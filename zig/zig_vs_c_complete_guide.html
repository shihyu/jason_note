<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zig vs C 語言完整比較指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zig-vs-c-語言完整比較指南"><a class="header" href="#zig-vs-c-語言完整比較指南">Zig vs C 語言完整比較指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#%E7%B0%A1%E4%BB%8B">簡介</a></li>
<li><a href="#%E8%AA%9E%E8%A8%80%E6%A6%82%E8%BF%B0">語言概述</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E6%AF%94%E8%BC%83">核心特性比較</a></li>
<li><a href="#%E8%AA%9E%E6%B3%95%E6%AF%94%E8%BC%83">語法比較</a></li>
<li><a href="#zig-%E5%84%AA%E5%8B%A2%E8%A9%B3%E8%A7%A3">Zig 優勢詳解</a></li>
<li><a href="#%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86">記憶體管理</a></li>
<li><a href="#%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86">錯誤處理</a></li>
<li><a href="#%E7%B7%A8%E8%AD%AF%E6%99%82%E7%89%B9%E6%80%A7">編譯時特性</a></li>
<li><a href="#%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB">標準函式庫</a></li>
<li><a href="#%E5%AF%A6%E9%9A%9B%E7%AF%84%E4%BE%8B%E5%B0%8D%E6%AF%94">實際範例對比</a></li>
<li><a href="#%E5%AF%A6%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%AF%84%E4%BE%8B">實用程式範例</a></li>
<li><a href="#ubuntu-%E5%AE%89%E8%A3%9D%E6%8C%87%E5%8D%97">Ubuntu 安裝指南</a></li>
<li><a href="#hello-world-%E5%AE%8C%E6%95%B4%E7%AF%84%E4%BE%8B">Hello World 完整範例</a></li>
<li><a href="#%E5%84%AA%E7%BC%BA%E9%BB%9E%E7%B8%BD%E7%B5%90">優缺點總結</a></li>
<li><a href="#%E9%81%B7%E7%A7%BB%E5%BB%BA%E8%AD%B0">遷移建議</a></li>
</ol>
<hr />
<h2 id="簡介"><a class="header" href="#簡介">簡介</a></h2>
<p><strong>Zig</strong> 是一個現代的系統程式語言,目標是成為「更好的 C」。它保留了 C 的簡潔性和性能，同時增加了現代語言的安全性和便利性。</p>
<p><strong>設計理念：</strong></p>
<ul>
<li>沒有隱藏的控制流</li>
<li>沒有隱藏的記憶體分配</li>
<li>沒有預處理器</li>
<li>編譯時程式設計能力強大</li>
</ul>
<hr />
<h2 id="語言概述"><a class="header" href="#語言概述">語言概述</a></h2>
<h3 id="c-語言"><a class="header" href="#c-語言">C 語言</a></h3>
<ul>
<li><strong>發布年份</strong>: 1972年</li>
<li><strong>設計者</strong>: Dennis Ritchie</li>
<li><strong>設計理念</strong>: 系統程式設計、可移植性、效率</li>
<li><strong>主要用途</strong>: 作業系統、嵌入式系統、系統軟體</li>
</ul>
<h3 id="zig-語言"><a class="header" href="#zig-語言">Zig 語言</a></h3>
<ul>
<li><strong>發布年份</strong>: 2016年</li>
<li><strong>設計者</strong>: Andrew Kelley</li>
<li><strong>設計理念</strong>: 取代 C 的現代系統程式語言，更安全、更簡單</li>
<li><strong>主要用途</strong>: 系統程式設計、嵌入式開發、WebAssembly</li>
</ul>
<hr />
<h2 id="核心特性比較"><a class="header" href="#核心特性比較">核心特性比較</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>C 語言</th><th>Zig 語言</th></tr></thead><tbody>
<tr><td><strong>記憶體安全</strong></td><td>手動管理，容易出錯</td><td>手動管理但有更多安全檢查</td></tr>
<tr><td><strong>空指標</strong></td><td>允許，常見錯誤來源</td><td>可選類型（Optional Types）</td></tr>
<tr><td><strong>錯誤處理</strong></td><td>返回錯誤碼或 errno</td><td>內建錯誤處理機制 (!)</td></tr>
<tr><td><strong>預處理器</strong></td><td>有（#define, #include）</td><td>無，使用編譯時執行</td></tr>
<tr><td><strong>標頭檔</strong></td><td>需要 .h 檔案</td><td>不需要標頭檔</td></tr>
<tr><td><strong>泛型程式設計</strong></td><td>透過巨集或 void*</td><td>編譯時泛型 (comptime)</td></tr>
<tr><td><strong>編譯時執行</strong></td><td>有限（巨集）</td><td>完整的編譯時執行</td></tr>
<tr><td><strong>未定義行為</strong></td><td>大量存在</td><td>明確定義所有行為</td></tr>
<tr><td><strong>交叉編譯</strong></td><td>需要工具鏈</td><td>內建交叉編譯支援</td></tr>
<tr><td><strong>C 相容性</strong></td><td>N/A</td><td>可直接導入 C 程式碼</td></tr>
<tr><td><strong>包管理</strong></td><td>無官方工具</td><td>內建包管理</td></tr>
<tr><td><strong>測試框架</strong></td><td>需要外部工具</td><td>內建測試</td></tr>
<tr><td><strong>整數溢位</strong></td><td>未定義</td><td>可檢測或環繞</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="語法比較"><a class="header" href="#語法比較">語法比較</a></h2>
<h3 id="1-基本程式結構"><a class="header" href="#1-基本程式結構">1. 基本程式結構</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const std = @import("std");

pub fn main() void {
    std.debug.print("Hello, World!\n", .{});
}
</code></pre>
<h3 id="2-變數宣告"><a class="header" href="#2-變數宣告">2. 變數宣告</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">int x = 10;           // 可變變數
const int y = 20;     // 常數
int *ptr = &amp;x;        // 指標
float pi = 3.14;
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">var x: i32 = 10;      // 可變變數
const y: i32 = 20;    // 編譯時常數
var ptr: *i32 = &amp;x;   // 指標
const pi: f32 = 3.14; // 浮點數
</code></pre>
<h3 id="3-資料型別"><a class="header" href="#3-資料型別">3. 資料型別</a></h3>
<div class="table-wrapper"><table><thead><tr><th>C 型別</th><th>Zig 型別</th><th>說明</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>u8</code> 或 <code>i8</code></td><td>8位元整數</td></tr>
<tr><td><code>short</code></td><td><code>i16</code></td><td>16位元有號整數</td></tr>
<tr><td><code>int</code></td><td><code>c_int</code> 或 <code>i32</code></td><td>32位元有號整數</td></tr>
<tr><td><code>long</code></td><td><code>c_long</code> 或 <code>i64</code></td><td>64位元有號整數</td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td><td>32位元浮點數</td></tr>
<tr><td><code>double</code></td><td><code>f64</code></td><td>64位元浮點數</td></tr>
<tr><td><code>void*</code></td><td><code>*anyopaque</code></td><td>不透明指標</td></tr>
<tr><td><code>NULL</code></td><td><code>null</code></td><td>空值</td></tr>
</tbody></table>
</div>
<h3 id="4-函式定義"><a class="header" href="#4-函式定義">4. 函式定義</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void print_hello() {
    printf("Hello\n");
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn swap(a: *i32, b: *i32) void {
    const temp = a.*;
    a.* = b.*;
    b.* = temp;
}

fn printHello() void {
    std.debug.print("Hello\n", .{});
}
</code></pre>
<h3 id="5-結構體"><a class="header" href="#5-結構體">5. 結構體</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">struct Point {
    int x;
    int y;
};

struct Point p = {10, 20};
p.x = 30;

typedef struct {
    char name[50];
    int age;
} Person;
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const Point = struct {
    x: i32,
    y: i32,
};

var p = Point{ .x = 10, .y = 20 };
p.x = 30;

const Person = struct {
    name: [50]u8,
    age: i32,

    // 可以包含方法
    pub fn greet(self: Person) void {
        std.debug.print("Hello, {s}\n", .{self.name});
    }
};
</code></pre>
<h3 id="6-陣列"><a class="header" href="#6-陣列">6. 陣列</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">int arr[5] = {1, 2, 3, 4, 5};
int len = sizeof(arr) / sizeof(arr[0]);  // 容易出錯
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const arr = [_]i32{1, 2, 3, 4, 5};
const len = arr.len;  // 內建長度屬性
</code></pre>
<h3 id="7-指標"><a class="header" href="#7-指標">7. 指標</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">int x = 10;
int *ptr = &amp;x;
*ptr = 20;

int *null_ptr = NULL;
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">var x: i32 = 10;
var ptr: *i32 = &amp;x;
ptr.* = 20;

var null_ptr: ?*i32 = null;  // 可選指標
</code></pre>
<h3 id="8-條件判斷"><a class="header" href="#8-條件判斷">8. 條件判斷</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">if (x &gt; 0) {
    printf("Positive\n");
} else if (x &lt; 0) {
    printf("Negative\n");
} else {
    printf("Zero\n");
}

// 三元運算子
int result = (x &gt; 0) ? 1 : -1;

// Switch
switch (x) {
    case 1:
        printf("One\n");
        break;  // 需要 break
    case 2:
        printf("Two\n");
        break;
    default:
        printf("Other\n");
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">if (x &gt; 0) {
    std.debug.print("Positive\n", .{});
} else if (x &lt; 0) {
    std.debug.print("Negative\n", .{});
} else {
    std.debug.print("Zero\n", .{});
}

// if 表達式
const result = if (x &gt; 0) 1 else -1;

// Switch
switch (x) {
    1 =&gt; std.debug.print("One\n", .{}),
    2 =&gt; std.debug.print("Two\n", .{}),
    else =&gt; std.debug.print("Other\n", .{}),
}  // 不需要 break，不會 fall-through
</code></pre>
<h3 id="9-迴圈"><a class="header" href="#9-迴圈">9. 迴圈</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">// for 迴圈
for (int i = 0; i &lt; 10; i++) {
    printf("%d ", i);
}

// while 迴圈
int i = 0;
while (i &lt; 10) {
    printf("%d ", i);
    i++;
}

// do-while 迴圈
do {
    printf("%d ", i);
    i++;
} while (i &lt; 10);
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">// for 迴圈（範圍）
for (0..10) |i| {
    std.debug.print("{} ", .{i});
}

// for 迴圈（陣列）
const array = [_]i32{1, 2, 3, 4, 5};
for (array) |item| {
    std.debug.print("{} ", .{item});
}

// while 迴圈
var i: usize = 0;
while (i &lt; 10) : (i += 1) {
    std.debug.print("{} ", .{i});
}
</code></pre>
<h3 id="10-列舉"><a class="header" href="#10-列舉">10. 列舉</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">enum Color {
    RED,
    GREEN,
    BLUE
};

enum Color c = RED;
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const Color = enum {
    red,
    green,
    blue,
};

var c = Color.red;

// 標籤聯合（Tagged Union）
const Value = union(enum) {
    int: i32,
    float: f32,
    string: []const u8,
};
</code></pre>
<hr />
<h2 id="zig-優勢詳解"><a class="header" href="#zig-優勢詳解">Zig 優勢詳解</a></h2>
<h3 id="1-沒有隱藏的記憶體分配"><a class="header" href="#1-沒有隱藏的記憶體分配">1. 沒有隱藏的記憶體分配</a></h3>
<p><strong>C/C++ 的隱藏分配：</strong></p>
<pre><code class="language-cpp">// C++ - 隱藏的分配
std::vector&lt;int&gt; vec;
vec.push_back(42);  // 內部自動 malloc，你看不到

std::string str = "Hello";
str += " World";  // 又一次隱藏的分配
</code></pre>
<p><strong>Zig 的顯式分配：</strong></p>
<pre><code class="language-zig">// Zig - 所有分配都需要明確的 allocator
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // 必須明確傳入 allocator
    var list = std.ArrayList(i32).init(allocator);
    defer list.deinit();
    try list.append(42);  // 你知道這裡可能分配記憶體

    // 字串處理也要明確
    const text = try std.fmt.allocPrint(allocator, "Hello {s}", .{"World"});
    defer allocator.free(text);
}
</code></pre>
<p><strong>好處：</strong></p>
<ul>
<li>記憶體使用清晰可見</li>
<li>可以選擇不同的分配策略（arena、pool、fixed buffer）</li>
<li>容易追蹤和調試記憶體問題</li>
<li>適合嵌入式和即時系統</li>
</ul>
<h3 id="2-編譯時程式設計-comptime"><a class="header" href="#2-編譯時程式設計-comptime">2. 編譯時程式設計 (comptime)</a></h3>
<p><strong>C 語言的限制：</strong></p>
<pre><code class="language-c">// C - 需要用宏
#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))  // 可能多次求值

// 或使用內聯函數，但無法編譯時計算
</code></pre>
<p><strong>Zig 的 comptime：</strong></p>
<pre><code class="language-zig">// 編譯時計算
fn fibonacci(comptime n: u32) u32 {
    if (n &lt;= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

const fib_10 = fibonacci(10);  // 在編譯時計算出 55

// 編譯時泛型
fn max(comptime T: type, a: T, b: T) T {
    return if (a &gt; b) a else b;
}

const result1 = max(i32, 10, 20);
const result2 = max(f64, 3.14, 2.71);
</code></pre>
<h3 id="3-內建錯誤處理"><a class="header" href="#3-內建錯誤處理">3. 內建錯誤處理</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">// C - 多種錯誤處理方式，不統一
FILE* file = fopen("test.txt", "r");
if (file == NULL) {
    perror("Error opening file");
    return -1;
}

// 或使用 errno
int result = some_function();
if (result &lt; 0) {
    fprintf(stderr, "Error: %s\n", strerror(errno));
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">// Zig - 統一的錯誤處理
const std = @import("std");

const MyError = error{
    FileNotFound,
    PermissionDenied,
};

fn openFile(path: []const u8) !std.fs.File {
    return std.fs.cwd().openFile(path, .{}) catch |err| {
        return err;
    };
}

pub fn main() !void {
    const file = try openFile("test.txt");
    defer file.close();

    // 或使用 catch 自訂處理
    const file2 = openFile("test.txt") catch |err| {
        std.debug.print("Error: {}\n", .{err});
        return err;
    };
}
</code></pre>
<h3 id="4-defer-和-errdefer"><a class="header" href="#4-defer-和-errdefer">4. defer 和 errdefer</a></h3>
<p><strong>C 語言的清理問題：</strong></p>
<pre><code class="language-c">// C - 容易遺漏清理
void process() {
    FILE* f1 = fopen("file1.txt", "r");
    if (!f1) return;

    char* buffer = malloc(1024);
    if (!buffer) {
        fclose(f1);  // 容易忘記
        return;
    }

    FILE* f2 = fopen("file2.txt", "r");
    if (!f2) {
        free(buffer);  // 要記得清理
        fclose(f1);    // 要記得關閉
        return;
    }

    // ... 處理

    fclose(f2);
    free(buffer);
    fclose(f1);
}
</code></pre>
<p><strong>Zig 的 defer：</strong></p>
<pre><code class="language-zig">// Zig - 自動清理，不會遺漏
fn process() !void {
    const f1 = try std.fs.cwd().openFile("file1.txt", .{});
    defer f1.close();  // 保證執行

    const buffer = try allocator.alloc(u8, 1024);
    defer allocator.free(buffer);

    const f2 = try std.fs.cwd().openFile("file2.txt", .{});
    defer f2.close();

    // ... 處理

    // defer 自動按相反順序清理：f2 -&gt; buffer -&gt; f1
}
</code></pre>
<p><strong>defer 執行規則：</strong></p>
<ul>
<li>在當前作用域結束時執行</li>
<li>執行順序：後進先出 (LIFO)</li>
<li>即使有 error return 也會執行</li>
</ul>
<p><strong>errdefer：</strong></p>
<pre><code class="language-zig">fn createResources() !void {
    const r1 = try allocateResource1();
    errdefer freeResource1(r1);  // 只在錯誤時執行

    const r2 = try allocateResource2();  // 如果這裡失敗
    errdefer freeResource2(r2);

    // 如果成功，errdefer 不執行
    // 如果失敗，自動清理已分配的資源
}
</code></pre>
<h3 id="5-可選類型-optional-types"><a class="header" href="#5-可選類型-optional-types">5. 可選類型 (Optional Types)</a></h3>
<p><strong>C 語言的空指標問題：</strong></p>
<pre><code class="language-c">// C - 空指標容易造成崩潰
int* find_value(int key) {
    // ...
    return NULL;  // 可能返回 NULL
}

int* result = find_value(42);
*result = 10;  // 💥 如果 result 是 NULL，程式崩潰
</code></pre>
<p><strong>Zig 的可選類型：</strong></p>
<pre><code class="language-zig">// Zig - 強制檢查 null
fn findValue(key: i32) ?*i32 {
    // ...
    return null;
}

const result = findValue(42);
if (result) |value| {
    value.* = 10;  // 安全，已經解包
} else {
    std.debug.print("Not found\n", .{});
}

// 或使用 orelse
const value = findValue(42) orelse return error.NotFound;
</code></pre>
<h3 id="6-更精確的整數類型"><a class="header" href="#6-更精確的整數類型">6. 更精確的整數類型</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">// C - 平台相依
int x;        // 可能是 16/32/64 位元
long y;       // 可能是 32/64 位元
size_t z;     // 平台相依

// 需要 stdint.h
int32_t a;
uint64_t b;
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">// Zig - 明確且一致
const x: i32 = 0;   // 32 位元有符號整數
const y: u64 = 0;   // 64 位元無符號整數
const z: i8 = 0;    // 8 位元有符號整數
const w: u1 = 0;    // 1 位元（bool）

// 甚至支援任意位元寬度
const a: i7 = 0;    // 7 位元整數
const b: u24 = 0;   // 24 位元整數
</code></pre>
<h3 id="7-內建測試"><a class="header" href="#7-內建測試">7. 內建測試</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">// C - 需要外部測試框架（如 CUnit, Check）
#include &lt;assert.h&gt;

void test_add() {
    assert(add(2, 3) == 5);
}

int main() {
    test_add();
    return 0;
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">// Zig - 內建測試
const std = @import("std");

fn add(a: i32, b: i32) i32 {
    return a + b;
}

test "basic addition" {
    try std.testing.expect(add(2, 3) == 5);
    try std.testing.expectEqual(@as(i32, 10), add(7, 3));
}

test "negative numbers" {
    try std.testing.expect(add(-5, 3) == -2);
}

// 執行: zig test myfile.zig
</code></pre>
<h3 id="8-c-互操作性"><a class="header" href="#8-c-互操作性">8. C 互操作性</a></h3>
<p><strong>Zig 可以直接使用 C 程式庫：</strong></p>
<pre><code class="language-zig">// 直接引入 C 標頭檔
const c = @cImport({
    @cInclude("stdio.h");
    @cInclude("stdlib.h");
});

pub fn main() void {
    c.printf("Hello from C!\n");

    const ptr = c.malloc(100);
    defer c.free(ptr);
}

// 也可以匯出給 C 使用
export fn zigAdd(a: i32, b: i32) i32 {
    return a + b;
}
</code></pre>
<h3 id="9-跨平台編譯"><a class="header" href="#9-跨平台編譯">9. 跨平台編譯</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-bash"># C - 需要安裝不同平台的工具鏈
sudo apt install gcc-mingw-w64  # Windows
sudo apt install gcc-arm-linux-gnueabihf  # ARM
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-bash"># Zig - 內建跨平台編譯
zig build-exe main.zig -target x86_64-windows
zig build-exe main.zig -target x86_64-linux
zig build-exe main.zig -target aarch64-macos
zig build-exe main.zig -target wasm32-freestanding

# 支援超過 30 個目標平台
</code></pre>
<h3 id="10-更安全的預設行為"><a class="header" href="#10-更安全的預設行為">10. 更安全的預設行為</a></h3>
<div class="table-wrapper"><table><thead><tr><th>行為</th><th>C 語言</th><th>Zig 語言</th></tr></thead><tbody>
<tr><td>整數溢位</td><td>未定義行為</td><td>Debug: panic, Release: 可選</td></tr>
<tr><td>陣列越界</td><td>未定義行為</td><td>Debug: panic, Release: 可選</td></tr>
<tr><td>空指標解引用</td><td>未定義行為</td><td>編譯錯誤（可選類型）</td></tr>
<tr><td>未初始化變數</td><td>未定義行為</td><td>編譯錯誤</td></tr>
<tr><td>Switch 未處理</td><td>警告</td><td>編譯錯誤（需要 else）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="記憶體管理"><a class="header" href="#記憶體管理">記憶體管理</a></h2>
<h3 id="c-語言的記憶體管理"><a class="header" href="#c-語言的記憶體管理">C 語言的記憶體管理</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void example() {
    // 分配
    int* arr = (int*)malloc(10 * sizeof(int));
    if (!arr) {
        // 處理錯誤
        return;
    }

    // 使用
    for (int i = 0; i &lt; 10; i++) {
        arr[i] = i;
    }

    // 重新分配
    int* new_arr = (int*)realloc(arr, 20 * sizeof(int));
    if (!new_arr) {
        free(arr);
        return;
    }
    arr = new_arr;

    // 釋放
    free(arr);
}
</code></pre>
<h3 id="zig-的記憶體管理"><a class="header" href="#zig-的記憶體管理">Zig 的記憶體管理</a></h3>
<pre><code class="language-zig">const std = @import("std");

fn example() !void {
    // 建立 allocator
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // 分配
    const arr = try allocator.alloc(i32, 10);
    defer allocator.free(arr);

    // 使用
    for (arr, 0..) |*item, i| {
        item.* = @intCast(i);
    }

    // 重新分配
    const new_arr = try allocator.realloc(arr, 20);
    defer allocator.free(new_arr);
}
</code></pre>
<h3 id="動態記憶體分配比較"><a class="header" href="#動態記憶體分配比較">動態記憶體分配比較</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int *arr = (int*)malloc(10 * sizeof(int));
if (arr == NULL) {
    // 處理錯誤
}

// 使用陣列
arr[0] = 42;

free(arr);  // 必須記得釋放
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const arr = try allocator.alloc(i32, 10);
    defer allocator.free(arr);  // defer 確保釋放

    arr[0] = 42;
}
</code></pre>
<h3 id="zig-的不同-allocator"><a class="header" href="#zig-的不同-allocator">Zig 的不同 Allocator</a></h3>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    // 1. GeneralPurposeAllocator - 通用分配器，有安全檢查
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();

    // 2. ArenaAllocator - 一次性釋放所有
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();  // 一次釋放全部
    const arena_allocator = arena.allocator();

    const item1 = try arena_allocator.create(i32);
    const item2 = try arena_allocator.create(i32);
    // 不需要逐個 free

    // 3. FixedBufferAllocator - 固定緩衝區（嵌入式）
    var buffer: [1024]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&amp;buffer);
    const fba_allocator = fba.allocator();

    // 4. page_allocator - 直接從 OS
    const page_mem = try std.heap.page_allocator.alloc(u8, 4096);
    defer std.heap.page_allocator.free(page_mem);
}
</code></pre>
<hr />
<h2 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h2>
<h3 id="c-語言的錯誤處理"><a class="header" href="#c-語言的錯誤處理">C 語言的錯誤處理</a></h3>
<pre><code class="language-c">FILE *file = fopen("test.txt", "r");
if (file == NULL) {
    perror("Error opening file");
    return -1;
}

// 或使用 errno
if (some_function() == -1) {
    if (errno == ENOENT) {
        printf("File not found\n");
    }
}
</code></pre>
<h3 id="zig-語言的錯誤處理"><a class="header" href="#zig-語言的錯誤處理">Zig 語言的錯誤處理</a></h3>
<pre><code class="language-zig">const file = std.fs.cwd().openFile("test.txt", .{}) catch |err| {
    std.debug.print("Error opening file: {}\n", .{err});
    return err;
};
defer file.close();

// 錯誤聯合類型
fn divide(a: f32, b: f32) !f32 {
    if (b == 0) {
        return error.DivisionByZero;
    }
    return a / b;
}

// 使用 try
const result = try divide(10, 2);
</code></pre>
<h3 id="完整的錯誤處理範例"><a class="header" href="#完整的錯誤處理範例">完整的錯誤處理範例</a></h3>
<pre><code class="language-zig">const std = @import("std");

// 定義錯誤集合
const FileError = error{
    FileNotFound,
    PermissionDenied,
    OutOfMemory,
};

// 函數可能返回錯誤
fn readConfig(path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const size = (try file.stat()).size;
    const allocator = std.heap.page_allocator;

    const content = try allocator.alloc(u8, size);
    errdefer allocator.free(content);  // 錯誤時釋放

    _ = try file.readAll(content);
    return content;
}

pub fn main() !void {
    // 方法 1: 使用 try（錯誤會向上傳遞）
    const config = try readConfig("config.txt");
    defer std.heap.page_allocator.free(config);

    // 方法 2: 使用 catch（自訂錯誤處理）
    const config2 = readConfig("config.txt") catch |err| {
        std.debug.print("Failed to read config: {}\n", .{err});
        return;
    };
    defer std.heap.page_allocator.free(config2);

    // 方法 3: 使用 if
    if (readConfig("config.txt")) |config3| {
        defer std.heap.page_allocator.free(config3);
        std.debug.print("Success!\n", .{});
    } else |err| {
        std.debug.print("Error: {}\n", .{err});
    }
}
</code></pre>
<hr />
<h2 id="編譯時特性"><a class="header" href="#編譯時特性">編譯時特性</a></h2>
<h3 id="c-語言的預處理器"><a class="header" href="#c-語言的預處理器">C 語言的預處理器</a></h3>
<pre><code class="language-c">#define MAX_SIZE 100
#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))

#ifdef DEBUG
    #define LOG(x) printf("%s\n", x)
#else
    #define LOG(x)
#endif
</code></pre>
<h3 id="zig-語言的編譯時執行"><a class="header" href="#zig-語言的編譯時執行">Zig 語言的編譯時執行</a></h3>
<pre><code class="language-zig">const max_size = 100;  // 編譯時常數

fn min(comptime T: type, a: T, b: T) T {
    return if (a &lt; b) a else b;
}

// 編譯時執行
const fibonacci = comptime blk: {
    var fib: [10]i32 = undefined;
    fib[0] = 0;
    fib[1] = 1;
    var i: usize = 2;
    while (i &lt; 10) : (i += 1) {
        fib[i] = fib[i-1] + fib[i-2];
    }
    break :blk fib;
};

// 條件編譯
const debug = @import("builtin").mode == .Debug;
fn log(msg: []const u8) void {
    if (debug) {
        std.debug.print("{s}\n", .{msg});
    }
}
</code></pre>
<hr />
<h2 id="標準函式庫"><a class="header" href="#標準函式庫">標準函式庫</a></h2>
<h3 id="字串操作"><a class="header" href="#字串操作">字串操作</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">#include &lt;string.h&gt;

char str1[100] = "Hello";
char str2[] = " World";

strcat(str1, str2);        // 串接
int len = strlen(str1);     // 長度
int cmp = strcmp(str1, str2); // 比較
char *copy = strcpy(dest, src); // 複製
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const std = @import("std");

var buffer: [100]u8 = undefined;
const str1 = "Hello";
const str2 = " World";

// 使用 fmt 格式化
const result = try std.fmt.bufPrint(&amp;buffer, "{s}{s}", .{str1, str2});

// 長度
const len = str1.len;

// 比較
const equal = std.mem.eql(u8, str1, str2);

// 複製
std.mem.copy(u8, &amp;buffer, str1);
</code></pre>
<hr />
<h2 id="實際範例對比"><a class="header" href="#實際範例對比">實際範例對比</a></h2>
<h3 id="範例-1陣列操作"><a class="header" href="#範例-1陣列操作">範例 1：陣列操作</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void print_array(int arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int sum_array(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i &lt; size; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    print_array(numbers, size);
    printf("Sum: %d\n", sum_array(numbers, size));

    return 0;
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const std = @import("std");

fn printArray(arr: []const i32) void {
    for (arr) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
}

fn sumArray(arr: []const i32) i32 {
    var sum: i32 = 0;
    for (arr) |item| {
        sum += item;
    }
    return sum;
}

pub fn main() void {
    const numbers = [_]i32{ 1, 2, 3, 4, 5 };

    printArray(&amp;numbers);
    std.debug.print("Sum: {}\n", .{sumArray(&amp;numbers)});
}
</code></pre>
<h3 id="範例-2鏈結串列"><a class="header" href="#範例-2鏈結串列">範例 2：鏈結串列</a></h3>
<p><strong>C 語言：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

struct Node* create_node(int data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    if (node == NULL) return NULL;
    node-&gt;data = data;
    node-&gt;next = NULL;
    return node;
}

void free_list(struct Node* head) {
    struct Node* temp;
    while (head != NULL) {
        temp = head;
        head = head-&gt;next;
        free(temp);
    }
}
</code></pre>
<p><strong>Zig 語言：</strong></p>
<pre><code class="language-zig">const std = @import("std");

const Node = struct {
    data: i32,
    next: ?*Node,

    fn create(allocator: std.mem.Allocator, data: i32) !*Node {
        const node = try allocator.create(Node);
        node.* = Node{
            .data = data,
            .next = null,
        };
        return node;
    }

    fn destroyList(self: *Node, allocator: std.mem.Allocator) void {
        var current: ?*Node = self;
        while (current) |node| {
            const next = node.next;
            allocator.destroy(node);
            current = next;
        }
    }
};
</code></pre>
<hr />
<h2 id="實用程式範例"><a class="header" href="#實用程式範例">實用程式範例</a></h2>
<h3 id="檔案讀寫"><a class="header" href="#檔案讀寫">檔案讀寫</a></h3>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // 寫入檔案
    const file = try std.fs.cwd().createFile("test.txt", .{});
    defer file.close();

    try file.writeAll("Hello from Zig!\n");

    // 讀取檔案
    const content = try std.fs.cwd().readFileAlloc(
        allocator,
        "test.txt",
        1024 * 1024,  // 最大 1MB
    );
    defer allocator.free(content);

    std.debug.print("File content: {s}\n", .{content});
}
</code></pre>
<h3 id="http-請求使用標準庫"><a class="header" href="#http-請求使用標準庫">HTTP 請求（使用標準庫）</a></h3>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client = std.http.Client{ .allocator = allocator };
    defer client.deinit();

    const uri = try std.Uri.parse("http://example.com");

    var buf: [4096]u8 = undefined;
    var req = try client.open(.GET, uri, .{ .server_header_buffer = &amp;buf });
    defer req.deinit();

    try req.send();
    try req.wait();

    const body = try req.reader().readAllAlloc(allocator, 1024 * 1024);
    defer allocator.free(body);

    std.debug.print("Response: {s}\n", .{body});
}
</code></pre>
<hr />
<h2 id="ubuntu-安裝指南"><a class="header" href="#ubuntu-安裝指南">Ubuntu 安裝指南</a></h2>
<h3 id="方法-1-下載官方二進位檔推薦"><a class="header" href="#方法-1-下載官方二進位檔推薦">方法 1: 下載官方二進位檔（推薦）</a></h3>
<pre><code class="language-bash"># 1. 下載最新版本
cd ~/Downloads
wget https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz

# 2. 解壓縮
tar -xf zig-linux-x86_64-0.13.0.tar.xz

# 3. 移動到系統目錄
sudo mv zig-linux-x86_64-0.13.0 /opt/zig

# 4. 建立符號連結
sudo ln -s /opt/zig/zig /usr/local/bin/zig

# 5. 驗證安裝
zig version
</code></pre>
<h3 id="方法-2-使用-snap"><a class="header" href="#方法-2-使用-snap">方法 2: 使用 Snap</a></h3>
<pre><code class="language-bash"># 安裝
sudo snap install zig --classic --beta

# 驗證
zig version
</code></pre>
<h3 id="方法-3-使用-aptubuntu-2204"><a class="header" href="#方法-3-使用-aptubuntu-2204">方法 3: 使用 APT（Ubuntu 22.04+）</a></h3>
<pre><code class="language-bash"># 更新套件列表
sudo apt update

# 安裝 Zig
sudo apt install zig
</code></pre>
<h3 id="方法-4-從原始碼編譯"><a class="header" href="#方法-4-從原始碼編譯">方法 4: 從原始碼編譯</a></h3>
<pre><code class="language-bash"># 安裝依賴
sudo apt update
sudo apt install -y git cmake llvm-14 clang-14 lld-14

# 下載原始碼
git clone https://github.com/ziglang/zig.git
cd zig

# 編譯
mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make install

# 驗證
zig version
</code></pre>
<h3 id="基本使用指令"><a class="header" href="#基本使用指令">基本使用指令</a></h3>
<pre><code class="language-bash"># 建立專案目錄
mkdir hello-zig
cd hello-zig

# 建立主程式檔案
cat &gt; main.zig &lt;&lt; 'EOF'
const std = @import("std");

pub fn main() void {
    std.debug.print("Hello, Zig!\n", .{});
}
EOF

# 直接執行（開發時使用）
zig run main.zig

# 編譯成執行檔
zig build-exe main.zig

# 執行編譯後的程式
./main
</code></pre>
<h3 id="編譯選項詳解"><a class="header" href="#編譯選項詳解">編譯選項詳解</a></h3>
<pre><code class="language-bash"># 基本編譯
zig build-exe main.zig

# 指定輸出檔名
zig build-exe main.zig -femit-bin=myapp

# 優化等級
zig build-exe main.zig -O ReleaseFast    # 最佳效能
zig build-exe main.zig -O ReleaseSafe    # 平衡效能與安全
zig build-exe main.zig -O ReleaseSmall   # 最小體積
zig build-exe main.zig -O Debug          # 偵錯模式（預設）

# 靜態連結（預設）
zig build-exe main.zig

# 動態連結
zig build-exe main.zig -dynamic

# 交叉編譯（編譯給其他平台）
zig build-exe main.zig -target x86_64-windows
zig build-exe main.zig -target aarch64-linux
zig build-exe main.zig -target wasm32-wasi
</code></pre>
<h3 id="使用-zig-專案建構系統"><a class="header" href="#使用-zig-專案建構系統">使用 Zig 專案建構系統</a></h3>
<pre><code class="language-bash"># 建立新專案
mkdir myproject
cd myproject

# 初始化 Zig 專案
zig init-exe  # 建立執行檔專案
# 或
zig init-lib  # 建立函式庫專案

# 專案結構
tree
# .
# ├── build.zig       # 建構腳本
# ├── src
# │   └── main.zig    # 主程式
# └── zig-cache/      # 快取目錄（自動生成）
</code></pre>
<h3 id="整合-c-程式碼"><a class="header" href="#整合-c-程式碼">整合 C 程式碼</a></h3>
<pre><code class="language-zig">// math_wrapper.zig
const c = @cImport({
    @cInclude("math.h");
    @cInclude("stdio.h");
});

pub fn main() void {
    const result = c.sqrt(16.0);
    _ = c.printf("Square root of 16 is: %f\n", result);
}
</code></pre>
<p>編譯：</p>
<pre><code class="language-bash"># 編譯包含 C 程式碼的 Zig 程式
zig build-exe math_wrapper.zig -lc
./math_wrapper
</code></pre>
<h3 id="開發環境設定"><a class="header" href="#開發環境設定">開發環境設定</a></h3>
<h4 id="vscode-設定"><a class="header" href="#vscode-設定">VSCode 設定</a></h4>
<pre><code class="language-bash"># 安裝 VSCode
sudo snap install code --classic

# 安裝 Zig 擴充套件
code --install-extension ziglang.vscode-zig

# 建立 VSCode 設定檔 (.vscode/settings.json)
mkdir .vscode
cat &gt; .vscode/settings.json &lt;&lt; 'EOF'
{
    "zig.buildOnSave": true,
    "zig.formattingProvider": "zls",
    "zig.zls.enableAutofix": true
}
EOF
</code></pre>
<h4 id="安裝-zls-zig-language-server"><a class="header" href="#安裝-zls-zig-language-server">安裝 ZLS (Zig Language Server)</a></h4>
<pre><code class="language-bash"># 方法 1: 使用預編譯版本
wget https://github.com/zigtools/zls/releases/download/0.11.0/zls-x86_64-linux.tar.gz
tar -xf zls-x86_64-linux.tar.gz
sudo mv zls /usr/local/bin/

# 方法 2: 從原始碼編譯
git clone https://github.com/zigtools/zls
cd zls
zig build -Doptimize=ReleaseSafe
sudo cp zig-out/bin/zls /usr/local/bin/
</code></pre>
<h3 id="常用開發指令"><a class="header" href="#常用開發指令">常用開發指令</a></h3>
<pre><code class="language-bash"># 格式化程式碼
zig fmt src/

# 產生文件
zig build-docs

# 執行內建測試
zig test src/main.zig

# 檢查程式碼
zig ast-check src/main.zig

# 顯示建構快取
zig build --verbose-cc

# 清理快取
rm -rf zig-cache zig-out

# 查看 Zig 內建函式
zig builtin

# 查看支援的目標平台
zig targets

# C 程式碼轉換為 Zig
zig translate-c helper.c &gt; helper.zig
</code></pre>
<h3 id="偵錯-zig-程式"><a class="header" href="#偵錯-zig-程式">偵錯 Zig 程式</a></h3>
<h4 id="使用-gdb"><a class="header" href="#使用-gdb">使用 GDB</a></h4>
<pre><code class="language-bash"># 編譯時加入偵錯資訊
zig build-exe main.zig -O Debug

# 使用 GDB 偵錯
gdb ./main

# GDB 指令
# (gdb) break main           # 設定中斷點
# (gdb) run                  # 執行程式
# (gdb) step                 # 單步執行
# (gdb) print variable_name  # 印出變數
# (gdb) backtrace           # 顯示呼叫堆疊
# (gdb) quit                # 離開
</code></pre>
<h4 id="使用-lldb"><a class="header" href="#使用-lldb">使用 LLDB</a></h4>
<pre><code class="language-bash"># 安裝 LLDB
sudo apt install lldb

# 偵錯
lldb ./main

# LLDB 指令
# (lldb) b main             # 設定中斷點
# (lldb) r                  # 執行
# (lldb) s                  # 單步執行
# (lldb) p variable_name    # 印出變數
# (lldb) bt                 # 顯示呼叫堆疊
</code></pre>
<h3 id="效能分析"><a class="header" href="#效能分析">效能分析</a></h3>
<pre><code class="language-bash"># 使用 Valgrind 檢查記憶體洩漏
sudo apt install valgrind
zig build-exe main.zig -O Debug
valgrind --leak-check=full ./main

# 使用 perf 進行效能分析
sudo apt install linux-tools-generic
zig build-exe main.zig -O ReleaseFast
perf record ./main
perf report
</code></pre>
<h3 id="常見問題解決"><a class="header" href="#常見問題解決">常見問題解決</a></h3>
<h4 id="1-版本相容性問題"><a class="header" href="#1-版本相容性問題">1. 版本相容性問題</a></h4>
<pre><code class="language-bash"># 檢查 Zig 版本
zig version

# 使用特定版本的 Zig
# 下載並管理多個版本，使用符號連結切換
ls -la /opt/zig-*
sudo ln -sf /opt/zig-0.11.0 /opt/zig
</code></pre>
<h4 id="2-編譯錯誤除錯"><a class="header" href="#2-編譯錯誤除錯">2. 編譯錯誤除錯</a></h4>
<pre><code class="language-bash"># 顯示詳細編譯資訊
zig build-exe main.zig --verbose-cc

# 顯示 AST（抽象語法樹）
zig ast-check --ast main.zig
</code></pre>
<h4 id="3-記憶體問題除錯"><a class="header" href="#3-記憶體問題除錯">3. 記憶體問題除錯</a></h4>
<pre><code class="language-zig">// 使用 GeneralPurposeAllocator 的除錯模式
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{
        .safety = true,  // 啟用安全檢查
    }){};
    defer {
        const leaked = gpa.deinit();
        if (leaked) {
            std.debug.print("Memory leak detected!\n", .{});
        }
    }

    const allocator = gpa.allocator();
    // 使用 allocator...
}
</code></pre>
<hr />
<h2 id="hello-world-完整範例"><a class="header" href="#hello-world-完整範例">Hello World 完整範例</a></h2>
<h3 id="建立專案"><a class="header" href="#建立專案">建立專案</a></h3>
<pre><code class="language-bash"># 建立專案目錄
mkdir zig-hello
cd zig-hello

# 建立 main.zig 檔案
touch main.zig
</code></pre>
<h3 id="hello-world-程式碼"><a class="header" href="#hello-world-程式碼">Hello World 程式碼</a></h3>
<p>建立 <code>main.zig</code> 檔案，內容如下：</p>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    // 使用標準輸出
    const stdout = std.io.getStdOut().writer();

    // 方法 1: 簡單輸出
    try stdout.print("Hello, World!\n", .{});

    // 方法 2: 格式化輸出
    const name = "Zig";
    const version = "0.13.0";
    try stdout.print("Hello from {s} {s}!\n", .{name, version});

    // 方法 3: Debug 輸出
    std.debug.print("Debug: Hello, World!\n", .{});
}
</code></pre>
<h3 id="編譯和執行"><a class="header" href="#編譯和執行">編譯和執行</a></h3>
<pre><code class="language-bash"># 編譯並執行（一步完成）
zig run main.zig

# 輸出：
# Hello, World!
# Hello from Zig 0.13.0!
# Debug: Hello, World!
</code></pre>
<h3 id="編譯為可執行檔"><a class="header" href="#編譯為可執行檔">編譯為可執行檔</a></h3>
<pre><code class="language-bash"># Debug 模式編譯
zig build-exe main.zig

# Release 模式編譯（優化）
zig build-exe main.zig -O ReleaseFast

# Release 模式（小體積）
zig build-exe main.zig -O ReleaseSmall

# Release 模式（安全檢查）
zig build-exe main.zig -O ReleaseSafe

# 執行
./main
</code></pre>
<h3 id="進階範例帶參數的-hello-world"><a class="header" href="#進階範例帶參數的-hello-world">進階範例：帶參數的 Hello World</a></h3>
<pre><code class="language-zig">const std = @import("std");

pub fn main() !void {
    // 取得 allocator
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // 取得命令列參數
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const stdout = std.io.getStdOut().writer();

    if (args.len &gt; 1) {
        try stdout.print("Hello, {s}!\n", .{args[1]});
    } else {
        try stdout.print("Hello, World!\n", .{});
    }
}
</code></pre>
<p>執行：</p>
<pre><code class="language-bash">zig build-exe hello.zig
./hello           # 輸出: Hello, World!
./hello Alice     # 輸出: Hello, Alice!
</code></pre>
<h3 id="使用-build-system"><a class="header" href="#使用-build-system">使用 Build System</a></h3>
<p>建立 <code>build.zig</code>：</p>
<pre><code class="language-zig">const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "hello",
        .root_source_file = b.path("main.zig"),
        .target = target,
        .optimize = optimize,
    });

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());

    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&amp;run_cmd.step);
}
</code></pre>
<p>使用 build system：</p>
<pre><code class="language-bash"># 編譯
zig build

# 編譯並執行
zig build run

# 可執行檔在 zig-out/bin/ 目錄
./zig-out/bin/hello
</code></pre>
<hr />
<h2 id="優缺點總結"><a class="header" href="#優缺點總結">優缺點總結</a></h2>
<h3 id="c-語言優點"><a class="header" href="#c-語言優點">C 語言優點</a></h3>
<ol>
<li>成熟穩定，生態系統龐大</li>
<li>幾乎所有平台都支援</li>
<li>大量的函式庫和工具</li>
<li>豐富的學習資源</li>
<li>簡單直接的語法</li>
</ol>
<h3 id="c-語言缺點"><a class="header" href="#c-語言缺點">C 語言缺點</a></h3>
<ol>
<li>大量未定義行為</li>
<li>手動記憶體管理容易出錯</li>
<li>缺乏現代語言特性</li>
<li>預處理器系統複雜且容易出錯</li>
<li>沒有內建的錯誤處理機制</li>
</ol>
<h3 id="zig-語言優點"><a class="header" href="#zig-語言優點">Zig 語言優點</a></h3>
<ol>
<li>沒有未定義行為</li>
<li>優秀的編譯時執行能力</li>
<li>內建錯誤處理機制</li>
<li>更好的型別安全</li>
<li>內建交叉編譯支援</li>
<li>可直接使用 C 程式碼</li>
<li>不需要標頭檔</li>
<li>defer 語句確保資源清理</li>
</ol>
<h3 id="zig-語言缺點"><a class="header" href="#zig-語言缺點">Zig 語言缺點</a></h3>
<ol>
<li>相對較新，生態系統較小</li>
<li>文件和學習資源較少</li>
<li>語言仍在發展中（尚未到 1.0 版）</li>
<li>IDE 支援不如 C 成熟</li>
<li>社群相對較小</li>
</ol>
<hr />
<h2 id="遷移建議"><a class="header" href="#遷移建議">遷移建議</a></h2>
<h3 id="從-c-遷移到-zig-的步驟"><a class="header" href="#從-c-遷移到-zig-的步驟">從 C 遷移到 Zig 的步驟</a></h3>
<ol>
<li><strong>漸進式遷移</strong>：Zig 可以直接導入和使用 C 程式碼，可以逐步遷移</li>
<li><strong>學習新概念</strong>：重點學習錯誤處理、可選類型、編譯時執行</li>
<li><strong>利用 Zig 的優勢</strong>：使用 defer、錯誤聯合、編譯時驗證</li>
<li><strong>保持 C 相容性</strong>：可以繼續使用現有的 C 函式庫</li>
</ol>
<h3 id="適合使用-zig-的場景"><a class="header" href="#適合使用-zig-的場景">適合使用 Zig 的場景</a></h3>
<ul>
<li>新的系統程式專案</li>
<li>需要更好的安全性保證</li>
<li>嵌入式系統開發</li>
<li>WebAssembly 目標</li>
<li>需要交叉編譯的專案</li>
</ul>
<h3 id="適合繼續使用-c-的場景"><a class="header" href="#適合繼續使用-c-的場景">適合繼續使用 C 的場景</a></h3>
<ul>
<li>維護現有的大型 C 程式碼庫</li>
<li>需要最廣泛的平台支援</li>
<li>團隊已經熟悉 C</li>
<li>依賴特定的 C 工具鏈</li>
</ul>
<hr />
<h2 id="總結對照表"><a class="header" href="#總結對照表">總結對照表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>項目</th><th>C 語言</th><th>Zig 語言</th></tr></thead><tbody>
<tr><td><strong>學習曲線</strong></td><td>低</td><td>中等</td></tr>
<tr><td><strong>記憶體安全</strong></td><td>手動，易出錯</td><td>更安全，有檢查</td></tr>
<tr><td><strong>編譯速度</strong></td><td>快</td><td>非常快</td></tr>
<tr><td><strong>執行效能</strong></td><td>極快</td><td>極快（相當）</td></tr>
<tr><td><strong>工具鏈</strong></td><td>成熟，多樣</td><td>現代，整合</td></tr>
<tr><td><strong>生態系統</strong></td><td>龐大</td><td>成長中</td></tr>
<tr><td><strong>適用場景</strong></td><td>系統、嵌入式</td><td>系統、嵌入式</td></tr>
<tr><td><strong>維護性</strong></td><td>中等</td><td>較好</td></tr>
</tbody></table>
</div>
<h2 id="何時選擇-zig"><a class="header" href="#何時選擇-zig">何時選擇 Zig？</a></h2>
<p>✅ <strong>選擇 Zig：</strong></p>
<ul>
<li>新專案，想要現代語言特性</li>
<li>需要更好的錯誤處理</li>
<li>重視編譯時安全檢查</li>
<li>需要跨平台編譯</li>
<li>想要更好的 C 互操作</li>
</ul>
<p>⚠️ <strong>選擇 C：</strong></p>
<ul>
<li>需要極度成熟的生態系統</li>
<li>團隊已熟悉 C</li>
<li>需要大量現成的函式庫</li>
<li>專案已經用 C 開發</li>
</ul>
<hr />
<h2 id="參考資源"><a class="header" href="#參考資源">參考資源</a></h2>
<ul>
<li><strong>官方網站</strong>: https://ziglang.org/</li>
<li><strong>文檔</strong>: https://ziglang.org/documentation/master/</li>
<li><strong>學習資源</strong>: https://ziglearn.org/</li>
<li><strong>標準庫文檔</strong>: https://ziglang.org/documentation/master/std/</li>
<li><strong>GitHub</strong>: https://github.com/ziglang/zig</li>
</ul>
<hr />
<p><strong>最後更新</strong>: 2025-10-19</p>
<hr />
<p><em>Zig 是一個現代化的系統程式語言，旨在解決 C 語言的許多問題，同時保持 C 的簡單性和效能。雖然 Zig 還在發展中，但它提供了許多吸引人的特性，特別是在安全性和開發體驗方面。對於新專案，Zig 是一個值得考慮的選擇；對於現有的 C 專案，可以考慮漸進式地引入 Zig。</em></p>
<p><em>選擇使用哪種語言應該基於專案需求、團隊經驗和長期維護考量。兩種語言都有其適用的場景，了解它們的差異有助於做出明智的技術決策。</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../zig/zig_compiler_size.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../web/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../zig/zig_compiler_size.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../web/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
