<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interview - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>這段程式碼定義了一個二元樹（Binary Tree）結構，並提供操作和管理樹中節點的功能。主要目的是構建一個完全二元樹，讓用戶可以輸入兩個節點的值來查找它們之間的路徑。下面是程式的詳細分解與說明：</p>
<hr />
<h3 id="1-變數-max_depth"><a class="header" href="#1-變數-max_depth">1. 變數 <code>MAX_DEPTH</code></a></h3>
<ul>
<li>設定樹的最大深度，這裡設定為 5，代表樹最多可以有 6 層（根節點為第 0 層）。這個設定影響樹的總節點數。</li>
</ul>
<hr />
<h3 id="2-node-類別"><a class="header" href="#2-node-類別">2. <code>Node</code> 類別</a></h3>
<ul>
<li>定義了樹中每個節點的結構，包括：
<ul>
<li><code>value</code>: 節點的值（例如 <code>A</code>, <code>B</code> 等）。</li>
<li><code>parent_index</code>: 父節點在節點列表中的索引，用於找出上一層節點。</li>
<li><code>is_right</code>: 是否是右子節點（0 表示左子節點，1 表示右子節點）。</li>
<li><code>depth</code>: 節點的深度（層數），根節點的深度為 0。</li>
<li><code>path</code>: 使用位運算儲存節點的路徑，用來表示從根節點到當前節點的左右走向。</li>
</ul>
</li>
</ul>
<p>在這個程式中，<code>path</code> 使用位運算來表示節點從根節點到該節點的左右走向，方便在樹中存儲節點路徑。每個節點的 <code>path</code> 是一個整數，該整數的二進位表示了從根節點走到該節點時的左右移動方向（左為 0，右為 1）。例如，如果我們有一個完全二元樹，從根節點 <code>A</code> 開始，並構建以下結構：</p>
<pre><code>       A
     /   \
    B     C
   / \   / \
  D   E F   G
</code></pre>
<p>我們可以分別查看每個節點的 <code>path</code> 值：</p>
<h3 id="例子說明"><a class="header" href="#例子說明">例子說明</a></h3>
<p>假設每次走向左子節點為 0、右子節點為 1。節點 <code>path</code> 值的計算會是這樣：</p>
<ol>
<li>
<p><strong>節點 A (根節點)</strong></p>
<ul>
<li><code>A</code> 的 <code>path</code> 是 <code>0</code>，因為它是根節點，不需要任何移動。</li>
</ul>
</li>
<li>
<p><strong>節點 B (A 的左子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>B</code> 走左邊，因此 <code>B</code> 的 <code>path</code> 是 <code>0</code>（二進位 <code>0</code>）。</li>
</ul>
</li>
<li>
<p><strong>節點 C (A 的右子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>C</code> 走右邊，因此 <code>C</code> 的 <code>path</code> 是 <code>1</code>（二進位 <code>1</code>）。</li>
</ul>
</li>
<li>
<p><strong>節點 D (B 的左子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>B</code> 再到 <code>D</code>，走向為「左 -&gt; 左」，因此 <code>D</code> 的 <code>path</code> 是 <code>00</code>（二進位 <code>00</code>，十進位是 <code>0</code>）。</li>
</ul>
</li>
<li>
<p><strong>節點 E (B 的右子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>B</code> 再到 <code>E</code>，走向為「左 -&gt; 右」，因此 <code>E</code> 的 <code>path</code> 是 <code>01</code>（二進位 <code>01</code>，十進位是 <code>1</code>）。</li>
</ul>
</li>
<li>
<p><strong>節點 F (C 的左子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>C</code> 再到 <code>F</code>，走向為「右 -&gt; 左」，因此 <code>F</code> 的 <code>path</code> 是 <code>10</code>（二進位 <code>10</code>，十進位是 <code>2</code>）。</li>
</ul>
</li>
<li>
<p><strong>節點 G (C 的右子節點)</strong></p>
<ul>
<li>從 <code>A</code> 到 <code>C</code> 再到 <code>G</code>，走向為「右 -&gt; 右」，因此 <code>G</code> 的 <code>path</code> 是 <code>11</code>（二進位 <code>11</code>，十進位是 <code>3</code>）。</li>
</ul>
</li>
</ol>
<h3 id="path-值總結"><a class="header" href="#path-值總結"><code>path</code> 值總結</a></h3>
<div class="table-wrapper"><table><thead><tr><th>節點</th><th>路徑方向</th><th>path (二進位)</th><th>path (十進位)</th></tr></thead><tbody>
<tr><td>A</td><td>-</td><td><code>0</code></td><td><code>0</code></td></tr>
<tr><td>B</td><td>左</td><td><code>0</code></td><td><code>0</code></td></tr>
<tr><td>C</td><td>右</td><td><code>1</code></td><td><code>1</code></td></tr>
<tr><td>D</td><td>左 -&gt; 左</td><td><code>00</code></td><td><code>0</code></td></tr>
<tr><td>E</td><td>左 -&gt; 右</td><td><code>01</code></td><td><code>1</code></td></tr>
<tr><td>F</td><td>右 -&gt; 左</td><td><code>10</code></td><td><code>2</code></td></tr>
<tr><td>G</td><td>右 -&gt; 右</td><td><code>11</code></td><td><code>3</code></td></tr>
</tbody></table>
</div>
<h3 id="path-值的用途"><a class="header" href="#path-值的用途"><code>path</code> 值的用途</a></h3>
<p>在二元樹中，<code>path</code> 可以被用來快速確定從根到任意節點的走向。例如，透過判斷 <code>path</code> 的二進位值中的每個位，可以知道應該向左還是向右移動。</p>
<hr />
<h3 id="3-binarytree-類別"><a class="header" href="#3-binarytree-類別">3. <code>BinaryTree</code> 類別</a></h3>
<p>這是管理整個二元樹的核心類別，負責樹的建立、節點的添加、路徑查找等功能。主要成員包括：</p>
<ul>
<li><code>nodes</code>: 用於儲存所有節點的列表。</li>
<li><code>size</code>: 樹中當前節點的數量。</li>
<li><code>value_to_index</code>: 將節點值對應到節點索引的字典，便於查找節點索引。</li>
</ul>
<h4 id="1-add_node-方法"><a class="header" href="#1-add_node-方法">(1) <code>add_node</code> 方法</a></h4>
<ul>
<li>用來添加新節點。若為根節點，則 <code>parent_idx</code> 設為 -1，<code>depth</code> 設為 0。</li>
<li>否則，根據父節點的深度和路徑來計算新節點的 <code>depth</code> 和 <code>path</code>。</li>
<li>在節點列表 <code>nodes</code> 中新增這個節點，並更新 <code>value_to_index</code> 字典。</li>
</ul>
<h4 id="2-find_node_index-方法"><a class="header" href="#2-find_node_index-方法">(2) <code>find_node_index</code> 方法</a></h4>
<ul>
<li>查找特定值的節點索引，如果找不到，則回傳 -1。</li>
</ul>
<h4 id="3-find_lca_index-方法"><a class="header" href="#3-find_lca_index-方法">(3) <code>find_lca_index</code> 方法</a></h4>
<ul>
<li>查找兩個節點的最近公共祖先（Lowest Common Ancestor, LCA）。</li>
<li>使用迴圈，使兩個節點逐層往上尋找，直到它們相遇為止。</li>
</ul>
<h4 id="4-generate_path-方法"><a class="header" href="#4-generate_path-方法">(4) <code>generate_path</code> 方法</a></h4>
<ul>
<li>根據兩個節點之間的關係生成路徑字符串：
<ul>
<li>從起始節點一路向上到最近公共祖先（LCA），路徑為 <code>"上" </code>。</li>
<li>從 LCA 開始，沿著左右走向到達目標節點，路徑為 <code>"左"</code> 或 <code>"右"</code>。</li>
<li>最後合併這兩部分路徑，並回傳最終的路徑字串。</li>
</ul>
</li>
</ul>
<h4 id="5-find_path_between_nodes-方法"><a class="header" href="#5-find_path_between_nodes-方法">(5) <code>find_path_between_nodes</code> 方法</a></h4>
<ul>
<li>查找指定節點之間的路徑，顯示從 <code>start_val</code> 到 <code>end_val</code> 的路徑。</li>
<li>若節點不存在，會提示使用者。</li>
</ul>
<hr />
<h3 id="4-main-函數"><a class="header" href="#4-main-函數">4. <code>main()</code> 函數</a></h3>
<ul>
<li>用來建立並測試二元樹的主程式。</li>
<li>以完全二元樹結構建立節點，節點的值從 <code>A</code> 開始，並依序增加。</li>
<li>使用 <code>deque</code> 進行廣度優先遍歷，將父節點依次出列，再添加其左右子節點（節點值字母超過 <code>Z</code> 時，進入 AA, AB 等雙字母模式）。</li>
<li>最後提供互動式功能，讓使用者輸入兩個節點的值來查找並顯示它們之間的路徑。</li>
</ul>
<hr />
<h3 id="執行流程"><a class="header" href="#執行流程">執行流程</a></h3>
<ol>
<li><code>BinaryTree</code> 類別被初始化，並建立根節點。</li>
<li>利用 <code>deque</code> 來按層構建完全二元樹，直到達到最大節點數量為止。</li>
<li>用戶可以輸入兩個節點的值來查找它們之間的路徑。程式會利用最近公共祖先（LCA）來生成路徑，顯示從起始節點到目標節點的走向。</li>
</ol>
<hr />
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>假設樹的結構如下（僅展示部分）：</p>
<pre><code>       A
     /   \
    B     C
   / \   / \
  D   E F   G
</code></pre>
<p>若使用者輸入從 <code>D</code> 到 <code>G</code> 的路徑：</p>
<ul>
<li>程式會找到 <code>D</code> 和 <code>G</code> 的最近公共祖先 <code>A</code>。</li>
<li><code>D</code> 到 <code>A</code> 的路徑為 <code>"上上"</code>。</li>
<li><code>A</code> 到 <code>G</code> 的路徑為 <code>"右左"</code>。</li>
<li>結果輸出 <code>"上上右左"</code>。</li>
</ul>
<hr />
<p>這段程式提供了有效的方法來構建完全二元樹，並以位運算儲存節點路徑，方便查找節點間的路徑。</p>
<hr />
<pre><code class="language-python"># 定義樹的最大深度
MAX_DEPTH = 5  # 為了方便展示，這裡設為5，可以根據需要調整


# 輔助函數：生成節點名稱
def get_next_node_value(index):
    letters = []
    while index &gt;= 0:
        letters.append(chr(index % 26 + ord("A")))
        index = index // 26 - 1
    return "".join(reversed(letters))


# 節點類，表示樹中的每個節點
class Node:
    def __init__(self, value, parent_index, is_right, depth, path):
        self.value = value  # 節點值
        self.parent_index = parent_index  # 父節點索引
        self.is_right = is_right  # 標記是左子節點還是右子節點
        self.depth = depth  # 節點深度
        self.path = path  # 使用位運算表示的路徑


# 二元樹類，用於管理樹
class BinaryTree:
    def __init__(self):
        self.nodes = []  # 節點列表
        self.size = 0  # 當前節點數量
        self.value_to_index = {}  # 節點值到索引的映射

    # 向樹中添加節點
    def add_node(self, value, parent_idx, is_right):
        print(value)
        if self.size &gt;= (1 &lt;&lt; (MAX_DEPTH + 1)):
            return -1

        if parent_idx == -1:
            depth = 0
            path = 0
        else:
            depth = self.nodes[parent_idx].depth + 1
            if depth &gt;= 64:  # 使用64位整數
                print("深度超過限制")
                return -1
            path = self.nodes[parent_idx].path | (is_right &lt;&lt; depth)

        node = Node(value, parent_idx, is_right, depth, path)
        self.nodes.append(node)
        curr_idx = self.size
        self.size += 1

        # 更新節點值到索引的映射
        self.value_to_index[value] = curr_idx

        return curr_idx

    # 查找具有給定值的節點的索引
    def find_node_index(self, value):
        return self.value_to_index.get(value, -1)

    # 利用 path 和 depth 找到最近公共祖先的索引
    def find_lca_index(self, idx1, idx2):
        node1, node2 = self.nodes[idx1], self.nodes[idx2]
        while node1.path != node2.path:
            if node1.depth &gt; node2.depth:
                idx1 = node1.parent_index
                node1 = self.nodes[idx1]
            elif node2.depth &gt; node1.depth:
                idx2 = node2.parent_index
                node2 = self.nodes[idx2]
            else:
                idx1, idx2 = node1.parent_index, node2.parent_index
                node1, node2 = self.nodes[idx1], self.nodes[idx2]
        return idx1

    # 使用 path 屬性生成從 start_idx 到 end_idx 的路徑字符串
    def generate_path(self, start_idx, end_idx):
        if start_idx == end_idx:
            return ""

        # 找到最近公共祖先的索引
        lca_idx = self.find_lca_index(start_idx, end_idx)

        path_parts = []

        # 從起始節點向上到LCA
        current_idx = start_idx
        while current_idx != lca_idx:
            path_parts.append("上")
            current_idx = self.nodes[current_idx].parent_index

        # 從LCA向下到目標節點
        directions = []
        current_idx = end_idx
        while current_idx != lca_idx:
            node = self.nodes[current_idx]
            if node.is_right:
                directions.append("右")
            else:
                directions.append("左")
            current_idx = node.parent_index

        path_parts.extend(reversed(directions))
        return "".join(path_parts)

    # 查找兩個節點之間的路徑並輸出
    def find_path_between_nodes(self, start_val, end_val):
        start_idx = self.find_node_index(start_val)
        end_idx = self.find_node_index(end_val)

        if start_idx == -1 or end_idx == -1:
            print("節點不存在")
            return

        path = self.generate_path(start_idx, end_idx)
        print(f"從 {start_val} 到 {end_val} 的路徑: {path}")


# 主函數，測試二元樹功能
def main():
    tree = BinaryTree()

    # 建立完全二元樹
    from collections import deque

    max_nodes = 2 ** (MAX_DEPTH + 1) - 1  # 完全二元樹的節點總數
    node_queue = deque()
    value_ord = 0  # 節點索引從0開始，將被轉換為字母表示

    # 添加根節點
    root_value = get_next_node_value(value_ord)
    root_idx = tree.add_node(root_value, -1, 0)
    node_queue.append((root_idx, value_ord))
    value_ord += 1

    while node_queue and tree.size &lt; max_nodes:
        parent_idx, parent_value_ord = node_queue.popleft()

        # 添加左子節點
        left_value = get_next_node_value(value_ord)
        left_idx = tree.add_node(left_value, parent_idx, 0)
        node_queue.append((left_idx, value_ord))
        value_ord += 1

        # 添加右子節點
        right_value = get_next_node_value(value_ord)
        right_idx = tree.add_node(right_value, parent_idx, 1)
        node_queue.append((right_idx, value_ord))
        value_ord += 1

    # 提供交互方式，允許用戶輸入任意兩個節點的值
    print("請輸入要查找路徑的節點，輸入 'exit' 退出程序。")
    while True:
        try:
            start_val = input("請輸入起始節點: ")
            if start_val.lower() == "exit":
                break
            end_val = input("請輸入目標節點: ")
            if end_val.lower() == "exit":
                break
            tree.find_path_between_nodes(start_val.strip(), end_val.strip())
        except KeyboardInterrupt:
            print("\n程序已退出。")
            break
        except Exception as e:
            print(f"發生錯誤: {e}")


if __name__ == "__main__":
    main()
</code></pre>
<p><code>find_lca_index</code> 函數用於找到二元樹中兩個節點的最近公共祖先（LCA, Lowest Common Ancestor），即兩個節點共同的最深祖先節點。</p>
<h3 id="基本邏輯"><a class="header" href="#基本邏輯">基本邏輯</a></h3>
<ol>
<li>比較兩個節點的 <code>path</code> 屬性，若不同則逐步向上回溯，直到兩者的 <code>path</code> 一致，即找到共同祖先。</li>
<li>如果兩個節點深度不同，較深的節點會先回溯到淺層，直至兩者深度相同。</li>
<li>如果兩者深度相同且路徑不同，則同時向上回溯父節點，直到路徑相同。</li>
</ol>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p>假設一棵二元樹的結構如下，根節點為 <code>A</code>，左右子節點分別依序命名為 <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>G</code>：</p>
<pre><code>         A
       /   \
      B     C
     / \   / \
    D   E F   G
</code></pre>
<p><strong>示例：找節點 <code>D</code> 和 <code>G</code> 的最近公共祖先</strong></p>
<ol>
<li><code>D</code> 的索引為 <code>3</code>，<code>G</code> 的索引為 <code>6</code>。</li>
<li>使用 <code>find_lca_index(3, 6)</code> 時，首先比較兩個節點的 <code>path</code> 值。</li>
<li>因 <code>D</code> 和 <code>G</code> 的深度相同，但 <code>path</code> 不同，因此兩者同時回溯到其父節點，分別是 <code>B</code> 和 <code>C</code>。</li>
<li>接下來，<code>B</code> 和 <code>C</code> 的深度相同，但仍然 <code>path</code> 不同，繼續回溯到其父節點 <code>A</code>。</li>
<li><code>A</code> 是 <code>D</code> 和 <code>G</code> 的最近公共祖先，因此返回 <code>A</code> 的索引 <code>0</code>。</li>
</ol>
<p>此過程確認 <code>find_lca_index</code> 可以通過路徑和深度找到最靠近根的公共祖先。</p>
<p>當我們使用 <code>find_lca_index</code> 函數時，會利用每個節點的 <code>path</code> 值來加速找到兩個節點的最近公共祖先（LCA）。以下是一個完整說明，包括 <code>path</code> 值的計算方式、範例，以及加上 <code>path</code> 後提高效能的原因。</p>
<h3 id="path-屬性的計算方式"><a class="header" href="#path-屬性的計算方式">path 屬性的計算方式</a></h3>
<p><code>path</code> 屬性是一個整數，使用位運算來表示從根節點到當前節點的路徑：</p>
<ul>
<li>根節點的 <code>path</code> 為 <code>0</code>。</li>
<li>對於每個子節點，若為左子節點，則 <code>path</code> 保持不變；若為右子節點，則將 <code>path</code> 的第 <code>depth</code> 位設為 <code>1</code>。</li>
<li>這樣，每個節點的 <code>path</code> 就可以唯一地表示從根節點出發的路徑。</li>
</ul>
<p>例如：</p>
<ol>
<li>根節點 <code>A</code> 的 <code>path = 0</code>。</li>
<li><code>A</code> 的左子節點 <code>B</code> 仍保持 <code>path = 0</code>（因為是左子節點）。</li>
<li><code>A</code> 的右子節點 <code>C</code> 的 <code>path</code> 為 <code>1</code>（因為是右子節點）。</li>
<li><code>B</code> 的左子節點 <code>D</code> 繼承 <code>B</code> 的 <code>path = 0</code>。</li>
<li><code>B</code> 的右子節點 <code>E</code> 的 <code>path</code> 為 <code>10</code>（即 <code>2</code>，因為是 <code>B</code> 的右子節點，在第 <code>2</code> 位設為 <code>1</code>）。</li>
<li>同理，<code>C</code> 的左子節點 <code>F</code> 的 <code>path</code> 為 <code>01</code>（即 <code>1</code>），<code>C</code> 的右子節點 <code>G</code> 的 <code>path</code> 為 <code>11</code>（即 <code>3</code>）。</li>
</ol>
<p>樹結構的節點及其對應 <code>path</code> 值：</p>
<pre><code>         A (path=0)
       /       \
   B (path=0)   C (path=1)
     /   \       /     \
D (0)   E (2)  F (1)   G (3)
</code></pre>
<h3 id="find_lca_index-的示例與過程"><a class="header" href="#find_lca_index-的示例與過程">find_lca_index 的示例與過程</a></h3>
<p>假設要找 <code>D</code> 和 <code>G</code> 的最近公共祖先：</p>
<ol>
<li><code>D</code> 的索引為 <code>3</code>，<code>path</code> 為 <code>0</code>，深度為 <code>2</code>。</li>
<li><code>G</code> 的索引為 <code>6</code>，<code>path</code> 為 <code>3</code>，深度也為 <code>2</code>。</li>
</ol>
<p>我們在 <code>find_lca_index</code> 中的比較過程為：</p>
<ol>
<li><code>D</code> 和 <code>G</code> 的 <code>path</code> 不同，但深度相同，因此同時回溯到各自的父節點，分別是 <code>B</code> 和 <code>C</code>。</li>
<li><code>B</code> 和 <code>C</code> 的 <code>path</code> 仍然不同，繼續回溯到 <code>A</code>。</li>
<li>在 <code>A</code> 處，<code>path</code> 相同（均為 <code>0</code>），因此 <code>A</code> 是 <code>D</code> 和 <code>G</code> 的最近公共祖先，返回 <code>A</code> 的索引 <code>0</code>。</li>
</ol>
<h3 id="使用-path-提高效能的原因"><a class="header" href="#使用-path-提高效能的原因">使用 path 提高效能的原因</a></h3>
<p>傳統方法需要沿樹逐層回溯父節點以找到公共祖先，而 <code>path</code> 可以壓縮多層回溯的操作，提供更快速的判斷：</p>
<ul>
<li><code>path</code> 用位元表示樹路徑，對比節點只需判斷 <code>path</code> 值是否一致，大幅減少比較操作。</li>
<li>當 <code>path</code> 不同且深度一致時，可以一次性向上找到公共祖先，而不必多層次逐步上溯。</li>
</ul>
<p>這種方法利用了整數位元的快速比較特性，有效地優化了查找的速度，特別是在深度較大的樹中，可以顯著提升查找效率。</p>
<pre><code class="language-python"># 查找最近公共祖先的索引 **第一版**：
def find_lca_index(self, idx1, idx2):
    node1_idx = idx1
    node2_idx = idx2

    node1 = self.nodes[node1_idx]
    node2 = self.nodes[node2_idx]

    while node1_idx != node2_idx:
        if node1.depth &gt; node2.depth:
            node1_idx = node1.parent_index
            node1 = self.nodes[node1_idx]
        elif node2.depth &gt; node1.depth:
            node2_idx = node2.parent_index
            node2 = self.nodes[node2_idx]
        else:
            node1_idx = node1.parent_index
            node2_idx = node2.parent_index
            node1 = self.nodes[node1_idx]
            node2 = self.nodes[node2_idx
</code></pre>
<pre><code class="language-python"># 利用 path 和 depth 找到最近公共祖先的索引  **第二版**：
def find_lca_index(self, idx1, idx2):
    # 獲取兩個節點的初始節點對象
    node1, node2 = self.nodes[idx1], self.nodes[idx2]

    # 當兩個節點的 path 不相等時，進行回溯以找到公共祖先
    while node1.path != node2.path:
        # 如果 node1 深度大於 node2，則將 node1 向上移動至父節點
        if node1.depth &gt; node2.depth:
            idx1 = node1.parent_index
            node1 = self.nodes[idx1]
        # 如果 node2 深度大於 node1，則將 node2 向上移動至父節點
        elif node2.depth &gt; node1.depth:
            idx2 = node2.parent_index
            node2 = self.nodes[idx2]
        # 如果兩個節點的深度相同，則同時向上移動到各自的父節點
        else:
            idx1, idx2 = node1.parent_index, node2.parent_index
            node1, node2 = self.nodes[idx1], self.nodes[idx2]

    # 當 node1 和 node2 的 path 相等時，即找到了最近公共祖先
    return idx1
</code></pre>
<p>這裡是完整的 15 個節點樹狀結構 <code>path</code> 值表示，其中每個節點的 <code>path</code> 值根據從根節點 <code>A</code> 移動的方向來計算。<code>0</code> 表示向左移動，<code>1</code> 表示向右移動。</p>
<div class="table-wrapper"><table><thead><tr><th>節點</th><th>路徑方向</th><th>path (二進位)</th><th>path (十進位)</th></tr></thead><tbody>
<tr><td>A</td><td>-</td><td><code>0</code></td><td><code>0</code></td></tr>
<tr><td>B</td><td>左</td><td><code>0</code></td><td><code>0</code></td></tr>
<tr><td>C</td><td>右</td><td><code>1</code></td><td><code>1</code></td></tr>
<tr><td>D</td><td>左 -&gt; 左</td><td><code>00</code></td><td><code>0</code></td></tr>
<tr><td>E</td><td>左 -&gt; 右</td><td><code>01</code></td><td><code>1</code></td></tr>
<tr><td>F</td><td>右 -&gt; 左</td><td><code>10</code></td><td><code>2</code></td></tr>
<tr><td>G</td><td>右 -&gt; 右</td><td><code>11</code></td><td><code>3</code></td></tr>
<tr><td>H</td><td>左 -&gt; 左 -&gt; 左</td><td><code>000</code></td><td><code>0</code></td></tr>
<tr><td>I</td><td>左 -&gt; 左 -&gt; 右</td><td><code>001</code></td><td><code>1</code></td></tr>
<tr><td>J</td><td>左 -&gt; 右 -&gt; 左</td><td><code>010</code></td><td><code>2</code></td></tr>
<tr><td>K</td><td>左 -&gt; 右 -&gt; 右</td><td><code>011</code></td><td><code>3</code></td></tr>
<tr><td>L</td><td>右 -&gt; 左 -&gt; 左</td><td><code>100</code></td><td><code>4</code></td></tr>
<tr><td>M</td><td>右 -&gt; 左 -&gt; 右</td><td><code>101</code></td><td><code>5</code></td></tr>
<tr><td>N</td><td>右 -&gt; 右 -&gt; 左</td><td><code>110</code></td><td><code>6</code></td></tr>
<tr><td>O</td><td>右 -&gt; 右 -&gt; 右</td><td><code>111</code></td><td><code>7</code></td></tr>
</tbody></table>
</div>
<p>這些 <code>path</code> 值能夠在樹的深度和節點關係中提供快速查找功能，尤其是使用 <code>path</code> 值進行公共祖先查找時。</p>
<p>在這兩個版本的 <code>find_lca_index</code> 中，主要區別在於條件的檢查方式。第一個版本直接比較兩個節點的索引，利用索引回溯至同一節點；第二個版本則比較兩個節點的 <code>path</code>，而回溯流程上是類似的。</p>
<h3 id="效能分析"><a class="header" href="#效能分析">效能分析</a></h3>
<ol>
<li>
<p><strong>第一版</strong>：</p>
<ul>
<li>直接比對索引 (<code>node1_idx</code> 和 <code>node2_idx</code>)，當兩者相同即找到最近公共祖先。當兩者深度不同時，會將較深的節點上移至父節點，否則同時將兩者上移。</li>
<li><strong>效能優點</strong>：操作相對簡潔，直接使用索引對比，減少了對 <code>path</code> 的檢查操作。</li>
</ul>
</li>
<li>
<p><strong>第二版</strong>：</p>
<ul>
<li>比較兩個節點的 <code>path</code>，當 <code>path</code> 不同時才進行回溯操作。</li>
<li><strong>效能優點</strong>：當樹具有多層且每層節點密集時，<code>path</code> 可以有效縮短查找最近公共祖先的步數。因為如果 <code>path</code> 不同，說明兩個節點在不同的分支中，能有效地排除分支差異，從而更快定位到共同的祖先。</li>
</ul>
</li>
</ol>
<h3 id="效能結論"><a class="header" href="#效能結論">效能結論</a></h3>
<p>第二版使用 <code>path</code> 來進行篩選，尤其在多層大樹結構中，能夠減少冗餘的節點回溯數量，因此 <strong>在深層且節點數量多的樹結構中，會更具效能優勢</strong>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../c++/cpp_note.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../c++/gcc_finstrument-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../c++/cpp_note.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../c++/gcc_finstrument-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
