<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Google Benchmark 指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="google-benchmark-完整使用指南"><a class="header" href="#google-benchmark-完整使用指南">Google Benchmark 完整使用指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#%E7%B0%A1%E4%BB%8B">簡介</a></li>
<li><a href="#%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F">安裝方式</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li>
<li><a href="#%E9%80%B2%E9%9A%8E%E5%8A%9F%E8%83%BD">進階功能</a></li>
<li><a href="#%E6%B8%AC%E8%A9%A6-c-%E8%AA%9E%E8%A8%80%E7%A8%8B%E5%BC%8F%E7%A2%BC">測試 C 語言程式碼</a></li>
<li><a href="#%E7%B7%A8%E8%AD%AF%E8%88%87%E5%9F%B7%E8%A1%8C">編譯與執行</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90">最佳實踐</a></li>
<li><a href="#%E8%BC%B8%E5%87%BA%E8%A7%A3%E8%AE%80">輸出解讀</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E6%B8%AC%E8%A9%A6%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC">完整測試範例程式碼</a></li>
</ul>
<h2 id="簡介"><a class="header" href="#簡介">簡介</a></h2>
<p>Google Benchmark 是一個強大的 C++ 微基準測試（microbenchmarking）函式庫，由 Google 開發並開源。它能夠精確測量程式碼效能，自動處理統計分析，並提供詳細的性能指標。</p>
<h3 id="主要特點"><a class="header" href="#主要特點">主要特點</a></h3>
<ul>
<li>自動決定迭代次數以獲得統計上有意義的結果</li>
<li>支援多執行緒基準測試</li>
<li>提供多種輸出格式（控制台、JSON、CSV）</li>
<li>防止編譯器優化的機制</li>
<li>支援自訂計數器和吞吐量測量</li>
<li>可測試 C 和 C++ 程式碼</li>
</ul>
<h2 id="安裝方式"><a class="header" href="#安裝方式">安裝方式</a></h2>
<h3 id="方法一使用-cmake-從源碼安裝"><a class="header" href="#方法一使用-cmake-從源碼安裝">方法一：使用 CMake 從源碼安裝</a></h3>
<pre><code class="language-bash"># 1. 克隆專案
git clone https://github.com/google/benchmark.git
cd benchmark

# 2. 建立建構目錄
cmake -E make_directory "build"

# 3. 產生建構檔案
cmake -E chdir "build" cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release ../

# 4. 編譯
cmake --build "build" --config Release

# 5. 安裝到系統（選擇性）
sudo cmake --build "build" --config Release --target install
</code></pre>
<h3 id="方法二使用-conan-套件管理器"><a class="header" href="#方法二使用-conan-套件管理器">方法二：使用 Conan 套件管理器</a></h3>
<p><strong>conanfile.txt:</strong></p>
<pre><code class="language-txt">[requires]
benchmark/1.8.3

[generators]
CMakeDeps
CMakeToolchain
</code></pre>
<p>安裝指令：</p>
<pre><code class="language-bash">conan install . --build=missing -s build_type=Release
</code></pre>
<h3 id="方法三整合到-cmake-專案"><a class="header" href="#方法三整合到-cmake-專案">方法三：整合到 CMake 專案</a></h3>
<p><strong>使用 find_package（需先安裝）：</strong></p>
<pre><code class="language-cmake">find_package(benchmark REQUIRED)
target_link_libraries(MyTarget benchmark::benchmark)
</code></pre>
<p><strong>使用 add_subdirectory（作為子專案）：</strong></p>
<pre><code class="language-cmake">add_subdirectory(benchmark)
target_link_libraries(MyTarget benchmark::benchmark)
</code></pre>
<p><strong>使用 FetchContent（CMake 3.14+）：</strong></p>
<pre><code class="language-cmake">include(FetchContent)
FetchContent_Declare(
  googlebenchmark
  GIT_REPOSITORY https://github.com/google/benchmark.git
  GIT_TAG main
)
FetchContent_MakeAvailable(googlebenchmark)
target_link_libraries(MyTarget benchmark::benchmark)
</code></pre>
<h2 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h2>
<h3 id="最簡單的範例"><a class="header" href="#最簡單的範例">最簡單的範例</a></h3>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;

static void BM_StringCreation(benchmark::State&amp; state) {
  for (auto _ : state)
    std::string empty_string;
}
// 註冊基準測試
BENCHMARK(BM_StringCreation);

// 定義主函式
BENCHMARK_MAIN();
</code></pre>
<h3 id="測試含參數的函式"><a class="header" href="#測試含參數的函式">測試含參數的函式</a></h3>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

static void BM_VectorSort(benchmark::State&amp; state) {
  // 取得參數（向量大小）
  const int size = state.range(0);

  for (auto _ : state) {
    // 暫停計時器來準備資料
    state.PauseTiming();
    std::vector&lt;int&gt; v(size);
    for (int i = 0; i &lt; size; i++) {
      v[i] = rand() % 1000;
    }
    state.ResumeTiming();

    // 實際要測試的程式碼
    std::sort(v.begin(), v.end());
  }
}

// 測試不同大小：8, 64, 512, 4096
BENCHMARK(BM_VectorSort)-&gt;Range(8, 8&lt;&lt;10);

// 或指定特定值
BENCHMARK(BM_VectorSort)-&gt;Args({10})-&gt;Args({100})-&gt;Args({1000});
</code></pre>
<h3 id="防止編譯器優化"><a class="header" href="#防止編譯器優化">防止編譯器優化</a></h3>
<pre><code class="language-cpp">static void BM_Calculation(benchmark::State&amp; state) {
  for (auto _ : state) {
    int sum = 0;
    for (int i = 0; i &lt; 1000; ++i) {
      sum += i;
    }
    // 防止編譯器優化掉未使用的結果
    benchmark::DoNotOptimize(sum);
  }
}
BENCHMARK(BM_Calculation);
</code></pre>
<h2 id="進階功能"><a class="header" href="#進階功能">進階功能</a></h2>
<h3 id="1-使用-fixture測試夾具"><a class="header" href="#1-使用-fixture測試夾具">1. 使用 Fixture（測試夾具）</a></h3>
<p>適用於需要複雜設定或共享資源的測試：</p>
<pre><code class="language-cpp">class MyFixture : public benchmark::Fixture {
public:
  void SetUp(const ::benchmark::State&amp; state) override {
    // 在每個基準測試開始前執行
    data.resize(state.range(0));
    std::generate(data.begin(), data.end(), std::rand);
  }

  void TearDown(const ::benchmark::State&amp; state) override {
    // 在每個基準測試結束後執行
    data.clear();
  }

  std::vector&lt;int&gt; data;
};

BENCHMARK_DEFINE_F(MyFixture, SortTest)(benchmark::State&amp; state) {
  for (auto _ : state) {
    std::vector&lt;int&gt; local_data = data;  // 複製資料
    std::sort(local_data.begin(), local_data.end());
  }
}

BENCHMARK_REGISTER_F(MyFixture, SortTest)-&gt;Range(8, 8&lt;&lt;10);
</code></pre>
<h3 id="2-多執行緒基準測試"><a class="header" href="#2-多執行緒基準測試">2. 多執行緒基準測試</a></h3>
<pre><code class="language-cpp">static void BM_MultiThreaded(benchmark::State&amp; state) {
  static std::mutex mu;
  static int counter = 0;

  if (state.thread_index() == 0) {
    // 只在第一個執行緒執行
    counter = 0;
  }

  for (auto _ : state) {
    std::lock_guard&lt;std::mutex&gt; lock(mu);
    ++counter;
  }
}

// 測試 1, 2, 4, 8 個執行緒
BENCHMARK(BM_MultiThreaded)-&gt;Threads(1);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(2);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(4);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(8);

// 或使用 ThreadRange
BENCHMARK(BM_MultiThreaded)-&gt;ThreadRange(1, 8);
</code></pre>
<h3 id="3-自訂計數器和吞吐量"><a class="header" href="#3-自訂計數器和吞吐量">3. 自訂計數器和吞吐量</a></h3>
<pre><code class="language-cpp">void ProcessData(size_t bytes) {
  // 模擬資料處理
  volatile char* data = new char[bytes];
  for (size_t i = 0; i &lt; bytes; ++i) {
    data[i] = static_cast&lt;char&gt;(i);
  }
  delete[] data;
}

static void BM_DataProcessing(benchmark::State&amp; state) {
  const size_t bytes_per_iteration = 1024 * 1024;  // 1MB

  for (auto _ : state) {
    ProcessData(bytes_per_iteration);
  }

  // 設定處理的位元組數（會顯示 MB/s）
  state.SetBytesProcessed(state.iterations() * bytes_per_iteration);

  // 設定處理的項目數（會顯示 items/s）
  state.SetItemsProcessed(state.iterations() * 1000);

  // 自訂計數器
  state.counters["CustomMetric"] = benchmark::Counter(
    state.iterations() * 2.5,
    benchmark::Counter::kIsRate
  );
}
BENCHMARK(BM_DataProcessing);
</code></pre>
<h3 id="4-統計分析"><a class="header" href="#4-統計分析">4. 統計分析</a></h3>
<pre><code class="language-cpp">static void BM_SomeFunction(benchmark::State&amp; state) {
  for (auto _ : state) {
    std::vector&lt;int&gt; v(100);
    std::iota(v.begin(), v.end(), 0);
    std::shuffle(v.begin(), v.end(), std::mt19937{42});
    benchmark::DoNotOptimize(v);
  }
}

// 重複執行以獲得統計資料
BENCHMARK(BM_SomeFunction)
  -&gt;Repetitions(10)           // 重複 10 次
  -&gt;ReportAggregatesOnly()    // 只報告統計結果
  -&gt;DisplayAggregatesOnly();  // 只顯示統計結果

// 或顯示所有資料加上統計
BENCHMARK(BM_SomeFunction)
  -&gt;Repetitions(5)
  -&gt;ComputeStatistics("max", [](const std::vector&lt;double&gt;&amp; v) -&gt; double {
    return *std::max_element(v.begin(), v.end());
  })
  -&gt;ComputeStatistics("min", [](const std::vector&lt;double&gt;&amp; v) -&gt; double {
    return *std::min_element(v.begin(), v.end());
  });
</code></pre>
<h3 id="5-模板基準測試"><a class="header" href="#5-模板基準測試">5. 模板基準測試</a></h3>
<pre><code class="language-cpp">template &lt;typename T&gt;
static void BM_TemplateTest(benchmark::State&amp; state) {
  T value{};
  for (auto _ : state) {
    value += T(1);
    benchmark::DoNotOptimize(value);
  }
}

BENCHMARK_TEMPLATE(BM_TemplateTest, int);
BENCHMARK_TEMPLATE(BM_TemplateTest, double);
// Note: std::string 不支援 += 與 int(1) 的操作
</code></pre>
<h2 id="測試-c-語言程式碼"><a class="header" href="#測試-c-語言程式碼">測試 C 語言程式碼</a></h2>
<p>Google Benchmark 雖然是 C++ 函式庫，但可以完美地測試 C 語言程式碼。</p>
<h3 id="專案結構範例"><a class="header" href="#專案結構範例">專案結構範例</a></h3>
<pre><code>project/
├── src/                    # C 原始碼
│   ├── algorithms.c
│   ├── algorithms.h
│   ├── data_structures.c
│   └── data_structures.h
├── benchmark/              # 基準測試（C++）
│   ├── bench_algorithms.cpp
│   └── bench_data_structures.cpp
├── CMakeLists.txt
└── Makefile
</code></pre>
<h3 id="c-程式碼範例"><a class="header" href="#c-程式碼範例">C 程式碼範例</a></h3>
<p><strong>algorithms.h:</strong></p>
<pre><code class="language-c">#ifndef ALGORITHMS_H
#define ALGORITHMS_H

#ifdef __cplusplus
extern "C" {
#endif

// 排序演算法
void bubble_sort(int* arr, int n);
void quick_sort(int* arr, int low, int high);
void merge_sort(int* arr, int n);

// 搜尋演算法
int linear_search(const int* arr, int n, int target);
int binary_search(const int* arr, int n, int target);

// 數學函式
int fibonacci(int n);
int factorial(int n);
int gcd(int a, int b);

#ifdef __cplusplus
}
#endif

#endif // ALGORITHMS_H
</code></pre>
<p><strong>algorithms.c:</strong></p>
<pre><code class="language-c">#include "algorithms.h"
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void bubble_sort(int* arr, int n) {
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void quick_sort_helper(int* arr, int low, int high) {
    if (low &lt; high) {
        int pivot = arr[high];
        int i = (low - 1);

        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt; pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        int pi = i + 1;

        quick_sort_helper(arr, low, pi - 1);
        quick_sort_helper(arr, pi + 1, high);
    }
}

void quick_sort(int* arr, int low, int high) {
    quick_sort_helper(arr, low, high);
}

void merge(int* arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int* L = (int*)malloc(n1 * sizeof(int));
    int* R = (int*)malloc(n2 * sizeof(int));

    for (int i = 0; i &lt; n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }

    free(L);
    free(R);
}

void merge_sort_helper(int* arr, int left, int right) {
    if (left &lt; right) {
        int mid = left + (right - left) / 2;

        merge_sort_helper(arr, left, mid);
        merge_sort_helper(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

void merge_sort(int* arr, int n) {
    merge_sort_helper(arr, 0, n - 1);
}

int linear_search(const int* arr, int n, int target) {
    for (int i = 0; i &lt; n; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}

int binary_search(const int* arr, int n, int target) {
    int left = 0;
    int right = n - 1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target)
            return mid;

        if (arr[mid] &lt; target)
            left = mid + 1;
        else
            right = mid - 1;
    }

    return -1;
}

int fibonacci(int n) {
    if (n &lt;= 1) return n;

    int prev = 0, curr = 1;
    for (int i = 2; i &lt;= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}

int factorial(int n) {
    if (n &lt;= 1) return 1;

    int result = 1;
    for (int i = 2; i &lt;= n; i++) {
        result *= i;
    }
    return result;
}

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
</code></pre>
<h3 id="基準測試程式碼"><a class="header" href="#基準測試程式碼">基準測試程式碼</a></h3>
<p><strong>bench_algorithms.cpp:</strong></p>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;

extern "C" {
    #include "algorithms.h"
}

// 測試排序演算法
class SortingFixture : public benchmark::Fixture {
public:
    void SetUp(const ::benchmark::State&amp; state) override {
        size = state.range(0);
        data = new int[size];
        for (int i = 0; i &lt; size; i++) {
            data[i] = rand() % 10000;
        }
    }

    void TearDown(const ::benchmark::State&amp; state) override {
        delete[] data;
    }

    int* data;
    int size;
};

BENCHMARK_DEFINE_F(SortingFixture, BubbleSort)(benchmark::State&amp; state) {
    for (auto _ : state) {
        int* temp = new int[size];
        memcpy(temp, data, size * sizeof(int));

        bubble_sort(temp, size);

        benchmark::DoNotOptimize(temp);
        delete[] temp;
    }
    state.SetItemsProcessed(state.iterations() * size);
}

BENCHMARK_REGISTER_F(SortingFixture, BubbleSort)
    -&gt;RangeMultiplier(2)
    -&gt;Range(8, 512)  // 減少範圍因為 bubble sort 是 O(n²)
    -&gt;Unit(benchmark::kMicrosecond);

BENCHMARK_DEFINE_F(SortingFixture, QuickSort)(benchmark::State&amp; state) {
    for (auto _ : state) {
        int* temp = new int[size];
        memcpy(temp, data, size * sizeof(int));

        quick_sort(temp, 0, size - 1);

        benchmark::DoNotOptimize(temp);
        delete[] temp;
    }
    state.SetItemsProcessed(state.iterations() * size);
}

BENCHMARK_REGISTER_F(SortingFixture, QuickSort)
    -&gt;RangeMultiplier(2)
    -&gt;Range(8, 8&lt;&lt;10)
    -&gt;Unit(benchmark::kMicrosecond);

BENCHMARK_DEFINE_F(SortingFixture, MergeSort)(benchmark::State&amp; state) {
    for (auto _ : state) {
        int* temp = new int[size];
        memcpy(temp, data, size * sizeof(int));

        merge_sort(temp, size);

        benchmark::DoNotOptimize(temp);
        delete[] temp;
    }
    state.SetItemsProcessed(state.iterations() * size);
}

BENCHMARK_REGISTER_F(SortingFixture, MergeSort)
    -&gt;RangeMultiplier(2)
    -&gt;Range(8, 8&lt;&lt;10)
    -&gt;Unit(benchmark::kMicrosecond);

// 比較 C 和 C++ STL 實作
static void BM_CSort_vs_STLSort(benchmark::State&amp; state) {
    const int size = state.range(0);
    std::vector&lt;int&gt; original(size);
    std::generate(original.begin(), original.end(), std::rand);

    for (auto _ : state) {
        if (state.range(1) == 0) {
            // 測試 C 版本
            int* arr = new int[size];
            std::copy(original.begin(), original.end(), arr);
            bubble_sort(arr, size);
            benchmark::DoNotOptimize(arr);
            delete[] arr;
        } else {
            // 測試 STL 版本
            std::vector&lt;int&gt; v = original;
            std::sort(v.begin(), v.end());
            benchmark::DoNotOptimize(v.data());
        }
    }
}

BENCHMARK(BM_CSort_vs_STLSort)-&gt;Args({100, 0})-&gt;Args({100, 1});

// 測試 Fibonacci
static void BM_Fibonacci(benchmark::State&amp; state) {
    const int n = state.range(0);

    for (auto _ : state) {
        int result = fibonacci(n);
        benchmark::DoNotOptimize(result);
    }
}

BENCHMARK(BM_Fibonacci)-&gt;DenseRange(10, 30, 5);

// 測試 Factorial
static void BM_Factorial(benchmark::State&amp; state) {
    const int n = state.range(0);

    for (auto _ : state) {
        int result = factorial(n);
        benchmark::DoNotOptimize(result);
    }
}

BENCHMARK(BM_Factorial)-&gt;Range(5, 20);

// 測試 GCD
static void BM_GCD(benchmark::State&amp; state) {
    const int a = state.range(0);
    const int b = state.range(1);

    for (auto _ : state) {
        int result = gcd(a, b);
        benchmark::DoNotOptimize(result);
    }
}

BENCHMARK(BM_GCD)-&gt;Args({48, 18})-&gt;Args({1234567, 987654})-&gt;Args({1000000, 500000});

// 測試搜尋演算法
static void BM_LinearSearch(benchmark::State&amp; state) {
    const int size = state.range(0);
    int* arr = new int[size];
    for (int i = 0; i &lt; size; i++) {
        arr[i] = i;
    }

    for (auto _ : state) {
        // 搜尋中間元素（平均情況）
        int result = linear_search(arr, size, size / 2);
        benchmark::DoNotOptimize(result);
    }

    delete[] arr;
    state.SetComplexityN(size);
}

BENCHMARK(BM_LinearSearch)-&gt;RangeMultiplier(10)-&gt;Range(10, 10000)-&gt;Complexity();

static void BM_BinarySearch(benchmark::State&amp; state) {
    const int size = state.range(0);
    int* arr = new int[size];
    for (int i = 0; i &lt; size; i++) {
        arr[i] = i;
    }

    for (auto _ : state) {
        // 搜尋中間元素（平均情況）
        int result = binary_search(arr, size, size / 2);
        benchmark::DoNotOptimize(result);
    }

    delete[] arr;
    state.SetComplexityN(size);
}

BENCHMARK(BM_BinarySearch)-&gt;RangeMultiplier(10)-&gt;Range(10, 10000)-&gt;Complexity();

// 組織相關測試
namespace {
    std::vector&lt;int&gt; GenerateTestData(size_t size) {
        std::vector&lt;int&gt; data(size);
        std::iota(data.begin(), data.end(), 0);
        std::shuffle(data.begin(), data.end(), std::mt19937{42});
        return data;
    }

    // 額外的測試：比較不同排序演算法在不同數據大小下的效能
    void RegisterComparisonBenchmarks() {
        // Small arrays (8 - 64)
        static auto small_sort = [](benchmark::State&amp; state, int algo) {
            const int size = state.range(0);
            std::vector&lt;int&gt; original = GenerateTestData(size);

            for (auto _ : state) {
                int* arr = new int[size];
                std::copy(original.begin(), original.end(), arr);

                switch (algo) {
                    case 0: bubble_sort(arr, size); break;
                    case 1: quick_sort(arr, 0, size - 1); break;
                    case 2: merge_sort(arr, size); break;
                }

                benchmark::DoNotOptimize(arr);
                delete[] arr;
            }
            state.SetItemsProcessed(state.iterations() * size);
        };

        benchmark::RegisterBenchmark("SmallArray_BubbleSort", small_sort, 0)-&gt;Range(8, 64);
        benchmark::RegisterBenchmark("SmallArray_QuickSort", small_sort, 1)-&gt;Range(8, 64);
        benchmark::RegisterBenchmark("SmallArray_MergeSort", small_sort, 2)-&gt;Range(8, 64);
    }
}

int main(int argc, char** argv) {
    RegisterComparisonBenchmarks();
    ::benchmark::Initialize(&amp;argc, argv);
    ::benchmark::RunSpecifiedBenchmarks();
    return 0;
}
</code></pre>
<h3 id="makefile-範例"><a class="header" href="#makefile-範例">Makefile 範例</a></h3>
<pre><code class="language-makefile"># 編譯器設定
CC = gcc
CXX = g++
CFLAGS = -O3 -Wall -Wextra
CXXFLAGS = -O3 -Wall -Wextra -std=c++17
LDFLAGS = -lbenchmark -pthread

# 目錄
SRC_DIR = src
BENCH_DIR = benchmark
BUILD_DIR = build

# 原始檔
C_SOURCES = $(wildcard $(SRC_DIR)/*.c)
C_OBJECTS = $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(C_SOURCES))

# 基準測試
BENCH_SOURCES = $(wildcard $(BENCH_DIR)/*.cpp)
BENCH_TARGETS = $(patsubst $(BENCH_DIR)/%.cpp,$(BUILD_DIR)/%_bench,$(BENCH_SOURCES))

# 預設目標
all: $(BUILD_DIR) $(BENCH_TARGETS)

# 建立建構目錄
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# 編譯 C 原始檔
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
	$(CC) $(CFLAGS) -c $&lt; -o $@

# 編譯並連結基準測試
$(BUILD_DIR)/%_bench: $(BENCH_DIR)/%.cpp $(C_OBJECTS)
	$(CXX) $(CXXFLAGS) $&lt; $(C_OBJECTS) $(LDFLAGS) -o $@

# 執行所有基準測試
benchmark: $(BENCH_TARGETS)
	@for bench in $(BENCH_TARGETS); do \
		echo "Running $$bench..."; \
		$$bench; \
		echo ""; \
	done

# 執行並輸出 JSON
benchmark-json: $(BENCH_TARGETS)
	@for bench in $(BENCH_TARGETS); do \
		$$bench --benchmark_format=json &gt; $$bench.json; \
	done

# 清理
clean:
	rm -rf $(BUILD_DIR)

.PHONY: all benchmark benchmark-json clean
</code></pre>
<h3 id="cmakeliststxt-範例"><a class="header" href="#cmakeliststxt-範例">CMakeLists.txt 範例</a></h3>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.14)
project(MyProject LANGUAGES C CXX)

# 設定 C 和 C++ 標準
set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)

# 尋找 Google Benchmark
find_package(benchmark REQUIRED)

# C 函式庫
add_library(algorithms STATIC
    src/algorithms.c
    src/data_structures.c
)
target_include_directories(algorithms PUBLIC src)

# 基準測試執行檔
add_executable(bench_algorithms benchmark/bench_algorithms.cpp)
target_link_libraries(bench_algorithms
    algorithms
    benchmark::benchmark
)

# 新增測試目標
enable_testing()
add_test(NAME benchmark_test COMMAND bench_algorithms)
</code></pre>
<h2 id="編譯與執行"><a class="header" href="#編譯與執行">編譯與執行</a></h2>
<h3 id="基本編譯指令"><a class="header" href="#基本編譯指令">基本編譯指令</a></h3>
<pre><code class="language-bash"># 簡單編譯
g++ -std=c++17 -O3 my_benchmark.cpp -lbenchmark -pthread -o my_benchmark

# 混合 C 和 C++
gcc -O3 -c my_c_code.c -o my_c_code.o
g++ -std=c++17 -O3 -c my_benchmark.cpp -o my_benchmark.o
g++ my_benchmark.o my_c_code.o -lbenchmark -pthread -o my_benchmark
</code></pre>
<h3 id="執行選項"><a class="header" href="#執行選項">執行選項</a></h3>
<pre><code class="language-bash"># 基本執行
./my_benchmark

# 只執行符合模式的測試
./my_benchmark --benchmark_filter=BM_StringCreation

# 設定最小執行時間（秒）
./my_benchmark --benchmark_min_time=2.0s

# 輸出格式
./my_benchmark --benchmark_format=console  # 預設
./my_benchmark --benchmark_format=json
./my_benchmark --benchmark_format=csv

# 輸出到檔案
./my_benchmark --benchmark_out=results.json --benchmark_out_format=json

# 顯示記憶體使用
./my_benchmark --benchmark_memory_usage

# 設定重複次數
./my_benchmark --benchmark_repetitions=10

# 報告統計資料
./my_benchmark --benchmark_report_aggregates_only=true

# 列出所有測試但不執行
./my_benchmark --benchmark_list_tests

# 設定時間單位
./my_benchmark --benchmark_time_unit=ns  # ns, us, ms, s
</code></pre>
<h2 id="最佳實踐"><a class="header" href="#最佳實踐">最佳實踐</a></h2>
<h3 id="1-測試設計原則"><a class="header" href="#1-測試設計原則">1. 測試設計原則</a></h3>
<ul>
<li><strong>隔離測試目標</strong>：只測試你關心的程式碼部分</li>
<li><strong>避免 I/O 操作</strong>：除非你正在測試 I/O 效能</li>
<li><strong>使用合理的資料大小</strong>：測試實際使用場景</li>
<li><strong>考慮快取效應</strong>：第一次執行通常較慢</li>
</ul>
<h3 id="2-防止優化技巧"><a class="header" href="#2-防止優化技巧">2. 防止優化技巧</a></h3>
<pre><code class="language-cpp">// 防止編譯器優化掉變數
benchmark::DoNotOptimize(data);

// 確保記憶體寫入
benchmark::ClobberMemory();

// 組合使用
static void BM_Example(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto result = ComputeSomething();
    benchmark::DoNotOptimize(result);
    benchmark::ClobberMemory();
  }
}
</code></pre>
<h3 id="3-環境優化"><a class="header" href="#3-環境優化">3. 環境優化</a></h3>
<pre><code class="language-bash"># 設定 CPU 為效能模式
sudo cpupower frequency-set -g performance

# 關閉 CPU 頻率調整
echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo

# 綁定到特定 CPU 核心
taskset -c 0 ./my_benchmark

# 設定程序優先級
nice -n -20 ./my_benchmark
</code></pre>
<h3 id="4-程式碼組織建議"><a class="header" href="#4-程式碼組織建議">4. 程式碼組織建議</a></h3>
<pre><code class="language-cpp">// 將相關測試分組
namespace {
  // 測試資料準備
  std::vector&lt;int&gt; GenerateTestData(size_t size) {
    std::vector&lt;int&gt; data(size);
    std::iota(data.begin(), data.end(), 0);
    std::shuffle(data.begin(), data.end(), std::mt19937{42});
    return data;
  }

  // 基準測試群組
  void RegisterSortingBenchmarks() {
    BENCHMARK(BM_BubbleSort)-&gt;Range(8, 8&lt;&lt;10);
    BENCHMARK(BM_QuickSort)-&gt;Range(8, 8&lt;&lt;10);
    BENCHMARK(BM_MergeSort)-&gt;Range(8, 8&lt;&lt;10);
  }
}

int main(int argc, char** argv) {
  RegisterSortingBenchmarks();
  ::benchmark::Initialize(&amp;argc, argv);
  ::benchmark::RunSpecifiedBenchmarks();
  return 0;
}
</code></pre>
<h2 id="輸出解讀"><a class="header" href="#輸出解讀">輸出解讀</a></h2>
<h3 id="基本輸出格式"><a class="header" href="#基本輸出格式">基本輸出格式</a></h3>
<pre><code>--------------------------------------------------------------------------
Benchmark                   Time             CPU   Iterations
--------------------------------------------------------------------------
BM_StringCreation        9.18 ns         9.17 ns     76143424
BM_StringCopy           30.5 ns         30.5 ns     22864488
BM_VectorSort/10        64.7 ns         64.7 ns     10744601
BM_VectorSort/100        815 ns          815 ns       854951
BM_VectorSort/1000     10183 ns        10183 ns        68647
</code></pre>
<h3 id="欄位說明"><a class="header" href="#欄位說明">欄位說明</a></h3>
<ul>
<li><strong>Benchmark</strong>: 測試名稱和參數</li>
<li><strong>Time</strong>: 實際經過時間（包含系統排程等）</li>
<li><strong>CPU</strong>: 純 CPU 執行時間</li>
<li><strong>Iterations</strong>: 執行次數</li>
</ul>
<h3 id="進階指標"><a class="header" href="#進階指標">進階指標</a></h3>
<pre><code>BM_DataProcess/1024     2145 ns      2145 ns    326224 1.79688GB/s 465.2k items/s
</code></pre>
<ul>
<li><strong>Throughput</strong>: 資料吞吐量（GB/s, MB/s, KB/s）</li>
<li><strong>Items/s</strong>: 每秒處理項目數</li>
</ul>
<h3 id="統計輸出"><a class="header" href="#統計輸出">統計輸出</a></h3>
<pre><code>BM_Example_mean         100 ns       100 ns        10
BM_Example_median        99 ns        99 ns        10
BM_Example_stddev         5 ns         5 ns        10
BM_Example_cv          5.00 %       5.00 %        10
</code></pre>
<ul>
<li><strong>mean</strong>: 平均值</li>
<li><strong>median</strong>: 中位數</li>
<li><strong>stddev</strong>: 標準差</li>
<li><strong>cv</strong>: 變異係數（stddev/mean）</li>
</ul>
<h3 id="複雜度分析"><a class="header" href="#複雜度分析">複雜度分析</a></h3>
<pre><code>BM_LinearSearch/10      146 ns       146 ns    4799450
BM_LinearSearch/100    1447 ns      1447 ns     483932
BM_LinearSearch/1000  14491 ns     14491 ns      48276
BM_LinearSearch_BigO   14.49 N      14.49 N
BM_LinearSearch_RMS        0 %          0 %
</code></pre>
<ul>
<li><strong>BigO</strong>: 演算法複雜度估計</li>
<li><strong>RMS</strong>: 均方根誤差</li>
</ul>
<h2 id="完整測試範例程式碼"><a class="header" href="#完整測試範例程式碼">完整測試範例程式碼</a></h2>
<h3 id="基本功能測試程式-test_basic_benchmarkcpp"><a class="header" href="#基本功能測試程式-test_basic_benchmarkcpp">基本功能測試程式 (test_basic_benchmark.cpp)</a></h3>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;
#include &lt;numeric&gt;
#include &lt;mutex&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;

// 1. 最簡單的範例
static void BM_StringCreation(benchmark::State&amp; state) {
  for (auto _ : state)
    std::string empty_string;
}
BENCHMARK(BM_StringCreation);

// 2. 測試含參數的函式
static void BM_VectorSort(benchmark::State&amp; state) {
  const int size = state.range(0);

  for (auto _ : state) {
    state.PauseTiming();
    std::vector&lt;int&gt; v(size);
    for (int i = 0; i &lt; size; i++) {
      v[i] = rand() % 1000;
    }
    state.ResumeTiming();

    std::sort(v.begin(), v.end());
  }
}
BENCHMARK(BM_VectorSort)-&gt;Range(8, 8&lt;&lt;10);
BENCHMARK(BM_VectorSort)-&gt;Args({10})-&gt;Args({100})-&gt;Args({1000});

// 3. 防止編譯器優化
static void BM_Calculation(benchmark::State&amp; state) {
  for (auto _ : state) {
    int sum = 0;
    for (int i = 0; i &lt; 1000; ++i) {
      sum += i;
    }
    benchmark::DoNotOptimize(sum);
  }
}
BENCHMARK(BM_Calculation);

// 4. 使用 Fixture（測試夾具）
class MyFixture : public benchmark::Fixture {
public:
  void SetUp(const ::benchmark::State&amp; state) override {
    data.resize(state.range(0));
    std::generate(data.begin(), data.end(), std::rand);
  }

  void TearDown(const ::benchmark::State&amp; state) override {
    data.clear();
  }

  std::vector&lt;int&gt; data;
};

BENCHMARK_DEFINE_F(MyFixture, SortTest)(benchmark::State&amp; state) {
  for (auto _ : state) {
    std::vector&lt;int&gt; local_data = data;
    std::sort(local_data.begin(), local_data.end());
  }
}
BENCHMARK_REGISTER_F(MyFixture, SortTest)-&gt;Range(8, 8&lt;&lt;10);

// 5. 多執行緒基準測試
static void BM_MultiThreaded(benchmark::State&amp; state) {
  static std::mutex mu;
  static int counter = 0;

  if (state.thread_index() == 0) {
    counter = 0;
  }

  for (auto _ : state) {
    std::lock_guard&lt;std::mutex&gt; lock(mu);
    ++counter;
  }
}
BENCHMARK(BM_MultiThreaded)-&gt;Threads(1);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(2);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(4);
BENCHMARK(BM_MultiThreaded)-&gt;Threads(8);
BENCHMARK(BM_MultiThreaded)-&gt;ThreadRange(1, 8);

// 6. 自訂計數器和吞吐量
void ProcessData(size_t bytes) {
  // 模擬資料處理
  volatile char* data = new char[bytes];
  for (size_t i = 0; i &lt; bytes; ++i) {
    data[i] = static_cast&lt;char&gt;(i);
  }
  delete[] data;
}

static void BM_DataProcessing(benchmark::State&amp; state) {
  const size_t bytes_per_iteration = 1024 * 1024;  // 1MB

  for (auto _ : state) {
    ProcessData(bytes_per_iteration);
  }

  state.SetBytesProcessed(state.iterations() * bytes_per_iteration);
  state.SetItemsProcessed(state.iterations() * 1000);
  state.counters["CustomMetric"] = benchmark::Counter(
    state.iterations() * 2.5,
    benchmark::Counter::kIsRate
  );
}
BENCHMARK(BM_DataProcessing);

// 7. 統計分析
static void BM_SomeFunction(benchmark::State&amp; state) {
  for (auto _ : state) {
    std::vector&lt;int&gt; v(100);
    std::iota(v.begin(), v.end(), 0);
    std::shuffle(v.begin(), v.end(), std::mt19937{42});
    benchmark::DoNotOptimize(v);
  }
}

BENCHMARK(BM_SomeFunction)
  -&gt;Repetitions(10)
  -&gt;ReportAggregatesOnly()
  -&gt;DisplayAggregatesOnly();

BENCHMARK(BM_SomeFunction)
  -&gt;Repetitions(5)
  -&gt;ComputeStatistics("max", [](const std::vector&lt;double&gt;&amp; v) -&gt; double {
    return *std::max_element(v.begin(), v.end());
  })
  -&gt;ComputeStatistics("min", [](const std::vector&lt;double&gt;&amp; v) -&gt; double {
    return *std::min_element(v.begin(), v.end());
  });

// 8. 模板基準測試
template &lt;typename T&gt;
static void BM_TemplateTest(benchmark::State&amp; state) {
  T value{};
  for (auto _ : state) {
    value += T(1);
    benchmark::DoNotOptimize(value);
  }
}

BENCHMARK_TEMPLATE(BM_TemplateTest, int);
BENCHMARK_TEMPLATE(BM_TemplateTest, double);

// 9. 防止優化技巧組合使用
int ComputeSomething() {
  int result = 0;
  for (int i = 0; i &lt; 100; ++i) {
    result += i * 2;
  }
  return result;
}

static void BM_Example(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto result = ComputeSomething();
    benchmark::DoNotOptimize(result);
    benchmark::ClobberMemory();
  }
}
BENCHMARK(BM_Example);

// Main function
BENCHMARK_MAIN();
</code></pre>
<h3 id="編譯和執行指令"><a class="header" href="#編譯和執行指令">編譯和執行指令</a></h3>
<pre><code class="language-bash"># 編譯基本測試程式
g++ -std=c++17 -O3 test_basic_benchmark.cpp -lbenchmark -pthread -o test_basic_benchmark

# 編譯 C 語言測試程式
gcc -O3 -c algorithms.c -o algorithms.o
g++ -std=c++17 -O3 test_c_benchmark.cpp algorithms.o -lbenchmark -pthread -o test_c_benchmark

# 執行測試
./test_basic_benchmark
./test_c_benchmark

# 執行特定測試
./test_basic_benchmark --benchmark_filter=BM_StringCreation

# 設定最小執行時間
./test_basic_benchmark --benchmark_min_time=0.5s

# 輸出到 JSON
./test_basic_benchmark --benchmark_format=json --benchmark_out=results.json
</code></pre>
<h2 id="疑難排解"><a class="header" href="#疑難排解">疑難排解</a></h2>
<h3 id="常見問題"><a class="header" href="#常見問題">常見問題</a></h3>
<ol>
<li>
<p><strong>結果不穩定</strong></p>
<ul>
<li>確保系統負載低</li>
<li>使用 <code>--benchmark_repetitions</code> 增加重複次數</li>
<li>考慮使用 CPU 隔離</li>
</ul>
</li>
<li>
<p><strong>測試時間太短</strong></p>
<ul>
<li>使用 <code>--benchmark_min_time</code> 增加最小執行時間</li>
<li>確保測試的工作量足夠</li>
</ul>
</li>
<li>
<p><strong>記憶體洩漏</strong></p>
<ul>
<li>使用 Valgrind 或 AddressSanitizer 檢查</li>
<li>確保 SetUp/TearDown 配對</li>
</ul>
</li>
<li>
<p><strong>連結錯誤</strong></p>
<ul>
<li>確認 <code>-lbenchmark -pthread</code> 連結選項</li>
<li>檢查函式庫安裝路徑</li>
</ul>
</li>
</ol>
<h2 id="參考資源"><a class="header" href="#參考資源">參考資源</a></h2>
<ul>
<li><a href="https://github.com/google/benchmark">Google Benchmark GitHub</a></li>
<li><a href="https://github.com/google/benchmark/blob/main/docs/user_guide.md">官方使用者指南</a></li>
<li><a href="https://groups.google.com/forum/#!forum/benchmark-discuss">Google Benchmark 討論群組</a></li>
<li><a href="https://www.youtube.com/watch?v=nXaxk27zwlk">CppCon 演講：Tuning C++</a></li>
</ul>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>Google Benchmark 是 C/C++ 效能測試的強大工具，提供了：</p>
<ul>
<li>精確的時間測量</li>
<li>自動化的統計分析</li>
<li>豐富的測試配置選項</li>
<li>良好的編譯器優化防護</li>
<li>支援 C 和 C++ 程式碼測試</li>
</ul>
<p>無論是簡單的函式測試還是複雜的多執行緒效能分析，Google Benchmark 都能提供可靠的測量結果，幫助開發者優化程式碼效能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../c++/benchmark.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../c++/乘以0.01和除以100哪個快.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../c++/benchmark.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../c++/乘以0.01和除以100哪個快.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
