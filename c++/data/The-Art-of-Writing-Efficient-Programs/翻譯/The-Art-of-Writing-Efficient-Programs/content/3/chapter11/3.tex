为什么标准里会提到UB？为什么没有为它指定结果？基于C++会在具有不同属性的各种硬件上使用这一事实，所产生的问题是:为什么标准不回到实现定义的行为上，去定义它呢？

上一节的最后一个示例为我们提供了一个完美的演示，以说明UB存在的理由。表示无限循环是UB，另一种说法是，标准不要求进入无限循环的程序有特定的结果(标准比这更微妙，某些形式的无限循环会导致程序挂起，但这些细节目前并不重要)。为了理解为什么会有这种规则，先来看看下面的代码:

\begin{lstlisting}[style=styleCXX]
size_t n1 = 0, n2 = 0;
void f(size_t n) {
	for (size_t j = 0; j != n; j += 2) ++n1; 
	for (size_t j = 0; j != n; j += 2) ++n2;
}
\end{lstlisting}

这两个循环是相同的，所以需要两次循环的开销(循环变量的增量和比较)。编译器显然应该通过折叠循环来进行优化:

\begin{lstlisting}[style=styleCXX]
void f(size_t n) {
	for (size_t j = 0; j != n; j += 2) ++n1, ++n2;
}
\end{lstlisting}

这种转换只有在第一个循环结束时才有效。否则，计数\texttt{n2}根本不会增加。在编译期间，不可能知道循环是否会结束——这取决于\texttt{n}。如果\texttt{n}是奇数，循环将永远运行下去(与有符号整数溢出不同，无符号类型大小的增量超过其最大值时很好定义，该值将回滚为零)。通常，编译器不可能知道某个特定的循环最终是否会终止(这是一个已知的NP完全问题)。假定每个循环最终都会终止，并允许进行无效的优化。这些优化可以使具有无限循环的程序无效，所以这种循环会认为是UB，这意味着编译器不必保留具有无限循环的行为。

为了避免过度简化这个问题，必须指出不在C++标准中定义UB的原因。引入UB是因为语言必须在不同类型的硬件上得到支持，其中一些情况在今天看可能是过时的。因为这是一本关于程序性能的书，所以将重点关注那些为了提高效率而存在，或者可以用来改进某些优化的UB。

下一节中，将看到更多的例子，说明编译器如何使用UB来发挥它(和开发者自己)的优势。




































