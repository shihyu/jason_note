第4章中详细讨论了数据组织对性能的影响，要是没有“热代码”，通常就会找到“热数据”。换句话说，如果运行时分布在大部分代码上，并且没有什么明显的优化机会，那么很可能在整个程序中有一些数据(一个或多个数据结构)正在访问，而这些访问限制了整体性能。

分析器没有显示出易于优化的结果，只能找到一些次优代码，但测试表明，只能从这些地方节省总运行时间的百分之一左右。除非知道要优化什么，否则很难找到提高此类代码性能的方法。 

现在知道了如何需要寻找“热数据”，那么应该怎么做呢？首先，若所有的数据访问通过函数调用完成，而不是直接读写公共数据成员，那么就容易了。即使这些访问函数本身不需要花费太多时间，也可以使用它们来对访问操作进行计数，这将直接显示哪些数据是热的。这种方法类似于代码分析，只不过不是查找多次执行的指令，而是查找多次访问的内存位置(有些数据文件将为进行此类测试，从而不需要检测代码)。再次回到设计准则，该准则规定了明确定义的接口，这些接口不公开内部细节，如内存中的数据布局——监视数据访问的能力是这种方法的另一个优点。

每个设计本身都涉及代码(组件、接口等)的组织和数据的组织。设计者可能还没有考虑具体的数据结构，但必须考虑数据流，每个组件都需要一些信息来完成其工作。系统的哪些部分生成这些信息？谁拥有这些信息？谁负责将这些信息交付给特定的组件或模块？计算通常会产生一些新的信息。再一次，应该送到哪里？谁将拥有这些数据？每一个设计都包含这样的数据流分析。若没有这样的数据流分析，那么需要通过接口的文档隐式地进行分析。信息流及其所有权可以从API上推断出来，但这就复杂了。 

当明确地描述了信息流，就知道在执行的每个步骤中出现了哪些数据，以及每个组件访问了哪些数据。还可以知道组件之间必须传输哪些数据，现在就可以考虑组织这些数据的方法了。

当涉及到数据组织时，在设计阶段可以采用两种方法。一种方法是依赖于接口来提供数据的抽象视图，同时隐藏有关其真实组织方式的所有细节。这是本章开始的第一个指导方针，最低限度的信息原则，需要发挥到极致。若有效，可以在以后需要时实现接口数据结构的优化。需要注意的是，设计一个不限制底层数据组织的接口是不可能的，而且这样做通常会付出很高的代价。若有一个有序的数据集合，是否允许在集合中间进行插入操作？如果答案是肯定的，数据将不会存储在类似数组的结构中，这种结构需要移动一半的元素以在中间打开一个空间(这是对实现的限制)。另一方面，如果坚定地拒绝限制，那么最终将会得到一个非常有限的接口，并且可能无法使用最快的算法(不尽早提交到特定数据组织的代价)。

第二种方法是将部分数据组织作为设计的一部分。这将降低实现的灵活性，但将放松对接口设计的一些限制。例如，为了按特定顺序访问数据，可以使用指向数据元素存储位置的索引。把间接访问的代价嵌入到系统架构的基础中，获得了数据访问的灵活性。元素可以以最佳方式存储，并且可以为任何类型的随机或有序访问正确的索引。\texttt{index\_tree}就是这种设计的例子。 

注意，在讨论如何为性能设计数据组织时，必须使用一些非常底层的概念。通常，像“通过指针访问”这样的细节会视为实现问题。但是在设计高性能系统时，必须考虑诸如缓存位置和间接引用之类的问题。 

最好的结果通常是通过结合这两种方法获得的:确定最重要的数据，并提出一个有效的组织方式。当然，不需要特别细，若程序多次搜索大量字符串，这时可能需要将所有字符串存储在一个大的、连续的内存块中，并使用索引进行搜索和其他目标访问。然后，设计一个高级接口来构建索引，并通过迭代器使用它，但这种索引的确切组织留给实现。需要为接口施加了一些限制，例如：可以决定调用者在构建索引时，可以进行随机访问或使用双向迭代器，这反过来也会影响实现。 

并发系统的设计需要注意数据共享。设计阶段，应该注意将数据分类为非共享、只读或共享以便写入。当然，后者应该最小化。如在第6章中所看到的，访问共享数据的代价很高。另一方面，用于独占单线程访问的组件或数据结构重新设计为线程安全的是很困难的，而且会导致较差的性能(很难将线程安全移植到根本不安全的设计上)。在数据流分析的设计阶段，应该花时间明确定义数据所有权和访问限制。因为“数据所有权”通常指的是非常底层的细节，比如“是否使用智能指针，以及哪个类拥有它？”，可能更适合讨论信息所有权和获取信息的途径。必须同时对可用的信息片段进行分类，确定哪个组件产生和拥有信息，哪些组件修改信息，以及是否并发执行。设计应该通过访问对所有数据进行高级分类:单线程(独占)、只读或共享。注意，这些角色可能会随时间而改变:一些数据可能由单个线程生成，但稍后会被多个线程读取。这也应该反映在设计中。 

将数据流或信息流视为设计的一部分的总体指导方针会经常被开发者遗忘，但其他方面还是相当简单的。更具体的指导原则是考虑数据组织限制和接口的组合，这在设计过程中给实现留下了很大的发挥空间，这通常会看作为\textit{过早的优化}。许多开发者会坚持认为“缓存局部化”在设计阶段不需要，当我们将性能作为设计目标之一时，这里确实需要做出的妥协。系统设计期间，经常需要权衡这些相互竞争的因素，从而将我们引入了在为设计为性能时，需要进行利弊权衡的话题。



































