
设计往往是妥协的艺术，有一些相互竞争的目标和要求必须得到平衡。本节中，将具体讨论与性能相关的权衡。在设计高性能系统时，需要做出许多这样的决定。以下是需要注意的问题。

\subsubsubsection{12.6.1\hspace{0.2cm}接口设计}

本章中，已经看到了尽可能少地公开实现的好处，但从中获得的优化自由与非常抽象的接口的成本之间存在着矛盾。 

这种矛盾关系需要在优化不同的组件之间进行权衡，不以任何方式限制实现的接口通常会对客户端造成相当严重的限制。在不限制其实施的情况下，能做什么？不允许任何插入操作，除非在末尾(实现可以是一个\texttt{vector}，复制集合的一半在性能上是不可接受的)。只能追加到末尾，这意味着不能保持有序，例如：不允许随机访问(集合可以存储在列表中)。如果压缩集合，可能无法提供反向迭代器。给实现者留下几乎无限自由的点集合，现在只能使用前向迭代器(流访问)和追加操作。即使是后者也是一种限制，一些压缩方案要求在读取数据之前对数据进行处理，因此集合可以处于只写或只读状态。

给出这个示例，并不是为了演示追求与实现无关的API如何导致对客户端的限制。恰恰相反，这是处理大量数据的有效设计。集合通过添加到末尾进行写入，在写入完成之前，数据没有特定的顺序，最终可能包括排序和压缩。要读取集合，需要动态地解压缩它(如果压缩算法同时在几个点上工作，需要一个缓冲区来保存未压缩的数据)。如果集合需要编辑，可以使用在第4章中介绍的算法，来实现内存高效的编辑或字符串，总是从头到尾读取整个集合，并根据需要修改每个点，添加新的点等。将结果写入新的集合，并最终删除原来的集合。这种设计允许非常高效的数据存储，无论是在内存使用(高压缩)方面，还是在高效的内存访问方面(仅缓存友好的顺序访问)。还要求客户端实现流访问和读-改-写的所有操作。 

如果分析数据的访问模式，并认为可以接受流访问和读-改-写更新，那么可以将其作为设计的一部分。当然，不是特定的压缩方案，而是高级的数据组织。在读取之前，必须完成写入，修改数据的唯一方法是将整个集合复制到一个新集合中，在复制期间根据需要修改内容。 

关于这种权衡的一个观察是，不仅可能必须在性能需求与易用性或其他设计考虑之间进行平衡，而且通常还需要决定性能的哪个方面更为重要。应该优先考虑底层组件，体系结构对整体设计来说比高级组件的算法选择更重要。因此，以后更改会更加困难，这使得做出明智的设计决策变得更加重要。注意，在设计组件时，还需要进行必要的权衡。 

\subsubsubsection{12.6.2\hspace{0.2cm}组件设计}

有时候组件要想在设计上有很好的性能，就必须对其他组件进行限制，而其他组件的性能则需要谨慎地选择算法和成熟地实现。但这不是必须做出的唯一权衡。 

在性能设计中，最常见的平衡行为是为组件和模块选择适当的粒度。制作小组件通常是一种很好的设计实践，特别是在测试驱动的设计中(通常在以可测试性为目标的设计中进行)。另外，将系统分割成分割成许多块，并且这些块之间的交互受到限制，则会对性能不利。通常，将较大的数据和代码单元视为单个组件可以让实现更高效。同样，点集合就是一个例子。若允许无限制地访问集合内的点对象，那么效率会更高。 

最后，这些决定应该通过考虑相互冲突的要求和机会来解决矛盾。最好将一个点作为独立的单元，并在其他代码中可测试和重用。但是，真的需要将点集合公开为这些点单元的集合吗？或许，可以将其视为包含所存储点信息的集合，而每次创建一个点对象只是为了将点读写到集合中。这种方法可以保持良好的模块化，并实现高性能。通常，接口是根据清晰且可测试的组件实现的。而在内部，较大的组件以完全不同的格式存储数据。 

应该避免的是在接口中创建“后门”，这些“后门”是专门为绕过遵循良好设计实践而设计的，但现在出现了性能限制。这通常以一种特殊的方式折衷了两个相互竞争的设计目标。相反，最好的方式是重新设计涉及的组件。如果没有找到解决相互矛盾的需求的方法，那么将较小的单元放入内部的、特定于实现的子组件中是个不错的方法。

到目前为止，我们对设计的另一个方面\textit{错误处理}不是很关注，因此这里不会说的太多。

\subsubsubsection{12.6.3\hspace{0.2cm}错误和未定义行为}

错误处理经常当作事后考虑的事情之一，但在设计决策时也应该是挺重要的因素。特别是，对于一个在设计时没有考虑到特定异常处理方法的程序，要将异常安全性(以及扩展为错误安全性)添加进去是非常困难的。

错误处理从接口开始，所有接口本质上都是控制组件之间交互的约定。这些约定应该包括对输入数据的限制，若满足某些外部条件，组件将按照指定的方式运行。但是约定还应该指定如果条件不满足，组件则不能履行约定(或者开发者认为这样做不合适或太困难)会发生什么。 

这个错误响应的大部分也应该包含在约定中，若指定的需求没有得到满足，组件将以某种方式报告错误。这可以是异常、错误代码、状态标志或其他方法或组合。还有一些书是关于错误处理的最佳实践的，不过本书关注的是性能。

从性能的角度来看，在更常见的情况下，当输入和结果是正确的，并且没有发生糟糕的事情时，最重要的考虑因素通常是处理潜在错误的开销，通常简单地表达为“错误处理必须廉价”。

这意味着，在正常的、无错误的情况下，错误处理必须是廉价的。相反，当这种罕见的事件发生时，通常不关心处理错误的代价。这需要根据具体内容因设计而异。 

例如，在处理事务的应用程序中，通常需要提交或回滚语义。每个事务要么成功，要么什么都不做。然而，这种设计的性能成本可能很高。通常，失败的事务仍会影响一些更改是可以接受的，只要这些更改不改变系统的主要不变量。对于基于磁盘的数据库，浪费一些磁盘空间也是可以接受的。然后，可以为事务分配空间并写入磁盘，但在发生错误的情况下，可以让用户不可访问写入的区域。

这种情况下，为了提高性能而“隐藏”错误的全部后果，最好设计一个单独的机制来清除这些错误的后果。对于数据库，这样的清理可以在一个单独的低优先级的后台进程中进行，以避免干扰主要访问线程。因为，这是一个通过及时分离来解决矛盾的例子。若必须从错误中恢复，那这么做代价太大，那么代价大的部分可以往后放一放再进行处理。

最后，必须考虑这种可能性。即在某些情况下，即使是发现违反约定的行为，但代价太大，第11章就出现过这样的场景。接口约定应明确说明，如果违反了某些限制，则结果是不确定的。如果选择这种方法，不要让程序花时间使未定义的结果更“可接受”。未定义意味任何事情都有可能发生。这不应该轻易地完成，应该考虑替代方法，例如轻量级数据的收集，将耗时的工作留给发生真正错误时处理的代码。但是，明确约定的边界和不确定的结果要比“我们将尽最大努力，但没有承诺”这样不确定的方案要好。 

在设计阶段需要做出许多的权衡，本章并不意味着是一个完整的权衡列表或实现全面平衡的指南。相反，我们展示了几个常见的矛盾和解决它们的方法。 

为了在平衡性能设计目标与其他目标和动机时做出明智的决定，有一些性能估计就很重要了。但如何在设计初期就获得性能指标呢？这是我们符性能设计讨论的最后一部分，在某种程度上也是最难的一部分。














