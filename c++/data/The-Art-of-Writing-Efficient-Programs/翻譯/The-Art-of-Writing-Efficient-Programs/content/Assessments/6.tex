\begin{enumerate}
\item 
基于锁的程序，不能保证在随时都朝着最终目标做有用的工作。无锁程序，至少有一个线程保证会取得这样的进展。无等待的程序，所有的线程都会朝着最终目标前进。

\item 
应该从算法的角度来理解“无等待”，每个线程完成算法的一个步骤，然后立即转移到下一个步骤，并且计算的结果不会因为线程同步而浪费或丢弃。这并不意味着当计算机运行多个线程时，特定步骤所花费的时间与运行一个线程时相同，其中对硬件访问的争夺仍然存在。

\item 
锁最常见的缺点是成本较高，这并不是避免使用它的主要原因。好的算法常常可以减少数据共享的数量，以至于锁本身的成本不是主要问题。更严重的问题是需要细粒度数据同步的程序中，管理多个锁的复杂性。锁定大量数据意味着只有一个线程可以操作所有锁定的数据，但是对小块数据使用多个锁会导致死锁，或者使锁的管理变的复杂。

\item
差异不在于计数器本身的实现，而在于数据依赖。计数器没有依赖项，因此不需要提供任何内存序保证。另一方面，索引应该确保当线程读取这个索引值时，特定值索引的数组或容器元素对线程是可见的。

\item
发布协议的关键特性是，允许许多使用者线程在不锁定的情况下访问相同的数据。同时，保证使用者在访问该数据之前，生产者线程生成的数据是可见的。

\end{enumerate}