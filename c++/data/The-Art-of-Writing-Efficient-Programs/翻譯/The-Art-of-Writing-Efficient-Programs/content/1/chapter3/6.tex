

现在了解流水线如何使CPU保持忙碌，以及通过推测预测条件分支的结果，执行预期的代码，在确定执行之前，可以让条件代码流水线化。图3.21描述了这种方法：通过假设循环的结束条件不会在当前的迭代之后发生，可以将下一次迭代的指令与当前迭代的指令交叉，这样就有更多的指令可以并行执行。

无论如何，预测都会出错，做的就是放弃一些不应该计算的结果，看起来像是从未计算过一样。这需要花费一些时间，当分支预测正确时，可以通过加快流水线的速度来补足这个时间。这就是要掩盖执行一些不必要操作的真实原因吗？

图3.21中，若第i次迭代是循环中最后一次迭代，那么下一次迭代不应该发生。当然，可以丢弃\texttt{a[i+1]}，不将其写入内存。但为了流水线操作，必须读取\texttt{v1[i+1]}，在检查迭代i是否是最后一次迭代之前访问了\texttt{v1[i+1]}。元素\texttt{v1[i+1]}在为数组分配的有效内存区域外，读取它会导致未定义行为。

在\textit{投机执行}的无害标签后面还隐藏着危险:

\begin{lstlisting}[style=styleCXX]
int f(int* p) {
	if (p) {
		return *p;
	} else {
		return 0;
	}
}
\end{lstlisting}

假设指针\texttt{p}很少为\texttt{NULL}，所以分支预测器知道\texttt{if(p)}语句常走真分支。当\texttt{p == NULL}时会发生什么？分支预测器会像往常一样推测地真正执行的分支，而后就是解引用空指针，接下来程序会崩溃。之后，我们会发现不应该走那个分支，但怎么修复崩溃呢？

事实上，像函数\texttt{f()}这样的代码很常见，并且不会受到随机崩溃的影响。我们可以得出这样的结论:要么预测执行并不存在，要么有一种方法可以避免崩溃。已经看到一些证据表明投机执行确实有发生，并且对于提高性能非常有效。那么，当尝试做一些不可能的事情时，比如解引用\texttt{NULL}指针，如何处理这种情况呢？对这种灾难的响应必须保持挂起，在分支条件评估之前，既不丢弃也不执行，处理器知道推测执行是否应该执行。这样，错误和其他无效的条件与普通的内存写入没有任何区别：只要动作指令仍具有推测性，那么撤消的动作就有可能发生。CPU必须有特殊的硬件电路(如缓冲区)来存储这些。最终，处理器确实在推测执行期间取消了空指针的引用，或读取了不存在的数组元素\texttt{v[i+1]}，然后假装它从未发生过。

已经理解了分支预测和投机执行，如何让处理器在数据和代码依赖关系产生不确定的情况下高效地运行。接下来，就可以将注意力转向程序优化了。





























































