
除了编译时间，C++项目中导致长构建时间的主要原因，通常是目标或文件之间不必要的依赖关系。若目标之间有不必要的链接要求，则构建系统将限制并行执行构建任务，并且目标将频繁地重新链接。如第6章所述，创建目标的依赖关系图有助于识别依赖关系。若生成的图看起来更像一条绳子，而不是一棵树，那么优化和重构项目结构可能会带来很多性能提升。第7章将代码质量工具与CMake无缝集成，介绍了包含所使用的工具并链接所使用的工具，这类工具可以进一步帮助识别不必要的依赖。另一个常见的问题是C或C++项目在公共头文件中暴露了太多的私有信息，经常导致频繁的重构并降低增量构建的有效性。

一个相对安全提高性能的选项是将CMAKE\_OPTIMIZE\_DEPENDENCIES缓存变量设置为true，这将使CMake在生成时删除一些不需要的静态或对象库的依赖项。若使用大量静态或对象库以及深度依赖图，这可能会在编译时间方面产生了一些收益。

一般来说，优化项目结构和代码模块化，通常比优化代码对构建性能的影响更大。编译和链接一个由许多小文件组成的项目，要比由几个大文件组成的项目花费更多的时间。CMake可以通过统一构建帮助提高构建性能，将几个文件合并为一个更大的文件。

\subsubsubsection{14.4.1\hspace{0.2cm}统一构建}

CMake的统一构建，可以通过将多个文件连接成更大的文件来提高构建性能，从而减少需要编译的文件数量。因为包含文件只处理一次，而不是对每个小文件都进行处理，所以这可能会减少构建时间。因此，若许多文件包含相同的头文件，并且编译器难以消化头文件，这将产生很大的效果。通常，这些头文件包含大量宏或模板元编程。创建统一构建可以显著提高构建时间，特别是当使用大型头文件库时，如数学特征库。另一方面，统一构建也有缺点，即增量构建可能需要更长的时间。当只有单个文件发生更改时，项目才需要重新编译和链接。

通过将CMAKE\_UNITY\_BUILD缓存变量设置为true, CMake将把源合并为一个或多个统一源并构建它们。生成的文件使用unity\_<lang>\_<Nr>.<lang>模式和位于项目构建目录下名为Unity的文件夹中。C++的Unity文件将命名为unity\_0\_cxx.cxx、unity\_1\_cxx.cxx等，C文件命名为unity\_0\_c.c等。这个变量不需要在CMakeLists.txt中设置，而是通过命令行或预设传递，因为它可能取决于是否需要统一构建。若需要并且可能合并文件，CMake将决定项目的语言。例如，由于头文件没有编译，其不会添加到统一源中。对于C和C++，这没问题;对于其他语言，这可能没什么用。

统一构建最适合由许多小文件组成的项目，若源文件本身已经很大，那么在编译时统一构建可能会出现内存耗尽的风险。若只有少数文件在这方面有问题，可以通过设置SKIP\_UNITY\_BUILD\_INCLUSION属性的源文件从统一构建中排除:

\begin{lstlisting}[style=styleCMake]
target_sources(ch14_unity_build PRIVATE
	src/main.cpp
	src/fibonacci.cpp
	src/eratosthenes.cpp
)

set_source_files_properties(src/eratosthenes.cpp PROPERTIES
	SKIP_UNITY_BUILD_INCLUSION YES)
\end{lstlisting}

这个例子中，eratosthenes.cpp文件将从统一构建中排除，而main.cpp和fibonacci.cpp将包含在单个编译单元中。若前面的项目已经配置，unit\_0\_cxx.cxx文件将包含如下内容:

\begin{lstlisting}[style=styleCXX]
/* generated by CMake */

#include "/chapter14/unity_build/src/main.cpp"
#include "/chapter14/unity_build/src/fibonacci.cpp"
\end{lstlisting}

注意，原始源文件只包含在统一文件中，而不是复制到文件中。

自CMake 3.18起，统一构建支持两种模式，由CMAKE\_UNITY\_BUILD\_MODE或UNITY\_BUILD\_MODE目标属性控制。该模式可以是BATCH或GROUP，默认为BATCH。BATCH模式中，CMake根据添加到目标中的顺序，确定默认情况下将哪些文件分组在一起。目标中的所有文件都将分配到统一批文件中，除非明确地进行排除。GROUP模式中，每个目标必须显式指定如何将文件分组在一起，未分配给组的文件将单独编译。虽然组模式提供了更精确的控制，但使用BATCH模式通常是首选的模式，因为它降低了维护成本。

默认情况下，当UNITY\_BUILD\_MODE属性设置为BATCH时，CMake将批量收集8个文件。通过设置目标的UNITY\_BUILD\_BATCH\_SIZE属性进行修改。要进行全局的批处理大小设置，可以使用CMAKE\_UNITY\_BUILD\_BATCH\_SIZE缓存变量。批处理大小应该谨慎选择，若设置得过低不会带来什么性能提升，而设置得太高可能会导致编译器使用过多内存或编译单元触发某些限制。若批处理大小设置为0，那么目标的所有文件将合并到一个批处理中，但是由于前面提到的原因，不建议这样做。

GROUP模式下，不应用批处理大小，但文件必须通过设置源文件的UNITY\_GROUP属性分配给组:

\begin{lstlisting}[style=styleCMake]
add_executable(ch14_unity_build_group)

target_sources(ch14_unity_build_group PRIVATE
	src/main.cpp
	src/fibonacci.cpp
	src/eratosthenes.cpp
	src/pythagoras.cpp
)
set_target_properties(ch14_unity_build_group PROPERTIES
	UNITY_BUILD_MODE GROUP)
set_source_files_properties(src/main.cpp src/fibonacci.cpp
	PROPERTIES UNITY_GROUP group1)
set_source_files_properties(src/erathostenes.cpp
	src/pythagoras.cpp PROPERTIES UNITY_GROUP group2)
\end{lstlisting}

本例中，main.cpp和fibonacci.cpp文件将分在一起，erathostenes.cpp和pythagoras.cpp将在不同的组中进行编译。GROUP模式下，生成的文件命名为unity\_<groupName>\_<lang>.<lang>。本例中，文件将命名为unity\_group1\_cxx.cxx和unity\_group2\_cxx.cxx。

根据项目的结构，使用统一构建可以对构建性能产生显著影响。另一种经常用于提高构建时间的技术是预编译头文件。

\subsubsubsection{14.4.2\hspace{0.2cm}预编译头文件}

预编译头文件可以显著提高编译时间，特别是在处理头文件是编译时间的重要组成部分，或头文件包含在许多不同编译单元中的情况下。预编译头文件是通过将一些头文件编译成二进制格式来工作的，这种二进制格式对编译器来说更容易处理。从CMake 3.16开始，直接支持预编译头文件，并且大多数主要编译器都支持某种形式的预编译头文件。

可以使用\texttt{target\_precompile\_headers}指令将预编译头文件添加到目标文件中:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(<target>
	<INTERFACE|PUBLIC|PRIVATE> [header1...]
	[<INTERFACE|PUBLIC|PRIVATE> [header2...] ...])
\end{lstlisting}

PRIVATE、PUBLIC和INTERFACE关键字具有通常的含义。大多数情况下，应该使用PRIVATE。指令中指定的头文件将收集在编译文件夹中cmake\_pch.h或cmake\_pch.hxx文件中，通过相应的编译器标志强制包含在所有源文件中，因此源文件不需要\#include "cmake\_pch.h"。

头文件可以指定为普通文件名，用尖括号，或者用双引号，这里必须用双方括号进行转义:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(SomeTarget PRIVATE myHeader.h
	[["external_header.h"]]
	  <unordered_map>
)
\end{lstlisting}

本例中，将从当前源目录中搜索myHeader.h，而在include目录中搜索external\_header.h和unordered\_map头文件。

大型项目中，多个目标中使用的预编译头文件很常见。可以使用\texttt{target\_precompile\_headers}的REUSE\_FROM选项，而不是每次都重新定义:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(<target> REUSE_FROM
	<other_target>)
\end{lstlisting}

重用预编译的头文件会自动从target引入对other\_target的依赖。两个目标都将启用相同的编译器选项、标志和定义。若不是这样，有些编译器就会发出警告。

只有在当前目标没有定义自己的预编译头文件集时，才能使用来自另一个目标的预编译头文件。若目标已经定义了预编译的头文件，CMake将报错。

预编译头文件在包含的头文件很少更改时，对缩短构建时间非常有效。编译器、系统或外部依赖项提供的头文件通常都可以包含在预编译头文件中。哪些头文件带来的好处最大，这需要尝试和衡量。

与统一构建一起，预编译头文件可以显著提高编译时间，特别是对于头文件频繁重用的项目。优化增量构建时间的第三种方法是使用编译器缓存，即ccache。

\subsubsubsection{14.4.3\hspace{0.2cm}编译器缓存(ccache)加速重建}

ccache的工作原理是缓存编译，并检测何时再次完成相同的编译。撰写本书时，缓存编译结果的最流行的程序是ccache，它是在LGPL 3下发布的开源程序，还不支持Visual Studio。只要在两次运行之间不删除缓存，ccache不仅会进行增量构建，还会影响新的构建。创建的缓存在相同编译器系统间可移植，并且可以存储在远程数据库中，这样多个开发人员可以访问相同的缓存。ccache官方支持GCC、Clang和NVCC，但也有人声称已经在MSVC和Intel编译器上运行过。将ccache与CMake一起使用时，它与Makefile和Ninja生成器一起使用的效果最好。

要在CMake中使用ccache，需要使用CMAKE\_<LANG>\_COMPILER\_LAUNCHER缓存变量，其中<LANG>可替换为相应的编程语言。推荐的方法是使用预设值，但是要在CMakeLists.txt中为C和C++启用ccache，可以使用以下代码:

\begin{lstlisting}[style=styleCMake]
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
	set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM})
	set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM})
endif()
\end{lstlisting}

从预设值或命令行传递变量也是很好的替代方法，使用环境变量完成ccache的配置。

使用默认配置的ccache可能已经在构建时间方面带来了相当大的改进，但若构建稍微复杂一点，可能需要进一步配置。要配置ccache，可以使用以CCACHE\_开头的某些环境变量;有关所有配置选项的完整文档，请参阅ccache文档。需要特别注意的常见场景包括:将ccache与预编译头相结合，使用\texttt{FetchContent}管理包含的依赖项，以及将ccache与其他编译器包装器相结合，例如用于分布式构建的distcc或icecc。对于这些场景，需要使用以下环境变量：

\begin{itemize}
\item 
为了使用预编译头文件，可将CCACHE\_SLOPPINESS设置为pch\_defines,time\_macros。这样，ccache不能检测到预编译头文件中\#define的更改，也不能判断在创建预编译头文件时是否使用了\_\_TIME\_\_、\_\_DATE\_\_或\_\_TIMESTAMP\_\_。或将include\_file\_mtime设置到CCACHE\_SLOPPINESS中，可能会进一步提高缓存命中，但也会带来可以忽略的条件竞争。

\item 
当从源代码构建的大型依赖时，例如：通过\texttt{FetchContent}，将CCACHE\_BASEDIR设置为CMAKE\_BINARY\_DIR可能会提高缓存命中率，这可能会带来性能的提升，特别是当有许多(子)项目具有相同的依赖项时。另一方面，若项目本身的源代码需要花费更多的时间来编译，则将其设置为CMAKE\_SOURCE\_DIR可能会带来更好的结果。但这也需要试验，以了解哪种方法能带来更好的结果。

\item 
为了与其他编译器包装器一起工作，使用CCACHE\_PREFIX环境变量可以为其他编译器包装器添加命令在链接多个包装器时，建议首先使用ccache，这样其他包装器的结果也可以缓存。
\end{itemize}

推荐的做法是使用第9章中描述的配置预设值，将环境变量传递给CMake。这可以与检测CMakeLists.txt中的ccache相结合，也可以使用以下预设来传递ccache命令:

\begin{lstlisting}[style=styleCMake]
{
	"name" : "ccache-env",
	...
	"environment": {
		"CCACHE_BASEDIR" : "${sourceDir}",
		"CCACHE_SLOPPINESS" : "pch_defines,time_macros"
	}
},
\end{lstlisting}

使用这些配置，ccache可以在编译时间方面带来非常大的好处，但缓存编译器结果是一个挺复杂的问题，因此要获得全部好处，应该参考ccache的文档。使用ccache可能通过相对简单的设置，就能带来最大的性能优势。其他工具，如用于分布式构建的distcc，从CMake的角度来看工作非常类似，但需要更多的设置工作。

\subsubsubsection{14.4.4\hspace{0.2cm}分布式构建}

分布式构建，通过将部分编译转移到网络上的不同机器来工作。这需要设置可以接受连接的服务器，然后配置客户机，使其能够连接到这些服务器。使用以下命令为distcc设置服务器:

\begin{tcblisting}{commandshell={}}
distccd --daemon --allow client1 client2
\end{tcblisting}

client1和client2是各自构建服务器的主机名或IP地址。客户端通过将CMAKE\_<LANG>\_COMPILER\_LAUNCHER设置为distcc，配置CMake使用distcc将类似于ccache。服务器列表可以通过配置文件配置，也可以通过DISTCC\_HOSTS环境变量配置。与ccache配置不同，这是特定于主机的，因此配置应该放在用户预设中，而不是特定于项目的预设中。各自的预设可能看起来像这样:

\begin{lstlisting}[style=styleCMake]
{
	"name" : "distcc-env",
	...
	"environment": {
		"DISTCC_HOSTS" : "localhost buildsrvr1,cpp,lzo
		host123,cpp,lzo"
	}
},
\end{lstlisting}

注意buildsrvr1主机后面的cpp后缀。这将使distcc进入所谓的“泵模式”，这种模式通过将预处理分配到服务器来进一步提高编译速度。lzo后缀说明distcc使用的是压缩通信。

分布式构建的缺点是，为了获得速度优势，网络必须足够快，否则传输编译信息的成本可能高于减少的构建时间。在大多数本地网络中，这种情况很容易发生。若机器在处理器架构、编译器和操作系统方面相似，那么分布式构建可以很好地工作。虽然可以使用distcc进行交叉编译，但要进行设置可能需要相当多的工作。通过结合良好的编码实践，在大型项目中工作的预编译头文件和编译器缓存仍然可以工作，而不必为每次构建等待几分钟。










