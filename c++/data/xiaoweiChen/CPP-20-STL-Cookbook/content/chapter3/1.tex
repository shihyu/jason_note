
STL提供了一套全面的容器类型，包括顺序容器、关联容器和容器适配器。以下是简要的概述:

\subsubsection{顺序容器}

顺序容器提供了一个接口，其中元素按顺序排列。虽然可以按顺序使用元素，但其中一些容器使用连续存储，而其他容器则不使用。STL包含以下顺序容器:

\begin{itemize}
\item 
array是固定大小的序列，在连续存储器中保存特定数量的元素，分配之后就不能改变大小。这是最简单和访问速度最快的连续存储容器。

\item 
vector就像数组，可以缩小和扩大。其元素是连续存储的，因此改变大小可能涉及分配内存和移动数据的开销。vector可以保留额外的空间来降低操作成本。在vector容器后面以外的任何位置插入和删除元素将触发元素的重新排列，以保持内存的连续存储。

\item 
list是双链表结构，允许在常量(O(1))时间内插入和删除元素。遍历列表的时间为线性O(n)。单链表的变体是forward\_list，只能向前迭代。forward\_list会使用更少的空间，并且比双链表更高效，但缺少一些功能。

\item 
deque(通常发音为deck)是双端队列，是连续的容器，可以在两端展开或收缩。deque允许随机访问它的元素，很像vector，但不保证存储的连续性。
\end{itemize}

\subsubsection{关联容器}

关联容器将一个键与每个元素关联起来。元素是通过键来引用的，而不是其在容器中的位置。STL关联容器包括以下容器:

\begin{itemize}
\item 
set是一个关联容器，每个元素也是自己的键，元素通常按某种二叉树方式排序。set中的元素不可变，不能修改，但是可以插入和移除。set中的元素是唯一的，不允许重复。set可以根据排序操作符按顺序进行迭代。

\item 
multiset就像一个具有非唯一键的集合，允许重复。

\item 
unordered\_set就像一个不按顺序迭代的集合。元素不按特定顺序排序，而是根据哈希值进行组织，以便快速访问。

\item 
unordered\_multiset类似于unordered\_set，允许重复。

\item 
map是键-值对的关联容器，其中每个键都映射到特定的值(或有效负载)。键和值的类型可能不同；键是唯一的，但值不是。map根据其排序操作符，按键的顺序进行迭代。

\item 
multimap类似于具有非唯一键的映射，允许重复键。

\item 
unordered\_map就像一个没有按顺序迭代的map。

\item 
unordered\_multimap类似于unordered\_map，允许重复。
\end{itemize}

\subsubsection{容器适配器}

容器适配器是封装底层容器的类，容器类提供了一组特定的成员函数来访问底层容器元素。STL提供了以下容器适配器:

\begin{itemize}
\item 
stack提供了后进先出(LIFO)接口，该接口中只能从容器的一端添加和提取元素。底层容器可以是vector、deque或list中的一种。若没有指定底层容器，默认为deque。

\item 
queue提供了先进先出(FIFO)接口，其中元素可以在容器的一端添加，并从另一端提取。底层容器可以是deque或list容器之一。若没有指定底层容器，默认为deque。

\item 
priority\_queue按照严格的弱顺序将最大的值元素保持在顶部，以对数时间插入和提取为代价，提供了对最大值元素的常数时间查找。底层容器可以是vector或deque中的一个。若没有指定底层容器，默认为vector。
\end{itemize}

我们将讨论以下主题:

\begin{itemize}
\item 
使用擦除函数从容器中删除项

\item 
常数时间内从未排序的向量中删除项

\item 
安全地访问vector元素

\item 
保持vector元素的顺序

\item 
高效地将元素插入到map中

\item 
高效地修改map项的键值

\item 
自定义键值的unordered\_map

\item 
使用set对输入进行排序和筛选

\item 
简单的RPN计算器与deque

\item 
使用map的词频计数器

\item 
找出含有相应长句的vector

\item 
使用multimap制作待办事项列表
\end{itemize}












