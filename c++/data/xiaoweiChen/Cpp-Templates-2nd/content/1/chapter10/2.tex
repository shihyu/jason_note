处理使用模板的源代码时，C++编译器必须用具体的模板实参替换模板中的模板形参。有时，这种替换是暂时的:编译器可能需要检查替换是否有效(参见8.4节和15.7节)。

通过替换模板的具体参数，为模板中的常规类、类型别名、函数、成员函数或变量实际创建定义的过程，称为模板实例化。

但目前还没有标准或公认的术语，来表示通过模板参数替换来创建非定义声明的过程。我们已经看到了一些团队使用的部分实例化或声明的实例化，但这不通用。也许更直观的术语是不完全实例化(类模板的情况下，会生成不完整的类)。

由实例化或不完全实例化(即类、函数、成员函数或变量)产生的实体一般称为特化。

C++中实例化过程并不是产生特化的唯一方法。替代机制允许开发者显式地指定与模板参数的特殊替换绑定的声明。如在2.5节中看到的，这样的特化是通过前缀template<>引入的:

\begin{lstlisting}[style=styleCXX]
template<typename T1, typename T2> // primary class template
class MyClass {
  ...
};

template<> // explicit specialization
class MyClass<std::string,float> {
  ...
};
\end{lstlisting}

严格地说，这称为显式特化(与实例化或生成的特化相对)。

如2.6节所述，仍有模板参数的特化称为偏特化:

\begin{lstlisting}[style=styleCXX]
template<typename T> // partial specialization
class MyClass<T,T> {
  ...
};

template<typename T> // partial specialization
class MyClass<bool,T> {
  ...
};
\end{lstlisting}

当说到(显式或部分)特化时，通用模板也称为主模板。
