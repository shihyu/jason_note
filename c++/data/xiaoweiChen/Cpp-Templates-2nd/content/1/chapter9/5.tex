在头文件和CPP文件中组织源代码具有一定义规则或以ODR形式的结果。附录A对此规则进行了讨论。

包含模型是一个实用的方式，主要由C++编译器的现有实践决定。第一个C++实现很特殊:包含的模板定义是隐式的，从而造成了某种分离的错觉(参见第14章了解这个原始模型的详细信息)。

第一个C++标准([C++98])通过导出的模板对模板编译的分离模型提供了支持。分离模型允许标记导出的模板声明在头文件中声明，而它们相应的定义放在CPP文件中，非常像非模板代码的声明和定义。与包含模型不同的是，这个模型不基于现有实现的理论模型，而且实现本身比C++标准化委员预期的要复杂得多。它花了五年多的时间才发布了第一个实现(2002年5月)，此后的几年里没有出现其他实现。为了更好地使C++标准与现有的实践保持一致，标准化委员会在C++11中删除了导出模板。有兴趣了解更多分离模型细节(和陷阱)的读者可以阅读本书第一版的6.3和10.3节([VandevoordeJosuttisTemplates1st])。

有时很容易想象扩展预编译头概念的方法，以便在编译中加载多个头文件，这允许使用更细粒度的方法进行预编译。这里的障碍主要是预处理器:头文件中的宏可能会改变后续头文件的含义。然而，当文件预编译，宏处理就完成了，而试图为其他头文件引入的预处理器效果修订预编译头文件不现实。不久的将来，会有一个称为“模块”的新语言特性(参见17.11节)添加到C++中，来解决这个问题(宏定义不能泄露到模块接口中)。