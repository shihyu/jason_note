全特模板从一开始就是C++模板机制的一部分。另一方面，函数模板重载和类模板偏特化出现要晚得多。HP aC++编译器是第一个实现函数模板重载的，EDG的C++前端是第一个实现类模板偏特化的。本章描述的部分排序原则最初是由EDG的Steve Adamczyk和John Spicer发明。

模板特化终止无限递归模板定义的能力(如第16.4节中给出的List<T*>示例)由来已久。然而，Erwin Unruh可能是第一个注意到这可以进行模板元编程的人:使用模板实例化机制在编译时执行计算。我们会在第23章专门讨论这个话题。

可能想知道为什么只有类模板和变量模板可以偏特化，主要是历史原因。其实，也可以为函数模板定义相同的机制(参见第17章)。重载函数模板的效果类似，但有细微的差别。使用时，只需要查找主模板。特化只在使用后考虑，以确定应该使用哪种实现。相反，必须通过查找将所有重载函数模板引入重载集，而且它们可能来自不同的命名空间或类。这无意中增加了重载模板名称的可能性。

相反，可以想象允许重载类模板和变量模板的形式:

\begin{lstlisting}[style=styleCXX]
// invalid overloading of class templates
template<typename T1, typename T2> class Pair;
template<int N1, int N2> class Pair;
\end{lstlisting}

然而，对这样的机制，似乎并没有迫切的需求。