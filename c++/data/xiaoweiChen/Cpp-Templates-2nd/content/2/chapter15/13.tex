函数模板的模板参数推导是最初C++设计的一部分。事实上，由显式模板参数提供的替代方法，直到许多年后才成为C++的一部分。

SFINAE是本书第一版中介绍的术语，很快在整个C++编程社区中变得流行起来。在C++98中，SFINAE并不像现在这样强大:只应用于有限的类型操作集，并没有涵盖任意表达式或访问控制。随着越来越多的模板技术开始依赖SFINAE(见第19.4节)，推广SFINAE条件的必要性变得明显。Steve Adamczyk和John Spicer在C++11中(通过N2634)进行了开发实现。尽管标准中的措辞变化相对较小，但在一些编译器中实现的工作量却大得不成比例。

auto类型说明符和decltype构造最早在C++03引入，并成为C++11的一部分。他们的发展是由Bjarne Stroustrup和Jaakko J{\"a}rvi牵头的(参见他们的N1607关于auto类型说明符和N2343关于decltype)。

Stroustrup在最初的C++实现(称为Cfront)中已经考虑了auto语法。当这个特性在C++11中引入时，auto作为存储说明符(继承自C语言)的原始含义保留了下来，并且消除歧义规则决定了关键字应该如何解释。当爱迪生设计团队的前端实现这个特性时，David Vandevoorde发现这个规则可能会让C++11程序员(N2337)感到意外。研究了这个问题之后，标准化委员会通过论文N2546(David Vandevoorde和Jens Maurer)决定完全放弃auto的传统使用(C++03中使用关键字auto的地方，也可以忽略)。这是一个不寻常的先例，即从该语言中删除一个特性，而不先反对它，但后来证明这是一个正确的决定。

GNU的GCC编译器接受了与decltype特性类似的扩展类型，开发者发现它在模板编程中很有用。但其是在C语言环境中开发的特性，并不完全适合C++。因此，C++委员会既不能合并它，也不修改它，因为那样会破坏依赖于GCC行为的现有代码。这就是为什么decltype不拼写为typeof。Jason Merrill和其他人已经提出了强有力的论点，认为使用不同的操作符会更好，而不是使用现在decltype(x)和decltype((x))不同的方式，但他们没有足够的说服力来改变最终的规范。

C++17中使用auto声明非类型模板参数的能力主要是由Mike Spertus在James Touton、David Vandevoorde和其他人一起开发的。该特性的更改在P0127R2中提出。尚不清楚是否有意使用decltype(auto)代替auto成为该语言的一部分(显然，委员会未对此进行讨论，但这超出了规范的范畴)。

Mike Spertus还推动了C++17中类模板参数推导的开发，Richard Smith和Faisal Vali贡献了重要的技术思想(包括推导指引的思想)。P0091R3是会纳入了下一个语言标准的工作论文。

结构化绑定主要由Herb Sutter驱动，他与Gabriel Dos Reis和Bjarne Stroustrup一起撰写了P0144R1，提出了该特性。委员会讨论期间进行了许多调整，包括使用括号来分隔分解标识符。Jens Maurer将该提案转化为标准的最终规范(P0217R3)。





