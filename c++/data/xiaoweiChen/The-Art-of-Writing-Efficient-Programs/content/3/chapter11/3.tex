為什麼標準裡會提到UB？為什麼沒有為它指定結果？基於C++會在具有不同屬性的各種硬件上使用這一事實，所產生的問題是:為什麼標準不回到實現定義的行為上，去定義它呢？

上一節的最後一個示例為我們提供了一個完美的演示，以說明UB存在的理由。表示無限循環是UB，另一種說法是，標準不要求進入無限循環的程序有特定的結果(標準比這更微妙，某些形式的無限循環會導致程序掛起，但這些細節目前並不重要)。為了理解為什麼會有這種規則，先來看看下面的代碼:

\begin{lstlisting}[style=styleCXX]
size_t n1 = 0, n2 = 0;
void f(size_t n) {
	for (size_t j = 0; j != n; j += 2) ++n1; 
	for (size_t j = 0; j != n; j += 2) ++n2;
}
\end{lstlisting}

這兩個循環是相同的，所以需要兩次循環的開銷(循環變量的增量和比較)。編譯器顯然應該通過摺疊循環來進行優化:

\begin{lstlisting}[style=styleCXX]
void f(size_t n) {
	for (size_t j = 0; j != n; j += 2) ++n1, ++n2;
}
\end{lstlisting}

這種轉換隻有在第一個循環結束時才有效。否則，計數\texttt{n2}根本不會增加。在編譯期間，不可能知道循環是否會結束——這取決於\texttt{n}。如果\texttt{n}是奇數，循環將永遠運行下去(與有符號整數溢出不同，無符號類型大小的增量超過其最大值時很好定義，該值將回滾為零)。通常，編譯器不可能知道某個特定的循環最終是否會終止(這是一個已知的NP完全問題)。假定每個循環最終都會終止，並允許進行無效的優化。這些優化可以使具有無限循環的程序無效，所以這種循環會認為是UB，這意味著編譯器不必保留具有無限循環的行為。

為了避免過度簡化這個問題，必須指出不在C++標準中定義UB的原因。引入UB是因為語言必須在不同類型的硬件上得到支持，其中一些情況在今天看可能是過時的。因為這是一本關於程序性能的書，所以將重點關注那些為了提高效率而存在，或者可以用來改進某些優化的UB。

下一節中，將看到更多的例子，說明編譯器如何使用UB來發揮它(和開發者自己)的優勢。




































