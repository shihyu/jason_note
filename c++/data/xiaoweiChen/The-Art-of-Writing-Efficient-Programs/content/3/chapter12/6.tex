
設計往往是妥協的藝術，有一些相互競爭的目標和要求必須得到平衡。本節中，將具體討論與性能相關的權衡。在設計高性能系統時，需要做出許多這樣的決定。以下是需要注意的問題。

\subsubsubsection{12.6.1\hspace{0.2cm}接口設計}

本章中，已經看到了儘可能少地公開實現的好處，但從中獲得的優化自由與非常抽象的接口的成本之間存在著矛盾。 

這種矛盾關係需要在優化不同的組件之間進行權衡，不以任何方式限制實現的接口通常會對客戶端造成相當嚴重的限制。在不限制其實施的情況下，能做什麼？不允許任何插入操作，除非在末尾(實現可以是一個\texttt{vector}，複製集合的一半在性能上是不可接受的)。只能追加到末尾，這意味著不能保持有序，例如：不允許隨機訪問(集合可以存儲在列表中)。如果壓縮集合，可能無法提供反向迭代器。給實現者留下幾乎無限自由的點集合，現在只能使用前向迭代器(流訪問)和追加操作。即使是後者也是一種限制，一些壓縮方案要求在讀取數據之前對數據進行處理，因此集合可以處於只寫或只讀狀態。

給出這個示例，並不是為了演示追求與實現無關的API如何導致對客戶端的限制。恰恰相反，這是處理大量數據的有效設計。集合通過添加到末尾進行寫入，在寫入完成之前，數據沒有特定的順序，最終可能包括排序和壓縮。要讀取集合，需要動態地解壓縮它(如果壓縮算法同時在幾個點上工作，需要一個緩衝區來保存未壓縮的數據)。如果集合需要編輯，可以使用在第4章中介紹的算法，來實現內存高效的編輯或字符串，總是從頭到尾讀取整個集合，並根據需要修改每個點，添加新的點等。將結果寫入新的集合，並最終刪除原來的集合。這種設計允許非常高效的數據存儲，無論是在內存使用(高壓縮)方面，還是在高效的內存訪問方面(僅緩存友好的順序訪問)。還要求客戶端實現流訪問和讀-改-寫的所有操作。 

如果分析數據的訪問模式，並認為可以接受流訪問和讀-改-寫更新，那麼可以將其作為設計的一部分。當然，不是特定的壓縮方案，而是高級的數據組織。在讀取之前，必須完成寫入，修改數據的唯一方法是將整個集合複製到一個新集合中，在複製期間根據需要修改內容。 

關於這種權衡的一個觀察是，不僅可能必須在性能需求與易用性或其他設計考慮之間進行平衡，而且通常還需要決定性能的哪個方面更為重要。應該優先考慮底層組件，體系結構對整體設計來說比高級組件的算法選擇更重要。因此，以後更改會更加困難，這使得做出明智的設計決策變得更加重要。注意，在設計組件時，還需要進行必要的權衡。 

\subsubsubsection{12.6.2\hspace{0.2cm}組件設計}

有時候組件要想在設計上有很好的性能，就必須對其他組件進行限制，而其他組件的性能則需要謹慎地選擇算法和成熟地實現。但這不是必須做出的唯一權衡。 

在性能設計中，最常見的平衡行為是為組件和模塊選擇適當的粒度。製作小組件通常是一種很好的設計實踐，特別是在測試驅動的設計中(通常在以可測試性為目標的設計中進行)。另外，將系統分割成分割成許多塊，並且這些塊之間的交互受到限制，則會對性能不利。通常，將較大的數據和代碼單元視為單個組件可以讓實現更高效。同樣，點集合就是一個例子。若允許無限制地訪問集合內的點對象，那麼效率會更高。 

最後，這些決定應該通過考慮相互衝突的要求和機會來解決矛盾。最好將一個點作為獨立的單元，並在其他代碼中可測試和重用。但是，真的需要將點集合公開為這些點單元的集合嗎？或許，可以將其視為包含所存儲點信息的集合，而每次創建一個點對象只是為了將點讀寫到集合中。這種方法可以保持良好的模塊化，並實現高性能。通常，接口是根據清晰且可測試的組件實現的。而在內部，較大的組件以完全不同的格式存儲數據。 

應該避免的是在接口中創建“後門”，這些“後門”是專門為繞過遵循良好設計實踐而設計的，但現在出現了性能限制。這通常以一種特殊的方式折衷了兩個相互競爭的設計目標。相反，最好的方式是重新設計涉及的組件。如果沒有找到解決相互矛盾的需求的方法，那麼將較小的單元放入內部的、特定於實現的子組件中是個不錯的方法。

到目前為止，我們對設計的另一個方面\textit{錯誤處理}不是很關注，因此這裡不會說的太多。

\subsubsubsection{12.6.3\hspace{0.2cm}錯誤和未定義行為}

錯誤處理經常當作事後考慮的事情之一，但在設計決策時也應該是挺重要的因素。特別是，對於一個在設計時沒有考慮到特定異常處理方法的程序，要將異常安全性(以及擴展為錯誤安全性)添加進去是非常困難的。

錯誤處理從接口開始，所有接口本質上都是控制組件之間交互的約定。這些約定應該包括對輸入數據的限制，若滿足某些外部條件，組件將按照指定的方式運行。但是約定還應該指定如果條件不滿足，組件則不能履行約定(或者開發者認為這樣做不合適或太困難)會發生什麼。 

這個錯誤響應的大部分也應該包含在約定中，若指定的需求沒有得到滿足，組件將以某種方式報告錯誤。這可以是異常、錯誤代碼、狀態標誌或其他方法或組合。還有一些書是關於錯誤處理的最佳實踐的，不過本書關注的是性能。

從性能的角度來看，在更常見的情況下，當輸入和結果是正確的，並且沒有發生糟糕的事情時，最重要的考慮因素通常是處理潛在錯誤的開銷，通常簡單地表達為“錯誤處理必須廉價”。

這意味著，在正常的、無錯誤的情況下，錯誤處理必須是廉價的。相反，當這種罕見的事件發生時，通常不關心處理錯誤的代價。這需要根據具體內容因設計而異。 

例如，在處理事務的應用程序中，通常需要提交或回滾語義。每個事務要麼成功，要麼什麼都不做。然而，這種設計的性能成本可能很高。通常，失敗的事務仍會影響一些更改是可以接受的，只要這些更改不改變系統的主要不變量。對於基於磁盤的數據庫，浪費一些磁盤空間也是可以接受的。然後，可以為事務分配空間並寫入磁盤，但在發生錯誤的情況下，可以讓用戶不可訪問寫入的區域。

這種情況下，為了提高性能而“隱藏”錯誤的全部後果，最好設計一個單獨的機制來清除這些錯誤的後果。對於數據庫，這樣的清理可以在一個單獨的低優先級的後臺進程中進行，以避免幹擾主要訪問線程。因為，這是一個通過及時分離來解決矛盾的例子。若必須從錯誤中恢復，那這麼做代價太大，那麼代價大的部分可以往後放一放再進行處理。

最後，必須考慮這種可能性。即在某些情況下，即使是發現違反約定的行為，但代價太大，第11章就出現過這樣的場景。接口約定應明確說明，如果違反了某些限制，則結果是不確定的。如果選擇這種方法，不要讓程序花時間使未定義的結果更“可接受”。未定義意味任何事情都有可能發生。這不應該輕易地完成，應該考慮替代方法，例如輕量級數據的收集，將耗時的工作留給發生真正錯誤時處理的代碼。但是，明確約定的邊界和不確定的結果要比“我們將盡最大努力，但沒有承諾”這樣不確定的方案要好。 

在設計階段需要做出許多的權衡，本章並不意味著是一個完整的權衡列表或實現全面平衡的指南。相反，我們展示了幾個常見的矛盾和解決它們的方法。 

為了在平衡性能設計目標與其他目標和動機時做出明智的決定，有一些性能估計就很重要了。但如何在設計初期就獲得性能指標呢？這是我們符性能設計討論的最後一部分，在某種程度上也是最難的一部分。














