本章中，我們瞭解了C++內存模型，以及它給開發者的保證。需要對多線程通過共享數據進行交互時，所發生的詳細情況，進行全面的理解。

多線程程序中，對內存的非同步和無序訪問會導致未定義行為，必須避免。然而，成本通常是通過性能來支付的。雖然我們看重正確性，但當涉及到內存同步時，很容易為正確性付出過高的代價。我們已經瞭解了管理併發內存訪問的不同方法，以及優缺點。最簡單的選擇是鎖定對共享數據的所有訪問。另一方面，最複雜的實現使用原子操作，並儘可能少地限制內存序。

性能的第一條規則在這裡是完全有效的:\textit{性能必須測量，而不是猜測}。這對於併發程序來說尤為重要，在併發程序中，由於種種原因，聰明的優化可能無法產生可測量的結果。另一方面，可以保證的是，帶鎖的簡單程序更容易編寫，而且更有可能是正確的。

有了數據共享對性能影響的理解，就可以更好地理解測試結果，以及在什麼時候嘗試優化併發內存訪問。受內存序限制影響的代碼部分越大，放鬆這些限制就越有可能提高性能。請記住，有些限制來自硬件本身。

總的來說，這比在前面幾章中處理的任何內容都要複雜得多(不奇怪，併發通常就很難)。下一章將展示在不放棄性能優勢的情況下，瞭解在程序中如何管理這種複雜性的方法。還將看到如何將這裡學到的知識，應用於實際。





