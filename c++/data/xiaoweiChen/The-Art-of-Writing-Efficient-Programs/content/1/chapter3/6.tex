

現在瞭解流水線如何使CPU保持忙碌，以及通過推測預測條件分支的結果，執行預期的代碼，在確定執行之前，可以讓條件代碼流水線化。圖3.21描述了這種方法：通過假設循環的結束條件不會在當前的迭代之後發生，可以將下一次迭代的指令與當前迭代的指令交叉，這樣就有更多的指令可以並行執行。

無論如何，預測都會出錯，做的就是放棄一些不應該計算的結果，看起來像是從未計算過一樣。這需要花費一些時間，當分支預測正確時，可以通過加快流水線的速度來補足這個時間。這就是要掩蓋執行一些不必要操作的真實原因嗎？

圖3.21中，若第i次迭代是循環中最後一次迭代，那麼下一次迭代不應該發生。當然，可以丟棄\texttt{a[i+1]}，不將其寫入內存。但為了流水線操作，必須讀取\texttt{v1[i+1]}，在檢查迭代i是否是最後一次迭代之前訪問了\texttt{v1[i+1]}。元素\texttt{v1[i+1]}在為數組分配的有效內存區域外，讀取它會導致未定義行為。

在\textit{投機執行}的無害標籤後面還隱藏著危險:

\begin{lstlisting}[style=styleCXX]
int f(int* p) {
	if (p) {
		return *p;
	} else {
		return 0;
	}
}
\end{lstlisting}

假設指針\texttt{p}很少為\texttt{NULL}，所以分支預測器知道\texttt{if(p)}語句常走真分支。當\texttt{p == NULL}時會發生什麼？分支預測器會像往常一樣推測地真正執行的分支，而後就是解引用空指針，接下來程序會崩潰。之後，我們會發現不應該走那個分支，但怎麼修復崩潰呢？

事實上，像函數\texttt{f()}這樣的代碼很常見，並且不會受到隨機崩潰的影響。我們可以得出這樣的結論:要麼預測執行並不存在，要麼有一種方法可以避免崩潰。已經看到一些證據表明投機執行確實有發生，並且對於提高性能非常有效。那麼，當嘗試做一些不可能的事情時，比如解引用\texttt{NULL}指針，如何處理這種情況呢？對這種災難的響應必須保持掛起，在分支條件評估之前，既不丟棄也不執行，處理器知道推測執行是否應該執行。這樣，錯誤和其他無效的條件與普通的內存寫入沒有任何區別：只要動作指令仍具有推測性，那麼撤消的動作就有可能發生。CPU必須有特殊的硬件電路(如緩衝區)來存儲這些。最終，處理器確實在推測執行期間取消了空指針的引用，或讀取了不存在的數組元素\texttt{v[i+1]}，然後假裝它從未發生過。

已經理解了分支預測和投機執行，如何讓處理器在數據和代碼依賴關係產生不確定的情況下高效地運行。接下來，就可以將注意力轉向程序優化了。





























































