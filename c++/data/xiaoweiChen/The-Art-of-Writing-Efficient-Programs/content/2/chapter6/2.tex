使用併發性來提高性能非常簡單，第一種方法是為併發線程和進程提供足夠的工作，使它們始終處於忙碌狀態；第二個是減少共享數據的使用，併發訪問共享變量的開銷非常大。剩下的只是如何實現的問題。

但實現往往相當殘酷，而且當期望的性能增益更大，並且當硬件變得更強大時，難度就會增加。每個從事併發工作的開發者都聽說過Amdahl法則，但並不是每個人都完全理解它的含義。

法則本身很簡單：對於一個具有並行(可擴展)部分和單線程部分的程序，最大可能的加速\textit{s}如下所示:

\begin{center}
$ s = \dfrac{s_0}{s_0(1-p)+p} $
\end{center}

這裡，計算是程序並行部分的加速比，也是程序並行部分的分數。現在考慮一下在大型多處理器系統上運行程序的情況:如果有256個處理器，並且能夠充分利用它們，除了運行時間的1/256，程序的總加速會限制為128，加速比削減了一半。換句話說，如果只有1/256的程序是單線程的，或者是在鎖下執行的，那麼不管如何優化程序的其餘部分，在這個256個處理器的系統的加速比永遠不會超過50\%。

這就是為什麼在開發併發程序時，設計、實現和優化的重點應該是使單線程計算併發化，並減少程序訪問共享數據所花費的時間。

第一個目標，從算法的選擇開始使計算並行化，但是許多設計決策會影響結果，所以應該更多地進行了解。第二種方法是降低數據共享的成本，延續了上一章的主題，當所有線程都在等待訪問某個共享變量或鎖(它本身也是一個共享變量)時，程序實際上是單線程的，只有當前有訪問權限的線程在運行，這就是為什麼全局鎖和全局共享數據對性能不利的原因。但是，即使是多個線程之間共享的數據，如果併發訪問這些線程，也會限制這些線程的性能。

數據共享的需求基本上是由問題本身導致的，特定問題的數據共享量可能受到算法、數據結構選擇和其他設計決策以及實現的影響。有些數據共享是實現的產物，或數據結構選擇的結果，但其他共享數據則是問題本身。如果需要計算滿足某個屬性的數據元素，比如只有一個計數，所有線程必須將其更新為共享變量。然而，實際發生了多少共享，以及對總體程序加速的影響，在很大程度上取決於具體實現。

本章中，我們將追尋兩條線索:首先，考慮到一些不可避免的數據共享，將研究如何使這個過程更有效。然後，考慮設計和實現技術，這些可以用來減少數據共享的需求或減少等待訪問該數據的時間。從第一個問題開始把，如何進行高效的數據共享。
































