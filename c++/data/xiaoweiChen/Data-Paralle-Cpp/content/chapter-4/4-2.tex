决定编写并行内核时，就必须要启动的内核类型，以及了解如何在程序中表示。并行内核很多种，如果想掌握，就要熟悉每一种方法。\par

\hspace*{\fill} \par %插入空行
\textbf{将内核与主机代码分离}

有几种分离主机和设备代码的替代方法:C++ Lambda表达式或函数对象(functors)、OpenCL C源字符串或二进制文件。其中一些在第2章中已经介绍了，这些方式将在第10章中进行更详细地介绍。\par

这些选项都展示并行性的基本概念。为了一致性和简洁性，本章中的所有代码示例都使用C++ Lambda来表示内核。\par

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, title=Lambda无害于性能]
为了使用DPC++，不需要完全理解C++规范中关于Lambda的所有内容——只需要知道Lambda可以表示内核，并且可以捕获的变量(按值)作为参数传递给内核。\par

使用Lambda来定义内核不会产生性能影响。DPC++编译器能够理解Lambda表示并行内核的主体，并能够进行优化执行。\par

关于C++ Lambda函数的复习，以及它们在SYCL中的使用说明，请参见第1章。有关使用Lambda定义内核的详细信息，请参见第10章。
\end{tcolorbox}

\hspace*{\fill} \par %插入空行
\textbf{不同形式的并行内核}

内核有三种不同的形式，支持不同的执行模型和语法。可以使用任何形式编写可移植的内核，并且可以对任何形式的内核进行调优，以在各种设备类型上实现高性能。然而，有时可能希望使用特定的形式使并行算法更容易表达，或者使用某些语言特性。\par

第一种形式用于基本的数据并行内核，为编写内核提供了最优雅的介绍。牺牲对底层特性的控制，使内核的表达式尽可能简单。单个内核实例如何映射到硬件资源完全由实现控制，因此随着内核的复杂性的增长，对其性能的控制会变得越来越困难。\par

第二种形式扩展了内核，以提供对底层性能调优的访问。由于历史原因，第二种形式称为ND-Range(N维范围)数据并行方式，其将某些内核实例分组在一起，允许对数据局域性的使用，以及内核实例和硬件资源之间的映射进行控制。\par

第三种形式提供了另一种语法，可以使用嵌套的内核构造来ND-Range内核。第三种形式称为分层数据并行，指的是嵌套内核的层次结构。\par

我们将在本章的最后再次讨论如何在不同的内核形式之间进行选择，届时将详细讨论了它们的特性。\par















