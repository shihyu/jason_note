考虑到编码，内核大致可以分为以下三类:\par

\begin{itemize}
	\item 泛型内核代码:在任何地方运行，而不是调优到特定的设备类。
	\item 设备类型特定的内核代码:运行在一种类型的设备(例如，GPU, CPU, FPGA)上，而不是针对某一设备特定的类型。因为许多设备类型具有共同的特性，所以可以编写一些不适用于所有设备的通用代码。
	\item 调优特定于设备的内核代码:运行在特定的设备上，使用对设备的特定参数作出反应的调优——这涵盖了从少量调优到详细的优化工作的可能性。
\end{itemize}

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
作为开发者，我们的工作是确定不同的设备类型，以及何时需要不同的模式(第14章)。我们会在第14、15、16和17章来阐明这一重要的思想。
\end{tcolorbox}

最常见的做法是先实现通用内核代码以使其工作。第2章特别讨论了在开始内核实现时哪些方法最容易调试。一旦有了可以工作的内核，就可以将它发展为针对特定设备类型或设备模型的功能。\par

深入研究设备问题之前，第14章提供了一个思考并行性的框架。对模式(又名算法)的选择决定了代码模式，我们的工作是确定不同的设备何时需要不同的模式。第15章(GPU)、第16章(CPU)和第17章(FPGA)深入地探讨了区分这些设备类型和使用模式选择的特性。当不同设备类型上的方法(模式选择)不同时，这些特性促使我们考虑为不同的设备编写不同版本的内核。\par

当为特定类型的设备(例如，特定的CPU、GPU、FPGA等)编写内核时，将其适应于特定的供应商甚至此类设备的模型是合乎逻辑的。好的编码风格是基于特性(例如，从设备查询中找到的项目大小支持)参数化的代码。\par

我们应该编写代码来查询描述设备实际性能的参数，而不是从互联网上查询它的市场信息；查询设备的型号并对此作出反应是非常糟糕的编程实践——这种代码的可移植性较差。\par

为支持的每种设备类型编写不同的内核是很常见的(内核的GPU版本和内核的FPGA版本，也许还有通用版本)。当支持特定的设备供应商甚至设备模型时，可以参数化内核而不是复制时，工作会轻松很多。只要我们认为合适，可以自由选择其中任何一种。有太多参数调整的代码可能难以阅读或在运行时负担过重。然而，参数可以很好地适用于内核的每个版本。\par

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
算法大致相同，当针对特定设备的功能进行了调整时，参数化最有意义。当使用完全不同的方法、模式或算法时，编写不同的内核要干净得多。
\end{tcolorbox}



























































