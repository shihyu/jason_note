\begin{center}
	\includegraphics[width=0.3\textwidth]{content/chapter-12/images/1}
\end{center}

第2章介绍了将工作导向特定设备的机制——控制代码执行的位置。本章中，我们将探索如何适应运行时出现的设备。\par

我们希望程序可以移植，程序需要适应设备的功能。我们可以将程序参数化，只使用现有的特性，并根据设备的具体情况调整代码。如果程序不能适应环境，那么不好的事情就会发生，比如执行缓慢或失败。\par

幸运的是，SYCL规范考虑到了这一点，并提供了解决这个问题的接口。SYCL规范定义了一个设备类，封装了可以执行内核的设备。查询设备类的能力，使程序能够适应设备的特性和能力，这是本章的核心内容。\par

许多人将从开始思考如何将“是否存在GPU?”通知正在执行的程序，并让程序自身做出选择。如我们将看到的，有更多的信息可以帮助我们使程序的健壮和性能更好。\par

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
对程序进行参数化可以帮助提高程序的正确性、功能可移植性和性能可移植性。
\end{tcolorbox}

本章将深入探讨查询，以及如何在程序中如何有效地使用。\par

设备特定的属性可以使用get\_info查询，但是DPC++不同于SYCL 1.2.1，完全重载了get\_info，以减少使用get\_work\_group\_info获取工作组的信息，而工作组信息实际上是设备特定的信息。DPC++不支持get\_work\_group\_info，这意味着特定于设备的内核和工作组属性可以查询特定于设备的属性(get\_info)。这纠正了SYCL 1.2.1中从OpenCL继承而来的历史问题。\par

















































