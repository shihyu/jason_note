\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, title=Note]
\hspace*{0.8cm}本节中，模块指的是可以在运行时加载和卸载的软件组件。C++20的模块，请参阅第5章。
\end{tcolorbox}

如果曾经需要在尽可能少的停机时间内运行一个组件，但由于某种原因不能应用常见的容错模式，比如:服务的冗余副本，那么使用基于组件模块的模式可以解决这个问题。或者只是因模块化系统而对其感兴趣，该系统对所有模块可以进行版本控制，并且可以轻松查找所有可用的服务，以及基于模块的系统可能导致的解耦、测试性和增强团队协作。这就是为什么为Java创建了\textbf{开放式服务平台技术(Open Service Gateway Initiative，OSGi)}模块，并在多个框架中移植到C++。使用模块的架构示例包括IDE(如Eclipse)、软件定义网络(如OpenDaylight)项目或家庭自动化软件(如OpenHAB)。

OSGi还允许模块之间的依赖关系进行自动化管理，控制初始化和销毁，以及控制运行。由于它是面向服务的，可以将使用OSGi的服务看作在“容器”中拥有微型(?)服务的东西。这就是C++实现命名为C++微服务的原因。要了解其实际操作，请参阅扩展阅读部分中的入门指南。

C++微服务框架使用了一个有趣的概念，一种处理单例的新方法。\textit{GetInstance()}静态函数将不只是传递一个静态实例对象，并且返回一个绑定上下文获取的服务引用。因此，可以配置的服务将取代单例对象。还可以避免静态反初始化的失败，即多个依赖于彼此的单例，必须按照特定的顺序进行卸载。





