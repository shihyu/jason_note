
代码审查既可以用于CI系统，也可以不用于。其主要目的是再次检查代码中引入的每一个更改，以确保它是正确的，符合应用程序的体系结构，并遵循项目的指导方针和最佳实践。

在没有CI系统的情况下使用时，通常是评审人员的任务来手动测试更改，并验证是否按预期工作。CI减少了这种负担，使软件开发人员可以专注于代码的逻辑结构。

\subsubsubsection{9.3.1\hspace{0.2cm}自动控制机制}

自动化测试只是门控机制的一个例子。当质量足够高时，可以保证代码按照设计工作。但是，正确运行的代码和良好的代码之间仍存在差异。目前为止，如果代码满足几个条件，就可以认为是好的，功能正确只是其中之一。

其他工具可以实现所需的代码库标准。其中一些已经在前面的章节中介绍过，所以这里就不详细讨论了。记住，在CI/CD流水中使用检查器、代码格式化器和静态分析是一个很好的实践。虽然静态分析可以作为一种门控机制，但可以对进入中央存储库的每个提交应用检测和格式化，使其与其他代码库保持一致。可以在附录中找到更多关于静态代码分析器和格式化工具的信息。

理想情况下，这种机制只需要检查代码是否已经格式化，因为格式化步骤应该由开发人员在将代码放入存储库之前完成。当使用Git作为版本控制系统时，Git hook的机制可以防止在没有运行必要工具的情况下提交代码。

但自动化分析只能帮到这里。接下来，需要检查代码在功能上是否完整，是否没有已知的错误和漏洞，是否符合编码标准，这就需要人工检查了。

\subsubsubsection{9.3.2\hspace{0.2cm}代码审查——手动控制机制}

代码修改的手动检查通常称为代码审查，其目的是识别问题，包括特定子系统的实现和应用程序的整体架构。自动化性能测试可能会发现，也可能不会发现给定功能的潜在问题。另一方面，人眼通常可以发现问题的次优方案。无论是错误的数据结构，还是计算复杂度过高的算法，优秀的架构师都应该能够查明问题所在。

但执行代码检查的不仅仅是架构师的角色。同行评审，即由作者的同行执行的代码评审，在开发过程中也有自己的位置。这样的审查之所以有价值，不仅仅是因为允许同事们在彼此的代码中发现错误。更重要的方面是，许多同事也可以了解到其他人在做什么。这样，当团队中出现缺勤时(无论是因为长时间的会议、假期，还是工作轮换)，另一个团队成员可以代替缺勤的那个人。即使他们不是这个方向的专家，每个其他成员至少知道相关的代码位于哪里，每个人都应该能够记住对代码的最后更改。这既指它们发生的时间，也指这些变化的范围和内容。

随着越来越多的人意识到应用程序内部是如何显示的，也更有可能找出一个组件中最近的更改与新发现的bug之间的关联。尽管团队中的每个人可能都有不同的经验，但当每个人都非常了解代码时，就可以共享资源。

因此，代码审查可以检查更改是否符合所需的体系结构，以及实现是否正确。可以将这样的代码评审称为架构评审，或者专家评审。

另一种类型的代码审查，即同行审查，不仅有助于发现错误，而且还提高了团队中其他成员正在做什么的意识。如果有必要，在处理与外部服务集成的更改时，还可以执行不同类型的专家审查。

由于每个接口都可能成为问题来源，接近接口级别的更改应该视为特别危险。这里建议在通常的同行评议中加入来自另一方的专家。例如，如果正在编写生产者的代码，请使用者进行审查。通过这种方式，可以确保不会错过一些重要的用例，这些用例在某个方面可能认为不太可能出现，但另一方面可能经常使用。

\subsubsubsection{9.3.3\hspace{0.2cm}代码评审的不同方法}

代码审查通常会异步进行，这意味着审查变更的作者和审查者之间的交流不是实时发生的。相反，每个参与者随时都可以发布他们的评论和建议。当没有更多的评论，作者需要重新修改，并再次将修改置于审查中。这个过程可能需要很多轮，直到每个人对这次修正没有意见。

当一个修改特别有争议，并且异步代码审查花费了太多时间时，同步地进行代码审查是有益的。这意味着一场会议(面对面或远程)，以解决前进道路上的各种意见。当由于在实施变更时获得的新知识而使变更与最初的决定相矛盾时，这种情况就会发生。

有一些专门的工具只针对代码检查。更常见的是，希望使用内置在存储库服务器中的工具，包括如下服务:

\begin{itemize}
\item 
GitHub

\item 
Bitbucket

\item 
GitLab

\item 
Gerrit
\end{itemize}

上述所有服务都提供Git托管和代码审查。有些甚至更进一步，提供完整的CI/CD管道、问题管理、wiki等等。

当使用代码托管和代码审查的组合包时，默认的工作流程是将更改作为一个单独的分支推送，然后要求项目所有者在一个称为拉请求(或合并请求)的过程中合并更改。尽管名称很花哨，但pull请求或merge请求会告诉项目所有者你有代码想要与主分支合并。这意味着审查人员应该检查更改，以确保一切正常。

\subsubsubsection{9.3.4\hspace{0.2cm}使用拉请求(合并请求)进行代码评审}

像GitLab这样的系统创建拉请求或合并请求非常容易。首先，从命令行将一个新分支推送到中央存储库时，可以观察到以下消息:

\begin{tcblisting}{commandshell={}}
remote:
remote: To create a merge request for fix-ci-cd, visit:
remote:
https://gitlab.com/hosacpp/continuous-integration/merge_requests/new?merge_
request%5Bsource_branch%5D=fix-ci-cd
remote:
\end{tcblisting}

如果以前启用了CI(通过添加\texttt{.gitlab-ci.yml}文件)，还会看到新推送的分支已经置于CI进程中。这甚至发生在创建合并请求之前，从而这意味着可以推迟发送给同事，直到从CI获得每个自动检查都已通过的信息。

打开合并请求的两种主要方式如下:

\begin{itemize}
\item 
通过链接中提到的推送信息

\item 
通过在GitLab UI中导航到合并请求，并选择创建合并请求按钮或新建合并请求按钮
\end{itemize}

当提交合并请求时，并完成了所有相关字段，将看到CI流水的状态也是可见的。若流水失败，就不可能进行合并。

























