CMake中的链接看起来简单而微不足道，但它比看上去的要复杂得多。毕竟，链接可执行文件并不像把拼图拼在一起那么简单。当了解目标文件和库的结构后，会发现在程序可运行之前，需要移动一些东西。这些东西称为区段，在程序的生命周期中具有不同的作用——存储不同类型的数据、指令、符号名称等。链接器需要将它们组合到最终的二进制文件中。这个过程称为迁移。

还需要注意符号——跨所有翻译单元解析引用，并确保没有遗漏。然后，链接器可以创建程序头，并将其添加到最终的可执行文件中。它将包含针对系统加载器的指令，描述如何将合并的段转换为组成进程的运行时内存映像的区段。

我们还讨论了三种不同类型的库(静态、动态和模块)，并解释了它们的区别以及哪些场景更适合某些场景。还讨论了PIC——这是一个支持符号的惰性绑定的强大概念。

ODR是一个C++概念，在很大程度上由链接器执行。介绍了这个主题之后，简要地探讨了如何在静态库和动态库中处理最基本的符号复制。接下来是一些简短的建议，尽可能使用命名空间，在防止符号冲突方面不要过度依赖链接器。

对于这样一个看似简单的步骤(CMake只提供了几个专门用于链接器的指令)，确实有很多怪癖!要正确处理的一个棘手的事情是链接的顺序，特别是当库有嵌套依赖时。现在知道了如何处理一些基本的情况，以及可以研究其他方法来处理更复杂的情况。

最后，研究了如何利用链接器为我们的程序准备测试——通过将main()函数分离到另一个翻译单元。这能够引入另一个可执行文件，针对将在生产中运行的完全相同的机器代码运行测试。

现在了解了如何链接，可以检索外部库并在CMake项目中使用它们。下一章中，将学习如何在CMake中管理依赖项。