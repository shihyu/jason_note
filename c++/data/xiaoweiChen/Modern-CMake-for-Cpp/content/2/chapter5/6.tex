
毫无疑问，编译是一个复杂的过程。对于所有的边缘案例和特定的需求，若没有一个好的工具，管理起来会很困难，CMake在这方面支持得很好。

到目前为止我们学到了什么?首先讨论了什么是编译，以及在构建和运行操作系统中的应用程序方面的位置。然后，研究了编译的各个阶段，以及管理它们的内部工具。这对于解决在更高级的情况下可能遇到的所有问题非常有用。

然后，研究了如何要求CMake验证主机上可用的编译器，是否满足要构建的代码的所有必要要求。对于用户来说，看到要求他们升级的友好消息要比看到老编译器抱怨神秘错误(很容易被语言的新特性弄懵)好的多。

我们简要地讨论了如何向已经定义的目标添加源，然后继续讨论预处理器的配置。这是一个相当大的主题，因为这个阶段将所有的代码集中在一起，并决定将忽略哪些代码。讨论了提供文件的路径，并将自定义定义作为单个参数和批量添加(以及一些用例)。

然后，讨论了优化器，探讨了优化的所有一般级别以及它们所暗示的标志类型，也详细讨论了其中的一些级别——finline、flop-unroll和ftree-vectorize。

最后，研究如何管理编译的可行性了。在这里讨论了两个主题——减少编译时间(通过扩展，加强开发者的注意力)和查找错误。后者对于发现什么是坏的，以及如何坏的极其重要。

正确设置工具，并理解事情发生的原因对于确保代码的质量(以及我们的心理健康)非常重要。

下一章中，将学习链接，以及在构建库并在项目中使用它们时需要考虑的事情

\subsubsubsection{5.6.1\hspace{0.2cm}扩展阅读}

\begin{itemize}
\item 
有关本章所涵盖主题的更多信息，可以参考以下内容:

\url{https:// cmake.org/cmake/help/latest/manual/cmake-compilefeatures.7.html\#supported-compilers}

\item 
CMake目标属性:

\begin{itemize}
\item 
\url{https://stackoverflow.com/questions/32411963/why-iscmake-file-glob-evil}

\item 
\url{https://cmake.org/cmake/help/latest/command/target_sources.html}
\end{itemize}

\item 
提供包含文件的路径:

\begin{itemize}
\item 
\url{https://en.cppreference.com/w/cpp/preprocessor/include}

\item 
\url{https://cmake.org/cmake/help/latest/command/target_include_directories.html}
\end{itemize}

\item 
配置头文件: \url{https://cmake.org/cmake/help/latest/command/configure_file.html}

\item 
预编译头文件: \url{https://cmake.org/cmake/help/latest/command/target_precompile_headers.html}

\item 
统一构建：

\begin{itemize}
\item 
\url{https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html}

\item 
\url{https://www.qt.io/blog/2019/08/01/precompiled-headersand-unity-jumbo-builds-in-upcoming-cmake}
\end{itemize}

\item 
查找错误-编译器标志: \url{https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags}

\item 
为什么使用库，而不是目标文件: \url{https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why}

\item 
关注点分离: \url{https://nalexn.github.io/separation-ofconcerns/}
\end{itemize}









