试想有一台机器在钢板上打孔的生产线。这些孔必须有特定的大小和形状，以便容纳螺栓，将成品连接在一起。这种工厂线的设计者将设置机器，测试孔是否正确，然后继续工作。在未来，工厂将使用不同的、更厚的钢材;工人会不小心改变孔的尺寸;或者，简单地说，需要打更多的孔，机器必须升级。聪明的设计师会在生产线上的某些点进行质量控制检查，以确保产品符合规格并保留其关键质量。孔必须符合特定的要求，不管是如何进行的打孔:钻孔、打孔或激光切割。

同样的方法在软件开发中也有应用:很难预测哪些代码段会保持多年不变，哪些代码段会多次修改。随着软件功能的扩展，需要确保不会弄坏，即使是最好的程序员也会犯错误，他们不能预见所做的更改。似乎这还不够，开发人员经常在别人写的代码上工作，不知道早期做出的复杂假设。他们会阅读代码，建立大致的心理模型，添加必要的更改，并希望自己得到的正确结果。大多数情况下，这是对的——可能事实并非如此，引入的bug可能需要花费数小时，甚至数天来修复，更不用说它可能对产品和客户造成的损害了。

有时，会偶然发现一些非常难以理解和遵循的代码。不仅会质疑代码如何产生，以及做了什么，而且可能还会开展一场政治迫害，以找出是谁造成了这样的混乱。这种事在我身上发生过，也可能会发生在你身上。有时候，代码是匆忙创建的，并没有完全理解要解决的问题。

作为开发者，不仅面临着截止日期或预算的压力。当要求半夜醒来去修复一个严重的错误时，肯定会惊讶于某些错误是如何通过代码检查的。

这些大部分都可以通过自动化测试来避免，这些代码块检查另一段代码(在生产中使用)的行为是否正确。每次有人进行更改，自动化测试应该在没有提示的情况下执行。

这通常作为构建过程的一部分进行，并且作为在将代码合并到存储库之前控制代码质量的步骤。

为了节省时间，可能会倾向于避免自动化测试，但这将会是一个代价高昂的教训。Steven Wright说得很对:“经验是在需要它的时候才会得到的东西。”相信我:除非是为个人目的编写一次性脚本或为非生产实验创建原型，否则不要跳过编写测试。最初，可能会对精心编写的代码不断在测试中失败的事实感到恼火。但认真考虑一下，失败的测试只是阻止向生产中添加破坏性修改。现在投入的努力将会得到回报，因为修复bug的时间节省了(以及一整晚的睡眠)。添加和维护测试也并不像看起来那样困难。





























