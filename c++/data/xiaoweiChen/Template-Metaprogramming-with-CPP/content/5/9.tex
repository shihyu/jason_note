\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 1}

什么是范围?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

范围是元素序列的抽象，用开始迭代器和结束迭代器定义。开始迭代器指向序列中的第一个元素，结束迭代器指向序列的最后一个元素。


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 2}

什么是范围库中的视图?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

C++范围库中的视图，也称为范围适配器，是实现一种算法的对象，该算法以一个或多个范围作为输入。可能还有其他参数，并返回一个经过调整的范围。视图可惰性求值，所以可以直到其元素迭代时，才进行适配。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 3}

什么是约束算法?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

约束算法是现有标准库算法的实现，在C++20范围库中，其之所以“受约束”，是因为它们的模板参数使用C++20的概念进行约束。这些算法中，值范围接受单个范围参数，而不是需要begin-end迭代器对进行指定，但也存在接受迭代器-哨兵对的重载。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 4}

什么是哨兵?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

哨点是对结束迭代器的抽象。这使得结束迭代器的类型可能与范围迭代器的类型不同，哨兵不能解除引用或增加。当对范围尽头的测试依赖于某些可变(动态)条件，并且直到某些事情发生(条件变为false)时，才知道处于范围末尾时，哨兵是有用的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 5}

如何检查哨兵类型是否与迭代器类型相对应?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

可以使用<iterator>头文件中的std::sentinel\_for概念来检查哨兵类型是否可以与迭代器类型一起使用。












