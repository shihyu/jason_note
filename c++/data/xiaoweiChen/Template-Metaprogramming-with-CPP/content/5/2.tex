\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 1}

什么类型可以用于非类型模板参数?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

非类型模板参数只能有结构类型。结构类型包括整型、浮点型(截至C++20)、枚举类型、指针类型(指向对象或函数)、指向成员类型的指针(指向成员对象或成员函数)、左值引用类型(指向对象或函数)，以及满足以下要求的文字类类型:所有基类都是公共的和不可变的，所有非静态数据成员都是公共的和不可变的，所有基类和非静态数据成员的类型也是结构类型或其数组。这些类型的const和volatile限定版本也允许。


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 2}

默认模板参数在哪里不允许使用?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

默认模板实参不能用于形参包、友元类模板的声明以，及函数模板或成员函数模板的显式特化声明或定义中。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 3}

什么是显式实例化声明，在语法上与显式实例化定义有何不同?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

显式实例化声明是告诉编译器模板实例化的定义在不同的翻译单元中，并且不应该生成新的定义的一种方式。其语法与显式实例化定义相同，只是在声明前使用了extern关键字。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 4}

什么是别名模板?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

别名模板是一个名称，与引用另一种类型的类型别名不同，它引用一个模板。换句话说，引用一组类型。使用using声明引入别名模板，不能用typedef声明引入。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{习题 5}

什么是模板Lambda?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参考答案}

模板Lambda是泛型Lambda的进阶形式，在C++20中引入。允许使用模板语法显式地指定编译器，为Lambda表达式生成函数对象模板化函数调用操作符的形式。












