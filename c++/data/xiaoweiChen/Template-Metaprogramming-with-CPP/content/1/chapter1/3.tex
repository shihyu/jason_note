本章中，已经使用了模板，有四个不同的术语可以描述我们所编写的模板类型:

\begin{itemize}
\item
\textbf{函数模板}是用于模板化函数的术语。例子就是max模板。

\item
\textbf{类模板}是用于模板化类的术语(可以用class、struct或union关键字定义)。例子就是前一节中的vector类。

\item
\textbf{可变参模板}是用于模板化变量的术语，例如上一节中的NewLine模板。

\item
\textbf{别名模板}是用于模板化类型别名的术语。将在下一章看到的别名模板。
\end{itemize}

模板用一个或多个参数进行参数化(迄今为止看到的示例中，只有一个参数)。这些参数被称为\textbf{模板参数}，可以分为三类:

\begin{itemize}
\item
\textbf{类型模板参数}，例如template<typename T>，其中参数表示使用模板时指定的类型。

\item
\textbf{非类型模板形参}，如template<size\_t N>或template<auto N>，其中每个参数必须有一个结构类型，包括整型、浮点型(C++20)、指针类型、枚举类型、左值引用类型等。

\item
\textbf{双重模板参数}，如template<typename K, typename V, template<typename> typename C>，其中参数类型为另一个模板。
\end{itemize}

模板可以通过提供替代实现进行特化。这些实现可以依赖于模板参数的特征。特化的目的是实现优化或减少代码膨胀，其有两种形式:

\begin{itemize}
\item
\textbf{偏特化}:仅为某些模板参数提供的替代实现。

\item
\textbf{(显式)全特化}:当提供了所有模板参数时，这是模板特化的实例。
\end{itemize}

编译器通过模板生成代码的过程称为\textbf{模板实例化}，将模板实参替换为模板定义中使用的模板形参实现。例如，在vector<int>的例子中，编译器在T出现的每一个地方都替换了int类型。

模板实例化可以有两种形式:

\begin{itemize}
\item
\textbf{隐式实例化}:当编译器由于在代码中使用模板而实例化模板时，就会发生这种情况，这只发生在那些正在使用的组合或参数上。例如，编译器遇到vector<int>和vector<double>，将实例化vector类模板为类型int和double。

\item
\textbf{显式实例化}:显式地告诉编译器要创建模板的哪些实例化的方法，即使这些实例化没有显式地在代码中使用。例如，创建库文件时，因为未实例化的模板不会放入目标文件中。其还有助于减少编译时间和对象大小，我们将在后面的内容中看到这些方法。
\end{itemize}

本节中提到的所有术语和主题都将在本书的其他章节中详细介绍。本节旨在作为模板的参考指南，但还有许多其他与模板相关的术语会在适当的时候进行介绍。



