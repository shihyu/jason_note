// ============================================================================
// Lock-Free Queue ä½¿ç”¨ç¯„ä¾‹
// ============================================================================
// ğŸ“Œ ç¯„ä¾‹ç›®çš„ï¼š
// å±•ç¤ºå¦‚ä½•ä½¿ç”¨ LFQueue å¯¦ç¾é«˜æ•ˆçš„ç”Ÿç”¢è€…-æ¶ˆè²»è€…æ¨¡å¼
//
// é—œéµå­¸ç¿’é»ï¼š
// 1. âš¡ å…©æ­¥é©Ÿå¯«å…¥ï¼šgetNextToWriteTo() â†’ å¯«å…¥è³‡æ–™ â†’ updateWriteIndex()
// 2. âš¡ å…©æ­¥é©Ÿè®€å–ï¼šgetNextToRead() â†’ è®€å–è³‡æ–™ â†’ updateReadIndex()
// 3. âš ï¸ ç´¢å¼•æ›´æ–°é †åºï¼šå¿…é ˆå…ˆå®Œæˆè³‡æ–™æ“ä½œï¼Œå†æ›´æ–°ç´¢å¼•
// 4. ç„¡é–é€šè¨Šï¼šç”Ÿç”¢è€…èˆ‡æ¶ˆè²»è€…ç„¡éœ€ mutex/lock
//
// åŸ·è¡Œæµç¨‹ï¼š
// - ä¸»åŸ·è¡Œç·’ï¼ˆç”Ÿç”¢è€…ï¼‰ï¼šæ¯ç§’ç”¢ç”Ÿ 1 ç­†è³‡æ–™ï¼Œå…± 50 ç­†
// - æ¶ˆè²»è€…åŸ·è¡Œç·’ï¼šç­‰å¾… 5 ç§’å¾Œé–‹å§‹æ¶ˆè²»ï¼Œæ¯ç§’è®€å– 1 ç­†è³‡æ–™
// - ä½‡åˆ—å®¹é‡ï¼š20ï¼ˆæœƒåœ¨ç¬¬ 20 ç­†æ™‚é–‹å§‹è¢«æ¶ˆè²»è€…é‡‹æ”¾ç©ºé–“ï¼‰

#include "thread_utils.h"
#include "lf_queue.h"

// æ¸¬è©¦ç”¨è³‡æ–™çµæ§‹
struct MyStruct {
    int d_[3];  // å„²å­˜ä¸‰å€‹æ•´æ•¸ï¼š[i, i*10, i*100]
};

using namespace Common;

// âš¡ æ¶ˆè²»è€…å‡½å¼ï¼ˆConsumer Functionï¼‰
// åŸ·è¡Œæ–¼ç¨ç«‹åŸ·è¡Œç·’ï¼Œå¾ Lock-Free Queue è®€å–è³‡æ–™
auto consumeFunction(LFQueue<MyStruct>* lfq)
{
    using namespace std::literals::chrono_literals;

    // âš ï¸ åˆ»æ„å»¶é² 5 ç§’ï¼Œè®“ç”Ÿç”¢è€…å…ˆå¡«æ»¿éƒ¨åˆ†ä½‡åˆ—
    // é€™æ¨¡æ“¬ç¾å¯¦æƒ…å¢ƒï¼šæ¶ˆè²»è€…è™•ç†é€Ÿåº¦å¯èƒ½è½å¾Œæ–¼ç”Ÿç”¢è€…
    std::this_thread::sleep_for(5s);

    // æŒçºŒè®€å–ç›´åˆ°ä½‡åˆ—æ¸…ç©º
    while (lfq->size()) {
        // æ­¥é©Ÿ 1ï¼šå–å¾—ä¸‹ä¸€å€‹å¯è®€è³‡æ–™çš„æŒ‡æ¨™
        const auto d = lfq->getNextToRead();

        // æ­¥é©Ÿ 2ï¼šæ›´æ–°è®€å–ç´¢å¼•ï¼ˆé€šçŸ¥ç”Ÿç”¢è€…æ­¤ä½ç½®å¯é‡ç”¨ï¼‰
        lfq->updateReadIndex();

        std::cout << "consumeFunction read elem:" << d->d_[0] << "," << d->d_[1] << ","
                  << d->d_[2] << " lfq-size:" << lfq->size() << std::endl;

        // æ¨¡æ“¬è™•ç†å»¶é²ï¼ˆ1 ç§’ï¼‰
        std::this_thread::sleep_for(1s);
    }

    std::cout << "consumeFunction exiting." << std::endl;
}

int main(int, char**)
{
    // å»ºç«‹å®¹é‡ç‚º 20 çš„ Lock-Free Queue
    // âš ï¸ å®¹é‡å›ºå®šï¼Œç„¡æ³•å‹•æ…‹æ“´å±•
    LFQueue<MyStruct> lfq(20);

    // å»ºç«‹æ¶ˆè²»è€…åŸ·è¡Œç·’
    // - core_id = -1ï¼šä¸ç¶å®šç‰¹å®š CPU æ ¸å¿ƒ
    // - affinity_str = ""ï¼šç„¡è¦ªå’Œæ€§è¨­å®š
    auto ct = createAndStartThread(-1, "", consumeFunction, &lfq);

    // âš¡ ç”Ÿç”¢è€…è¿´åœˆï¼šä¸»åŸ·è¡Œç·’ç”¢ç”Ÿ 50 ç­†è³‡æ–™
    for (auto i = 0; i < 50; ++i) {
        // å»ºç«‹æ¸¬è©¦è³‡æ–™
        const MyStruct d{i, i * 10, i * 100};

        // æ­¥é©Ÿ 1ï¼šå–å¾—ä¸‹ä¸€å€‹å¯å¯«å…¥ä½ç½®çš„æŒ‡æ¨™
        // âš ï¸ è‹¥ä½‡åˆ—å·²æ»¿ï¼Œæœƒè¦†è“‹èˆŠè³‡æ–™ï¼ˆç”Ÿç”¢è€…é€Ÿåº¦ > æ¶ˆè²»è€…é€Ÿåº¦æ™‚ï¼‰
        *(lfq.getNextToWriteTo()) = d;

        // æ­¥é©Ÿ 2ï¼šæ›´æ–°å¯«å…¥ç´¢å¼•ï¼ˆé€šçŸ¥æ¶ˆè²»è€…æœ‰æ–°è³‡æ–™ï¼‰
        lfq.updateWriteIndex();

        std::cout << "main constructed elem:" << d.d_[0] << "," << d.d_[1] << "," <<
                  d.d_[2] << " lfq-size:" << lfq.size() << std::endl;

        using namespace std::literals::chrono_literals;
        // æ¯ç§’ç”¢ç”Ÿä¸€ç­†è³‡æ–™
        std::this_thread::sleep_for(1s);
    }

    // ç­‰å¾…æ¶ˆè²»è€…åŸ·è¡Œç·’çµæŸ
    ct->join();

    std::cout << "main exiting." << std::endl;

    return 0;
}
