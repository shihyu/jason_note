<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++11 ~ C++23 與 Rust 功能對照表 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c11--c23-與-rust-功能對照表"><a class="header" href="#c11--c23-與-rust-功能對照表">C++11 ~ C++23 與 Rust 功能對照表</a></h1>
<blockquote>
<p>詳細對比 C++ 各版本新增功能與 Rust 對應實現方式</p>
</blockquote>
<hr />
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#c11">C++11</a></li>
<li><a href="#c14">C++14</a></li>
<li><a href="#c17">C++17</a></li>
<li><a href="#c20">C++20</a></li>
<li><a href="#c23">C++23</a></li>
<li><a href="#%E7%B8%BD%E7%B5%90">總結</a></li>
</ul>
<hr />
<h2 id="c11"><a class="header" href="#c11">C++11</a></h2>
<h3 id="1-auto-型別推導"><a class="header" href="#1-auto-型別推導">1. Auto 型別推導</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">auto x = 42;
auto y = 3.14;
auto lambda = [](int x) { return x * 2; };
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;        // 自動推導為 i32
let y = 3.14;      // 自動推導為 f64
let lambda = |x: i32| x * 2;
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的型別推導更強大，幾乎所有地方都能使用，且更安全。</p>
<hr />
<h3 id="2-lambda-表達式--閉包"><a class="header" href="#2-lambda-表達式--閉包">2. Lambda 表達式 / 閉包</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">// 基本 lambda
auto add = [](int a, int b) { return a + b; };

// 捕獲外部變數
int x = 10;
auto capture_by_value = [x](int y) { return x + y; };
auto capture_by_ref = [&amp;x](int y) { x += y; return x; };
auto capture_all = [=](int y) { return x + y; };  // 全部按值捕獲
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 基本閉包
let add = |a: i32, b: i32| a + b;

// 自動捕獲（不可變借用）
let x = 10;
let capture_immut = |y| x + y;

// 可變捕獲
let mut x = 10;
let mut capture_mut = |y| {
    x += y;
    x
};

// 移動所有權
let s = String::from("hello");
let take_ownership = move |suffix| format!("{}{}", s, suffix);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的閉包自動推斷捕獲方式（不可變借用、可變借用、移動），更安全且語法更簡潔。</p>
<hr />
<h3 id="3-move-semantics移動語義"><a class="header" href="#3-move-semantics移動語義">3. Move Semantics（移動語義）</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = std::move(v1);  // v1 被移動後處於未定義狀態

// 右值引用
void process(std::vector&lt;int&gt;&amp;&amp; vec) {
    // 接受右值
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];
let v2 = v1;  // v1 自動移動，之後無法使用

// v1 在這裡已經無效，編譯器會阻止使用
// println!("{:?}", v1);  // 編譯錯誤！

fn process(vec: Vec&lt;i32&gt;) {
    // 接受所有權
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的移動是<strong>預設行為</strong>，且編譯器強制檢查，避免 use-after-move 錯誤。C++ 需要手動 <code>std::move</code>，且移動後的物件仍可訪問（危險）。</p>
<hr />
<h3 id="4-智慧指標-smart-pointers"><a class="header" href="#4-智慧指標-smart-pointers">4. 智慧指標 (Smart Pointers)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">#include &lt;memory&gt;

// unique_ptr - 獨佔所有權
std::unique_ptr&lt;int&gt; p1 = std::make_unique&lt;int&gt;(42);
std::unique_ptr&lt;int&gt; p2 = std::move(p1);  // 轉移所有權

// shared_ptr - 共享所有權（引用計數）
std::shared_ptr&lt;int&gt; s1 = std::make_shared&lt;int&gt;(100);
std::shared_ptr&lt;int&gt; s2 = s1;  // 引用計數 +1

// weak_ptr - 弱引用，避免循環引用
std::weak_ptr&lt;int&gt; w1 = s1;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Arc;

// Box - 堆上分配（類似 unique_ptr）
let b1 = Box::new(42);
let b2 = b1;  // 所有權移動

// Rc - 單執行緒引用計數（類似 shared_ptr）
let r1 = Rc::new(100);
let r2 = Rc::clone(&amp;r1);  // 引用計數 +1

// Arc - 多執行緒安全的引用計數
let a1 = Arc::new(200);
let a2 = Arc::clone(&amp;a1);

// Weak - 弱引用
let w1 = Rc::downgrade(&amp;r1);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong></p>
<ul>
<li>Rust 區分單執行緒 (<code>Rc</code>) 和多執行緒 (<code>Arc</code>) 的引用計數</li>
<li>Rust 沒有預設的垃圾回收，所有權系統更明確</li>
<li>C++ 的 <code>shared_ptr</code> 在多執行緒下也是安全的（使用原子操作）</li>
</ul>
<hr />
<h3 id="5-範圍-for-迴圈-range-based-for"><a class="header" href="#5-範圍-for-迴圈-range-based-for">5. 範圍 for 迴圈 (Range-based for)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};

// 遍歷
for (int x : vec) {
    std::cout &lt;&lt; x &lt;&lt; " ";
}

// 引用遍歷（可修改）
for (int&amp; x : vec) {
    x *= 2;
}

// const 引用（不可修改）
for (const auto&amp; x : vec) {
    std::cout &lt;&lt; x &lt;&lt; " ";
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3, 4, 5];

// 不可變遍歷（借用）
for x in &amp;vec {
    println!("{}", x);
}

// 可變遍歷
let mut vec = vec![1, 2, 3];
for x in &amp;mut vec {
    *x *= 2;
}

// 消耗迭代器（移動所有權）
for x in vec {
    println!("{}", x);
}
// vec 在這裡已失效
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 強制明確指定是借用 <code>&amp;</code>、可變借用 <code>&amp;mut</code> 還是移動所有權，避免意外修改。</p>
<hr />
<h3 id="6-nullptr"><a class="header" href="#6-nullptr">6. nullptr</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;  // 取代 NULL 或 0

void func(int* p) { }
void func(int i) { }

func(nullptr);  // 明確呼叫指標版本
func(NULL);     // C++11 前可能有歧義
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 沒有 null 指標！
// 使用 Option&lt;T&gt; 表示可能為空的值

let ptr: Option&lt;Box&lt;i32&gt;&gt; = None;
let ptr2: Option&lt;Box&lt;i32&gt;&gt; = Some(Box::new(42));

// 使用 match 處理
match ptr2 {
    Some(val) =&gt; println!("值: {}", val),
    None =&gt; println!("空值"),
}

// 或使用 if let
if let Some(val) = ptr2 {
    println!("值: {}", val);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 徹底消除了 null pointer 問題，使用 <code>Option&lt;T&gt;</code> 型別系統強制處理空值情況，這是<strong>十億美元的錯誤</strong>的解決方案。</p>
<hr />
<h3 id="7-強型別列舉-enum-class"><a class="header" href="#7-強型別列舉-enum-class">7. 強型別列舉 (Enum class)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">// 傳統 enum（全域命名空間污染）
enum Color { RED, GREEN, BLUE };

// C++11 enum class（強型別）
enum class Status {
    Success,
    Failed,
    Pending
};

Status s = Status::Success;
// int x = Status::Success;  // 編譯錯誤，無法隱式轉換
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 enum 更強大，可以帶資料
enum Status {
    Success,
    Failed,
    Pending,
}

let s = Status::Success;

// 帶資料的 enum
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let msg = Message::Write(String::from("hello"));

// 使用 match 處理
match msg {
    Message::Quit =&gt; println!("退出"),
    Message::Move { x, y } =&gt; println!("移動到 ({}, {})", x, y),
    Message::Write(text) =&gt; println!("訊息: {}", text),
    Message::ChangeColor(r, g, b) =&gt; println!("顏色: ({}, {}, {})", r, g, b),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 enum 是<strong>代數資料型別</strong>（ADT），比 C++ 強大得多，類似 Haskell/OCaml 的 sum types。</p>
<hr />
<h3 id="8-初始化列表-initializer-list"><a class="header" href="#8-初始化列表-initializer-list">8. 初始化列表 (Initializer List)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::map&lt;std::string, int&gt; map = {
    {"apple", 1},
    {"banana", 2}
};

// 自定義類型
struct Point {
    int x, y;
};
Point p = {10, 20};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3, 4, 5];

use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("apple", 1);
map.insert("banana", 2);

// 或使用宏
let map: HashMap&lt;_, _&gt; = [
    ("apple", 1),
    ("banana", 2),
].iter().cloned().collect();

// 結構體初始化
struct Point {
    x: i32,
    y: i32,
}
let p = Point { x: 10, y: 20 };
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 <code>vec![]</code> 宏來創建向量，結構體初始化語法類似但必須具名。</p>
<hr />
<h3 id="9-右值引用與完美轉發"><a class="header" href="#9-右值引用與完美轉發">9. 右值引用與完美轉發</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">// 右值引用
void process(std::string&amp;&amp; s) {
    // s 是右值引用
}

// 完美轉發
template&lt;typename T&gt;
void wrapper(T&amp;&amp; arg) {
    process(std::forward&lt;T&gt;(arg));
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 沒有引用類別的區分
// 所有權系統自動處理

fn process(s: String) {
    // 接受所有權
}

fn process_ref(s: &amp;String) {
    // 借用
}

// 泛型函數
fn wrapper&lt;T&gt;(arg: T) {
    // 根據需要傳遞所有權或借用
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的所有權系統簡化了這些概念，不需要區分左值/右值引用。</p>
<hr />
<h3 id="10-可變參數模板-variadic-templates"><a class="header" href="#10-可變參數模板-variadic-templates">10. 可變參數模板 (Variadic Templates)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">// 遞迴展開
template&lt;typename T&gt;
void print(T arg) {
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
}

template&lt;typename T, typename... Args&gt;
void print(T first, Args... args) {
    std::cout &lt;&lt; first &lt;&lt; ", ";
    print(args...);
}

print(1, 2.5, "hello", 'c');
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用宏來處理可變參數
macro_rules! print_all {
    ($($arg:expr),*) =&gt; {
        $(
            println!("{:?}", $arg);
        )*
    };
}

print_all!(1, 2.5, "hello", 'c');

// 或使用 println! 內建宏
println!("{}, {}, {}, {}", 1, 2.5, "hello", 'c');
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用宏系統處理可變參數，比 C++ 模板更直觀。</p>
<hr />
<h3 id="11-靜態斷言-static_assert"><a class="header" href="#11-靜態斷言-static_assert">11. 靜態斷言 (static_assert)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">static_assert(sizeof(int) == 4, "int must be 4 bytes");

template&lt;typename T&gt;
void func() {
    static_assert(std::is_integral&lt;T&gt;::value, "T must be integral");
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 編譯期斷言
const _: () = assert!(std::mem::size_of::&lt;i32&gt;() == 4);

// 使用 trait bounds 限制型別
fn func&lt;T: std::ops::Add&gt;() {
    // T 必須實作 Add trait
}

// 或使用 where 子句
fn func2&lt;T&gt;() 
where
    T: std::ops::Add + Clone
{
    // T 必須實作 Add 和 Clone
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 trait bounds 來限制泛型，在編譯期就能檢查型別約束。</p>
<hr />
<h3 id="12-預設和刪除函數"><a class="header" href="#12-預設和刪除函數">12. 預設和刪除函數</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">class MyClass {
public:
    MyClass() = default;  // 使用編譯器生成的預設建構子
    MyClass(const MyClass&amp;) = delete;  // 禁止拷貝
    MyClass&amp; operator=(const MyClass&amp;) = delete;
};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 預設不實作 Copy/Clone
struct MyStruct {
    data: i32,
}

// 需要明確標記才能複製
#[derive(Clone)]
struct Copyable {
    data: i32,
}

// 需要 Copy trait 才能隱式複製（只適用於簡單型別）
#[derive(Copy, Clone)]
struct SimpleCopy {
    data: i32,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 預設禁止複製，需要明確實作 <code>Clone</code> 或 <code>Copy</code> trait。</p>
<hr />
<h3 id="13-委託建構子-delegating-constructors"><a class="header" href="#13-委託建構子-delegating-constructors">13. 委託建構子 (Delegating Constructors)</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">class Point {
    int x, y;
public:
    Point(int x, int y) : x(x), y(y) {}
    Point() : Point(0, 0) {}  // 委託給另一個建構子
};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Self {
        Point { x, y }
    }
    
    fn default() -&gt; Self {
        Point::new(0, 0)  // 呼叫另一個建構函數
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用關聯函數模擬建構子，可以互相呼叫。</p>
<hr />
<h3 id="14-constexpr編譯期計算"><a class="header" href="#14-constexpr編譯期計算">14. constexpr（編譯期計算）</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">constexpr int factorial(int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
}

constexpr int val = factorial(5);  // 編譯期計算
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn factorial(n: u32) -&gt; u32 {
    if n &lt;= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

const VAL: u32 = factorial(5);  // 編譯期計算
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>const fn</code> 類似 C++ 的 <code>constexpr</code>，但限制更嚴格（逐漸放寬中）。</p>
<hr />
<h3 id="15-執行緒支援"><a class="header" href="#15-執行緒支援">15. 執行緒支援</a></h3>
<p><strong>C++11:</strong></p>
<pre><code class="language-cpp">#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex mtx;

void worker() {
    std::lock_guard&lt;std::mutex&gt; lock(mtx);
    // 臨界區
}

int main() {
    std::thread t1(worker);
    std::thread t2(worker);
    t1.join();
    t2.join();
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;
use std::thread;

fn main() {
    let mutex = Mutex::new(0);
    
    let handles: Vec&lt;_&gt; = (0..2).map(|_| {
        thread::spawn(move || {
            let mut data = mutex.lock().unwrap();
            *data += 1;
        })
    }).collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre></pre>
<p><strong>說明:</strong> Rust 的執行緒安全是<strong>編譯期保證</strong>的（通過 Send/Sync trait），C++ 只能在執行期檢查。</p>
<hr />
<h2 id="c14"><a class="header" href="#c14">C++14</a></h2>
<h3 id="1-泛型-lambda"><a class="header" href="#1-泛型-lambda">1. 泛型 Lambda</a></h3>
<p><strong>C++14:</strong></p>
<pre><code class="language-cpp">auto lambda = [](auto x, auto y) { return x + y; };
std::cout &lt;&lt; lambda(1, 2) &lt;&lt; std::endl;      // 3
std::cout &lt;&lt; lambda(1.5, 2.5) &lt;&lt; std::endl;  // 4.0
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 需要明確型別，或使用 trait
fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T {
    x + y
}

println!("{}", add(1, 2));      // 3
println!("{}", add(1.5, 2.5));  // 4.0

// 或使用閉包 + impl Trait (Rust 2018+)
fn make_adder() -&gt; impl Fn(i32, i32) -&gt; i32 {
    |x, y| x + y
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的泛型更明確，需要指定 trait bounds。</p>
<hr />
<h3 id="2-lambda-捕獲表達式"><a class="header" href="#2-lambda-捕獲表達式">2. Lambda 捕獲表達式</a></h3>
<p><strong>C++14:</strong></p>
<pre><code class="language-cpp">int x = 10;
auto lambda = [y = x + 1](int z) { return y + z; };
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let lambda = {
    let y = x + 1;
    move |z| y + z
};
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 <code>move</code> 關鍵字明確表示捕獲所有權。</p>
<hr />
<h3 id="3-返回型別推導"><a class="header" href="#3-返回型別推導">3. 返回型別推導</a></h3>
<p><strong>C++14:</strong></p>
<pre><code class="language-cpp">auto add(int a, int b) {
    return a + b;  // 自動推導返回 int
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 一直都支援，但仍建議明確寫出
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// 或使用型別推導（較少用）
fn add_auto(a: i32, b: i32) {
    a + b  // 錯誤！必須有返回型別
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 強制函數簽名必須明確，但內部可以推導。</p>
<hr />
<h3 id="4-變數模板-variable-templates"><a class="header" href="#4-變數模板-variable-templates">4. 變數模板 (Variable Templates)</a></h3>
<p><strong>C++14:</strong></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
constexpr T pi = T(3.1415926535897932385);

std::cout &lt;&lt; pi&lt;float&gt; &lt;&lt; std::endl;
std::cout &lt;&lt; pi&lt;double&gt; &lt;&lt; std::endl;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用 const 泛型
const fn pi&lt;T&gt;() -&gt; f64 {
    3.1415926535897932385
}

// 或使用 trait
trait PI {
    const VALUE: Self;
}

impl PI for f32 {
    const VALUE: f32 = 3.14159265;
}

impl PI for f64 {
    const VALUE: f64 = 3.1415926535897932385;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的常數泛型功能較新，但已經很強大。</p>
<hr />
<h3 id="5-binary-literals"><a class="header" href="#5-binary-literals">5. Binary Literals</a></h3>
<p><strong>C++14:</strong></p>
<pre><code class="language-cpp">int binary = 0b1010'1100;  // 二進位字面值，分隔符
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let binary = 0b1010_1100;  // 二進位字面值，底線分隔
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> 語法幾乎相同，只是分隔符不同。</p>
<hr />
<h2 id="c17"><a class="header" href="#c17">C++17</a></h2>
<h3 id="1-結構化綁定-structured-bindings"><a class="header" href="#1-結構化綁定-structured-bindings">1. 結構化綁定 (Structured Bindings)</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">std::tuple&lt;int, double, std::string&gt; get_data() {
    return {42, 3.14, "hello"};
}

auto [i, d, s] = get_data();
std::cout &lt;&lt; i &lt;&lt; ", " &lt;&lt; d &lt;&lt; ", " &lt;&lt; s &lt;&lt; std::endl;

// 用於 map
std::map&lt;std::string, int&gt; map = {{"a", 1}, {"b", 2}};
for (const auto&amp; [key, value] : map) {
    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; (i32, f64, String) {
    (42, 3.14, String::from("hello"))
}

let (i, d, s) = get_data();
println!("{}, {}, {}", i, d, s);

// 用於 HashMap
use std::collections::HashMap;
let map: HashMap&lt;_, _&gt; = [("a", 1), ("b", 2)].iter().cloned().collect();
for (key, value) in &amp;map {
    println!("{}: {}", key, value);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的模式匹配比 C++ 更強大，且一直都有此功能。</p>
<hr />
<h3 id="2-ifswitch-初始化語句"><a class="header" href="#2-ifswitch-初始化語句">2. if/switch 初始化語句</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">if (auto it = map.find("key"); it != map.end()) {
    std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}

switch (auto val = get_value(); val) {
    case 1: break;
    case 2: break;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// if let 模式匹配
if let Some(value) = map.get("key") {
    println!("{}", value);
}

// match 初始化
match get_value() {
    1 =&gt; {},
    2 =&gt; {},
    _ =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>if let</code> 和 <code>match</code> 更優雅，一直都有。</p>
<hr />
<h3 id="3-stdoptional"><a class="header" href="#3-stdoptional">3. std::optional</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">#include &lt;optional&gt;

std::optional&lt;int&gt; find_value(bool exists) {
    if (exists) return 42;
    return std::nullopt;
}

auto result = find_value(true);
if (result.has_value()) {
    std::cout &lt;&lt; result.value() &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_value(exists: bool) -&gt; Option&lt;i32&gt; {
    if exists {
        Some(42)
    } else {
        None
    }
}

let result = find_value(true);
if let Some(val) = result {
    println!("{}", val);
}

// 或使用 match
match result {
    Some(val) =&gt; println!("{}", val),
    None =&gt; println!("沒有值"),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>Option&lt;T&gt;</code> 是核心型別，從一開始就有，且更安全。</p>
<hr />
<h3 id="4-stdvariant"><a class="header" href="#4-stdvariant">4. std::variant</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">#include &lt;variant&gt;

std::variant&lt;int, double, std::string&gt; data;
data = 42;
data = 3.14;
data = "hello";

// 訪問
std::visit([](auto&amp;&amp; arg) {
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
}, data);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Data {
    Integer(i32),
    Float(f64),
    Text(String),
}

let data = Data::Integer(42);

// 訪問
match data {
    Data::Integer(i) =&gt; println!("{}", i),
    Data::Float(f) =&gt; println!("{}", f),
    Data::Text(s) =&gt; println!("{}", s),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 enum 更強大，是原生的 tagged union。</p>
<hr />
<h3 id="5-stdany"><a class="header" href="#5-stdany">5. std::any</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">#include &lt;any&gt;

std::any data = 42;
data = std::string("hello");

if (data.type() == typeid(std::string)) {
    std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(data) &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::Any;

fn print_any(value: &amp;dyn Any) {
    if let Some(s) = value.downcast_ref::&lt;String&gt;() {
        println!("String: {}", s);
    } else if let Some(i) = value.downcast_ref::&lt;i32&gt;() {
        println!("i32: {}", i);
    }
}

let data: Box&lt;dyn Any&gt; = Box::new(42);
print_any(&amp;*data);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>Any</code> trait 提供執行期型別資訊，但較少用（推薦用 enum）。</p>
<hr />
<h3 id="6-stdstring_view"><a class="header" href="#6-stdstring_view">6. std::string_view</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">#include &lt;string_view&gt;

void process(std::string_view sv) {
    std::cout &lt;&lt; sv &lt;&lt; std::endl;
}

std::string s = "hello";
process(s);  // 不複製
process("world");  // 不複製
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(s: &amp;str) {
    println!("{}", s);
}

let s = String::from("hello");
process(&amp;s);  // 字串切片，不複製
process("world");  // 字串字面值，不複製
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>&amp;str</code> 一直都是字串切片，預設就是 zero-copy。</p>
<hr />
<h3 id="7-fold-expressions摺疊表達式"><a class="header" href="#7-fold-expressions摺疊表達式">7. Fold Expressions（摺疊表達式）</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
auto sum(Args... args) {
    return (args + ...);  // 一元右摺疊
}

std::cout &lt;&lt; sum(1, 2, 3, 4, 5) &lt;&lt; std::endl;  // 15
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用迭代器
fn sum(args: &amp;[i32]) -&gt; i32 {
    args.iter().sum()
}

println!("{}", sum(&amp;[1, 2, 3, 4, 5]));  // 15

// 或使用宏
macro_rules! sum {
    ($($x:expr),*) =&gt; {
        0 $(+ $x)*
    };
}

println!("{}", sum!(1, 2, 3, 4, 5));
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 傾向使用迭代器而非模板元編程。</p>
<hr />
<h3 id="8-inline-變數"><a class="header" href="#8-inline-變數">8. inline 變數</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">// header.h
inline int global_var = 42;  // 多個編譯單元共享
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 沒有全域可變變數問題
// 使用靜態變數
static GLOBAL_VAR: i32 = 42;

// 需要可變性時使用 Mutex
use std::sync::Mutex;
static GLOBAL_MUT: Mutex&lt;i32&gt; = Mutex::new(42);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的全域變數預設不可變，需要可變性時必須使用同步原語。</p>
<hr />
<h3 id="9-constexpr-if"><a class="header" href="#9-constexpr-if">9. constexpr if</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
auto get_value(T t) {
    if constexpr (std::is_integral_v&lt;T&gt;) {
        return t + 1;
    } else {
        return t + 0.1;
    }
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用 trait 和泛型
trait GetValue {
    type Output;
    fn get_value(self) -&gt; Self::Output;
}

impl GetValue for i32 {
    type Output = i32;
    fn get_value(self) -&gt; i32 {
        self + 1
    }
}

impl GetValue for f64 {
    type Output = f64;
    fn get_value(self) -&gt; f64 {
        self + 0.1
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 trait 系統實現編譯期多態。</p>
<hr />
<h3 id="10-class-template-argument-deduction-ctad"><a class="header" href="#10-class-template-argument-deduction-ctad">10. Class Template Argument Deduction (CTAD)</a></h3>
<p><strong>C++17:</strong></p>
<pre><code class="language-cpp">std::pair p(1, 2.5);  // 推導為 std::pair&lt;int, double&gt;
std::vector v = {1, 2, 3};  // 推導為 std::vector&lt;int&gt;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 一直都有型別推導
let p = (1, 2.5);  // (i32, f64)
let v = vec![1, 2, 3];  // Vec&lt;i32&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的型別推導更自然，不需要特殊語法。</p>
<hr />
<h2 id="c20"><a class="header" href="#c20">C++20</a></h2>
<h3 id="1-concepts概念"><a class="header" href="#1-concepts概念">1. Concepts（概念）</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;concepts&gt;

template&lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -&gt; std::convertible_to&lt;T&gt;;
};

template&lt;Addable T&gt;
T add(T a, T b) {
    return a + b;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 trait 就是 concepts
trait Addable: std::ops::Add&lt;Output = Self&gt; + Sized {}

fn add&lt;T: Addable&gt;(a: T, b: T) -&gt; T {
    a + b
}

// 或直接使用 trait bound
fn add2&lt;T&gt;(a: T, b: T) -&gt; T
where
    T: std::ops::Add&lt;Output = T&gt;
{
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 trait 系統從一開始就有，比 C++20 的 concepts 更成熟。</p>
<hr />
<h3 id="2-ranges範圍庫"><a class="header" href="#2-ranges範圍庫">2. Ranges（範圍庫）</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;vector&gt;

std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};

auto result = vec 
    | std::views::filter([](int x) { return x % 2 == 0; })
    | std::views::transform([](int x) { return x * 2; });

for (int x : result) {
    std::cout &lt;&lt; x &lt;&lt; " ";  // 4 8
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3, 4, 5];

let result: Vec&lt;_&gt; = vec.iter()
    .filter(|&amp;&amp;x| x % 2 == 0)
    .map(|&amp;x| x * 2)
    .collect();

println!("{:?}", result);  // [4, 8]
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的迭代器從一開始就有，且更優雅（零成本抽象）。</p>
<hr />
<h3 id="3-coroutines協程"><a class="header" href="#3-coroutines協程">3. Coroutines（協程）</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;coroutine&gt;
#include &lt;iostream&gt;

struct Generator {
    struct promise_type {
        int current_value;
        auto get_return_object() { return Generator{this}; }
        auto initial_suspend() { return std::suspend_always{}; }
        auto final_suspend() noexcept { return std::suspend_always{}; }
        void return_void() {}
        void unhandled_exception() {}
        
        auto yield_value(int value) {
            current_value = value;
            return std::suspend_always{};
        }
    };
    
    std::coroutine_handle&lt;promise_type&gt; handle;
    
    Generator(promise_type* p) : handle(std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)) {}
    ~Generator() { if (handle) handle.destroy(); }
};

Generator counter() {
    for (int i = 0; i &lt; 5; ++i) {
        co_yield i;
    }
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 async/await 就是協程
async fn fetch_data(url: &amp;str) -&gt; String {
    // 模擬網路請求
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    format!("Data from {}", url)
}

// Generator 可以用迭代器實現
fn counter() -&gt; impl Iterator&lt;Item = i32&gt; {
    (0..5)
}

// 或手動實現
struct Counter {
    count: i32,
}

impl Iterator for Counter {
    type Item = i32;
    
    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        if self.count &lt; 5 {
            let result = self.count;
            self.count += 1;
            Some(result)
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong></p>
<ul>
<li>Rust 的 async/await 已經穩定（2019），比 C++20 早</li>
<li>C++20 的協程很底層，需要手動實現 promise_type</li>
<li>Rust 的 Generator trait 還在實驗階段</li>
</ul>
<hr />
<h3 id="4-modules模組"><a class="header" href="#4-modules模組">4. Modules（模組）</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">// math.cppm
export module math;

export int add(int a, int b) {
    return a + b;
}

// main.cpp
import math;

int main() {
    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust">// math.rs
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// main.rs
mod math;

fn main() {
    println!("{}", math::add(1, 2));
}</code></pre></pre>
<p><strong>說明:</strong> Rust 從一開始就有現代化的模組系統，C++20 才加入（編譯器支援仍不完整）。</p>
<hr />
<h3 id="5-three-way-comparison太空船運算子-"><a class="header" href="#5-three-way-comparison太空船運算子-">5. Three-way Comparison（太空船運算子 &lt;=&gt;）</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;compare&gt;

struct Point {
    int x, y;
    
    auto operator&lt;=&gt;(const Point&amp;) const = default;
};

Point p1{1, 2}, p2{1, 3};
if (p1 &lt; p2) { /* ... */ }
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialOrd, Ord, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 1, y: 2 };
let p2 = Point { x: 1, y: 3 };

if p1 &lt; p2 { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 derive 宏自動實作比較 trait，更簡潔。</p>
<hr />
<h3 id="6-constexpr-虛擬函數"><a class="header" href="#6-constexpr-虛擬函數">6. constexpr 虛擬函數</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">struct Base {
    virtual constexpr int get() const { return 1; }
};

struct Derived : Base {
    constexpr int get() const override { return 2; }
};

constexpr int value = Derived{}.get();  // 編譯期計算
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 const fn 不支援 trait objects
// 但可以用泛型 + trait
trait GetValue {
    fn get(&amp;self) -&gt; i32;
}

struct Base;
impl GetValue for Base {
    fn get(&amp;self) -&gt; i32 { 1 }
}

struct Derived;
impl GetValue for Derived {
    fn get(&amp;self) -&gt; i32 { 2 }
}

// 編譯期計算
const fn get_static() -&gt; i32 {
    2  // 必須是具體型別
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 const fn 限制較嚴格，不支援動態分派。</p>
<hr />
<h3 id="7-constinit"><a class="header" href="#7-constinit">7. constinit</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">constinit int global = 42;  // 保證編譯期初始化
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 static 預設就是編譯期初始化
static GLOBAL: i32 = 42;

// const 也是編譯期計算
const CONST_VAL: i32 = 42;
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的靜態變數預設就是編譯期初始化，不需要特殊關鍵字。</p>
<hr />
<h3 id="8-stdspan"><a class="header" href="#8-stdspan">8. std::span</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;span&gt;

void process(std::span&lt;int&gt; data) {
    for (int x : data) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }
}

std::vector&lt;int&gt; vec = {1, 2, 3};
int arr[] = {4, 5, 6};

process(vec);
process(arr);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(data: &amp;[i32]) {
    for x in data {
        print!("{} ", x);
    }
}

let vec = vec![1, 2, 3];
let arr = [4, 5, 6];

process(&amp;vec);
process(&amp;arr);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的切片 <code>&amp;[T]</code> 從一開始就有，且更安全。</p>
<hr />
<h3 id="9-format-格式化"><a class="header" href="#9-format-格式化">9. format 格式化</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;format&gt;

std::string s = std::format("Hello, {}! The answer is {}.", "world", 42);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = format!("Hello, {}! The answer is {}.", "world", 42);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>format!</code> 宏一直都有，且編譯期檢查格式字串。</p>
<hr />
<h3 id="10-stdsource_location"><a class="header" href="#10-stdsource_location">10. std::source_location</a></h3>
<p><strong>C++20:</strong></p>
<pre><code class="language-cpp">#include &lt;source_location&gt;

void log(std::string_view message, 
         const std::source_location&amp; location = std::source_location::current()) {
    std::cout &lt;&lt; location.file_name() &lt;&lt; ":" &lt;&lt; location.line() &lt;&lt; " - " &lt;&lt; message &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用宏獲取位置資訊
macro_rules! log {
    ($msg:expr) =&gt; {
        println!("{}:{} - {}", file!(), line!(), $msg);
    };
}

log!("Hello");
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用宏在編譯期捕獲位置資訊。</p>
<hr />
<h2 id="c23"><a class="header" href="#c23">C++23</a></h2>
<h3 id="1-stdexpected"><a class="header" href="#1-stdexpected">1. std::expected</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;expected&gt;

std::expected&lt;int, std::string&gt; divide(int a, int b) {
    if (b == 0) {
        return std::unexpected("除以零錯誤");
    }
    return a / b;
}

auto result = divide(10, 2);
if (result) {
    std::cout &lt;&lt; "結果: " &lt;&lt; *result &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "錯誤: " &lt;&lt; result.error() &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from("除以零錯誤"))
    } else {
        Ok(a / b)
    }
}

let result = divide(10, 2);
match result {
    Ok(val) =&gt; println!("結果: {}", val),
    Err(e) =&gt; println!("錯誤: {}", e),
}

// 或使用 ? 運算子
fn compute() -&gt; Result&lt;i32, String&gt; {
    let result = divide(10, 2)?;  // 自動傳播錯誤
    Ok(result * 2)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>Result&lt;T, E&gt;</code> 從一開始就有，且有 <code>?</code> 運算子簡化錯誤處理。</p>
<hr />
<h3 id="2-stdprint--stdprintln"><a class="header" href="#2-stdprint--stdprintln">2. std::print / std::println</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;print&gt;

std::print("Hello, {}!\n", "world");
std::println("The answer is {}", 42);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!("Hello, {}!\n", "world");
println!("The answer is {}", 42);
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 一直都有 <code>print!</code> 和 <code>println!</code> 宏，且編譯期檢查。</p>
<hr />
<h3 id="3-deducing-this顯式物件參數"><a class="header" href="#3-deducing-this顯式物件參數">3. Deducing this（顯式物件參數）</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">struct MyClass {
    void func(this MyClass&amp; self) {  // 顯式 self
        // ...
    }
    
    void func_by_value(this MyClass self) {  // 按值傳遞
        // ...
    }
};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyClass {
    data: i32,
}

impl MyClass {
    fn func(&amp;self) {  // 不可變借用
        // ...
    }
    
    fn func_mut(&amp;mut self) {  // 可變借用
        // ...
    }
    
    fn func_by_value(self) {  // 按值傳遞（移動）
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 從一開始就有顯式 <code>self</code> 參數，且強制明確借用類型。</p>
<hr />
<h3 id="4-if-consteval"><a class="header" href="#4-if-consteval">4. if consteval</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">constexpr int func() {
    if consteval {
        return 1;  // 編譯期執行
    } else {
        return 2;  // 執行期執行
    }
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 沒有直接對應，但可以用條件編譯
const fn func_const() -&gt; i32 {
    1
}

fn func_runtime() -&gt; i32 {
    2
}

// 使用者根據需要選擇
const VAL: i32 = func_const();
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 const fn 和普通函數分離更明確。</p>
<hr />
<h3 id="5-multidimensional-subscript-operator"><a class="header" href="#5-multidimensional-subscript-operator">5. Multidimensional subscript operator</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">struct Matrix {
    int operator[](int i, int j) {  // 多維下標
        return data[i][j];
    }
    
    int data[10][10];
};

Matrix m;
int val = m[3, 4];  // 使用逗號
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Matrix {
    data: [[i32; 10]; 10],
}

impl std::ops::Index&lt;(usize, usize)&gt; for Matrix {
    type Output = i32;
    
    fn index(&amp;self, (i, j): (usize, usize)) -&gt; &amp;i32 {
        &amp;self.data[i][j]
    }
}

let m = Matrix { data: [[0; 10]; 10] };
let val = m[(3, 4)];  // 使用 tuple
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 使用 tuple 作為索引，更明確。</p>
<hr />
<h3 id="6-stdflat_map--stdflat_set"><a class="header" href="#6-stdflat_map--stdflat_set">6. std::flat_map / std::flat_set</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;flat_map&gt;

std::flat_map&lt;int, std::string&gt; map;
map[1] = "one";
map[2] = "two";
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 標準庫沒有 flat_map
// 但可以用 BTreeMap（類似功能）
use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert(1, "one");
map.insert(2, "two");

// 或使用第三方庫如 indexmap
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 <code>BTreeMap</code> 提供排序的 map，類似 flat_map 的性能特性。</p>
<hr />
<h3 id="7-stdmdspan"><a class="header" href="#7-stdmdspan">7. std::mdspan</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;mdspan&gt;

int data[12];
std::mdspan&lt;int, std::dextents&lt;size_t, 2&gt;&gt; matrix(data, 3, 4);
matrix[1, 2] = 42;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用第三方庫如 ndarray
use ndarray::Array2;

let mut matrix = Array2::&lt;i32&gt;::zeros((3, 4));
matrix[(1, 2)] = 42;

// 或手動實現
struct Matrix {
    data: Vec&lt;i32&gt;,
    rows: usize,
    cols: usize,
}

impl Matrix {
    fn get(&amp;self, i: usize, j: usize) -&gt; &amp;i32 {
        &amp;self.data[i * self.cols + j]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 生態系統中有成熟的多維陣列庫。</p>
<hr />
<h3 id="8-stdstacktrace"><a class="header" href="#8-stdstacktrace">8. std::stacktrace</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;stacktrace&gt;

void func() {
    std::cout &lt;&lt; std::stacktrace::current() &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 使用 backtrace crate
use backtrace::Backtrace;

fn func() {
    let bt = Backtrace::new();
    println!("{:?}", bt);
}

// Panic 時自動顯示 backtrace
// RUST_BACKTRACE=1 cargo run
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的 backtrace 功能已經很成熟（第三方庫）。</p>
<hr />
<h3 id="9-literal-suffix-for-size_t"><a class="header" href="#9-literal-suffix-for-size_t">9. Literal suffix for size_t</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">auto size = 42uz;  // size_t 字面值
auto ssize = 42z;  // ssize_t 字面值
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let size: usize = 42;
let ssize: isize = 42;

// Rust 沒有字面值後綴，但型別推導通常足夠
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 依賴型別推導，較少需要字面值後綴。</p>
<hr />
<h3 id="10-stdgenerator-預計"><a class="header" href="#10-stdgenerator-預計">10. std::generator (預計)</a></h3>
<p><strong>C++23:</strong></p>
<pre><code class="language-cpp">#include &lt;generator&gt;

std::generator&lt;int&gt; fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        int next = a + b;
        a = b;
        b = next;
    }
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的 Generator trait 還在實驗階段
// 但可以用迭代器
fn fibonacci() -&gt; impl Iterator&lt;Item = i32&gt; {
    let mut a = 0;
    let mut b = 1;
    std::iter::from_fn(move || {
        let current = a;
        let next = a + b;
        a = b;
        b = next;
        Some(current)
    })
}

// 使用
for num in fibonacci().take(10) {
    println!("{}", num);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>說明:</strong> Rust 的迭代器提供類似功能，Generator trait 正在開發中。</p>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<h3 id="rust-已經有的功能甚至更好"><a class="header" href="#rust-已經有的功能甚至更好">Rust 已經有的功能（甚至更好）</a></h3>
<div class="table-wrapper"><table><thead><tr><th>C++ 功能</th><th>Rust 對應</th><th>優勢</th></tr></thead><tbody>
<tr><td>Move semantics</td><td>所有權系統</td><td>預設行為，編譯器強制檢查</td></tr>
<tr><td>Smart pointers</td><td>Box, Rc, Arc</td><td>更明確的單/多執行緒區分</td></tr>
<tr><td>nullptr</td><td>Option<T></td><td>型別系統強制處理，無 null pointer</td></tr>
<tr><td>Lambda</td><td>閉包</td><td>自動捕獲，更簡潔</td></tr>
<tr><td>Range-based for</td><td>for in</td><td>強制明確借用類型</td></tr>
<tr><td>Concepts</td><td>Trait 系統</td><td>更成熟，從一開始就有</td></tr>
<tr><td>Ranges</td><td>Iterator</td><td>零成本抽象，更優雅</td></tr>
<tr><td>optional</td><td>Option<T></td><td>核心型別，模式匹配</td></tr>
<tr><td>variant</td><td>Enum</td><td>更強大的代數資料型別</td></tr>
<tr><td>string_view</td><td>&amp;str</td><td>預設 zero-copy</td></tr>
<tr><td>expected</td><td>Result&lt;T, E&gt;</td><td>有 ? 運算子簡化錯誤處理</td></tr>
<tr><td>Modules</td><td>mod 系統</td><td>從一開始就有，更成熟</td></tr>
<tr><td>Coroutines</td><td>async/await</td><td>更早穩定，生態系統成熟</td></tr>
</tbody></table>
</div>
<h3 id="c-特有或更強的功能"><a class="header" href="#c-特有或更強的功能">C++ 特有或更強的功能</a></h3>
<div class="table-wrapper"><table><thead><tr><th>功能</th><th>說明</th></tr></thead><tbody>
<tr><td>Template metaprogramming</td><td>C++ 的模板元編程更靈活</td></tr>
<tr><td>constexpr 的廣度</td><td>C++20/23 的編譯期計算能力更廣</td></tr>
<tr><td>多重繼承</td><td>Rust 沒有繼承，用 trait 組合</td></tr>
<tr><td>操作符重載靈活性</td><td>C++ 更自由（也更危險）</td></tr>
<tr><td>與 C 的無縫互操作</td><td>C++ 天生兼容 C</td></tr>
</tbody></table>
</div>
<h3 id="關鍵差異總結"><a class="header" href="#關鍵差異總結">關鍵差異總結</a></h3>
<ol>
<li>
<p><strong>設計哲學</strong></p>
<ul>
<li>C++: 向後兼容，功能不斷疊加</li>
<li>Rust: 從零開始，一致性優先</li>
</ul>
</li>
<li>
<p><strong>安全性</strong></p>
<ul>
<li>C++: 執行期檢查（或無檢查）</li>
<li>Rust: 編譯期保證記憶體安全</li>
</ul>
</li>
<li>
<p><strong>學習曲線</strong></p>
<ul>
<li>C++: 語法複雜，陷阱多</li>
<li>Rust: 前期陡峭，但之後更平穩</li>
</ul>
</li>
<li>
<p><strong>生態系統</strong></p>
<ul>
<li>C++: 成熟但碎片化</li>
<li>Rust: 現代化工具鏈（Cargo），快速成長</li>
</ul>
</li>
<li>
<p><strong>性能</strong></p>
<ul>
<li>兩者都提供零成本抽象，性能相當</li>
</ul>
</li>
</ol>
<h3 id="結論"><a class="header" href="#結論">結論</a></h3>
<p>Rust 並非「追趕」C++，而是從一開始就選擇了不同的道路。很多 C++11-23 才加入的功能，Rust 在設計之初就內建了更優雅的解決方案。C++ 的優勢在於成熟的生態系統和極致的靈活性，而 Rust 的優勢在於編譯期安全保證和現代化的語言設計。</p>
<p>選擇哪個語言取決於：</p>
<ul>
<li><strong>專案需求</strong>: 需要與 C/C++ 生態整合？選 C++</li>
<li><strong>團隊背景</strong>: 團隊已經熟悉 C++？或願意投資學習 Rust？</li>
<li><strong>安全要求</strong>: 對記憶體安全有嚴格要求？選 Rust</li>
<li><strong>開發效率</strong>: 想要更好的工具鏈和包管理？選 Rust</li>
</ul>
<p>兩者都是優秀的系統程式語言，可以根據實際情況選擇！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../c++/modern-cpp11-essential-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../c++/cpp.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../c++/modern-cpp11-essential-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../c++/cpp.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
