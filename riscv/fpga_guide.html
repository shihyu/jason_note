<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FPGA Guide - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fpga-學習指南---從入門到實踐"><a class="header" href="#fpga-學習指南---從入門到實踐">FPGA 學習指南 - 從入門到實踐</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#fpga-vs-%E9%9F%8C%E9%AB%94-c-%E8%AA%9E%E8%A8%80%E9%96%8B%E7%99%BC%E5%B7%AE%E7%95%B0">FPGA vs 韌體 C 語言開發差異</a></li>
<li><a href="#fpga-%E5%85%A5%E9%96%80%E9%96%8B%E7%99%BC%E6%9D%BF%E6%8E%A8%E8%96%A6">FPGA 入門開發板推薦</a></li>
<li><a href="#tang-nano-9k-ubuntu-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83">Tang Nano 9K Ubuntu 開發環境</a></li>
<li><a href="#tang-nano-%E5%AD%B8%E7%BF%92%E5%B0%88%E6%A1%88%E8%88%87%E8%B7%AF%E5%BE%91">Tang Nano 學習專案與路徑</a></li>
<li><a href="#fpga-vs-cpu-%E5%B9%B3%E8%A1%8C%E9%81%8B%E7%AE%97%E6%AF%94%E8%BC%83">FPGA vs CPU 平行運算比較</a></li>
</ol>
<hr />
<h2 id="fpga-vs-韌體-c-語言開發差異"><a class="header" href="#fpga-vs-韌體-c-語言開發差異">FPGA vs 韌體 C 語言開發差異</a></h2>
<h3 id="執行模式的根本差異"><a class="header" href="#執行模式的根本差異">執行模式的根本差異</a></h3>
<h4 id="fpga硬體描述"><a class="header" href="#fpga硬體描述">FPGA（硬體描述）</a></h4>
<ul>
<li>使用 HDL（Hardware Description Language）如 Verilog 或 VHDL</li>
<li>描述的是實際的硬體電路結構</li>
<li>所有邏輯是<strong>並行執行</strong>的，同時發生</li>
<li>直接定義硬體的連接和行為</li>
</ul>
<h4 id="韌體-c-語言軟體程式"><a class="header" href="#韌體-c-語言軟體程式">韌體 C 語言（軟體程式）</a></h4>
<ul>
<li>在微控制器/處理器上執行</li>
<li>程式碼是<strong>循序執行</strong>的，一行接一行</li>
<li>透過 CPU 指令集來運作</li>
<li>需要既有的處理器硬體架構</li>
</ul>
<h3 id="開發思維的差異"><a class="header" href="#開發思維的差異">開發思維的差異</a></h3>
<h4 id="fpga-思維"><a class="header" href="#fpga-思維">FPGA 思維</a></h4>
<ul>
<li>電路如何連接</li>
<li>時脈域（clock domain）的管理</li>
<li>資源使用（LUT、觸發器、記憶體區塊）</li>
<li>時序約束（timing constraints）</li>
<li>平行處理架構設計</li>
</ul>
<h4 id="c-語言韌體思維"><a class="header" href="#c-語言韌體思維">C 語言韌體思維</a></h4>
<ul>
<li>程式流程控制</li>
<li>記憶體管理</li>
<li>中斷處理</li>
<li>RTOS 或任務排程</li>
<li>演算法效率</li>
</ul>
<h3 id="效能特性"><a class="header" href="#效能特性">效能特性</a></h3>
<h4 id="fpga-優勢"><a class="header" href="#fpga-優勢">FPGA 優勢</a></h4>
<ul>
<li>極低延遲（奈秒級）</li>
<li>真正的平行處理</li>
<li>可以同時處理多個資料流</li>
<li>適合高速即時訊號處理</li>
</ul>
<h4 id="c-語言韌體優勢"><a class="header" href="#c-語言韌體優勢">C 語言韌體優勢</a></h4>
<ul>
<li>開發速度快</li>
<li>除錯相對容易</li>
<li>複雜演算法實現較簡單</li>
<li>成本較低（使用現成的 MCU）</li>
</ul>
<h3 id="實際應用範例"><a class="header" href="#實際應用範例">實際應用範例</a></h3>
<h4 id="fpga-verilog"><a class="header" href="#fpga-verilog">FPGA (Verilog)</a></h4>
<pre><code class="language-verilog">always @(posedge clk) begin
    if (counter == 50000000) begin
        led &lt;= ~led;
        counter &lt;= 0;
    end else
        counter &lt;= counter + 1;
end
</code></pre>
<h4 id="c-語言韌體"><a class="header" href="#c-語言韌體">C 語言韌體</a></h4>
<pre><code class="language-c">while(1) {
    GPIO_Toggle(LED_PIN);
    delay_ms(1000);
}
</code></pre>
<h3 id="選擇建議"><a class="header" href="#選擇建議">選擇建議</a></h3>
<p><strong>選 FPGA 當：</strong></p>
<ul>
<li>需要極高速處理（如高速 ADC 資料處理）</li>
<li>需要精確的時序控制</li>
<li>需要大量平行運算</li>
<li>需要自訂硬體介面</li>
</ul>
<p><strong>選 C 語言韌體當：</strong></p>
<ul>
<li>控制邏輯較複雜</li>
<li>需要快速開發原型</li>
<li>成本考量重要</li>
<li>需要豐富的軟體生態系支援</li>
</ul>
<hr />
<h2 id="fpga-入門開發板推薦"><a class="header" href="#fpga-入門開發板推薦">FPGA 入門開發板推薦</a></h2>
<h3 id="入門級開發板價格親民"><a class="header" href="#入門級開發板價格親民">入門級開發板（價格親民）</a></h3>
<h4 id="1-tang-nano-系列高雲半導體"><a class="header" href="#1-tang-nano-系列高雲半導體">1. Tang Nano 系列（高雲半導體）</a></h4>
<ul>
<li><strong>Tang Nano 9K</strong>：約 $15-25 美元
<ul>
<li>GW1NR-9 FPGA，8640 個 LUT</li>
<li>內建 HDMI 介面、USB-JTAG</li>
<li>適合學習基礎數位邏輯、小型專案</li>
</ul>
</li>
</ul>
<h4 id="2-icebreakerlattice"><a class="header" href="#2-icebreakerlattice">2. iCEBreaker（Lattice）</a></h4>
<ul>
<li>約 $70-80 美元</li>
<li>Lattice iCE40UP5K FPGA</li>
<li>開源工具鏈支援（Yosys + nextpnr）</li>
<li>豐富的擴充板（PMOD）</li>
</ul>
<h4 id="3-sipeed-lichee-tang-primer"><a class="header" href="#3-sipeed-lichee-tang-primer">3. Sipeed Lichee Tang Primer</a></h4>
<ul>
<li>約 $30-40 美元</li>
<li>Anlogic EG4S20 FPGA</li>
<li>有 LCD 螢幕接口</li>
<li>適合影像處理入門</li>
</ul>
<h3 id="主流學習板"><a class="header" href="#主流學習板">主流學習板</a></h3>
<h4 id="4-digilent-basys-3xilinx"><a class="header" href="#4-digilent-basys-3xilinx">4. Digilent Basys 3（Xilinx）</a></h4>
<ul>
<li>約 $150 美元（學生價更低）</li>
<li><strong>Artix-7 FPGA</strong>（XC7A35T）</li>
<li>16 個開關、16 個 LED、七段顯示器</li>
<li>大學課程常用，教學資源豐富</li>
<li>支援 Vivado 免費版本</li>
</ul>
<h4 id="5-terasic-de0-nanointelaltera"><a class="header" href="#5-terasic-de0-nanointelaltera">5. Terasic DE0-Nano（Intel/Altera）</a></h4>
<ul>
<li>約 $80-90 美元</li>
<li>Cyclone IV FPGA</li>
<li>內建加速度計、ADC</li>
<li>豐富的 GPIO</li>
<li>Quartus Prime Lite 免費支援</li>
</ul>
<h4 id="6-digilent-arty-a7"><a class="header" href="#6-digilent-arty-a7">6. Digilent Arty A7</a></h4>
<ul>
<li>約 $130-250 美元（依規格）</li>
<li>Artix-7 FPGA（有 35T 和 100T 版本）</li>
<li>Arduino 相容接頭</li>
<li>乙太網路、DDR3 記憶體</li>
</ul>
<h3 id="進階學習板"><a class="header" href="#進階學習板">進階學習板</a></h3>
<h4 id="7-terasic-de10-lite"><a class="header" href="#7-terasic-de10-lite">7. Terasic DE10-Lite</a></h4>
<ul>
<li>約 $85 美元（學術價）</li>
<li>Intel MAX 10 FPGA</li>
<li>豐富的周邊（VGA、加速度計、Arduino 接頭）</li>
<li>適合教學和進階專案</li>
</ul>
<h4 id="8-pynq-z2"><a class="header" href="#8-pynq-z2">8. PYNQ-Z2</a></h4>
<ul>
<li>約 $120-150 美元</li>
<li>Zynq-7000（ARM + FPGA）</li>
<li>支援 Python 程式設計</li>
<li>適合軟硬體協同設計</li>
</ul>
<h3 id="選擇建議-1"><a class="header" href="#選擇建議-1">選擇建議</a></h3>
<ul>
<li><strong>完全新手（預算有限）</strong>：推薦 Tang Nano 9K</li>
<li><strong>系統性學習</strong>：推薦 Basys 3 或 DE0-Nano</li>
<li><strong>想學 SoC/軟硬整合</strong>：推薦 PYNQ-Z2</li>
</ul>
<hr />
<h2 id="tang-nano-9k-ubuntu-開發環境"><a class="header" href="#tang-nano-9k-ubuntu-開發環境">Tang Nano 9K Ubuntu 開發環境</a></h2>
<h3 id="方法一官方-ide推薦新手"><a class="header" href="#方法一官方-ide推薦新手">方法一：官方 IDE（推薦新手）</a></h3>
<h4 id="高雲官方-ide---gowin-eda"><a class="header" href="#高雲官方-ide---gowin-eda">高雲官方 IDE - Gowin EDA</a></h4>
<pre><code class="language-bash"># 1. 下載教育版（免費）
# 從高雲官網下載：https://www.gowinsemi.com/cn/support/download_eda/

# 2. 解壓縮後安裝
tar -xzf Gowin_V1.9.9_linux.tar.gz
cd Gowin_V1.9.9_linux

# 3. 執行 IDE
./IDE/bin/gw_ide

# 4. 安裝 license（教育版免費）
</code></pre>
<h4 id="燒錄工具---openfpgaloader"><a class="header" href="#燒錄工具---openfpgaloader">燒錄工具 - openFPGALoader</a></h4>
<pre><code class="language-bash"># 安裝依賴
sudo apt-get install libftdi1-2 libftdi1-dev libhidapi-dev libudev-dev cmake pkg-config git

# 編譯安裝 openFPGALoader
git clone https://github.com/trabucayre/openFPGALoader.git
cd openFPGALoader
mkdir build
cd build
cmake ..
make -j$(nproc)
sudo make install

# 燒錄到 Tang Nano 9K
openFPGALoader -b tangnano9k -f your_design.fs
</code></pre>
<h3 id="方法二開源工具鏈進階用戶"><a class="header" href="#方法二開源工具鏈進階用戶">方法二：開源工具鏈（進階用戶）</a></h3>
<h4 id="apicula--yosys--nextpnr"><a class="header" href="#apicula--yosys--nextpnr">Apicula + Yosys + nextpnr</a></h4>
<pre><code class="language-bash"># 1. 安裝 Python 環境
sudo apt-get install python3 python3-pip python3-venv

# 2. 建立虛擬環境
python3 -m venv fpga-env
source fpga-env/bin/activate

# 3. 安裝 Apicula（高雲 FPGA 支援）
pip install apycula

# 4. 安裝 Yosys（綜合工具）
sudo apt-get install yosys

# 5. 安裝 nextpnr-gowin
git clone https://github.com/YosysHQ/nextpnr.git
cd nextpnr
cmake -DARCH=gowin -DGOWIN_BBA_EXECUTABLE=`which gowin_bba` .
make -j$(nproc)
sudo make install
</code></pre>
<h3 id="完整開發流程範例"><a class="header" href="#完整開發流程範例">完整開發流程範例</a></h3>
<h4 id="1-寫-verilog-程式碼"><a class="header" href="#1-寫-verilog-程式碼">1. 寫 Verilog 程式碼</a></h4>
<pre><code class="language-verilog">// blink.v
module blink(
    input clk,
    output reg [5:0] led
);
    reg [25:0] counter;
    
    always @(posedge clk) begin
        counter &lt;= counter + 1;
        if (counter == 26'd27_000_000) begin  // 約 0.5 秒
            counter &lt;= 0;
            led &lt;= ~led;
        end
    end
endmodule
</code></pre>
<h4 id="2-約束檔案cst"><a class="header" href="#2-約束檔案cst">2. 約束檔案（.cst）</a></h4>
<pre><code class="language-tcl">// tangnano9k.cst
IO_LOC "clk" 52;  // 27MHz 時脈
IO_LOC "led[0]" 10;
IO_LOC "led[1]" 11;
IO_LOC "led[2]" 13;
IO_LOC "led[3]" 14;
IO_LOC "led[4]" 15;
IO_LOC "led[5]" 16;
</code></pre>
<h4 id="3-使用開源工具鏈編譯"><a class="header" href="#3-使用開源工具鏈編譯">3. 使用開源工具鏈編譯</a></h4>
<pre><code class="language-bash"># 綜合
yosys -p "read_verilog blink.v; synth_gowin -top blink -json blink.json"

# 佈局佈線
nextpnr-gowin --json blink.json --write blink_pnr.json \
    --device GW1NR-LV9QN88PC6/I5 --family GW1N-9C \
    --cst tangnano9k.cst

# 生成位元流
gowin_pack -d GW1N-9C -o blink.fs blink_pnr.json

# 燒錄
openFPGALoader -b tangnano9k blink.fs
</code></pre>
<h3 id="usb-權限設定"><a class="header" href="#usb-權限設定">USB 權限設定</a></h3>
<pre><code class="language-bash"># 建立 udev 規則
sudo nano /etc/udev/rules.d/99-openfpgaloader.rules

# 加入以下內容
ATTR{idVendor}=="0403", ATTR{idProduct}=="6010", MODE="0666", GROUP="plugdev"

# 重新載入規則
sudo udevadm control --reload-rules
sudo udevadm trigger

# 確保用戶在 plugdev 群組
sudo usermod -a -G plugdev $USER
</code></pre>
<hr />
<h2 id="tang-nano-學習專案與路徑"><a class="header" href="#tang-nano-學習專案與路徑">Tang Nano 學習專案與路徑</a></h2>
<h3 id="基礎數位邏輯學習"><a class="header" href="#基礎數位邏輯學習">基礎數位邏輯學習</a></h3>
<h4 id="入門專案"><a class="header" href="#入門專案">入門專案</a></h4>
<ul>
<li><strong>LED 控制</strong>：學習時脈分頻、計數器</li>
<li><strong>按鈕消除彈跳</strong>：理解數位訊號處理</li>
<li><strong>七段顯示器</strong>：多工掃描、解碼器設計</li>
<li><strong>PWM 呼吸燈</strong>：脈波寬度調變原理</li>
<li><strong>流水燈花樣</strong>：狀態機設計</li>
</ul>
<h4 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h4>
<ul>
<li>組合邏輯 vs 循序邏輯</li>
<li>同步設計、時脈域</li>
<li>Finite State Machine（FSM）</li>
<li>時序約束基礎</li>
</ul>
<h3 id="通訊協定實作"><a class="header" href="#通訊協定實作">通訊協定實作</a></h3>
<pre><code class="language-verilog">// UART 發送器實作範例
module uart_tx(
    input clk,
    input [7:0] data,
    input send,
    output reg tx
);
    // 學習串列通訊原理
    // 鮑率產生、起始/停止位元
endmodule
</code></pre>
<p>可以實作：</p>
<ul>
<li><strong>UART</strong>：與電腦通訊、debug</li>
<li><strong>SPI</strong>：控制 OLED 螢幕、SD 卡</li>
<li><strong>I2C</strong>：讀取感測器</li>
<li><strong>WS2812</strong>：控制 RGB LED 燈條</li>
</ul>
<h3 id="視訊顯示專案"><a class="header" href="#視訊顯示專案">視訊/顯示專案</a></h3>
<p>Tang Nano 9K 的 HDMI 功能：</p>
<ul>
<li><strong>VGA/HDMI 輸出</strong>：產生視訊時序</li>
<li><strong>簡單遊戲</strong>：乒乓球、貪食蛇、俄羅斯方塊</li>
<li><strong>字元顯示</strong>：ROM 字型表、framebuffer</li>
<li><strong>圖形產生</strong>：幾何圖形、碎形圖案</li>
</ul>
<pre><code class="language-verilog">// HDMI 640x480 顯示範例架構
module hdmi_display(
    input clk,
    output hdmi_clk_p,
    output [2:0] hdmi_data_p
);
    // 學習視訊時序
    // H-Sync, V-Sync, blanking
    // RGB 像素產生
endmodule
</code></pre>
<h3 id="數位訊號處理dsp"><a class="header" href="#數位訊號處理dsp">數位訊號處理（DSP）</a></h3>
<h4 id="音訊處理"><a class="header" href="#音訊處理">音訊處理</a></h4>
<ul>
<li><strong>蜂鳴器音樂</strong>：頻率產生、音符編碼</li>
<li><strong>PDM 麥克風</strong>：數位濾波器</li>
<li><strong>音訊效果器</strong>：延遲、混響基礎</li>
</ul>
<h4 id="訊號產生與處理"><a class="header" href="#訊號產生與處理">訊號產生與處理</a></h4>
<ul>
<li><strong>DDS 訊號產生器</strong>：正弦波、方波</li>
<li><strong>FIR 濾波器</strong>：基礎數位濾波</li>
<li><strong>FFT 基礎</strong>：頻譜分析入門</li>
</ul>
<h3 id="處理器與電腦架構"><a class="header" href="#處理器與電腦架構">處理器與電腦架構</a></h3>
<h4 id="軟核-cpu"><a class="header" href="#軟核-cpu">軟核 CPU</a></h4>
<p>Tang Nano 9K 可以跑小型 RISC-V！</p>
<ul>
<li><strong>PicoRV32</strong>：精簡 RISC-V 核心</li>
<li><strong>自製 CPU</strong>：8 位元或 16 位元簡易處理器</li>
</ul>
<p>學習內容：</p>
<ul>
<li>指令集架構</li>
<li>流水線概念</li>
<li>記憶體介面</li>
</ul>
<pre><code class="language-verilog">// 簡易 8-bit CPU 架構
module simple_cpu(
    input clk,
    input reset,
    output [7:0] addr,
    inout [7:0] data
);
    // 學習 fetch-decode-execute
    // 暫存器、ALU、控制單元
endmodule
</code></pre>
<h3 id="實用專案範例"><a class="header" href="#實用專案範例">實用專案範例</a></h3>
<ol>
<li>
<p><strong>邏輯分析儀</strong></p>
<ul>
<li>多通道訊號擷取</li>
<li>觸發條件設定</li>
<li>UART 傳送數據到 PC</li>
</ul>
</li>
<li>
<p><strong>復古遊戲機</strong></p>
<ul>
<li>NES 遊戲模擬器的 PPU</li>
<li>簡單的 8-bit 遊戲</li>
<li>搖桿控制介面</li>
</ul>
</li>
<li>
<p><strong>LED 矩陣控制器</strong></p>
<ul>
<li>WS2812 LED 動畫</li>
<li>音樂視覺化</li>
<li>POV 顯示器</li>
</ul>
</li>
<li>
<p><strong>頻率計/訊號產生器</strong></p>
<ul>
<li>測量外部訊號頻率</li>
<li>產生各種波形</li>
<li>PWM 控制器</li>
</ul>
</li>
</ol>
<h3 id="學習路徑建議"><a class="header" href="#學習路徑建議">學習路徑建議</a></h3>
<h4 id="階段一基礎1-2-個月"><a class="header" href="#階段一基礎1-2-個月">階段一：基礎（1-2 個月）</a></h4>
<ol>
<li>LED、按鈕、基本 I/O</li>
<li>計數器、分頻器</li>
<li>FSM 狀態機</li>
<li>UART 通訊</li>
</ol>
<h4 id="階段二中級2-3-個月"><a class="header" href="#階段二中級2-3-個月">階段二：中級（2-3 個月）</a></h4>
<ol>
<li>VGA/HDMI 顯示</li>
<li>SPI、I2C 協定</li>
<li>簡單遊戲設計</li>
<li>記憶體控制</li>
</ol>
<h4 id="階段三進階3-6-個月"><a class="header" href="#階段三進階3-6-個月">階段三：進階（3-6 個月）</a></h4>
<ol>
<li>軟核 CPU 實作</li>
<li>DSP 應用</li>
<li>高速介面</li>
<li>複雜專案整合</li>
</ol>
<h3 id="學習資源"><a class="header" href="#學習資源">學習資源</a></h3>
<h4 id="github-專案"><a class="header" href="#github-專案">GitHub 專案</a></h4>
<ul>
<li><a href="https://github.com/sipeed/TangNano-9K-example">Sipeed 官方範例</a></li>
<li><a href="https://github.com/janschiefer/tang-nano-9k-hello-world">社群專案集合</a></li>
</ul>
<h4 id="影片教學"><a class="header" href="#影片教學">影片教學</a></h4>
<ul>
<li>B站：「高雲 FPGA」、「Tang Nano 9K 入門」</li>
<li>YouTube：搜尋 "Tang Nano 9K projects"</li>
</ul>
<hr />
<h2 id="fpga-vs-cpu-平行運算比較"><a class="header" href="#fpga-vs-cpu-平行運算比較">FPGA vs CPU 平行運算比較</a></h2>
<h3 id="兩種平行運算的本質差異"><a class="header" href="#兩種平行運算的本質差異">兩種平行運算的本質差異</a></h3>
<h4 id="c-語言多核心軟體平行"><a class="header" href="#c-語言多核心軟體平行">C 語言多核心（軟體平行）</a></h4>
<pre><code class="language-c">// 4 核心 CPU 執行
#pragma omp parallel for
for(int i = 0; i &lt; 1000; i++) {
    result[i] = data[i] * 2 + 3;
}
</code></pre>
<ul>
<li>還是在<strong>執行指令</strong>，只是有 4 個 CPU 同時執行</li>
<li>每個核心仍然是<strong>循序處理</strong>它分配到的任務</li>
<li>受限於核心數量（4核、8核、16核）</li>
<li>需要作業系統排程、context switch</li>
</ul>
<h4 id="fpga硬體平行"><a class="header" href="#fpga硬體平行">FPGA（硬體平行）</a></h4>
<pre><code class="language-verilog">// 1000 個乘加器同時運算
generate
    for(genvar i = 0; i &lt; 1000; i++) begin
        assign result[i] = data[i] * 2 + 3;
    end
endgenerate
</code></pre>
<ul>
<li>真的建立了 <strong>1000 個實體乘加器電路</strong></li>
<li>這 1000 個運算在<strong>同一個時脈週期</strong>完成</li>
<li>沒有排程、沒有等待、沒有 context switch</li>
</ul>
<h3 id="具體比較範例影像處理"><a class="header" href="#具體比較範例影像處理">具體比較範例：影像處理</a></h3>
<h4 id="c-語言多核心版本"><a class="header" href="#c-語言多核心版本">C 語言多核心版本</a></h4>
<pre><code class="language-c">// 使用 8 核心 CPU
#pragma omp parallel for num_threads(8)
for(int y = 1; y &lt; height-1; y++) {
    for(int x = 1; x &lt; width-1; x++) {
        int sum = 0;
        // 9 個乘加運算，循序執行
        for(int ky = -1; ky &lt;= 1; ky++) {
            for(int kx = -1; kx &lt;= 1; kx++) {
                sum += image[y+ky][x+kx] * kernel[ky+1][kx+1];
            }
        }
        output[y][x] = sum;
    }
}
</code></pre>
<h4 id="fpga-版本"><a class="header" href="#fpga-版本">FPGA 版本</a></h4>
<pre><code class="language-verilog">// 9 個乘法器同時運算
always @(posedge clk) begin
    // 這 9 個乘法「同時」發生
    mult[0] &lt;= pixel[0] * kernel[0];
    mult[1] &lt;= pixel[1] * kernel[1];
    mult[2] &lt;= pixel[2] * kernel[2];
    mult[3] &lt;= pixel[3] * kernel[3];
    mult[4] &lt;= pixel[4] * kernel[4];
    mult[5] &lt;= pixel[5] * kernel[5];
    mult[6] &lt;= pixel[6] * kernel[6];
    mult[7] &lt;= pixel[7] * kernel[7];
    mult[8] &lt;= pixel[8] * kernel[8];
    
    // 加法樹也是並行的
    sum &lt;= mult[0] + mult[1] + mult[2] + 
           mult[3] + mult[4] + mult[5] + 
           mult[6] + mult[7] + mult[8];
end
</code></pre>
<h3 id="平行程度的差異"><a class="header" href="#平行程度的差異">平行程度的差異</a></h3>
<h4 id="cpu-多核心限制"><a class="header" href="#cpu-多核心限制">CPU 多核心限制</a></h4>
<pre><code>處理 1920×1080 影像：
- 單核：2,073,600 個像素循序處理
- 8 核：每核處理 259,200 個像素（仍是循序）
- 最多幾十個核心（伺服器 CPU）
</code></pre>
<h4 id="fpga-可能的平行度"><a class="header" href="#fpga-可能的平行度">FPGA 可能的平行度</a></h4>
<pre><code>同樣處理 1920×1080 影像：
- 可以建立 100 個卷積運算單元
- 每個單元每週期處理 1 個像素
- 甚至可以 pipeline，每週期輸出多個像素
</code></pre>
<h3 id="實際應用比較比特幣挖礦"><a class="header" href="#實際應用比較比特幣挖礦">實際應用比較：比特幣挖礦</a></h3>
<h4 id="cpuc語言"><a class="header" href="#cpuc語言">CPU（C語言）</a></h4>
<pre><code class="language-c">// 8 核心 CPU
for(int nonce = start; nonce &lt; end; nonce++) {
    hash = SHA256(SHA256(block_header + nonce));
    if(hash &lt; target) found = true;
}
// 8 核心 = 8 個 hash 平行運算
</code></pre>
<h4 id="fpga"><a class="header" href="#fpga">FPGA</a></h4>
<pre><code class="language-verilog">// 可以實例化 1000 個 SHA256 模組
generate
    for(genvar i = 0; i &lt; 1000; i++) begin
        sha256_core hash_unit(
            .data(block_header + nonce + i),
            .hash(hash_result[i])
        );
    end
endgenerate
// 1000 個 SHA256 單元同時運算！
</code></pre>
<h3 id="平行運算的層級"><a class="header" href="#平行運算的層級">平行運算的層級</a></h3>
<pre><code>平行運算層級比較：

1. 單核心 CPU + SIMD
   └─ 有限的向量運算（如 AVX-512）

2. 多核心 CPU（2-128 核）
   └─ 多個循序執行單元

3. GPU（幾千個核心）
   └─ SIMT 架構，適合規則的平行運算

4. FPGA（只受晶片資源限制）
   └─ 真正的硬體平行，可自定義架構
   └─ 可以有數千個運算單元同時工作
</code></pre>
<h3 id="各有適合的場景"><a class="header" href="#各有適合的場景">各有適合的場景</a></h3>
<h4 id="cpu-多核心適合"><a class="header" href="#cpu-多核心適合">CPU 多核心適合</a></h4>
<ul>
<li>複雜的控制邏輯</li>
<li>不規則的平行任務</li>
<li>需要大量記憶體的運算</li>
<li>通用運算</li>
</ul>
<h4 id="fpga-大量平行適合"><a class="header" href="#fpga-大量平行適合">FPGA 大量平行適合</a></h4>
<ul>
<li>規則的平行運算（如訊號處理）</li>
<li>低延遲要求（金融交易）</li>
<li>串流處理（影像、網路封包）</li>
<li>自定義運算架構</li>
</ul>
<h3 id="結論"><a class="header" href="#結論">結論</a></h3>
<p>C 語言多核心確實是平行運算，但它是<strong>任務級平行</strong>（task-level parallelism），而 FPGA 提供的是<strong>位元級平行</strong>（bit-level parallelism）和<strong>運算單元級平行</strong>。</p>
<p>打個比方：</p>
<ul>
<li><strong>CPU 多核心</strong>像是有 8 個工人，每個工人還是一次做一件事</li>
<li><strong>FPGA</strong>像是可以僱用 1000 個專門的機器人，每個只做特定工作，但全部同時進行</li>
</ul>
<p>兩者都是平行運算，但平行的粒度和靈活度完全不同！</p>
<hr />
<h2 id="fpga-vs-risc-v-的關係"><a class="header" href="#fpga-vs-risc-v-的關係">FPGA vs RISC-V 的關係</a></h2>
<h3 id="fpga-和-risc-v-的本質差異"><a class="header" href="#fpga-和-risc-v-的本質差異">FPGA 和 RISC-V 的本質差異</a></h3>
<h4 id="fpga-是什麼"><a class="header" href="#fpga-是什麼">FPGA 是什麼</a></h4>
<ul>
<li><strong>硬體平臺</strong>：可編程的晶片</li>
<li>像是「空白的積木盒」</li>
<li>你可以在上面建造任何數位電路</li>
<li>包括建造一個 CPU！</li>
</ul>
<h4 id="risc-v-是什麼"><a class="header" href="#risc-v-是什麼">RISC-V 是什麼</a></h4>
<ul>
<li><strong>指令集架構（ISA）</strong>：CPU 的「語言規範」</li>
<li>定義 CPU 如何執行指令</li>
<li>是開源的 CPU 架構（像 ARM、x86 的替代品）</li>
<li>需要實際的硬體來實現</li>
</ul>
<h3 id="tang-nano-9k-的-risc-v-實現"><a class="header" href="#tang-nano-9k-的-risc-v-實現">Tang Nano 9K 的 RISC-V 實現</a></h3>
<h4 id="軟核-risc-v最可能"><a class="header" href="#軟核-risc-v最可能">軟核 RISC-V（最可能）</a></h4>
<pre><code class="language-verilog">// 在 FPGA 內部用邏輯閘實現一個 RISC-V CPU
module picorv32_core (
    input clk,
    input resetn,
    output [31:0] mem_addr,
    output [31:0] mem_wdata,
    input [31:0] mem_rdata
);
    // RISC-V CPU 的 Verilog 實現
endmodule
</code></pre>
<ul>
<li><strong>你可以選擇</strong>：要不要在 FPGA 裡放一個 RISC-V CPU</li>
<li>可以用 FPGA 的邏輯資源「建造」一個 RISC-V 處理器</li>
<li>常見的軟核：PicoRV32、VexRiscv、NEORV32</li>
</ul>
<h3 id="實際運用場景"><a class="header" href="#實際運用場景">實際運用場景</a></h3>
<h4 id="純-fpga-模式"><a class="header" href="#純-fpga-模式">純 FPGA 模式</a></h4>
<pre><code class="language-verilog">// 直接寫硬體邏輯，不需要 CPU
module led_controller(
    input clk,
    output [5:0] led
);
    // 純硬體邏輯控制
endmodule
</code></pre>
<h4 id="fpga--軟核-risc-v-模式"><a class="header" href="#fpga--軟核-risc-v-模式">FPGA + 軟核 RISC-V 模式</a></h4>
<pre><code class="language-c">// RISC-V 上跑的 C 程式
int main() {
    while(1) {
        GPIO_write(LED_PORT, pattern);
        delay_ms(100);
        complex_algorithm();  // 複雜演算法
    }
}
</code></pre>
<h3 id="混合架構範例"><a class="header" href="#混合架構範例">混合架構範例</a></h3>
<pre><code>┌─────────────────────────────────┐
│      Tang Nano 9K FPGA          │
│                                 │
│  ┌──────────────┐  ┌─────────┐ │
│  │  RISC-V      │  │  自訂   │ │
│  │  軟核 CPU    │←→│  硬體   │ │
│  │  (可選)      │  │  加速器 │ │
│  └──────────────┘  └─────────┘ │
│                                 │
│  ┌──────────────┐  ┌─────────┐ │
│  │   UART       │  │  HDMI   │ │
│  │   控制器     │  │  輸出   │ │
│  └──────────────┘  └─────────┘ │
└─────────────────────────────────┘
</code></pre>
<h3 id="為什麼要在-fpga-裡放-risc-v"><a class="header" href="#為什麼要在-fpga-裡放-risc-v">為什麼要在 FPGA 裡放 RISC-V？</a></h3>
<p><strong>優點</strong>：</p>
<ol>
<li><strong>彈性控制</strong>：用 C 寫複雜邏輯比 Verilog 簡單</li>
<li><strong>軟硬結合</strong>：RISC-V 負責控制流程，FPGA 硬體加速處理</li>
<li><strong>熟悉的開發</strong>：可以用 GCC、標準 C 庫</li>
</ol>
<p><strong>缺點</strong>：</p>
<ol>
<li><strong>消耗資源</strong>：RISC-V 軟核佔用 FPGA 邏輯</li>
<li><strong>效能限制</strong>：軟核 CPU 通常只能跑 50-100 MHz</li>
<li><strong>複雜度增加</strong>：需要處理軟硬體介面</li>
</ol>
<h3 id="tang-nano-9k-資源分配"><a class="header" href="#tang-nano-9k-資源分配">Tang Nano 9K 資源分配</a></h3>
<pre><code>GW1NR-9 FPGA 總資源：
- 8640 個 LUT
- 6480 個觸發器

如果實現 PicoRV32：
- 約使用 2000-3000 個 LUT
- 剩餘 5000+ LUT 可做其他硬體

你可以選擇：
1. 100% 純 FPGA 邏輯
2. 70% FPGA + 30% RISC-V
3. 根據專案需求調整
</code></pre>
<hr />
<h2 id="fpga-vs-cpuarmx86的根本差異"><a class="header" href="#fpga-vs-cpuarmx86的根本差異">FPGA vs CPU（ARM/x86）的根本差異</a></h2>
<h3 id="晶片類型的根本區別"><a class="header" href="#晶片類型的根本區別">晶片類型的根本區別</a></h3>
<h4 id="cpuarmx86--固定的處理器"><a class="header" href="#cpuarmx86--固定的處理器">CPU（ARM、x86）- 固定的處理器</a></h4>
<pre><code>┌──────────────────────────┐
│     CPU 晶片（固定）      │
│                          │
│  ▣ 算術邏輯單元 (ALU)     │
│  ▣ 控制單元              │
│  ▣ 暫存器組              │  
│  ▣ 快取記憶體            │
│  ▣ 指令解碼器            │
└──────────────────────────┘
</code></pre>
<ul>
<li><strong>製造時就決定</strong>了所有電路</li>
<li>只能執行預定的指令集</li>
<li>你寫軟體在上面跑</li>
</ul>
<h4 id="fpga---可編程的邏輯晶片"><a class="header" href="#fpga---可編程的邏輯晶片">FPGA - 可編程的邏輯晶片</a></h4>
<pre><code>┌──────────────────────────┐
│    FPGA 晶片（空白）      │
│                          │
│  □ □ □ □ □ □ □ □        │
│  □ □ □ □ □ □ □ □        │
│  □ □ □ □ □ □ □ □        │
│  □ □ □ □ □ □ □ □        │
│  (可編程邏輯區塊)         │
└──────────────────────────┘
</code></pre>
<ul>
<li>像是「數位樂高積木」</li>
<li>你決定要建造什麼電路</li>
<li>可以建造 CPU、GPU 或任何數位電路</li>
</ul>
<h3 id="執行方式完全不同"><a class="header" href="#執行方式完全不同">執行方式完全不同</a></h3>
<h4 id="armx86-cpu"><a class="header" href="#armx86-cpu">ARM/x86 CPU</a></h4>
<pre><code class="language-c">// 軟體程式
int sum = a + b;  // CPU 執行 ADD 指令
</code></pre>
<p>過程：</p>
<ol>
<li>從記憶體取指令</li>
<li>解碼指令</li>
<li>執行 ADD 運算</li>
<li>存回結果
（需要多個時脈週期）</li>
</ol>
<h4 id="fpga-1"><a class="header" href="#fpga-1">FPGA</a></h4>
<pre><code class="language-verilog">// 硬體電路
assign sum = a + b;  // 直接建造加法器
</code></pre>
<p>過程：</p>
<ol>
<li>直接用邏輯閘建造加法器電路</li>
<li>訊號通過就得到結果
（一個時脈週期或更少）</li>
</ol>
<h3 id="具體例子實現乘法"><a class="header" href="#具體例子實現乘法">具體例子：實現乘法</a></h3>
<h4 id="arm-cpu-做乘法"><a class="header" href="#arm-cpu-做乘法">ARM CPU 做乘法</a></h4>
<pre><code class="language-assembly">; ARM 組合語言
MUL R0, R1, R2  ; 使用 CPU 內建的乘法器
</code></pre>
<ul>
<li>使用 CPU <strong>預先設計好</strong>的乘法單元</li>
<li>無法改變乘法器的實作方式</li>
</ul>
<h4 id="x86-cpu-做乘法"><a class="header" href="#x86-cpu-做乘法">x86 CPU 做乘法</a></h4>
<pre><code class="language-assembly">; x86 組合語言  
IMUL EAX, EBX   ; 使用 Intel 設計的乘法器
</code></pre>
<ul>
<li>同樣是固定的硬體乘法器</li>
<li>Intel 或 AMD 設計好的</li>
</ul>
<h4 id="fpga-做乘法"><a class="header" href="#fpga-做乘法">FPGA 做乘法</a></h4>
<pre><code class="language-verilog">// 你可以選擇不同的實現方式！

// 方式1：直接乘法器
assign result = a * b;

// 方式2：自己設計的移位加法器
module multiplier(
    input [7:0] a, b,
    output [15:0] result
);
    // 自訂乘法邏輯
endmodule

// 方式3：查表法
// 方式4：Booth 演算法
// ... 任何你想要的方式
</code></pre>
<h3 id="形象化比喻"><a class="header" href="#形象化比喻">形象化比喻</a></h3>
<p><strong>CPU（ARM/x86）像是：</strong></p>
<ul>
<li><strong>瑞士刀</strong> 🔪</li>
<li>功能固定（刀、剪刀、開瓶器）</li>
<li>很方便，拿來就用</li>
<li>但你不能把剪刀變成鋸子</li>
<li>通用但每個功能不一定最優</li>
</ul>
<p><strong>FPGA 像是：</strong></p>
<ul>
<li><strong>一箱樂高積木</strong> 🧱</li>
<li>你決定要組什麼</li>
<li>可以組成任何東西</li>
<li>今天組汽車，明天可以拆掉組飛機</li>
<li>為特定用途最佳化</li>
</ul>
<h3 id="效能與應用場景差異"><a class="header" href="#效能與應用場景差異">效能與應用場景差異</a></h3>
<h4 id="任務處理-1000-個數字相加"><a class="header" href="#任務處理-1000-個數字相加">任務：處理 1000 個數字相加</a></h4>
<p><strong>ARM/x86 CPU 方式</strong>：</p>
<pre><code class="language-c">for(int i = 0; i &lt; 1000; i++) {
    sum += array[i];  // 循序，1000 次迴圈
}
</code></pre>
<ul>
<li>一個一個加</li>
<li>需要 1000+ 個時脈週期</li>
</ul>
<p><strong>FPGA 方式</strong>：</p>
<pre><code class="language-verilog">// 建造 1000 個加法器同時運算！
always @(posedge clk) begin
    sum &lt;= array[0] + array[1] + array[2] + ... + array[999];
end
</code></pre>
<ul>
<li>平行處理</li>
<li>幾個時脈週期完成</li>
</ul>
<h3 id="為什麼會有這些不同的晶片"><a class="header" href="#為什麼會有這些不同的晶片">為什麼會有這些不同的晶片？</a></h3>
<h4 id="cpu-的優勢與用途"><a class="header" href="#cpu-的優勢與用途">CPU 的優勢與用途</a></h4>
<pre><code>優點：
✓ 容易編程（C/Python）
✓ 作業系統支援
✓ 豐富的軟體生態
✓ 適合複雜控制邏輯

應用：
• 個人電腦
• 手機
• 伺服器
• 通用運算
</code></pre>
<h4 id="fpga-的優勢與用途"><a class="header" href="#fpga-的優勢與用途">FPGA 的優勢與用途</a></h4>
<pre><code>優點：
✓ 超低延遲
✓ 大量平行處理
✓ 可自訂架構
✓ 硬體級效能

應用：
• 5G 基地臺
• 高頻交易
• AI 推論加速
• 原型設計
</code></pre>
<h3 id="處理器家族定位"><a class="header" href="#處理器家族定位">處理器家族定位</a></h3>
<pre><code>通用處理器（CPU）
├── x86（Intel, AMD）
│   └── 桌機、筆電、伺服器
├── ARM
│   └── 手機、平板、嵌入式
└── RISC-V
    └── 開源、IoT、嵌入式

可編程邏輯（不是CPU！）
└── FPGA（Xilinx, Intel, Lattice）
    └── 可以變成任何數位電路
</code></pre>
<h3 id="混合型產品---soc-fpga"><a class="header" href="#混合型產品---soc-fpga">混合型產品 - SoC FPGA</a></h3>
<pre><code>┌─────────────────────────┐
│   Xilinx Zynq           │
│  ┌─────┐    ┌────────┐ │
│  │ ARM │ ←→ │  FPGA  │ │
│  │ CPU │    │  邏輯  │ │
│  └─────┘    └────────┘ │
└─────────────────────────┘
</code></pre>
<ul>
<li>固定的 ARM CPU + 可編程 FPGA</li>
<li>結合兩者優點</li>
</ul>
<h3 id="簡單總結比較表"><a class="header" href="#簡單總結比較表">簡單總結比較表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>CPU (ARM/x86)</th><th>FPGA</th></tr></thead><tbody>
<tr><td>是什麼</td><td>固定的處理器</td><td>可編程邏輯晶片</td></tr>
<tr><td>執行什麼</td><td>軟體指令</td><td>硬體電路</td></tr>
<tr><td>如何改變功能</td><td>寫新軟體</td><td>重新配置硬體</td></tr>
<tr><td>平行能力</td><td>有限（核心數）</td><td>極高（受資源限制）</td></tr>
<tr><td>開發難度</td><td>簡單（寫程式）</td><td>困難（設計電路）</td></tr>
<tr><td>延遲</td><td>微秒級</td><td>奈秒級</td></tr>
<tr><td>適合</td><td>通用運算、控制</td><td>平行處理、加速</td></tr>
</tbody></table>
</div>
<p><strong>關鍵理解</strong>：</p>
<ul>
<li><strong>CPU</strong> = 買現成的計算機</li>
<li><strong>FPGA</strong> = 買電子零件自己組計算機</li>
</ul>
<p>FPGA 不是 CPU，但 FPGA 可以用來<strong>建造</strong>一個 CPU！</p>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>FPGA 提供了一種與傳統軟體開發完全不同的思維方式。透過 Tang Nano 9K 這樣的入門開發板，你可以用很低的成本開始學習硬體設計的精髓。從簡單的 LED 控制開始，逐步掌握平行處理、時序設計、通訊協定等核心概念，最終能夠設計出自己的數位系統。</p>
<p>關鍵是要動手實作，從簡單的專案開始，逐步挑戰更複雜的設計。FPGA 的學習曲線雖然陡峭，但一旦掌握，你將擁有一種強大的硬體設計能力，能夠解決許多傳統軟體難以處理的問題。</p>
<h3 id="重要觀念釐清"><a class="header" href="#重要觀念釐清">重要觀念釐清</a></h3>
<ol>
<li><strong>FPGA ≠ CPU</strong>：FPGA 是可編程邏輯晶片，不是處理器</li>
<li><strong>FPGA 可以實現 CPU</strong>：用 FPGA 的邏輯資源可以建造一個 CPU（如 RISC-V）</li>
<li><strong>選擇彈性</strong>：可以純用 FPGA、純用軟核 CPU、或混合使用</li>
<li><strong>平行運算差異</strong>：FPGA 是真正的硬體平行，CPU 多核心是任務級平行</li>
</ol>
<h3 id="下一步建議"><a class="header" href="#下一步建議">下一步建議</a></h3>
<ol>
<li>購買一塊 Tang Nano 9K 開發板</li>
<li>在 Ubuntu 上搭建開發環境</li>
<li>從 LED 閃爍開始第一個專案</li>
<li>逐步學習更複雜的設計</li>
<li>參與社群，分享你的專案</li>
</ol>
<p>祝你的 FPGA 學習之旅順利！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../riscv/qemu_gdb_lab.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../centos/centos.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../riscv/qemu_gdb_lab.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../centos/centos.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
