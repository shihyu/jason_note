<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pytorch - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pytorch-學習筆記"><a class="header" href="#pytorch-學習筆記">PyTorch 學習筆記</a></h1>
<p>colab 使用GPU 的方法</p>
<p>Edit -&gt;NoteBook Settings 選GPU</p>
<p><img src="images/1*HpmXaFjFCDL_jAtLaYEeGw.jpeg" alt="img" /></p>
<p>如果要將定義好的張量放到GPU上執行，可以用x.cuda()來指定</p>
<pre><code class="language-python">import torch
import numpy as np
x_tensor = torch.rand(5,3)
y_numpy = np.random.rand(5,3)
x_numpy = x_tensor.numpy()
y_tensor = torch.from_numpy(y_numpy)

print(x_tensor)
print(x_numpy)
print(y_numpy)
print(y_tensor)

if torch.cuda.is_available():
    x = x_tensor.cuda()
    y = y_tensor.cuda()
    print(x+y)
</code></pre>
<p>關於自動微分變數，在使用自動微分變數後，針對後續變數的計算，系統會自動展開計算突來運算。也因為這個關係，可以很快地運用.backward 來執行反向傳播演算法。</p>
<p>下面的例子宣告x 是個張量變數(tensor)，無法調用x.grad_fn方法</p>
<pre><code class="language-python">import torch
import numpy as np
x = torch.ones(3,3)
y = x + 10
print(x)
print(x.grad_fn)
</code></pre>
<p>傳回</p>
<pre><code>tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]])
None
</code></pre>
<p>宣告x為自動微分變數， x = Variable(torch.ones(2,2),requires_grad = True)</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
x = Variable(torch.ones(2,2),requires_grad = True)
y = x + 2
print(y.grad_fn)
</code></pre>
<p>傳回 &lt;AddBackward0 object at 0x7fc37bd17438&gt;</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
num_x = np.array([[1.0, 2.0],[3.0,4.0]])
tensor_x = torch.from_numpy(num_x)
x = Variable(tensor_x,requires_grad = True)
y = x + 2
z = y*y
print(z)
m = torch.mean(z)
print(m)
</code></pre>
<p>傳回</p>
<p>tensor([[ 9., 16.], [25., 36.]], dtype=torch.float64, grad_fn=<MulBackward0>) tensor(21.5000, dtype=torch.float64, grad_fn=<MeanBackward0>)</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
num_x = np.array([[1.0, 2.0],[3.0,4.0]])
tensor_x = torch.from_numpy(num_x)
x = Variable(tensor_x,requires_grad = True)
y = x + 2
z = y*y   #等價  z=torch.mul(y, y)
m = torch.mean(z)
m.backward()
print(x.grad)
</code></pre>
<p>傳回</p>
<p>tensor([[1.5000, 2.0000]</p>
<p>, [2.5000, 3.0000]], dtype=torch.float64)</p>
<hr />
<p>https://minglunwu.com/notes/2020/20200324.html/</p>
<p>研究所時有花時間去了解Neural Network的概念，但卻一直沒有機會進行實作，最近有機會可以從頭開始學習Pytorch，把學習的過程整理記錄下來，希望想要快速上手Pytorch的人，可以透過這篇文章快速入門！</p>
<h1 id="tensor的基本使用格式轉換"><a class="header" href="#tensor的基本使用格式轉換">Tensor的基本使用、格式轉換</a></h1>
<h2 id="建立tensor"><a class="header" href="#建立tensor">建立Tensor</a></h2>
<pre><code class="language-python">a = [1,2,3]
tensor_a = torch.tensor(a)
</code></pre>
<h2 id="tensor-的維度轉換"><a class="header" href="#tensor-的維度轉換">Tensor 的維度轉換</a></h2>
<pre><code class="language-python">tensor_reshape = tensor_a.view(1,-1)
</code></pre>
<h2 id="tensor-中的元素型態轉換"><a class="header" href="#tensor-中的元素型態轉換">Tensor 中的元素型態轉換</a></h2>
<p>僅需要在tensor之後加上轉換的型態即可。</p>
<pre><code class="language-python">tensor_a_long = tensor_a.long() # 將tensor_a轉換為long資料型態。
tensor_a_float = tensor_a.float() # 將tensor_a轉換為float資料型態。
</code></pre>
<h2 id="與其他常用套件之轉換"><a class="header" href="#與其他常用套件之轉換">與其他常用套件之轉換</a></h2>
<pre><code class="language-python">tensor_b = torch.from_numpy(np_element) # numpy -&gt; torch
np_a = tensor_a.numpy() # torch -&gt; numpy
</code></pre>
<hr />
<h1 id="常會使用到的module"><a class="header" href="#常會使用到的module">常會使用到的Module</a></h1>
<p>通常在 <code>Pytorch</code> 時，常會使用到下列的 Module</p>
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

from torch.utils.data import Dataset, DataLoader
from torch.utils.tensorboard import SummaryWriter
</code></pre>
<ul>
<li><strong>torch</strong> : <code>Pytorch</code> 基本的套件</li>
<li><strong>torch.nn</strong> : 定義了基本的 Layer 元件 (例如: Linear)，在建構模型時會使用到。(請見<a href="https://minglunwu.com/notes/2020/20200324.html/#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8BNetwork">5. 如何建立一個Network。</a>)</li>
<li><strong>torch.nn.functional</strong> : 定義了卷積、Activation Function 等。</li>
<li><strong>torch.optim</strong> : 定義了許多常見的 optimizer.（請見<a href="https://minglunwu.com/notes/2020/20200324.html/#%E8%A8%93%E7%B7%B4%E7%9A%84Pipeline">7.訓練的Pipeline</a>)</li>
<li><strong>torch.utils.data</strong> : 定義了 Dataset 及 DataLoader 等資料相關 Class (請見<a href="https://minglunwu.com/notes/2020/20200324.html/#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%A8%93%E7%B7%B4%E8%B3%87%E6%96%99%E9%9B%86">6. 如何建立訓練資料集</a>)</li>
<li><strong>torch.utils.tensorboard</strong> : 定義了與 Tensorboard 互動相關的 Class (請見<a href="https://minglunwu.com/notes/2020/20200324.html/#%E8%A6%96%E8%A6%BA%E5%8C%96%E5%B7%A5%E5%85%B7-TensorBoard">8. 視覺化工具-TensorBoard</a>)</li>
</ul>
<hr />
<h1 id="建立一個network"><a class="header" href="#建立一個network">建立一個Network</a></h1>
<p>通常透過 <code>Pytorch</code> 建立一個 Network 時，我們習慣透過定義<strong>Python 的 Class</strong> 來建構我們的 Network. 這一個Python Class 必須具備下列特性:</p>
<ol>
<li>
<p>必須繼承 <code>torch.nn.Module</code>，這樣才能使用 Pytorch 內建的各種 function，並且與其他 Pytorch 元件進行互動。</p>
</li>
<li>
<p>繼承 <code>torch.nn.Module</code>後，會需要 Override 一些特定的 Method:</p>
<ul>
<li><strong><em>*init*</em>()</strong>:</li>
</ul>
<p>定義在 Initial 此 Class(Network) 時需要初始化的元件。基本上在 Network 中需要使用到的 Layer、Hyperparameter 都需要在這邊先行定義。</p>
<ul>
<li>
<p>forward()</p>
<p>:</p>
<ul>
<li>透過 Override forward 這個 Method 來定義此 Network 的 Forward Propagation 方式。</li>
<li>值得注意的是 <code>forward()</code> 在 Override 以後，往後透過可以直接透過 call model 來進行 forward(). (請看下方範例)</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="language-python">class MyOwnNet(nn.Module):
    def __init__(self):
        super(my_own_net, self).__init__() #初始化 nn.Module class

        # 以下按照需求定義Layer.
        self.ln = nn.Linear(768, 384)
        self.ln_2 = nn.Linear(384, 10)
    
    def forward(self, x):
        outputs = self.ln(x)
        outputs = self.ln_2(outputs)

if __name__ == "__main__":
    net = MyOwnNet()
    test = list(range(768))
    test_input = torch.tensor(test)
    outputs = net(test_input) # 直接呼叫instance，將會自動執行forward()的function.
</code></pre>
<hr />
<h1 id="建立訓練資料集"><a class="header" href="#建立訓練資料集">建立訓練資料集</a></h1>
<p>在定義好模型架構後，接著需要處理資料的部分。</p>
<p>當然在提供訓練資料時，我們也可以單純透過迴圈的方式自行提取，但是透過 <code>Pytorch</code> 的資料集，我們不需要再特別去處理「Batch size」或是「Shuffle」的問題。</p>
<p>這裡記錄了兩種 <code>Pytorch</code> 內建的 Module 提供我們實作並且改寫:</p>
<ol>
<li>Dataset</li>
<li>DataLoader</li>
</ol>
<h2 id="dataset"><a class="header" href="#dataset">Dataset</a></h2>
<p>實作時，與上節建立 Network 相同，需要先定義一個 Python Class 來繼承 <code>torch.utils.data.Dataset</code>，並且要Override 以下 Methods:</p>
<ul>
<li><strong><em>*init*</em>(self)</strong>: 初始化 instance 時需要進行的動作，通常會在這個地方載入資料集、或是進行前處理。</li>
<li><strong>_getitem(self, index)__</strong>: 定義使用 idx 去 query 元素時要進行的動作。 (通常直接回傳第 index 筆資料)</li>
<li><strong>_len(self)__</strong>: 定義使用 len() 去取得 instance 元素數量時要進行的動作。 （通常直接回傳資料筆數)</li>
</ul>
<pre><code class="language-python">class OwnDataset(Dataset):
    def __init__(self, file_path):
        super(OwnDataset, self).__init__()
        self.data = pickle.load(open(file_path, "rb")) # 讀取資料
    
    def __len__(self):
        return len(self.data)
    
    def __getitem__(self, idx):
        return {"x": self.data["feature"], "y": self.data["label"]}
    
if __name__ == "__main__":
    dataset = OwnDataset("./data/test.pickle") #Initial an instance.

    print(len(dataset)) # Call __len__()
    a_example = dataset[0] # Call __getitem__()

    feature, label = a_example["x"], a_example["y"]
</code></pre>
<p>從範例中可以看到使用 Dataset 的好處在於先行定義好回傳資料的格式、以及如何取用資料。進行訓練時就不需要再重複的撰寫取用資料的程式。</p>
<p>也可以在Dataset中加入一個 <code>type</code> 變數來切換要回傳 training、evaluation、testing set. 並且針對傳入的型態不同來進行資料的Sample。</p>
<h2 id="dataloader"><a class="header" href="#dataloader">DataLoader</a></h2>
<p>除此之外，再進行訓練時常會需要動態的調整 <code>batch_size</code> 以及需要打亂資料(Shuffle)，如果自行撰寫 Function 的話，常會被 index 搞得昏頭轉向。 有時多一個 idx 就會造成 out of range 的錯誤。</p>
<p>此時如果你有按照上述的格式定義好一個 <code>Dataset</code>，那麼以上任務都不用擔心，我們可以透過 <code>DataLoader</code> 直接處理好。</p>
<p><code>DataLoader</code> 具有幾個參數:</p>
<ul>
<li>dataset: 放入我們剛剛創建的 OwnDataset Instance.</li>
<li>batch_size: 一個 batch 要包含多少資料筆數。</li>
<li>shuffle: 是否對資料進行隨機調整。</li>
<li>num_workers: 透過 Multi-Process 來加速資料的取用，避免訓練時速度被 IO 給限制。（不建議使用在GPU環境)</li>
<li>pin_memory: 在使用 GPU 時，啟用此屬性能提升訓練速度。</li>
</ul>
<p>有關 <code>num_workers</code>, <code>pin_memory</code> 的探討，建議可以參考<a href="https://pytorch.org/docs/stable/data.html#single-and-multi-process-data-loading">官方文件</a></p>
<pre><code class="language-python">data_loader = DataLoader(dataset= dataset, batch_size= 4, shuffle= True, num_workers= 2, pin_memory= True)

print(len(data_loader)) #回傳當前共有幾個batch，可以直接用這個數值來作為Step.

data_iter = iter(data_loader)
x, y = data_iter.next() # 透過這種方式來取用資料。

for (x,y) in data_iter: # 也可以透過For loop來取用資料。
    some_train_step(x)
</code></pre>
<p>在定義完 <code>Dataset</code> 後，透過 <code>DataLoader</code> 來對資料進行訓練前的處理，接著就能按照需求去取得資料。相當的方便且簡潔。</p>
<hr />
<h1 id="訓練的pipeline"><a class="header" href="#訓練的pipeline">訓練的Pipeline</a></h1>
<p>個人認為建構 Model 的 Pipeline 大略如下:</p>
<ol>
<li>定義 Model.</li>
<li>定義 Dataset.</li>
<li>定義 Loss 以及 Optimizer.</li>
<li>進行訓練.</li>
</ol>
<p>其中第一點以及第二點請參考本文前段。</p>
<h2 id="定義loss及optimizer"><a class="header" href="#定義loss及optimizer">定義Loss及Optimizer</a></h2>
<p>在 <code>torch.nn</code> 以及 <code>torch.nn.Functional</code> 中定義了許多不同的 Loss Function，可以根據需求自行選擇. 以下範例以分類問題的 CrossEntropy 為例:</p>
<pre><code class="language-python">import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

# Init an instance.
criterion = nn.CrossEntropyLoss() 
# 建立一個optimizer來優化 model 的所有"可訓練參數"
optimizer = optim.Adam(model.parameters(), lr=1e-5)
</code></pre>
<p>首先，必須先建立計算 Loss 以及 Optimizer 的 Instance。</p>
<p>在建立 Optimizer 時會需要設定優化的對象，通常會直接放 <code>model.parameters()</code>，代表 <code>model</code> 中所有可訓練的參數。而不同的 Optimizer(SGD, Adam, …) 會有不同的參數要進行設定。</p>
<h2 id="進行訓練"><a class="header" href="#進行訓練">進行訓練</a></h2>
<pre><code class="language-python">feature, label = data_iter.next() #透過前面提到的iterator取得一個batch的資料。

outputs = model(x) # 將訓練資料送入model中進行forward propagation。

loss = criterion(outputs, y) # 回傳當前Forward結果與真實Label的Loss

optimizer.zero_grad() # 先清空當前的梯度值
loss.backward() # 進行Backward Propagation
optimizer.step() # 針對Backward Propagation所得到的梯度調整參數。
</code></pre>
<p>接著直接呼叫 <code>model(x)</code> 如同上節所說，就是直接將 <code>x</code> 送入 <code>model</code> 中進行 Forward Propagation。 得到的結果可以直接與真實 label 送到剛剛建立的 Loss Instance 計算 Loss.</p>
<p>在計算完Loss後，我們就能直接使用 <code>loss.backward()</code> 來取得 Loss 對所有參數的梯度。 在 <code>Pytorch</code> 中，我們只有定義 Forward 的方式，而 Backward Propagation 只需要透過短短一行即可得到。</p>
<p>取得每一個參數的梯度以後，就能呼叫剛剛定義的 <code>optimizer.step()</code> 來進行參數調整。</p>
<p>以上就是一次的訓練迭代: <strong>Forward propagation -&gt; 計算Loss -&gt; Backward propagation -&gt; Optimize (根據梯度調整Weight.)</strong></p>
<p>實際訓練時可根據需求來不斷從 Data Iterator 中取得資料，重複上述迭代進行訓練，也因為會有不斷的迭代，所以記得使用 <code>optimizer.zero_grad()</code> 來清空上一次的梯度。</p>
<p>另外，在 <code>Pytorch</code> 中的 <code>Tensor</code> 都會有 <code>requires_grad</code> 的屬性，如果啟用的話會自動追蹤計算圖，方便直接呼叫<code>backward()</code>，如果不希望啟用的話，可以透過下列方法解除:</p>
<pre><code class="language-python"># Method 1
tensor_nograd = torch.tensor([1,2,3], requires_grad=False)

# Method 2
with torch.no_grad(): # 以下做的事情都不會取得梯度。
    # Your Code.
</code></pre>
<hr />
<h1 id="視覺化工具-tensorboard"><a class="header" href="#視覺化工具-tensorboard">視覺化工具-TensorBoard</a></h1>
<h2 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h2>
<p>在訓練的過程中，我們需要觀察 Loss 或是 Accuracy 來確認訓練的效果，雖然可以透過 Print Log 的方式來顯示，但其實透過有更好的工具能夠協助視覺化。</p>
<pre><code class="language-python">from torch.utils.tensorboard import SummaryWriter

LOGDIR = "./logs/" # Define 資料要被寫入的位置
writer = SummaryWriter(LOGDIR)

for n_iter in range(100):
    writer.add_scalar('Loss/train', np.random.random(), n_iter)
    writer.add_scalar('Loss/test', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/train', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/test', np.random.random(), n_iter)
</code></pre>
<p>也就是在定義了一個 writer 後，可以透過 <code>writer.add_scalar</code> 的方式將想要觀測的值記錄下來，同時可以分門別類的設定標籤、Step 或是 Epoch 數目。 除了<code>add_scalar</code> 外，還有許多如 <code>add_image</code>、<code>add_graph</code> 的方法可以使用。</p>
<p>寫入資料後，執行 tensorboard 即可在 LocalHost 的瀏覽器觀察結果:</p>
<pre><code class="language-bash">pip install tensorboard
tensorboard --logdir="./logs"
</code></pre>
<p><img src="images/hier_tags.png" alt="img" /></p>
<p><a href="https://pytorch.org/docs/stable/tensorboard.html">圖片來源</a></p>
<h2 id="remote-server"><a class="header" href="#remote-server">Remote Server</a></h2>
<p>另外在進行機器學習時，常常會需要使用到遠端主機的 GPU，紀錄一下如何在 Localhost 查看遠端機器的訓練狀態。 首先還是一樣要在訓練過程中透過 <code>SummaryWriter</code> 將 log 寫入。</p>
<p>接著透過 SSH連線將本地端的一個 Port 與遠端機器的特定 Port 綁定在一起，首先在本地端執行:</p>
<pre><code class="language-bash">ssh -L 16001:127.0.0.1:16001 username@server_ip
</code></pre>
<p>透過特定 Port 與遠端主機連線。</p>
<p>接著在<strong>遠端主機</strong>執行</p>
<pre><code class="language-bash">tensorboard --logdir="./logs" --port=16001
</code></pre>
<p>同樣的啟動指令，只是規定要在剛剛設定 Port 上啟動服務。</p>
<p>如此一來就能在自己的主機上查看遠端 Server 的訓練狀況了。</p>
<hr />
<h1 id="儲存載入model"><a class="header" href="#儲存載入model">儲存、載入Model</a></h1>
<p>在訓練完模型後，需要將模型儲存下來，方便日後驗證或使用。 <code>Pytorch</code> 提供了兩種儲存方法: <code>完整模型</code> 以及 <code>State_dict</code></p>
<h2 id="完整模型"><a class="header" href="#完整模型">完整模型:</a></h2>
<p>官方較不推薦這種方式，由於是透過 <code>pickle</code> 的方式進行儲存，很可能會遭遇意料之外的問題。</p>
<h3 id="save"><a class="header" href="#save">Save</a></h3>
<pre><code class="language-python">torch.save(model, PATH)
</code></pre>
<h3 id="load"><a class="header" href="#load">Load</a></h3>
<pre><code class="language-python">model = torch.load(PATH)
model.eval()
</code></pre>
<p>在 <code>Pytorch</code> 的 model 中，可以透過 <code>model.train()</code> 以及 <code>model.eval()</code> 來切換不同模式，使用 <code>model.eval()</code> 會將 dropout layer 以及 batch_normalization 切換成驗證模式，避免在 Inference 的過程中造成結果不一致。</p>
<h2 id="state-dict"><a class="header" href="#state-dict">State Dict</a></h2>
<p>State Dictionary 則是透過 <code>Python 的 Dictionary</code> 來儲存每一層的內容以及權重。如果要查看的話可以透過<code>model.state_dict()</code> 來取得。</p>
<h3 id="save-1"><a class="header" href="#save-1">Save</a></h3>
<pre><code class="language-python">torch.save(model.state_dict(), PATH)
</code></pre>
<h3 id="load-1"><a class="header" href="#load-1">Load</a></h3>
<pre><code class="language-python">model = MyOwnNet() # 要先建立相同的Class Instance.
model.load_state_dict(torch.load(PATH))
model.eval()
</code></pre>
<hr />
<h1 id="使用gpu"><a class="header" href="#使用gpu">使用GPU</a></h1>
<p>在上述的內容完成後，基本上已經可以建立一個簡易的 Neural Network 了，接下來紀錄如何將快速的將資料從 CPU 訓練切換為 GPU.</p>
<p>首先要先確定自己的 <code>Pytorch</code> 是有安裝到 CUDA 版本。 可以透過下列指令確認:</p>
<pre><code class="language-python">print(torch.cuda.is_available())
</code></pre>
<p>如果是 True 則代表有成功偵測到 GPU，若為 False 則可能是設定錯誤！</p>
<p>接著要建立一個 device 變數:</p>
<pre><code class="language-python">device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
</code></pre>
<p>接著就是將自己的 Model 以及需要送進 Model 的 Input 都轉換為 GPU 模式.</p>
<pre><code class="language-python">model = model.to(device)
x, y = x.to(device), y.to(device)
# 以下正常進行使用
</code></pre>
<p>只要加上短短一行指令即可切換為 GPU 模式，此時如果在 print 這些 tensor，可以發現數值不變，但是後面多了一個"cuda:n" 屬性，這就代表 Tensor 已經被送到 GPU 去了。</p>
<hr />
<h1 id="後記"><a class="header" href="#後記">後記</a></h1>
<p>在學習 <code>Pytorch</code> 的過程中，很多教材都是語法居多，透過實際進行任務的方式教學，但我在過程中對於許多 Component都似懂非懂，現在稍微釐清後，記錄下來，希望如果是想學習 <code>Pytorch</code> 的入門者，看完這篇文章可以瞭解一些基本觀念，在看網路上的 Tutorial 或是 Track 別人的 Code 時，能夠不再霧煞煞～</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ml/llm-inference-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ml/pytorch_setup.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ml/llm-inference-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ml/pytorch_setup.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
