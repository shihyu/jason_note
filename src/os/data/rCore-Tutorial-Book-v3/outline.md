# 更新記錄
### 2021-01-04更新：

Chaptter4 添加實現的過程描述：改進內存隔離的好處；

### 2020-12-20更新：

將文件描述符從 Chapter7 移動到 Chapter6。

### 2020-12-02更新：

根據討論更新了 Chapter1-Chapter7 到分割線之前的內容作為 Tutorial 的第一部分，即讓系統能夠將所有的資源都利用起來。第二部分則討論如何做的更好。在 12 月 26 日之前儘可能按照大綱完成多個不同版本的 demo。

[https://shimo.im/sheets/wV3VVxl04EieK3y1/MODOC](https://shimo.im/sheets/wV3VVxl04EieK3y1/MODOC)是目前的系統調用一覽表，預計只需要實現 14 個系統調用就能初步滿足要求。

### 2020-11-30更新：

更新了Chapter2。

合併了Chapter3/Chapter4為Chapter3，目前覆蓋範圍為Chapter1-Chapter5。

### lab 設計：2020-11-01

#### 可能的章節與代碼風格

* 新 OS 實驗的目的是：“**強化學生對 OS 的整體觀念**”。OS的目的是滿足應用需求，為此需要一定的硬件支持和自身逐步增強的功能。鼓勵學生自己從頭寫（有參考實現）、強化整體觀、step-by-step。
* **整個文檔的風格是應用**導向的，每個 step 的任務一定不是憑空而來、而是**應用**的需求。每一章都是為了解決一個應用具體需求而要求OS要完成的功能，這個功能需要一定的硬件支持。
* 每個章節給出完整可運行且帶有完整註釋（可以通過 rustdoc 工具生成 html 版）的代碼。
* 文檔中給出重要的代碼片段（照顧到紙質版的讀者，事實上在網頁版給出代碼的鏈接即可）而並不需要完整的代碼，但是需要有完整的執行流程敘述，對於邊界條件有足夠的討論。在文檔中插入的代碼不帶有註釋，而是將解釋放到文檔的文字部分。
* 類似xv6，每一章的小節描述一項小功能是如何實現的，不同小節之間可能有一定的先後關係，也有可能是並列的。
* 儘可能講清楚設計背後的思想與優缺點。
* 在講解OS設計方面，儘量做到與語言無關。在講解例子的時候，應該有對應的C和rust版本。
* 在某些具體例子中，最好能體現rust比c強
* 2020-10-28：前幾章 Chapter1-4 需要等具體實現出來之後再規劃章節。

# 章節大綱
## Chapter0 Hello world! 之旅（偏概述）

### 主要動機：

參考 csapp 第一章，站在一個相對宏觀的視角解釋一個非常簡單的 hello world! 程序是在哪些硬件/軟件的支持下得以編譯/運行起來的。

helloworld.c 如何被編譯器編譯成執行程序，且如何被操作系統執行的。

gcc

strace

## Chapter1 裸機應用（優先級1）

### 主要動機

支持應用進行計算與結果輸出。

在裸機上輸出 Hello world，就像在其他 OS 上一樣。

app列表：

* hello_world：輸出字符串
* count_sum：累加一維數組的和，並輸出結果

備註：不需要輸入功能

### 內核應完成功能

內存地址空間：

知道自己在內存的哪個位置。理解編譯器生成的代碼。

init：基本初始化

主要是硬件加電後的硬件初始化，以前是OS做，後面給BIOS, bootloader等完成初步初始化。OS需要知道內存大小，IO分佈。

write函數：輸出字符串

驅動串口的初始化，能夠通過串口輸出。

exit函數：表明程序結束

其它（不是主要的）：

在 qemu/k210 平臺上基於 RustSBI 跳轉到內核，打印調試信息，支持內核堆內存分配。

### 章節分佈

基本上和第二版/第三版一致。注意需要考慮上面的應用和功能。

## Chapter2批處理系統（優先級1）

### 主要動機

內核不會被應用程序破壞

### 用戶程序

支持應用進行計算與結果輸出。在裸機上輸出 Hello world，就像在其他 OS 上一樣。但應用程序無法破壞內核，但能得到內核的服務。

app列表：

* hello_world：輸出字符串。
* count_sum：累加一維數組的和，並輸出結果。
### 內核應完成功能

設置好內核和用戶運行的棧，內核初始化完成後通過 sret 跳轉到用戶程序進行執行，然後在用戶程序系統調用的時候完成特權級切換、上下文保存/恢復及棧的切換

按順序加載運行多個應用程序。當應用程序出錯（非法指令基於 RustSBI 不容易完成，比如訪問非法的物理地址）之後直接殺死應用程序並切換到下一個。

### 新增系統調用

* sys_write：向串口寫
* sys_exit： 表明任務結束。
### 實現備註

將編譯之後的用戶鏡像和內核打包到一起放到內存上

分離用戶和內核特權級，保護OS，用戶需要請求內核提供的服務

## 
## Chapter3 分時多任務系統之一非搶佔式調度（優先級1）

### 主要動機

提高整個應用的CPU利用率

多任務，因此需要實現任務切換，可採用如下方法：

* 批處理：在內存中放多個程序，執行完一個再執行下一個。當執行IO操作時，採用的是忙等的方式，效率差。
* 非搶佔切換：CPU和I/O設備之間速度不匹配矛盾，程序之間的公平性。當一個程序主動要求暫停或退出時，換另外一個程序執行CPU計算。

*>> 這時，可能需要引入中斷（但中斷不是本章主要的內容，如果不引入更好）。*

### 用戶程序

兩個程序放置在一個不同的固定的物理地址上（這樣不需要頁表機制等虛存能力），完成的功能為：一個程序完成一些計算&輸出，主動暫停，OS切換到另外一個程序執行，交替運行。

* count_multiplication：一維數組的乘法，並輸出結果
* count_sum：累加一維數組的和，並輸出結果
* [wyf 的具體實現]三個輸出小程序，詳見[here](https://github.com/rcore-os/rCore-Tutorial-v3/tree/ch3-coop/user/src/bin)
### 內核應完成功能

實現通過 sys_yield 交出當前任務的 CPU 所有權，通過 sys_exit 表明任務結束。需要為每個任務分配一個用戶棧和內核棧，且需要實現類似 switch 用來任務切換的函數。

* sys_yield：讓出CPU
* sys_exit：退出當前任務並讓出 CPU
### 實現備註

重點是實現switch

當所有任務運行結束後退出內核

## Chapter3 分時多任務系統之二 搶佔式調度（優先級1）

### 主要動機

進一步提高整個應用的CPU利用率/交互性與任務之間的公平性

因此需要實現強制任務切換，並引入中斷，可採用如下方法：

* 時鐘中斷：基於時間片進行調度
* （不在這裡引入）串口中斷：在發出輸出請求後，不是輪詢忙等，而是中斷方式響應
### 用戶程序

* [wyf 的具體實現]三個計算質數冪次的小程序，外加一個 sleep 的程序。[here](https://github.com/rcore-os/rCore-Tutorial-v3/tree/ch3/user/src/bin)
### 內核應完成功能

實現時鐘/串口中斷處理，以及基於中斷的基本時間片輪轉調度

### 新增系統調用

* sys_get_time：返回當前的 CPU 時鐘週期數
## Chapter4 內存隔離安全性：地址空間（優先級1）

### 主要動機

* 更好地支持應用（包括內核）的動態內存需求。首先：在內核態實現動態內存分配（這是物理內存），這樣引入了堆的概念
* 更好地支持在內核中對非法地址的訪問的檢查。在內核態實現頁表機制，這樣內核訪問異常地址也能及時報警。
* 提高應用間的安全性（通過頁機制實現隔離）
* 附帶好處：應用程序地址空間可以相同，便於應用程序的開發
### 用戶程序

應用程序與上一章基本相同，只不過應用程序的地址空間起始位置應該相同。而且這一章需要將 ELF 鏈接進內核而不是二進制鏡像。

特別的，可以設置訪問其他應用程序地址空間或是訪問內核地址空間的應用程序，內核會將其殺死。

在用戶庫使用 sbrk 申請動態分配空間而不是放在數據段中。

### 內核應完成功能

* 內核動態內存分配器（對於 Rust 而言，對於 C 仍可以考慮靜態分配）
* 物理頁幀分配器
* 頁表機制，特別是用戶和內核地址空間的隔離（參考 xv6）
* ELF 解析和加載（在內核初始化的時候完成全部的地址空間創建和加載即可） 
### 新增系統調用

* sys_sbrk：拓展或縮減當前應用程序的堆空間大小
### 建議實現過程：

1. 在Chapter1的基礎上實現基本的物理內存管理機制，即連續內存的動態分配。
2. 在Chapter1的基礎上實現基本的頁表機制。
3. 然後再合併到Chapter3上。
## Chapter5 進程及重要系統調用（優先級1）

### 主要動機

應用以進程的方式進行運行，簡化了應用開發的負擔，OS也更好管理

引入重要的進程概念，整合Chapt1~4的內容抽象出進程，實現一系列相關機制及 syscall

### 用戶程序

shell程序 user_shell以及一些相應的測試

### 內核應完成功能

實現完整的子進程機制，初始化第一個用戶進程 initproc。

### 新增系統調用

* sys_fork
* sys_wait(輪詢版)
* sys_exec
* sys_getpid
* sys_yield更新
* sys_exit 更新
* sys_read：終端需要從串口讀取命令
## Chapter6 文件系統與進程間通信（優先級1）

### 主要動機

進程之間需要進行一些協作。本章主要是通過管道進行通信。

同時，需要引入文件系統，並通過文件描述符來訪問對應類型的 Unix 資源。

### 用戶程序

簡單的通過 fork 和子進程共享管道的測試；

【可選】強化shell程序的功能，支持使用 | 進行管道連接。

### 內核應完成功能

實現管道。

將字符設備（標準輸入/輸出）和管道封裝為通過文件描述符訪問的文件。

### 新增系統調用

* sys_pipe：目前對於管道的 read/write 只需實現輪詢版本。
* sys_close：作用是關閉管道
## Chapter7 數據持久化（優先級1）

### 主要動機

實現數據持久化存儲。

### 用戶程序

多種不同大小的文件讀寫。

### 內核應完成功能

實現另一種在塊設備上持久化存儲的文件。

文件系統不需要實現目錄。

### 新增系統調用

* sys_open：創建或打開一個文件
# ----------------------------分割線-------------------------------------------------

## Chapter6 單核同步互斥（優先級1，需要劃分為單核/多核兩部分）

### 主要動機：

應用之間需要在操作系統的幫助下有序共享資源（如串口，內存等）。

解釋內核中已有的同步互斥問題，並實現阻塞機制。

### 內核應完成功能：

實現死鎖檢測機制，並基於阻塞機制實現 sys_sleep 和 sys_wait 以及 sys_kill

### 新增系統調用：

sys_sleep 以及 sys_wait/sys_kill 的更新

### 章節分佈：

#### 基於原子指令實現自旋鎖

* 討論併發衝突的來源（單核/多核）
* 關中斷/自旋/自旋關中斷鎖各自什麼情況下能起作用，在課上還講到一種獲取鎖失敗直接 yield 的鎖
* 原子指令與內存一致性模型簡介
* 具體實現
* 需要說明的是，課上的鎖是針對於同一時刻只能有一個進程處於臨界區之內。但是 Rust 風格的鎖，也就是 Mutex 更加類似於一個管程（儘管 Rust 語言並沒有這個概念），它用來保護一個數據結構，保證同一時間只有一個進程對於這個數據結構進行操作，自然保證了一致性。而 xv6 裡面的鎖只能保護臨界區，相對而言對於數據結構一致性的保護就需要更加複雜的討論。
#### 死鎖檢測

#### 阻塞的同步原語：條件變量

簡單討論一下其他的同步原語。

* 課上提到的信號量和互斥量（後者是前者的特例）保護的都是某一個臨界區
#### 基於條件變量實現 sys_sleep

#### 基於條件變量重新實現 sys_wait

#### 更新 sys_kill 使得支持 kill 掉正在阻塞的進程

## ChapterX IPC（優先級1）

### 主要動機：

應用之間需要交換信息

### 內核應完成功能：

* pipe
* shared mem
### 新增系統調用：

## Chapter8 設備驅動（優先級2）

### 主要動機：

應用可以把I/O 設備用起來。

### 內核應完成功能：

實現塊設備驅動和串口驅動，理解同步/異步兩種驅動實現方式

#### 背景知識：設備驅動、設備寄存器、輪詢、中斷

#### 設備樹（可選）

#### 實現 virtio_disk 塊設備的塊讀寫（同步+輪詢風格）

#### 實現 virtio_disk 塊設備的塊讀寫（異步+中斷風格）

#### 實現串口設備的異步輸入和同步輸出

* 參考 xv6，可以在內核裡面維護一個 FIFO，這樣即使串口本身沒有 FIFO 也可以
## Chapter9 Unix 資源：文件（優先級1）

### 主要動機：

應用可以通過單一接口（文件）訪問磁盤來保存信息和訪問其他外設

Unix 萬物皆文件，將文件作為進程可以訪問的內核資源單位

### 內核應完成功能：

支持三種不同的 Unix 資源：字符設備（串口）、塊設備（文件系統）、管道

### 新增系統調用：

sys_open/sys_close

### 背景知識：Unix 萬物皆文件/進程對於文件的訪問方式

#### file 抽象接口

* 支持 read/write 兩種操作，表示 file 到地址空間中一塊緩衝區的讀寫操作
#### 字符設備路線

* 直接將串口設備驅動封裝一下即可。
#### 文件系統路線

* 分成多個子章節，等實現出來之後才知道怎麼寫
#### 管道路線

* 一個非常經典的讀者/寫者問題。
### ChapterX 虛存管理（優先級2）

### 主要動機：

提高應用執行的效率（側重內存）

- 支持物理內存不夠的情況

- copy on write

### 內核應完成功能：

### 新增系統調用：



### Chapter10 多核（可選）

### 主要動機：

提高應用執行的並行執行效率（側重多處理器）

### 內核應完成功能：

### 新增系統調用：

#### 多核啟動與 IPI

#### 多核調度

### Chapter11多核下的同步互斥（可選）

### 主要動機：

提高應用並行執行下的正確性（側重多處理器）

### 內核應完成功能：

### 新增系統調用：

#### 多核啟動與 IPI

#### 多核調度

## Appendix A Rust 語言快速入門與練習題

## Appendix B 常見構建工具的使用方法

比如 Makefile\ld 等。

## Appendix C RustSBI 與 Kendryte K210 兼容性設計

## 其他附錄…

