操作系統的特徵
================================================

.. toctree::
   :hidden:
   :maxdepth: 5


基於操作系統的四個抽象，我們可以看出，從總體上看，操作系統具有五個方面的特徵：虛擬化 (Virtualization)、併發性 (Concurrency)、異步性、共享性和持久性 (Persistency)。操作系統的虛擬化可以理解為它對內存、CPU 的抽象和處理；併發性和共享性可以理解為操作系統支持多個應用程序“同時”運行；異步性可以從操作系統調度、中斷處理對應用程序執行造成的影響等幾個方面來理解；持久性則可以從操作系統中的文件系統支持把數據方便地從磁盤等存儲介質上存入和取出來理解。

虛擬性
----------------------------------


內存虛擬化
~~~~~~~~~~~~~~

首先來看看內存虛擬化。程序員在寫應用程序的時候，不用考慮其程序的起始內存地址要放到計算機內存的具體某個位置，而是用字符串符號定義了各種變量和函數，直接在代碼中便捷地使用這些符號就行了。這是由於操作系統建立了一個 *地址固定* ， *空間巨大* 的虛擬內存給應用程序來運行，這是 **內存虛擬化** 。內存虛擬化的核心問題是：採用什麼樣的方式讓虛擬地址和物理地址對應起來，也就是如何將虛擬地址“翻譯”成物理地址。

**內存虛擬化** 其實是一種 **“空間虛擬化”** ， 可進一步細分為 **內存地址虛擬化** 和 **內存大小虛擬化** 。這裡的每個符號在運行時是要對應到具體的內存地址的。這些內存地址的具體數值是什麼？程序員不用關心。為什麼？因為編譯器會自動幫我們把這些符號翻譯成地址，形成可執行程序。程序使用的內存是否佔得太大了？在一般情況下，程序員也不用關心。

.. note::

  還記得虛擬地址（邏輯地址）的描述嗎？  
  
  實際上，編譯器 (Compiler，比如 gcc) 和鏈接器 (linker，比如 ld) 也不知道程序每個符號對應的地址應該放在未來程序運行時的哪個物理內存地址中。所以，編譯器的一個簡單處理辦法就是，設定一個固定地址（比如 0x10000）作為起始地址開始存放代碼，代碼之後是數據，所有變量和函數的符號都在這個起始地址之後的某個固定偏移位置。假定程序每次運行都是位於一個不會變化的起始地址。這裡的變量指的是全局變量，其地址在編譯鏈接後會確定不變。但局部變量是放在堆棧中的，會隨著堆棧大小的動態變化而變化。這裡編譯器產生的地址就是虛擬地址。

  這裡，編譯器和鏈接器圖省事，找了一個適合它們的解決辦法。當程序要運行的時候，這個符號所對應的虛擬內存地址到計算機的物理內存地址的映射必須要解決了，這自然就推到了操作系統身上。操作系統會把編譯器和鏈接器生成的執行代碼和數據放到空閒的物理內存中，並建立虛擬地址到物理地址的映射關係。由於物理內存中的空閒區域是動態變化的，這導致虛擬地址到物理地址的映射關係也是動態變化的，需要操作系統來維護好可變的映射關係，確保編譯器“固定起始地址”的假設成立。只有操作系統維護好了這個映射關係，才能讓程序員只需寫一些易於人理解的字符串符號來代表一個內存空間地址。這樣，編譯器只需確定一個固定地址作為程序的起始地址，就可以不用考慮將來這個程序要在哪個物理地址空間運行的問題，從而實現了 **內存地址虛擬化** 。

應用程序在運行時不用考慮當前物理內存是否夠用。如果應用程序需要一定空間的內存，但由於在某些情況下，物理內存的空閒空間可能不多了，這時操作系統通過把物理內存中最近沒使用的空間（不是空閒的，只是最近用得少）換出（就是“挪地”）到硬盤上暫時緩存起來，這樣空閒空間就大了，就可以滿足應用程序的運行時內存需求了，從而實現了 **內存大小虛擬化** 。

CPU 虛擬化
~~~~~~~~~~~~~~

再來看 CPU 虛擬化。不同的應用程序可以在內存中併發運行，相同的應用程序也可有多個拷貝在內存中併發運行。而每個程序都“認為”自己完全獨佔了 CPU 在運行，這是 **“CPU虛擬化”**，也是一種 **“時間虛擬化”** 。操作系統給了運行的應用程序一個幻象，即操作系統把時間分成小段，每個應用程序佔用其中一小段時間片運行，用完這一時間片後，操作系統會切換到另外一個應用程序，讓它運行。由於時間片很短，操作系統的切換開銷也很小，應用程序或使用應用程序的用戶基本上是看不出的，反而感覺到多個程序各自在獨立“並行”執行，從而實現了 **CPU虛擬化** 。


併發性
----------------------------------

操作系統為了能夠讓 CPU 充分地忙起來，並充分利用各種資源，就需要有多種不同的應用程序在執行。這些應用程序是分時執行的，並由操作系統來完成各個應用在運行時的任務切換。併發性雖然能有效改善系統資源的利用率，但也帶來了對共享資源的爭奪問題，即同步互斥問題。還會帶來執行時間的不確定性問題，即併發程序在執行中是走走停停，斷續推進的，使得應用程序的完成時間是不確定的。併發性對操作系統的設計也帶來了很多挑戰，一不小心就會出現程序執行結果不確定，程序死鎖等很難調試和重現的問題。

.. _term-parallel-concurrency:

.. note::
  * 並行 (Parallel) 是指兩個或者多個事件在同一時刻發生；
  * 併發 (Concurrent) 是指兩個或多個事件在同一時間間隔內發生。  
  
  對於基於單 CPU 的計算機而言，各個“同時”運行的程序其實是串行分時複用一個 CPU ，任一個時刻點上只有一個程序在 CPU 上運行。  
  這些虛擬性的特徵給應用程序的開發和執行提供了非常方便的執行環境，但也給操作系統的設計與實現提出了很多挑戰。

異步性
----------------------------------

在這裡，異步是指由於操作系統的調度和中斷等，會不時地暫停或打斷當前正在運行的程序，使得程序的整個運行過程走走停停。在應用程序運行的表現上，特別體現在它的執行完成時間是不可預測的。但需要注意，只要應用程序的輸入是一致的，那麼它的輸出結果應該是符合預期的。

共享性
----------------------------------

共享是指多個應用併發運行時，宏觀上體現出它們可同時訪問同一個資源，即這個資源可被共享。但其實在微觀上，操作系統在硬件等的支持下要確保應用程序互斥訪問這個共享的資源。比如，在單核處理器下，對於兩個應用同時訪問同一個內存單元的情況，從宏觀的應用層面上看，二者都能正確地讀出同一個內存單元的內容；而在微觀上，操作系統會調度應用程序的先後執行順序，確保在任何一個時刻，只有一個應用去訪問存儲單元。在多核處理器下，多個 CPU 核可能同時訪問同一內存單元，在這種多核場景下的共享性不僅僅由 OS 來保證，還需硬件級的 Cache 一致性保證。

持久性
----------------------------------

操作系統提供了文件系統來從可持久保存的存儲介質（磁盤， SSD 等，以後以硬盤來代表）中取數據和代碼到內存中，並可以把內存中的數據寫回到硬盤上。硬盤在這裡是外設，具有持久性，以文件系統的形式呈現給應用程序。

.. note::
  
  文件系統也可看成是操作系統對存儲外設（如硬盤、SSD 等）的虛擬化。
  這種持久性的特徵進一步帶來了共享屬性，即在文件系統中的文件可以被多個運行的程序所訪問，從而給應用程序之間實現數據共享提供了方便。即使掉電，存儲外設上的數據還不會丟失，可以在下一次機器加電後提供給運行的程序使用。持久性對操作系統的執行效率提出了挑戰，如何讓數據在高速的內存和慢速的硬盤間高效流動是需要操作系統考慮的問題。



