練習參考答案
=====================================================

.. toctree::
     :hidden:
     :maxdepth: 4


編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 在你日常使用的操作系統環境中安裝並配置好實驗環境。簡要說明你碰到的問題/困難和解決方法。

2. `*` 在Linux環境下編寫一個會產生異常的應用程序，並簡要解釋操作系統的處理結果。

   例如，對於這樣一段 C 程序，其中包含一個除以零的操作：

   .. code-block:: c
      :linenos:

      #include <stdio.h>

      int main() {
          printf("1 / 0 = %d", 1 / 0);
          return 0;
      }

   在基於 x86-64 Linux 的環境下編譯運行結果如下：

   .. code-block:: console

      $ gcc divzero
      $ ./divzero
      Floating point exception (core dumped)

   程序接收到了一個“浮點數異常”而異常終止。使用 ``strace`` 可以看到更詳細的信號信息：

   .. code-block:: console

      $ strace ./divzero
      [... 此處省略系統調用跟蹤輸出]
      --- SIGFPE {si_signo=SIGFPE, si_code=FPE_INTDIV, si_addr=0x401131} ---
      +++ killed by SIGFPE (core dumped) +++

   用 gdb 的 ``disassemble`` 命令可以看到發生異常的指令

   .. code-block:: console

      $ gdb divzero
      Reading symbols from divzero...
      (gdb) r
      Starting program: [...]/divzero

      Program received signal SIGFPE, Arithmetic exception.
      0x0000000000401131 in main ()
      (gdb) disassemble
      Dump of assembler code for function main:
         0x0000000000401122 <+0>:     push   %rbp
         0x0000000000401123 <+1>:     mov    %rsp,%rbp
         0x0000000000401126 <+4>:     mov    $0x1,%eax
         0x000000000040112b <+9>:     mov    $0x0,%ecx
         0x0000000000401130 <+14>:    cltd
      => 0x0000000000401131 <+15>:    idiv   %ecx
         0x0000000000401133 <+17>:    mov    %eax,%esi
         0x0000000000401135 <+19>:    mov    $0x402004,%edi
         0x000000000040113a <+24>:    mov    $0x0,%eax
         0x000000000040113f <+29>:    call   0x401030 <printf@plt>
         0x0000000000401144 <+34>:    mov    $0x0,%eax
         0x0000000000401149 <+39>:    pop    %rbp
         0x000000000040114a <+40>:    ret

   可以看出，應用程序在執行 `idiv` 指令（有符號除法指令）時發生了除以零異常，跳轉至操作系統處理。操作系統把它轉換為一個信號 `SIGFPE`，使用信號處理機制處理這個異常。該程序收到 `SIGFPE` 時應發生的行為是異常終止，於是操作系統將其終止，並將異常退出的信息報告給 shell 進程。

   需要注意的是，異常的處理和與信號的對應是與架構相關的。例如，RISC-V 架構下除以零不是異常，而是有個確定的結果。此外，不同架構下具體異常和信號的對應關係也是不同的，甚至有些混亂（例如，這裡明明是整數除以零錯誤，卻報告了“浮點數”異常）。

3. `**`  在Linux環境下編寫一個可以睡眠5秒後打印出一個字符串，並把字符串內容存入一個文件中的應用程序A。(基於C或Rust語言)

   樣例實現如下（未包含錯誤處理）

   .. code-block:: c

      #include <stdio.h>
      #include <unistd.h>

      int main() {
          sleep(5);

          const char* hello_string = "Hello Linux!\n";

          printf(hello_string);

          FILE *output_file = fopen("output.txt", "w");
          fputs(hello_string, output_file);
          fclose(output_file);

          return 0;
      }


   編譯運行，查看程序的輸出和文件，結果如下：

   .. code-block:: console

      $ gcc -o program-a program-a.c
      $ ./program-a
      Hello Linux!        [這一行等待 5s 後才輸出]
      $ cat output.txt
      Hello Linux!

4. `***`  在Linux環境下編寫一個應用程序B，簡要說明此程序能夠體現操作系統的併發性、異步性、共享性和持久性。(基於C或Rust語言)

注： 在類Linux環境下編寫嘗試用GDB等調試工具調試應用程序A，能夠設置斷點，單步執行，顯示變量信息。

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*`  什麼是操作系統？操作系統的主要目標是什麼？

2. `*`  面向服務器的操作系統與面向手機的操作系統在功能上有何異同？

   * 相同部分舉例：

     * 都需要進行進程的管理
     * 都需要管理 CPU，內存這些基本資源
     * 都需要隔離保護等安全機制
     * （服務器和手機的操作系統共通之處很多，甚至可以共用最基礎的部分，比如都用 Linux 內核）

   * 不同部分舉例：

     * 支持的外設不同：

       * 服務器：高性能網卡（如光纖）、存儲設備（如 HBA）等
       * 手機：屏幕，音響和話筒，基帶（移動網絡）、WiFi 等

     * 服務器和手機都有的資源，管理起來也有區別：

       * 服務器：內存很多，CPU 核數很多，可能需要支持更復雜的硬件拓撲，如 NUMA 架構
       * 手機：對低功耗的要求，需要操作系統在調度時考慮到電源管理，平衡省電和性能

     * 應用不同，導致對安全性要求不同：

       * 服務器：上千用戶，少數幾個應用，需要各種阻止用戶利用漏洞操控服務器上的程序的功能
       * 手機：一個或少數幾個用戶，幾十個應用，需要隱私保護功能

3. `*`  對於目前的手機或桌面操作系統而言，操作系統是否應該包括網絡瀏覽器？請說明理由。

4. `*`  操作系統的核心抽象有哪些？它們應對的對象是啥？

   * 進程/線程 -- CPU 時間
   * 地址空間 -- 內存
   * 執行環境 -- CPU 上覆雜的環境（有中斷異常等），和操作系統提供的功能（如系統調用）
   * 文件和文件描述符 -- 存儲和輸入輸出設備

5. `*`  操作系統與應用程序之間通過什麼來進行互操作和數據交換？

   * 互操作的方式：

     * 應用程序調用系統調用主動讓操作系統進行操作
     * 操作系統在中斷異常發生時強制暫停應用程序進行相關操作

   * 數據交換的方式：

     * 系統調用時根據 ABI 規定在（比如）寄存器中傳遞參數
     * 複製數據：在內核佔用的空間和用戶佔用的空間之間互相複製數據，如讀寫文件的時候從應用程序給出的緩衝區複製寫的數據，或者複製讀的數據到緩衝區
     * （共享內存空間：如 `io_uring`）

6. `*`  操作系統的特徵是什麼？請結合你日常使用的操作系統的具體運行情況來進一步說明操作系統的特徵。

   以在普通的桌面機上運行基於 Linux 的平臺上做操作系統實驗時可能發生的事情為例：

   * 虛擬性：如果物理內存相對不足，Linux 的 swap 機制會將不常用的內存內容轉存到硬盤上，優先保證活躍的進程可以高速訪問物理內存。
   * 併發性：正在運行的程序數量（包括併發運行的 `gcc` 或 `rustc`，和其它程序）可以超過 CPU 核心數，由操作系統來調度分配使用 CPU 時間。
   * 異步性：並行運行的編譯器太多，可能會影響寫代碼用的文本編輯器性能，因為操作系統安排了更多時間運行編譯器而不是文本編輯器進程。
   * 共享性：寫代碼和編譯可以共享同一個文件系統，在同一塊硬盤上讀寫，操作系統的文件系統相關模塊（VFS）會調用文件系統實現和硬盤驅動安排這些讀寫操作。
   * 持久性：操作系統實驗用的文件保存在文件系統中，晚上宿舍斷電關機，明天早上起來可以從昨天保存的文件的狀態繼續工作。

7. `*`  請說明基於C語言應用的執行環境與基於Java語言應用的執行環境的異同。

8. `**`  請簡要列舉操作系統的系統調用的作用，以及簡要說明與程序執行、內存分配、文件讀寫相關的Linux系統調用的大致接口和含義。

   * 系統調用的作用：

     * 將操作系統實現和用戶程序調用方式分開，作為一個抽象層方便開發和使用
     * 在讓用戶程序沒法直接訪問別的用戶程序的地址空間和操作系統地址空間的情況下，作為一個統一的應用程序請求操作系統服務的入口，方便安全檢查和審計。
     * 讓用戶程序能有限訪問其不能直接訪問的計算機資源和操作系統對象

   * 在 Linux 中：

     * `clone`（曾用的有 `fork`）創建進程；`execve` 傳入文件路徑、命令行參數、環境變量，加載新的程序替換當前進程。
     * `brk` 修改或獲取當前的堆頂的位置，增加堆頂地址分配空間，減小堆底地址釋放空間；`mmap` 用於映射地址空間，也可以分配物理內存（`MAP_ANONYMOUS`），`munmap` 釋放對應的地址空間和對應的內存。
     * 文件讀寫相關有 `openat`（曾用的有 `open`）打開文件，`read` 讀文件，`write` 寫文件等。

9. `**`  以你編寫的可以睡眠5秒後打印出一個字符串的應用程序A為例，說明什麼是控制流？什麼是異常控制流？什麼是進程、地址空間和文件？並簡要描述操作系統是如何支持這個應用程序完成其工作並結束的。

   應用程序A中體現的操作系統相關概念：

   * 控制流： ``main`` 函數內一行一行往下執行，是一個順序控制流；其中調用的標準庫函數，是函數調用的控制流。
   * 異常控制流： 在 ``sleep`` 的時候，執行系統調用 `clock_nanosleep`，此時控制流跳出了該程序，進入了操作系統的系統調用實現代碼，之後操作系統將應用程序A進入睡眠狀態，轉而運行別的進程，這裡體現了異常控制流。在執行其它系統調用的時候也會有類似的情況。
   * 進程：整個應用程序A是在一個新的進程中運行的，與啟動它的 shell。
   * 地址空間：字符串 ``hello_string`` 所在的地址，是在這個進程自己的地址空間內有效的，和別的進程無關。
   * 文件：應用程序A打開文件名為 ``output.txt`` 的文件，向其中寫入了一個字符串。此外， ``printf`` 是向標準輸出寫入，標準輸出在此時是一個對應當前終端的文件。

   操作系統支持應用程序A運行的流程：

   * 操作系統加載程序和 C 語言標準庫到內存中
   * 操作系統設置一些初始的虛擬內存配置和一些數據，然後切換到用戶態跳轉到程序的入口點開始運行。
   * 應用程序調用 C 語言標準庫，庫再進行系統調用，進入內核，內核處理相關的系統調用然後恢復應用程序運行，具體來說：

     * 對於 ``sleep`` 來說，操作系統在 5 秒時間內切換到別的任務，不運行應用程序A，5 秒過後再繼續運行
     * 對於文件來說，操作系統在文件系統內找到對應的文件寫入，或者找到對應的終端將寫入的內容發送過去

   * 最後 C 語言標準庫會調用 `exit_group` 系統調用退出進程。操作系統接收這個系統調用後，不再回到應用程序，釋放該進程相關資源。

10. `*`  請簡要描述支持單個應用的OS、批處理OS、多道程序OS、分時共享OS的特點。
