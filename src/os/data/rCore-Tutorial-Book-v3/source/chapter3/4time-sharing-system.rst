分時多任務系統與搶佔式調度
===========================================================

本節導讀
--------------------------

上一節我們介紹了“始初龍”協作式操作系統，依靠應用程序之間的協作來完成任務調度和切換。本節的重點是操作系統對中斷的處理和對應用程序的搶佔，並設計實現更加公平和高效交互的三疊紀“腔骨龍” [#coelophysis]_ 搶佔式操作系統。為此，我們需要對 **任務** 的概念進行進一步擴展和延伸：

-  分時多任務：操作系統管理每個應用程序，以時間片為單位來分時佔用處理器運行應用。
-  時間片輪轉調度：操作系統在一個程序用完其時間片後，就搶佔當前程序並調用下一個程序執行，週而復始，形成對應用程序在任務級別上的時間片輪轉調度。


分時多任務系統的背景
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _term-throughput:

上一節我們介紹了多道程序，它是一種允許應用在等待外設時主動切換到其他應用來達到總體 CPU 利用率最高的設計。在多道程序盛行的時候，計算機應用的開發者和計算機管理者是兩類人，開發者不能管理計算機，對於應用的運行過程沒有太多控制權，而計算機管理者的目標是總體 CPU 利用率最高，可以換成一個等價的指標： **吞吐量** (Throughput) 。大概可以理解為在某個時間點將一組應用放進去，要求在一段固定的時間之內執行完畢的應用最多，或者是總進度百分比最大。因此，所有的應用和編寫應用的程序員都有這樣的共識：只要 CPU 一直在做實際的工作就好。

.. _term-background-application:
.. _term-interactive-application:
.. _term-latency:

從現在的眼光來看，當時的應用更多是一種 **後臺應用** (Background Application) ，在將它加入執行隊列之後我們只需定期確認它的運行狀態。而隨著技術的發展，湧現了越來越多的 **交互式應用** (Interactive Application) ，它們要達成的一個重要目標就是提高用戶（應用的使用者和開發者）操作的響應速度，減少 **延遲** （Latency），這樣才能優化應用的使用體驗和開發體驗。對於這些應用而言，即使需要等待外設或某些事件，它們也不會傾向於主動 yield 交出 CPU 使用權，因為這樣可能會帶來無法接受的延遲。也就是說，應用之間更多的是互相競爭寶貴的硬件資源，而不是相互合作。

.. _term-cooperative-scheduling:
.. _term-preemptive-scheduling:

如果應用自己很少 yield ，操作系統內核就要開始收回之前下放的權力，由它自己對 CPU 資源進行集中管理併合理分配給各應用，這就是內核需要提供的任務調度能力。我們可以將多道程序的調度機制分類成 **協作式調度** (Cooperative Scheduling) ，因為它的特徵是：只要一個應用不主動 yield 交出 CPU 使用權，它就會一直執行下去。與之相對， **搶佔式調度** (Preemptive Scheduling) 則是應用 *隨時* 都有被內核切換出去的可能。

.. _term-time-slice:
.. _term-fairness:

現代的任務調度算法基本都是搶佔式的，它要求每個應用只能連續執行一段時間，然後內核就會將它強制性切換出去。一般將 **時間片** (Time Slice) 作為應用連續執行時長的度量單位，每個時間片可能在毫秒量級。調度算法需要考慮：每次在換出之前給一個應用多少時間片去執行，以及要換入哪個應用。可以從性能（主要是吞吐量和延遲兩個指標）和 **公平性** (Fairness) 兩個維度來評價調度算法，後者要求多個應用分到的時間片佔比不應差距過大。

時間片輪轉調度
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _term-round-robin:

簡單起見，本書中我們使用 **時間片輪轉算法** (RR, Round-Robin) 來對應用進行調度，只要對它進行少許拓展就能完全滿足我們的需求。本章中我們僅需要最原始的 RR 算法，用文字描述的話就是維護一個任務隊列，每次從隊頭取出一個應用執行一個時間片，然後把它丟到隊尾，再繼續從隊頭取出一個應用，以此類推直到所有的應用執行完畢。

本節的代碼可以在 ``ch3`` 分支上找到。


RISC-V 架構中的中斷
-----------------------------------

.. _term-interrupt:
.. _term-sync:
.. _term-async:


時間片輪轉調度的核心機制就在於計時。操作系統的計時功能是依靠硬件提供的時鐘中斷來實現的。在介紹時鐘中斷之前，我們先簡單介紹一下中斷。

在 RISC-V 架構語境下， **中斷** (Interrupt) 和我們第二章中介紹的異常（包括程序錯誤導致或執行 Trap 類指令如用於系統調用的 ``ecall`` ）一樣都是一種 Trap ，但是它們被觸發的原因卻是不同的。對於某個處理器核而言， 異常與當前 CPU 的指令執行是 **同步** (Synchronous) 的，異常被觸發的原因一定能夠追溯到某條指令的執行；而中斷則 **異步** (Asynchronous) 於當前正在進行的指令，也就是說中斷來自於哪個外設以及中斷如何觸發完全與處理器正在執行的當前指令無關。

.. _term-parallel: 

.. note::

    **從底層硬件的角度區分同步和異步**

    從底層硬件的角度可能更容易理解這裡所提到的同步和異步。以一個處理器的五級流水線設計而言，裡面含有取指、譯碼、算術、訪存、寄存器等單元，都屬於執行指令所需的硬件資源。那麼假如某條指令的執行出現了問題，一定能被其中某個單元看到並反饋給流水線控制單元，從而它會在執行預定的下一條指令之前先進入異常處理流程。也就是說，異常在這些單元內部即可被發現並解決。
    
    而對於中斷，可以理解為發起中斷的是一套與處理器執行指令無關的電路（從時鐘中斷來看就是簡單的計數和比較器），這套電路僅通過一根導線接入處理器。當外設想要觸發中斷的時候則輸入一個高電平或正邊沿，處理器會在每執行完一條指令之後檢查一下這根線，看情況決定是繼續執行接下來的指令還是進入中斷處理流程。也就是說，大多數情況下，指令執行的相關硬件單元和可能發起中斷的電路是完全獨立 **並行** (Parallel) 運行的，它們中間只有一根導線相連。

在不考慮指令集拓展的情況下，RISC-V 架構中定義瞭如下中斷：

.. list-table:: RISC-V 中斷一覽表
   :align: center
   :header-rows: 1
   :widths: 30 30 60

   * - Interrupt
     - Exception Code
     - Description
   * - 1
     - 1
     - Supervisor software interrupt
   * - 1
     - 3
     - Machine software interrupt
   * - 1
     - 5
     - Supervisor timer interrupt
   * - 1
     - 7
     - Machine timer interrupt
   * - 1
     - 9
     - Supervisor external interrupt
   * - 1
     - 11
     - Machine external interrupt

RISC-V 的中斷可以分成三類：

.. _term-software-interrupt:
.. _term-timer-interrupt:
.. _term-external-interrupt:

- **軟件中斷** (Software Interrupt)：由軟件控制發出的中斷
- **時鐘中斷** (Timer Interrupt)：由時鐘電路發出的中斷
- **外部中斷** (External Interrupt)：由外設發出的中斷

另外，相比於異常，中斷和特權級之間的聯繫更為緊密，可以看到這三種中斷每一個都有 M/S 特權級兩個版本。中斷的特權級可以決定該中斷是否會被屏蔽，以及需要 Trap 到 CPU 的哪個特權級進行處理。

在判斷中斷是否會被屏蔽的時候，有以下規則：

- 如果中斷的特權級低於 CPU 當前的特權級，則該中斷會被屏蔽，不會被處理；
- 如果中斷的特權級高於與 CPU 當前的特權級或相同，則需要通過相應的 CSR 判斷該中斷是否會被屏蔽。

以內核所在的 S 特權級為例，中斷屏蔽相應的 CSR 有 ``sstatus`` 和 ``sie`` 。``sstatus`` 的 ``sie`` 為 S 特權級的中斷使能，能夠同時控制三種中斷，如果將其清零則會將它們全部屏蔽。即使 ``sstatus.sie`` 置 1 ，還要看 ``sie`` 這個 CSR，它的三個字段  ``ssie/stie/seie`` 分別控制 S 特權級的軟件中斷、時鐘中斷和外部中斷的中斷使能。比如對於 S 態時鐘中斷來說，如果 CPU 不高於 S 特權級，需要 ``sstatus.sie`` 和 ``sie.stie`` 均為 1 該中斷才不會被屏蔽；如果 CPU 當前特權級高於 S 特權級，則該中斷一定會被屏蔽。

如果中斷沒有被屏蔽，那麼接下來就需要軟件進行處理，而具體到哪個特權級進行處理與一些中斷代理 CSR 的設置有關。默認情況下，所有的中斷都需要到 M 特權級處理。而通過軟件設置這些中斷代理 CSR 之後，就可以到低特權級處理，但是 Trap 到的特權級不能低於中斷的特權級。事實上所有的中斷/異常默認也都是到 M 特權級處理的。

我們會在 :doc:`/appendix-c/index` 中再深入介紹中斷/異常代理。在本書中我們只需要瞭解：

- U 特權級的應用程序發出系統調用或產生錯誤異常都會跳轉到 S 特權級的操作系統內核來處理；
- S 特權級的時鐘/軟件/外部中斷產生後，都會跳轉到 S 特權級的操作系統內核來處理。

這裡我們還需要對第二章介紹的系統調用和異常發生時的硬件機制做一下與中斷相關的補充。默認情況下，當中斷產生並進入某個特權級之後，在中斷處理的過程中同特權級的中斷都會被屏蔽。中斷產生後，硬件會完成如下事務：

- 當中斷髮生時，``sstatus.sie`` 字段會被保存在 ``sstatus.spie`` 字段中，同時把 ``sstatus.sie`` 字段置零，這樣軟件在進行後續的中斷處理過程中，所有 S 特權級的中斷都會被屏蔽；
- 當軟件執行中斷處理完畢後，會執行 ``sret`` 指令返回到被中斷打斷的地方繼續執行，硬件會把 ``sstatus.sie`` 字段恢復為 ``sstatus.spie`` 字段內的值。

.. _term-nested-interrupt:

也就是說，如果不去手動設置 ``sstatus`` CSR ，在只考慮 S 特權級中斷的情況下，是不會出現 **嵌套中斷** (Nested Interrupt) 的。嵌套中斷是指在處理一箇中斷的過程中再一次觸發了中斷。由於默認情況下，在軟件開始響應中斷前， 硬件會自動禁用所有同特權級中斷，自然也就不會再次觸發中斷導致嵌套中斷了。

.. note::

    **嵌套中斷與嵌套 Trap**

    嵌套中斷可以分為兩部分：在處理一箇中斷的過程中又被同特權級/高特權級中斷所打斷。默認情況下硬件會避免同特權級再次發生，但高特權級中斷則是不可避免的會再次發生。

    嵌套 Trap 則是指處理一個 Trap（可能是中斷或異常）的過程中又再次發生 Trap ，嵌套中斷是嵌套 Trap 的一個特例。在內核開發時我們需要仔細權衡哪些嵌套 Trap 應當被允許存在，哪些嵌套 Trap 又應該被禁止，這會關係到內核的執行模型。

.. chyyuu .. note:: N extension在最新版（20211203）的privileged spec裡被移除了

..     **RISC-V 架構的 U （用戶態）特權級中斷**

..     目前，RISC-V 用戶態中斷作為代號 N 的一個指令集拓展而存在。有興趣的同學可以閱讀最新版的 RISC-V 特權級架構規範一探究竟。


時鐘中斷與計時器
------------------------------------------------------------------

.. _link-time-counter:

由於軟件（特別是操作系統）需要一種計時機制，RISC-V 架構要求處理器要有一個內置時鐘，其頻率一般低於 CPU 主頻。此外，還有一個計數器用來統計處理器自上電以來經過了多少個內置時鐘的時鐘週期。在 RISC-V 64 架構上，該計數器保存在一個 64 位的 CSR ``mtime`` 中，我們無需擔心它的溢出問題，在內核運行全程可以認為它是一直遞增的。這個計數器被設計成在所有的特權級均可以通過一條 ``rdtime`` 的偽指令訪問（可以參考 RISC-V 規範的"Zicntr"拓展相關章節）。 ``riscv`` 庫已經封裝了這個功能，我們直接調用相應接口，在 ``timer`` 子模塊的 ``get_time`` 函數中取得計數器的值：

.. code-block:: rust

    // os/src/timer.rs

    use riscv::register::time;

    pub fn get_time() -> usize {
        time::read()
    }

另外一個 64 位的 CSR ``mtimecmp`` 的作用是：一旦計數器 ``mtime`` 的值超過了 ``mtimecmp``，就會觸發一次時鐘中斷。這使得我們可以方便的通過設置 ``mtimecmp`` 的值來決定下一次時鐘中斷何時觸發。運行在 M 特權級的 SEE （這裡是RustSBI）預留了相關接口來實現計時器的控制：

.. code-block:: rust
    :linenos:

    // os/src/sbi.rs

    const SBI_SET_TIMER: usize = 0;

    pub fn set_timer(timer: usize) {
        sbi_call(SBI_SET_TIMER, timer, 0, 0);
    }

    // os/src/timer.rs

    use crate::config::CLOCK_FREQ;
    const TICKS_PER_SEC: usize = 100;

    pub fn set_next_trigger() {
        set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);
    }

- 代碼片段第 5 行， ``sbi`` 子模塊有一個 ``set_timer`` 調用，是一個由 SEE 提供的標準 SBI 接口函數，它可以用來設置 ``mtimecmp`` 的值。
- 代碼片段第 14 行， ``timer`` 子模塊的 ``set_next_trigger`` 函數對 ``set_timer`` 進行了封裝，它首先讀取當前 ``mtime`` 的值，然後計算出 10ms 之內計數器的增量，再將 ``mtimecmp`` 設置為二者的和。這樣，10ms 之後一個 S 特權級時鐘中斷就會被觸發。

  至於增量的計算方式，常數 ``CLOCK_FREQ`` 是一個預先獲取到的各平臺不同的時鐘頻率，單位為赫茲，也就是一秒鐘之內計數器的增量。它可以在 ``config`` 子模塊中找到。``CLOCK_FREQ`` 除以常數 ``TICKS_PER_SEC`` 即是下一次時鐘中斷的計數器增量值。

後面可能還有一些計時的操作，比如統計一個應用的運行時長，我們再設計一個函數：

.. code-block:: rust

  // os/src/timer.rs

  const MICRO_PER_SEC: usize = 1_000_000;

  pub fn get_time_us() -> usize {
      time::read() / (CLOCK_FREQ / MICRO_PER_SEC)
  }

``timer`` 子模塊的 ``get_time_us`` 以微秒為單位返回當前計數器的值，這讓我們終於能對時間有一個具體概念了。實現原理就不再贅述。

新增一個系統調用，方便應用獲取當前的時間：

.. code-block:: rust
    :caption: 第三章新增系統調用（二）

    /// 功能：獲取當前的時間，保存在 TimeVal 結構體 ts 中，_tz 在我們的實現中忽略 
    /// 返回值：返回是否執行成功，成功則返回 0
    /// syscall ID：169
    fn sys_get_time(ts: *mut TimeVal, _tz: usize) -> isize;        

    #[repr(C)]
    pub struct TimeVal {
        pub sec: usize,
        pub usec: usize,
    }

它在內核中的實現只需調用 ``get_time_us`` 函數即可。

.. _term-preempt-sched:

搶佔式調度
-----------------------------------

有了時鐘中斷和計時器，搶佔式調度就很容易實現了：

.. code-block:: rust

    // os/src/trap/mod.rs

    match scause.cause() {
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next();
        }
    }

我們只需在 ``trap_handler`` 函數下新增一個條件分支跳轉，當發現觸發了一個 S 特權級時鐘中斷的時候，首先重新設置一個 10ms 的計時器，然後調用上一小節提到的 ``suspend_current_and_run_next`` 函數暫停當前應用並切換到下一個。

為了避免 S 特權級時鐘中斷被屏蔽，我們需要在執行第一個應用之前進行一些初始化設置：

.. code-block:: rust
    :linenos:
    :emphasize-lines: 9,10

    // os/src/main.rs

    #[no_mangle]
    pub fn rust_main() -> ! {
        clear_bss();
        println!("[kernel] Hello, world!");
        trap::init();
        loader::load_apps();
        trap::enable_timer_interrupt();
        timer::set_next_trigger();
        task::run_first_task();
        panic!("Unreachable in rust_main!");
    }

    // os/src/trap/mod.rs

    use riscv::register::sie;

    pub fn enable_timer_interrupt() {
        unsafe { sie::set_stimer(); }
    }

- 第 9 行設置了 ``sie.stie`` 使得 S 特權級時鐘中斷不會被屏蔽；
- 第 10 行則是設置第一個 10ms 的計時器。

這樣，當一個應用運行了 10ms 之後，一個 S 特權級時鐘中斷就會被觸發。由於應用運行在 U 特權級，且 ``sie`` 寄存器被正確設置，該中斷不會被屏蔽，而是跳轉到 S 特權級內的我們的 ``trap_handler`` 裡面進行處理，並順利切換到下一個應用。這便是我們所期望的搶佔式調度機制。從應用運行的結果也可以看出，三個 ``power`` 系列應用並沒有進行 yield ，而是由內核負責公平分配它們執行的時間片。

有同學可能會注意到，我們並沒有將應用初始 Trap 上下文中的 ``sstatus`` 中的 ``SPIE`` 位置為 1 。這將意味著 CPU 在用戶態執行應用的時候 ``sstatus`` 的 ``SIE`` 為 0 ，根據定義來說，此時的 CPU 會屏蔽 S 態所有中斷，自然也包括 S 特權級時鐘中斷。但是可以觀察到我們的應用在用盡一個時間片之後能夠正常被打斷。這是因為當 CPU 在 U 態接收到一個 S 態時鐘中斷時會被搶佔，這時無論 ``SIE`` 位是否被設置都會進入 Trap 處理流程。

目前在等待某些事件的時候仍然需要 yield ，其中一個原因是為了節約 CPU 計算資源，另一個原因是當事件依賴於其他的應用的時候，由於只有一個 CPU ，當前應用的等待可能永遠不會結束。這種情況下需要先將它切換出去，使得其他的應用到達它所期待的狀態並滿足事件的生成條件，再切換回來。

.. _term-busy-loop:

這裡我們先通過 yield 來優化 **輪詢** (Busy Loop) 過程帶來的 CPU 資源浪費。在 ``03sleep`` 這個應用中：

.. code-block:: rust

    // user/src/bin/03sleep.rs

    #[no_mangle]
    fn main() -> i32 {
        let current_timer = get_time();
        let wait_for = current_timer + 3000;
        while get_time() < wait_for {
            yield_();
        }
        println!("Test sleep OK!");
        0
    }

它的功能是等待 3000ms 然後退出。可以看出，我們會在循環裡面 ``yield_`` 來主動交出 CPU 而不是無意義的忙等。其實，現在的搶佔式調度會在它循環 10ms 之後切換到其他應用，這樣能讓內核給其他應用分配更多的 CPU 資源並讓它們更早運行結束。


我們的“腔骨龍”協作式操作系統就算是實現完畢了。它支持把多個應用的代碼和數據放置到內存中；並能夠執行每個應用；在應用程序發出 ``sys_yield`` 系統調用時，協作式地切換應用；並能通過時鐘中斷來實現搶佔式調度並強行切換應用，從而提高了應用執行的靈活性、公平性和交互效率。

.. note::

    **內核代碼執行是否會被中斷打斷？**

    目前為了簡單起見，我們的內核不會被 S 特權級中斷所打斷，這是因為 CPU 在 S 特權級時， ``sstatus.sie`` 總為 0 。但這會造成內核對部分中斷的響應不及時，因此一種較為合理的做法是允許內核在處理系統調用的時候被打斷優先處理某些中斷，這是一種允許 Trap 嵌套的設計。從第四章可以看到，我們目前的設計不允許 Trap 嵌套，當通過 Trap 進入內核再次遇到 Trap 的時候，內核會直接 panic 。


.. [#coelophysis] 腔骨龍（也稱虛形龍）最早出現於三疊紀晚期，它體形纖細，善於奔跑，以小型動物為食。