練習
=======================================


課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


1. `*` 擴展內核，能夠顯示操作系統切換任務的過程。
2. `**` 擴展內核，能夠統計每個應用執行後的完成時間：用戶態完成時間和內核態完成時間。
3. `**` 編寫浮點應用程序A，並擴展內核，支持面向浮點應用的正常切換與搶佔。
4. `**` 編寫應用程序或擴展內核，能夠統計任務切換的大致開銷。
5. `***` 擴展內核，支持在內核態響應中斷。
6. `***` 擴展內核，支持在內核運行的任務（簡稱內核任務），並支持內核任務的搶佔式切換。

注：上述擴展內核的編程基於 rcore/ucore tutorial v3: Branch ch3

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 協作式調度與搶佔式調度的區別是什麼？
2. `*` 中斷、異常和系統調用有何異同之處？
3. `*` RISC-V支持哪些中斷/異常？
4. `*` 如何判斷進入操作系統內核的起因是由於中斷還是異常？
5. `**` 在 RISC-V 中斷機制中，PLIC 和 CLINT 各起到了什麼作用？
6. `**` 基於RISC-V 的操作系統支持中斷嵌套？請給出進一步的解釋說明。
7. `**` 本章提出的任務的概念與前面提到的進程的概念之間有何區別與聯繫？
8. `*` 簡單描述一下任務的地址空間中有哪些類型的數據和代碼。
9.  `*` 任務控制塊保存哪些內容？
10. `*` 任務上下文切換需要保存與恢復哪些內容？
11. `*` 特權級上下文和任務上下文有何異同？
12. `*` 上下文切換為什麼需要用匯編語言實現？
13. `*` 有哪些可能的時機導致任務切換？
14. `**` 在設計任務控制塊時，為何採用分離的內核棧和用戶棧，而不用一個棧？
15. `***` 我們已經在 rCore 裡實現了不少操作系統的基本功能：特權級、上下文切換、系統調用……為了讓大家對相關代碼更熟悉，我們來以另一個操作系統為例，比較一下功能的實現。看看換一段代碼，你還認不認識操作系統。

    閱讀 Linux 源代碼，特別是 ``riscv`` 架構相關的代碼，回答以下問題：

    1. Linux 正常運行的時候， ``stvec`` 指向哪個函數？是哪段代碼設置的 ``stvec`` 的值？
    2. Linux 裡進行上下文切換的函數叫什麼？（對應 rCore 的 ``__switch`` ）
    3. Linux 裡，和 rCore 中的 ``TrapContext`` 和 ``TaskContext`` 這兩個類型大致對應的結構體叫什麼？
    4. Linux 在內核態運行的時候， ``tp`` 寄存器的值有什麼含義？ ``sscratch`` 的值是什麼？
    5. Linux 在用戶態運行的時候， ``sscratch`` 的值有什麼含義？
    6. Linux 在切換到內核態的時候，保存了和用戶態程序相關的什麼狀態？
    7. Linux 在內核態的時候，被打斷的用戶態程序的寄存器值存在哪裡？在 C 代碼裡如何訪問？
    8. Linux 是如何根據系統調用編號找到對應的函數的？（對應 rCore 的 ``syscall::syscall()`` 函數的功能）
    9. Linux 用戶程序調用 ``ecall`` 的參數是怎麼傳給系統調用的實現的？系統調用的返回值是怎樣返回給用戶態的？

    閱讀代碼的時候，可以重點關注一下如下幾個文件，尤其是第一個 ``entry.S`` ，當然也可能會需要讀到其它代碼：

    * ``arch/riscv/kernel/entry.S`` （與 rCore 的 ``switch.S`` 對比）
    * ``arch/riscv/include/asm/current.h``
    * ``arch/riscv/include/asm/processor.h``
    * ``arch/riscv/include/asm/switch_to.h``
    * ``arch/riscv/kernel/process.c``
    * ``arch/riscv/kernel/syscall_table.c``
    * ``arch/riscv/kernel/traps.c``
    * ``include/linux/sched.h``

    此外，推薦使用 https://elixir.bootlin.com 閱讀 Linux 源碼，方便查找各個函數、類型、變量的定義及引用情況。

    一些提示：

    * Linux 支持各種架構，查找架構相關的代碼的時候，請認準文件名中的 ``arch/riscv`` 。
    * 為了同時兼容 RV32 和 RV64，Linux 在彙編代碼中用了幾個宏定義。例如， ``REG_L`` 在 RV32 上是 ``lw`` ，而在 RV64 上是 ``ld`` 。同理， ``REG_S`` 在 RV32 上是 ``sw`` ，而在 RV64 上是 ``sd`` 。
    * 如果看到 ``#ifdef CONFIG_`` 相關的預處理指令，是 Linux 根據編譯時的配置啟用不同的代碼。一般閱讀代碼時，要麼比較容易判斷出這些宏有沒有被定義，要麼其實無關緊要。比如，Linux 內核確實應該和 rCore 一樣，是在 S-mode 運行的，所以 ``CONFIG_RISCV_M_MODE`` 應該是沒有啟用的。
    * 彙編代碼中可能會看到有些 ``TASK_`` 和 `PT_` 開頭的常量，找不到定義。這些常量並沒有直接寫在源碼裡，而是自動生成的。

      在彙編語言中需要用到的很多 ``struct`` 裡偏移量的常量定義可以在 ``arch/riscv/kernel/asm-offsets.c`` 文件裡找到。其中， ``OFFSET(NAME, struct_name, field)`` 指的是 ``NAME`` 的值定義為 ``field`` 這一項在 ``struct_name`` 結構體裡，距離結構體開頭的偏移量。最終這些代碼會生成 ``asm/asm-offsets.h`` 供彙編代碼使用。
    * ``#include <asm/unistd.h>`` 在 ``arch/riscv/include/uapi/asm/unistd.h`` ， ``#include <asm-generic/unistd.h>`` 在 ``include/uapi/asm-generic/unistd.h`` 。

.. chyyuu：任務與進程，類似青蛙生長過程中的蝌蚪與青蛙的區別與聯繫。



實驗練習
-------------------------------

實驗練習包括實踐作業和問答作業兩部分。

實踐作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

獲取任務信息
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ch3 中，我們的系統已經能夠支持多個任務分時輪流運行，我們希望引入一個新的系統調用 ``sys_task_info`` 以獲取任務的信息，定義如下：

.. code-block:: rust

    fn sys_task_info(id: usize, ts: *mut TaskInfo) -> isize

- syscall ID: 410
- 根據任務 ID 查詢任務信息，任務信息包括任務 ID、任務控制塊相關信息（任務狀態）、任務使用的系統調用及調用次數、任務總運行時長。

.. code-block:: rust

    struct TaskInfo {
        id: usize,
        status: TaskStatus,
        call: [SyscallInfo; MAX_SYSCALL_NUM],
        time: usize
    }

- 系統調用信息採用數組形式對每個系統調用的次數進行統計，相關結構定義如下：

.. code-block:: rust

    struct SyscallInfo {
        id: usize,
        times: usize
    }

- 參數：
    - id: 待查詢任務id
    - ts: 待查詢任務信息
- 返回值：執行成功返回0，錯誤返回-1
- 說明：
    - 相關結構已在框架中給出，只需添加邏輯實現功能需求即可。
- 提示：
    - 大膽修改已有框架！除了配置文件，你幾乎可以隨意修改已有框架的內容。
    - 程序運行時間可以通過調用 ``get_time()`` 獲取。
    - 系統調用次數可以考慮在進入內核態系統調用異常處理函數之後，進入具體系統調用函數之前維護。
    - 閱讀 TaskManager 的實現，思考如何維護內核控制塊信息（可以在控制塊可變部分加入其他需要的信息）

打印調用堆棧（選做）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

我們在調試程序時，除了正在執行的函數外，往往還需要知道當前的調用堆棧。這樣的功能通常由調試器、運行環境、 IDE 或操作系統等提供，但現在我們只能靠自己了。最基本的實現只需打印出調用鏈上的函數地址，更豐富的功能包括打印出函數名、函數定義、傳遞的參數等等。

本實驗我們不提供新的測例，僅提供參考實現，各位同學可以通過對照 GDB 、參考實現或自行構造調用鏈等方式檢驗自己的實現是否正確。

.. hint:: 可以參考《編譯原理》課程中關於函數調用棧幀的內容。

實驗要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 完成分支: ch3-lab

- 實驗目錄要求

.. code-block::

   ├── os(內核實現)
   │   ├── Cargo.toml(配置文件)
   │   └── src(所有內核的源代碼放在 os/src 目錄下)
   │       ├── main.rs(內核主函數)
   │       └── ...
   ├── reports (不是 report)
   │   ├── lab3.md/pdf
   │   └── ...
   ├── ...


- 通過所有已有的測例：

  CI 使用的測例與本地相同，測試中，user 文件夾及其它與構建相關的文件將被替換，請不要試圖依靠硬編碼通過測試。

.. note::

    你的實現只需且必須通過測例，建議讀者感到困惑時先檢查測例。

實驗約定
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

問答作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. 正確進入 U 態後，程序的特徵還應有：使用 S 態特權指令，訪問 S 態寄存器後會報錯。
   請同學們可以自行測試這些內容 (運行 `Rust 兩個 bad 測例 (ch2b_bad_*.rs) <https://github.com/LearningOS/rCore-Tutorial-Test-2022S/tree/master/src/bin>`_ ) ，
   描述程序出錯行為，同時注意註明你使用的 sbi 及其版本。
2. 請通過 gdb 跟蹤或閱讀源代碼瞭解機器從加電到跳轉到 0x80200000 的過程，並描述重要的跳轉。回答內核是如何進入 S 態的？

   - 事實上進入 rustsbi (0x80000000) 之後就不需要使用 gdb 調試了。可以直接閱讀 `代碼 <https://github.com/rustsbi/rustsbi-qemu/blob/7d71bfb7b3ad8e36f06f92c2ffe2066bbb0f9254/rustsbi-qemu/src/main.rs#L56>`_ 。
   - 可以使用 Makefile 中的 ``make debug`` 指令。
   - 一些可能用到的 gdb 指令：
       - ``x/10i 0x80000000`` : 顯示 0x80000000 處的10條彙編指令。
       - ``x/10i $pc`` : 顯示即將執行的10條彙編指令。
       - ``x/10xw 0x80000000`` : 顯示 0x80000000 處的10條數據，格式為16進制32bit。
       - ``info register``: 顯示當前所有寄存器信息。
       - ``info r t0``: 顯示 t0 寄存器的值。
       - ``break funcname``: 在目標函數第一條指令處設置斷點。
       - ``break *0x80200000``: 在 0x80200000 出設置斷點。
       - ``continue``: 執行直到碰到斷點。
       - ``si``: 單步執行一條彙編指令。



實驗練習的提交報告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- 簡單總結與上次實驗相比本次實驗你增加的東西（控制在5行以內，不要貼代碼）。
- 完成問答問題。
- (optional) 你對本次實驗設計及難度/工作量的看法，以及有哪些需要改進的地方，歡迎暢所欲言。
