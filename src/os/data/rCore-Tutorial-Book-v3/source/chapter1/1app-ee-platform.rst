應用程序執行環境與平臺支持
================================================

.. toctree::
   :hidden:
   :maxdepth: 5


本節導讀
-------------------------------

.. 本節介紹瞭如何設計實現一個提供顯示字符服務的用戶態執行環境和裸機執行環境，以支持一個應用程序顯示字符串。顯示字符服務的裸機執行環境和用戶態執行環境向下直接或間接與硬件關聯，向上可通過函數庫給應用提供 **顯示字符** 的服務。這也說明了不管執行環境是簡單還是複雜，設計實現上是否容易，它都體現了不同操作系統的共性特徵--給應用需求提供服務。在某種程度上看，執行環境的軟件主體雖然是以函數庫的形態存在，但可稱為是一種操作系統。

本節我們從一個最簡單的 Rust 應用程序入手，深入地挖掘它下面的多層執行環境，分析編譯器和操作系統為應用程序的開發和運行提供了怎樣的便利條件。需要注意的是，LibOS操作系統也是一層執行環境，因此它需要為上層的應用程序提供服務。我們會接觸到計算機科學中最核心的思想 -- 抽象，同時以現實中不同需求層級的應用為例分析如何進行合理的抽象。最後，我們還會介紹軟硬件平臺（包括 RISC-V 架構）的一些基礎知識。

執行應用程序
-------------------------------

我們先在Linux上開發並運行一個簡單的 “Hello, world” 應用程序，看看一個簡單應用程序從開發到執行的全過程。作為一切的開始，讓我們使用 Cargo 工具來創建一個 Rust 項目。它看上去沒有任何特別之處：

.. code-block:: console

   $ cargo new os --bin

我們加上了 ``--bin`` 選項來告訴 Cargo 我們創建一個可執行程序項目而不是函數庫項目。此時，項目的文件結構如下：

.. code-block:: console
   
   $ tree os
   os
   ├── Cargo.toml
   └── src
       └── main.rs

   1 directory, 2 files

其中 ``Cargo.toml`` 中保存著項目的配置，包括作者的信息、聯繫方式以及庫依賴等等。顯而易見源代碼保存在 ``src`` 目錄下，目前為止只有 ``main.rs`` 一個文件，讓我們看一下里面的內容：

.. code-block:: rust
   :linenos:
   :caption: 最簡單的 Rust 應用

   fn main() {
       println!("Hello, world!");
   }

進入 os 項目根目錄下，利用 Cargo 工具即可一條命令實現構建並運行項目：

.. code-block:: console
   
   $ cargo run
      Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)
       Finished dev [unoptimized + debuginfo] target(s) in 1.15s
        Running `target/debug/os`
   Hello, world!
 
如我們預想的一樣，我們在屏幕上看到了一行 ``Hello, world!`` 。但是，需要注意到我們所享受到的編程和執行程序的方便性並不是理所當然的，背後有著從硬件到軟件多種機制的支持。特別是對於應用程序的運行，需要有一個強大的執行環境來幫助。接下來，我們就要看看有操作系統加持的強大的執行環境。

應用程序執行環境
-------------------------------

如下圖所示，現在通用操作系統（如 Linux 等）上的應用程序運行需要下面多層次的執行環境棧的支持，圖中的白色塊自上而下（越往下則越靠近底層，下層作為上層的執行環境支持上層代碼的運行）表示各級執行環境，黑色塊則表示相鄰兩層執行環境之間的接口。

.. _app-software-stack:

.. figure:: app-software-stack.png
   :align: center

   應用程序執行環境棧

.. _term-execution-environment:

我們的應用位於最上層，它可以通過調用編程語言提供的標準庫或者其他三方庫對外提供的函數接口，使得僅需少量的源代碼就能完成複雜的功能。但是這些庫的功能不僅限於此，事實上它們屬於應用程序 **執行環境** (Execution Environment)的一部分。在我們通常不會注意到的地方，這些軟件庫還會在執行應用之前完成一些初始化工作，並在應用程序執行的時候對它進行監控。我們在打印 ``Hello, world!`` 時使用的 ``println!`` 宏正是由 Rust 標準庫 std提供的。

.. _term-system-call:

從操作系統內核的角度看來，它上面的一切都屬於用戶態軟件，而它自身屬於內核態軟件。無論用戶態應用如何編寫，是手寫彙編代碼，還是基於某種高級編程語言調用其標準庫或三方庫，某些功能總要直接或間接的通過操作系統內核提供的 **系統調用** (System Call) 來實現。因此係統調用充當了用戶和內核之間的邊界。內核作為用戶態軟件的執行環境，它不僅要提供系統調用接口，還需要對用戶態軟件的執行進行監控和管理。

.. note::

   **Hello, world! 用到了哪些系統調用？**
   
   從之前的 ``cargo run`` 的輸出可以看出之前構建的可執行文件是在 target/debug 目錄下的 os 。在 Ubuntu 系統上，可以通過 ``strace`` 工具來運行一個程序並輸出程序運行過程當中向內核請求的所有的系統調用及其返回值。我們只需輸入 ``strace target/debug/os`` 即可看到一長串的各種系統調用。

   其中，容易看出與 ``Hello, world!`` 應用實際執行相關的只有兩個系統調用：

   .. code-block::

      # 輸出字符串
      write(1, "Hello, world!\n", 14)         = 14
      # 程序退出執行
      exit_group(0)

   其參數的具體含義我們暫且不在這裡進行解釋。

   其餘的系統調用基本上分別用於函數庫和內核兩層執行環境的初始化工作和對上層應用的運行進行監控和管理。之後，隨著應用場景的複雜化，操作系統需要提供更強的硬件抽象能力和資源管理能力，並實現相關的一些系統調用。   

.. _term-isa:

從硬件的角度來看，它上面的一切都屬於軟件。硬件可以分為三種： 處理器 (Processor，也稱CPU)，內存 (Memory) 還有 I/O 設備。其中處理器無疑是其中最複雜，同時也最關鍵的一個。它與軟件約定一套 **指令集體系結構** (ISA, Instruction Set Architecture)，使得軟件可以通過 ISA 中提供的機器指令來訪問各種硬件資源。軟件當然也需要知道處理器會如何執行這些指令，以及指令執行後的結果。當然，實際的情況遠比這個要複雜得多，為了適應現代應用程序的場景，處理器還需要提供很多額外的機制（如特權級、頁表、TLB、異常/中斷響應等）來管理應用程序的執行過程，而不僅僅是讓數據在 CPU 寄存器、內存和 I/O 設備三者之間流動。


.. note::

    計算機科學中遇到的所有問題都可通過增加一層抽象來解決。

    All problems in computer science can be solved by another level of indirection。

    -- 計算機科學家 David Wheeler


.. _term-abstraction:

.. note::

   **多層執行環境都是必需的嗎？**

   除了最上層的應用程序和最下層的硬件平臺必須存在之外，作為中間層的函數庫和操作系統內核並不是必須存在的：
   它們都是對下層資源進行了 **抽象** (Abstraction/Indirection)，併為上層提供了一個執行環境（也可理解為一些服務功能）。抽象的優點在於它讓上層以較小的代價獲得所需的功能，並同時可以提供一些保護。但抽象同時也是一種限制，會喪失一些應有的靈活性。比如，當你在考慮在項目中應該使用哪個函數庫的時候，就常常需要這方面的權衡：過多的抽象和過少的抽象自然都是不合適的。理解應用的需求也很重要。一個能合理滿足應用需求的操作系統設計是操作系統設計者需要深入考慮的問題。這也是一種權衡，過多的服務功能和過少的服務功能自然都是不合適的。



   實際上，我們通過應用程序的特徵和需求來判斷操作系統需要什麼程度的抽象和功能。

   - 如果函數庫和操作系統內核都不存在，那麼我們就需要手寫彙編代碼來控制硬件，這種方式具有最高的靈活性，抽象能力則最低，基本等同於編寫彙編代碼來直接控制硬件。我們通常用這種方式來實現一些架構相關且僅通過高級編程語言無法描述的小模塊或者代碼片段。
   - 如果僅存在函數庫而不存在操作系統內核，意味著我們不需要操作系統內核提供過於通用的抽象。在那些功能單一的嵌入式場景就常常會出現這種情況。嵌入式設備雖然也包含處理器、內存和 I/O 設備，但是它上面通常只會同時運行一個或幾個功能非常簡單的小應用程序，比如定時顯示、實時採集數據、人臉識別打卡系統等。常見的解決方案是僅使用函數庫構建單獨的應用程序或是用專為應用場景特別裁減過的輕量級函數庫管理少數應用程序。這就只需要一層函數庫形態的執行環境。
   - 如果存在函數庫和操作系統內核，這意味著應用需求比較多樣，會需要併發執行。常見的通用操作系統如 Windows/Linux/macOS 等都支持併發運行多個不同的應用程序。為此需要更加強大的操作系統抽象和功能，也就會需要多層執行環境。

.. note::

   **“用力過猛”的現代操作系統**

   對於如下更簡單的小應用程序，我們可以看到“用力過猛”的現代操作系統提供的執行環境支持：

   .. code-block:: rust
      :linenos:
      
      //ch1/donothing.rs
      fn main()  {
         //do nothing
      }
   
   對於這個程序，在它的執行過程中，幾乎感知不到它存在感。在編譯後運行，可以看到的情況是：

   .. code-block:: console

      $ rustc donothing.rs
      $ ./donothing
      $ (無輸出)

   與我們預計一樣，程序執行後，看不到有何明顯的輸出信息，程序非常快地就結束了。但如果通過監視程序系統調用請求的工具 `strace` 來重新執行一下這個程序，就可以看到程序執行過程中的大量動態信息：
   
   .. code-block:: console

      $ strace ./donothing
         (多達 93 行的輸出，表明 donothing 向 Linux 操作系統內核發出了93次各種各樣的系統調用)
         execve("./donothing", ["./donothing"], 0x7ffe02c9ca10 /* 67 vars */) = 0
         brk(NULL)                               = 0x563ba0532000
         arch_prctl(0x3001 /* ARCH_??? */, 0x7fff2da54360) = -1 EINVAL (無效的參數)
         ......

   這說明了現在的操作系統，如 `Linux` ，為了通用性，而實現了大量的功能。但對於非常簡單的程序而言，有很多的功能是多餘的。

目標平臺與目標三元組
---------------------------------------

.. _term-platform:

.. note::

   現代編譯器工具集（以C或Rust編譯器為例）的主要工作流程如下：
   
   1. 源代碼（source code） --> 預處理器（preprocessor） --> 宏展開的源代碼
   2. 宏展開的源代碼 --> 編譯器（compiler） --> 彙編程序
   3. 彙編程序 --> 彙編器（assembler）--> 目標代碼（object code）
   4. 目標代碼 --> 鏈接器（linker） --> 可執行文件（executables）


對於一份用某種編程語言實現的應用程序源代碼而言，編譯器在將其通過編譯、鏈接得到可執行文件的時候需要知道程序要在哪個 **平臺** (Platform) 上運行。這裡平臺主要是指 CPU 類型、操作系統類型和標準運行時庫的組合。從上面給出的 :ref:`應用程序執行環境棧 <app-software-stack>` 可以看出：

- 如果用戶態基於的內核不同，會導致系統調用接口不同或者語義不一致；
- 如果底層硬件不同，對於硬件資源的訪問方式會有差異。特別是如果 ISA 不同，則向軟件提供的指令集和寄存器都不同。

它們都會導致最終生成的可執行文件有很大不同。需要指出的是，某些編譯器支持同一份源代碼無需修改就可編譯到多個不同的目標平臺並在上面運行。這種情況下，源代碼是 **跨平臺** 的。而另一些編譯器則已經預設好了一個固定的目標平臺。

.. _term-target-triplet:

Rust編譯器通過 **目標三元組** (Target Triplet) 來描述一個軟件運行的目標平臺。它一般包括 CPU、操作系統和運行時庫等信息，從而控制Rust編譯器可執行代碼生成。比如，我們可以嘗試看一下之前的 ``Hello, world!`` 的目標平臺是什麼。這可以通過打印編譯器 rustc 的默認配置信息：

.. code-block:: console

   $ rustc --version --verbose
      rustc 1.57.0-nightly (e1e9319d9 2021-10-14)
      binary: rustc
      commit-hash: e1e9319d93aea755c444c8f8ff863b0936d7a4b6
      commit-date: 2021-10-14
      host: x86_64-unknown-linux-gnu
      release: 1.57.0-nightly
      LLVM version: 13.0.0

從其中的 host 一項可以看出默認的目標平臺是 ``x86_64-unknown-linux-gnu``，其中 CPU 架構是 x86_64，CPU 廠商是 unknown，操作系統是 linux，運行時庫是 GNU libc（封裝了 Linux 系統調用，並提供 POSIX 接口為主的函數庫）。這種無論編譯器還是其生成的可執行文件都在我們當前所處的平臺運行是一種最簡單也最普遍的情況。但是很快我們就將遇到另外一種情況。

講了這麼多，終於該介紹我們的主線任務了。我們希望能夠在另一個硬件平臺上運行 ``Hello, world!``，而與之前的默認平臺不同的地方在於，我們將 CPU 架構從 x86_64 換成 RISC-V。

.. chyyuu note::
   **為何基於 RISC-V 架構而非 x86 系列架構？**
   x86 架構為了在升級換代的同時保持對基於舊版架構應用程序/內核的兼容性，存在大量的歷史包袱，也就是一些對於目前的應用場景沒有任何意義，但又必須花大量時間正確設置才能正常使用 CPU 的奇怪設定。為了建立並維護架構的應用生態，這確實是必不可少的，但站在教學的角度幾乎是在浪費時間。而新生的 RISC-V 架構十分簡潔，架構文檔需要閱讀的核心部分不足百頁，且這些功能已經足以用來構造一個具有相當抽象能力且可以運行的簡潔內核了。

可以看一下目前 Rust 編譯器支持哪些基於 RISC-V 的目標平臺：

.. code-block:: console

   $ rustc --print target-list | grep riscv
   riscv32gc-unknown-linux-gnu
   riscv32i-unknown-none-elf
   riscv32imac-unknown-none-elf
   riscv32imc-unknown-none-elf
   riscv64gc-unknown-linux-gnu
   riscv64gc-unknown-none-elf
   riscv64imac-unknown-none-elf

這裡我們選擇 ``riscv64gc-unknown-none-elf`` 目標平臺。這其中的 CPU 架構是 `riscv64gc` ，CPU廠商是 `unknown` ，操作系統是 `none` ， `elf` 表示沒有標準的運行時庫（表明沒有任何系統調用的封裝支持），但可以生成 ELF 格式的執行程序。這裡我們之所以不選擇有 linux-gnu 系統調用支持的目標平臺 ``riscv64gc-unknown-linux-gnu``，是因為我們只是想跑一個在裸機環境上運行的 ``Hello, world!`` 應用程序，沒有必要使用Linux操作系統提供的那麼高級的抽象和多餘的操作系統服務。而且我們很清楚後續我們要開發的是一個操作系統內核，它必須直面底層物理硬件（bare-metal）來提供精簡的操作系統服務功能，通用操作系統（如 Linux）提供的很多系統調用服務對這個內核而言是多餘的。

.. note::

   **RISC-V 指令集拓展**

   由於基於 RISC-V 架構的處理器可能用於嵌入式場景或是通用計算場景，因此指令集規範將指令集劃分為最基本的 RV32/64I 以及若干標準指令集拓展。每款處理器只需按照其實際應用場景按需實現指令集拓展即可。

   - RV32/64I：每款處理器都必須實現的基本整數指令集。在 RV32I 中，每個通用寄存器的位寬為 32 位；在 RV64I 中則為 64 位。它可以用來模擬絕大多數標準指令集拓展中的指令，除了比較特殊的 A 拓展，因為它需要特別的硬件支持。
   - M 拓展：提供整數乘除法相關指令。
   - A 拓展：提供原子指令和一些相關的內存同步機制，這個後面會展開。
   - F/D 拓展：提供單/雙精度浮點數運算支持。
   - C 拓展：提供壓縮指令拓展。

   G 拓展是基本整數指令集 I 再加上標準指令集拓展 MAFD 的總稱，因此 riscv64gc 也就等同於 riscv64imafdc。我們剩下的內容都基於該處理器架構完成。除此之外 RISC-V 架構還有很多標準指令集拓展，有一些還在持續更新中尚未穩定，有興趣的同學可以瀏覽最新版的 RISC-V 指令集規範。

Rust 標準庫與核心庫
----------------------------------

我們嘗試一下將當前的 ``Hello, world!`` 程序的目標平臺換成 riscv64gc-unknown-none-elf 看看會發生什麼事情：

.. code-block:: console
   
   $ cargo run --target riscv64gc-unknown-none-elf
      Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)
   error[E0463]: can't find crate for `std`
     |
     = note: the `riscv64gc-unknown-none-elf` target may not be installed

.. _term-bare-metal:

在之前的開發環境配置中，我們已經在 rustup 工具鏈中安裝了這個目標平臺支持，因此並不是該目標平臺未安裝的問題。這個問題只是單純的表示在這個目標平臺上找不到 Rust 標準庫 std。我們之前曾經提到過，編程語言的標準庫或三方庫的某些功能會直接或間接的用到操作系統提供的系統調用。但目前我們所選的目標平臺不存在任何操作系統支持，於是 Rust 並沒有為這個目標平臺支持完整的標準庫 std。類似這樣的平臺通常被我們稱為 **裸機平臺** (bare-metal)。這意味著在裸機平臺上的軟件沒有傳統操作系統支持。

.. note::

   **Rust Tips：Rust語言標準庫std和核心庫core**

   Rust 語言標準庫--std 是讓 Rust 語言開發的軟件具備可移植性的基礎，類似於 C 語言的 LibC 標準庫。它是一組小巧的、經過實踐檢驗的共享抽象，適用於更廣泛的 Rust 生態系統開發。它提供了核心類型，如 Vec 和 Option、類庫定義的語言原語操作、標準宏、I/O 和多線程等。默認情況下，我們可以使用 Rust 語言標準庫來支持 Rust 應用程序的開發。但 Rust 語言標準庫的一個限制是，它需要有操作系統的支持。所以，如果你要實現的軟件是運行在裸機上的操作系統，就不能直接用 Rust 語言標準庫了。


幸運的是，Rust 有一個對 Rust 語言標準庫--std 裁剪過後的 Rust 語言核心庫 core。core庫是不需要任何操作系統支持的，它的功能也比較受限，但是也包含了 Rust 語言相當一部分的核心機制，可以滿足我們的大部分功能需求。Rust 語言是一種面向系統（包括操作系統）開發的語言，所以在 Rust 語言生態中，有很多三方庫也不依賴標準庫 std 而僅僅依賴核心庫 core。對它們的使用可以很大程度上減輕我們的編程負擔。它們是我們能夠在裸機平臺掙扎求生的最主要倚仗，也是大部分運行在沒有操作系統支持的 Rust 嵌入式軟件的必備。

於是，我們知道在裸機平臺上我們要將對於標準庫 std 的引用換成核心庫 core。但是實際做起來其實還要有一些瑣碎的事情需要解決。
