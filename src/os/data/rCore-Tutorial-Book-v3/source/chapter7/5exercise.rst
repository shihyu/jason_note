練習
===========================================

課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 分別編寫基於UNIX System V IPC的管道、共享內存、信號量和消息隊列的Linux應用程序，實現進程間的數據交換。
2. `**` 分別編寫基於UNIX的signal機制的Linux應用程序，實現進程間異步通知。
3. `**` 參考rCore Tutorial 中的shell應用程序，在Linux環境下，編寫一個簡單的shell應用程序，通過管道相關的系統調用，能夠支持管道功能。
4. `**` 擴展內核，實現共享內存機制。
5. `***` 擴展內核，實現signal機制。

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 直接通信和間接通信的本質區別是什麼？分別舉一個例子。
2. `**` 試說明基於UNIX的signal機制，如果在本章內核中實現，請描述其大致設計思路和運行過程。
3. `**` 比較在Linux中的無名管道（普通管道）與有名管道（FIFO）的異同。
4. `**` 請描述Linux中的無名管道機制的特徵和適用場景。
5. `**` 請描述Linux中的消息隊列機制的特徵和適用場景。
6. `**` 請描述Linux中的共享內存機制的特徵和適用場景。
7. `**` 請描述Linux的bash shell中執行與一個程序時，用戶敲擊 `Ctrl+C` 後，會產生什麼信號（signal），導致什麼情況出現。
8. `**` 請描述Linux的bash shell中執行與一個程序時，用戶敲擊 `Ctrl+Zombie` 後，會產生什麼信號（signal），導致什麼情況出現。
9. `**` 請描述Linux的bash shell中執行 `kill -9 2022` 這個命令的含義是什麼？導致什麼情況出現。
10. `**` 請指出一種跨計算機的主機間的進程間通信機制。

實驗練習
-------------------------------

實驗練習包括實踐作業和問答作業兩部分。

**本次難度也就和lab3一樣吧** 

編程作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

進程通信：郵箱
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

這一章我們實現了基於 pipe 的進程間通信，但是看測例就知道了，管道不太自由，我們來實現一套乍一看更靠譜的通信 syscall吧！本節要求實現郵箱機制，以及對應的 syscall。

- 郵箱說明：每個進程擁有唯一一個郵箱，基於“數據報”收發字節信息，利用環形buffer存儲，讀寫順序為 FIFO，不記錄來源進程。每次讀寫單位必須為一個報文，如果用於接收的緩衝區長度不夠，捨棄超出的部分（截斷報文）。為了簡單，郵箱中最多擁有16條報文，每條報文最大長度256字節。當郵箱滿時，發送郵件（也就是寫郵箱）會失敗。不考慮讀寫郵箱的權限，也就是所有進程都能夠隨意給其他進程的郵箱發報。

**mailread**:

    * syscall ID：401
    * Rust接口: ``fn mailread(buf: *mut u8, len: usize)``
    * 功能：讀取一個報文，如果成功返回報文長度.
    * 參數：
        * buf: 緩衝區頭。
        * len：緩衝區長度。
    * 說明：
        * len > 256 按 256 處理，len < 隊首報文長度且不為0，則截斷報文。
        * len = 0，則不進行讀取，如果沒有報文讀取，返回-1，否則返回0，這是用來測試是否有報文可讀。
    * 可能的錯誤：
        * 郵箱空。
        * buf 無效。

**mailwrite**:

    * syscall ID：402
    * Rust接口: ``fn mailwrite(pid: usize, buf: *mut u8, len: usize)``
    * 功能：向對應進程郵箱插入一條報文.
    * 參數：
        * pid: 目標進程id。
        * buf: 緩衝區頭。
        * len：緩衝區長度。
    * 說明：
        * len > 256 按 256 處理，
        * len = 0，則不進行寫入，如果郵箱滿，返回-1，否則返回0，這是用來測試是否可以發報。
        * 可以向自己的郵箱寫入報文。
    * 可能的錯誤：
        * 郵箱滿。
        * buf 無效。
  
實驗要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- 實現分支：ch6-lab
- 實驗目錄要求不變
- 通過所有測例

  在 os 目錄下 ``make run TEST=1`` 加載所有測例， ``test_usertest`` 打包了所有你需要通過的測例，你也可以通過修改這個文件調整本地測試的內容。

  你的內核必須前向兼容，能通過前一章的所有測例。

challenge: 支持多核。

問答作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(1) 舉出使用 pipe 的一個實際應用的例子。

(2) 共享內存的測例中有如下片段(偽代碼)：

    .. code-block:: c 

      int main()
      {
          uint64 *A = (void *)0x10000000;
          uint64 *B = (void *)(0x10000000 + 0x1000);
          uint64 len = 0x1000;
          make_shmem(A, B, len); // 將 [A, A + len) [B, B + len) 這兩段虛存映射到同一段物理內存
          *A = 0xabab;
          __sync_synchronize();  // 這是什麼？
          if(*B != 0xabab) {
              return ERROR;
          }
          printf("OK!");
          return 0;
      }

    請查閱相關資料，回答 ``__sync_synchronize`` 這行代碼的作用，如果去掉它可能會導致什麼錯誤？為什麼？


實驗練習的提交報告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 簡單總結本次實驗與上個實驗相比你增加的東西。（控制在5行以內，不要貼代碼）
* 完成問答問題
* (optional) 你對本次實驗設計及難度的看法。