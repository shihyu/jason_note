進程概念及重要系統調用
================================================

本節導讀
-------------------------

本節的內容有：

- 介紹進程的概念以及它和一些其他相近的概念的比較；
- 從應用開發者或是用戶的角度介紹我們實現的一種簡單類 Unix 進程模型；
- 介紹三個最重要的進程相關係統調用並給出一些用例。

進程概念
-------------------------

.. _term-process:

在本章的引言中，出於方便應用開發和使得應用功能更加強大的目標，我們引入了進程的概念。在本章之前，我們有 **任務** 的概念，即 **正在執行的程序** ，主角是程序。而相比於 **任務** ， **進程** (Process) 的含義是 **在操作系統管理下的程序的一次執行過程**。這裡的“程序的”成了形容詞，而執行過程成為了主角，這充分體現了動態變化的執行特點。儘管這說起來很容易，但事實上進程是一個內涵相當豐富且深刻、難以從單個角度解釋清楚的抽象概念。我們可以先試著從動態和靜態的角度來進行初步的思考。我們知道，當一個應用的源程序被編譯器成功構建之後，它會從源代碼變為某種格式的可執行文件，如果將其展開，可以在它的內存佈局中看到若干個功能迥異的邏輯段。但如果僅是這樣，它也就只是某種格式特殊的、被 **靜態** 歸檔到存儲器上的一個文件而已。

然而，可執行文件與其他類型文件的根本性不同在於它可以被內核加載並執行。這一執行過程自然是不能憑空進行的，而是需要佔據某些真實的硬件資源。例如，可執行文件一定需要被加載到物理內存的某些區域中才能執行，另外還可能需要預留一些可執行文件內存佈局中未規劃的區域（比如堆和棧），這就會消耗掉部分內存空間；在執行的時候需要佔據一個 CPU 的全部硬件資源，我們之前介紹過的有通用寄存器（其中程序計數器 pc 和棧指針 sp 兩個意義尤其重大）、CSR 、各級 cache 、TLB 等。

打一個比方，可執行文件本身可以看成一張編譯器解析源代碼之後總結出的一張記載如何利用各種硬件資源進行一輪生產流程的 **藍圖** 。而內核的一大功能便是作為一個硬件資源管理器，它可以隨時啟動一輪生產流程（即執行任意一個應用），這需要選中一張藍圖（此時確定執行哪個可執行文件），接下來就需要內核按照藍圖上所記載的對資源的需求來對應的將各類資源分配給它，讓這輪生產流程得以順利進行。當按照藍圖上的記載生產流程完成（應用退出）之後，內核還需要將對應的硬件資源回收以便後續的重複利用。

因此，進程就是操作系統選取某個可執行文件並對其進行一次動態執行的過程。相比可執行文件，它的動態性主要體現在：

1. 它是一個過程，從時間上來看有開始也有結束；
2. 在該過程中對於可執行文件中給出的需求要相應對 **硬件/虛擬資源** 進行 **動態綁定和解綁** 。

這裡需要指出的是，兩個進程可以選擇同一個可執行文件執行，然而它們卻是截然不同的進程：它們的啟動時間、佔據的硬件資源、輸入數據均有可能是不同的，這些條件均會導致它們是不一樣的執行過程。在某些情況下，我們可以看到它們的輸出是不同的——這是其中一種可能的直觀表象。

在內核中，需要有一個進程管理器，在其中記錄每個進程對資源的佔用情況，這是內核作為一個硬件資源管理器所必須要做到的。進程管理器通常需要管理多個進程，因為如果同一時間只有一個進程的話，就可以簡單的將所有的硬件資源都交給該進程，同時內核也會像第一章《RV64 裸機應用》那樣退化成一個函數庫。

本節接下來主要站在應用開發者和用戶的角度來介紹如何理解進程概念並基於它編寫應用程序。

.. note::

    **為何要在這裡才引入進程**

    根據我們多年來的 OS 課程經驗，學生對 **進程** 的簡單定義“ **正在執行的程序** ”比較容易理解。但對於多個運行的程序之間如何切換，會帶來哪些併發問題，進程創建與虛擬內存的關係等問題很難一下子理解清楚，也不清楚試圖解決這些問題的原因。這主要是由於學生對進程的理解是站在應用程序角度來看的。
    
    如果變化一下，讓學生站在操作系統的角度來看，那麼在進程這個定義背後，有特權級切換、異常處理，程序執行的上下文切換、地址映射、地址空間、虛存管理等一系列的知識支撐，才能理解清楚操作系統對進程的整個管理過程。所以，我們在前面幾章對上述知識進行了鋪墊。並以此為基礎，更加全面地來分析操作系統是如何管理進程的。

.. note::
    
    **進程，線程和協程**

    進程，線程和協程是操作系統中經常出現的名詞，它們都是操作系統中的抽象概念，有聯繫和共同的地方，但也有區別。計算機的核心是 CPU，它承擔了基本上所有的計算任務；而操作系統是計算機的管理者，它可以以進程，線程和協程為基本的管理和調度單位來使用 CPU 執行具體的程序邏輯。

    從歷史角度上看，它們依次出現的順序是進程、線程和協程。在還沒有進程抽象的早期操作系統中，計算機科學家把程序在計算機上的一次執行過程稱為一個任務（Task）或一個工作（Job），其特點是任務和工作在其整個的執行過程中，不會被切換。這樣其他任務必須等待一個任務結束後，才能執行，這樣系統的效率會比較低。
    
    在引入面向 CPU 的分時切換機制和麵向內存的虛擬內存機制後，進程的概念就被提出了，進程成為 CPU（也稱處理器）調度（Scheduling）和分派（Switch）的對象，各個進程間以時間片為單位輪流使用 CPU，且每個進程有各自獨立的一塊內存，使得各個進程之間內存地址相互隔離。這時，操作系統通過進程這個抽象來完成對應用程序在 CPU 和內存使用上的管理。

    隨著計算機的發展，對計算機系統性能的要求越來越高，而進程之間的切換開銷相對較大，於是計算機科學家就提出了線程。線程是程序執行中一個單一的順序控制流程，線程是進程的一部分，一個進程可以包含一個或多個線程。各個線程之間共享進程的地址空間，但線程要有自己獨立的棧（用於函數訪問，局部變量等）和獨立的控制流。且線程是處理器調度和分派的基本單位。對於線程的調度和管理，可以在操作系統層面完成，也可以在用戶態的線程庫中完成。用戶態線程也稱為綠色線程（GreenThread）。如果是在用戶態的線程庫中完成，操作系統是“看不到”這樣的線程的，也就談不上對這樣線程的管理了。

    協程（Coroutines，也稱纖程（Fiber）），也是程序執行中一個單一的順序控制流程，建立在線程之上（即一個線程上可以有多個協程），但又是比線程更加輕量級的處理器調度對象。協程一般是由用戶態的協程管理庫來進行管理和調度，這樣操作系統是看不到協程的。而且多個協程共享同一線程的棧，這樣協程在時間和空間的管理開銷上，相對於線程又有很大的改善。在具體實現上，協程可以在用戶態運行時庫這一層面通過函數調用來實現；也可在語言級支持協程，比如 Rust 借鑑自其他語言的的 ``async`` 、 ``await`` 關鍵字等，通過編譯器和運行時庫二者配合來簡化程序員編程的負擔並提高整體的性能。

進程模型與重要系統調用
------------------------------------------------------------

目前，我們只介紹本章實現的內核中採用的一種非常簡單的進程模型。這個進程模型有三個運行狀態：就緒態、運行態和等待態；有基於獨立頁表的地址空間；可被操作系統調度來分時佔用 CPU 執行；可以動態創建和退出；可通過系統調用獲得操作系統的服務。

前面我們並沒有給出進程需要使用哪些類型的資源，這其實取決於內核提供給應用的系統調用接口以及內核的具體實現。我們實現的進程模型建立在地址空間抽象之上：每個進程都需要一個地址空間，它涵蓋了它選擇的可執行文件的內存佈局，還包含一些其他的邏輯段。且進程模型需要操作系統支持一些重要的系統調用：創建進程、執行新程序、等待進程結束等，來達到應用程序執行的動態靈活性。接下來會介紹這些系統調用的基本功能和設計思路。

fork 系統調用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _term-pid:
.. _term-initial-process:

系統中同一時間存在的每個進程都被一個不同的 **進程標識符** (PID, Process Identifier) 所標識。在內核初始化完畢之後會創建一個進程——即 **用戶初始進程** (Initial Process) ，它是目前在內核中以硬編碼方式創建的唯一一個進程。其他所有的進程都是通過一個名為 ``fork`` 的系統調用來創建的。

.. code-block:: rust

    /// 功能：當前進程 fork 出來一個子進程。
    /// 返回值：對於子進程返回 0，對於當前進程則返回子進程的 PID 。
    /// syscall ID：220
    pub fn sys_fork() -> isize;

進程 A 調用 ``fork`` 系統調用之後，內核會創建一個新進程 B，這個進程 B 和調用 ``fork`` 的進程A在它們分別返回用戶態那一瞬間幾乎處於相同的狀態：這意味著它們包含的用戶態的代碼段、堆棧段及其他數據段的內容完全相同，但是它們是被放在兩個獨立的地址空間中的。因此新進程的地址空間需要從原有進程的地址空間完整拷貝一份。兩個進程通用寄存器也幾乎完全相同。例如， pc 相同意味著兩個進程會從同一位置的一條相同指令（我們知道其上一條指令一定是用於系統調用的 ecall 指令）開始向下執行， sp 相同則意味著兩個進程的用戶棧在各自的地址空間中的位置相同。其餘的寄存器相同則確保了二者回到了相同的控制流狀態。

.. _term-child-process:
.. _term-parent-process:

但是唯有用來保存 ``fork`` 系統調用返回值的 a0 寄存器（這是 RISC-V 64 的函數調用規範規定的函數返回值所用的寄存器）的值是不同的。這區分了兩個進程：原進程的返回值為它新創建進程的 PID ，而新創建進程的返回值為 0 。由於新的進程是原進程主動調用 ``fork`` 衍生出來的，我們稱新進程為原進程的 **子進程** (Child Process) ，相對的原進程則被稱為新進程的 **父進程** (Parent Process) 。這樣二者就建立了一種父子關係。注意到每個進程可能有多個子進程，但最多隻能有一個父進程，於是所有進程可以被組織成一顆樹，其根節點正是代表用戶初始程序——initproc，也即第一個用戶態的初始進程。

相比創建一個進程， ``fork`` 的另一個重要功能是建立一對新的父子關係。在我們的進程模型中，父進程和子進程之間的聯繫更為緊密，它們更容易進行合作或通信，而且一些重要的機制（如第七章會涉及的進程間通信機制）也需要在它們之間才能展開。

waitpid 系統調用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _term-zombie-process:

當一個進程通過 ``exit`` 系統調用退出之後，它所佔用的資源並不能夠立即全部回收。比如該進程的內核棧目前就正用來進行系統調用處理，如果將放置它的物理頁幀回收的話，可能會導致系統調用不能正常處理。對於這種問題，一種典型的做法是當進程退出的時候內核立即回收一部分資源並將該進程標記為 **殭屍進程** (Zombie Process) 。之後，由該進程的父進程通過一個名為 ``waitpid`` 的系統調用來收集該進程的返回狀態並回收掉它所佔據的全部資源，這樣這個進程才被徹底銷燬。系統調用 ``waitpid`` 的原型如下：

.. code-block:: rust

    /// 功能：當前進程等待一個子進程變為殭屍進程，回收其全部資源並收集其返回值。
    /// 參數：pid 表示要等待的子進程的進程 ID，如果為 -1 的話表示等待任意一個子進程；
    /// exit_code 表示保存子進程返回值的地址，如果這個地址為 0 的話表示不必保存。
    /// 返回值：如果要等待的子進程不存在則返回 -1；否則如果要等待的子進程均未結束則返回 -2；
    /// 否則返回結束的子進程的進程 ID。
    /// syscall ID：260
    pub fn sys_waitpid(pid: isize, exit_code: *mut i32) -> isize;

一般情況下一個進程要負責通過 ``waitpid`` 系統調用來等待它 ``fork`` 出來的子進程結束並回收掉它們佔據的資源，這也是父子進程間的一種同步手段。但這並不是必須的。如果一個進程先於它的子進程結束，在它退出的時候，它的所有子進程將成為進程樹的根節點——用戶初始進程的子進程，同時這些子進程的父進程也會轉成用戶初始進程。這之後，這些子進程的資源就由用戶初始進程負責回收了，這也是用戶初始進程很重要的一個用途。後面我們會介紹用戶初始進程是如何實現的。

exec 系統調用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果僅有 ``fork`` 的話，那麼所有的進程都只能和用戶初始進程一樣執行同樣的代碼段，這顯然是遠遠不夠的。於是我們還需要引入 ``exec`` 系統調用來執行不同的可執行文件：

.. code-block:: rust

    /// 功能：將當前進程的地址空間清空並加載一個特定的可執行文件，返回用戶態後開始它的執行。
    /// 參數：path 給出了要加載的可執行文件的名字；
    /// 返回值：如果出錯的話（如找不到名字相符的可執行文件）則返回 -1，否則不應該返回。
    /// syscall ID：221
    pub fn sys_exec(path: &str) -> isize;

注意，我們知道 ``path`` 作為 ``&str`` 類型是一個胖指針，既有起始地址又包含長度信息。在實際進行系統調用的時候，我們只會將起始地址傳給內核（對標 C 語言僅會傳入一個 ``char*`` ）。這就需要應用負責在傳入的字符串的末尾加上一個 ``\0`` ，這樣內核才能知道字符串的長度。下面給出了用戶庫 ``user_lib`` 中的調用方式：

.. code-block:: rust

    // user/src/exec.rs

    pub fn sys_exec(path: &str) -> isize {
        syscall(SYSCALL_EXEC, [path.as_ptr() as usize, 0, 0])
    }

這樣，利用 ``fork`` 和 ``exec`` 的組合，我們很容易在一個進程內 ``fork`` 出一個子進程並執行一個特定的可執行文件。

.. _term-redirection:

.. note::

    **為何創建進程要通過兩個系統調用而不是一個？**

    同學可能會有疑問，對於要達成執行不同應用的目標，我們為什麼不設計一個系統調用接口同時實現創建一個新進程並加載給定的可執行文件兩種功能？如果使用 ``fork`` 和 ``exec`` 的組合，那麼 ``fork`` 出來的進程僅僅是為了 ``exec`` 一個新應用提供空間。而執行 ``fork`` 中對父進程的地址空間拷貝沒有用處，還浪費了時間，且在後續清空地址空間的時候還會產生一些資源回收的額外開銷。這樣的設計來源於早期的 MULTICS [#multics]_ 和 UNIX 操作系統  [#unix]_ ，在當時是經過實踐考驗的，事實上 ``fork`` 和 ``exec`` 是一種靈活的系統調用組合，在當時內存空間比較小的情況下，可以支持更快的進程創建，且上述的開銷能夠通過一些結合虛存的技術方法（如 *Copy on write* 等）來緩解。而且拆分為兩個系統調用後，可以靈活地支持 **重定向** (Redirection) 等功能。
    上述方法是 UNIX 類操作系統的典型做法。

    這一點與 Windows 操作系統不一樣。在 Windows 中， ``CreateProcess`` 函數用來創建一個新的進程和它的主線程，通過這個新進程運行指定的可執行文件。雖然是一個函數，但這個函數的參數十個之多，使得這個函數很複雜，且沒有 ``fork`` 和 ``exec`` 的組合的靈活性。而基於 POSIX 標準的 ``posix_spawn`` 系統調用則類似 Windows 的 ``CreateProcess`` 函數，不過對參數進行了簡化，更適合現在的計算機系統（有更大的物理內存空間）和類 UNIX 應用程序(更加複雜的軟件)。


應用程序示例
-----------------------------------------------

我們剛剛介紹了 ``fork/waitpid/exec`` 三個重要系統調用，我們可以藉助它們和之前實現的系統調用開發出功能更為強大的應用程序。下面我們通過描述兩個重要的應用程序： **用戶初始程序-init** 和 **shell程序-user_shell** 的開發過程，來展示這些重要系統調用的使用方法。

系統調用封裝
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

同學可以在 ``user/src/syscall.rs`` 中看到以 ``sys_*`` 開頭的系統調用的函數原型，它們後續還會在 ``user/src/lib.rs`` 中被封裝成方便應用程序使用的形式。如 ``sys_fork`` 被封裝成 ``fork`` ，而 ``sys_exec`` 被封裝成 ``exec`` 。這裡值得一提的是 ``sys_waitpid`` 被封裝成兩個不同的 API ：

.. code-block:: rust
    :linenos:

    // user/src/lib.rs

    pub fn wait(exit_code: &mut i32) -> isize {
        loop {
            match sys_waitpid(-1, exit_code as *mut _) {
                -2 => { yield_(); }
                // -1 or a real pid
                exit_pid => return exit_pid,
            }
        }
    }

    pub fn waitpid(pid: usize, exit_code: &mut i32) -> isize {
        loop {
            match sys_waitpid(pid as isize, exit_code as *mut _) {
                -2 => { yield_(); }
                // -1 or a real pid
                exit_pid => return exit_pid,
            }
        }
    }

其中 ``wait`` 表示等待任意一個子進程結束，根據 ``sys_waitpid`` 的約定它需要傳的 pid 參數為 ``-1`` ；而 ``waitpid`` 則等待一個進程標識符的值為pid 的子進程結束。在具體實現方面，我們看到當 ``sys_waitpid`` 返回值為 ``-2`` ，即要等待的子進程存在但它卻尚未退出的時候，我們調用 ``yield_`` 主動交出 CPU 使用權，待下次 CPU 使用權被內核交還給它的時候再次調用 ``sys_waitpid`` 查看要等待的子進程是否退出。這樣做可以減小 CPU 資源的浪費。

目前的實現風格是儘可能簡化內核，因此 ``sys_waitpid`` 是立即返回的，即它的返回值只能給出返回這一時刻的狀態。如果這一時刻要等待的子進程還尚未結束，那麼也只能如實嚮應用報告這一結果。於是用戶庫 ``usr/src/lib.rs`` 就需要負責對返回狀態進行持續的監控，因此它裡面便需要進行循環檢查。在後續的實現中，我們會將  ``sys_waitpid`` 的內核實現設計為 **阻塞** 的，即直到得到一個確切的結果之前，其對應的進程暫停（不再繼續執行）在內核內；如果  ``sys_waitpid`` 需要的值能夠得到，則它對應的進程會被內核喚醒繼續執行，且內核返回給應用的結果可以直接使用。那時 ``wait`` 和 ``waitpid`` 兩個 API 的實現便會更加簡單。

用戶初始程序 initproc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我們首先來看用戶初始程序 initproc 是如何實現的：

.. code-block:: rust
    :linenos:

    // user/src/bin/initproc.rs

    #![no_std]
    #![no_main]

    #[macro_use]
    extern crate user_lib;

    use user_lib::{
        fork,
        wait,
        exec,
        yield_,
    };

    #[no_mangle]
    fn main() -> i32 {
        if fork() == 0 {
            exec("user_shell\0");
        } else {
            loop {
                let mut exit_code: i32 = 0;
                let pid = wait(&mut exit_code);
                if pid == -1 {
                    yield_();
                    continue;
                }
                println!(
                    "[initproc] Released a zombie process, pid={}, exit_code={}",
                    pid,
                    exit_code,
                );
            }
        }
        0
    }

- 第 19 行為 ``fork`` 返回值為 0 的分支，表示子進程，此行直接通過 ``exec`` 執行 shell 程序 ``user_shell`` ，注意我們需要在字符串末尾手動加入 ``\0`` ，因為 Rust 在將這些字符串連接到只讀數據段的時候不會插入 ``\0`` 。
- 第 21 行開始則為返回值不為 0 的分支，表示調用 ``fork`` 的用戶初始程序 initproc 自身。可以看到它在不斷循環調用 ``wait`` 來等待那些被移交到它下面的子進程並回收它們佔據的資源。如果回收成功的話則會打印一條報告信息給出被回收子進程的 pid 值和返回值；否則就 ``yield_`` 交出 CPU 資源並在下次輪到它執行的時候再回收看看。這也可以看出，用戶初始程序 initproc 對於資源的回收並不算及時，但是對於已經退出的殭屍進程，用戶初始程序 initproc 最終總能夠成功回收它們的資源。 


shell程序 user_shell
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

由於shell程序 user_shell 需要捕獲我們的輸入並進行解析處理，我們需要加入一個新的用於輸入的系統調用：

.. code-block:: rust

    /// 功能：從文件中讀取一段內容到緩衝區。
    /// 參數：fd 是待讀取文件的文件描述符，切片 buffer 則給出緩衝區。
    /// 返回值：如果出現了錯誤則返回 -1，否則返回實際讀到的字節數。
    /// syscall ID：63
    pub fn sys_read(fd: usize, buffer: &mut [u8]) -> isize;

在實際調用的時候我們必須要同時向內核提供緩衝區的起始地址及長度：

.. code-block:: rust

    // user/src/syscall.rs

    pub fn sys_read(fd: usize, buffer: &mut [u8]) -> isize {
        syscall(SYSCALL_READ, [fd, buffer.as_mut_ptr() as usize, buffer.len()])
    }

我們在用戶庫中將其進一步封裝成每次能夠從 **標準輸入** 中獲取一個字符的 ``getchar`` 函數：

.. code-block:: rust

    // user/src/lib.rs

    pub fn read(fd: usize, buf: &mut [u8]) -> isize { sys_read(fd, buf) }

    // user/src/console.rs

    const STDIN: usize = 0;

    pub fn getchar() -> u8 {
        let mut c = [0u8; 1];
        read(STDIN, &mut c);
        c[0]
    }

其中，我們每次臨時聲明一個長度為 1 的緩衝區。

接下來就可以介紹 shell 程序 ``user_shell`` 是如何實現的了：

.. code-block:: rust
    :linenos:
    :emphasize-lines: 28,53,61

    // user/src/bin/user_shell.rs

    #![no_std]
    #![no_main]

    extern crate alloc;

    #[macro_use]
    extern crate user_lib;

    const LF: u8 = 0x0au8;
    const CR: u8 = 0x0du8;
    const DL: u8 = 0x7fu8;
    const BS: u8 = 0x08u8;

    use alloc::string::String;
    use user_lib::{fork, exec, waitpid, yield_};
    use user_lib::console::getchar;

    #[no_mangle]
    pub fn main() -> i32 {
        println!("Rust user shell");
        let mut line: String = String::new();
        print!(">> ");
        loop {
            let c = getchar();
            match c {
                LF | CR => {
                    println!("");
                    if !line.is_empty() {
                        line.push('\0');
                        let pid = fork();
                        if pid == 0 {
                            // child process
                            if exec(line.as_str()) == -1 {
                                println!("Error when executing!");
                                return -4;
                            }
                            unreachable!();
                        } else {
                            let mut exit_code: i32 = 0;
                            let exit_pid = waitpid(pid as usize, &mut exit_code);
                            assert_eq!(pid, exit_pid);
                            println!(
                                "Shell: Process {} exited with code {}",
                                pid, exit_code
                            );
                        }
                        line.clear();
                    }
                    print!(">> ");
                }
                BS | DL => {
                    if !line.is_empty() {
                        print!("{}", BS as char);
                        print!(" ");
                        print!("{}", BS as char);
                        line.pop();
                    }
                }
                _ => {
                    print!("{}", c as char);
                    line.push(c as char);
                }
            }
        }
    }

可以看到，在以第 25 行開頭的主循環中，每次都是調用 ``getchar`` 獲取一個用戶輸入的字符，並根據它相應進行一些動作。第 23 行聲明的字符串 ``line`` 則維護著用戶當前輸入的命令內容，它也在不斷髮生變化。

.. note::

    **在應用中使能動態內存分配**

    我們知道，在 Rust 中可變長字符串類型 ``String`` 是基於動態內存分配的。因此本章我們還要在用戶庫 ``user_lib`` 中支持動態內存分配，與第四章的做法相同，只需加入以下內容即可：

    .. code-block:: rust

        use buddy_system_allocator::LockedHeap;

        const USER_HEAP_SIZE: usize = 16384;

        static mut HEAP_SPACE: [u8; USER_HEAP_SIZE] = [0; USER_HEAP_SIZE];

        #[global_allocator]
        static HEAP: LockedHeap = LockedHeap::empty();

        #[alloc_error_handler]
        pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
            panic!("Heap allocation error, layout = {:?}", layout);
        }

        #[no_mangle]
        #[link_section = ".text.entry"]
        pub extern "C" fn _start() -> ! {
            unsafe {
                HEAP.lock()
                    .init(HEAP_SPACE.as_ptr() as usize, USER_HEAP_SIZE);
            }
            exit(main());
        }

- 如果用戶輸入回車鍵（第 28 行），那麼 user_shell 會 fork 出一個子進程（第 34 行開始）並試圖通過 ``exec`` 系統調用執行一個應用，應用的名字在字符串 ``line`` 中給出。這裡我們需要注意的是，由於子進程是從 user_shell 進程中 fork 出來的，它們除了 fork 的返回值不同之外均相同，自然也可以看到一個和user_shell 進程維護的版本相同的字符串 ``line`` 。第 35 行對 ``exec`` 的返回值進行了判斷，如果返回值為 -1 則說明在應用管理器中找不到名字相同的應用，此時子進程就直接打印錯誤信息並退出；反之 ``exec`` 則根本不會返回，而是開始執行目標應用。

  fork 之後的 user_shell 進程自己的邏輯可以在第 41 行找到。可以看出它只是在等待 fork 出來的子進程結束並回收掉它的資源，還會順帶收集子進程的退出狀態並打印出來。
- 如果用戶輸入退格鍵（第 53 行），首先我們需要將屏幕上當前行的最後一個字符用空格替換掉，這可以通過輸入一個特殊的退格字節 ``BS`` 來實現。其次，user_shell 進程內維護的 ``line`` 也需要彈出最後一個字符。
- 如果用戶輸入了一個其他字符（第 61 行），它將會被視為用戶的正常輸入，我們直接將它打印在屏幕上並加入到 ``line`` 中。

當內核初始化完畢之後，它會從可執行文件 ``initproc`` 中加載並執行用戶初始程序 initproc，而用戶初始程序 initproc中又會 ``fork`` 並 ``exec`` 來運行shell程序 ``user_shell`` 。這兩個應用雖然都是在 CPU 的 U 特權級執行的，但是相比其他應用，它們要更加底層和基礎。原則上應該將它們作為一個組件打包在操作系統中。但這裡為了實現更加簡單，我們並不將它們和其他應用進行區分。

除此之外，我們還從 :math:`\mu\text{Core}`  [#uCore]_ 中借鑑了很多應用測例。它們可以做到同一時間 **併發** 多個進程並能夠有效檢驗我們內核實現的正確性。感興趣的同學可以參考 ``matrix`` 和 ``forktree`` 等應用。


.. [#multics] 1965年，MIT、通用電氣公司、貝爾實驗室聯合開發 MULTICS 操作系統，開發不夠成功，但產生了很多新的設計思想，並催生了UNIX操作系統。
.. [#unix]  1969 年，貝爾實驗室的 Ken Thompson 和 Dennis Ritchie 在退出 MUITICS 操作系統研發後，吸收其好的想法，設計實現了 UNIX 操作系統和 C 語言，並開始廣泛推廣。

.. [#uCore] uCore OS 是用於清華大學計算機系本科操作系統課程的 OS 教學試驗內容。 uCore OS 起源於 MIT CSAIL PDOS 課題組開發的xv6&jos、哈佛大學開發的 OS161 教學操作系統、以及 Linux-2.4 內核。目前 rCore/uCore Tutorial OS 逐步代替 uCore OS 成為新的教學 OS。  