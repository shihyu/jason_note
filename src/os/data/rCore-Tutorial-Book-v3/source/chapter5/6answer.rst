練習參考答案
==============================================

課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 實現一個使用nice,fork,exec,spawn等與進程管理相關的系統調用的linux應用程序。

   參考實現：

   .. code-block:: c

      #include <unistd.h> 
      #include <stdlib.h> 
      #include <stdio.h>  
      int main(void)  
      {  
         int childpid;  
         int i;  

         if (fork() == 0){  
               //child process  
               char * execv_str[] = {"echo", "child process, executed by execv",NULL};  
               if (execv("/usr/bin/echo",execv_str) <0 ){  
                  perror("error on exec\n");  
                  exit(0);  
               }  
         }else{  
               //parent process  
               wait(&childpid);  
               printf("parent process, execv done\n");  
         }
         return 0;
      }  

2. `*` 擴展操作系統內核，能夠顯示操作系統切換進程的過程。

      體現調度的過程十分簡單，只需要在調度器部分，在尋找或運行下一任務的函數中加入一些輸出調試信息就可以看到效果了，但切換可能會比較頻繁，因此輸出會很多。

3. `*` 請閱讀下列代碼，分析程序的輸出 ``A`` 的數量：( 已知 ``&&`` 的優先級比 ``||`` 高)

    .. code-block:: c

      int main() {
          fork() && fork() && fork() || fork() && fork() || fork() && fork();
          printf("A");
          return 0;
      }

    如果給出一個 ``&&`` ``||`` 的序列，如何設計一個程序來得到答案？

    22個。&&優先級高於||，根據fork子進程返回值為0父進程返回pid和邏輯運算符的短路現象（&&左邊為F即短路，||左邊為T即短路），
    可以按||分割來進行判斷，共1+1*3+3*2+3*2*2=22.

      .. code-block:: python

        def count_fork(seq):
        counts = [1] +  [i.count("&&") + 1 for i in seq.split("||")]
        total = sum([np.prod(counts[:i + 1]) for i in range(len(counts))])
        return total

4. `**` 在本章操作系統中實現本章提出的某一種調度算法（RR調度除外）。

    先來先服務調度算法FCFS：它與 RR 調度的區別在於沒有時鐘中斷導致的任務切換，其他細節上相似。
    因此基於已有的 RR 調度，刪除對 Timer 中斷的相關處理即可得到一個 FCFS 調度。

    以 ucore 本章節代碼為例，一種處理方式是將 `trap.c` 的 `usertrap` 函數中 `case SupervisorTimer` 部分的 `yield();` 一句刪除
    即可去掉 RR 特性，得到一個 FCFS 調度。
    
    代碼略。

5. `***` 擴展操作系統內核，支持多核處理器。

    題目編程內容過於複雜，不建議作為練習題。
6. `***` 擴展操作系統內核，支持在內核態響應並處理中斷。

    題目編程內容過於複雜，不建議作為練習題。

 
問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 如何查看Linux操作系統中的進程？

      使用ps命令，常用方法：

      .. code-block:: bash

            $ ps aux
      
2. `*` 簡單描述一下進程的地址空間中有哪些數據和代碼。

      代碼(text)段，數據(data)段： 已初始化的全局變量的內存映射，bss段：未初始化或默認初始化為0的全局變量，堆(heap)，用戶棧(stack)，共享內存段

3. `*` 進程控制塊保存哪些內容？

      進程標識符、進程調度信息（進程狀態，進程的優先級，進程調度所需的其它信息）、進程間通信信息、內存管理信息（基地址、頁表或段表等存儲空間結構）、進程所用資源（ I/O 設備列表、打開文件列表等）、處理機信息（通用寄存器、指令計數器、用戶的棧指針）

4. `*` 進程上下文切換需要保存哪些內容？

      頁全局目錄、部分寄存器、內核棧、當前運行位置

5. `**` fork 為什麼需要在父進程和子進程提供不同的返回值？

      可以根據返回值區分父子進程，明確進程之間的關係，方便用戶為不同進程執行不同的操作。

6. `**` fork + exec 的一個比較大的問題是 fork 之後的內存頁/文件等資源完全沒有使用就廢棄了，針對這一點，有什麼改進策略？

      採用COW(copy on write),或使用使⽤vfork等。

7. `**` 其實使用了6的策略之後，fork + exec 所帶來的無效資源的問題已經基本被解決了，但是近年來fork 還是在被不斷的批判，那麼到底是什麼正在"殺死"fork？可以參考 `論文 <https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf>`_ 。

      fork 和其他的操作不正交,也就是 os 每增加一個功能,都要改 fork, 這導致新功能開發困難,設計受限.有些和硬件相關的甚至根本無法支持 fork.
      
      fork 得到的父子進程可能產生共享資源的衝突；
      
      子進程繼承父進程，如果父進程處理不當，子進程可以找到父進程的安全漏洞進而威脅父進程；
      
      還有比如 fork 必須要虛存, SAS 無法支持等等.

8. `**` 請閱讀下列代碼，並分析程序的輸出，假定不發生運行錯誤，不考慮行緩衝，不考慮中斷：

    .. code-block:: c

      int main(){
          int val = 2;

          printf("%d", 0);
          int pid = fork();
          if (pid == 0) {
              val++;
              printf("%d", val);
          } else {
              val--;
              printf("%d", val);
              wait(NULL);
          }
          val++;
          printf("%d", val);
          return 0;
      }


    如果 fork() 之後主程序先運行，則結果如何？如果 fork() 之後 child 先運行，則結果如何？

      01342  03412

9. `**` 為什麼子進程退出後需要父進程對它進行 wait，它才能被完全回收？

      當一個進程通過exit系統調用退出之後，它所佔用的資源並不能夠立即全部回收，需要由該進程的父進程通過wait收集該進程的返回狀態並回收掉它所佔據的全部資源，防止子進程變為殭屍進程造成內存洩漏。同時父進程通過wait可以獲取子進程執行結果，判斷運行是否達到預期，進行管理。

10. `**` 有哪些可能的時機導致進程切換？

      進程主動放棄cpu：運行結束、調用yield/sleep等、運行發生異常中斷

      進程被動失去cpu：時間片用完、新進程到達、發生I/O中斷等

11. `**` 請描述在本章操作系統中實現本章提出的某一種調度算法（RR調度除外）的簡要實現步驟。

      可降低優先級的MLFQ：將manager的進程就緒隊列變為數個，初始進程進入第一隊列，調度器每次選擇第一隊列的隊首進程執行，當一個進程用完時間片而未執行完，就在將它重新添加至就緒隊列時添加到下一隊列，直到進程位於底部隊列。

12. `*` 非搶佔式的調度算法，以及搶佔式的調度算法，他們的優點各是什麼？

      非搶佔式：中斷響應性能好、進程執行連續，便於分析管理

      搶佔式：任務級響應時間最優，更能滿足緊迫作業要求

13. `**` 假設我們簡單的將進程分為兩種：前臺交互（要求短時延）、後臺計算（計算量大）。下列進程/或進程組分別是前臺還是後臺？a) make 編譯 linux; b) vim 光標移動; c) firefox 下載影片; d) 某遊戲處理玩家點擊鼠標開槍; e) 播放交響樂歌曲; f) 轉碼一個電影視頻。除此以外，想想你日常應用程序的運行，它們哪些是前臺，哪些是後臺的？

      前臺：b,d,e

      後臺：a,c,f

14. `**` RR 算法的時間片長短對系統性能指標有什麼影響？

      時間片太大，可以讓每個任務都在時間片內完成，但進程平均週轉時間會比較長，極限情況下甚至退化為FCFS；

      時間片過小，反應迅速，響應時間會比較短，可以提高批量短任務的完成速度。但產生大量上下文切換開銷，使進程的實際執行時間受到擠佔。

      因此需要在響應時間和進程切換開銷之間進行權衡，合理設定時間片大小。

15. `**` MLFQ 算法並不公平，惡意的用戶程序可以愚弄 MLFQ 算法，大幅擠佔其他進程的時間。（MLFQ 的規則：“如果一個進程，時間片用完了它還在執行用戶計算，那麼 MLFQ 下調它的優先級”）你能舉出一個例子，使得你的用戶程序能夠擠佔其他進程的時間嗎？

      每次連續執行只進行大半個時間片長度即通過執行一個IO操作等讓出cpu，這樣優先級不會下降，仍能很快得到下一次調度。

16. `***` 多核執行和調度引入了哪些新的問題和挑戰？

      多處理機之間的負載不均問題：在調度時，如何保證每一個處理機的就緒隊列保證優先級、性能指標的同時負載均衡
    
      數據在不同處理機之間的共享與同步問題：除了Cache一致性的問題，在不同處理機上同時運行的進程可能對共享的數據區域產生相同的數據要求，這時就需要避免數據衝突，採用同步互斥機制處理資源競爭；
    
      線程化問題：如何將單個進程分為多線程放在多個處理機上
    
      Cache一致性問題：由於各個處理機有自己的私有Cache，需要保證不同處理機下的Cache之中的數據一致性

      處理器親和性問題：在單一處理機上運行的進程可以利用Cache實現內存訪問的優化與加速，這就需要我們規劃調度策略，儘量使一個進程在它前一次運行過的同一個CPU上運行，也即滿足處理器親和性。

      通信問題：類似同步問題，如何降低核間的通信代價
    
    
