# 執行一條 select 語句，期間發生了什麼？

大家好，我是小林。

學習 SQL 的時候，大家肯定第一個先學到的就是 select 查詢語句了，比如下面這句查詢語句：

```sql
// 在 product 表中，查詢 id = 1 的記錄
select * from product where id = 1;
```

但是有沒有想過，**MySQL 執行一條 select 查詢語句，在 MySQL 中期間發生了什麼？**

帶著這個問題，我們可以很好的瞭解 MySQL 內部的架構，所以這次小林就帶大家拆解一下 MySQL 內部的結構，看看內部裡的每一個“零件”具體是負責做什麼的。

## MySQL 執行流程是怎樣的？

先來一個上帝視角圖，下面就是 MySQL 執行一條 SQL 查詢語句的流程，也從圖中可以看到 MySQL 內部架構裡的各個功能模塊。

![查詢語句執行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/mysql查詢流程.png)

可以看到， MySQL 的架構共分為兩層：**Server 層和存儲引擎層**，

- **Server 層負責建立連接、分析和執行 SQL**。MySQL 大多數的核心功能模塊都在這實現，主要包括連接器，查詢緩存、解析器、預處理器、優化器、執行器等。另外，所有的內置函數（如日期、時間、數學和加密函數等）和所有跨存儲引擎的功能（如存儲過程、觸發器、視圖等。）都在 Server 層實現。
- **存儲引擎層負責數據的存儲和提取**。支持 InnoDB、MyISAM、Memory 等多個存儲引擎，不同的存儲引擎共用一個 Server 層。現在最常用的存儲引擎是 InnoDB，從 MySQL 5.5 版本開始， InnoDB 成為了 MySQL 的默認存儲引擎。我們常說的索引數據結構，就是由存儲引擎層實現的，不同的存儲引擎支持的索引類型也不相同，比如 InnoDB 支持索引類型是 B+樹 ，且是默認使用，也就是說在數據表中創建的主鍵索引和二級索引默認使用的是 B+ 樹索引。

好了，現在我們對 Server 層和存儲引擎層有了一個簡單認識，接下來，就詳細說一條 SQL 查詢語句的執行流程，依次看看每一個功能模塊的作用。

## 第一步：連接器

如果你在 Linux 操作系統裡要使用 MySQL，那你第一步肯定是要先連接 MySQL 服務，然後才能執行 SQL 語句，普遍我們都是使用下面這條命令進行連接：

```shell
# -h 指定 MySQL 服務得 IP 地址，如果是連接本地的 MySQL服務，可以不用這個參數；
# -u 指定用戶名，管理員角色名為 root；
# -p 指定密碼，如果命令行中不填寫密碼（為了密碼安全，建議不要在命令行寫密碼），就需要在交互對話裡面輸入密碼
mysql -h$ip -u$user -p
```

連接的過程需要先經過 TCP 三次握手，因為 MySQL 是基於 TCP 協議進行傳輸的，如果 MySQL 服務並沒有啟動，則會收到如下的報錯：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/mysql連接錯誤.png)

如果  MySQL 服務正常運行，完成 TCP 連接的建立後，連接器就要開始驗證你的用戶名和密碼，如果用戶名或密碼不對，就收到一個"Access denied for user"的錯誤，然後客戶端程序結束執行。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/密碼錯誤.png)

如果用戶密碼都沒有問題，連接器就會獲取該用戶的權限，然後保存起來，後續該用戶在此連接裡的任何操作，都會基於連接開始時讀到的權限進行權限邏輯的判斷。

所以，如果一個用戶已經建立了連接，即使管理員中途修改了該用戶的權限，也不會影響已經存在連接的權限。修改完成後，只有再新建的連接才會使用新的權限設置。

> 如何查看 MySQL 服務被多少個客戶端連接了？

如果你想知道當前  MySQL 服務被多少個客戶端連接了，你可以執行 `show processlist` 命令進行查看。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/查看連接.png)

比如上圖的顯示結果，共有兩個用戶名為 root 的用戶連接了 MySQL 服務，其中 id 為 6 的用戶的 Command 列的狀態為 `Sleep` ，這意味著該用戶連接完 MySQL 服務就沒有再執行過任何命令，也就是說這是一個空閒的連接，並且空閒的時長是 736 秒（ Time 列）。

> 空閒連接會一直佔用著嗎？

當然不是了，MySQL 定義了空閒連接的最大空閒時長，由 `wait_timeout` 參數控制的，默認值是 8 小時（28880秒），如果空閒連接超過了這個時間，連接器就會自動將它斷開。

```sql
mysql> show variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```

當然，我們自己也可以手動斷開空閒的連接，使用的是 kill connection + id 的命令。

```sql
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```

一個處於空閒狀態的連接被服務端主動斷開後，這個客戶端並不會馬上知道，等到客戶端在發起下一個請求的時候，才會收到這樣的報錯“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

> MySQL 的連接數有限制嗎？

MySQL 服務支持的最大連接數由 max_connections 參數控制，比如我的 MySQL 服務默認是 151 個,超過這個值，系統就會拒絕接下來的連接請求，並報錯提示“Too many connections”。

```sql
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

MySQL 的連接也跟 HTTP 一樣，有短連接和長連接的概念，它們的區別如下：

```c
// 短連接
連接 mysql 服務（TCP 三次握手）
執行sql
斷開 mysql 服務（TCP 四次揮手）

// 長連接
連接 mysql 服務（TCP 三次握手）
執行sql
執行sql
執行sql
....
斷開 mysql 服務（TCP 四次揮手）
```

可以看到，使用長連接的好處就是可以減少建立連接和斷開連接的過程，所以一般是推薦使用長連接。

但是，使用長連接後可能會佔用內存增多，因為 MySQL 在執行查詢過程中臨時使用內存管理連接對象，這些連接對象資源只有在連接斷開時才會釋放。如果長連接累計很多，將導致 MySQL 服務佔用內存太大，有可能會被系統強制殺掉，這樣會發生 MySQL 服務異常重啟的現象。

> 怎麼解決長連接佔用內存的問題？

有兩種解決方式。

第一種，**定期斷開長連接**。既然斷開連接後就會釋放連接佔用的內存資源，那麼我們可以定期斷開長連接。

第二種，**客戶端主動重置連接**。MySQL 5.7 版本實現了 `mysql_reset_connection()` 函數的接口，注意這是接口函數不是命令，那麼當客戶端執行了一個很大的操作後，在代碼裡調用 mysql_reset_connection 函數來重置連接，達到釋放內存的效果。這個過程不需要重連和重新做權限驗證，但是會將連接恢復到剛剛創建完時的狀態。

至此，連接器的工作做完了，簡單總結一下：

- 與客戶端進行 TCP 三次握手建立連接；
- 校驗客戶端的用戶名和密碼，如果用戶名或密碼不對，則會報錯；
- 如果用戶名和密碼都對了，會讀取該用戶的權限，然後後面的權限邏輯判斷都基於此時讀取到的權限；

## 第二步：查詢緩存

連接器得工作完成後，客戶端就可以向 MySQL 服務發送 SQL 語句了，MySQL 服務收到 SQL 語句後，就會解析出 SQL 語句的第一個字段，看看是什麼類型的語句。

如果 SQL 是查詢語句（select 語句），MySQL 就會先去查詢緩存（ Query Cache ）裡查找緩存數據，看看之前有沒有執行過這一條命令，這個查詢緩存是以 key-value 形式保存在內存中的，key 為 SQL 查詢語句，value 為 SQL 語句查詢的結果。

如果查詢的語句命中查詢緩存，那麼就會直接返回 value 給客戶端。如果查詢的語句沒有命中查詢緩存中，那麼就要往下繼續執行，等執行完後，查詢的結果就會被存入查詢緩存中。

這麼看，查詢緩存還挺有用，但是其實**查詢緩存挺雞肋**的。

對於更新比較頻繁的表，查詢緩存的命中率很低的，因為只要一個表有更新操作，那麼這個表的查詢緩存就會被清空。如果剛緩存了一個查詢結果很大的數據，還沒被使用的時候，剛好這個表有更新操作，查詢緩衝就被清空了，相當於緩存了個寂寞。

所以，MySQL 8.0 版本直接將查詢緩存刪掉了，也就是說 MySQL 8.0 開始，執行一條 SQL 查詢語句，不會再走到查詢緩存這個階段了。

對於 MySQL 8.0 之前的版本，如果想關閉查詢緩存，我們可以通過將參數 query_cache_type 設置成 DEMAND。

::: tip

這裡說的查詢緩存是 server 層的，也就是 MySQL 8.0 版本移除的是 server 層的查詢緩存，並不是 Innodb 存儲引擎中的 buffer pool。

::::

## 第三步：解析 SQL

在正式執行 SQL 查詢語句之前， MySQL 會先對 SQL 語句做解析，這個工作交由「解析器」來完成。

### 解析器

解析器會做如下兩件事情。

第一件事情，**詞法分析**。MySQL 會根據你輸入的字符串識別出關鍵字出來，構建出 SQL 語法樹，這樣方便後面模塊獲取 SQL 類型、表名、字段名、 where 條件等等。

第二件事情，**語法分析**。根據詞法分析的結果，語法解析器會根據語法規則，判斷你輸入的這個 SQL 語句是否滿足 MySQL 語法。

如果我們輸入的 SQL 語句語法不對，就會在解析器這個階段報錯。比如，我下面這條查詢語句，把 from 寫成了 form，這時 MySQL 解析器就會給報錯。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/語法錯誤.png)

但是注意，表不存在或者字段不存在，並不是在解析器裡做的，《MySQL 45 講》說是在解析器做的，但是經過我和朋友看 MySQL 源碼（5.7和8.0）得出結論是解析器只負責構建語法樹和檢查語法，但是不會去查表或者字段存不存在。

那到底誰來做檢測表和字段是否存在的工作呢？別急，接下來就是了。

## 第四步：執行 SQL

經過解析器後，接著就要進入執行 SQL 查詢語句的流程了，每條`SELECT` 查詢語句流程主要可以分為下面這三個階段：

- prepare 階段，也就是預處理階段；
- optimize 階段，也就是優化階段；
- execute 階段，也就是執行階段；

### 預處理器

我們先來說說預處理階段做了什麼事情。

- 檢查 SQL 查詢語句中的表或者字段是否存在；
- 將 `select *` 中的 `*` 符號，擴展為表上的所有列；

我下面這條查詢語句，test 這張表是不存在的，這時 MySQL 就會在執行 SQL 查詢語句的 prepare 階段中報錯。

```sql
mysql> select * from test;
ERROR 1146 (42S02): Table 'mysql.test' doesn't exist
```

這裡貼個 MySQL 8.0 源碼來證明表或字段是否存在的判斷，不是在解析器裡做的，而是在 prepare 階段。（*PS：下圖是公眾號「一樹一溪」老哥幫我分析的，這位老哥專門寫 MySQL 源碼文章，感興趣的朋友，可以微信搜索關注*）

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/表不存在.jpeg)

上面的中間部分是 MySQL 報錯表不存在時的函數調用棧，可以看到表不存在的錯誤是在get_table_share()  函數裡報錯的，而這個函數是在 prepare 階段調用的。

不過，對於  MySQL 5.7 判斷表或字段是否存在的工作，是在詞法分析&語法分析之後，prepare 階段之前做的。結論都一樣，不是在解析器裡做的。代碼我就不放了，正因為   MySQL 5.7  代碼結構不好，所以 MySQL 8.0 代碼結構變化很大，後來判斷表或字段是否存在的工作就被放入到 prepare 階段做了。

### 優化器

經過預處理階段後，還需要為 SQL 查詢語句先制定一個執行計劃，這個工作交由「優化器」來完成的。

**優化器主要負責將 SQL 查詢語句的執行方案確定下來**，比如在表裡面有多個索引的時候，優化器會基於查詢成本的考慮，來決定選擇使用哪個索引。

當然，我們本次的查詢語句（select * from product where id = 1）很簡單，就是選擇使用主鍵索引。

要想知道優化器選擇了哪個索引，我們可以在查詢語句最前面加個 `explain` 命令，這樣就會輸出這條 SQL 語句的執行計劃，然後執行計劃中的 key 就表示執行過程中使用了哪個索引，比如下圖的 key 為 `PRIMARY` 就是使用了主鍵索引。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/執行計劃.png)

如果查詢語句的執行計劃裡的 key 為 null 說明沒有使用索引，那就會全表掃描（type = ALL），這種查詢掃描的方式是效率最低檔次的，如下圖：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/全表掃描.png)

這張 product 表只有一個索引就是主鍵，現在我在表中將 name 設置為普通索引（二級索引）。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/產品表.png)

這時 product 表就有主鍵索引（id）和普通索引（name）。假設執行了這條查詢語句：

```sql
select id from product where id > 1  and name like 'i%';
```

這條查詢語句的結果既可以使用主鍵索引，也可以使用普通索引，但是執行的效率會不同。這時，就需要優化器來決定使用哪個索引了。

很顯然這條查詢語句是**覆蓋索引**，直接在二級索引就能查找到結果（因為二級索引的 B+ 樹的葉子節點的數據存儲的是主鍵值），就沒必要在主鍵索引查找了，因為查詢主鍵索引的 B+ 樹的成本會比查詢二級索引的 B+ 的成本大，優化器基於查詢成本的考慮，會選擇查詢代價小的普通索引。

在下圖中執行計劃，我們可以看到，執行過程中使用了普通索引（name），Exta 為 Using index，這就是表明使用了覆蓋索引優化。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/選擇索引.png)

### 執行器

經歷完優化器後，就確定了執行方案，接下來 MySQL 就真正開始執行語句了，這個工作是由「執行器」完成的。在執行的過程中，執行器就會和存儲引擎交互了，交互是以記錄為單位的。

接下來，用三種方式執行過程，跟大家說一下執行器和存儲引擎的交互過程（PS ：為了寫好這一部分，特地去看 MySQL 源碼，也是第一次看哈哈）。

- 主鍵索引查詢
- 全表掃描
- 索引下推

#### 主鍵索引查詢

以本文開頭查詢語句為例，看看執行器是怎麼工作的。

```sql
select * from product where id = 1;
```

這條查詢語句的查詢條件用到了主鍵索引，而且是等值查詢，同時主鍵 id 是唯一，不會有 id 相同的記錄，所以優化器決定選用訪問類型為 const 進行查詢，也就是使用主鍵索引查詢一條記錄，那麼執行器與存儲引擎的執行流程是這樣的：

- 執行器第一次查詢，會調用 read_first_record 函數指針指向的函數，因為優化器選擇的訪問類型為 const，這個函數指針被指向為 InnoDB 引擎索引查詢的接口，把條件 `id = 1` 交給存儲引擎，**讓存儲引擎定位符合條件的第一條記錄**。
- 存儲引擎通過主鍵索引的 B+ 樹結構定位到 id = 1的第一條記錄，如果記錄是不存在的，就會向執行器上報記錄找不到的錯誤，然後查詢結束。如果記錄是存在的，就會將記錄返回給執行器；
- 執行器從存儲引擎讀到記錄後，接著判斷記錄是否符合查詢條件，如果符合則發送給客戶端，如果不符合則跳過該記錄。
- 執行器查詢的過程是一個 while 循環，所以還會再查一次，但是這次因為不是第一次查詢了，所以會調用 read_record 函數指針指向的函數，因為優化器選擇的訪問類型為 const，這個函數指針被指向為一個永遠返回 - 1 的函數，所以當調用該函數的時候，執行器就退出循環，也就是結束查詢了。

至此，這個語句就執行完成了。

#### 全表掃描

舉個全表掃描的例子：

```
select * from product where name = 'iphone';
```

這條查詢語句的查詢條件沒有用到索引，所以優化器決定選用訪問類型為 ALL 進行查詢，也就是全表掃描的方式查詢，那麼這時執行器與存儲引擎的執行流程是這樣的：

- 執行器第一次查詢，會調用 read_first_record 函數指針指向的函數，因為優化器選擇的訪問類型為 all，這個函數指針被指向為 InnoDB 引擎全掃描的接口，**讓存儲引擎讀取表中的第一條記錄**；
- 執行器會判斷讀到的這條記錄的 name 是不是 iphone，如果不是則跳過；如果是則將記錄發給客戶端（是的沒錯，Server 層每從存儲引擎讀到一條記錄就會發送給客戶端，之所以客戶端顯示的時候是直接顯示所有記錄的，是因為客戶端是等查詢語句查詢完成後，才會顯示出所有的記錄）。
- 執行器查詢的過程是一個 while 循環，所以還會再查一次，會調用 read_record 函數指針指向的函數，因為優化器選擇的訪問類型為 all，read_record 函數指針指向的還是 InnoDB 引擎全掃描的接口，所以接著向存儲引擎層要求繼續讀剛才那條記錄的下一條記錄，存儲引擎把下一條記錄取出後就將其返回給執行器（Server層），執行器繼續判斷條件，不符合查詢條件即跳過該記錄，否則發送到客戶端；
- 一直重複上述過程，直到存儲引擎把表中的所有記錄讀完，然後向執行器（Server層） 返回了讀取完畢的信息；
- 執行器收到存儲引擎報告的查詢完畢的信息，退出循環，停止查詢。

至此，這個語句就執行完成了。

#### 索引下推

在這部分非常適合講索引下推（MySQL 5.6 推出的查詢優化策略），這樣大家能清楚的知道，「下推」這個動作，下推到了哪裡。

索引下推能夠減少**二級索引**在查詢時的回表操作，提高查詢的效率，因為它將 Server 層部分負責的事情，交給存儲引擎層去處理了。

舉一個具體的例子，方便大家理解，這裡一張用戶表如下，我對 age 和 reward 字段建立了聯合索引（age，reward）：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/路飛表.png)

現在有下面這條查詢語句：

```sql
select * from t_user  where age > 20 and reward = 100000;
```

聯合索引當遇到範圍查詢 (>、<) 就會停止匹配，也就是 **age 字段能用到聯合索引，但是 reward 字段則無法利用到索引**。具體原因這裡可以看這篇：[索引常見面試題](https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB)

那麼，不使用索引下推（MySQL 5.6 之前的版本）時，執行器與存儲引擎的執行流程是這樣的：

- Server 層首先調用存儲引擎的接口定位到滿足查詢條件的第一條二級索引記錄，也就是定位到 age > 20 的第一條記錄；
- 存儲引擎根據二級索引的 B+ 樹快速定位到這條記錄後，獲取主鍵值，然後**進行回表操作**，將完整的記錄返回給 Server 層；
- Server 層在判斷該記錄的 reward 是否等於 100000，如果成立則將其發送給客戶端；否則跳過該記錄；
- 接著，繼續向存儲引擎索要下一條記錄，存儲引擎在二級索引定位到記錄後，獲取主鍵值，然後回表操作，將完整的記錄返回給 Server 層；
- 如此往復，直到存儲引擎把表中的所有記錄讀完。

可以看到，沒有索引下推的時候，每查詢到一條二級索引記錄，都要進行回表操作，然後將記錄返回給 Server，接著 Server 再判斷該記錄的 reward 是否等於 100000。

而使用索引下推後，判斷記錄的 reward 是否等於 100000 的工作交給了存儲引擎層，過程如下 ：

- Server 層首先調用存儲引擎的接口定位到滿足查詢條件的第一條二級索引記錄，也就是定位到 age > 20 的第一條記錄；
- 存儲引擎定位到二級索引後，**先不執行回表**操作，而是先判斷一下該索引中包含的列（reward列）的條件（reward 是否等於 100000）是否成立。如果**條件不成立**，則直接**跳過該二級索引**。如果**成立**，則**執行回表**操作，將完成記錄返回給 Server 層。
- Server 層在判斷其他的查詢條件（本次查詢沒有其他條件）是否成立，如果成立則將其發送給客戶端；否則跳過該記錄，然後向存儲引擎索要下一條記錄。
- 如此往復，直到存儲引擎把表中的所有記錄讀完。

可以看到，使用了索引下推後，雖然 reward 列無法使用到聯合索引，但是因為它包含在聯合索引（age，reward）裡，所以直接在存儲引擎過濾出滿足  reward = 100000 的記錄後，才去執行回表操作獲取整個記錄。相比於沒有使用索引下推，節省了很多回表操作。

當你發現執行計劃裡的 Extr 部分顯示了 “Using index condition”，說明使用了索引下推。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/索引下推執行計劃.png)

---

## 總結

執行一條 SQL 查詢語句，期間發生了什麼？

- 連接器：建立連接，管理連接、校驗用戶身份；
- 查詢緩存：查詢語句如果命中查詢緩存則直接返回，否則繼續往下執行。MySQL 8.0 已刪除該模塊；
- 解析 SQL，通過解析器對 SQL 查詢語句進行詞法分析、語法分析，然後構建語法樹，方便後續模塊讀取表名、字段、語句類型；
- 執行 SQL：執行 SQL 共有三個階段：
  - 預處理階段：檢查表或字段是否存在；將 `select *` 中的 `*` 符號擴展為表上的所有列。
  - 優化階段：基於查詢成本的考慮， 選擇查詢成本最小的執行計劃；
  - 執行階段：根據執行計劃執行  SQL 查詢語句，從存儲引擎讀取記錄，返回給客戶端；

怎麼樣？現在再看這張圖，是不是很清晰了。

![查詢語句執行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql執行過程/mysql查詢流程.png)

完！

----

參考資料：

- 《MySQL 45 講》
- 《MySQL是怎樣運行的：從根兒上理解MySQL》
- https://gohalo.me/post/mysql-executor.html
- http://www.iskm.org/mysql56/sql__executor_8cc_source.html
- https://tangocc.github.io/2018/10/11/mysql-sourcecode/

---

最新的圖解文章都在公眾號首發，別忘記關注哦！！如果你想加入百人技術交流群，掃碼下方二維碼回覆「加群」。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)