# 2.1 CPU 是如何執行程序的？

代碼寫了那麼多，你知道 `a = 1 + 2` 這條代碼是怎麼被 CPU 執行的嗎？

軟件用了那麼多，你知道軟件的 32 位和 64 位之間的區別嗎？再來 32 位的操作系統可以運行在 64 位的電腦上嗎？64 位的操作系統可以運行在 32 位的電腦上嗎？如果不行，原因是什麼？

CPU 看了那麼多，我們都知道 CPU 通常分為 32 位和 64 位，你知道 64 位相比 32 位 CPU 的優勢在哪嗎？64 位 CPU 的計算性能一定比 32 位 CPU 高很多嗎？

不知道也不用慌張，接下來就循序漸進的、一層一層的攻破這些問題。


![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/程序執行提綱.png)

---

## 圖靈機的工作方式

要想知道程序執行的原理，我們可以先從「圖靈機」說起，圖靈的基本思想是用機器來模擬人們用紙筆進行數學運算的過程，而且還定義了計算機由哪些部分組成，程序又是如何執行的。

圖靈機長什麼樣子呢？你從下圖可以看到圖靈機的實際樣子：


![圖來源自：http://www.kristergustafsson.me/turing-machine/](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/Turing%2Bmachine%2B1.jpeg)

圖靈機的基本組成如下：

- 有一條「紙帶」，紙帶由一個個連續的格子組成，每個格子可以寫入字符，紙帶就好比內存，而紙帶上的格子的字符就好比內存中的數據或程序；
- 有一個「讀寫頭」，讀寫頭可以讀取紙帶上任意格子的字符，也可以把字符寫入到紙帶的格子；
- 讀寫頭上有一些部件，比如存儲單元、控制單元以及運算單元：
  1、存儲單元用於存放數據；
  2、控制單元用於識別字符是數據還是指令，以及控制程序的流程等；
  3、運算單元用於執行運算指令；

知道了圖靈機的組成後，我們以簡單數學運算的 `1 + 2` 作為例子，來看看它是怎麼執行這行代碼的。

- 首先，用讀寫頭把 「1、2、+」這 3 個字符分別寫入到紙帶上的 3 個格子，然後讀寫頭先停在 1 字符對應的格子上；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/圖靈機-第一步.png)


- 接著，讀寫頭讀入 1 到存儲設備中，這個存儲設備稱為圖靈機的狀態；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/圖靈機-第二步.png)

- 然後讀寫頭向右移動一個格，用同樣的方式把 2 讀入到圖靈機的狀態，於是現在圖靈機的狀態中存儲著兩個連續的數字， 1 和 2；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/圖靈機-第三步.png)

- 讀寫頭再往右移動一個格，就會碰到 + 號，讀寫頭讀到 + 號後，將 + 號傳輸給「控制單元」，控制單元發現是一個 + 號而不是數字，所以沒有存入到狀態中，因為 `+` 號是運算符指令，作用是加和目前的狀態，於是通知「運算單元」工作。運算單元收到要加和狀態中的值的通知後，就會把狀態中的 1 和 2 讀入並計算，再將計算的結果 3 存放到狀態中；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/圖靈機-第四步.png)


- 最後，運算單元將結果返回給控制單元，控制單元將結果傳輸給讀寫頭，讀寫頭向右移動，把結果 3 寫入到紙帶的格子中；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/圖靈機-第五步.png)


通過上面的圖靈機計算 `1 + 2`  的過程，可以發現圖靈機主要功能就是讀取紙帶格子中的內容，然後交給控制單元識別字符是數字還是運算符指令，如果是數字則存入到圖靈機狀態中，如果是運算符，則通知運算符單元讀取狀態中的數值進行計算，計算結果最終返回給讀寫頭，讀寫頭把結果寫入到紙帶的格子中。

事實上，圖靈機這個看起來很簡單的工作方式，和我們今天的計算機是基本一樣的。接下來，我們一同再看看當今計算機的組成以及工作方式。


---

## 馮諾依曼模型

在 1945 年馮諾依曼和其他計算機科學家們提出了計算機具體實現的報告，其遵循了圖靈機的設計，而且還提出用電子元件構造計算機，並約定了用二進制進行計算和存儲。

最重要的是定義計算機基本結構為 5 個部分，分別是**運算器、控制器、存儲器、輸入設備、輸出設備**，這 5 個部分也被稱為**馮諾依曼模型**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/操作系統/Von_Neumann_architecture.svg)

運算器、控制器是在中央處理器裡的，存儲器就我們常見的內存，輸入輸出設備則是計算機外接的設備，比如鍵盤就是輸入設備，顯示器就是輸出設備。

存儲單元和輸入輸出設備要與中央處理器打交道的話，離不開總線。所以，它們之間的關係如下圖：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/馮諾依曼模型.png)

接下來，分別介紹內存、中央處理器、總線、輸入輸出設備。

### 內存

我們的程序和數據都是存儲在內存，存儲的區域是線性的。

在計算機數據存儲中，存儲數據的基本單位是**字節（*byte*）**，1 字節等於 8 位（8 bit）。每一個字節都對應一個內存地址。

內存的地址是從 0 開始編號的，然後自增排列，最後一個地址為內存總字節數 - 1，這種結構好似我們程序裡的數組，所以內存的讀寫任何一個數據的速度都是一樣的。


### 中央處理器

中央處理器也就是我們常說的 CPU，32 位和 64 位 CPU 最主要區別在於一次能計算多少字節數據：

- 32 位 CPU 一次可以計算 4 個字節；
- 64 位 CPU 一次可以計算 8 個字節；

這裡的 32 位和 64 位，通常稱為 CPU 的位寬。

之所以 CPU 要這樣設計，是為了能計算更大的數值，如果是 8 位的 CPU，那麼一次只能計算 1 個字節 `0~255` 範圍內的數值，這樣就無法一次完成計算 `10000 * 500` ，於是為了能一次計算大數的運算，CPU 需要支持多個 byte 一起計算，所以 CPU 位寬越大，可以計算的數值就越大，比如說 32 位 CPU 能計算的最大整數是 `4294967295`。

CPU 內部還有一些組件，常見的有**寄存器、控制單元和邏輯運算單元**等。其中，控制單元負責控制 CPU 工作，邏輯運算單元負責計算，而寄存器可以分為多種類，每種寄存器的功能又不盡相同。

CPU 中的寄存器主要作用是存儲計算時的數據，你可能好奇為什麼有了內存還需要寄存器？原因很簡單，因為內存離 CPU 太遠了，而寄存器就在 CPU 裡，還緊挨著控制單元和邏輯運算單元，自然計算時速度會很快。

常見的寄存器種類：

- *通用寄存器*，用來存放需要進行運算的數據，比如需要進行加和運算的兩個數據。
- *程序計數器*，用來存儲 CPU 要執行下一條指令「所在的內存地址」，注意不是存儲了下一條要執行的指令，此時指令還在內存中，程序計數器只是存儲了下一條指令「的地址」。
- *指令寄存器*，用來存放當前正在執行的指令，也就是指令本身，指令被執行完成之前，指令都存儲在這裡。


### 總線

總線是用於 CPU 和內存以及其他設備之間的通信，總線可分為 3 種：

- *地址總線*，用於指定 CPU 將要操作的內存地址；
- *數據總線*，用於讀寫內存的數據；
- *控制總線*，用於發送和接收信號，比如中斷、設備復位等信號，CPU 收到信號後自然進行響應，這時也需要控制總線；

當 CPU 要讀寫內存數據的時候，一般需要通過下面這三個總線：

- 首先要通過「地址總線」來指定內存的地址；
- 然後通過「控制總線」控制是讀或寫命令；
- 最後通過「數據總線」來傳輸數據；

### 輸入、輸出設備

輸入設備向計算機輸入數據，計算機經過計算後，把數據輸出給輸出設備。期間，如果輸入設備是鍵盤，按下按鍵時是需要和 CPU 進行交互的，這時就需要用到控制總線了。


---

## 線路位寬與 CPU 位寬


數據是如何通過線路傳輸的呢？其實是通過操作電壓，低電壓表示 0，高壓電壓則表示 1。

如果構造了高低高這樣的信號，其實就是 101 二進制數據，十進制則表示 5，如果只有一條線路，就意味著每次只能傳遞 1 bit 的數據，即 0 或 1，那麼傳輸 101 這個數據，就需要 3 次才能傳輸完成，這樣的效率非常低。


這樣一位一位傳輸的方式，稱為串行，下一個 bit 必須等待上一個 bit 傳輸完成才能進行傳輸。當然，想一次多傳一些數據，增加線路即可，這時數據就可以並行傳輸。

為了避免低效率的串行傳輸的方式，線路的位寬最好一次就能訪問到所有的內存地址。 

CPU 要想操作的內存地址就需要地址總線：

- 如果地址總線只有 1 條，那每次只能表示 「0 或 1」這兩種地址，所以 CPU 能操作的內存地址最大數量為 2（2^1）個（注意，不要理解成同時能操作 2 個內存地址）；
- 如果地址總線有 2 條，那麼能表示 00、01、10、11 這四種地址，所以 CPU 能操作的內存地址最大數量為 4（2^2）個。

那麼，想要 CPU 操作 4G 大的內存，那麼就需要 32 條地址總線，因為 `2 ^ 32 = 4G`。

知道了線路位寬的意義後，我們再來看看 CPU 位寬。

CPU 的位寬最好不要小於線路位寬，比如 32 位 CPU 控制 40 位寬的地址總線和數據總線的話，工作起來就會非常複雜且麻煩，所以 32 位的 CPU 最好和 32 位寬的線路搭配，因為 32 位 CPU 一次最多隻能操作 32 位寬的地址總線和數據總線。

如果用 32 位 CPU 去加和兩個 64 位大小的數字，就需要把這 2 個 64 位的數字分成 2 個低位 32 位數字和 2 個高位 32 位數字來計算，先加個兩個低位的 32 位數字，算出進位，然後加和兩個高位的 32 位數字，最後再加上進位，就能算出結果了，可以發現 32 位 CPU 並不能一次性計算出加和兩個 64 位數字的結果。

對於 64 位 CPU 就可以一次性算出加和兩個 64 位數字的結果，因為 64 位 CPU 可以一次讀入 64 位的數字，並且 64 位 CPU 內部的邏輯運算單元也支持 64 位數字的計算。

但是並不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少應用需要算超過 32 位的數字，所以**如果計算的數額不超過 32 位數字的情況下，32 位和 64 位 CPU 之間沒什麼區別的，只有當計算超過 32 位數字的情況下，64 位的優勢才能體現出來**。

另外，32 位 CPU 最大隻能操作 4GB 內存，就算你裝了 8 GB 內存條，也沒用。而 64 位 CPU 尋址範圍則很大，理論最大的尋址空間為 `2^64`。


---

## 程序執行的基本過程

在前面，我們知道了程序在圖靈機的執行過程，接下來我們來看看程序在馮諾依曼模型上是怎麼執行的。


程序實際上是一條一條指令，所以程序的運行過程就是把每一條指令一步一步的執行起來，負責執行指令的就是 CPU 了。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/CPU執行程序.png)

那 CPU 執行程序的過程如下：

- 第一步，CPU 讀取「程序計數器」的值，這個值是指令的內存地址，然後 CPU 的「控制單元」操作「地址總線」指定需要訪問的內存地址，接著通知內存設備準備數據，數據準備好後通過「數據總線」將指令數據傳給 CPU，CPU 收到內存傳來的數據後，將這個指令數據存入到「指令寄存器」。
- 第二步，「程序計數器」的值自增，表示指向下一條指令。這個自增的大小，由 CPU 的位寬決定，比如 32 位的 CPU，指令是 4 個字節，需要 4 個內存地址存放，因此「程序計數器」的值會自增 4；
- 第三步，CPU 分析「指令寄存器」中的指令，確定指令的類型和參數，如果是計算類型的指令，就把指令交給「邏輯運算單元」運算；如果是存儲類型的指令，則交由「控制單元」執行；

簡單總結一下就是，一個程序執行的時候，CPU 會根據程序計數器裡的內存地址，從內存裡面把需要執行的指令讀取到指令寄存器裡面執行，然後根據指令長度自增，開始順序讀取下一條指令。

CPU 從程序計數器讀取指令、到執行、再到下一條指令，這個過程會不斷循環，直到程序執行結束，這個不斷循環的過程被稱為 **CPU 的指令週期**。

---

## a = 1 + 2 執行具體過程

知道了基本的程序執行過程後，接下來用 `a = 1 + 2` 的作為例子，進一步分析該程序在馮諾伊曼模型的執行過程。

CPU 是不認識 `a = 1 + 2` 這個字符串，這些字符串只是方便我們程序員認識，要想這段程序能跑起來，還需要把整個程序翻譯成**彙編語言**的程序，這個過程稱為編譯成彙編代碼。

針對彙編代碼，我們還需要用匯編器翻譯成機器碼，這些機器碼由 0 和 1 組成的機器語言，這一條條機器碼，就是一條條的**計算機指令**，這個才是 CPU 能夠真正認識的東西。

下面來看看  `a = 1 + 2` 在 32 位 CPU 的執行過程。

程序編譯過程中，編譯器通過分析代碼，發現 1 和 2 是數據，於是程序運行時，內存會有個專門的區域來存放這些數據，這個區域就是「數據段」。如下圖，數據 1 和 2 的區域位置：

- 數據 1 被存放到 0x200 位置；
- 數據 2 被存放到 0x204 位置；

注意，數據和指令是分開區域存放的，存放指令區域的地方稱為「正文段」。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/數據段與正文段.png)

編譯器會把 `a = 1 + 2` 翻譯成 4 條指令，存放到正文段中。如圖，這 4 條指令被存放到了 0x100 ~ 0x10c 的區域中： 

- 0x100 的內容是 `load` 指令將 0x200 地址中的數據 1 裝入到寄存器 `R0`；
- 0x104 的內容是 `load` 指令將 0x204 地址中的數據 2 裝入到寄存器 `R1`；
- 0x108 的內容是 `add` 指令將寄存器 `R0` 和 `R1` 的數據相加，並把結果存放到寄存器 `R2`；
- 0x10c 的內容是 `store` 指令將寄存器 `R2` 中的數據存回數據段中的 0x208 地址中，這個地址也就是變量 `a` 內存中的地址；

編譯完成後，具體執行程序的時候，程序計數器會被設置為 0x100 地址，然後依次執行這 4 條指令。

上面的例子中，由於是在 32 位 CPU 執行的，因此一條指令是佔 32 位大小，所以你會發現每條指令間隔 4 個字節。

而數據的大小是根據你在程序中指定的變量類型，比如 `int` 類型的數據則佔 4 個字節，`char` 類型的數據則佔 1 個字節。

### 指令

上面的例子中，圖中指令的內容我寫的是簡易的彙編代碼，目的是為了方便理解指令的具體內容，事實上指令的內容是一串二進制數字的機器碼，每條指令都有對應的機器碼，CPU 通過解析機器碼來知道指令的內容。

不同的 CPU 有不同的指令集，也就是對應著不同的彙編語言和不同的機器碼，接下來選用最簡單的 MIPS 指集，來看看機器碼是如何生成的，這樣也能明白二進制的機器碼的具體含義。

MIPS 的指令是一個 32 位的整數，高 6 位代表著操作碼，表示這條指令是一條什麼樣的指令，剩下的 26 位不同指令類型所表示的內容也就不相同，主要有三種類型R、I 和 J。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/MIPS指令集.png)

一起具體看看這三種類型的含義：

- *R 指令*，用在算術和邏輯操作，裡面有讀取和寫入數據的寄存器地址。如果是邏輯位移操作，後面還有位移操作的「位移量」，而最後的「功能碼」則是再前面的操作碼不夠的時候，擴展操作碼來表示對應的具體指令的；
- *I 指令*，用在數據傳輸、條件分支等。這個類型的指令，就沒有了位移量和功能碼，也沒有了第三個寄存器，而是把這三部分直接合併成了一個地址值或一個常數；
- *J 指令*，用在跳轉，高 6 位之外的 26 位都是一個跳轉後的地址；

接下來，我們把前面例子的這條指令：「`add` 指令將寄存器 `R0` 和 `R1` 的數據相加，並把結果放入到 `R2`」，翻譯成機器碼。


![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/add的MIPS指令.png)

加和運算 add 指令是屬於 R 指令類型：

- add 對應的 MIPS 指令裡操作碼是 `000000`，以及最末尾的功能碼是 `100000`，這些數值都是固定的，查一下 MIPS 指令集的手冊就能知道的；
- rs 代表第一個寄存器 R0 的編號，即 `00000`；
- rt 代表第二個寄存器 R1 的編號，即 `00001`；
- rd 代表目標的臨時寄存器 R2 的編號，即 `00010`；
- 因為不是位移操作，所以位移量是 `00000`

把上面這些數字拼在一起就是一條 32 位的 MIPS 加法指令了，那麼用 16 進製表示的機器碼則是 `0x00011020`。

編譯器在編譯程序的時候，會構造指令，這個過程叫做指令的編碼。CPU 執行程序的時候，就會解析指令，這個過程叫作指令的解碼。

現代大多數 CPU 都使用來流水線的方式來執行指令，所謂的流水線就是把一個任務拆分成多個小任務，於是一條指令通常分為 4 個階段，稱為 4 級流水線，如下圖：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/CPU指令週期.png)

四個階段的具體含義：

1. CPU 通過程序計數器讀取對應內存地址的指令，這個部分稱為 **Fetch（取得指令）**；
2. CPU 對指令進行解碼，這個部分稱為 **Decode（指令譯碼）**；
3. CPU 執行指令，這個部分稱為 **Execution（執行指令）**；
4. CPU 將計算結果存回寄存器或者將寄存器的值存入內存，這個部分稱為 **Store（數據回寫）**；


上面這 4 個階段，我們稱為**指令週期（*Instrution Cycle*）**，CPU 的工作就是一個週期接著一個週期，周而復始。

事實上，不同的階段其實是由計算機中的不同組件完成的：


![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/指令週期工作組件.png)

- 取指令的階段，我們的指令是存放在**存儲器**裡的，實際上，通過程序計數器和指令寄存器取出指令的過程，是由**控制器**操作的；
- 指令的譯碼過程，也是由**控制器**進行的；
- 指令執行的過程，無論是進行算術操作、邏輯操作，還是進行數據傳輸、條件分支操作，都是由**算術邏輯單元**操作的，也就是由**運算器**處理的。但是如果是一個簡單的無條件地址跳轉，則是直接在**控制器**裡面完成的，不需要用到運算器。


### 指令的類型


指令從功能角度劃分，可以分為 5 大類：

- *數據傳輸類型的指令*，比如 `store/load` 是寄存器與內存間數據傳輸的指令，`mov` 是將一個內存地址的數據移動到另一個內存地址的指令；
- *運算類型的指令*，比如加減乘除、位運算、比較大小等等，它們最多隻能處理兩個寄存器中的數據；
- *跳轉類型的指令*，通過修改程序計數器的值來達到跳轉執行指令的過程，比如編程中常見的 `if-else`、`switch-case`、函數調用等。
- *信號類型的指令*，比如發生中斷的指令 `trap`；
- *閒置類型的指令*，比如指令 `nop`，執行後 CPU 會空轉一個週期；

### 指令的執行速度

CPU 的硬件參數都會有 `GHz` 這個參數，比如一個 1 GHz 的 CPU，指的是時鐘頻率是 1 G，代表著 1 秒會產生 1G 次數的脈衝信號，每一次脈衝信號高低電平的轉換就是一個週期，稱為時鐘週期。

對於 CPU 來說，在一個時鐘週期內，CPU 僅能完成一個最基本的動作，時鐘頻率越高，時鐘週期就越短，工作速度也就越快。

一個時鐘週期一定能執行完一條指令嗎？答案是不一定的，大多數指令不能在一個時鐘週期完成，通常需要若干個時鐘週期。不同的指令需要的時鐘週期是不同的，加法和乘法都對應著一條 CPU 指令，但是乘法需要的時鐘週期就要比加法多。

> 如何讓程序跑的更快？

程序執行的時候，耗費的 CPU 時間少就說明程序是快的，對於程序的 CPU 執行時間，我們可以拆解成 **CPU 時鐘週期數（*CPU Cycles*）和時鐘週期時間（*Clock Cycle Time*）的乘積**。


![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/程序的CPU執行時間公式1.png)

時鐘週期時間就是我們前面提及的 CPU 主頻，主頻越高說明 CPU 的工作速度就越快，比如我手頭上的電腦的 CPU 是 2.4 GHz 四核 Intel Core i5，這裡的 2.4 GHz 就是電腦的主頻，時鐘週期時間就是 1/2.4G。

要想 CPU 跑的更快，自然縮短時鐘週期時間，也就是提升 CPU 主頻，但是今非彼日，摩爾定律早已失效，當今的 CPU 主頻已經很難再做到翻倍的效果了。

另外，換一個更好的 CPU，這個也是我們軟件工程師控制不了的事情，我們應該把目光放到另外一個乘法因子 —— CPU 時鐘週期數，如果能減少程序所需的 CPU 時鐘週期數量，一樣也是能提升程序的性能的。


對於 CPU 時鐘週期數我們可以進一步拆解成：「**指令數 x 每條指令的平均時鐘週期數（*Cycles Per Instruction*，簡稱 `CPI`）**」，於是程序的 CPU 執行時間的公式可變成如下：


![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/操作系統/程序執行/程序的CPU執行時間公式2.png)


因此，要想程序跑的更快，優化這三者即可：

- *指令數*，表示執行程序所需要多少條指令，以及哪些指令。這個層面是基本靠編譯器來優化，畢竟同樣的代碼，在不同的編譯器，編譯出來的計算機指令會有各種不同的表示方式。
- *每條指令的平均時鐘週期數 CPI*，表示一條指令需要多少個時鐘週期數，現代大多數 CPU 通過流水線技術（Pipeline），讓一條指令需要的 CPU 時鐘週期數儘可能的少；
- *時鐘週期時間*，表示計算機主頻，取決於計算機硬件。有的 CPU 支持超頻技術，打開了超頻意味著把 CPU 內部的時鐘給調快了，於是 CPU 工作速度就變快了，但是也是有代價的，CPU 跑的越快，散熱的壓力就會越大，CPU 會很容易奔潰。

很多廠商為了跑分而跑分，基本都是在這三個方面入手的哦，特別是超頻這一塊。


---

## 總結

最後我們再來回答開頭的問題。

>  64 位相比 32 位 CPU 的優勢在哪嗎？64 位 CPU 的計算性能一定比 32 位 CPU 高很多嗎？

64 位相比 32 位 CPU 的優勢主要體現在兩個方面：

- 64 位 CPU 可以一次計算超過 32 位的數字，而 32 位 CPU 如果要計算超過 32 位的數字，要分多步驟進行計算，效率就沒那麼高，但是大部分應用程序很少會計算那麼大的數字，所以**只有運算大數字的時候，64 位 CPU 的優勢才能體現出來，否則和 32 位 CPU 的計算性能相差不大**。
- 64 位 CPU 可以**尋址更大的內存空間**，32 位 CPU 最大的尋址地址是 4G，即使你加了 8G 大小的內存，也還是隻能尋址到 4G，而 64 位 CPU 最大尋址地址是 `2^64`，遠超於 32 位 CPU 最大尋址地址的 `2^32`。


> 你知道軟件的 32 位和 64 位之間的區別嗎？再來 32 位的操作系統可以運行在 64 位的電腦上嗎？64 位的操作系統可以運行在 32 位的電腦上嗎？如果不行，原因是什麼？


64 位和 32 位軟件，實際上代表指令是 64 位還是 32 位的：

- 如果 32 位指令在 64 位機器上執行，需要一套兼容機制，就可以做到兼容運行了。但是**如果 64 位指令在 32 位機器上執行，就比較困難了，因為 32 位的寄存器存不下 64 位的指令**；
- 操作系統其實也是一種程序，我們也會看到操作系統會分成 32 位操作系統、64 位操作系統，其代表意義就是操作系統中程序的指令是多少位，比如 64 位操作系統，指令也就是 64 位，因此不能裝在 32 位機器上。

總之，硬件的 64 位和 32 位指的是 CPU 的位寬，軟件的 64 位和 32 位指的是指令的位寬。

----

## 關注作者

**哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，歡迎微信搜索「小林coding」，關注後，回覆「網絡」再送你圖解網絡 PDF**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)
