# 4.1 為什麼要有虛擬內存？

本篇跟大家說說**內存管理**，內存管理還是比較重要的一個環節，理解了它，至少對整個操作系統的工作會有一個初步的輪廓，這也難怪面試的時候常問內存管理。

幹就完事，本文的提綱：

![](https://img-blog.csdnimg.cn/970ec527d1c1417eab0d3246e77405f9.png)




## 虛擬內存

如果你是電子相關專業的，肯定在大學裡搗鼓過單片機。

單片機是沒有操作系統的，所以每次寫完代碼，都需要藉助工具把程序燒錄進去，這樣程序才能跑起來。

另外，**單片機的 CPU 是直接操作內存的「物理地址」**。

![](https://img-blog.csdnimg.cn/019f1f0d2d30469cbda2b8fe2cf5e622.png)



在這種情況下，要想在內存中同時運行兩個程序是不可能的。如果第一個程序在 2000 的位置寫入一個新的值，將會擦掉第二個程序存放在相同位置上的所有內容，所以同時運行兩個程序是根本行不通的，這兩個程序會立刻崩潰。

> 操作系統是如何解決這個問題呢？

這裡關鍵的問題是這兩個程序都引用了絕對物理地址，而這正是我們最需要避免的。

我們可以把進程所使用的地址「隔離」開來，即讓操作系統為每個進程分配獨立的一套「**虛擬地址**」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有個前提每個進程都不能訪問物理地址，至於虛擬地址最終怎麼落到物理內存裡，對進程來說是透明的，操作系統已經把這些都安排的明明白白了。

![進程的中間層](https://img-blog.csdnimg.cn/img_convert/298fb68e3da94d767b02f2ed81ebf2c4.png)

**操作系統會提供一種機制，將不同進程的虛擬地址和不同內存的物理地址映射起來。**

如果程序要訪問虛擬地址的時候，由操作系統轉換成不同的物理地址，這樣不同的進程運行的時候，寫入的是不同的物理地址，這樣就不會衝突了。

於是，這裡就引出了兩種地址的概念：

- 我們程序所使用的內存地址叫做**虛擬內存地址**（*Virtual Memory Address*）
- 實際存在硬件裡面的空間地址叫**物理內存地址**（*Physical Memory Address*）。

操作系統引入了虛擬內存，進程持有的虛擬地址會通過 CPU 芯片中的內存管理單元（MMU）的映射關係，來轉換變成物理地址，然後再通過物理地址訪問內存，如下圖所示：

![](https://img-blog.csdnimg.cn/72ab76ba697e470b8ceb14d5fc5688d9.png)


> 操作系統是如何管理虛擬地址與物理地址之間的關係？

主要有兩種方式，分別是**內存分段和內存分頁**，分段是比較早提出的，我們先來看看內存分段。



## 內存分段


程序是由若干個邏輯分段組成的，如可由代碼分段、數據分段、棧段、堆段組成。**不同的段是有不同的屬性的，所以就用分段（*Segmentation*）的形式把這些段分離出來。**

> 分段機制下，虛擬地址和物理地址是如何映射的？

分段機制下的虛擬地址由兩部分組成，**段選擇因子**和**段內偏移量**。

![](https://img-blog.csdnimg.cn/a9ed979e2ed8414f9828767592aadc21.png)

段選擇因子和段內偏移量：

- **段選擇因子**就保存在段寄存器裡面。段選擇子裡面最重要的是**段號**，用作段表的索引。**段表**裡面保存的是這個**段的基地址、段的界限和特權等級**等。

- 虛擬地址中的**段內偏移量**應該位於 0 和段界限之間，如果段內偏移量是合法的，就將段基地址加上段內偏移量得到物理內存地址。

在上面，知道了虛擬地址是通過**段表**與物理地址進行映射的，分段機制會把程序的虛擬地址分成 4 個段，每個段在段表中有一個項，在這一項找到段的基地址，再加上偏移量，於是就能找到物理內存中的地址，如下圖：

![](https://img-blog.csdnimg.cn/c5e2ab63e6ee4c8db575f3c7c9c85962.png)



如果要訪問段 3 中偏移量 500 的虛擬地址，我們可以計算出物理地址為，段 3 基地址 7000 + 偏移量 500 = 7500。

分段的辦法很好，解決了程序本身不需要關心具體的物理內存地址的問題，但它也有一些不足之處：

- 第一個就是**內存碎片**的問題。
- 第二個就是**內存交換的效率低**的問題。

接下來，說說為什麼會有這兩個問題。

> 我們先來看看，分段為什麼會產生內存碎片的問題？


我們來看看這樣一個例子。假設有 1G 的物理內存，用戶執行了多個程序，其中：

- 遊戲佔用了 512MB 內存
- 瀏覽器佔用了 128MB 內存
- 音樂佔用了 256 MB 內存。

這個時候，如果我們關閉了瀏覽器，則空閒內存還有 1024 - 512 - 256 = 256MB。

如果這個 256MB 不是連續的，被分成了兩段 128 MB 內存，這就會導致沒有空間再打開一個 200MB 的程序。

![](https://img-blog.csdnimg.cn/6142bc3c917e4a6298bdb62936e0d332.png)

> 內存分段會出現內存碎片嗎？

內存碎片主要分為，內部內存碎片和外部內存碎片。

內存分段管理可以做到段根據實際需求分配內存，所以有多少需求就分配多大的段，所以**不會出現內部內存碎片**。

但是由於每個段的長度不固定，所以多個段未必能恰好使用所有的內存空間，會產生了多個不連續的小物理內存，導致新的程序無法被裝載，所以**會出現外部內存碎片**的問題。

解決「外部內存碎片」的問題就是**內存交換**。

可以把音樂程序佔用的那 256MB 內存寫到硬盤上，然後再從硬盤上讀回來到內存裡。不過再讀回的時候，我們不能裝載回原來的位置，而是緊緊跟著那已經被佔用了的 512MB 內存後面。這樣就能空缺出連續的 256MB 空間，於是新的 200MB 程序就可以裝載進來。

這個內存交換空間，在 Linux 系統裡，也就是我們常看到的 Swap 空間，這塊空間是從硬盤劃分出來的，用於內存與硬盤的空間交換。

> 再來看看，分段為什麼會導致內存交換效率低的問題？

對於多進程的系統來說，用分段的方式，外部內存碎片是很容易產生的，產生了外部內存碎片，那不得不重新 `Swap` 內存區域，這個過程會產生性能瓶頸。

因為硬盤的訪問速度要比內存慢太多了，每一次內存交換，我們都需要把一大段連續的內存數據寫到硬盤上。

所以，**如果內存交換的時候，交換的是一個佔內存空間很大的程序，這樣整個機器都會顯得卡頓。**

為瞭解決內存分段的「外部內存碎片和內存交換效率低」的問題，就出現了內存分頁。

## 內存分頁

分段的好處就是能產生連續的內存空間，但是會出現「外部內存碎片和內存交換的空間太大」的問題。

要解決這些問題，那麼就要想出能少出現一些內存碎片的辦法。另外，當需要進行內存交換的時候，讓需要交換寫入或者從磁盤裝載的數據更少一點，這樣就可以解決問題了。這個辦法，也就是**內存分頁**（*Paging*）。

**分頁是把整個虛擬和物理內存空間切成一段段固定尺寸的大小**。這樣一個連續並且尺寸固定的內存空間，我們叫**頁**（*Page*）。在 Linux 下，每一頁的大小為 `4KB`。

虛擬地址與物理地址之間通過**頁表**來映射，如下圖：

![](https://img-blog.csdnimg.cn/08a8e315fedc4a858060db5cb4a654af.png)


頁表是存儲在內存裡的，**內存管理單元** （*MMU*）就做將虛擬內存地址轉換成物理地址的工作。


而當進程訪問的虛擬地址在頁表中查不到時，系統會產生一個**缺頁異常**，進入系統內核空間分配物理內存、更新進程頁表，最後再返回用戶空間，恢復進程的運行。

> 分頁是怎麼解決分段的「外部內存碎片和內存交換效率低」的問題？

內存分頁由於內存空間都是預先劃分好的，也就不會像內存分段一樣，在段與段之間會產生間隙非常小的內存，這正是分段會產生外部內存碎片的原因。而**採用了分頁，頁與頁之間是緊密排列的，所以不會有外部碎片。**

但是，因為內存分頁機制分配內存的最小單位是一頁，即使程序不足一頁大小，我們最少只能分配一個頁，所以頁內會出現內存浪費，所以針對**內存分頁機制會有內部內存碎片**的現象。

如果內存空間不夠，操作系統會把其他正在運行的進程中的「最近沒被使用」的內存頁面給釋放掉，也就是暫時寫在硬盤上，稱為**換出**（*Swap Out*）。一旦需要的時候，再加載進來，稱為**換入**（*Swap In*）。所以，一次性寫入磁盤的也只有少數的一個頁或者幾個頁，不會花太多時間，**內存交換的效率就相對比較高。**

![](https://img-blog.csdnimg.cn/388a29f45fe947e5a49240e4eff13538.png)


更進一步地，分頁的方式使得我們在加載程序的時候，不再需要一次性都把程序加載到物理內存中。我們完全可以在進行虛擬內存和物理內存的頁之間的映射之後，並不真的把頁加載到物理內存裡，而是**只有在程序運行中，需要用到對應虛擬內存頁裡面的指令和數據時，再加載到物理內存裡面去。**


> 分頁機制下，虛擬地址和物理地址是如何映射的？

在分頁機制下，虛擬地址分為兩部分，**頁號**和**頁內偏移**。頁號作為頁表的索引，**頁表**包含物理頁每頁所在**物理內存的基地址**，這個基地址與頁內偏移的組合就形成了物理內存地址，見下圖。

![](https://img-blog.csdnimg.cn/7884f4d8db4949f7a5bb4bbd0f452609.png)

總結一下，對於一個內存地址轉換，其實就是這樣三個步驟：

- 把虛擬內存地址，切分成頁號和偏移量；
- 根據頁號，從頁表裡面，查詢對應的物理頁號；
- 直接拿物理頁號，加上前面的偏移量，就得到了物理內存地址。

下面舉個例子，虛擬內存中的頁通過頁表映射為了物理內存中的頁，如下圖：

![](https://img-blog.csdnimg.cn/8f187878c809414ca2486b0b71e8880e.png)


這看起來似乎沒什麼毛病，但是放到實際中操作系統，這種簡單的分頁是肯定是會有問題的。

> 簡單的分頁有什麼缺陷嗎？

有空間上的缺陷。

因為操作系統是可以同時運行非常多的進程的，那這不就意味著頁表會非常的龐大。

在 32 位的環境下，虛擬地址空間共有 4GB，假設一個頁的大小是 4KB（2^12），那麼就需要大約 100 萬 （2^20） 個頁，每個「頁表項」需要 4 個字節大小來存儲，那麼整個 4GB 空間的映射就需要有 `4MB` 的內存來存儲頁表。

這 4MB 大小的頁表，看起來也不是很大。但是要知道每個進程都是有自己的虛擬地址空間的，也就說都有自己的頁表。

那麼，`100` 個進程的話，就需要 `400MB` 的內存來存儲頁表，這是非常大的內存了，更別說 64 位的環境了。


### 多級頁表

要解決上面的問題，就需要採用一種叫作**多級頁表**（*Multi-Level Page Table*）的解決方案。

在前面我們知道了，對於單頁表的實現方式，在 32 位和頁大小 `4KB` 的環境下，一個進程的頁表需要裝下 100 多萬個「頁表項」，並且每個頁表項是佔用 4 字節大小的，於是相當於每個頁表需佔用 4MB 大小的空間。

我們把這個 100 多萬個「頁表項」的單級頁表再分頁，將頁表（一級頁表）分為 `1024` 個頁表（二級頁表），每個表（二級頁表）中包含 `1024` 個「頁表項」，形成**二級分頁**。如下圖所示：


![](https://img-blog.csdnimg.cn/19296e249b2240c29f9c52be70f611d5.png)

> 你可能會問，分了二級表，映射 4GB 地址空間就需要 4KB（一級頁表）+ 4MB（二級頁表）的內存，這樣佔用空間不是更大了嗎？

當然如果 4GB 的虛擬地址全部都映射到了物理內存上的話，二級分頁佔用空間確實是更大了，但是，我們往往不會為一個進程分配那麼多內存。

其實我們應該換個角度來看問題，還記得計算機組成原理裡面無處不在的**局部性原理**麼？

每個進程都有 4GB 的虛擬地址空間，而顯然對於大多數程序來說，其使用到的空間遠未達到 4GB，因為會存在部分對應的頁表項都是空的，根本沒有分配，對於已分配的頁表項，如果存在最近一定時間未訪問的頁表，在物理內存緊張的情況下，操作系統會將頁面換出到硬盤，也就是說不會佔用物理內存。

如果使用了二級分頁，一級頁表就可以覆蓋整個 4GB 虛擬地址空間，但**如果某個一級頁表的頁表項沒有被用到，也就不需要創建這個頁表項對應的二級頁表了，即可以在需要時才創建二級頁表**。做個簡單的計算，假設只有 20% 的一級頁表項被用到了，那麼頁表佔用的內存空間就只有 4KB（一級頁表） + 20% * 4MB（二級頁表）= `0.804MB`，這對比單級頁表的 `4MB` 是不是一個巨大的節約？

那麼為什麼不分級的頁表就做不到這樣節約內存呢？

我們從頁表的性質來看，保存在內存中的頁表承擔的職責是將虛擬地址翻譯成物理地址。假如虛擬地址在頁表中找不到對應的頁表項，計算機系統就不能工作了。所以**頁表一定要覆蓋全部虛擬地址空間，不分級的頁表就需要有 100 多萬個頁表項來映射，而二級分頁則只需要 1024 個頁表項**（此時一級頁表覆蓋到了全部虛擬地址空間，二級頁表在需要時創建）。

我們把二級分頁再推廣到多級頁表，就會發現頁表佔用的內存空間更少了，這一切都要歸功於對局部性原理的充分應用。

對於 64 位的系統，兩級分頁肯定不夠了，就變成了四級目錄，分別是：

- 全局頁目錄項 PGD（*Page Global Directory*）；
- 上層頁目錄項 PUD（*Page Upper Directory*）；
- 中間頁目錄項 PMD（*Page Middle Directory*）；
- 頁表項 PTE（*Page Table Entry*）；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系統/內存管理/四級分頁.png)


### TLB

多級頁表雖然解決了空間上的問題，但是虛擬地址到物理地址的轉換就多了幾道轉換的工序，這顯然就降低了這倆地址轉換的速度，也就是帶來了時間上的開銷。

程序是有局部性的，即在一段時間內，整個程序的執行僅限於程序中的某一部分。相應地，執行所訪問的存儲空間也侷限於某個內存區域。

![](https://img-blog.csdnimg.cn/edce58534d9342ff89f5261b1929c754.png)


我們就可以利用這一特性，把最常訪問的幾個頁表項存儲到訪問速度更快的硬件，於是計算機科學家們，就在 CPU 芯片中，加入了一個專門存放程序最常訪問的頁表項的 Cache，這個 Cache 就是 TLB（*Translation Lookaside Buffer*） ，通常稱為頁表緩存、轉址旁路緩存、快表等。

![](https://img-blog.csdnimg.cn/a3cdf27646b24614a64cfc5d7ccffa35.png)

在 CPU 芯片裡面，封裝了內存管理單元（*Memory Management Unit*）芯片，它用來完成地址轉換和 TLB 的訪問與交互。

有了 TLB 後，那麼 CPU 在尋址時，會先查 TLB，如果沒找到，才會繼續查常規的頁表。

TLB 的命中率其實是很高的，因為程序最常訪問的頁就那麼幾個。



## 段頁式內存管理

內存分段和內存分頁並不是對立的，它們是可以組合起來在同一個系統中使用的，那麼組合起來後，通常稱為**段頁式內存管理**。


![](https://img-blog.csdnimg.cn/f19ebd6f70f84083b0d87cc5e9dea8e3.png)



段頁式內存管理實現的方式：

- 先將程序劃分為多個有邏輯意義的段，也就是前面提到的分段機制；
- 接著再把每個段劃分為多個頁，也就是對分段劃分出來的連續空間，再劃分固定大小的頁；

這樣，地址結構就由**段號、段內頁號和頁內位移**三部分組成。


用於段頁式地址變換的數據結構是每一個程序一張段表，每個段又建立一張頁表，段表中的地址是頁表的起始地址，而頁表中的地址則為某頁的物理頁號，如圖所示：

![](https://img-blog.csdnimg.cn/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)



段頁式地址變換中要得到物理地址須經過三次內存訪問：

- 第一次訪問段表，得到頁表起始地址；
- 第二次訪問頁表，得到物理頁號；
- 第三次將物理頁號與頁內位移組合，得到物理地址。

可用軟、硬件相結合的方法實現段頁式地址變換，這樣雖然增加了硬件成本和系統開銷，但提高了內存的利用率。


## Linux 內存管理

那麼，Linux 操作系統採用了哪種方式來管理內存呢？

> 在回答這個問題前，我們得先看看 Intel 處理器的發展歷史。

早期 Intel 的處理器從 80286 開始使用的是段式內存管理。但是很快發現，光有段式內存管理而沒有頁式內存管理是不夠的，這會使它的 X86 系列會失去市場的競爭力。因此，在不久以後的 80386 中就實現了頁式內存管理。也就是說，80386 除了完成並完善從 80286 開始的段式內存管理的同時還實現了頁式內存管理。

但是這個 80386 的頁式內存管理設計時，沒有繞開段式內存管理，而是建立在段式內存管理的基礎上，這就意味著，**頁式內存管理的作用是在由段式內存管理所映射而成的地址上再加上一層地址映射。**

由於此時由段式內存管理映射而成的地址不再是“物理地址”了，Intel 就稱之為“線性地址”（也稱虛擬地址）。於是，段式內存管理先將邏輯地址映射成線性地址，然後再由頁式內存管理將線性地址映射成物理地址。

![](https://img-blog.csdnimg.cn/bc0aaaf379fc4bc8882efd94b9052b64.png)

這裡說明下邏輯地址和線性地址：

- 程序所使用的地址，通常是沒被段式內存管理映射的地址，稱為邏輯地址；
- 通過段式內存管理映射的地址，稱為線性地址，也叫虛擬地址；

邏輯地址是「段式內存管理」轉換前的地址，線性地址則是「頁式內存管理」轉換前的地址。

> 瞭解完 Intel 處理器的發展歷史後，我們再來說說 Linux 採用了什麼方式管理內存？

**Linux 內存主要採用的是頁式內存管理，但同時也不可避免地涉及了段機制**。

這主要是上面 Intel 處理器發展歷史導致的，因為 Intel X86 CPU 一律對程序中使用的地址先進行段式映射，然後才能進行頁式映射。既然 CPU 的硬件結構是這樣，Linux 內核也只好服從 Intel 的選擇。

但是事實上，Linux 內核所採取的辦法是使段式映射的過程實際上不起什麼作用。也就是說，“上有政策，下有對策”，若惹不起就躲著走。


**Linux 系統中的每個段都是從 0 地址開始的整個 4GB 虛擬空間（32 位環境下），也就是所有的段的起始地址都是一樣的。這意味著，Linux 系統中的代碼，包括操作系統本身的代碼和應用程序代碼，所面對的地址空間都是線性地址空間（虛擬地址），這種做法相當於屏蔽了處理器中的邏輯地址概念，段只被用於訪問控制和內存保護。**

> 我們再來瞧一瞧，Linux 的虛擬地址空間是如何分佈的？

在 Linux 操作系統中，虛擬地址空間的內部又被分為**內核空間和用戶空間**兩部分，不同位數的系統，地址空間的範圍也不同。比如最常見的 32 位和 64 位系統，如下所示：

![](https://img-blog.csdnimg.cn/3a6cb4e3f27241d3b09b4766bb0b1124.png)

通過這裡可以看出：

- `32` 位系統的內核空間佔用 `1G`，位於最高處，剩下的 `3G` 是用戶空間；
- `64` 位系統的內核空間和用戶空間都是 `128T`，分別佔據整個內存空間的最高和最低處，剩下的中間部分是未定義的。

再來說說，內核空間與用戶空間的區別：

- 進程在用戶態時，只能訪問用戶空間內存；
- 只有進入內核態後，才可以訪問內核空間的內存；

雖然每個進程都各自有獨立的虛擬內存，但是**每個虛擬內存中的內核地址，其實關聯的都是相同的物理內存**。這樣，進程切換到內核態後，就可以很方便地訪問內核空間內存。

![](https://img-blog.csdnimg.cn/48403193b7354e618bf336892886bcff.png)


接下來，進一步瞭解虛擬空間的劃分情況，用戶空間和內核空間劃分的方式是不同的，內核空間的分佈情況就不多說了。

我們看看用戶空間分佈的情況，以 32 位系統為例，我畫了一張圖來表示它們的關係：


![虛擬內存空間劃分](https://img-blog.csdnimg.cn/img_convert/b4f882b9447760ce5321de109276ec23.png)

通過這張圖你可以看到，用戶空間內存，從**低到高**分別是 6 種不同的內存段：

- 程序文件段（.text），包括二進制可執行代碼；
- 已初始化數據段（.data），包括靜態常量；
- 未初始化數據段（.bss），包括未初始化的靜態變量；
- 堆段，包括動態分配的內存，從低地址開始向上增長；
- 文件映射段，包括動態庫、共享內存等，從低地址開始向上增長（[跟硬件和內核版本有關](http://lishiwen4.github.io/linux/linux-process-memory-location)）；
- 棧段，包括局部變量和函數調用的上下文等。棧的大小是固定的，一般是 `8 MB`。當然系統也提供了參數，以便我們自定義大小；

在這 7 個內存段中，堆和文件映射段的內存是動態分配的。比如說，使用 C 標準庫的 `malloc()` 或者 `mmap()` ，就可以分別在堆和文件映射段動態分配內存。

## 總結

為了在多進程環境下，使得進程之間的內存地址不受影響，相互隔離，於是操作系統就為每個進程獨立分配一套**虛擬地址空間**，每個程序只關心自己的虛擬地址就可以，實際上大家的虛擬地址都是一樣的，但分佈到物理地址內存是不一樣的。作為程序，也不用關心物理地址的事情。

每個進程都有自己的虛擬空間，而物理內存只有一個，所以當啟用了大量的進程，物理內存必然會很緊張，於是操作系統會通過**內存交換**技術，把不常使用的內存暫時存放到硬盤（換出），在需要的時候再裝載回物理內存（換入）。

那既然有了虛擬地址空間，那必然要把虛擬地址「映射」到物理地址，這個事情通常由操作系統來維護。

那麼對於虛擬地址與物理地址的映射關係，可以有**分段**和**分頁**的方式，同時兩者結合都是可以的。

內存分段是根據程序的邏輯角度，分成了棧段、堆段、數據段、代碼段等，這樣可以分離出不同屬性的段，同時是一塊連續的空間。但是每個段的大小都不是統一的，這就會導致外部內存碎片和內存交換效率低的問題。

於是，就出現了內存分頁，把虛擬空間和物理空間分成大小固定的頁，如在 Linux 系統中，每一頁的大小為 `4KB`。由於分了頁後，就不會產生細小的內存碎片，解決了內存分段的外部內存碎片問題。同時在內存交換的時候，寫入硬盤也就一個頁或幾個頁，這就大大提高了內存交換的效率。

再來，為瞭解決簡單分頁產生的頁表過大的問題，就有了**多級頁表**，它解決了空間上的問題，但這就會導致 CPU 在尋址的過程中，需要有很多層表參與，加大了時間上的開銷。於是根據程序的**局部性原理**，在 CPU 芯片中加入了 **TLB**，負責緩存最近常被訪問的頁表項，大大提高了地址的轉換速度。

**Linux 系統主要採用了分頁管理，但是由於 Intel 處理器的發展史，Linux 系統無法避免分段管理**。於是 Linux 就把所有段的基地址設為 `0`，也就意味著所有程序的地址空間都是線性地址空間（虛擬地址），相當於屏蔽了 CPU 邏輯地址的概念，所以段只被用於訪問控制和內存保護。

另外，Linux 系統中虛擬空間分佈可分為**用戶態**和**內核態**兩部分，其中用戶態的分佈：代碼段、全局變量、BSS、函數棧、堆內存、映射區。

> 最後，說下虛擬內存有什麼作用？

- 第一，虛擬內存可以使得進程的運行內存超過物理內存大小，因為程序運行符合局部性原理，CPU 訪問內存會有很明顯的重複訪問的傾向性，對於那些沒有被經常使用到的內存，我們可以把它換出到物理內存之外，比如硬盤上的 swap 區域。
- 第二，由於每個進程都有自己的頁表，所以每個進程的虛擬內存空間就是相互獨立的。進程也沒有辦法訪問其他進程的頁表，所以這些頁表是私有的，這就解決了多進程之間地址衝突的問題。
- 第三，頁表裡的頁表項中除了物理地址之外，還有一些標記屬性的比特，比如控制一個頁的讀寫權限，標記該頁是否存在等。在內存訪問方面，操作系統提供了更好的安全性。

---

***哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，歡迎微信搜索「小林coding」，關注後，回覆「網絡」再送你圖解網絡 PDF***

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/其他/公眾號介紹.png)
