# 8.1 鍵盤敲入 A 字母時，操作系統期間發生了什麼？

鍵盤可以說是我們最常使用的輸入硬件設備了，但身為程序員的你，你知道「**鍵盤敲入A 字母時，操作系統期間發生了什麼嗎**」？

那要想知道這個發生的過程，我們得先了解了解「操作系統是如何管理多種多樣的的輸入輸出設備」的，等了解完這個後，我們再來看看這個問題，你就會發現問題已經被迎刃而解了。

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.png)



---

## 設備控制器

我們的電腦設備可以接非常多的輸入輸出設備，比如鍵盤、鼠標、顯示器、網卡、硬盤、打印機、音響等等，每個設備的用法和功能都不同，那操作系統是如何把這些輸入輸出設備統一管理的呢?

為了屏蔽設備之間的差異，每個設備都有一個叫**設備控制器（*Device Control*）** 的組件，比如硬盤有硬盤控制器、顯示器有視頻控制器等。

![計算機 I/O 系統結構](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png)

因為這些控制器都很清楚的知道對應設備的用法和功能，所以 CPU 是通過設備控制器來和設備打交道的。

設備控制器裡有芯片，它可執行自己的邏輯，也有自己的寄存器，用來與 CPU 進行通信，比如：

- 通過寫入這些寄存器，操作系統可以命令設備發送數據、接收數據、開啟或關閉，或者執行某些其他操作。
- 通過讀取這些寄存器，操作系統可以瞭解設備的狀態，是否準備好接收一個新的命令等。

實際上，控制器是有三類寄存器，它們分別是**狀態寄存器（*Status Register*）**、 **命令寄存器（*Command Register*）**以及**數據寄存器（*Data Register*）**，如下圖：

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8.png)

這三個寄存器的作用：

- *數據寄存器*，CPU 向 I/O 設備寫入需要傳輸的數據，比如要打印的內容是「Hello」，CPU 就要先發送一個 H 字符給到對應的 I/O 設備。
- *命令寄存器*，CPU 發送一個命令，告訴 I/O 設備，要進行輸入/輸出操作，於是就會交給 I/O 設備去工作，任務完成後，會把狀態寄存器裡面的狀態標記為完成。
- *狀態寄存器*，目的是告訴 CPU ，現在已經在工作或工作已經完成，如果已經在工作狀態，CPU 再發送數據或者命令過來，都是沒有用的，直到前面的工作已經完成，狀態寄存標記成已完成，CPU 才能發送下一個字符和命令。

CPU 通過讀寫設備控制器中的寄存器控制設備，這可比 CPU 直接控制輸入輸出設備，要方便和標準很多。

另外， 輸入輸出設備可分為兩大類 ：**塊設備（*Block Device*）**和**字符設備（*Character Device*）**。

- *塊設備*，把數據存儲在固定大小的塊中，每個塊有自己的地址，硬盤、USB 是常見的塊設備。
- *字符設備*，以字符為單位發送或接收一個字符流，字符設備是不可尋址的，也沒有任何尋道操作，鼠標是常見的字符設備。


塊設備通常傳輸的數據量會非常大，於是控制器設立了一個可讀寫的**數據緩衝區**。

- CPU 寫入數據到控制器的緩衝區時，當緩衝區的數據囤夠了一部分，才會發給設備。
- CPU 從控制器的緩衝區讀取數據時，也需要緩衝區囤夠了一部分，才拷貝到內存。

這樣做是為了，減少對設備的頻繁操作。

那 CPU 是如何與設備的控制寄存器和數據緩衝區進行通信的？存在兩個方法：

- *端口 I/O*，每個控制寄存器被分配一個 I/O 端口，可以通過特殊的彙編指令操作這些寄存器，比如 `in/out` 類似的指令。
- *內存映射 I/O*，將所有控制寄存器映射到內存空間中，這樣就可以像讀寫內存一樣讀寫數據緩衝區。

---

## I/O 控制方式

在前面我知道，每種設備都有一個設備控制器，控制器相當於一個小 CPU，它可以自己處理一些事情，但有個問題是，當 CPU 給設備發送了一個指令，讓設備控制器去讀設備的數據，它讀完的時候，要怎麼通知 CPU 呢？

控制器的寄存器一般會有狀態標記位，用來標識輸入或輸出操作是否完成。於是，我們想到第一種**輪詢等待**的方法，讓 CPU 一直查寄存器的狀態，直到狀態標記為完成，很明顯，這種方式非常的傻瓜，它會佔用 CPU 的全部時間。

那我們就想到第二種方法 —— **中斷**，通知操作系統數據已經準備好了。我們一般會有一個硬件的**中斷控制器**，當設備完成任務後觸發中斷到中斷控制器，中斷控制器就通知 CPU，一箇中斷產生了，CPU 需要停下當前手裡的事情來處理中斷。

另外，中斷有兩種，一種**軟中斷**，例如代碼調用 `INT` 指令觸發，一種是**硬件中斷**，就是硬件通過中斷控制器觸發的。

但中斷的方式對於頻繁讀寫數據的磁盤，並不友好，這樣 CPU 容易經常被打斷，會佔用 CPU 大量的時間。對於這一類設備的問題的解決方法是使用 **DMA（*Direct Memory Access*）** 功能，它可以使得設備在 CPU 不參與的情況下，能夠自行完成把設備 I/O 數據放入到內存。那要實現 DMA 功能要有 「DMA 控制器」硬件的支持。


![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/DMA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png)

DMA 的工作方式如下：

- CPU 需對 DMA 控制器下發指令，告訴它想讀取多少數據，讀完的數據放在內存的某個地方就可以了；
- 接下來，DMA 控制器會向磁盤控制器發出指令，通知它從磁盤讀數據到其內部的緩衝區中，接著磁盤控制器將緩衝區的數據傳輸到內存；
- 當磁盤控制器把數據傳輸到內存的操作完成後，磁盤控制器在總線上發出一個確認成功的信號到 DMA 控制器；
- DMA 控制器收到信號後，DMA 控制器發中斷通知 CPU 指令完成，CPU 就可以直接用內存裡面現成的數據了；

可以看到， CPU 當要讀取磁盤數據的時候，只需給 DMA 控制器發送指令，然後返回去做其他事情，當磁盤數據拷貝到內存後，DMA 控制機器通過中斷的方式，告訴 CPU 數據已經準備好了，可以從內存讀數據了。僅僅在傳送開始和結束時需要 CPU 幹預。

----

## 設備驅動程序

雖然設備控制器屏蔽了設備的眾多細節，但每種設備的控制器的寄存器、緩衝區等使用模式都是不同的，所以為了屏蔽「設備控制器」的差異，引入了**設備驅動程序**。


![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.png)

設備控制器不屬於操作系統範疇，它是屬於硬件，而設備驅動程序屬於操作系統的一部分，操作系統的內核代碼可以像本地調用代碼一樣使用設備驅動程序的接口，而設備驅動程序是面向設備控制器的代碼，它發出操控設備控制器的指令後，才可以操作設備控制器。

不同的設備控制器雖然功能不同，但是**設備驅動程序會提供統一的接口給操作系統**，這樣不同的設備驅動程序，就可以以相同的方式接入操作系統。如下圖：

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E4%B8%80%E8%87%B4%E6%80%A7.png)

前面提到了不少關於中斷的事情，設備完成了事情，則會發送中斷來通知操作系統。那操作系統就需要有一個地方來處理這個中斷，這個地方也就是在設備驅動程序裡，它會及時響應控制器發來的中斷請求，並根據這個中斷的類型調用響應的**中斷處理程序**進行處理。

通常，設備驅動程序初始化的時候，要先註冊一個該設備的中斷處理函數。

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

我們來看看，中斷處理程序的處理流程：

1. 在 I/O 時，設備控制器如果已經準備好數據，則會通過中斷控制器向 CPU 發送中斷請求；
2. 保護被中斷進程的 CPU 上下文；
3. 轉入相應的設備中斷處理函數；
4. 進行中斷處理；
5. 恢復被中斷進程的上下文；

----

## 通用塊層

對於塊設備，為了減少不同塊設備的差異帶來的影響，Linux 通過一個統一的**通用塊層**，來管理不同的塊設備。

通用塊層是處於文件系統和磁盤驅動中間的一個塊設備抽象層，它主要有兩個功能：

- 第一個功能，向上為文件系統和應用程序，提供訪問塊設備的標準接口，向下把各種不同的磁盤設備抽象為統一的塊設備，並在內核層面，提供一個框架來管理這些設備的驅動程序；
- 第二功能，通用層還會給文件系統和應用程序發來的 I/O 請求排隊，接著會對隊列重新排序、請求合併等方式，也就是 I/O 調度，主要目的是為了提高磁盤讀寫的效率。

Linux 內存支持 5 種 I/O 調度算法，分別是：

- 沒有調度算法
- 先入先出調度算法
- 完全公平調度算法
- 優先級調度
- 最終期限調度算法

第一種，沒有調度算法，是的，你沒聽錯，它不對文件系統和應用程序的 I/O 做任何處理，這種算法常用在虛擬機 I/O 中，此時磁盤 I/O 調度算法交由物理機系統負責。

第二種，先入先出調度算法，這是最簡單的 I/O 調度算法，先進入 I/O 調度隊列的 I/O 請求先發生。

第三種，完全公平調度算法，大部分系統都把這個算法作為默認的 I/O 調度器，它為每個進程維護了一個 I/O 調度隊列，並按照時間片來均勻分佈每個進程的 I/O 請求。

第四種，優先級調度算法，顧名思義，優先級高的 I/O 請求先發生， 它適用於運行大量進程的系統，像是桌面環境、多媒體應用等。

第五種，最終期限調度算法，分別為讀、寫請求創建了不同的 I/O 隊列，這樣可以提高機械磁盤的吞吐量，並確保達到最終期限的請求被優先處理，適用於在 I/O 壓力比較大的場景，比如數據庫等。

---

## 存儲系統 I/O 軟件分層

前面說到了不少東西，設備、設備控制器、驅動程序、通用塊層，現在再結合文件系統原理，我們來看看 Linux 存儲系統的 I/O 軟件分層。

可以把 Linux 存儲系統的 I/O 由上到下可以分為三個層次，分別是文件系統層、通用塊層、設備層。他們整個的層次關係如下圖：

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png)

這三個層次的作用是：

- 文件系統層，包括虛擬文件系統和其他文件系統的具體實現，它向上為應用程序統一提供了標準的文件訪問接口，向下會通過通用塊層來存儲和管理磁盤數據。
- 通用塊層，包括塊設備的 I/O 隊列和 I/O 調度器，它會對文件系統的 I/O 請求進行排隊，再通過 I/O 調度器，選擇一個 I/O 發給下一層的設備層。
- 設備層，包括硬件設備、設備控制器和驅動程序，負責最終物理設備的 I/O 操作。

有了文件系統接口之後，不但可以通過文件系統的命令行操作設備，也可以通過應用程序，調用 `read`、`write` 函數，就像讀寫文件一樣操作設備，所以說設備在 Linux 下，也只是一個特殊的文件。

但是，除了讀寫操作，還需要有檢查特定於設備的功能和屬性。於是，需要 `ioctl` 接口，它表示輸入輸出控制接口，是用於配置和修改特定設備屬性的通用接口。


另外，存儲系統的 I/O 是整個系統最慢的一個環節，所以 Linux 提供了不少緩存機制來提高 I/O 的效率。

- 為了提高文件訪問的效率，會使用**頁緩存、索引節點緩存、目錄項緩存**等多種緩存機制，目的是為了減少對塊設備的直接調用。
- 為了提高塊設備的訪問效率， 會使用**緩衝區**，來緩存塊設備的數據。

---

## 鍵盤敲入字母時，期間發生了什麼？

看完前面的內容，相信你對輸入輸出設備的管理有了一定的認識，那接下來就從操作系統的角度回答開頭的問題「鍵盤敲入字母時，操作系統期間發生了什麼？」

我們先來看看 CPU 的硬件架構圖：

![CPU 的硬件架構圖](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/CPU%20%E7%A1%AC%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%9B%BE.png)

CPU 裡面的內存接口，直接和系統總線通信，然後系統總線再接入一個 I/O 橋接器，這個 I/O 橋接器，另一邊接入了內存總線，使得 CPU 和內存通信。再另一邊，又接入了一個 I/O 總線，用來連接 I/O 設備，比如鍵盤、顯示器等。

那當用戶輸入了鍵盤字符，**鍵盤控制器**就會產生掃描碼數據，並將其緩衝在鍵盤控制器的寄存器中，緊接著鍵盤控制器通過總線給 CPU 發送**中斷請求**。

CPU 收到中斷請求後，操作系統會**保存被中斷進程的 CPU 上下文**，然後調用鍵盤的**中斷處理程序**。

鍵盤的中斷處理程序是在**鍵盤驅動程序**初始化時註冊的，那鍵盤**中斷處理函數**的功能就是從鍵盤控制器的寄存器的緩衝區讀取掃描碼，再根據掃描碼找到用戶在鍵盤輸入的字符，如果輸入的字符是顯示字符，那就會把掃描碼翻譯成對應顯示字符的  ASCII 碼，比如用戶在鍵盤輸入的是字母 A，是顯示字符，於是就會把掃描碼翻譯成 A 字符的 ASCII 碼。

得到了顯示字符的 ASCII 碼後，就會把 ASCII 碼放到「讀緩衝區隊列」，接下來就是要把顯示字符顯示屏幕了，顯示設備的驅動程序會定時從「讀緩衝區隊列」讀取數據放到「寫緩衝區隊列」，最後把「寫緩衝區隊列」的數據一個一個寫入到顯示設備的控制器的寄存器中的數據緩衝區，最後將這些數據顯示在屏幕裡。

顯示出結果後，**恢復被中斷進程的上下文**。

---

## 關注作者

***哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，歡迎微信搜索「小林coding」，關注後，回覆「網絡」再送你圖解網絡 PDF***

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/其他/公眾號介紹.png)