# 2.2 鍵入網址到網頁顯示，期間發生了什麼？

想必不少小夥伴面試過程中，會遇到「**當鍵入網址後，到網頁顯示，其間發生了什麼**」的面試題。

還別說，這問題真挺常問的，前幾天坐在我旁邊的主管電話面試應聘者的時候，也問了這個問題。

接下來以下圖較簡單的網絡拓撲模型作為例子，探究探究其間發生了什麼？

![簡單的網絡模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

## 孤單小弟 —— HTTP

> 瀏覽器做的第一步工作是解析 URL

首先瀏覽器做的第一步工作就是要對 `URL` 進行解析，從而生成發送給 `Web` 服務器的請求信息。

讓我們看看一條長長的 URL 裡的各個元素的代表什麼，見下圖：

![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

所以圖中的長長的 URL 實際上是請求服務器裡的文件資源。

> 要是上圖中的藍色部分 URL 元素都省略了，那應該是請求哪個文件呢？

當沒有路徑名時，就代表訪問根目錄下事先設置的**默認文件**，也就是 `/index.html` 或者 `/default.html` 這些文件，這樣就不會發生混亂了。

> 生產 HTTP 請求信息

對 `URL` 進行解析之後，瀏覽器確定了 Web 服務器和文件名，接下來就是根據這些信息來生成 HTTP 請求消息了。

![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

> 一個孤單 HTTP 數據包表示：“我這麼一個小小的數據包，沒親沒友，直接發到浩瀚的網絡，誰會知道我呢？誰能載我一程呢？誰能保護我呢？我的目的地在哪呢？”充滿各種疑問的它，沒有停滯不前，依然踏上了征途！

---

## 真實地址查詢 —— DNS

通過瀏覽器解析 URL 並生成 HTTP 消息後，需要委託操作系統將消息發送給 `Web`  服務器。

但在發送之前，還有一項工作需要完成，那就是**查詢服務器域名對應的 IP 地址**，因為委託操作系統發送消息時，必須提供通信對象的 IP 地址。

比如我們打電話的時候，必須要知道對方的電話號碼，但由於電話號碼難以記憶，所以通常我們會將對方電話號 + 姓名保存在通訊錄裡。

所以，有一種服務器就專門保存了 `Web` 服務器域名與 `IP` 的對應關係，它就是 `DNS` 服務器。

> 域名的層級關係

DNS 中的域名都是用**句點**來分隔的，比如 `www.server.com`，這裡的句點代表了不同層次之間的**界限**。

在域名中，**越靠右**的位置表示其層級**越高**。

畢竟域名是外國人發明，所以思維和中國人相反，比如說一個城市地點的時候，外國喜歡從小到大的方式順序說起（如 XX 街道 XX 區 XX 市 XX 省），而中國則喜歡從大到小的順序（如 XX 省 XX 市 XX 區 XX 街道）。

實際上域名最後還有一個點，比如 `www.server.com.`，這個最後的一個點代表根域名。

也就是，`.` 根域是在最頂層，它的下一層就是 `.com` 頂級域，再下面是 `server.com`。

所以域名的層級關係類似一個樹狀結構：

- 根 DNS 服務器（.）
- 頂級域 DNS 服務器（.com）
- 權威 DNS 服務器（server.com）

![DNS 樹狀結構](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)


根域的 DNS 服務器信息保存在互聯網中所有的 DNS 服務器中。

這樣一來，任何 DNS 服務器就都可以找到並訪問根域 DNS 服務器了。

因此，客戶端只要能夠找到任意一臺 DNS 服務器，就可以通過它找到根域 DNS 服務器，然後再一路順藤摸瓜找到位於下層的某臺目標 DNS 服務器。

> 域名解析的工作流程

1. 客戶端首先會發出一個 DNS 請求，問 www.server.com 的 IP 是啥，併發給本地 DNS 服務器（也就是客戶端的 TCP/IP 設置中填寫的 DNS 服務器地址）。
2. 本地域名服務器收到客戶端的請求後，如果緩存裡的表格能找到 www.server.com，則它直接返回 IP 地址。如果沒有，本地 DNS 會去問它的根域名服務器：“老大， 能告訴我 www.server.com 的 IP 地址嗎？” 根域名服務器是最高層次的，它不直接用於域名解析，但能指明一條道路。 
3. 根 DNS 收到來自本地 DNS 的請求後，發現後置是 .com，說：“www.server.com 這個域名歸 .com 區域管理”，我把 .com 頂級域名服務器的地址給你，你去問問它吧。”
4. 本地 DNS 收到頂級域名服務器的地址後，發起請求問“老二， 你能告訴我 www.server.com  的 IP 地址嗎？”
5. 頂級域名服務器說：“我給你負責 www.server.com 區域的權威 DNS 服務器的地址，你去問它應該能問到”。
6. 本地 DNS 於是轉向問權威 DNS 服務器：“老三，www.server.com 對應的 IP 是啥呀？” server.com 的權威 DNS 服務器，它是域名解析結果的原出處。為啥叫權威呢？就是我的域名我做主。
7. 權威 DNS 服務器查詢後將對應的 IP 地址 X.X.X.X 告訴本地 DNS。
8. 本地 DNS 再將 IP 地址返回客戶端，客戶端和目標建立連接。


至此，我們完成了 DNS 的解析過程。現在總結一下，整個過程我畫成了一個圖。

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

DNS 域名解析的過程蠻有意思的，整個過程就和我們日常生活中找人問路的過程類似，**只指路不帶路**。

> 那是不是每次解析域名都要經過那麼多的步驟呢？

當然不是了，還有緩存這個東西的嘛。

瀏覽器會先看自身有沒有對這個域名的緩存，如果有，就直接返回，如果沒有，就去問操作系統，操作系統也會去看自己的緩存，如果有，就直接返回，如果沒有，再去 hosts 文件看，也沒有，才會去問「本地 DNS 服務器」。

> 數據包表示：“DNS 老大哥厲害呀，找到了目的地了！我還是很迷茫呀，我要發出去，接下來我需要誰的幫助呢?”

----

## 指南好幫手 —— 協議棧

通過 DNS 獲取到 IP 後，就可以把 HTTP 的傳輸工作交給操作系統中的**協議棧**。

協議棧的內部分為幾個部分，分別承擔不同的工作。上下關係是有一定的規則的，上面的部分會向下面的部分委託工作，下面的部分收到委託的工作並執行。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

應用程序（瀏覽器）通過調用 Socket 庫，來委託協議棧工作。協議棧的上半部分有兩塊，分別是負責收發數據的 TCP 和 UDP 協議，這兩個傳輸協議會接受應用層的委託執行收發數據的操作。

協議棧的下面一半是用 IP 協議控制網絡包收發操作，在互聯網上傳數據時，數據會被切分成一塊塊的網絡包，而將網絡包發送給對方的操作就是由 IP 負責的。

此外 IP 中還包括 `ICMP` 協議和 `ARP` 協議。

- `ICMP` 用於告知網絡包傳送過程中產生的錯誤以及各種控制信息。
- `ARP` 用於根據 IP 地址查詢相應的以太網 MAC 地址。

IP 下面的網卡驅動程序負責控制網卡硬件，而最下面的網卡則負責完成實際的收發操作，也就是對網線中的信號執行發送和接收操作。

> 數據包看了這份指南表示：“原來我需要那麼多大佬的協助啊，那我先去找找 TCP 大佬！”

----

## 可靠傳輸 —— TCP

HTTP 是基於 TCP 協議傳輸的，所以在這我們先了解下 TCP 協議。

> TCP 包頭格式

我們先看看 TCP 報文頭部的格式：

![TCP 包頭格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

首先，**源端口號**和**目標端口**號是不可少的，如果沒有這兩個端口號，數據就不知道應該發給哪個應用。

接下來有包的**序**號，這個是為瞭解決包亂序的問題。

還有應該有的是**確認號**，目的是確認發出去對方是否有收到。如果沒有收到就應該重新發送，直到送達，這個是為瞭解決不丟包的問題。

接下來還有一些**狀態位**。例如 `SYN` 是發起一個連接，`ACK` 是回覆，`RST` 是重新連接，`FIN` 是結束連接等。TCP 是面向連接的，因而雙方要維護連接的狀態，這些帶狀態位的包的發送，會引起雙方的狀態變更。

還有一個重要的就是**窗口大小**。TCP 要做**流量控制**，通信雙方各聲明一個窗口（緩存大小），標識自己當前能夠的處理能力，別發送的太快，撐死我，也別發的太慢，餓死我。

除了做流量控制以外，TCP還會做**擁塞控制**，對於真正的通路堵車不堵車，它無能為力，唯一能做的就是控制自己，也即控制發送的速度。不能改變世界，就改變自己嘛。

> TCP 傳輸數據之前，要先三次握手建立連接

在 HTTP 傳輸數據之前，首先需要 TCP 建立連接，TCP 連接的建立，通常稱為**三次握手**。

這個所謂的「連接」，只是雙方計算機裡維護一個狀態機，在連接建立的過程中，雙方的狀態變化時序圖就像這樣。

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/網絡/TCP三次握手.drawio.png)

- 一開始，客戶端和服務端都處於 `CLOSED` 狀態。先是服務端主動監聽某個端口，處於 `LISTEN` 狀態。

- 然後客戶端主動發起連接 `SYN`，之後處於 `SYN-SENT` 狀態。

- 服務端收到發起的連接，返回 `SYN`，並且 `ACK` 客戶端的 `SYN`，之後處於 `SYN-RCVD` 狀態。

- 客戶端收到服務端發送的 `SYN` 和 `ACK` 之後，發送對 `SYN` 確認的 `ACK`，之後處於 `ESTABLISHED` 狀態，因為它一發一收成功了。

- 服務端收到 `ACK` 的 `ACK` 之後，處於 `ESTABLISHED` 狀態，因為它也一發一收了。

所以三次握手目的是**保證雙方都有發送和接收的能力**。

> 如何查看 TCP 的連接狀態？

TCP 的連接狀態查看，在 Linux 可以通過 `netstat -napt` 命令查看。

![TCP 連接狀態查看](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg)

> TCP 分割數據

如果 HTTP 請求消息比較長，超過了 `MSS` 的長度，這時 TCP 就需要把 HTTP 的數據拆解成一塊塊的數據發送，而不是一次性發送所有數據。

![MTU 與 MSS](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)

- `MTU`：一個網絡包的最大長度，以太網中一般為 `1500` 字節。
- `MSS`：除去 IP 和 TCP 頭部之後，一個網絡包所能容納的 TCP 數據的最大長度。

數據會被以 `MSS` 的長度為單位進行拆分，拆分出來的每一塊數據都會被放進單獨的網絡包中。也就是在每個被拆分的數據加上 TCP 頭信息，然後交給 IP 模塊來發送數據。

![數據包分割](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

> TCP 報文生成

TCP 協議裡面會有兩個端口，一個是瀏覽器監聽的端口（通常是隨機生成的），一個是 Web 服務器監聽的端口（HTTP 默認端口號是 `80`， HTTPS 默認端口號是 `443`）。

在雙方建立了連接後，TCP 報文中的數據部分就是存放 HTTP 頭部 + 數據，組裝好 TCP 報文之後，就需交給下面的網絡層處理。

至此，網絡包的報文如下圖。

![TCP 層報文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)

> 此時，遇上了 TCP 的  數據包激動表示：“太好了，碰到了可靠傳輸的 TCP 傳輸，它給我加上 TCP 頭部，我不再孤單了，安全感十足啊！有大佬可以保護我的可靠送達！但我應該往哪走呢？”

---

## 遠程定位 —— IP

TCP 模塊在執行連接、收發、斷開等各階段操作時，都需要委託 IP 模塊將數據封裝成**網絡包**發送給通信對象。

> IP 包頭格式

我們先看看 IP 報文頭部的格式：

![IP 包頭格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

在 IP 協議裡面需要有**源地址 IP** 和 **目標地址 IP**：

- 源地址 IP，即是客戶端輸出的 IP 地址；
- 目標地址，即通過 DNS 域名解析得到的 Web 服務器 IP。

因為 HTTP 是經過 TCP 傳輸的，所以在 IP 包頭的**協議號**，要填寫為 `06`（十六進制），表示協議為 TCP。

> 假設客戶端有多個網卡，就會有多個 IP 地址，那 IP 頭部的源地址應該選擇哪個 IP 呢？

當存在多個網卡時，在填寫源地址 IP 時，就需要判斷到底應該填寫哪個地址。這個判斷相當於在多塊網卡中判斷應該使用哪個一塊網卡來發送包。

這個時候就需要根據**路由表**規則，來判斷哪一個網卡作為源地址 IP。

在 Linux 操作系統，我們可以使用 `route -n` 命令查看當前系統的路由表。

![路由表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/15.jpg)

舉個例子，根據上面的路由表，我們假設 Web 服務器的目標地址是 `192.168.10.200`。

![路由規則判斷](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg)

1. 首先先和第一條目的子網掩碼（`Genmask`）進行 **與運算**，得到結果為 `192.168.10.0`，但是第一個條目的 `Destination` 是 `192.168.3.0`，兩者不一致所以匹配失敗。
2. 再與第二條目的子網掩碼進行 **與運算**，得到的結果為 `192.168.10.0`，與第二條目的 `Destination 192.168.10.0` 匹配成功，所以將使用 `eth1` 網卡的 IP 地址作為 IP 包頭的源地址。

那麼假設 Web 服務器的目標地址是 `10.100.20.100`，那麼依然依照上面的路由表規則判斷，判斷後的結果是和第三條目匹配。

第三條目比較特殊，它目標地址和子網掩碼都是 `0.0.0.0`，這表示**默認網關**，如果其他所有條目都無法匹配，就會自動匹配這一行。並且後續就把包發給路由器，`Gateway` 即是路由器的 IP 地址。

> IP 報文生成

至此，網絡包的報文如下圖。

![IP 層報文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

> 此時，加上了 IP 頭部的數據包表示 ：“有 IP 大佬給我指路了，感謝 IP 層給我加上了 IP 包頭，讓我有了遠程定位的能力，不會害怕在浩瀚的互聯網迷茫了！可是目的地好遠啊，我下一站應該去哪呢？”

---

## 兩點傳輸 —— MAC

生成了 IP 頭部之後，接下來網絡包還需要在 IP 頭部的前面加上 **MAC 頭部**。

> MAC 包頭格式

MAC 頭部是以太網使用的頭部，它包含了接收方和發送方的 MAC 地址等信息。

![MAC 包頭格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

在 MAC 包頭裡需要**發送方 MAC 地址**和**接收方目標 MAC 地址**，用於**兩點之間的傳輸**。

一般在 TCP/IP 通信裡，MAC 包頭的**協議類型**只使用：

- `0800` ： IP 協議
- `0806` ： ARP 協議


> MAC 發送方和接收方如何確認?

**發送方**的 MAC 地址獲取就比較簡單了，MAC 地址是在網卡生產時寫入到 ROM 裡的，只要將這個值讀取出來寫入到 MAC 頭部就可以了。

**接收方**的 MAC 地址就有點複雜了，只要告訴以太網對方的 MAC 的地址，以太網就會幫我們把包發送過去，那麼很顯然這裡應該填寫對方的 MAC 地址。

所以先得搞清楚應該把包發給誰，這個只要查一下**路由表**就知道了。在路由表中找到相匹配的條目，然後把包發給 `Gateway` 列中的 IP 地址就可以了。

> 既然知道要發給誰，按如何獲取對方的 MAC 地址呢？

不知道對方 MAC 地址？不知道就喊唄。

此時就需要 `ARP` 協議幫我們找到路由器的 MAC 地址。

![ARP 廣播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

ARP 協議會在以太網中以**廣播**的形式，對以太網所有的設備喊出：“這個 IP 地址是誰的？請把你的 MAC 地址告訴我”。

然後就會有人回答：“這個 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果對方和自己處於同一個子網中，那麼通過上面的操作就可以得到對方的 MAC 地址。然後，我們將這個 MAC 地址寫入 MAC 頭部，MAC 頭部就完成了。

> 好像每次都要廣播獲取，這不是很麻煩嗎？

放心，在後續操作系統會把本次查詢結果放到一塊叫做 **ARP 緩存**的內存空間留著以後用，不過緩存的時間就幾分鐘。

也就是說，在發包時：

- 先查詢 ARP 緩存，如果其中已經保存了對方的 MAC 地址，就不需要發送 ARP 查詢，直接使用 ARP 緩存中的地址。
- 而當 ARP 緩存中不存在對方 MAC 地址時，則發送 ARP 廣播查詢。


> 查看 ARP 緩存內容

在 Linux 系統中，我們可以使用 `arp -a` 命令來查看 ARP 緩存的內容。

![ARP 緩存內容](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)


> MAC 報文生成

至此，網絡包的報文如下圖。

![MAC 層報文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)

> 此時，加上了 MAC 頭部的數據包萬分感謝，說道 ：“感謝 MAC 大佬，我知道我下一步要去哪了！我現在有很多頭部兄弟，相信我可以到達最終的目的地！”。
> 帶著眾多頭部兄弟的數據包，終於準備要出門了。

---

## 出口 —— 網卡

網絡包只是存放在內存中的一串二進制數字信息，沒有辦法直接發送給對方。因此，我們需要將**數字信息轉換為電信號**，才能在網線上傳輸，也就是說，這才是真正的數據發送過程。

負責執行這一操作的是**網卡**，要控制網卡還需要靠**網卡驅動程序**。

網卡驅動獲取網絡包之後，會將其**複製**到網卡內的緩存區中，接著會在其**開頭加上報頭和起始幀分界符，在末尾加上用於檢測錯誤的幀校驗序列**。

![數據包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/網絡/數據包.drawio.png)

- 起始幀分界符是一個用來表示包起始位置的標記
- 末尾的 `FCS`（幀校驗序列）用來檢查包傳輸過程是否有損壞

最後網卡會將包轉為電信號，通過網線發送出去。

> 唉，真是不容易，發一個包，真是歷經千辛萬苦。致此，一個帶有許多頭部的數據終於踏上尋找目的地的征途了！

---

## 送別者 —— 交換機

下面來看一下包是如何通過交換機的。交換機的設計是將網絡包**原樣**轉發到目的地。交換機工作在 MAC 層，也稱為**二層網絡設備**。

> 交換機的包接收操作

首先，電信號到達網線接口，交換機裡的模塊進行接收，接下來交換機裡的模塊將電信號轉換為數字信號。

然後通過包末尾的 `FCS` 校驗錯誤，如果沒問題則放到緩衝區。這部分操作基本和計算機的網卡相同，但交換機的工作方式和網卡不同。

計算機的網卡本身具有 MAC 地址，並通過核對收到的包的接收方 MAC 地址判斷是不是發給自己的，如果不是發給自己的則丟棄；相對地，交換機的端口不核對接收方 MAC 地址，而是直接接收所有的包並存放到緩衝區中。因此，和網卡不同，**交換機的端口不具有 MAC 地址**。

將包存入緩衝區後，接下來需要查詢一下這個包的接收方 MAC 地址是否已經在 MAC 地址表中有記錄了。

交換機的 MAC 地址表主要包含兩個信息：

- 一個是設備的 MAC 地址，
- 另一個是該設備連接在交換機的哪個端口上。

![交換機的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)


舉個例子，如果收到的包的接收方 MAC 地址為 `00-02-B3-1C-9C-F9`，則與圖中表中的第 3 行匹配，根據端口列的信息，可知這個地址位於 `3` 號端口上，然後就可以通過交換電路將包發送到相應的端口了。

所以，**交換機根據 MAC 地址表查找 MAC 地址，然後將信號發送到相應的端口**。

> 當 MAC 地址表找不到指定的 MAC 地址會怎麼樣？

地址表中找不到指定的 MAC 地址。這可能是因為具有該地址的設備還沒有向交換機發送過包，或者這個設備一段時間沒有工作導致地址被從地址表中刪除了。

這種情況下，交換機無法判斷應該把包轉發到哪個端口，只能將包轉發到除了源端口之外的所有端口上，無論該設備連接在哪個端口上都能收到這個包。

這樣做不會產生什麼問題，因為以太網的設計本來就是將包發送到整個網絡的，然後**只有相應的接收者才接收包，而其他設備則會忽略這個包**。

有人會說：“這樣做會發送多餘的包，會不會造成網絡擁塞呢？”

其實完全不用過於擔心，因為發送了包之後目標設備會作出響應，只要返回了響應包，交換機就可以將它的地址寫入 MAC 地址表，下次也就不需要把包發到所有端口了。

局域網中每秒可以傳輸上千個包，多出一兩個包並無大礙。

此外，如果接收方 MAC 地址是一個**廣播地址**，那麼交換機會將包發送到除源端口之外的所有端口。

以下兩個屬於廣播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

> 數據包通過交換機轉發抵達了路由器，準備要離開土生土長的子網了。此時，數據包和交換機離別時說道：“感謝交換機兄弟，幫我轉發到出境的大門，我要出遠門啦！”

---

## 出境大門 —— 路由器

> 路由器與交換機的區別

網絡包經過交換機之後，現在到達了**路由器**，並在此被轉發到下一個路由器或目標設備。

這一步轉發的工作原理和交換機類似，也是通過查表判斷包轉發的目標。

不過在具體的操作過程上，路由器和交換機是有區別的。

- 因為**路由器**是基於 IP 設計的，俗稱**三層**網絡設備，路由器的各個端口都具有 MAC 地址和 IP 地址；
- 而**交換機**是基於以太網設計的，俗稱**二層**網絡設備，交換機的端口不具有 MAC 地址。

> 路由器基本原理

路由器的端口具有 MAC 地址，因此它就能夠成為以太網的發送方和接收方；同時還具有 IP 地址，從這個意義上來說，它和計算機的網卡是一樣的。

當轉發包時，首先路由器端口會接收發給自己的以太網包，然後**路由表**查詢轉發目標，再由相應的端口作為發送方將以太網包發送出去。

> 路由器的包接收操作

首先，電信號到達網線接口部分，路由器中的模塊會將電信號轉成數字信號，然後通過包末尾的 `FCS` 進行錯誤校驗。

如果沒問題則檢查 MAC 頭部中的**接收方 MAC 地址**，看看是不是發給自己的包，如果是就放到接收緩衝區中，否則就丟棄這個包。

總的來說，路由器的端口都具有 MAC 地址，只接收與自身地址匹配的包，遇到不匹配的包則直接丟棄。

> 查詢路由表確定輸出端口

完成包接收操作之後，路由器就會**去掉**包開頭的 MAC 頭部。

**MAC 頭部的作用就是將包送達路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，當包到達路由器之後，MAC 頭部的任務就完成了，於是 MAC 頭部就會**被丟棄**。

接下來，路由器會根據 MAC 頭部後方的 `IP` 頭部中的內容進行包的轉發操作。

轉發操作分為幾個階段，首先是查詢**路由表**判斷轉發目標。

![路由器轉發](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg)

具體的工作流程根據上圖，舉個例子。

假設地址為 `10.10.1.101` 的計算機要向地址為 `192.168.1.100` 的服務器發送一個包，這個包先到達圖中的路由器。

判斷轉發目標的第一步，就是根據包的接收方 IP 地址查詢路由表中的目標地址欄，以找到相匹配的記錄。

路由匹配和前面講的一樣，每個條目的子網掩碼和 `192.168.1.100` IP 做 **& 與運算**後，得到的結果與對應條目的目標地址進行匹配，如果匹配就會作為候選轉發目標，如果不匹配就繼續與下個條目進行路由匹配。

如第二條目的子網掩碼 `255.255.255.0` 與 `192.168.1.100` IP 做 **& 與運算**後，得到結果是 `192.168.1.0` ，這與第二條目的目標地址 `192.168.1.0` 匹配，該第二條目記錄就會被作為轉發目標。

實在找不到匹配路由時，就會選擇**默認路由**，路由表中子網掩碼為 `0.0.0.0` 的記錄表示「默認路由」。

> 路由器的發送操作

接下來就會進入包的**發送操作**。

首先，我們需要根據**路由表的網關列**判斷對方的地址。

- 如果網關是一個 IP 地址，則這個IP 地址就是我們要轉發到的目標地址，**還未抵達終點**，還需繼續需要路由器轉發。
- 如果網關為空，則 IP 頭部中的接收方 IP 地址就是要轉發到的目標地址，也是就終於找到 IP 包頭裡的目標地址了，說明**已抵達終點**。

知道對方的 IP 地址之後，接下來需要通過 `ARP` 協議根據 IP 地址查詢 MAC 地址，並將查詢的結果作為接收方 MAC 地址。

路由器也有 ARP 緩存，因此首先會在 ARP 緩存中查詢，如果找不到則發送 ARP 查詢請求。

接下來是發送方 MAC 地址字段，這裡填寫輸出端口的 MAC 地址。還有一個以太類型字段，填寫 `0800` （十六進制）表示 IP 協議。

網絡包完成後，接下來會將其轉換成電信號並通過端口發送出去。這一步的工作過程和計算機也是相同的。

發送出去的網絡包會通過**交換機**到達下一個路由器。由於接收方 MAC 地址就是下一個路由器的地址，所以交換機會根據這一地址將包傳輸到下一個路由器。

接下來，下一個路由器會將包轉發給再下一個路由器，經過層層轉發之後，網絡包就到達了最終的目的地。

不知你發現了沒有，在網絡包傳輸的過程中，**源 IP 和目標 IP 始終是不會變的，一直變化的是 MAC 地址**，因為需要 MAC 地址在以太網內進行**兩個設備**之間的包傳輸。

> 數據包通過多個路由器道友的幫助，在網絡世界途經了很多路程，最終抵達了目的地的城門！城門值守的路由器，發現了這個小兄弟數據包原來是找城內的人，於是它就將數據包送進了城內，再經由城內的交換機幫助下，最終轉發到了目的地了。數據包感慨萬千的說道：“多謝這一路上，各路大俠的相助！”

---

## 互相扒皮 —— 服務器 與 客戶端

數據包抵達了服務器，服務器肯定高興呀，正所謂有朋自遠方來，不亦樂乎？

服務器高興的不得了，於是開始扒數據包的皮！就好像你收到快遞，能不興奮嗎？

![網絡分層模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)

數據包抵達服務器後，服務器會先扒開數據包的 MAC 頭部，查看是否和服務器自己的 MAC 地址符合，符合就將包收起來。

接著繼續扒開數據包的 IP 頭，發現 IP 地址符合，根據 IP 頭中協議項，知道自己上層是 TCP 協議。

於是，扒開 TCP 的頭，裡面有序列號，需要看一看這個序列包是不是我想要的，如果是就放入緩存中然後返回一個 ACK，如果不是就丟棄。TCP 頭部裡面還有端口號， HTTP 的服務器正在監聽這個端口號。

於是，服務器自然就知道是 HTTP 進程想要這個包，於是就將包發給 HTTP 進程。

服務器的 HTTP 進程看到，原來這個請求是要訪問一個頁面，於是就把這個網頁封裝在 HTTP 響應報文裡。

HTTP 響應報文也需要穿上 TCP、IP、MAC 頭部，不過這次是源地址是服務器 IP 地址，目的地址是客戶端 IP 地址。

穿好頭部衣服後，從網卡出去，交由交換機轉發到出城的路由器，路由器就把響應數據包發到了下一個路由器，就這樣跳啊跳。

最後跳到了客戶端的城門把守的路由器，路由器扒開 IP 頭部發現是要找城內的人，於是又把包發給了城內的交換機，再由交換機轉發到客戶端。

客戶端收到了服務器的響應數據包後，同樣也非常的高興，客戶能拆快遞了！

於是，客戶端開始扒皮，把收到的數據包的皮扒剩 HTTP 響應報文後，交給瀏覽器去渲染頁面，一份特別的數據包快遞，就這樣顯示出來了！

最後，客戶端要離開了，向服務器發起了 TCP 四次揮手，至此雙方的連接就斷開了。

----

## 一個數據包臭不要臉的感受

> 下面內容的 「我」，代表「臭美的數據包角色」。注：（括號的內容）代表我的吐槽，三連呸！

我一開始我雖然孤單、不知所措，但沒有停滯不前。我依然滿懷信心和勇氣開始了征途。（**你當然有勇氣，你是應用層數據，後面有底層兄弟當靠山，我呸！**）

我很慶幸遇到了各路神通廣大的大佬，有可靠傳輸的 TCP、有遠程定位功能的 IP、有指明下一站位置的 MAC 等（**你當然會遇到，因為都被計算機安排好的，我呸！**）。

這些大佬都給我前面加上了頭部，使得我能在交換機和路由器的轉發下，抵達到了目的地！（**哎，你也不容易，不吐槽了，放過你！**）

這一路上的經歷，讓我認識到了網絡世界中各路大俠協作的重要性，是他們維護了網絡世界的秩序，感謝他們！（**我呸，你應該感謝眾多計算機科學家！**）

----

參考資料

[1] 戶根勤.網絡是怎麼連接的.人民郵電出版社.

[2] 劉超.趣談網絡協議.極客時間.

----

## 讀者問答

> 讀者問：“筆記本的是自帶交換機的嗎？交換機現在我還不知道是什麼”

筆記本不是交換機，交換機通常是2個網口以上。

現在家裡的路由器其實有了交換機的功能了。交換機可以簡單理解成一個設備，三臺電腦網線接到這個設備，這三臺電腦就可以互相通信了，交換機嘛，交換數據這麼理解就可以。

> 讀者問：“如果知道你電腦的 Mac 地址，我可以直接給你發消息嗎？”

Mac 地址只能是兩個設備之間傳遞時使用的，如果你要從大老遠給我發消息，是離不開 IP 的。

> 讀者問：“請問公網服務器的 Mac 地址是在什麼時機通過什麼方式獲取到的？我看 ARP 獲取 Mac 地址只能獲取到內網機器的 Mac 地址吧？”

在發送數據包時，如果目標主機不是本地局域網，填入的 Mac 地址是路由器，也就是把數據包轉發給路由器，路由器一直轉發下一個路由器，直到轉發到目標主機的路由器，發現 IP 地址是自己局域網內的主機，就會 ARP 請求獲取目標主機的 Mac 地址，從而轉發到這個服務器主機。

轉發的過程中，源 IP 地址和目標 IP 地址是不會變的（前提：沒有使用 NAT 網絡的），源 MAC 地址和目標 MAC 地址是會變化的。

---

哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，別忘記關注我哦！

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)

