# 4.13 拔掉網線後， 原本的 TCP 連接還存在嗎？

大家好，我是小林。

今天，聊一個有趣的問題：**拔掉網線幾秒，再插回去，原本的 TCP 連接還存在嗎？**

可能有的同學會說，網線都被拔掉了，那說明物理層被斷開了，那在上層的傳輸層理應也會斷開，所以原本的 TCP 連接就不會存在的了。就好像， 我們撥打有線電話的時候，如果某一方的電話線被拔了，那麼本次通話就徹底斷了。

真的是這樣嗎？

上面這個邏輯就有問題。問題在於，錯誤的認為拔掉網線這個動作會影響傳輸層，事實上並不會影響。

實際上，TCP 連接在 Linux 內核中是一個名為 `struct socket` 的結構體，該結構體的內容包含 TCP 連接的狀態等信息。當拔掉網線的時候，操作系統並不會變更該結構體的任何內容，所以 TCP 連接的狀態也不會發生改變。

我在我的電腦上做了個小實驗，我用 ssh 終端連接了我的雲服務器，然後我通過斷開 wifi 的方式來模擬拔掉網線的場景，此時查看 TCP 連接的狀態沒有發生變化，還是處於 ESTABLISHED 狀態。

![圖片](https://img-blog.csdnimg.cn/img_convert/fff358407ee92aeea1e17386191a5d18.png)

通過上面這個實驗結果，我們知道了，拔掉網線這個動作並不會影響 TCP 連接的狀態。

接下來，要看拔掉網線後，雙方做了什麼動作。

所以， 針對這個問題，要分場景來討論：

- 拔掉網線後，有數據傳輸；
- 拔掉網線後，沒有數據傳輸；

## 拔掉網線後，有數據傳輸

在客戶端拔掉網線後，服務端向客戶端發送的數據報文會得不到任何的響應，在等待一定時長後，服務端就會觸發**超時重傳**機制，重傳未得到響應的數據報文。

**如果在服務端重傳報文的過程中，客戶端剛好把網線插回去了**，由於拔掉網線並不會改變客戶端的 TCP 連接狀態，並且還是處於 ESTABLISHED 狀態，所以這時客戶端是可以正常接收服務端發來的數據報文的，然後客戶端就會回 ACK 響應報文。

此時，客戶端和服務端的 TCP 連接依然存在的，就感覺什麼事情都沒有發生。

但是，**如果如果在服務端重傳報文的過程中，客戶端一直沒有將網線插回去**，服務端超時重傳報文的次數達到一定閾值後，內核就會判定出該 TCP 有問題，然後通過 Socket 接口告訴應用程序該 TCP 連接出問題了，於是服務端的 TCP 連接就會斷開。

而等客戶端插回網線後，如果客戶端向服務端發送了數據，由於服務端已經沒有與客戶端相同四元祖的 TCP 連接了，因此服務端內核就會回覆 RST 報文，客戶端收到後就會釋放該 TCP 連接。

此時，客戶端和服務端的 TCP 連接都已經斷開了。

> 那 TCP 的數據報文具體重傳幾次呢？

在 Linux 系統中，提供了一個叫 tcp_retries2 配置項，默認值是 15，如下圖：

![圖片](https://img-blog.csdnimg.cn/img_convert/f92c00c7e9cd01e89326e943232e5f04.png)

這個內核參數是控制，在 TCP 連接建立的情況下，超時重傳的最大次數。

不過 tcp_retries2 設置了 15 次，並不代表 TCP 超時重傳了 15 次才會通知應用程序終止該 TCP 連接，**內核會根據 tcp_retries2 設置的值，計算出一個 timeout**（*如果 tcp_retries2 =15，那麼計算得到的 timeout = 924600 ms*），**如果重傳間隔超過這個 timeout，則認為超過了閾值，就會停止重傳，然後就會斷開 TCP 連接**。

在發生超時重傳的過程中，每一輪的超時時間（RTO）都是**倍數增長**的，比如如果第一輪 RTO 是 200 毫秒，那麼第二輪 RTO 是 400 毫秒，第三輪 RTO 是 800 毫秒，以此類推。

而 RTO 是基於 RTT（一個包的往返時間） 來計算的，如果 RTT 較大，那麼計算出來的 RTO 就越大，那麼經過幾輪重傳後，很快就達到了上面的 timeout 值了。

舉個例子，如果 tcp_retries2 =15，那麼計算得到的 timeout = 924600 ms，如果重傳總間隔時長達到了 timeout 就會停止重傳，然後就會斷開 TCP 連接：

- 如果 RTT 比較小，那麼 RTO 初始值就約等於下限 200ms，也就是第一輪的超時時間是 200 毫秒，由於 timeout 總時長是 924600 ms，表現出來的現象剛好就是重傳了 15 次，超過了 timeout 值，從而斷開 TCP 連接
- 如果 RTT 比較大，假設 RTO 初始值計算得到的是 1000 ms，也就是第一輪的超時時間是 1 秒，那麼根本不需要重傳 15 次，重傳總間隔就會超過 924600 ms。

最小 RTO 和最大 RTO 是在 Linux 內核中定義好了：

```c
#define TCP_RTO_MAX ((unsigned)(120*HZ))
#define TCP_RTO_MIN ((unsigned)(HZ/5))
```

Linux 2.6+ 使用 1000 毫秒的 HZ，因此`TCP_RTO_MIN`約為 200 毫秒，`TCP_RTO_MAX`約為 120 秒。

如果`tcp_retries`設置為`15`，且  RTT 比較小，那麼 RTO 初始值就約等於下限 200ms，這意味著**它需要 924.6 秒**才能將斷開的 TCP 連接通知給上層（即應用程序），每一輪的 RTO 增長關係如下表格：

![](https://img-blog.csdnimg.cn/img_convert/10fa6882db83aee68f246c04fcb7d760.png)

## 拔掉網線後，沒有數據傳輸

針對拔掉網線後，沒有數據傳輸的場景，還得看是否開啟了 TCP keepalive 機制 （TCP 保活機制）。

如果**沒有開啟** TCP keepalive 機制，在客戶端拔掉網線後，並且雙方都沒有進行數據傳輸，那麼客戶端和服務端的 TCP 連接將會一直保持存在。

而如果**開啟**了 TCP keepalive 機制，在客戶端拔掉網線後，即使雙方都沒有進行數據傳輸，在持續一段時間後，TCP 就會發送探測報文：

- 如果**對端是正常工作**的。當 TCP 保活的探測報文發送給對端, 對端會正常響應，這樣 **TCP 保活時間會被重置**，等待下一個 TCP 保活時間的到來。
- 如果**對端主機宕機**（*注意不是進程崩潰，進程崩潰後操作系統在回收進程資源的時候，會發送 FIN 報文，而主機宕機則是無法感知的，所以需要 TCP 保活機制來探測對方是不是發生了主機宕機*），或對端由於其他原因導致報文不可達。當 TCP 保活的探測報文發送給對端後，石沉大海，沒有響應，連續幾次，達到保活探測次數後，**TCP 會報告該 TCP 連接已經死亡**。

所以，TCP 保活機制可以在雙方沒有數據交互的情況，通過探測報文，來確定對方的 TCP 連接是否存活。

> TCP keepalive 機制具體是怎麼樣的？

這個機制的原理是這樣的：

定義一個時間段，在這個時間段內，如果沒有任何連接相關的活動，TCP 保活機制會開始作用，每隔一個時間間隔，發送一個探測報文，該探測報文包含的數據非常少，如果連續幾個探測報文都沒有得到響應，則認為當前的 TCP 連接已經死亡，系統內核將錯誤信息通知給上層應用程序。

在 Linux 內核可以有對應的參數可以設置保活時間、保活探測的次數、保活探測的時間間隔，以下都為默認值：

```
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9
```

- tcp_keepalive_time=7200：表示保活時間是 7200 秒（2小時），也就 2 小時內如果沒有任何連接相關的活動，則會啟動保活機制
- tcp_keepalive_intvl=75：表示每次檢測間隔 75 秒；
- tcp_keepalive_probes=9：表示檢測 9 次無響應，認為對方是不可達的，從而中斷本次的連接。

也就是說在 Linux 系統中，最少需要經過 2 小時 11 分 15 秒才可以發現一個「死亡」連接。

![](https://img-blog.csdnimg.cn/img_convert/46906e588260607680db43a68fe00278.png)

注意，應用程序若想使用 TCP 保活機制需要通過 socket 接口設置 `SO_KEEPALIVE` 選項才能夠生效，如果沒有設置，那麼就無法使用 TCP 保活機制。

> TCP keepalive 機制探測的時間也太長了吧？

對的，是有點長。

TCP keepalive  是 **TCP 層（內核態）** 實現的，它是給所有基於 TCP 傳輸協議的程序一個兜底的方案。

實際上，我們應用層可以自己實現一套探測機制，可以在較短的時間內，探測到對方是否存活。

比如，web 服務軟件一般都會提供 `keepalive_timeout` 參數，用來指定 HTTP 長連接的超時時間。如果設置了 HTTP 長連接的超時時間是 60 秒，web 服務軟件就會**啟動一個定時器**，如果客戶端在完後一個 HTTP 請求後，在 60 秒內都沒有再發起新的請求，**定時器的時間一到，就會觸發回調函數來釋放該連接。**

![圖片](https://img-blog.csdnimg.cn/img_convert/c881f163091a4c6427d68b7144c3a980.png)

## 總結

客戶端拔掉網線後，並不會直接影響 TCP 連接狀態。所以，拔掉網線後，TCP 連接是否還會存在，關鍵要看拔掉網線之後，有沒有進行數據傳輸。

有數據傳輸的情況：

- 在客戶端拔掉網線後，如果服務端發送了數據報文，那麼在服務端重傳次數沒有達到最大值之前，客戶端就插回了網線，那麼雙方原本的 TCP 連接還是能正常存在，就好像什麼事情都沒有發生。
- 在客戶端拔掉網線後，如果服務端發送了數據報文，在客戶端插回網線之前，服務端重傳次數達到了最大值時，服務端就會斷開 TCP 連接。等到客戶端插回網線後，向服務端發送了數據，因為服務端已經斷開了與客戶端相同四元組的 TCP 連接，所以就會回 RST 報文，客戶端收到後就會斷開 TCP 連接。至此， 雙方的 TCP 連接都斷開了。

沒有數據傳輸的情況：

- 如果雙方都沒有開啟 TCP keepalive 機制，那麼在客戶端拔掉網線後，如果客戶端一直不插回網線，那麼客戶端和服務端的 TCP 連接狀態將會一直保持存在。
- 如果雙方都開啟了 TCP keepalive 機制，那麼在客戶端拔掉網線後，如果客戶端一直不插回網線，TCP keepalive 機制會探測到對方的 TCP 連接沒有存活，於是就會斷開 TCP 連接。而如果在 TCP 探測期間，客戶端插回了網線，那麼雙方原本的 TCP 連接還是能正常存在。

除了客戶端拔掉網線的場景，還有客戶端「[主機宕機和進程崩潰](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html)」的兩種場景。

第一個場景，客戶端宕機這件事跟拔掉網線是一樣無法被服務端的感知的，所以如果在沒有數據傳輸，並且沒有開啟 TCP keepalive 機制時，，**服務端的 TCP 連接將會一直處於 ESTABLISHED 連接狀態**，直到服務端重啟進程。

所以，我們可以得知一個點。在沒有使用 TCP 保活機制，且雙方不傳輸數據的情況下，一方的 TCP 連接處在 ESTABLISHED 狀態時，並不代表另一方的 TCP 連接還一定是正常的。

第二個場景，客戶端的進程崩潰後，客戶端的內核就會向服務端發送 FIN 報文，**與服務端進行四次揮手**。

所以，即使沒有開啟 TCP keepalive，且雙方也沒有數據交互的情況下，如果其中一方的進程發生了崩潰，這個過程操作系統是可以感知的到的，於是就會發送 FIN 報文給對方，然後與對方進行 TCP 四次揮手。

完！

---

最新的圖解文章都在公眾號首發，別忘記關注哦！！如果你想加入百人技術交流群，掃碼下方二維碼回覆「加群」。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)