# 4.6 如何理解是 TCP 面向字節流協議？

有個讀者問我，這麼個問題：

> TCP 是面向字節流的協議，UDP 是面向報文的協議？這裡的「面向字節流」和「面向報文」該如何理解。


------

## 如何理解字節流？

之所以會說 TCP 是面向字節流的協議，UDP 是面向報文的協議，是因為操作系統對 TCP 和 UDP 協議的**發送方的機制不同**，也就是問題原因在發送方。

> 先來說說為什麼 UDP 是面向報文的協議？

當用戶消息通過 UDP 協議傳輸時，**操作系統不會對消息進行拆分**，在組裝好 UDP 頭部後就交給網絡層來處理，所以發出去的 UDP 報文中的數據部分就是完整的用戶消息，也就是**每個 UDP 報文就是一個用戶消息的邊界**，這樣接收方在接收到 UDP 報文後，讀一個 UDP 報文就能讀取到完整的用戶消息。

你可能會問，如果收到了兩個 UDP 報文，操作系統是怎麼區分開的？

操作系統在收到 UDP 報文後，會將其插入到隊列裡，**隊列裡的每一個元素就是一個 UDP 報文**，這樣當用戶調用 recvfrom() 系統調用讀數據的時候，就會從隊列裡取出一個數據，然後從內核裡拷貝給用戶緩衝區。

![圖片](https://img-blog.csdnimg.cn/img_convert/a9116c5b375d356048df033dcb53582e.png)



> 再來說說為什麼 TCP 是面向字節流的協議？

當用戶消息通過 TCP 協議傳輸時，**消息可能會被操作系統分組成多個的 TCP 報文**，也就是一個完整的用戶消息被拆分成多個 TCP 報文進行傳輸。

這時，接收方的程序如果不知道發送方發送的消息的長度，也就是不知道消息的邊界時，是無法讀出一個有效的用戶消息的，因為用戶消息被拆分成多個 TCP 報文後，並不能像 UDP 那樣，一個 UDP 報文就能代表一個完整的用戶消息。

舉個實際的例子來說明。

發送方準備發送 「Hi.」和「I am Xiaolin」這兩個消息。

在發送端，當我們調用 send 函數完成數據“發送”以後，數據並沒有被真正從網絡上發送出去，只是從應用程序拷貝到了操作系統內核協議棧中。

至於什麼時候真正被髮送，**取決於發送窗口、擁塞窗口以及當前發送緩衝區的大小等條件**。也就是說，我們不能認為每次 send 調用發送的數據，都會作為一個整體完整地消息被髮送出去。

如果我們考慮實際網絡傳輸過程中的各種影響，假設發送端陸續調用 send 函數先後發送 「Hi.」和「I am Xiaolin」 報文，那麼實際的發送很有可能是這幾種情況。

第一種情況，這兩個消息被分到同一個 TCP 報文，像這樣：

![圖片](https://img-blog.csdnimg.cn/img_convert/02dce678f870c8c70482b6e37dbb5574.png)

第二種情況，「I am Xiaolin」的部分隨 「Hi」 在一個 TCP 報文中發送出去，像這樣：

![圖片](https://img-blog.csdnimg.cn/img_convert/f58b70cde860188b8f95a433e2f5293b.png)

第三種情況，「Hi.」 的一部分隨 TCP 報文被髮送出去，另一部分和 「I am Xiaolin」 一起隨另一個 TCP 報文發送出去，像這樣。

![圖片](https://img-blog.csdnimg.cn/img_convert/68080e783d7acc842fa254e4f9ec5630.png)

類似的情況還能舉例很多種，這裡主要是想說明，我們不知道 「Hi.」和 「I am Xiaolin」 這兩個用戶消息是如何進行 TCP 分組傳輸的。

因此，**我們不能認為一個用戶消息對應一個 TCP 報文，正因為這樣，所以 TCP 是面向字節流的協議**。

當兩個消息的某個部分內容被分到同一個 TCP 報文時，就是我們常說的 TCP 粘包問題，這時接收方不知道消息的邊界的話，是無法讀出有效的消息。

要解決這個問題，要交給**應用程序**。

## 如何解決粘包？

粘包的問題出現是因為不知道一個用戶消息的邊界在哪，如果知道了邊界在哪，接收方就可以通過邊界來劃分出有效的用戶消息。

一般有三種方式分包的方式：

- 固定長度的消息；
- 特殊字符作為邊界；
- 自定義消息結構。

#### 固定長度的消息

這種是最簡單方法，即每個用戶消息都是固定長度的，比如規定一個消息的長度是 64 個字節，當接收方接滿 64 個字節，就認為這個內容是一個完整且有效的消息。

但是這種方式靈活性不高，實際中很少用。

### 特殊字符作為邊界

我們可以在兩個用戶消息之間插入一個特殊的字符串，這樣接收方在接收數據時，讀到了這個特殊字符，就把認為已經讀完一個完整的消息。

HTTP 是一個非常好的例子。

![圖片](https://img-blog.csdnimg.cn/img_convert/a49a6bb8cd38ae1738d9c00aec68b444.png)

HTTP 通過設置回車符、換行符作為 HTTP 報文協議的邊界。

有一點要注意，這個作為邊界點的特殊字符，如果剛好消息內容裡有這個特殊字符，我們要對這個字符轉義，避免被接收方當作消息的邊界點而解析到無效的數據。

### 自定義消息結構

我們可以自定義一個消息結構，由包頭和數據組成，其中包頭包是固定大小的，而且包頭裡有一個字段來說明緊隨其後的數據有多大。

比如這個消息結構體，首先 4 個字節大小的變量來表示數據長度，真正的數據則在後面。

```c
struct { 
    u_int32_t message_length; 
    char message_data[]; 
} message;
```

當接收方接收到包頭的大小（比如 4 個字節）後，就解析包頭的內容，於是就可以知道數據的長度，然後接下來就繼續讀取數據，直到讀滿數據的長度，就可以組裝成一個完整到用戶消息來處理了。