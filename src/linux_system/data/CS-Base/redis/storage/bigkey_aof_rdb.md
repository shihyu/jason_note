# Redis 大 Key 對持久化有什麼影響？

大家好，我是小林。

上週有位讀者字節一二面時，被問到：**Redis 的大 Key 對持久化有什麼影響？**

![·](https://img-blog.csdnimg.cn/2ae06f60d9614da0be4729944b2a317c.png)

Redis 的持久化方式有兩種：AOF 日誌和 RDB 快照。

所以接下來，針對這兩種持久化方式具體分析分析。

## 大 Key 對 AOF 日誌的影響

> 先說說 AOF 日誌三種寫回磁盤的策略

Redis 提供了 3 種 AOF 日誌寫回硬盤的策略，分別是：
- Always，這個單詞的意思是「總是」，所以它的意思是每次寫操作命令執行完後，同步將 AOF 日誌數據寫回硬盤；
- Everysec，這個單詞的意思是「每秒」，所以它的意思是每次寫操作命令執行完後，先將命令寫入到 AOF 文件的內核緩衝區，然後每隔一秒將緩衝區裡的內容寫回到硬盤；
- No，意味著不由 Redis 控制寫回硬盤的時機，轉交給操作系統控制寫回的時機，也就是每次寫操作命令執行完後，先將命令寫入到 AOF 文件的內核緩衝區，再由操作系統決定何時將緩衝區內容寫回硬盤。

這三種策略只是在控制 fsync() 函數的調用時機。

當應用程序向文件寫入數據時，內核通常先將數據複製到內核緩衝區中，然後排入隊列，然後由內核決定何時寫入硬盤。

![](https://img-blog.csdnimg.cn/def7d5328829470c9f3cfd15bbcc6814.png)


如果想要應用程序向文件寫入數據後，能立馬將數據同步到硬盤，就可以調用 fsync() 函數，這樣內核就會將內核緩衝區的數據直接寫入到硬盤，等到硬盤寫操作完成後，該函數才會返回。

- Always 策略就是每次寫入 AOF 文件數據後，就執行 fsync() 函數；
- Everysec 策略就會創建一個異步任務來執行 fsync() 函數；
- No 策略就是永不執行 fsync() 函數;


> 分別說說這三種策略，在持久化大 Key 的時候，會影響什麼？

在使用 Always 策略的時候，主線程在執行完命令後，會把數據寫入到 AOF 日誌文件，然後會調用  fsync() 函數，將內核緩衝區的數據直接寫入到硬盤，等到硬盤寫操作完成後，該函數才會返回。

**當使用 Always 策略的時候，如果寫入是一個大 Key，主線程在執行 fsync() 函數的時候，阻塞的時間會比較久，因為當寫入的數據量很大的時候，數據同步到硬盤這個過程是很耗時的**。



當使用 Everysec 策略的時候，由於是異步執行 fsync() 函數，所以大 Key 持久化的過程（數據同步磁盤）不會影響主線程。

當使用 No 策略的時候，由於永不執行 fsync() 函數，所以大 Key 持久化的過程不會影響主線程。


## 大 Key 對 AOF 重寫和 RDB 的影響

當 AOF 日誌寫入了很多的大 Key，AOF 日誌文件的大小會很大，那麼很快就會觸發 **AOF 重寫機制**。

AOF 重寫機制和 RDB 快照（bgsave 命令）的過程，都會分別通過 `fork()` 函數創建一個子進程來處理任務。

在創建子進程的過程中，操作系統會把父進程的「頁表」複製一份給子進程，這個頁表記錄著虛擬地址和物理地址映射關係，而不會複製物理內存，也就是說，兩者的虛擬空間不同，但其對應的物理空間是同一個。

![](https://img-blog.csdnimg.cn/06657cb93ffa4a24b8fc5b3069cb29bf.png)
這樣一來，子進程就共享了父進程的物理內存數據了，這樣能夠節約物理內存資源，頁表對應的頁表項的屬性會標記該物理內存的權限為**只讀**。

隨著 Redis 存在越來越多的大 Key，那麼 Redis 就會佔用很多內存，對應的頁表就會越大。

在通過  `fork()`  函數創建子進程的時候，雖然不會複製父進程的物理內存，但是**內核會把父進程的頁表複製一份給子進程，如果頁表很大，那麼這個複製過程是會很耗時的，那麼在執行 fork 函數的時候就會發生阻塞現象**。

而且，fork 函數是由 Redis 主線程調用的，如果 fork 函數發生阻塞，那麼意味著就會阻塞 Redis 主線程。由於 Redis 執行命令是在主線程處理的，所以當 Redis 主線程發生阻塞，就無法處理後續客戶端發來的命令。

我們可以執行 `info ` 命令獲取到 latest_fork_usec 指標，表示 Redis 最近一次 fork 操作耗時。

```sql
# 最近一次 fork 操作耗時
latest_fork_usec:315
```
如果 fork 耗時很大，比如超過1秒，則需要做出優化調整：
- 單個實例的內存佔用控制在 10 GB 以下，這樣 fork 函數就能很快返回。
-  如果 Redis 只是當作純緩存使用，不關心 Redis 數據安全性問題，可以考慮關閉 AOF 和 AOF 重寫，這樣就不會調用 fork 函數了。
- 在主從架構中，要適當調大 repl-backlog-size，避免因為  repl_backlog_buffer 不夠大，導致主節點頻繁地使用全量同步的方式，全量同步的時候，是會創建 RDB 文件的，也就是會調用 fork 函數。


> 那什麼時候會發生物理內存的複製呢？


當父進程或者子進程在向共享內存發起寫操作時，CPU 就會觸發**缺頁中斷**，這個缺頁中斷是由於違反權限導致的，然後操作系統會在「缺頁異常處理函數」裡進行物理內存的複製，並重新設置其內存映射關係，將父子進程的內存讀寫權限設置為可讀寫，最後才會對內存進行寫操作，這個過程被稱為「**寫時複製(Copy On Write)**」。

![](https://img-blog.csdnimg.cn/451024fe10374431aff6f93a8fed4638.png)

寫時複製顧名思義，在發生寫操作的時候，操作系統才會去複製物理內存，這樣是為了防止 fork 創建子進程時，由於物理內存數據的複製時間過長而導致父進程長時間阻塞的問題。

如果創建完子進程後，**父進程對共享內存中的大 Key 進行了修改，那麼內核就會發生寫時複製，會把物理內存複製一份，由於大 Key 佔用的物理內存是比較大的，那麼在複製物理內存這一過程中，也是比較耗時的，於是父進程（主線程）就會發生阻塞**。

所以，有兩個階段會導致阻塞父進程：

- 創建子進程的途中，由於要複製父進程的頁表等數據結構，阻塞的時間跟頁表的大小有關，頁表越大，阻塞的時間也越長；
- 創建完子進程後，如果子進程或者父進程修改了共享數據，就會發生寫時複製，這期間會拷貝物理內存，如果內存越大，自然阻塞的時間也越長；

這裡額外提一下， 如果 **Linux 開啟了內存大頁，會影響 Redis 的性能的**。

Linux 內核從 2.6.38 開始支持內存大頁機制，該機制支持 2MB 大小的內存頁分配，而常規的內存頁分配是按 4KB 的粒度來執行的。


如果採用了內存大頁，那麼即使客戶端請求只修改 100B 的數據，在發生寫時複製後，Redis 也需要拷貝 2MB 的大頁。相反，如果是常規內存頁機制，只用拷貝 4KB。

兩者相比，你可以看到，每次寫命令引起的**複製內存頁單位放大了 512 倍，會拖慢寫操作的執行時間，最終導致 Redis 性能變慢**。

那該怎麼辦呢？很簡單，關閉內存大頁（默認是關閉的）。

禁用方法如下：

```shell
echo never >  /sys/kernel/mm/transparent_hugepage/enabled
```


## 總結

當 AOF 寫回策略配置了 Always 策略，如果寫入是一個大 Key，主線程在執行 fsync() 函數的時候，阻塞的時間會比較久，因為當寫入的數據量很大的時候，數據同步到硬盤這個過程是很耗時的。


AOF 重寫機制和 RDB 快照（bgsave 命令）的過程，都會分別通過 `fork()` 函數創建一個子進程來處理任務。會有兩個階段會導致阻塞父進程（主線程）：

- 創建子進程的途中，由於要複製父進程的頁表等數據結構，阻塞的時間跟頁表的大小有關，頁表越大，阻塞的時間也越長；
- 創建完子進程後，如果父進程修改了共享數據中的大 Key，就會發生寫時複製，這期間會拷貝物理內存，由於大 Key 佔用的物理內存會很大，那麼在複製物理內存這一過程，就會比較耗時，所以有可能會阻塞父進程。

大 key 除了會影響持久化之外，還會有以下的影響。

- 客戶端超時阻塞。由於 Redis 執行命令是單線程處理，然後在操作大 key 時會比較耗時，那麼就會阻塞 Redis，從客戶端這一視角看，就是很久很久都沒有響應。

- 引發網絡阻塞。每次獲取大 key 產生的網絡流量較大，如果一個 key 的大小是 1 MB，每秒訪問量為 1000，那麼每秒會產生 1000MB 的流量，這對於普通千兆網卡的服務器來說是災難性的。

- 阻塞工作線程。如果使用 del 刪除大 key 時，會阻塞工作線程，這樣就沒辦法處理後續的命令。

- 內存分佈不均。集群模型在 slot 分片均勻情況下，會出現數據和查詢傾斜情況，部分有大 key 的 Redis 節點佔用內存多，QPS 也會比較大。

如何避免大 Key 呢？

最好在設計階段，就把大 key 拆分成一個一個小 key。或者，定時檢查 Redis 是否存在大 key ，如果該大 key 是可以刪除的，不要使用 DEL 命令刪除，因為該命令刪除過程會阻塞主線程，而是用 unlink 命令（Redis 4.0+）刪除大 key，因為該命令的刪除過程是異步的，不會阻塞主線程。 

完！

---

最新的圖解文章都在公眾號首發，別忘記關注哦！！如果你想加入百人技術交流群，掃碼下方二維碼回覆「加群」。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)