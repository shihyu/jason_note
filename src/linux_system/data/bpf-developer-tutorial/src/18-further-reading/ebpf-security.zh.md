# eBPF 運行時安全性：面臨的挑戰與前沿創新

鄭昱笙

擴展伯克利數據包過濾器（eBPF）代表了我們與現代操作系統交互和擴展其能力方式的重大演變。作為一種強大的技術，它使得Linux內核能夠響應事件運行沙盒程序，eBPF已成為系統可觀察性、網絡和安全特性的基石。

然而，像任何與內核緊密接口的系統一樣，eBPF 運行時本身的安全性至關重要。在這篇博客中，我們將深入探討常被忽視的 eBPF 安全性問題，探索旨在保護 eBPF 的機制本身如何被加固。我們將解析 eBPF 驗證器的作用，審視當前的訪問控制模型，並調查研究中的潛在改進機會。

## 目錄

<!-- TOC -->

- [eBPF 運行時安全性：面臨的挑戰與前沿創新](#ebpf-運行時安全性面臨的挑戰與前沿創新)
  - [目錄](#目錄)
  - [eBPF如何通過驗證器確保安全](#ebpf如何通過驗證器確保安全)
    - [eBPF驗證器是什麼以及它的作用](#ebpf驗證器是什麼以及它的作用)
  - [eBPF 驗證器的工作原理](#ebpf-驗證器的工作原理)
    - [verifier 的挑戰](#verifier-的挑戰)
    - [強化 eBPF 驗證器的其他研究工作](#強化-ebpf-驗證器的其他研究工作)
  - [eBPF訪問控制的限制](#ebpf訪問控制的限制)
    - [CAP\_BPF](#cap_bpf)
    - [bpf命名空間](#bpf命名空間)
    - [無特權eBPF](#無特權ebpf)
    - [可信的非特權BPF](#可信的非特權bpf)
  - [一些其他的解決方案](#一些其他的解決方案)
    - [MOAT：實現安全的BPF內核擴展（隔離）](#moat實現安全的bpf內核擴展隔離)
    - [利用動態沙箱釋放無特權eBPF的潛力](#利用動態沙箱釋放無特權ebpf的潛力)
    - [內核擴展驗證是不切實際的](#內核擴展驗證是不切實際的)
    - [Wasm-bpf：WebAssembly eBPF庫、工具鏈及運行時](#wasm-bpfwebassembly-ebpf庫工具鏈及運行時)
    - [`bpftime`：用戶空間eBPF運行時，用於uprobe、系統調用鉤子及插件](#bpftime用戶空間ebpf運行時用於uprobe系統調用鉤子及插件)
    - [結論](#結論)

<!-- /TOC -->
## eBPF如何通過驗證器確保安全

eBPF的安全框架在很大程度上取決於其驗證器的強大性能。這個組件充當守門人，確保只有安全且符合規範的程序被允許在內核空間運行。

### eBPF驗證器是什麼以及它的作用

eBPF驗證器的核心是靜態代碼分析器。它的主要功能是在BPF程序指令執行前進行審查。它在內核中審查程序副本，操作目標包括：

- `確保程序終止`

  驗證器使用深度優先搜索（DFS）算法遍歷程序的控制流圖，確保它是一個有向無環圖（DAG）。這對於保證程序不會進入無限循環，從而確保其終止至關重要。它仔細檢查任何無界循環和格式錯誤或越界跳轉，這些都可能破壞內核的正常操作或導致系統掛起。

- `確保內存安全`

  內存安全在內核操作中至關重要。驗證器檢查可能的越界內存訪問，這些訪問可能導致數據損壞或安全漏洞。它還防範使用後釋放的錯誤和對象洩漏，這些是常見的可被利用的漏洞。除此之外，它還考慮到硬件漏洞，如幽靈（Spectre），執行緩解措施以防止此類旁路攻擊。

- `確保類型安全`

  類型安全是驗證器確保的另一個關鍵方面。通過防止類型混淆錯誤，它有助於維護內核數據的完整性。eBPF驗證器利用BPF類型格式（BTF），它允許準確理解和檢查內核的複雜數據結構，確保程序對這些結構的操作是有效和安全的。

- `防止硬件異常`

  硬件異常，如除以零，可能導致程序突然終止和內核恐慌。為了防止這種情況，驗證器包括檢查未知標量的除法，確保指令按照與aarch64規範一致的方式重寫或處理，這些規範規定了這類異常的安全處理。

通過這些機制，eBPF驗證器在維護內核的安全性和穩定性中發揮了關鍵作用，成為eBPF基礎設施中不可或缺的組成部分。它不僅加強了系統的防禦，還維護了eBPF程序打算執行的操作的完整性，使其成為eBPF生態系統中的重要部分。

## eBPF 驗證器的工作原理

- **遵循控制流程圖**
  驗證器首先通過構建並遵循eBPF程序的控制流程圖（CFG）來進行其分析。它細緻地計算出每條指令的所有可能狀態，同時考慮BPF寄存器集和堆棧。然後根據當前的指令上下文進行安全檢查。

  其中一個關鍵步驟是跟蹤程序私有BPF堆棧的寄存器溢出/填充情況。這確保了堆棧相關操作不會引起溢出或下溢，避免了數據破壞或成為攻擊路徑。

- **控制流程圖的回邊處理**
  驗證器通過識別CFG中的回邊來有效處理eBPF程序內的循環。通過模擬所有迭代直到達到預定的上限，從而確保循環不會導致無限制執行。

- **處理大量潛在狀態**
  驗證器需要處理程序執行路徑中大量潛在狀態帶來的複雜性。它運用路徑修剪邏輯，將當前狀態與之前的狀態進行比較，判斷當前路徑是否與之前的路徑“等效”，並且有一個安全的出口。這樣減少了需要考慮的狀態總數。

- **逐函數驗證以減少狀態數量**
  為了簡化驗證過程，驗證器進行逐函數分析。這種模塊化的方法使得在任何給定時間內需要分析的狀態數量得以減少，從而提高了驗證過程的效率。

- **按需標量精度追蹤以進一步減少狀態**
  驗證器運用按需標量精度追蹤來進一步減少狀態空間。通過在必要時對標量值進行回溯，驗證器可以更準確地預測程序的行為，優化其分析過程。

- **超過“複雜性”閾值時終止並拒絕**
  為了保持實用性能，驗證器設定了一個“複雜性”閾值。如果程序分析超過此閾值，驗證器將終止過程並拒絕該程序。這樣確保只有在可管理的複雜性範圍內的程序被允許執行，實現了安全性與系統性能的平衡。

### verifier 的挑戰

儘管eBPF驗證器執行得非常徹底，但它面臨著一系列重大挑戰：

- **對非root用戶暴露時成為攻擊目標**
  隨著驗證器日益複雜化，它逐漸成為攻擊者的青睞目標。由於eBPF具備強大的可編程性，一旦攻擊者繞過驗證器並在操作系統內核中執行代碼，可能帶來嚴重的後果。

- **驗證器正確性的複雜推斷**
  確保驗證器正確運行，特別是在Spectre緩解方面，並非易事。雖然部分形式的驗證已經到位，但仍有許多挑戰，特別是在即時編譯器（JIT）和抽象解釋模型等方面。

- **有時錯誤拒絕有效程序**
  由於LLVM（用於編譯eBPF程序的基礎架構）的優化與驗證器的理解能力之間有時存在不匹配，導致一些有效的程序被錯誤地拒絕。

- **為BPF程序類型維護“穩定的ABI”**
  為了確保操作系統內核更新時不影響生產環境中運行的BPF程序，“穩定的ABI”至關重要。但在保持此穩定性的同時，不斷發展驗證器和BPF生態系統也是一大挑戰。

- **性能與安全的平衡**
  在驗證複雜的eBPF程序時，性能與安全之間的平衡格外突出。雖然驗證器必須保持高效以確保實用性，但同時也不能在安全性上做出妥協，因為它所驗證的程序性能對現代計算系統至關重要。

eBPF驗證器代表了現代計算安全領域的創新，它巧妙地在最大化程序可編程性和在內核級別保持堅固防禦之間找到了平衡。

### 強化 eBPF 驗證器的其他研究工作

- 領域內的規範與驗證：將形式化方法應用於Linux內核BPF即時編譯器：<https://www.usenix.org/conference/osdi20/presentation/nelson>
- “使用三態數進行準確、精確和快速的抽象解釋”，Vishwanathan等。<https://arxiv.org/abs/2105.05398>
- “通過自動化形式驗證消除BPF JIT的漏洞”，Nelson等。<https://arxiv.org/abs/2105.05398>
- “使用證明攜帶方法構建正確且靈活的BPF驗證器”，Nelson等。<https://linuxplumbersconf.org/event/7/contributions/685/>
- “利用程序合成自動優化BPF程序”，徐等。<https://linuxplumbersconf.org/event/11/contributions/944/>
- “簡單且精確地靜態分析不受信任的Linux內核擴展”，Gershuni等。<https://linuxplumbersconf.org/event/11/contributions/951/>
- “對野外存在的投機型類型混淆漏洞進行分析”，Kirzner等。<https://www.usenix.org/conference/usenixsecurity21/presentation/kirzner>

這些研究共同構成了一個強大而多維的研究倡議，旨在加強eBPF驗證的基礎，確保其作為擴展Linux內核能力的工具保持安全和高效。

更多eBPF驗證器學習資料：

- BPF和Spectre：緩解瞬時執行攻擊：<https://popl22.sigplan.org/details/prisc-2022-papers/11/BPF-and-Spectre-Mitigating-transient-execution-attacks>

## eBPF訪問控制的限制

在像Ubuntu和SUSE這樣的主要Linux發行版禁止非特權用戶使用 eBPF 套接字過濾器和 CGroup 程序之後，目前的eBPF訪問控制模型只支持一個單一的權限級別。這一級別要求具備CAP_SYS_ADMIN能力，用於所有功能。然而，CAP_SYS_ADMIN因其廣泛的特權特性，特別是對於容器環境，帶來了顯著的風險。

為應對這一問題，Linux 5.6引入了更為細緻的權限系統，通過細分eBPF的能力。它引入了一個新的能力CAP_BPF，用於調用bpf系統調用。此外，安裝某些類型的eBPF程序還需要其他能力，如CAP_PERFMON用於性能監控或CAP_NET_ADMIN用於網絡管理任務。這種設計旨在減少某些攻擊類型，如更改進程內存或eBPF映射，這些攻擊仍然需要CAP_SYS_ADMIN權限。

然而，這些分割的能力並不能完全防止所有基於eBPF的攻擊，如拒絕服務（DoS）和信息竊取。攻擊者可能利用這些漏洞製造針對容器的eBPF惡意軟件。eBPF在雲原生應用中的廣泛應用加劇了這種威脅，因為用戶可能不小心部署了含有不可信eBPF程序的容器。

此外，eBPF在容器化環境中的風險還沒有被完全理解。一些容器服務可能無意中授予了eBPF權限，例如為了實現文件系統掛載功能。現行的權限模型不足以防止容器中這些可能有害的eBPF功能被濫用。

### CAP_BPF

在傳統上，幾乎所有的BPF行為都需要CAP_SYS_ADMIN權限，這同時也授予了廣泛的系統訪問權限。隨著時間的推移，已經有努力將BPF權限與根權限分開。因此，像CAP_PERFMON和CAP_BPF這樣的能力被引入，以便在不需要完整的系統管理員權限的情況下，對BPF操作進行更精細的控制，如讀取內核內存和加載跟蹤或網絡程序。

然而，CAP_BPF的範圍存在模糊性，導致了認知上的問題。不同於明確定義且用於加載內核模塊的CAP_SYS_MODULE，CAP_BPF缺少命名空間約束，這意味著它可以訪問所有的內核內存，而不僅僅是與容器相關的部分。這種廣泛的訪問權限是有問題的，因為BPF程序中的驗證器錯誤可能導致內核崩潰，被視為安全漏洞，導致過多的CVE（常見漏洞和曝光）被記錄，即使是那些已經修復的錯誤。這種對驗證器錯誤的反應引發了不必要的警報和緊迫感，迫使人們修補可能尚未更新的舊內核版本。

此外，一些安全初創公司因利用人們對BPF能力的恐懼來推銷產品而受到批評，他們矛盾地使用BPF本身來防禦他們強調的問題。這導致了一個矛盾的敘述，其中BPF既被視為問題又被推崇為解決方案。

### bpf命名空間

目前的安全模型要求具備 CAP_SYS_ADMIN 權限，以便迭代 BPF 對象 ID，並將其轉換為文件描述符（FD）。這樣做是為了防止非特權用戶訪問其他用戶的BPF程序，但同時也限制了他們檢查自己的BPF對象，這在容器環境中尤為挑戰。

儘管用戶可以使用CAP_BPF等特定權限運行BPF程序，但他們缺少一種通用的方法來檢查這些程序，因為如bpftool這類工具需要CAP_SYS_ADMIN權限。目前在沒有CAP_SYS_ADMIN的情況下的解決方法，包括使用SCM_RIGHTS和Unix域套接字在

進程間共享BPF對象的FD，但這被認為不夠方便。

為解決這些限制，Yafang Shao提議引入BPF命名空間。這將允許用戶在特定的命名空間內創建BPF映射、程序和鏈接，實現這些對象與其他命名空間用戶的隔離。然而，在一個BPF命名空間內的對象對其父命名空間仍然可見，從而使系統管理員能夠進行監督。

BPF命名空間在概念上與PID命名空間相似，設計上直觀易用。最初的實現重點是BPF映射、程序和鏈接，未來計劃將其擴展到其他BPF對象，如BTF和bpffs。這可能使容器用戶能夠只追蹤自己容器內的進程，而不接觸到其他容器的數據，從而在容器化環境中提高安全性和易用性。

參考資料：

- BPF和安全：<https://lwn.net/Articles/946389/>
- 雲上eBPF的跨容器攻擊：<https://www.usenix.org/system/files/usenixsecurity23-he.pdf>
- bpf：引入BPF命名空間：<https://lwn.net/Articles/927354/>
- ebpf在Linux命名空間運行的情況：<https://stackoverflow.com/questions/48815633/ebpf-running-in-linux-namespaces>

### 無特權eBPF

無特權eBPF是指非root用戶將eBPF程序加載到內核的能力。由於安全問題，這個特性在所有主要Linux發行版中默認是關閉的。安全擔憂主要來自硬件漏洞（如Spectre）和內核漏洞，惡意eBPF程序可能利用這些漏洞洩露敏感數據或攻擊系統。

為應對這一挑戰，針對這些漏洞的各種版本（如v1、v2和v4）已經實施了緩解措施。然而，這些緩解措施常常以犧牲eBPF程序的靈活性和性能為代價。這種權衡使得該功能對許多用戶和應用場景來說變得不具吸引力和實用性。

### 可信的非特權BPF

鑑於這些挑戰，目前正在探索一種名為“可信的非特權BPF”的中間方案。這種方法涉及一個白名單系統，其中已經經過徹底審查並被認為是可信的特定eBPF程序可以由非特權用戶加載。審查過程確保只有安全、適合生產環境的程序可以繞過特權要求，保持安全性與功能性之間的平衡。這是朝著在不妥協系統完整性的前提下，更廣泛地使用eBPF的一步。

- 寬鬆的LSM鉤子：由於LSM增加了進一步的限制，因此被上游拒絕

    Linux安全模塊（LSM）的新鉤子專門為BPF子系統設計，旨在提供對BPF映射和BTF數據對象更細粒度的控制。這些是現代BPF應用程序的運作基礎。

    主要添加了兩個LSM鉤子：bpf_map_create_security和bpf_btf_load_security，它們提供了覆蓋依賴於CAP_BPF和CAP_NET_ADMIN等能力的默認權限檢查的能力。這種新機制允許更精細的控制，使策略能夠強制實施限制或為可信應用程序繞過檢查，轉移決策至自定義LSM策略實現。

    這種方法通過不要求應用程序具備與內核BPF子系統交互所需的BPF相關能力，實現了更安全的默認設置。相反，應用程序可以在沒有這些權限的情況下運行，只有被審查並信任的情況才被授予操作權限，就像它們擁有提升的能力一樣。

- BPF令牌概念：特權守護進程通過令牌fd委託BPF的子集

    BPF令牌是一種新機制，允許特權守護進程將BPF功能的子集委託給可信的非特權應用程序。這一概念使得容器化的BPF應用程序能夠在用戶命名空間內安全運行，這在之前由於CAP_BPF能力的安全限制而無法實現。BPF令牌通過內核API創建和管理，並可以在BPF文件系統中固定，以實現控制訪問。最新版本的補丁確保BPF令牌被限制在其在BPF文件系統中的創建實例中，以防止誤用。這種添加到BPF子系統的功能促進了更安全、更靈活的無特權BPF操作。

- BPF簽名作為守門員：應用程序與BPF程序（沒有一刀切的解決方案）

    Song Liu提出了一個補丁，通過一個新設備`/dev/bpf`允許無特權訪問BPF功能。這個設備通過兩個新的ioctl命令控制訪問，允許對該設備具有寫權限的用戶調用`sys_bpf()`。這些命令切換當前任務調用`sys_bpf()`的能力，權限狀態存儲在`task_struct`中。這種權限也可以由任務創建的新線程繼承。引入了一個新的輔助函數`bpf_capable()`來檢查任務是否通過`/dev/bpf`獲得了權限。該補丁包括對文檔和頭文件的更新。

- RPC到特權BPF守護進程：根據用例/環境的限制

    RPC方法（例如bpfd）與BPF令牌概念類似，但它使用特權守護進程來管理BPF程序。這個守護進程負責加載和卸載BPF程序，以及管理BPF映射。守護進程還負責在加載前驗證BPF程序。這種方法比BPF令牌概念更靈活，因為它允許更細緻的控制BPF程序。然而，它也更復雜，帶來了更多的維護挑戰和單點故障的可能性。

參考資料：

- 寬鬆的LSM鉤子：<https://lore.kernel.org/bpf/20230412043300.360803-1-andrii@kernel.org/>
- BPF令牌概念：<https://lore.kernel.org/bpf/20230629051832.897119-1-andrii@kernel.org/>
- 使用fsverity和LSM守門員進行BPF簽名：<https://www.youtube.com/watch?v=9p4qviq60z8>
- 簽名BPF字節碼：<https://lpc.events/event/16/contributions/1357/attachments/1045/1999/BPF%20Signatures.pdf>
- bpfd：<https://bpfman.io/>

## 一些其他的解決方案

這裡還有一些關於如何提高eBPF安全性的研究或討論。現有工作大致可分為三類：虛擬化、軟件故障隔離（SFI）和形式方法。使用類似WebAssembly的沙箱部署eBPF程序或在用戶空間運行eBPF程序也是一種可能的解決方案。

### MOAT：實現安全的BPF內核擴展（隔離）

Linux內核廣泛使用伯克利數據包過濾器（BPF），允許用戶編寫的BPF應用在內核空間中執行。BPF使用驗證器來靜態檢查用戶提供的BPF代碼的安全性。最近的攻擊表明，BPF程序可以繞過安全檢查，獲得對內核內存的未授權訪問，這表明驗證過程並非無懈可擊。在本文中，我們介紹了MOAT，一個使用英特爾內存保護鍵（MPK）隔離潛在惡意BPF程序的系統。使用MPK強制執行BPF程序隔離並非易事；MOAT被精心設計以解決技術障礙，如硬件鍵數量有限和支持各種內核BPF輔助函數。我們已在原型內核模塊中實現MOAT，評估結果表明，MOAT在多種真實場景下實現了BPF程序的低成本隔離，例如對memcached數據庫的數據包轉發BPF程序隔離，平均吞吐量損失為6%。

<https://arxiv.org/abs/2301.13421>

> 如果我們必須依賴硬件保護機制，那麼語言安全性或驗證是否仍然有必要來保護內核及其擴展？

### 利用動態沙箱釋放無特權eBPF的潛力

出於安全原因，如今非特權用戶只能有限地通過擴展伯克利數據包過濾器（eBPF）來自定義內核。這非常遺憾，尤其是考慮到近年來eBPF框架本身的範圍不斷擴大。我們提出SandBPF，一種基於軟件的內核隔離技術，它通過動態地對eBPF程序進行沙箱化，允許非特權用戶安全地擴展內核，釋放eBPF的全部潛能。我們的早期概念驗證表明，SandBPF可以有效地防止eBPF本機安全機制（即靜態驗證）遺漏的漏洞，同時在Web服務器基準測試中帶來0%-10%的開銷。

<https://arxiv.org/abs/2308.01983>

> 這可能與eBPF的原始設計相悖，因為它並非設計為依賴沙箱來確保安全。如果你想使用軟件故障隔離，為什麼不在內核中使用 webassembly？

### 內核擴展驗證是不切實際的

經過驗證的eBPF字節碼的出現預示著安全內核擴展的新時代。在本文中，我們認為eBPF的驗證器——其安全保證的來源——已成為一個負擔。除了眾所周知的錯誤和漏洞（源於內核驗證器的複雜性和臨時性質），我們還突出了一個令人擔憂的趨勢，即向不安全的內核函數引入逃逸通道（以輔助函數的形式），旨在繞過驗證器對錶達性的限制，不幸的是，也繞過了其安全保證。我們提出了使用靜態和輕量級運行時技術平衡的安全內核擴展框架。我們描述了一個以安全Rust為中心的內核擴展設計，將消除內核驗證器的需要，提高表達性，減少逃逸通道，並最終提高內核擴展的安全性。

<https://sigops.org/s/conferences/hotos/2023/papers/jia.pdf>

> 這可能限制內核只加載受信任第三方簽名的 eBPF 程序，因為內核本身無法獨立驗證它們。Rust工具鏈也存在漏洞。

### Wasm-bpf：WebAssembly eBPF庫、工具鏈及運行時

Wasm-bpf是一種WebAssembly eBPF庫、工具鏈和運行時，能夠使eBPF程序幾乎無需更改代碼就能構建成Wasm，並在Wasm沙箱中實現跨平臺運行。

它提供了一個可配置的環境，具有限制性的eBPF WASI行為，增強了安全性和控制力。這使得實現細粒度權限成為可能，限制了對內核資源的訪問，提供了更安全的環境。例如，可以限制eBPF程序僅用於特定類型的用途，比如網絡監控，並且還可以配置哪些類型的eBPF程序能在內核中加載，以及它們可以訪問哪些類型的附加事件，而無需修改內核eBPF的權限模型。

- Kubecon talk: <https://sched.co/1R2uf>
- Repo: <https://github.com/eunomia-bpf/wasm-bpf>

> 將應用程序移植到WebAssembly需要額外的工作。此外，內核eBPF的Wasm接口也需要進行維護，就像BPF守護進程一樣。

### `bpftime`：用戶空間eBPF運行時，用於uprobe、系統調用鉤子及插件

`bpftime` 是一個用戶空間eBPF運行時，它使現有的eBPF應用能夠在非特權用戶空間中運行，使用相同的庫和工具鏈。它為eBPF提供了Uprobe和系統調用跟蹤點，與內核uprobe相比有顯著的性能提升，且不需要手動的代碼插樁或進程重啟。運行時促進了用戶空間共享內存中的進程間eBPF映射，並與內核eBPF映射兼容，實現了與內核eBPF基礎架構的無縫操作。它包括了針對各種架構的高性能LLVM JIT，以及專為x86設計的輕量級JIT和解釋器。

- <https://arxiv.org/abs/2311.07923>
- Linux Plumbers: <https://lpc.events/event/17/contributions/1639/>
- Repo: <https://github.com/eunomia-bpf/bpftime>

> 它的應用僅限於特定類型的eBPF程序和用例，不是一種普遍適用的方法。

### 結論

在我們深入探討eBPF安全性的多維領域時，很明顯，雖然eBPF的驗證器提供了堅實的首層防禦，但當前訪問控制模型中存在的內在限制需要引起關注。我們已經考慮了從虛擬化、軟件故障隔離和形式化方法到WebAssembly 或用戶空間 eBPF 運行時的各種潛在解決方案，每種方法都為加固eBPF抵抗漏洞提供了獨特的途徑。

然而，像所有複雜系統一樣，新的問題和挑戰持續出現。理論安全模型與其實際執行之間的差距呼籲著持續的研究和實驗。eBPF安全的未來不僅前景光明，而且還需要集體努力，以確保該技術能夠在保障系統安全的能力上被信賴地採納。

> 我們是 [github.com/eunomia-bpf](https://github.com/eunomia-bpf) 開源社區，希望能使eBPF更易使用，並探索與 eBPF 相關的工具鏈和運行時等技術。
>
> 對eBPF技術感興趣的朋友，歡迎查看我們的教程代碼倉庫 <https://github.com/eunomia-bpf/bpf-developer-tutorial> 和我們的網站 <https://eunomia.dev/tutorials/> 以獲取更多關於 eBPF 的相關資料和實踐經驗。原文地址：<https://eunomia.dev/zh/blogs/ebpf-security>
