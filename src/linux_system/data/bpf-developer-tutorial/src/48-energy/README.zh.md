# eBPF 教程：進程級能源監控與功耗分析

您是否想過應用程序到底消耗了多少能源？在數據中心和邊緣設備中，能源效率正變得愈發重要，深入瞭解進程級別的功耗已成為系統優化的關鍵。本教程將帶您構建一個基於 eBPF 的能源監控工具，它能以極低的系統開銷實時洞察進程的功耗情況。

## 能源監控和功耗分析簡介

長期以來，計算系統的能源監控一直面臨著細粒度測量能力不足的挑戰。雖然 Intel RAPL（Running Average Power Limit）等硬件計數器能夠測量系統總功耗或 CPU 封裝功耗，但無法精確定位具體是哪些進程在消耗這些能量。這正是軟件層面能源歸因技術的用武之地。

進程在 CPU 上運行時，其功耗與 CPU 佔用時間和處理器功率狀態密切相關。難點在於如何實時精確地追蹤這種關係，同時避免監控本身帶來的額外功耗和測量偏差。傳統的輪詢式監控方法容易遺漏短生命週期的進程，而且監控開銷會影響測量的準確性。

eBPF 技術的出現徹底改變了這一局面！通過在內核調度器事件上設置鉤子，我們能夠以納秒級精度捕獲每次上下文切換時的進程 CPU 時間。這種方法不僅能精確測量每個進程的 CPU 時間，完全消除短生命週期進程的採樣誤差，還能相比輪詢方式大幅降低監控開銷。更重要的是，它支持實時計算基於 CPU 時間的能源消耗，精準關聯能源使用與具體工作負載。

## 理解 CPU 功耗

在深入實現之前，瞭解 CPU 功耗的工作原理非常重要。現代處理器以幾種方式消耗功率：

### 動態功耗

動態功耗產生於晶體管狀態切換的過程中。當處理器工作在更高的時鐘頻率時，單位時間內的狀態切換次數增加；當電壓升高時，每次切換消耗的能量也相應增大；而執行的指令越多，參與切換的晶體管數量就越多。這些因素共同決定了動態功耗的大小，其關係可以用公式表示為：P_dynamic = C × V² × f × α，其中 C 表示電容，V 表示電壓，f 表示頻率，α 表示活動因子。

### 靜態功耗

即使晶體管不切換，由於通過晶體管的電流洩漏，也會消耗靜態（或洩漏）功率。在擁有數十億個晶體管的現代處理器中，這變得越來越重要。

### 功率狀態和 DVFS

現代 CPU 使用動態電壓和頻率調節（DVFS）來平衡性能和功耗。處理器可以在具有不同頻率/電壓組合的不同 P 狀態（性能狀態）下運行，並在不主動計算時進入 C 狀態（空閒狀態）。

我們的能源監控方法通過將 CPU 時間乘以平均功耗來估算能源消耗。雖然這是一種簡化（它不考慮頻率變化或空閒狀態），但它提供了一個有用的近似值來比較進程之間的相對能源使用。

## 比較傳統與 eBPF 能源監控

為了理解為什麼 eBPF 在能源監控方面更優越，讓我們將其與傳統方法進行比較：

### 傳統的基於 /proc 的監控

傳統的能源監控工具通常通過定期讀取 `/proc/stat` 來採樣 CPU 使用情況。以下是我們的傳統監控器的工作原理：

```bash
# 讀取進程的總 CPU 時間
cpu_time=$(awk '{print $14 + $15}' /proc/$pid/stat)

# 基於時間差計算能量
energy = cpu_power * (current_time - previous_time)
```

這種方法存在明顯的侷限性。首先是**採樣誤差**問題，在採樣間隔內啟動和停止的進程會被完全遺漏。其次是**固定開銷**，每次採樣都需要讀取和解析 `/proc` 文件系統。再者是**精度限制**，典型的採樣間隔達到 100ms 或更長。最後是**可擴展性**挑戰，監控大量進程時需要頻繁讀取眾多文件，開銷急劇增加。

### 基於 eBPF 的監控

我們的 eBPF 方法直接掛鉤到內核調度器：

```c
SEC("tp/sched/sched_switch")
int monitor_energy(struct trace_event_raw_sched_switch *ctx) {
    u64 ts = bpf_ktime_get_ns();
    // 跟蹤進程停止運行的確切時間
    u64 delta = ts - previous_timestamp;
    update_runtime(prev_pid, delta);
}
```

這種方法的優勢非常明顯。它能夠捕獲每一次上下文切換，實現**完美精度**；無需輪詢或文件解析，保證了**最小開銷**；提供**納秒級精度**的 CPU 時間測量；更重要的是具有出色的**可擴展性**，無論監控 1 個還是 1000 個進程，系統開銷基本相同。

## 為什麼選擇 eBPF 進行能源監控？

能源監控的格局已經顯著發展，正如 eBPF 能源項目綜合調查中詳細描述的那樣。讓我結合能源監控生態系統的關鍵見解：

### eBPF 能源項目的當前狀態

eBPF 能源管理生態系統正在兩個主要類別中快速發展：成熟的遙測解決方案和新興的功率控制框架。

**能源遙測和計費（生產就緒）**

在生產就緒的能源遙測和計費領域，已經湧現出幾個成熟的解決方案。**Kepler** 作為 CNCF 沙箱項目，已經在生產環境中廣泛部署，它專注於 Kubernetes 環境中的容器和 pod 能源歸因，通過結合 eBPF 跟蹤點、RAPL 硬件計數器和性能計數器來實現精確測量。**Wattmeter** 則是一個研究原型，在 HotCarbon '24 會議上展示，它通過在上下文切換時讀取 RAPL MSR 寄存器的 eBPF 程序來實現每進程能源跟蹤，其開銷低於 1 微秒，展現了極高的效率。**DEEP-mon** 提供了另一種經過學術驗證的方法，專門針對容器功率監控，通過在內核內對調度器事件進行 eBPF 聚合，巧妙地避免了用戶空間的開銷。

**通過 eBPF 進行功率控制（研發中）**

新興的功率控制領域代表了 eBPF 能源管理的下一個前沿。**cpufreq_ext** 是第一個可以通過 `bpf_struct_ops` 接口實際修改 CPU 頻率的上游 eBPF 實現，允許用 eBPF 而不是內核 C 代碼編寫頻率調節策略。

研究原型包括一個 **eBPF CPU 空閒調節器**，它用 eBPF 掛鉤替換傳統的 menu/TEO 調節器，用於動態空閒狀態選擇和空閒注入。概念性的 **BEAR（BPF 能源感知運行時）** 框架旨在在單個基於 eBPF 的策略引擎下統一 DVFS、空閒和熱管理，儘管還沒有公開實現。

### 為什麼我們的方法很重要

我們的能源監控器屬於遙測類別，但特別關注教育清晰度和與傳統方法的比較。eBPF 的**事件驅動架構**與基於輪詢的方法根本不同，它實時響應內核事件。當調度器切換進程時，我們的代碼立即運行，以納秒精度捕獲確切的轉換時刻。

**內核內聚合**功能通過在內核中維護每個 CPU 的哈希映射，消除了將每個上下文切換事件發送到用戶空間的開銷。只有聚合數據或採樣事件需要跨越內核-用戶邊界，大大減少了監控開銷。結合 eBPF 在加載前通過程序驗證的**安全保證**，這創建了一個生產就緒的解決方案，不會崩潰內核或創建無限循環。

也許最重要的是，eBPF 支持**熱插拔分析**，您可以在不重新啟動應用程序或重新啟動系統的情況下附加和分離能源監控器。這種能力支持對生產工作負載進行臨時分析，這是傳統內核模塊或檢測方法無法做到的。

### 現實世界的影響

eBPF 能源監控在不同部署場景中展現出的實際優勢令人矚目。對於**短暫進程**，傳統方法經常會完全錯過這些快速啟動和停止的進程，而 eBPF 方法能夠跟蹤每一微秒，實現 100% 的可見性。在**容器監控**場景中，傳統方法需要為每個容器承擔高昂的監控開銷，而 eBPF 通過共享內核基礎設施，能夠將開銷降低 10 到 100 倍。對於**生產系統**而言，傳統的內核模塊存在系統崩潰的風險，而 eBPF 的驗證安全程序確保了零崩潰風險。面對**動態工作負載**時，傳統的固定採樣方式容易錯過功耗峰值，而 eBPF 的事件驅動機制能夠捕獲所有變化，實現準確的峰值檢測。

### 何時 eBPF 能源監控至關重要

eBPF 能源監控在多種關鍵場景中發揮著不可替代的作用。在**電池供電設備**上，每一毫焦耳的能量都至關重要，而 eBPF 的低開銷特性確保了監控過程本身不會影響電池壽命。**多租戶雲**環境需要準確的能源計費和功率預算執行，eBPF 的精確歸因能力使得公平的能源計費成為可能。在**熱管理**場景中，熱約束環境需要實時反饋，eBPF 的事件驅動更新機制能夠提供即時的熱響應。對於**可持續性報告**，組織需要審計級別的碳足跡測量，eBPF 提供了生產級的精度，同時避免了傳統方法的高開銷。在進行**性能/瓦特優化**時，開發者需要以最小的干擾測量代碼更改的影響，eBPF 提供了接近零偏差的 A/B 測試能力。

這些用例共享傳統基於輪詢的方法難以滿足的共同要求：需要準確、低開銷、實時的能源歸因，可以在生產環境中可靠運行。

生態系統正在迅速成熟，像 Kepler 這樣的項目已經部署在生產 Kubernetes 集群中，cpufreq_ext 正朝著主線內核包含的方向發展。我們的教程為理解和構建這些高級功能提供了基礎。

## 架構概述

我們的能源監控解決方案提供了一個全面的比較框架，包含兩種不同的實現。**eBPF 能源監控器**通過內核掛鉤提供高性能監控，而**傳統能源監控器**使用基於 bash 的 `/proc` 採樣來代表傳統方法。**比較腳本**允許在相同條件下直接評估兩種方法。

eBPF 實現架構由三個緊密集成的組件組成：

### 頭文件 (energy_monitor.h)

定義內核-用戶通信的共享數據結構：

```c
struct energy_event {
    __u64 ts;           // 上下文切換的時間戳
    __u32 cpu;          // 進程運行的 CPU 核心
    __u32 pid;          // 進程 ID
    __u64 runtime_ns;   // 進程運行時間（納秒）
    char comm[16];      // 進程名稱
};
```

### eBPF 程序 (energy_monitor.bpf.c)

使用三個關鍵映射實現內核端邏輯：

```c
// 跟蹤每個進程開始運行的時間
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, u32);    // PID
    __type(value, u64);  // 開始時間戳
} time_lookup SEC(".maps");

// 累積每個進程的總運行時間
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);
    __uint(max_entries, 10240);
    __type(key, u32);    // PID
    __type(value, u64);  // 總運行時間（微秒）
} runtime_lookup SEC(".maps");

// 向用戶空間發送事件
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} rb SEC(".maps");
```

### 用戶空間應用程序 (energy_monitor.c)

處理事件並基於配置的 CPU 功率計算能源消耗。

## 實現深入探討

讓我們探索 eBPF 能源監控器實現的關鍵部分：

### 掛鉤到調度器

我們監控器的核心是在每次上下文切換時觸發的調度器跟蹤點：

```c
SEC("tp/sched/sched_switch")
int monitor_energy(struct trace_event_raw_sched_switch *ctx)
{
    u64 ts = bpf_ktime_get_ns();
    u32 cpu = bpf_get_smp_processor_id();
    
    u32 prev_pid = ctx->prev_pid;
    u32 next_pid = ctx->next_pid;
    
    // 計算剛剛停止的進程的運行時間
    u64 *old_ts_ptr = bpf_map_lookup_elem(&time_lookup, &prev_pid);
    if (old_ts_ptr) {
        u64 delta = ts - *old_ts_ptr;
        update_runtime(prev_pid, delta);
        
        // 向用戶空間發送事件以進行實時監控
        struct energy_event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
        if (e) {
            e->ts = ts;
            e->cpu = cpu;
            e->pid = prev_pid;
            e->runtime_ns = delta;
            bpf_probe_read_kernel_str(e->comm, sizeof(e->comm), ctx->prev_comm);
            bpf_ringbuf_submit(e, 0);
        }
    }
    
    // 記錄下一個進程開始運行的時間
    bpf_map_update_elem(&time_lookup, &next_pid, &ts, BPF_ANY);
    
    return 0;
}
```

這個函數捕獲 CPU 從一個進程切換到另一個進程的確切時刻，使我們能夠精確計算每個進程運行了多長時間。

### 高效的時間計算

為了最小化內核中的開銷，我們使用優化的除法函數將納秒轉換為微秒：

```c
static inline u64 div_u64_by_1000(u64 n) {
    u64 q, r, t;
    t = (n >> 7) + (n >> 8) + (n >> 12);
    q = (n >> 1) + t + (n >> 15) + (t >> 11) + (t >> 14);
    q = q >> 9;
    r = n - q * 1000;
    return q + ((r + 24) >> 10);
}
```

這種位移方法在內核上下文中比常規除法快得多，在內核上下文中浮點運算不可用。

### 用戶空間中的能源計算

用戶空間程序接收運行時事件並計算能源消耗：

```c
static int handle_event(void *ctx, void *data, size_t data_sz)
{
    const struct energy_event *e = data;
    
    // 計算能量（納焦耳）
    // 能量 (J) = 功率 (W) × 時間 (s)
    // 能量 (nJ) = 功率 (W) × 時間 (ns)
    __u64 energy_nj = (__u64)(env.cpu_power_watts * e->runtime_ns);
    
    if (env.verbose) {
        printf("%-16s pid=%-6d cpu=%-2d runtime=%llu ns energy=%llu nJ\n",
               e->comm, e->pid, e->cpu, e->runtime_ns, energy_nj);
    }
    
    return 0;
}
```

### 最終統計

當監控會話結束時，我們聚合來自所有 CPU 核心的數據：

```c
static void print_stats(struct energy_monitor_bpf *skel)
{
    int num_cpus = libbpf_num_possible_cpus();
    __u64 *values = calloc(num_cpus, sizeof(__u64));
    
    // 遍歷所有進程
    while (bpf_map_get_next_key(bpf_map__fd(skel->maps.runtime_lookup), 
                                &key, &next_key) == 0) {
        // 彙總來自所有 CPU 的值（percpu map）
        if (bpf_map_lookup_elem(bpf_map__fd(skel->maps.runtime_lookup), 
                               &next_key, values) == 0) {
            for (int i = 0; i < num_cpus; i++) {
                runtime_us += values[i];
            }
            
            // 計算能量
            double energy_mj = (env.cpu_power_watts * runtime_us) / 1000000.0;
            printf("%-10d %-16s %-15.2f %-15.4f\n", 
                   next_key, comm, runtime_ms, energy_mj);
        }
    }
}
```

## 構建和運行能源監控器

### 先決條件

在構建之前，需要確保系統環境滿足幾個基本要求。首先需要 Linux 內核 5.4 或更新版本，且支持 BTF（BPF 類型格式）功能。其次要安裝 libbpf 開發文件，這是 eBPF 程序開發的基礎庫。編譯 eBPF 程序需要 clang 和 llvm 工具鏈。最後，還需要安裝基本的構建工具，包括 make 和 gcc。

### 編譯

使用提供的 Makefile 構建所有組件：

```bash
cd /home/yunwei37/bpf-developer-tutorial/src/48-energy
make clean && make
```

編譯完成後會生成三個主要的可執行文件。`energy_monitor` 是基於 eBPF 的能源監控器，提供高精度的實時監控功能。`energy_monitor_traditional.sh` 是傳統的基於輪詢的監控器，使用 `/proc` 文件系統進行採樣。`compare_monitors.sh` 則是用於比較兩種方法效率和精度的腳本。

### 運行 eBPF 監控器

eBPF 監控器需要 root 權限才能附加到內核跟蹤點：

```bash
# 以 15W CPU 功率監控所有進程 10 秒
sudo ./energy_monitor -d 10 -p 15.0

# 詳細輸出監控
sudo ./energy_monitor -v -d 10

# 持續監控（Ctrl+C 停止）
sudo ./energy_monitor
```

示例輸出：

```
能源監控器已啟動... 按 Ctrl-C 結束。
CPU 功率：15.00 W
運行 10 秒

=== 能源使用摘要 ===
PID        COMM             運行時間 (ms)    能量 (mJ)    
---------- ---------------- --------------- ---------------
39716      firefox          541.73          8.1260         
19845      node             67.71           1.0157         
39719      vscode           63.15           0.9472         
29712      chrome           13.34           0.2000         
...

總 CPU 時間：2781.52 ms
總估計能量：0.0417 J (41.7229 mJ)
CPU 功率設置：15.00 W
```

### 運行傳統監控器

傳統監控器使用 `/proc` 採樣，無需特殊權限即可運行：

```bash
# 詳細輸出監控 10 秒
./energy_monitor_traditional.sh -d 10 -v

# 調整採樣間隔（默認 100ms）
./energy_monitor_traditional.sh -d 10 -i 0.05
```

### 比較兩種方法

使用比較腳本查看差異：

```bash
# 基本比較
sudo ./compare_monitors.sh -d 10

# 帶有 CPU 工作負載
sudo ./compare_monitors.sh -d 10 -w "stress --cpu 2 --timeout 10"
```

比較輸出示例：

```
比較結果
==================

指標                      傳統           eBPF           
------------------------- --------------- ---------------
總能量 (J)                1.050000        0.0288         
監控時間 (s)              5.112031        4.500215       
樣本/事件                 50              連續     

性能分析：
- 傳統監控開銷：與 eBPF 相比為 13.00%
- eBPF 提供每個上下文切換的粒度
- 傳統採樣以固定間隔（100ms）
```

## 理解能源監控權衡

雖然我們的能源監控器提供了有價值的見解，但瞭解其侷限性和權衡很重要：

### 精度考慮

我們的能源監控模型採用簡化方法，使用公式：能量 = CPU_功率 × CPU_時間。雖然這提供了有價值的比較見解，但它沒有考慮影響實際功耗的幾個動態因素。

**頻率調節**是一個重要限制，因為現代 CPU 根據工作負載和熱條件動態改變頻率。不同的**空閒狀態**（C 狀態）也消耗不同的功率，從深度睡眠中的接近零到淺空閒狀態中的顯著待機功率。此外，**工作負載特性**很重要，因為某些指令（特別是向量操作和內存密集型任務）每個週期消耗的功率比簡單的算術運算更多。

該模型還忽略了來自緩存、內存控制器和 I/O 子系統的**共享資源消耗**，這些都有助於總系統功率，但不能直接歸因於 CPU 執行時間。

對於需要更高精度的生產部署，增強功能將包括讀取硬件性能計數器以進行實際功率測量，通過 DVFS 事件跟蹤頻率變化，基於性能計數器對不同指令類型進行建模，以及合併來自更廣泛系統的內存和 I/O 活動指標。

### 何時使用每種方法

在 eBPF 和傳統監控之間進行選擇取決於您的具體要求和約束。

**eBPF 監控**在您需要準確的 CPU 時間跟蹤時表現出色，特別是對於傳統採樣可能完全錯過的短暫進程。其最小的測量開銷使其成為生產環境的理想選擇，在生產環境中，監控工具本身不應影響被測量的工作負載。eBPF 對於進程之間的比較分析特別有價值，其中相對精度比絕對精度更重要。

**傳統監控**在由於權限限制或缺少 BTF 支持的舊內核版本而無法使用 eBPF 時仍然適用。它提供了一個簡單、可移植的解決方案，不需要特殊權限，可以跨不同平臺工作。對於監控長時間運行的穩定工作負載，其中近似測量就足夠了，傳統方法提供了足夠的洞察力，部署要求更簡單。

## 實際用例和部署場景

瞭解何時以及如何部署 eBPF 能源監控有助於最大化其價值。以下是它表現出色的現實場景：

### 數據中心能源優化

現代數據中心在嚴格的功率預算和冷卻約束下運行，eBPF 能源監控提供了關鍵的運營能力。當調度器瞭解不同應用程序的能源配置文件時，**工作負載放置**變得智能化，從而在機架之間實現平衡的功耗，同時避免熱點並最大化整體效率。

在高峰需求期間，**功率上限**系統可以利用實時能源歸因來識別和選擇性地限制最耗電的進程，而不影響關鍵服務。這種外科手術方法在保持在電力基礎設施限制內的同時維持服務水平。

對於雲提供商，**計費和退款**準確性推動客戶行為朝著更高效的代碼發展。當客戶可以看到其工作負載的實際能源成本時，他們有直接的財務激勵來優化其應用程序的能源效率。

### 移動和邊緣計算

電池供電設備提出了獨特的能源約束，其中精確監控對於用戶體驗和設備壽命至關重要。**應用程序能源分析**使開發人員能夠在不同操作期間獲得準確的能源消耗數據，從而實現有針對性的優化，可以顯著延長電池壽命而不犧牲功能。

操作系統受益於**後臺任務管理**智能，其中歷史能源消耗模式告知有關允許或推遲哪些後臺任務的決策。這可以防止耗能的後臺進程耗盡電池，同時維護基本服務。

在沒有主動冷卻的設備中，**熱管理**變得至關重要，因為能源監控有助於在節流發生之前預測熱量積累。通過了解能源模式，系統可以主動管理工作負載，以在熱限制內保持一致的性能。

### 開發和 CI/CD 集成

將能源監控集成到開發工作流中會創建一個連續的反饋循環，防止效率倒退到達生產環境。**能源迴歸測試**通過 CI/CD 管道變得自動化，這些管道標記將能源消耗增加到預定義閾值以上的代碼更改，將能源效率視為一流的軟件質量指標。

**性能/瓦特優化**為開發人員提供了對性能改進的真實成本的可見性。一些優化可能會提高速度，同時大幅增加能源消耗，而另一些可能會以最小的性能影響實現更好的效率。這種可見性支持基於實際工作負載要求的明智架構決策，平衡速度和效率。

**綠色軟件指標**集成允許組織跟蹤和報告能源效率作為可持續性計劃的一部分。定期測量為環境影響報告提供了具體數據，同時為軟件團隊創建了在其開發實踐中考慮能源效率的問責制。

### 研究和教育

eBPF 能源監控作為一種強大的研究和教育工具，彌合了理論理解和實際系統行為之間的差距。當研究人員可以在生產現實條件下測量方法之間的能源效率差異時，**算法比較**變得嚴格，提供了補充理論複雜性分析的經驗數據。

**系統行為分析**從能源角度揭示了不同組件之間的複雜交互，發現了僅查看性能指標時不明顯的優化機會。這些見解推動了考慮總擁有成本（包括運營能源成本）的系統設計決策。

作為**教學工具**，能源監控通過向學生展示其代碼的即時能源影響，使抽象概念變得具體。當算法複雜性討論與真實能源測量配對時，學生們對其設計選擇的實際影響有了直覺，而不僅僅是計算效率。

## 擴展能源監控器

當前的實現為構建更復雜的能源監控功能提供了堅實的基礎，有多個擴展方向值得探索。**硬件計數器集成**是最有影響力的增強方向，通過 `PERF_TYPE_POWER` 事件集成 RAPL 計數器，可以用實際的硬件測量來替換我們的估算模型，大幅提升精度。**每核功率建模**在處理異構處理器時尤為重要，通過跟蹤進程的核心分配並建模性能核心（P 核）與效率核心（E 核）之間的功耗差異，能夠實現更準確的能源歸因。**工作負載分類**功能可以識別 CPU 密集型、內存綁定、I/O 綁定和空閒模式等不同工作負載類型，從而實現針對特定工作負載的功率優化策略。**容器運行時集成**使得系統能夠按容器或 pod 聚合 Kubernetes 環境中的能源消耗，支持雲原生的能源歸因和計費。**實時可視化**通過提供帶有能源消耗圖表的 Web 儀表板，為能源優化提供即時的視覺反饋。

**硬件計數器集成**代表了最有影響力的增強，通過 RAPL（運行平均功率限制）接口用實際硬件測量替換我們的簡化估計模型。現代處理器提供詳細的能源計數器，可以通過性能事件讀取，提供精確到單個 CPU 封裝的能源測量。

```c
// 讀取 RAPL 計數器以獲取實際能源測量
struct perf_event_attr attr = {
    .type = PERF_TYPE_POWER,
    .config = PERF_COUNT_HW_POWER_PKG,
};
```

**每核功率建模**在異構處理器上變得至關重要，其中性能核心和效率核心具有截然不同的功率特性。跟蹤每個進程在哪個核心上運行可以實現準確的能源歸因：

```c
// 不同的核心可能具有不同的功率特性
double core_power[MAX_CPUS] = {15.0, 15.0, 10.0, 10.0}; // P 核與 E 核
```

**工作負載分類**通過識別不同的計算模式及其相關的能源成本來增強能源監控：

```c
enum workload_type {
    WORKLOAD_CPU_INTENSIVE,
    WORKLOAD_MEMORY_BOUND,
    WORKLOAD_IO_BOUND,
    WORKLOAD_IDLE
};
```

## 故障排除常見問題

部署 eBPF 能源監控時，您可能會遇到這些常見問題：

### 權限被拒絕

如果在運行 eBPF 監控器時看到權限錯誤：

```bash
# 檢查 BPF 是否已啟用
sudo sysctl kernel.unprivileged_bpf_disabled

# 啟用 BPF 進行調試（不建議用於生產）
sudo sysctl kernel.unprivileged_bpf_disabled=0
```

### 缺少 BTF 信息

如果內核缺少 BTF（BPF 類型格式）數據：

```bash
# 檢查 BTF 支持
ls /sys/kernel/btf/vmlinux

# 在較舊的內核上，您可能需要生成 BTF
# 或使用帶有 CONFIG_DEBUG_INFO_BTF=y 的內核
```

### 高 CPU 使用率

如果監控器本身導致高 CPU 使用率，可以採取幾種優化措施。首先考慮減少 eBPF 程序中的環形緩衝區大小，這能夠降低內存壓力和處理開銷。其次，增加批量讀取事件的大小可以減少系統調用的頻率。最有效的方法是在內核中添加事件過濾邏輯，從源頭上減少需要傳遞到用戶空間的事件數量。

### 缺少進程

當發現某些進程沒有被正確跟蹤時，需要從幾個方面進行排查。首先檢查這些進程是否運行在不同的 PID 命名空間中，容器化環境經常會出現這種情況。其次，確保監控器在目標進程啟動之前就已經運行，否則可能會錯過初始的調度事件。最後，驗證 eBPF 程序中的哈希映射大小是否足夠容納所有需要跟蹤的進程，必要時可以增加 `max_entries` 的值。

## 未來方向

基於 eBPF 的能源監控領域正在迅速發展。以下是即將到來的令人興奮的發展：

### 與硬件加速器集成

隨著 GPU、TPU 和其他加速器變得普遍，擴展 eBPF 監控以跟蹤其能源消耗將提供完整的系統可見性。

### 用於功率預測的機器學習

使用 eBPF 收集的數據來訓練模型，這些模型基於工作負載模式預測未來的功耗，從而實現主動電源管理。

### 標準化工作

正在進行標準化 eBPF 能源監控接口的工作，使構建跨不同平臺工作的可移植工具變得更加容易。

### 碳感知計算

將能源監控與實時碳強度數據相結合，自動將工作負載轉移到具有更清潔能源的時間和地點。

## 參考文獻和進一步閱讀

要深入瞭解本教程中涵蓋的主題：

### 能源和電源管理

在能源和電源管理領域，有幾個重要的參考資源值得深入研究。Intel 的運行平均功率限制 (RAPL) 文檔（[https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html)）詳細解釋瞭如何使用硬件計數器進行精確的能源測量。Linux 電源管理文檔（[https://www.kernel.org/doc/html/latest/admin-guide/pm/index.html](https://www.kernel.org/doc/html/latest/admin-guide/pm/index.html)）提供了內核電源管理子系統的全面指南。而 ACPI 規範（[https://uefi.org/specifications](https://uefi.org/specifications)）則定義了現代系統電源管理的標準接口。

### 相關項目

在能源監控生態系統中，有許多值得關注的項目。Kepler（Kubernetes 高效功率級別導出器）作為 CNCF 項目，專門為雲原生環境提供能源監控解決方案（[https://sustainable-computing.io/](https://sustainable-computing.io/)）。Scaphandre（[https://github.com/hubblo-org/scaphandre](https://github.com/hubblo-org/scaphandre)）提供了另一種功率測量實現，支持多種硬件平臺。經典的 PowerTOP 工具（[https://github.com/fenrus75/powertop](https://github.com/fenrus75/powertop)）一直是 Linux 系統上診斷電源問題的首選工具。最近的 cpufreq_ext eBPF 調節器（[https://lwn.net/Articles/991991/](https://lwn.net/Articles/991991/)）展示了使用 eBPF 進行動態頻率調節的可能性。Wattmeter 項目在 HotCarbon '24 會議上的展示（[https://www.asafcidon.com/uploads/5/9/7/0/59701649/energy-aware-ebpf.pdf](https://www.asafcidon.com/uploads/5/9/7/0/59701649/energy-aware-ebpf.pdf)）則代表了該領域的最新研究成果。

### 學術論文

學術界對 eBPF 能源監控的研究日益活躍。HotCarbon '24 會議上發表的 "Linux 中的能源感知進程調度" 論文提出了創新的調度算法。"DEEP-mon：基於容器的基礎設施的動態和節能功率監控" 研究展示瞭如何在容器化環境中實現高效的能源監控。而 "基於 eBPF 的能源感知調度" 等研究論文則探索了將能源感知與任務調度緊密結合的新方法。

本教程的完整代碼可在以下位置獲得：[https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/48-energy](https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/48-energy)

有關更多 eBPF 教程和項目，請訪問：[https://eunomia.dev/tutorials/](https://eunomia.dev/tutorials/)

## 結論

隨著我們努力實現更可持續的計算，能源監控變得越來越重要。本教程演示了 eBPF 如何在進程級別提供精確、低開銷的能源歸因，使開發人員和系統管理員能夠就能源效率做出明智的決策。

eBPF 的內核集成和高效事件處理的結合使其成為生產能源監控的理想選擇。無論您是優化數據中心工作負載、延長移動設備的電池壽命，還是隻是對應用程序的能源足跡感到好奇，eBPF 都提供了您進行詳細分析所需的工具。

隨著生態系統的成熟，像 Kepler 這樣的項目已經投入生產，cpufreq_ext 正在接近主線包含，我們正在進入一個能源感知計算成為默認而不是事後想法的時代。立即開始監控您的應用程序的能源消耗，為更可持續的計算未來做出貢獻！