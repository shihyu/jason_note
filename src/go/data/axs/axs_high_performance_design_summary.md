# axs 系統：為什麼能做到「百萬級吞吐」且「一塊錢都不會少」？（深度白話版）

簡單來說，axs 的設計哲學是：**「在記憶體裡飆車，但每一步都綁好安全帶」。**

## 1. 極速的核心：單線程 + 記憶體（飆車模式）

傳統資料庫之所以慢，是因為大家都在搶路（鎖競爭）。axs 的做法是把路分好，讓大家各跑各的。

*   **分道揚鑣（Sharding）**：
    系統把用戶分組（例如：小明歸 A 處理，小華歸 B 處理）。A 和 B 就像兩個獨立的會計，**互不干擾**。
*   **單線程飆車（Single Thread）**：
    因為小明的帳只有 A 會動，A 根本**不需要鎖**（不用擔心別人來搶），可以全速在記憶體裡按計算機。
*   **GC 優化（BigCache）**：
    為了怕垃圾回收車（Garbage Collection）出來擋路，axs 用了一種特殊的記憶體存法（BigCache），把幾萬筆帳單打包成一大包，讓垃圾回收車以為只有一件垃圾，直接開過去，不影響速度。

## 2. 聰明的批次處理：公車與臨時表（物流模式）

前面說過「公車原理」（累積一堆再寫資料庫），但 axs 在這點上做得更細緻。

*   **智慧等公車（Kafka Consumer Batching）**：
    它不會傻傻地等。
    *   如果有很多人（交易多），公車坐滿（例如 200 人）就馬上發車。
    *   如果沒人（交易少），最久只等 0.1 秒（100ms）就發車，保證不讓乘客等太久。
*   **高速卸貨（Copy & Temp Table）**：
    當這輛公車載著 1000 筆交易到達資料庫（金庫）時，傳統做法是一個人一個人下車（逐筆 Update），很慢。
    axs 的做法是：**開一條專用通道（Temp Table + COPY）**，把整車人直接「倒」進一個臨時區，然後用一個超級指令（Update Join）一次把所有帳目更新完。這招比傳統方法快 2-3 倍！

## 3. 鐵壁般的安全機制：綁定 Offset（安全帶模式）

這是有錢的系統，最怕就是「算錯」或「當機後資料亂掉」。axs 用了一個絕招來解決這個問題。

*   **生死與共（Transaction + Offset）**：
    在寫入資料庫時，它把「**用戶的錢**」和「**進度條（Kafka Offset）**」綁在一起。
    *   **情境**：電腦突然拔插頭。
    *   **結果**：因為「錢」沒寫進去，「進度條」也不會往前推。
    *   **恢復**：電腦重開後，看到進度條還在舊的地方，就會把剛才那批交易**重新拿出來算一遍**。
*   **防止腦裂（Leader Lock）**：
    如果有兩台電腦同時以為自己是「小明的會計」（腦裂），那帳就亂了。
    axs 在寫入資料庫的最後一刻，會再檢查一次：「我還是不是老大？」。如果發現令牌（Leader Lock）被搶走了，這筆帳就算算好了也不會寫進去，直接作廢。

## 4. 懶人新增法（Lazy Insert）

如果有新幣種（例如突然要存比特幣），傳統做法是先幫幾百萬用戶都開個比特幣帳戶（餘額 0），這會把資料庫操死。
axs 採用 **「要用再開」**：
*   你要存比特幣時，它才檢查你有沒有帳戶。
*   如果沒有，它用一個很厲害的 SQL 語法（CTE），在更新別人的同時，順便幫你開戶。一次工，兩件事，效率極高。

---

### 總結

axs 之所以強，是因為它：
1.  **完全不排隊**：用 Sharding 和單線程消滅了「鎖」。
2.  **記憶體運算**：避開了硬碟的龜速。
3.  **批次黑科技**：用 COPY 和 Temp Table 把資料庫寫入速度催到極限。
4.  **絕對安全**：用「資料庫交易綁定進度條」這招，保證了就算拔插頭，錢也一分不會少。

這就是一個**把物理極限（記憶體、IO）和邏輯安全（一致性）都算計到極致**的系統。
