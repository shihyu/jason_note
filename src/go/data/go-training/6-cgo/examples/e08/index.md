
用go語言實現一個sum函數，給C語言調用。

```go
package main

//int sum(int a, int b);
import "C"

//export sum
func sum(a, b C.int) C.int {
    return a + b
}

func main() {
	
}
```

將 Go 代碼編譯為一個 C 靜態庫，生成一個 sum.a 靜態庫和 sum.h 頭文件。其中 sum.h 頭文件將包含 sum 函數的聲明，靜態庫中將包含 sum 函數的實現。

```
# go build -buildmode=c-archive -o sum.a main.go
```

分析 cgo 生成的中間文件
```
# go tool cgo main.go
```

生成的文件包括
- _cgo_export.c：包含C語言版本的 sum 函數的實現
- _cgo_export.h：文件的內容和生成 C 靜態庫時產生的 sum.h 頭文件是同一個文件
- _cgo_gotypes.go
- main.cgo1.go
- main.cgo2.c

## 調用入口 _cgo_export.c
C語言版本的SUM函數位於_cgo_export.c中。
```
int sum(int a, int b)
{
	__SIZE_TYPE__ _cgo_ctxt = _cgo_wait_runtime_init_done();
	typedef struct {
		int p0;
		int p1;
		int r0;
	} __attribute__((__packed__)) _cgo_argtype;
	static _cgo_argtype _cgo_zero;
	_cgo_argtype _cgo_a = _cgo_zero;
	_cgo_a.p0 = a;
	_cgo_a.p1 = b;
	_cgo_tsan_release();
	crosscall2(_cgoexp_e81351f2a93e_sum, &_cgo_a, 12, _cgo_ctxt);
	_cgo_tsan_acquire();
	_cgo_release_context(_cgo_ctxt);
	return _cgo_a.r0;
}
```
sum函數負責工作如下
- 將 sum 函數的參數和返回值打包到一個結構體中
- 通過 runtime/cgo.crosscall2 函數將結構體傳給 _cgoexp_8313eaf44386_sum 函數執行

## Go運行時 runtime/cgo.crosscall2
在 crosscall2 的參數中，fn 是中間代理函數的指針，a 是對應調用參數和返回值的結構體指針
```
//file:runtime/cgo/asm_amd64.s
TEXT crosscall2(SB),NOSPLIT,$0-0
	PUSH_REGS_HOST_TO_ABI0()

	// Make room for arguments to cgocallback.
	ADJSP	$0x18
#ifndef GOOS_windows
	MOVQ	DI, 0x0(SP)	/* fn */
	MOVQ	SI, 0x8(SP)	/* arg */
	// Skip n in DX.
	MOVQ	CX, 0x10(SP)	/* ctxt */
#else
	MOVQ	CX, 0x0(SP)	/* fn */
	MOVQ	DX, 0x8(SP)	/* arg */
	// Skip n in R8.
	MOVQ	R9, 0x10(SP)	/* ctxt */
#endif

	CALL	runtime·cgocallback(SB)

	ADJSP	$-0x18
	POP_REGS_HOST_TO_ABI0()
	RET
```

在 crosscall2 中，調用 runtime·cgocallback。 runtime·cgocallback也是一個用匯編實現的函數。

```go
//file:runtime/asm_amd64.s
TEXT ·cgocallback(SB),NOSPLIT,$24-24
    ......
    MOVQ	$runtime·cgocallbackg(SB), AX
    .....
```

cgocallback
- 從m->g0的棧切換goroutine的棧，
- 並在這個棧中調用runtime.cgocallbackg(p.GoF, frame, framesize)
- 在runtime.cgocallback重獲控制權之後，它切換回m->g0棧，從棧中恢復之前的m->g0.sched.sp值，
- 最後返回到crosscall2

重點看runtime.cgocallbackg。 runtime.cgocallbackg現在是運行在一個真實的goroutine棧中（不是m->g0棧）。現在我們只是切換到了goroutine棧，此刻還是處於syscall狀態的。
因此這個函數會先調用runtime.exitsyscall，接著才是執行Go代碼。當它調用runtime.exitsyscall，這會阻塞這條goroutine直到滿足$GOMAXPROCS限制條件。

```go
//file:runtime/cgocall.go
// Call from C back to Go. fn must point to an ABIInternal Go entry-point.
func cgocallbackg(fn, frame unsafe.Pointer, ctxt uintptr) {
    gp := getg()

	// entersyscall saves the caller's SP to allow the GC to trace the Go
	// stack. However, since we're returning to an earlier stack frame and
	// need to pair with the entersyscall() call made by cgocall, we must
	// save syscall* and let reentersyscall restore them.
	savedsp := unsafe.Pointer(gp.syscallsp)
    savedpc := gp.syscallpc
    exitsyscall() // coming out of cgo call

	
	//調用用戶函數
    cgocallbackg1(fn, frame, ctxt) // will call unlockOSThread

    // going back to cgo call
    reentersyscall(savedpc, uintptr(savedsp))
    gp.m.syscall = syscall
    gp.m.syscallsp = sp
}

```

cgocallbackg1調用 reflectcall，正式進入到用戶定義的 Go 函數。
```go
//file:runtime/cgocall.go
func cgocallbackg1(fn, frame unsafe.Pointer, ctxt uintptr) {
	......
	// Invoke callback. This function is generated by cmd/cgo and
	// will unpack the argument frame and call the Go function.
	var cb func(frame unsafe.Pointer)
    cbFV := funcval{uintptr(fn)}
    *(*unsafe.Pointer)(unsafe.Pointer(&cb)) = noescape(unsafe.Pointer(&cbFV))
    cb(frame)
}
```

## 代理函數 _cgo_types.go

代理函數 _cgoexp_e81351f2a93e_sum 位於 _cgo_gotypes.go 文件中。

```go
func _cgoexp_e81351f2a93e_sum(a *struct {
		p0 _Ctype_int
		p1 _Ctype_int
		r0 _Ctype_int
	}) {
	a.r0 = sum(a.p0, a.p1)
}
```

通過代理函數調用到 main.go 函數中定義的 sum 函數。


## 總結
無論是Go調用C，還是C調用Go，其需要解決的核心問題其實都是提供一個C/Go的運行環境來執行相應的代碼。
Go的代碼執行環境就是goroutine以及Go的runtime，而C的執行環境需要一個不使用分段的棧，並且執行C代碼的goroutine需要暫時地脫離調度器的管理。
要達到這些要求，運行時提供的支持就是切換棧，以及runtime.entersyscall。

在Go中調用C函數時，runtime.cgocall中調用entersyscall脫離調度器管理。runtime.asmcgocall切換到m的g0棧，於是得到C的運行環境。
在C中調用Go函數時，crosscall2解決gcc編譯到6c編譯之間的調用協議問題。cgocallback切換回goroutine棧。 runtime.cgocallbackg中調用exitsyscall恢復Go的運行環境。

## C語言實際調用Go函數
Linux下使用靜態庫，只需要在編譯的時候，指定靜態庫的搜索路徑（-L選項）、指定靜態庫名（不需要lib前綴和.a後綴，-l選項）。

```shell
#gcc main.c -L../StaticLibrary -lstaticdemo
```
-L：表示要連接的庫所在目錄
-l：指定鏈接時需要的動態庫，編譯器查找動態連接庫時有隱含的命名規則，即在給出的名字前面加上lib，後面加上.a或.so來確定庫的名稱。

~~將go函數編譯為靜態庫~~
```shell
#go build -buildmode=c-archive -o libsum.a main.go
```

將go函數編譯為動態庫(測試通過)
```shell
#go build -o libsum.dylib -buildmode=c-shared main.go
```

c加載動態鏈接庫
```shell
#gcc main.c -L. -lsum
```

## 參考
- [cgo內部機制](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-05-internal.html)
- [cgo性能之謎](https://cloud.tencent.com/developer/article/1650525?areaId=106001)
- [Go語言中文網 - C調用go](https://books.studygolang.com/go-internals/09.4.html)
- [騰訊技術工程 - Go 與 C 的橋樑：cgo 入門，剖析與實踐](https://zhuanlan.zhihu.com/p/349197066)