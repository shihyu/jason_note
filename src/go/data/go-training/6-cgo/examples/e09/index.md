
go和其它語言互調要考慮如下幾個核心問題

- 線程與棧：
  - Go自己的函數使用的是goroutine，並使用特殊的棧（運行時可能會擴張）
  - C語言使用的是線程，並使用普通線程棧來運行，幸運的是m中的g0使用的就是這個棧。
- 系統調用處理
  - Go運行時為了保證始終是GOMAXPROCS個P在運行，
    - 會在系統調用之前先調用runtime.entersyscall，會將P的M剝離並將它設置為PSyscall。告知系統此時其它的P有機會運行。
    - 會在系統調用之後再runtime.exitsyscall，會查看當前仍然有可用的P，則讓它繼續運行，否則這個goroutine就要被掛起了
  - 為了不讓cgo代碼影響Go的調度，Go運行時將C函數像處理系統調用一樣隔離開來，要使用entersyscall、exitsyscall。
- 垃圾回收
  - Go語言中存在GC
  - C語言中沒有GC，需要依賴開發手動釋放
- 函數調用約定：調用約定規定了參數是使用寄存器，還是棧，入棧的話是從右往左，還是從左往右，堆棧是由被調用者清理，還是調用者清理
- 內存模型    

Go語言的實現中，包括如下兩個關鍵點
- CGO樁代碼生成
  - 負責C類型和Go類型之間的轉換
  - 命名空間處理以及特殊的調用方式處理
- 運行時支持
  - 負責處理好C的運行環境，類似於給C代碼一個非分段的棧空間並讓它脫離與調度系統的交互
  - go調用c的核心函數是runtime.cgocall
  - c調用go的核心函數是runtime.crosscall2


## 調用約定
C 語言 x86架構 常用的三種調用約定：
- cdecl，入參從右往左依次入棧，由調用者清理堆棧
- stdcall，入參從右往左依次入棧，由被調自己清理堆棧
- fastcall，使用 ecx、edx 傳遞前兩個參數，剩下的參數從右向左依次入棧，且由被調自己清理堆棧

C語言x86_64架構中
- 函數前 6 個參數通過寄存器 rdi、rsi、rdx、rcx、r8、r9 傳遞，超出的參數從右向左依次入棧
- 調用方清理棧

Go1.16調用約定
- 棧底到棧頂先儲存返回參數，然後儲存輸入參數，
- 壓棧順序按參數順序從右到左。
- main 函數分配的棧內存由 main 函數自己銷燬

Go1.17之後
- 使用 AX，BX，CX，DI，SI，R8，R9，R10，R11 傳遞前 9 個參數，剩餘 2 個參數按從右到左的順序依次壓棧
- 主調負責釋放參數佔用的棧空間

Go中使用的C編譯器其實是plan9的C編譯器,和gcc等會有一些區別。





## 內存管理
例如Golang採用垃圾回收機制，C語言採用手動釋放內存機制。

## 內存模型
如果在 CGO 處理的跨語言函數調用時涉及到了指針的傳遞，則可能會出現 Go 語言和 C 語言共享某一段內存的場景
- 在C語言中，只要沒有顯示釋放，內存默認是一直可用的
- 但在go語言中，可能會出現因為函數棧的動態伸縮而導致內存地址變化

在Go語言訪問C中內存的時候，一般不存在問題。但在C訪問Go內存的時候，可能會出現因為Go內存的動態伸縮而導致訪問不安全。

對於C臨時訪問傳入的Go內存
1、避免指針傳遞，全部使用值傳遞。不過會帶來一些額外的性能開銷。
2、CGO 規定在調用的 C 語言函數返回前，cgo 保證傳入的 Go 語言內存在此期間不會發生移動。 但需要開發者注意：
  - 保證在取得 Go 內存後需要馬上傳入 C 語言函數。因為在調用CGO之前還是可能變化的
  - 在需要長時間運行的 C 語言函數需要謹慎處理參數，因為運行期間協程棧無法擴縮

如果C需要長期訪問某個對象，可以以將 Go 語言內存對象在 Go 語言空間映射為一個 int 類型的 id，然後通過此 id 來間接訪問和控制 Go 語言對象。
這樣對象發生移動後，仍然可以通過id找到對應的值，而不會出現非法訪問。

 Go 語言的 new 函數分配，是由 Go 語言運行時統一管理的內存。所以默認 cgocheck 為1，檢查go導出的C函數中不能返回 Go 內存。
 如果需要可以將該選項調整成2或者0。


## Go使用C語言的方式
- 直接使用C語言的源代碼
- 使用C語言編譯出來的靜態鏈接庫
- 使用C語言編譯出來的動態鏈接庫



## 參考
- [C++/Go 調用約定](https://zhuanlan.zhihu.com/p/640963428)
- [CGO靜態庫和動態庫](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-09-static-shared-lib.html)