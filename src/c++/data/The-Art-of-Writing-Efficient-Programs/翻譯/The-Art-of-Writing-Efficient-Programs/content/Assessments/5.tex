\begin{enumerate}
\item 
内存模型描述了线程通过共享内存的交互方式，当多个线程访问内存中的相同数据时，内存模型是一组限制和保证。

\item 
一方面，如果不需要共享数据，所有线程都将完全独立运行，只要有更多的处理器可用，程序就可以完美地扩展了。而且，编写这样的程序和编写单线程程序差不多。另一方面，所有与并发相关的Bug最终都是对某些共享数据的无效访问引起的。

\item 
整个内存模型是系统不同组件的几个内存模型的叠加:首先，硬件有一个适用于运行任何程序的内存模型。操作系统和运行时环境可能提供额外的限制和保证。最后，编译器实现语言(如C++)的内存模型，如果提供的内存模型比语言需要的更严格，那么可能会有更多的限制。

\item
有几个因素限制了并发程序的性能。首先是并行工作的可用性(这个问题要通过并行算法的改进来解决，这超出了本书的范围)。其次，是硬件的可用性来完成这项工作(我们已经看到了程序被内存限制的例子)。最后，当线程必须并发访问相同的数据(共享数据)时，这种访问必须是同步的，编译器和硬件在这些同步访问之间优化执行的能力会受到限制。

\end{enumerate}