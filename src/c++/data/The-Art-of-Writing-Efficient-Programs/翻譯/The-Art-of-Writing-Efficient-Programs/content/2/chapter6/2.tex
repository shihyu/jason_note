使用并发性来提高性能非常简单，第一种方法是为并发线程和进程提供足够的工作，使它们始终处于忙碌状态；第二个是减少共享数据的使用，并发访问共享变量的开销非常大。剩下的只是如何实现的问题。

但实现往往相当残酷，而且当期望的性能增益更大，并且当硬件变得更强大时，难度就会增加。每个从事并发工作的开发者都听说过Amdahl法则，但并不是每个人都完全理解它的含义。

法则本身很简单：对于一个具有并行(可扩展)部分和单线程部分的程序，最大可能的加速\textit{s}如下所示:

\begin{center}
$ s = \dfrac{s_0}{s_0(1-p)+p} $
\end{center}

这里，计算是程序并行部分的加速比，也是程序并行部分的分数。现在考虑一下在大型多处理器系统上运行程序的情况:如果有256个处理器，并且能够充分利用它们，除了运行时间的1/256，程序的总加速会限制为128，加速比削减了一半。换句话说，如果只有1/256的程序是单线程的，或者是在锁下执行的，那么不管如何优化程序的其余部分，在这个256个处理器的系统的加速比永远不会超过50\%。

这就是为什么在开发并发程序时，设计、实现和优化的重点应该是使单线程计算并发化，并减少程序访问共享数据所花费的时间。

第一个目标，从算法的选择开始使计算并行化，但是许多设计决策会影响结果，所以应该更多地进行了解。第二种方法是降低数据共享的成本，延续了上一章的主题，当所有线程都在等待访问某个共享变量或锁(它本身也是一个共享变量)时，程序实际上是单线程的，只有当前有访问权限的线程在运行，这就是为什么全局锁和全局共享数据对性能不利的原因。但是，即使是多个线程之间共享的数据，如果并发访问这些线程，也会限制这些线程的性能。

数据共享的需求基本上是由问题本身导致的，特定问题的数据共享量可能受到算法、数据结构选择和其他设计决策以及实现的影响。有些数据共享是实现的产物，或数据结构选择的结果，但其他共享数据则是问题本身。如果需要计算满足某个属性的数据元素，比如只有一个计数，所有线程必须将其更新为共享变量。然而，实际发生了多少共享，以及对总体程序加速的影响，在很大程度上取决于具体实现。

本章中，我们将追寻两条线索:首先，考虑到一些不可避免的数据共享，将研究如何使这个过程更有效。然后，考虑设计和实现技术，这些可以用来减少数据共享的需求或减少等待访问该数据的时间。从第一个问题开始把，如何进行高效的数据共享。
































