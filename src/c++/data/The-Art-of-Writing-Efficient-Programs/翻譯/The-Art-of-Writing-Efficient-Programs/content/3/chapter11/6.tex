我们用了整整一章专门讨论C++和程序中的UB。为什么这么做？因为这个主题与性能有着千丝万缕的关系。

首先，当程序接收到指定程序行为之外的输入时，UB就会发生。此外，标准还说程序不需要检测这样的输入和发出诊断。这对于C++标准定义的UB和自己程序的UB都是正确的。

其次，规范(或标准)没有涵盖所有可能的输入和定义结果的原因，主要与性能有关。当可靠地生成特定结果的成本非常昂贵时，通常会引入UB。对于C++中的UB，处理器和内存架构的多样性也会导致无法统一处理的情况。如果没有一种可行的方法来保证一个特定的结果，这个标准就没有明确结果的。

最后，程序不需要检测(如果不处理)无效输入的原因是，这样的检测可能也会非常昂贵。有时确认输入是有效，会比计算结果花费更长的时间。

设计软件时，应该牢记这些点:总是希望有一个一般性约定来定义任何或任何输入的结果，但是这样做会给那些只提供典型或“正常”输入的用户带来不必要的性能开销。当用户可以在更快地执行想要执行的任务，以及可靠地执行一开始就不想执行的任务之间做出选择时，大多数用户会选择性能。作为一种妥协，可以为用户提供一种验证输入的方法。如果这种验证的代价很高，那么应该是可选的。

当涉及到C++标准的UB时，情况就变了，这时开发者就是用户。有必要理解，如果一个程序包含了UB的代码，那么整个程序都是定义不清的，而不仅仅是有问题的那一行。这是因为编译器可以假设UB永远不会在运行时发生，并据此推断对代码进行的相应优化。现代的编译器在某种程度上都会这样做，而未来的编译器可能会在他们的推断中更加激进。 

最后，许多编译器开发人员还提供了验证工具，可以在运行时检测未定义的行为——UB杀灭器。就像自己的程序的输入验证器一样，这些工具需要时间来运行，这就是为什么杀灭器是一个可选工具，应该在软件测试和开发过程中使用。

这本书快结束了。下一章，也就是最后一章，我们将回顾我们所学到的一切，并着眼于软件设计的含义和启示。
