未定义行为(UB)的概念有些神秘，对不了解情况的人来说，它是一种未初始化的警告。Usenet组织\texttt{comp.std.c}警告说:“\textit{当编译器遇到(一个未定义的结构)时，可以让恶魔从你的鼻子里飞出来。}”还有，发射核导弹和阉割你的猫(即使你没有养猫)等类似言论，都是在类似的背景下提出的。本章要揭开UB的面纱，虽然最终目标是解释UB与性能之间的关系，并展示如何利用UB，但只有在能够理性地讨论这一概念时才能做到。

首先，在C++(或其他编程语言)的上下文中，UB是什么？在标准中有使用了未定义行为或格式不良的程序。标准进一步说，如果行为没有定义，则标准对结果没有任何要求。相应的情况称为UB，如下代码:

\begin{lstlisting}[style=styleCXX]
int f(int k) {
	return k + 10;
}
\end{lstlisting}

标准规定，如果加法导致整数溢出(如果\texttt{k}大于\texttt{INT\_MAX-10})，则上述代码的结果未定义。

提到UB时，讨论倾向于两个极端，刚刚看到的第一个。夸张的语言可能是对UB危险的善意警告，但也会成为理性解释的障碍，因为鼻子和猫都不会受到编译器的攻击。编译器最终会根据程序生成一些代码，然后开发者会运行这些代码。它不会赋予计算机任何超能力:这个程序做的事情，开发者都可以自主完成，例如：用汇编程序手工编写一个相同的指令序列。如果开发者都无法执行\textit{发射核导弹}的机器指令，那么编译器也无法做到，不论UB是否存在(当然，如果正在为导弹发射控制器编程，那就是另外一个故事了)。当程序的行为未定义时，编译器根据标准可以生成开发者不期望的代码。

虽然夸大UB的危险没什么意思，但出现了针对UB进行推理的倾向，这也是一种不祥的做法。例如以下代码:

\begin{lstlisting}[style=styleCXX]
int k = 3;
k = k++ + k;
\end{lstlisting}

虽然C++标准已经逐步收紧了执行这类表达式的规则，但这个特定表达式的结果在C++17中仍没有定义。许多开发者低估了这种情况的危险性，会觉得“编译器要么先求k++，要么先求k+k”为了解释这里的错误和危险，必须先对标准进行分析。

C++标准有三个容易混淆的行为类别:定义的实现、未指定和未定义。实现必须提供实现定义的行为的确切规范。这不可选，符合标准的实现必须通过语言构造的行为来符合标准的描述。未指定行为与此类似，但实现没有义务记录该行为:标准通常提供可能的结果，而实现可以指定自己的结果，而不指定会是哪一个。最后，对于未定义行为，标准没有对整个程序的行为强加要求。标准没有说计算表达式\texttt{k++ + k}的几种备选方法中必须有一种发生(这将是未指定的行为，这不是标准所说的)。标准说整个程序都是病态的，并且对其结果没有任何限制(在为鼻子感到恐慌和恐惧之前，结果会限制为一些可执行代码)。

无论编译器在编译有UB代码行的时候做什么，必须以标准的方式处理代码的其余部分。因此(这个论证是这样的)，损坏仅限于特定代码行可能的结果。正如不夸大危险一样，理解这种观点为什么是错误的也很重要。编译器是基于这样的假设进行的:程序定义良好，在这种情况下(且仅在这种情况下)需要生成正确的结果。如果违背了这个假设，就没有什么先入为主的概念。描述这种情况的方法是，编译器零容忍UB。回到第一个例子:

\begin{lstlisting}[style=styleCXX]
int f(int k) {
	return k + 10;
}
\end{lstlisting}

由于程序定义不明，\texttt{k}大到足以引起整数溢出，因此编译器可以假定这种情况永远不会发生。那真的发生了呢？如果单独编译这个函数(在一个单独的编译单元中)，编译器会生成一些代码，为所有\texttt{k <= INT\_MAX-10}生成正确的结果。如果在编译器和链接器中没有整个程序的转换，那么对于更大的\texttt{k}，同样的代码可能会执行，结果与硬件在这种情况下所做事情一样。编译器可以插入对\texttt{k}的检查，也可能不会(但在某些编译器选项中可能会)。

如果函数是更大的编译单元的一部分呢？这就是有趣的地方了。编译器现在知道\texttt{f()}函数的输入参数是受限制的，那么这些信息就可以用于优化了。代码如下:

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{01\_opt.C}
\begin{lstlisting}[style=styleCXX]
int g(int k) {
	if (k > INT_MAX-5) cout << "Large k" << endl;
	return f(k);
}
\end{lstlisting}

如果\texttt{f()}函数的定义对编译器可见，编译器可以推断出打印输出从来没有发生过。如果\texttt{k}足够大，这个程序可以打印，那么整个程序就是病态的，标准不要求它打印。如果\texttt{k}的值在某个范围内，程序将不会打印。无论哪种方式，根据标准，什么都不打印都是有效结果。请注意，仅仅因为编译器目前没有做优化，并不意味着它永远不会做，这种类型的优化在新的编译器中可能会更加激进。

那么第二个例子呢？表达式\texttt{k++ + k}的结果对于\texttt{k}的值都是未定义的。编译器可以用做什么呢？同样，编译器不需要容忍UB。这个程序能够保持良好定义的唯一方法是永远不执行这一行。编译器可以先这样假设，然后进行反向推理，从而使这段代码的函数永远不会调用。

如果认为编译器不会做那些事情，那这里有一个惊喜:

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{02\_infC}
\begin{lstlisting}[style=styleCXX]
int i = 1;
int main() {
	cout << "Before" << endl;
	while (i) {}
	cout << "After" << endl;
}
\end{lstlisting}

这个程序的期望是打印\texttt{Before}并永远挂起。当用GCC(版本9，优化O3)编译时，行为与期望一致。当使用Clang(版本13，也是O3)编译时，会打印Before，然后After，然后立即终止，没有任何错误(不会崩溃，只是退出)。这两个结果都是有效的，因为遇到无限循环的程序的结果是未定义的(除非满足某些条件，而这里没有适用的条件)。

前面的例子对于理解为什么有UB具有指导意义。下一节中，将揭开面纱并解释UB产生的原因。

























