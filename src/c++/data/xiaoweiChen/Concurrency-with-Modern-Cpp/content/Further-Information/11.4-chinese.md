# 術語表

本術語表只為基本術語提供參考。

## ACID

事務具有原子性、一致性、隔離性和持久性(ACID)屬性的操作。在C++中，除了持久性之外，事務性內存的所有屬性都保持不變。

* 原子性：執行或不執行塊的所有語句。
* 一致性：系統始終處於一致的狀態，所有事務構建順序一致。
* 獨立性：每個事務在完全隔離的情況下運行。
* 會對事務的持久性進行記錄。

## CAS

CAS表示compare-and-swap，是一個原子操作。它將內存位置與給定值進行比較，如果內存位置與給定值相同，則修改內存位置的值。在C++中，CAS操作有`std::compare_exchange_strong`和`std::compare_exchange_weak`。

## 可調用單元

可調用單元的行為類似於函數。不僅是函數，還有函數對象和Lambda函數。如果一個可調用單元接受一個參數，它就被稱為一元可調用單元；如果有兩個參數，就是二元可調用單元。

謂詞是返回布爾值的特殊可調用項。

## 併發性

併發性意味著多個任務的重疊執行。而且，併發是並行的超集。

## 臨界區

臨界區是一段代碼，最多隻有一個線程可以訪問。

## 立即求值

如果立即求值，則立即求出表達式的值，則該策略與延遲求值正交。立即求值通常也稱為貪婪求值。

## Executor

執行者是與特定執行上下文相關聯的對象。它提供一個或多個執行函數，用於為可調用的函數對象創建執行代理。

## 函數對象

首先，不要叫它們[函子](https://en.wikipedia.org/wiki/Functor)。這是一個明確的數學術語，叫做[範疇理論](https://en.wikipedia.org/wiki/Category_theory)。

函數對象是行為類似於函數，通過實現函數調用操作符來實現這一點。由於函數對象是對象，因此可以有屬性和狀態。

```c++
struct Square{
	void operator()(int& i){i= i*i;}
};

std::vector<int> myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

std::for_each(myVec.begin(), myVec.end(), Square());

for (auto v: myVec) std::cout << v << " "; // 1 4 9 16 25 36 49 64 81 100
```

> **實例化函數對象**
>
> 常見的錯誤是在算法中使用函數對象(`Square`)的名稱，而不是函數對象(`Square()`)本身的實例，比如：`std::for_each(myVec.begin()， myVec.end()， Square)`，應該使用：`std::for_each(myVec.begin()， myVec.end()， Square())`。

## Lambda函數

Lambda函數可以就地提供需要的功能，編譯器當場就能得到相應的信息，因此具有極佳的優化潛力。Lambda函數可以通過值或引用來接收它們的參數，還可以通過值或引用捕獲已定義的變量。

```c++
std::vector<int> myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
std::for_each(myVec.begin(), myVec.end(), [](int& i){ i= i*i; });
// 1 4 9 16 25 36 49 64 81 100
```

> **應該首選Lambda函數**
>
> 如果可調用的功能是簡短和可以自解釋的，使用Lambda函數最好不過。Lambda函數通常比函數或函數對象更快，而且更容易理解。

## 延遲求值

[延遲求值](https://en.wikipedia.org/wiki/Lazy_evaluation)的情況下，僅在需要時才對表達式求值。該策略與立即求值策略正交。延遲求值通常稱為按需調用。

## 無鎖

如果保證了系統範圍內的進程無影響，那麼非阻塞算法就是無鎖的。

##未喚醒

未喚醒是指，線程由於競爭條件而丟失喚醒通知的情況。

如果使用沒有使用謂詞，可能會發生這種情況。

## 數學規律

某個集合X上的一個二進制操作(*)：

* 結合律，滿足x, y, z中的所有x, y, z的結合律：(x * y) * z = x * (y * z)
* 交換律，滿足所有x和y的交換律x * y = y * x

## 內存位置

內存位置的詳解可以參考[cppreference.com](http://en.cppreference.com/w/cpp/language/memory_model)

* 標量類型的對象(算術類型、指針類型、枚舉類型或`std::nullptr_t`。
*  非零長度的最大連續序列。

## 內存模型

內存模型定義了對象和內存位置之間的關係，特別是處理了以下問題：如果兩個線程訪問相同的內存位置，會發生什麼情況。

##修改順序

對特定原子對象M的所有修改，都以特定的順序進行，這個順序稱為M的修改順序。因此，線程讀取原子對象時，不會看到比線程已經觀察到的值更“舊”的值。

## Monad(單子)

Haskell作為一種純函數語言，只有純函數。這些純函數的一個關鍵特性，當給定相同的參數時，總是返回相同的結果。有了這個[透明參照](https://en.wikipedia.org/wiki/Referential_transparency)的屬性，Haskell函數才不會有副作用。因此，Haskell有一個概念上的問題。到處都是有副作用的計算，這些計算可能會失敗，可能返回未知數量的結果，或者依賴於環境。為了解決這個概念上的問題，Haskell使用單子並將它們嵌入到純函數語言中。

經典的單子封裝：

* I/O單子：計算輸入和輸出的結果。
* 可能性單子：可能會返回計算結果的單子。
* 錯誤單子：計算可能失敗。
* 列表單子：計算可以有任意數量的結果。
* 狀態單子：基於狀態的計算。
* 讀者單子：基於環境的計算。

單子的概念來自數學中的[範疇理論](https://en.wikipedia.org/wiki/Category_theory)，其處理對象之間的映射。單子是抽象的數據類型，將簡單的類型轉換為豐富的類型。這些豐富類型的值稱為一元值。當進入單子，一個值只能由一個函數組合轉換成另一個一元值。

這種組合尊重了單子的獨特結構。因此，當發生錯誤，錯誤單子中斷它的計算，或重新構建狀態單子的狀態。

一個單子包括三個部分:

* 類型構造函數：定義簡單數據類型，如何成為一元數據類型。
* 函數:
  * 恆等函數：在單子中引入一個簡單的值。
  * 綁定操作符：定義如何將函數應用於一元值，以獲得新的一元值。
*  功能規則:
  * 恆等函數的左右必須是恆等元素。
  * 函數的複合必須遵循結合律。

要使錯誤單子成為類型類單子的實例，錯誤單子必須支持恆等函數和綁定操作符，這兩個函數定義了錯誤單子應該如何處理計算中的錯誤。如果使用錯誤單子，錯誤處理會在後臺完成。

單子由兩個控制流組成：用於計算結果的顯式控制和用於處理特定副作用的隱式控制流。

當然，也可以用更少的詞來定義單子：“單子只是內函子類中的一個獨異點(monoid)。”

單子在C++中變得越來越重要。在C++ 17中，添加了[`std::optional`](http://en.cppreference.com/w/cpp/utility/optional) ，這是一種可能性單子。在C++20/23中，可能會從Eric Niebler那裡得到擴展future和[範圍庫]( http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html)，二者也都是單子。

## 無阻塞

如果任何線程的失敗或掛起，不會導致另一個線程的失敗或掛起，則稱為非阻塞。這個定義來自於[《Java併發實踐》]( http://jcip.net/)。

## 並行性

並行性意味著同時執行多個任務。並行性是併發性的一個子集。

## 謂詞

謂詞是返回布爾值的可調用單元。如果一個謂詞有一個參數，它就稱為一元謂詞。如果一個謂詞有兩個參數，就稱為二元謂詞。

## 模式

“每個模式規則都是一個由三部分組成，表明了特定上下文、問題和解決方案之間的關係。“ —— [Christopher Alexander](https://en.wikipedia.org/wiki/Christopher_Alexander)

## RAII

資源獲取是初始化(RAII)，代表C++中的一種流行技術，在這種技術中，資源的獲取和釋放與對象的生命週期綁定在一起。這意味著對於鎖，互斥鎖將被鎖定在構造函數中，並在析構函數中解鎖。這種RAII實現，也稱為範圍鎖定。

C++中的典型用例有：管理互斥鎖生命週期的鎖、管理資源(內存)生命週期的智能指針，或者管理元素生命週期的[標準模板庫容器](https://en.cppreference.com/w/cpp/container)。

## 釋放序列

原子對象M的釋放序列，以釋放操作A為首，是M修改順序中最大的連續子序列，其中第一個操作為A，每個後續操作為:

* 由執行A操作的線程進行的操作
* 原子的讀-改-寫操作。

## 順序一致的存儲模型

順序一致有兩個基本特徵:

1. 程序的指令是按源代碼順序執行的。
2. 所有線程上的所有操作都遵循全局順序。

## 序列點

序列點定義了程序執行過程中的任何一個結點。在這個點上，可以保證先前評估的所有執行效果，而不影響後續評估的 執行效果。

## 偽喚醒

偽喚醒是一種條件變量的現象。可能發生的情況是，條件變量的等待組件錯誤地獲取了一個通知。

## 線程

計算機科學中，執行線程是可由調度器獨立管理的最小程序指令序列，調度器通常是操作系統的一部分。線程和進程的實現在不同的操作系統之間是不同的，但是在大多數情況下，線程是進程的一個組件。多個線程可以存放在於一個進程中，併發執行並共享內存等資源，而不同的進程不共享這些資源。特別是，進程中的線程在任何給定時間，共享其可執行代碼和變量。想要了解更多信息，可以閱讀維基百科關於[線程](https://en.wikipedia.org/wiki/Thread_(computing))的文章。

## 全序關係

總序是一個二元關係(<=)在某個集合X上表現，其有反對稱性、傳遞性，完全性。

* 反對稱性：如果a <= b並且b <= a，則a == b
* 傳遞性：如果a <= b, b <= c，則a <= c
* 完全性：a <= b或b <= a

## volatile

volatile通常用於表示可以獨立於常規程序流進行更改的對象。例如，這些對象在嵌入式編程中表示一個外部設備(內存映射I/O)。由於這些對象可以獨立於常規程序流進行更改，並且其值可以直接寫入主內存，因此不會在緩存中進行優化存儲。

## 無等待

當有每個線程都有進程保證不會互相影響時，那麼一個非阻塞算法是無等待的。

