# 內存模型

多線程的基礎是定義良好的內存模型。對內存有基本的瞭解，有助於更深入地瞭解多線程的挑戰。

## 不要使用volatile進行同步

C++與C#或Java相比，`volatile`關鍵字沒有多線程語義。在C#或Java中，`volatile`聲明瞭一個原子變量，如`std::atomic`在C++中聲明瞭一個原子一樣，通常用於可以進行更改的對象。由於這一特性，沒有優化的存儲會發生在緩存中。

## 不要讓程序無鎖

這個建議聽起來很荒謬，但是這個建議的理由很簡單，無鎖編程非常容易出錯，並且需要在這個領域是專家級別的人，才能保證很少出錯。如果需要實現無鎖的數據結構，請務必注意ABA問題。

## 如果使用無鎖程序，請使用成熟的模式

如果已經確定要使用無鎖方案，那麼請使用成熟的模式。

1. 簡單的共享原子布爾值或原子計數器。
2. 使用線程安全，甚至無鎖的容器來支持消費者/生產者的場景。如果使用的容器是線程安全的，則可以將值放入容器中或從容器中取出，而不必擔心同步的問題。這就將應用程序的挑戰轉移到基礎設施中。

## 不要構建自定義的抽象方式，儘量使用當前語言能夠保證的方式

共享變量的線程安全初始化，可以通過多種方式完成。可以依賴於C++運行時的保證，比如：常量表達式、帶有塊作用域的靜態變量，或者使用函數`std::call_once`與`std::once_flag`組合使用。這裡用C++編程，即使使用非常複雜的獲取-發佈語義，也可以構建基於原子的抽象。一開始最好不要這樣做，除非不得已。這意味著，通過度量關鍵代碼的性能來確定瓶頸時，只有當明確自定義版本比當前語言默認的方式性能更好時，再進行更改。

## 不要重新發明輪子

編寫線程安全的數據結構是一項頗具挑戰性的工作，這要比編寫無鎖的數據結構更困難。因此，最好使用現成的庫，如[Boost.Lockfree](http://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html)或[CDS](http://http://libcds.sourceforge.net/).

**Boost.Lockfree**

Boost.Lockfree支持三種不同的數據結構:

Queue：無鎖的多生產/多消費者隊列

Stack：無鎖的多產品/多消費者堆棧

spsc_queue：無等待的單生產者/單消費者隊列(通常稱為環形緩衝區)

**CDS**

CDS代表併發數據結構，包含許多侵入式(非擁有)和非侵入式(擁有)容器。因為它們會自動管理元素，所以標準模板庫的容器是非侵入的。

* 堆棧(無鎖)
* 隊列和帶優先級的隊列 (無鎖)
* 有序列表
* 有序的set和map(無鎖和有鎖)
* 無序的set和map(無鎖和有鎖 )