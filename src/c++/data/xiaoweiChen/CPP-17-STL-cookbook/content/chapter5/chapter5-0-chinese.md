# 第5章 STL基礎算法

STL不僅包含數據結構，還有很多算法。數據結構可以幫助存放特定情況下需要保存的數據，而算法則會將數據結構中存儲的數據進行變換。

讓我們來看一個標準的例子，例如對`vector`實例中的數據進行累加。這個可以簡單的通過循環迭代`vector`中的元素，將所有值累加在一個對應的值上：

```c++
vector<int> v {100, 400, 200 /*, ... */ };

int sum {0};
for (int i : v) { sum += i; }

cout << sum << '\n';
```

不過，作為一個標準的例子，當然可以使用STL的算法來完成：

```c++
cout << accumulate(begin(v), end(v), 0) << '\n';
```

例子中循環變量也不是很長，不過其可讀性比`accumulate`差很多。一個10行的循環代碼看起來的確很尷尬，那麼本章我們就看來瞭解一下標準算法(`accumulate`,  `copy`,  `move`,  `transform`和`shuffle`等等)的工作機制。

其思想就是提供豐富的算法供開發者使用，避免耗費大量的時間在重複製造輪子上面。另一方面就是，即便開發者會自己去實現相應STL中的算法，也要進行大量的測試來確保自己實現的算法是否正確，STL提供的算法都是經過了嚴格的測試。所以沒有必要做重複的工作，這樣也能節省代碼審閱者的時間，否則他們還要確定算法實現中是否有Bug。

另一個重點是STL算法非常的高效。很多STL算法提供了多種特化實現，這樣足以應對依賴迭代器類型的使用方式。例如，將`vector`中的所有元素都填充0時，就可以使用`std::fill`。因為`vector`使用的是一段連續的內存，對於這種使用連續內存存放數據的結構都可以使用`std::fill`進行填充，這個函數類似於C中的`memset`函數。當開發者將容器類型從`vector`改為`list`，STL算法就不能再使用`memset`了，並且需要逐個迭代list的元素，並將元素賦0。開發者不能為了使用`memset`將數據類型寫死為`vector`或`array`，因為實際項目中，還是有很多數據結構存儲的地址並不是連續的。大多數情況下，想要自己去將代碼實現的更聰明是沒有太多意義的，因為STL的實現者已經考慮到了這種情況，並且STL還是免費使用的，為什麼不用呢？

讓我們總結一下前面提到的幾點。使用STL算法的好處：

- **維護性**：算法的名字已經說明它要做什麼了。顯式使用循環的方式與使用STL算法的方式沒法對比。
- **正確性**：STL是由專家編寫和審閱過的，並且經過了良好的測試，重新實現的複雜程度可能是你無法想象的。
- **高效性**：STL算法真的很高效，至少要比手寫的循環要強許多。

很多算法都是對迭代器進行操作，第3章已經解釋了迭代器的工作原理。本章專注於如何使用STL算法解決各種問題，瞭解這些STL應該如何使用。要展示所有STL算法的使用方式不是本書所要做的事情，這個事情C++手冊已經完成了，你可以在網上進行查詢，或者花錢購買電子/紙質發佈版本。

作為一個STL“忍者”需要將C++手冊放在手邊……嗯，至少放在瀏覽器的書籤中吧。當我們在完成一個任務的過程中，每個開發者都可以回看一下任務本身，在完成自己的任務時，確定這個STL算法是否適合於你的問題。

在線版本的C++手冊：http://cppreference.com

其也提供離線下載功能。

> Note:
>
> 在面試過程中，對於STL算法的熟悉程度也是判斷一個開發者對C++的熟悉程度的標準之一。

