# 第9章 并行和并发

C++11之前，C++原生不支持并发和并发。但这并不意味着无法对线程进行操作，只不过需要使用系统库的API进行操作(因为线程与操作系统是不可分开的)。

随着C++11标准的完成，我们有了`std::thread`，其能给予我们可以在所有操作系统上可移植的线程操作。为了同步线程，C++11也添加了互斥量，并且对一些RAII类型的锁进行了封装。另外，`std::condition_variable`也能够灵活的在线程间，进行唤醒操作。

另一些有趣的东西就是`std::async`和`std::future`——我们可以将普通的函数封装到`std::async`中，可以在后台异步的运行这些函数。包装后函数的返回值则用`std::future`来表示，函数的结果将会在运行完成后，放入这个对象中，所以可以在函数完成前，做点别的事情。

另一个STL中值得一提提升就是*执行策略*，其被添加到已有的69种算法中。这样就可以对现有的STL算法不做任何修改，就能享受其并行化带来的性能提升。

本章中，我们将通过例子来了解其中最为核心的部分。之后，我们也将了解到C++17对并行的支持。不会覆盖所有的细节，但是比较重要的部分肯定会介绍。本书会快速的帮助你了解并行编程机制，至于详细的介绍，可以在线对C++17 STL文档进行查阅。

最后，本章中最后两节值的注意。倒数第二节中，我们将并行化[第6章的ASCII曼德尔布罗特渲染器](content/chapter6/chapter6-5-chinese.md)，使用STL进阶用法让代码改动程度最小。最后一节中，我们将实现一个简单的库，其可以用来隐式并行复杂的任务。





