# 第2章 STL容器

C++標準庫中有大量的標準容器。容器通常包含一組數據或對象的集合。容器的厲害之處在於幾乎可以和任何類型的對象一起使用，所以我們只需要為程序選擇合適的容器即可。STL帶給我們棧、自動增長的vector、map等等。這樣我們就可以集中精力於我們的應用，而不用重複製作輪子。瞭解所有容器，對於C++開發者來說至關重要。

STL容器的分類如下，會在各節中進行詳細描述：

- 連續存儲
- 列表存儲
- 搜索樹
- 哈希表
- 容器適配器

## 連續存儲

想要存儲一組對象最簡單的方式，就是將其一個接一個的存在一塊比較大的內存當中。內存可以使用隨機訪問的方式進行，其時間複雜度為O(1)。

最簡單的方式就是使用`std::array`，其就是對C風格數組的一種包裝。不過，`std::array`要比C風格數組要先進的多，因為其沒有運行時開銷，而且進行元素添加時，也會十分舒適和安全。還有一點和C風格數組一樣，一旦創建，其長度就是固定的，創建過後無法改變長度。

`std::vector`和`std::array`很類似，不過`std::vector`的長度可變。其會使用堆上的內存來存儲對象。當新元素添加到`vector`中後，當前長度超過了原始的長度，那麼`std::vector`會自動新分配一段更大的內存，用來放置包括新插入元素的所有元素，並且釋放之前所佔用的內存。此外，當新元素需要插入到兩個舊元素之間時，`std::vector`會移動當前已有的元素。當要刪除`vector`中間的一個已存在元素，那麼`vector`類會自動地移動其他對象，將刪除後的縫隙填補起來。

如果有大量元素在`std::vector`的頭部或尾部進行插入或刪除，那麼為了填補空隙和移動已有元素，將會耗費很多時間。如遇到這樣的情況，建議你考慮使用`std::deque`。對象集合會存儲在多段固定長度的連續內存中，這些內存段是相互獨立的。這就使得雙向隊列變得很簡單，並且增長也很容易，因為不同的內存段相對獨立，只需要將新分配的內存段加入就可以了，無需對其他已存在的內存段進行移動。減少的場景也是一樣的。

## 列表存儲

`std::list`是一個典型的雙向鏈表。如果是單向列表，那就需要進行遍歷，所以`std::forward_list`的優勢在維護的複雜性上，因為其指針方向只有一個方向。列表遍歷的時間複雜度是線性的O(n)。其在特定位置上插入和刪除元素的時間複雜度為O(1)。

## 搜索樹

當對象集具有可進行排序的自然屬性時，可以使用小於的關係將這些元素進行排序，我們就可以使用搜索樹來保存這個排序關係。從名字就可以看出，搜索樹可以幫助我們很容易的通過一個關鍵字查找到對應元素，其搜索的時間複雜度為O(log(n))。

STL提供了不同種類的樹，`std::set`是其中最簡單的一種，保存元素不重複，存儲的元素是可排序的(用一種樹的結構)。

`std::map`使用的是另一種方式，將存儲的數據使用組對進行存儲。一個組對有一個key值和一個對應值構成。搜索樹會對key值部分進行排序，使組對能作為`std::map`的一種關聯容器。`std::map`的key值和`std::set`的值一樣，在整個樹中只能存在一個。

`std::multiset`和`std::multimap`是被特化的，key對象可以是重複的。

## 哈希表

討論關聯容器時，搜索樹並不是唯一的方式。使用哈希表查找元素的時間複雜度只有O(1)，不過這就會忽略其自然序，所以不能簡單的使用排序的方式進行遍歷。哈希表大小可由用戶控制，並且可以單獨選擇哈希函數，這是一項很重要的特性，因為其性能與空間複雜度依賴於此。

`std::unordered_set`和`std::unordered_map`具有很多接口與`std::set`和`std::map`一樣，它們之間幾乎可以相互替換。

搜索樹的實現中，容器都具有多個變種： `std::unordered_multiset`和`std::unordered_multimap`，這兩種方法都取消了對象/鍵的唯一性，因此我們可以用相同的鍵存儲多個元素。

## 容器適配器

數組、列表、樹和哈希表並不是存儲和訪問數據的唯一方式，這裡還有棧、隊列等其他的方式也可以存儲和訪問數據。類似的，越複雜的結構可以使用越原始的方式實現，並且STL使用以下形式的容器適配器進行操作：`std::stack`、`std::queue`和`std::priotity_queue`。

最牛X的是當我們需要這樣的數據結構時，我們可以選擇一種適配器。然後，當我們覺得到它們性能較差時，就可以改變一個模板參數，以便讓適配器使用不同的容器實現。實踐中，這也就意味著我們可以將`std::stack`實例中的元素類型從`std::vector`切換成`std::deque`。