# 以O(1)的時間複雜度刪除未排序std::vector中的元素

因為其他元素要填補刪除元素所留下來的空隙，從而需要進行移動，所以從`std::vector`中刪除元素的時間複雜度為O(n)。

移動其他元素也與此類似，當很多很大或很複雜的元素需要移動，那麼就會花費很長的時間。當無法保證順序時，我們需要對其進行優化，這就是本節的內容。

## How to do it...

我們繼續使用一些數字來填充`std::vector`實例，並且實現一個快速刪除函數，以O(1)的時間複雜度刪除vector中的元素。

1. 首先，包含必要的頭文件：

   ```c++
   #include <iostream>
   #include <vector>
   #include <algorithm>
   ```

2. 定義主函數，並定義一個`vector`實例：

   ```c++
   int main(){
       std::vector<int> v{123, 456, 789, 100, 200}; 
   ```

3. 下一步就要刪除索引為2的元素(789)。我們所要用的來刪除元素的函數在後面進行實現，我們先假設已經實現好了。執行完成後，來看下`vector`中的內容。

   ```c++
       quick_remove_at(v, 2);
       for (int i : v){
           std::cout << i << ", ";
       }
       std::cout << '\n';
   ```

4. 現在，我們將刪除另外一個元素。我們想刪除123，但是要假裝不知道其索引。因此，我們要使用`std::find`函數在vector的合法範圍內查找這個值，並返回其位置信息。得到索引信息後，我們就可以用`quick_remove_at`將對應元素刪除了，這裡所使用到的是一個重載版本，能接受迭代器作為輸入參數。

   ```c++
       quick_remove_at(v, std::find(std::begin(v), std::end(v), 123));
       for (int i : v) {
      		std::cout << i << ", ";
       }
       std::cout << '\n';
   }
   ```

5. 我們實現了兩種`quick_remove_at`函數。具體實現代碼中，需要注意與`main`函數的前後關係。兩個函數都能接收一個`vector`實例的引用，所以這裡允許用戶使用各種類型的變量作為元素。對於我們來說，其類型就是`T`。第一個 `quick_remove_at`函數用來接收索引值，是一個具體的數，所以其接口如下所示：

   ```c++
   template <typename T>
   void quick_remove_at(std::vector<T> &v, std::size_t idx)
   {
   ```

6. 現在來展示一下本節的重點——如何在不移動其他元素的情況下，快速刪除某個元素？首先，將`vector`中最後一個元素進行重寫。第二，刪除`vector`中最後一個元素。就這兩步。我們的代碼會對輸入進行檢查。如果輸入的索引值超出了範圍，函數不會做任何事情。另外，該函數會在傳入空`vector`的時候崩潰。

   ```c++
       if (idx < v.size()) {
           v[idx] = std::move(v.back());
           v.pop_back();
       }
   }
   ```

7. 另一個`quick_remove_at`實現也很類似。用`std::vector<T>`的迭代器替換了具體的索引數值。因為泛型容器已經定義了這樣的類型，所以獲取它的類型並不複雜。

   ```c++
   template <typename T>
   void quick_remove_at(std::vector<T> &v,
   				    typename std::vector<T>::iterator it)
   {
   ```

8. 現在我們來訪問這些迭代器所指向的值。和另一個函數一樣，我們會將最後一個元素進行重寫。因為這次處理的是迭代器，所以我們要對迭代器指向的位置進行檢查。如果其指向了一個錯誤的位置，我們就會阻止其解引用。

   ```c++
   	if (it != std::end(v)) {
   ```

9. 在該代碼塊中，我們會做和之前一樣的事情——我們要覆蓋最後一個位置上的值——然後將最後一個元素從`vector`中剪掉。

   ```c++
           *it = std::move(v.back());
           v.pop_back();
       }
   }
   ```

10. 這就完事了。讓我們來編譯程序，並運行：

   ```txt
   $ ./main
   123, 456, 200, 100,
   100, 456, 200,
   ```

## How it works...

`quick_remove_at`函數移除元素非常快，而且不需要動其他元素。這個函數使用了更加具有創造性的做法：這是一種與實際元素交換的方式，然後將最後一個元素從`vector`中刪除。雖然，最後一個元素與選中的元素沒有實際的關聯，但是它在這個特別的位置上，而且刪除最後一個元素的成本最低！`vector`的長度在刪除完成後，也就減少1，這就是這個函數所要做的。並且無需移動任何元素。看一下下面的圖，可能有助於你理解這個函數的原理。

![](../../images/chapter2/2-2-1.png)

完成這兩步的代碼如下：

```c++
v.at(idx) = std::move(v.back());
v.pop_back();
```

迭代器版本實現幾乎一模一樣：

```c++
*it = std::move(v.back());
v.pop_back();
```

邏輯上，我們將選定元素與最後一個元素進行交換。不過，在代碼中元素並沒有進行交換，代碼直接使用最後一個值覆蓋了選定元素的值。為什麼要這樣？當我們交換元素時，就需要將選定的元素存儲在一個臨時變量中，並在最後將這個臨時變量中的值放在`vector`的最後。這個臨時變量是多餘的，而且要刪除的值對於我們來說是沒有意義的，所以這裡選擇了直接覆蓋的方式，更加高效的實現了刪除。

好了，交換是無意義的，覆蓋是一種更好的方式。讓我們來看下這個，當我們要獲取`vector`最後元素的迭代器時，只需要簡單的執行`*it = v.back();`就行了，對吧？完全正確，不過試想我們存儲了一些非常長的字符串在`vector`中，或存儲了另一個`vector`或`map`——這種情況下，簡單的賦值將對這些值進行拷貝，那麼就會帶來非常大的開銷。這裡使用`std::move`可將這部分開銷優化掉：比如字符串，指向堆內存上存儲的一個大字符串。我們無需拷貝它。只需要移動這個字符串即可，就是將目標指針指向這塊地址即可。移動源保持不變，不過出於無用的狀態，這樣做可以類似的讓目標指針指向源指針所在的位置，然後將原始位置的元素刪除，這樣做即完成了元素移動，又免去了移動消耗。