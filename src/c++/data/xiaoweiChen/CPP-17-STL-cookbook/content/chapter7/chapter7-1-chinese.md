# 创建、连接和转换字符串

熟悉C++的“老人”们对`std::string`一定不会陌生。在处理C风格的字符串时，会感觉冗余和痛苦，特别是在于解析、连接和复制这些字符串的时候，而使用`std::string`确实一种简单的安全的方法。

要特别感谢C++11添加了移动的特性，这样我们就可以对字符串的所有权进行转移。这样，很多情况下的开销就能降的很低。

`std::string`也随着标准的更新添加了新的特性。C++17中添加了一个全新的类——`std::string_view`。本节我们将在C++17下感受一下这些新特性(将在其他节中使用`std::string_view`新类，来连接多个字符串)。

## How to do it...

本节，将创建几个字符串和几个字符串代理，并使用它们进行对字符串的连接和转换：

1. 包含必要的头文件，并声明所使用的命名空间：

   ```c++
   #include <iostream>
   #include <string>
   #include <string_view>
   #include <sstream>
   #include <algorithm>
   
   using namespace std; 
   using namespace std::literals;
   ```

2. 首先来创建字符串对象，这里`a`就为一个`string`对象。我们使用C风格的字符串对其进行构造(编译后，C风格的字符串就成为静态数组)。构造函数将对其进行拷贝，然后构成一个字符串对象。或者也可直接使用字符字面值操作符`""s`来代替C风格的字符串。其也会在运行时创建一个字符串对象，这里`b`也是一个字符串对象，不过这里我们让程序自己去推断这个类型：

   ```c++
   int main()
   {
   	string a { "a" };
   	auto b ( "b"s ); 
   ```

3. 构造字符串对象的时候，会将相应的内容拷贝到字符串的内部内存中。为了不拷贝，可以直接对输入字符串进行引用，这里就用一下`string_view`。这个类具有一个字面值操作，称为`""sv`：

   ```c++
   	string_view c { "c" };
   	auto d ( "d"sv );
   ```

4. OK！现在就让我们来用一下字符串和代理字符串吧！对于这两种类型，其`operator<<`都是对`std::ostream`类型重载的类型，所以这两种类型可以直接打印：

   ```c++
   	cout << a << ", " << b << '\n';
   	cout << c << ", " << d << '\n'; 
   ```

5. 字符串类也对`operator+`操作进行了重载，所以可以直接将两个字符串进行连接。连接`a`和`b`只要使用`+`操作就能完成。对于`a`和`c`来说，就没有那么简单了，因为c不是一个字符串对象，而是一个字符串代理对象。我们必须先获取`c`的字符串，这步可以通过对`c`进行新的字符串构造得到，然后再和`a`进行相加。这里就有一个问题，“等下！只是为了和`a`相加，我们就要将`c`的内容拷贝到临时字符串对象中吗？没有避免使用`c.data()`进行内容拷贝的方法吗？”这个想法很好，但是类型本身具有缺陷——`string_view`实例中没有终止符。这个很可能会导致缓存溢出：

   ```c++
   	cout << a + b << '\n';
   	cout << a + string{c} << '\n'; 
   ```

6. 我们来创建一个新的字符串，其包含我们之前创建的所有字符串和字符串代理。使用`std::ostringstream`，我们能将任意的变量通过流对象进行打印(类似`std::cout`)，不过其不会显示在终端，而是打印到一个字符串缓存中。对于所有的字符串，我们是用空格对这些字符串进行分割，并使用`operator<<`将这些字符串打印到新的字符串对象中(使用`o.str()`):

   ```c++
   ostringstream o;
   
   o << a << " " << b << " " << c << " " << d;
   auto concatenated (o.str());
   cout << concatenated << '\n';
   ```

7. 这时我们可以通过相应的函数，将新字符串中所有的字符转换成大写字符。这里使用C库中的`toupper`函数来完成将字母转换为大写的工作，可将其与`std::transform`相结合。因为这里字符串的基础类型为`char`，所以可以直接使用：

   ```c++
       transform(begin(concatenated), end(concatenated),
       		 begin(concatenated), ::toupper);
       cout << concatenated << '\n';
   }
   ```

8. 编译并运行程序，将会得到如下输出：

   ```c++
   $ ./creating_strings
   a, b
   c, d
   ab
   ac
   a b c d
   A B C D
   ```

## How it works...

显然，字符串可以通过加法操作进行连接。如果要对`string_view`使用这个特性，我们首先需要将其转化为`std::string`。

不过，进行字符串和字符串代理编码时要格外注意，`string_view`的内容中没有终止符！这也就是为什么我们宁愿写成` "abc"s + string{some_string_view}`，而不写成`"abc"s + some_string_view.data()`的原因。除此之外，`std::string`也提供了`append`成员函数，其能对`string_view`实例进行处理，不过其会对字符串的内容直接进行操作。

> Note：
>
> `std::string_view`是非常有用的，不过为了将其与字符串和字符串函数相混合。我们不能假设其具有终止符，其会在标准字符串环境中快速的跳出。幸运的是，通常一些函数的重载版本，可以对其进行正确的处理。

如果我们想要将更为复杂的字符串进行格式化连接，不需要对字符串实例进行逐个处理。`std::stringstream`，`std::ostringstream`和`std::istringstream`类就适合来处理这种任务，它们能对通过对内存的管理来进行字符串的添加，并且能提供流所具有的所有通用格式化特性。这也就是本节为什么选择`std::ostringstream`类的原因，其可以很方便的对变量类型进行解析，然后将其放入字符串中。如果想将输入输出进行结合，那么`std::stringstream`则是一个不错的选择。