# 創建、連接和轉換字符串

熟悉C++的“老人”們對`std::string`一定不會陌生。在處理C風格的字符串時，會感覺冗餘和痛苦，特別是在於解析、連接和複製這些字符串的時候，而使用`std::string`確實一種簡單的安全的方法。

要特別感謝C++11添加了移動的特性，這樣我們就可以對字符串的所有權進行轉移。這樣，很多情況下的開銷就能降的很低。

`std::string`也隨著標準的更新添加了新的特性。C++17中添加了一個全新的類——`std::string_view`。本節我們將在C++17下感受一下這些新特性(將在其他節中使用`std::string_view`新類，來連接多個字符串)。

## How to do it...

本節，將創建幾個字符串和幾個字符串代理，並使用它們進行對字符串的連接和轉換：

1. 包含必要的頭文件，並聲明所使用的命名空間：

   ```c++
   #include <iostream>
   #include <string>
   #include <string_view>
   #include <sstream>
   #include <algorithm>
   
   using namespace std; 
   using namespace std::literals;
   ```

2. 首先來創建字符串對象，這裡`a`就為一個`string`對象。我們使用C風格的字符串對其進行構造(編譯後，C風格的字符串就成為靜態數組)。構造函數將對其進行拷貝，然後構成一個字符串對象。或者也可直接使用字符字面值操作符`""s`來代替C風格的字符串。其也會在運行時創建一個字符串對象，這裡`b`也是一個字符串對象，不過這裡我們讓程序自己去推斷這個類型：

   ```c++
   int main()
   {
   	string a { "a" };
   	auto b ( "b"s ); 
   ```

3. 構造字符串對象的時候，會將相應的內容拷貝到字符串的內部內存中。為了不拷貝，可以直接對輸入字符串進行引用，這裡就用一下`string_view`。這個類具有一個字面值操作，稱為`""sv`：

   ```c++
   	string_view c { "c" };
   	auto d ( "d"sv );
   ```

4. OK！現在就讓我們來用一下字符串和代理字符串吧！對於這兩種類型，其`operator<<`都是對`std::ostream`類型重載的類型，所以這兩種類型可以直接打印：

   ```c++
   	cout << a << ", " << b << '\n';
   	cout << c << ", " << d << '\n'; 
   ```

5. 字符串類也對`operator+`操作進行了重載，所以可以直接將兩個字符串進行連接。連接`a`和`b`只要使用`+`操作就能完成。對於`a`和`c`來說，就沒有那麼簡單了，因為c不是一個字符串對象，而是一個字符串代理對象。我們必須先獲取`c`的字符串，這步可以通過對`c`進行新的字符串構造得到，然後再和`a`進行相加。這裡就有一個問題，“等下！只是為了和`a`相加，我們就要將`c`的內容拷貝到臨時字符串對象中嗎？沒有避免使用`c.data()`進行內容拷貝的方法嗎？”這個想法很好，但是類型本身具有缺陷——`string_view`實例中沒有終止符。這個很可能會導致緩存溢出：

   ```c++
   	cout << a + b << '\n';
   	cout << a + string{c} << '\n'; 
   ```

6. 我們來創建一個新的字符串，其包含我們之前創建的所有字符串和字符串代理。使用`std::ostringstream`，我們能將任意的變量通過流對象進行打印(類似`std::cout`)，不過其不會顯示在終端，而是打印到一個字符串緩存中。對於所有的字符串，我們是用空格對這些字符串進行分割，並使用`operator<<`將這些字符串打印到新的字符串對象中(使用`o.str()`):

   ```c++
   ostringstream o;
   
   o << a << " " << b << " " << c << " " << d;
   auto concatenated (o.str());
   cout << concatenated << '\n';
   ```

7. 這時我們可以通過相應的函數，將新字符串中所有的字符轉換成大寫字符。這裡使用C庫中的`toupper`函數來完成將字母轉換為大寫的工作，可將其與`std::transform`相結合。因為這裡字符串的基礎類型為`char`，所以可以直接使用：

   ```c++
       transform(begin(concatenated), end(concatenated),
       		 begin(concatenated), ::toupper);
       cout << concatenated << '\n';
   }
   ```

8. 編譯並運行程序，將會得到如下輸出：

   ```c++
   $ ./creating_strings
   a, b
   c, d
   ab
   ac
   a b c d
   A B C D
   ```

## How it works...

顯然，字符串可以通過加法操作進行連接。如果要對`string_view`使用這個特性，我們首先需要將其轉化為`std::string`。

不過，進行字符串和字符串代理編碼時要格外注意，`string_view`的內容中沒有終止符！這也就是為什麼我們寧願寫成` "abc"s + string{some_string_view}`，而不寫成`"abc"s + some_string_view.data()`的原因。除此之外，`std::string`也提供了`append`成員函數，其能對`string_view`實例進行處理，不過其會對字符串的內容直接進行操作。

> Note：
>
> `std::string_view`是非常有用的，不過為了將其與字符串和字符串函數相混合。我們不能假設其具有終止符，其會在標準字符串環境中快速的跳出。幸運的是，通常一些函數的重載版本，可以對其進行正確的處理。

如果我們想要將更為複雜的字符串進行格式化連接，不需要對字符串實例進行逐個處理。`std::stringstream`，`std::ostringstream`和`std::istringstream`類就適合來處理這種任務，它們能對通過對內存的管理來進行字符串的添加，並且能提供流所具有的所有通用格式化特性。這也就是本節為什麼選擇`std::ostringstream`類的原因，其可以很方便的對變量類型進行解析，然後將其放入字符串中。如果想將輸入輸出進行結合，那麼`std::stringstream`則是一個不錯的選擇。