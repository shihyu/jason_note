# 從std::iostream錯誤中獲取可讀異常

本書之前的章節中，我們還沒對異常進行過捕獲。不過對於流對象不會拋出異常，所以很容易使用。當我們想要解析10個數，不過解析過程在中途失敗了，那麼流對象將會將自身設置為失敗狀態，並且不會繼續對數字進行解析。這樣，我們就不會讓程序處於危險當中。我們可以將解析過程轉換為一個條件變量，比如`if (cin >> foo >> bar >> ...)`。如果這個判斷失敗了，那我們將對輸入進行處理。所以，這裡並不會出現`try-catch`代碼塊。

實際上，之前的C++輸入輸出流是會拋出異常的。異常這個特性是不是一開始就有的，所以這也可能是流對象庫並不是第一個支持異常特性的原因。

為了對流使用異常，我們必須對每個流對象單獨進行配置，讓其在失敗的時候拋出一個異常。不幸的是，我們可以對對象的異常進行捕獲，但是這步並沒有標準化。這就導致我們無法獲得有效的錯誤信息，我們將在後續的實例中看到。如果我們很想對流對象使用異常，那麼可以使用C庫中有關文件系統錯誤狀態，來獲取更多的信息。

本節中，我們將會通過不同的方式，讓程序運行失敗，然後來處理這些異常，並且瞭解如何獲取更多的有效信息。

## How to do it...

我們將會讓程序打開一個文件(這個過程可能會失敗)，並且將會從文件中讀取一個整型數字(也可能會失敗)。我們可以通過激活異常的方式來發現錯誤，然後再來看如何對這些錯誤進行處理：

1. 包含必要的頭文件，並聲明所使用的命名空間：

   ```c++
   #include <iostream>
   #include <fstream>
   #include <system_error>
   #include <cstring>
   
   using namespace std;  
   ```

2. 當我們要將流對象和異常一起使用時，首先需要啟動異常。為了獲取一個文件流對象，在指定文件並不存在時，拋出一個異常；或是在解析錯誤時，我們需要將對應的失敗原因設置到異常掩碼的對應位上。當執行失敗的時候，將觸發一個異常。並通過激活的`failbit`和`badbit`，我們能讓文件系統的錯誤拋出異常，並對這個錯誤進行解析：

   ```c++
   int main()
   {
   	ifstream f;
   	f.exceptions(f.failbit | f.badbit);	
   ```

3. 現在可以使用`try`塊進行對文件的訪問。文件打開成功，那我們將繼續讀取文件中的整型數字。並且，只有在讀取數字成功的情況下，我們才會對數字進行打印：

   ```c++
       try {
           f.open("non_existant.txt");
           
           int i;
           f >> i;
           
           cout << "integer has value: " << i << '\n';
       }
   ```

4. 對於可能發生的兩種錯誤，一個`std::ios_base::failure`實例將會拋出。這個對象有一個`what()`成員函數，其會為我們解釋觸發了哪種異常。不幸的是，並不存在標準化的信息，所以我們不會得到太多有用的信息。不過，我們至少可以區分，觸發異常的是一個文件系統問題，還是一個格式解析問題。全局變量`errno`，其在C++誕生前就存在，其會設置為一個錯誤值，可供我們進行查看。`strerror`函數會將一個錯誤值，翻譯為我們可以讀懂的字符串。當`errno`是0時，就代表文件系統沒有任何錯誤：

   ```c++
       catch (ios_base::failure& e) {
           cerr << "Caught error: ";
           if (errno) {
               cerr << strerror(errno) << '\n';
           } else {
               cerr << e.what() << '\n';
           }
       }
   }
   ```

5. 編譯並運行程序，兩種錯誤可能都會在運行時發生。當文件不存在時，我們就不可能從文件中獲取數值，所以我們會得到一個`iostream_category`錯誤信息：

   ```c++
   $ ./readable_error_msg
   Caught error: ios_base::clear: unspecified iostream_category
   ```

6. 如果文件不存在， `strerror(errno)`將會返回不同的錯誤信息：

   ```c++
   $ ./readable_error_msg
   Caught error: No such file or directory
   ```

## How it works...

我們可以通過`  s.exceptions(s.failbit | s.badbit) `使能流對象s拋出異常的能力。不過，這也就意味著有些情況無法使用異常，例如`std::ifstream`的實例需要打開一個文件進行構造，所以我們不能在之後對異常進行設置。

```c++
ifstream f {"non_existant.txt"};
f.exceptions(...); // too late for an exception
```

這就十分遺憾了，因為異常處理與原始C風格的方式進行對比，無需被`if`困擾，其每一步都是在處理異常。

當我們使用各種方法讓流處於失敗的狀態，就會發現拋出的這些異常並沒有什麼區別。這樣只需要瞭解何時捕獲錯誤，而非捕獲了什麼錯誤(對於流是這樣，而對於STL中的其他類型就不是了)，這也就是為什麼我們要對`errno`的值進行檢查的原因。這個全局變量在C++和異常誕生之前，就已經存在了。

如果有任何與系統相關的函數發生了錯誤，其會將`errno`設置為除0之外的其他值(0代表沒有錯誤)，然後調用者可以通過對`errno`值的查詢，來了解到底出現了什麼問題。這個問題我們在多線程程序會經常遇到，並且所有線程都會對一個全局變量進行修改，那麼當出現錯誤了，是哪個線程造成的呢？幸運的是，這個設計已經在C++11中進行了修改，每個線程都只能看到屬於自己的`erron`變量。

對於原始的錯誤處理方式，我們就不進行詳細的描述了，不過其能為我們提供額外有用的信息，比如流對象觸發了基於系統的異常。異常會告訴我們發生了什麼，而`erron`則會告訴我們會發生哪種級別的錯誤。