# 對共享對象使用弱指針

本節和`shared_ptr`有關，我們已經瞭解瞭如何使用共享指針。和`unique_ptr`一樣，其提升了C++對動態分配對象的管理能力。

拷貝`shared_ptr`時，我們會將內部計數器加1。當持有共享指針的拷貝時，其指向的對象則不會被刪除。但是，當使用某種弱指針時，其能像普通指針一樣對指向對象進行操作，但依舊能讓所指向對象被銷燬？然而，銷燬之後我們應該如何確定對象是否存在呢？

這種情況下`weak_ptr`就是我們最佳的選擇。其相對於`unique_ptr`和`shared_ptr`來說有些複雜，但是在本節隨後的內容中，我們將會對其進行使用。

## How to do it...

我們將使用`shared_ptr`對一個實例進行管理，然後我們將`weak_ptr`混入其中，從而瞭解對`weak_ptr`的操作對智能指針的內存處理有何影響：

1. 包含必要的頭文件，並聲明所使用的命名空間：

   ```c++
   #include <iostream>
   #include <iomanip>
   #include <memory>
   
   using namespace std; 
   ```

2. 接下來，我們將實現一個類，將在析構函數的實現中進行打印。當類型被析構時，我們可以從打印輸出進行判斷：

   ```c++
   struct Foo {
       int value;
       
       Foo(int i) : value{i} {}
       ~Foo() { cout << "DTOR Foo " << value << '\n'; }
   };
   ```

3. 讓我們來實現一個函數用於對弱指針的信息進行打印，這樣我們就可以瞭解弱指針不同指向時的狀態。`expired`成員函數會告訴我們，弱指針指向的對象是否依舊存在，因為使用弱指針持有這個對象並無法讓其生命週期延長！`use_count`計數器告訴我們，當前`shared_ptr`實例中對象的引用次數：

   ```c++
   void weak_ptr_info(const weak_ptr<Foo> &p)
   {
       cout << "---------" << boolalpha
           << "\nexpired: " << p.expired()
           << "\nuse_count: " << p.use_count()
           << "\ncontent: "; 
   ```

4. 當我們要訪問一個實際對象時，需要調用`lock`函數，會返回一個指向對象的共享指針。當對象不存在時，返回的共享指針則是一個空指針。我們將對其進行檢查，然後對其進行訪問：

   ```c++
       if (const auto sp (p.lock()); sp) {
       	cout << sp->value << '\n';
       } else {
       	cout << "<null>\n";
       }
   }
   ```

5. 主函數中實例化一個空的弱指針，並且對其內容進行打印：

   ```c++
   int main()
   {
       weak_ptr<Foo> weak_foo;
       weak_ptr_info(weak_foo);
   ```

6. 新的代碼段中，使用`Foo`類實例化了一個共享指針，再將其拷貝給弱指針。需要注意的是，這個操作並不會對共享指針的引用計數有任何影響。其引用計數依舊為1，因為只有共享指針對其具有所有權：

   ```c++
   	{
   		auto shared_foo (make_shared<Foo>(1337));
   		weak_foo = shared_foo;
   ```

7. 離開代碼段前，我們對弱指針的狀態進行打印；離開時候，再打印一次。雖然弱指針依舊指向`Foo`的對象，但是`Foo`實例還是會在離開代碼段時立即被銷燬：

   ```c++
           weak_ptr_info(weak_foo);
       }
   
       weak_ptr_info(weak_foo);
   }
   ```

8. 編譯並運行程序，就會看到`weak_ptr_info`函數的輸出。第一次，是弱指針為空的時候。第二次，是其指向我們創建的`Foo`實例，並在弱指針鎖定後對其進行解引用。第三次調用之前，我們離開了內部代碼區域，會觸發`Foo`類型的析構。之後，我們就無法通過弱指針獲取已經刪除的`Foo`對象，並且在這時弱指針也意識到，原先指向的對象已經不存在了：

   ```c++
   $ ./weak_ptr
   ---------
   expired: true
   use_count: 0
   content: <null>
   ---------
   expired: false
   use_count: 1
   content: 1337
   DTOR Foo 1337
   ---------
   expired: true
   use_count: 0
   content: <null>
   ```

## How it works...

弱指針為我們提供了一種指向共享指針對象，但不會增加其引用計數的方式。Okay，一個裸指針也可以做這樣的事，不過裸指針無法告訴我們其是否處於懸垂的狀態，而弱指針可以！

為了能更好的瞭解弱指針為共享指針添加的功能，我們畫了一張圖供大家參考：

![](../../images/chapter8/8-10-1.png)

流程與共享指針的圖類似。第1步中，我們有兩個共享指針和一個弱指針，都指向`Foo`類型的實例。雖然有三個指針指向這個對象，但是其共享指針引用數依舊為2，弱指針在控制塊有屬於自己的計數器。第2和3步中，共享指針的實例被銷燬，這步將會讓引用計數歸0。第4步，`Foo`對象也被銷燬了，不過控制塊依舊存在。因為弱指針依舊需要控制塊來對其是否懸垂進行判斷。只有當最後一個指向對象的弱指針被銷燬，那麼控制塊才會被銷燬。

也可以說處於懸垂狀態的弱指針是無效的。為了對這個屬性進行檢查，我們可以調用`weak_ptr`指針的`expired`成員函數，其將會為我們返回一個布爾值。當其返回true時，我們就不能對這個弱指針進行解引用，因為其說明這個對象已經不存在了。

為了對弱指針解引用，我們需要調用`lock()`函數。這是種安全和方便的方法，因為函數返回給我們一個共享指針。當持有這個共享指針時，我們對其進行了鎖定，所以這時對象的計數器無法進行變化。`lock()`之後，對象被刪除，我們將會得到一個空的共享指針。

