# 使用同一輸入調用多個函數

當我們有很多工作要做時，可能就會導致很多代碼的重複。使用Lambda表達式就很容易的避免重複代碼，並且Lambda表達式將幫助你將這些重複的任務包裝起來。

本節，我們將使用Lambda表達式接受一組參數，然後分發給相應的任務函數。這種方式並不需要添加額外的數據結構，所以編譯器很容易的將這些函數打包成一個二進制文件(並且沒有額外的開銷)。

## How to do it...

我們將要完成兩個Lambda表達式輔助器，一個能接受一組參數，並調用多個函數對象；另一個使用一個函數調用，引發後續多個函數調用。我們的例子中，我們將使用不同的打印函數打印一些信息出來。

1. 包含打印頭文件。

   ```c++
   #include <iostream>
   ```

2. 首先，讓我們實現`multicall`函數，這個函數是本章的重點。這個函數可以接受任意數量的參數，並且返回一個Lambda表達式，這個Lambda表達式只接受一個參數。表達式可以通過這個參數調用所有已提供的函數。這樣，我們可以定義`auto call_all (multicall(f, g, h))`函數對象，然後調用`call_all(123)`，從而達到同時調用`f(123); g(123); h(123); `的效果。這個函數看起來比較複雜，是因為我們需要一個語法技巧來展開參數包functions，並在`std::initializer_list`實例中包含一系列可調用的函數對象。

   ```c++
   template <typename ... Ts>
   static auto multicall (Ts ...functions)
   {
       return [=](auto x) {
           (void)std::initializer_list<int>{
           	((void)functions(x), 0)...
           };
       };
   }
   ```

3. 下一個輔助器能接受一個函數f和一個參數包`xs`。這裡要表示的就是參數包中的每個參數都會傳入f中運行。這種方式類似於`for_each(f, 1, 2, 3)`調用，從而會產生一系列調用——` f(1); f(2); f(3); `。本質上來說，這個函數使用同樣的技巧來為函數展開參數包`xs`：

   ```c++
   template <typename F, typename ... Ts>
   static auto for_each (F f, Ts ...xs) {
       (void)std::initializer_list<int>{
      		((void)f(xs), 0)...
       };
   }
   ```

4. `brace_print`函數能接受兩個字符，並返回一個新的函數對象，這個函數對象可以接受一個參數`x`。其將會打印這個參數，當然會讓之前的兩個字符將這個參數包圍：

   ```c++
   static auto brace_print (char a, char b) {
       return [=] (auto x) {
       	std::cout << a << x << b << ", ";
       };
   }
   ```

5. 現在，我們終於可以在main函數中使用這些定義好的東西了。首先，我們定義函數f，g和h。其使用括號打印函數將其參數進行包圍。`nl`函數只打印換行符。

   ```c++
   int main()
   {
       auto f (brace_print('(', ')'));
       auto g (brace_print('[', ']'));
       auto h (brace_print('{', '}'));
       auto nl ([](auto) { std::cout << '\n'; });		
   ```

6. 讓我們將所有函數和`multicall`輔助器放在一起：

   ```c++
   	auto call_fgh (multicall(f, g, h, nl)); 
   ```

7. 這裡我們提供一組數字，之後這些數字就會被相應的括號包圍，然後打印出來。這樣，我們現在調用一次，就等於以前調用五次主函數中定義的函數。

   ```c++
   	for_each(call_fgh, 1, 2, 3, 4, 5);
   }
   ```

8. 編譯運行，我們應該能得到期望的結果：

   ```c++
   $ ./multicaller
   (1), [1], {1},
   (2), [2], {2},
   (3), [3], {3},
   (4), [4], {4},
   (5), [5], {5},
   ```

## How it works...

我們剛剛實現的輔助函數還是挺複雜的。我們使用了`std::initializer_list`來幫助我們展開參數包。為什麼這裡不用特殊的數據結構呢？再來看一下`for_each`的實現：

```c++
auto for_each ([](auto f, auto ...xs) {
    (void)std::initializer_list<int>{
    	((void)f(xs), 0)...
    };
});
```

這段代碼的核心在於`f(xs)`表達式。`xs`是一個參數包，我們需要將其進行解包，才能獲取出獨立的參數，以便調用函數f。不幸的是，我們知道這裡不能簡單的使用`...`標記，寫成`f(xs)...`。

所以，我能做的只能是構造出一個`std::initializer_list`列表，其具有一個可變的構造函數。表達式可以直接通過` return std::initializer_list<int>{f(xs)...};`方式構建，不過其也有缺點。在讓我們看一下`for_each`的實現，看起來要比之前簡單許多：

```c++
auto for_each ([](auto f, auto ...xs) {
	return std::initializer_list<int>{f(xs)...};
});
```

這看起來非常簡單易懂，但是我們要了解其缺點所在：

1. 其使用f函數的所有調用返回值，構造了一個初始化列表。但我們並不關心返回值。
2. 雖然其返回的初始化列表，但是我們想要一個“即發即棄”的函數，這些函數不用返回任何東西。
3. f在這裡可能是一個函數，因為其不會返回任何東西，可能在編譯時就會被優化掉。

要想`for_each`修復上面所有的問題，會讓其變的更加複雜。例子中做到了一下幾點：

1. 不返回初始化列表，但會將所有表達式使用` (void)std::initializer_list<int>{...} `轉換為`void`類型。
2. 初始化表達式中，其將`f(xs)...`包裝進`(f(xs),0)...`表達式中。這會讓程序將返回值完全拋棄，不過0將會放置在初始化列表中。
3. `f(xs)`在`(f(xs), 0)...`表達式中，將會再次轉換成`void`，所以這裡就和沒有返回值一樣。

這些不幸的事導致例程如此複雜醜陋，不過其能為所有可變的函數對象工作，並且不管這些函數對象是否返回值，或返回什麼樣的值。

這種技術可以很好控制函數調用的順序，嚴格保證多個函數/函數對象以某種順序進行調用。

> Note:
>
> 不推薦使用C風格的類型轉換，因為C++有自己的轉換操作。我們可以使用`reinterpret_cast<void>(expression) `代替例程中的代碼行，不過這樣會降低代碼的可讀性，會給後面的閱讀者帶來一些困擾。

