# 使用Lambda表達式定義函數

我們可以使用Lambda表達式來包裝代碼，為了在之後對其進行調用。我們可以像調用函數那樣，給Lambda表達式傳入不同的參數，從而得到不同的結果，這樣我們就不需要在類中實現這個函數了。

C++11標準正式將Lambda語法加入C++，之後的C++14和C++17標準中對Lambda語法進行了升級。本節我們將看到如何使用Lambda表達式，以及其給我們帶來的改變。

## How to do it...

現在我們就來使用Lambda表達式完成一個程序，在實踐中體驗Lambda表達式：

1. Lambda表達式不需要任何庫，不過我們需要將一些字符串打印在屏幕上，所以需要包含必要的的頭文件：

   ```c++
   #include <iostream>
   #include <string>
   ```

2. 這次我們所有內容都會在主函數中完成。我們定義了兩個沒有參數的函數對象，並且返回整型常量1和2。需要注意的是，返回部分在大括號對`{}`中，就像普通的函數那樣，而小括號`()`表示沒有參數傳入，當然也可以像普通函數那樣定義函數簽名，對於第二個Lambda表達式沒有添加小括號對。不過兩個表達式都有中括號對`[]`：

   ```c++
   int main()
   {
       auto just_one ( [](){ return 1; } );
       auto just_two ( []  { return 2; } );
   ```

3. 那麼現在我們就來調用這兩個函數，就像調用普通函數那樣：

   ```c++
   	std::cout << just_one() << ", " << just_two() << '\n';
   ```

4. 現在，來定義另一個函數對象，其名為plus，因為它要將兩個參數進行加和：

   ```c++
   	auto plus ( [](auto l, auto r) { return l + r; } );
   ```

5. 這個函數對象也不難用。使用`auto`類型定義兩個參數，只要是作為參數的實參類型支持加法操作，那麼就沒有任何問題：

   ```c++
       std::cout << plus(1, 2) << '\n';
       std::cout << plus(std::string{"a"}, "b") << '\n';
   ```

6. 當然，我們可以不使用變量的方式對Lambda表達式進行保存。我們只需要在使用到的地方對其進行定義即可：

   ```c++
       std::cout
           << [](auto l, auto r){ return l + r; }(1, 2)
           << '\n';
   ```

7. 接下來，我們定義一個閉包，包裡面裝著一個計數器。當我們調用這個計數器時，其值就會自加，並且會將自加後的值返回。為了對計數變量進行初始化，我們(在中括號對中)對`count`進行了賦值。為了能讓函數對獲取的值進行修改，我們使用`mutable`關鍵字對函數進行修飾，否則在編譯時會出問題：

   ```c++
       auto counter (
       	[count = 0] () mutable { return ++count; }
       );
   ```

8. 現在讓我們調用函數對象5次，並且打印其返回值，觀察每次調用後計數器增加後的值：

   ```c++
       for (size_t i {0}; i < 5; ++i) {
       	std::cout << counter() << ", ";
       }
       std::cout << '\n';
   ```

9. 我們也可以通過捕獲已經存在的變量的引用，在閉包中進行修改。這樣的話，捕獲到的值會自加，並且在閉包外部也能訪問到這個變量。為了完成這個任務，我們在中括號對中寫入`&a`，`&`符號就意味著捕獲的是對應變量的引用，而非副本：

   ```c++
       int a {0};
       auto incrementer ( [&a] { ++a; } );
   ```

10. 如果這樣能行，那我們就可以多次的調用這個函數對象，並且直接在外部對a變量的值進行觀察：

   ```c++
       incrementer();
       incrementer();
       incrementer();
     
   	std::cout
           << "Value of 'a' after 3 incrementer() calls: "
           << a << '\n';
   ```

11. 最後一個例子是一個多方位展示，這個例子中一個函數對象可以接受參數，並且將其傳入另一個函數對象中進行保存。在這個`plus_ten`函數對象中，我們會調用`plus`函數對象：

    ```c++
        auto plus_ten ( [=] (int x) { return plus(10, x); } );
        std::cout << plus_ten(5) << '\n';
    } 
    ```

12. 編譯並運行代碼，我們將看到如下的內容打印在屏幕上。我們也可以自己計算一下，看看打印的結果是否正確：

    ```c++
    1, 2
    3
    ab
    3
    1, 2, 3, 4, 5,
    Value of a after 3 incrementer() calls: 3
    15
    ```

## How it works...

上面的例子並不複雜——添加了數字，並對調用進行計數，並打印計數的結果。甚至用一個函數對象來連接字符串，並用這個函數對象對對應字符串進行計數。不過，這些實現對於對Lambda表達式不太瞭解的人來說，看著就很困惑了。

所以，先讓我們瞭解一下Lambda表達式的特點：

```c++
[capture list] (parameters)
	mutable			(optional)
	constexpr		(optional)
	exception attr	(optional)
	-> return type	(optional)
{
	body
}
```

Lambda表達式的最短方式可以寫為`[]{}`。其沒有參數，沒有捕獲任何東西，並且也不做實質性的執行。

那麼其餘的部分是什麼意思呢？

**捕獲列表 capture list** 

指定我們需要捕獲什麼。其由很多種方式，我們展示兩種比較“懶惰”的方式：

- 將Lambda表達式寫成`[=] () {...} `時，會捕獲到外部所有變量的副本。
- 將Lambda表達式寫成`[&] () {...} `時，會捕獲到外部所有變量的引用。

當然，也可以在捕獲列表中單獨的去寫需要捕獲的變量。比如` [a, &b] () {...}`，就是捕獲`a`的副本和`b`的引用，這樣捕獲列表就不會去捕獲那些不需要捕獲的變量。

本節中，我們定義了一個Lambda表達式：`  [count=0] () {...}`，這樣我們就不會捕獲外部的任何變量。我們定義了一個新的`count`變量，其類型通過初始化的值的類型進行推斷，由於初始化為0，所以其類型為`int`。

所以，可以通過捕獲列表捕獲變量的副本和/或引用：

- `  [a, &b] () {...}`：捕獲`a`的副本和`b`的引用。
- `[&, a] () {...}`：除了捕獲`a`為副本外，其餘捕獲的變量皆為引用。
- `[=, &b, i{22}, this] () {...}`：捕獲`b`的引用，`this`的副本，並將新變量`i`初始化成22，並且其餘捕獲的變量都為其副本。

> Note:
>
> 當你需要捕獲一個對象的成員變量時，不能直接去捕獲成員變量。需要先去捕獲對象的`this`指針或引用。

**mutable (optional)**

當函數對象需要去修改通過副本傳入的變量時，表達式必須用`mutable`修飾。這就相當於對捕獲的對象使用非常量函數。

**constexpr (optional)**

如果我們顯式的將Lambda表達式修飾為`constexpr`，編譯器將不會通過編譯，因為其不滿足`constexpr`函數的標準。`constexpr`函數有很多條件，編譯器會在編譯時對Lambda表達式進行評估，看其在編譯時是否為一個常量參數，這樣就會讓程序的二進制文件體積減少很多。

當我們不顯式的將Lambda表達式聲明為`constexpr`時，編譯器就會自己進行判斷，如果滿足條件那麼會將Lambda表達式隱式的聲明為`constexpr`。當我們需要一個Lambda表達式為`constexpr`時，我們最好顯式的對Lambda的表達式進行聲明，當編譯不通過時，編譯器會告訴我們哪裡做錯了。

**exception attr (optional)**

這裡指定在運行錯誤時，是否拋出異常。

**return type (optional)**

當想完全控制返回類型時，我們不會讓編譯器來做類型推導。我們可以寫成這樣`[] () -> Foo {}`，這樣就告訴編譯器，這個Lambda表達式總是返回`Foo`類型的結果。