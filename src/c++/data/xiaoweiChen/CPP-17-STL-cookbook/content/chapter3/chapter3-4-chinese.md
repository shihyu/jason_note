# 使用迭代器實現算法

迭代器通常根據指向位置的移動，來遍歷容器中的元素，但不需要迭代對應的數據類型。迭代器也會被用來實現算法，其可以通過`++it`指向下一個元素，並且通過`*it`解引用得到對應的值。

本節中，我們將用迭代器來實現斐波那契函數。斐波那契函數會有類似如下的迭代：`F(n) = F(n - 1) + F(n - 2)`。數列的初始值`F(0) = 0 `和 `F(1) = 1`。這樣下列序列就可以進行計算：

- F(0) = 0
- F(1) = 1
- F(2) = F(1) + F(0) = 1
- F(3) = F(2) + F(1) = 2
- F(4) = F(3) + F(2) = 3
- F(5) = F(4) + F(3) = 5
- F(6) = F(5) + F(4) = 8
- ...

我們要實現一個函數，可以輸出斐波那契第n個數的值。通常我們都會使用函數迭代，或者是循環來實現這個函數。這樣的話，我們只能一個個的將相應的值算出來，然後才能計算出下一個值。這裡我們有兩個選擇——遞歸調用斐波那契函數計算整個數列，這樣很浪費計算時間，或者將最後兩個斐波那契數作為臨時變量，並用它們來計算下一個數。第二種方法我們需要重新實現斐波那契算法循環。這樣我們就可以將斐波那契數列計算的代碼和我們實際的代碼放在一起：

```c++
size_ta{0};
size_tb{1};
for(size_ti{0};i< N;++i){
    constsize_told_b{b};
    b+=a;
    a=old_b;
    // do something with b, which is the current fibonacci number
}
```

使用迭代器實現斐波那契數列是一件很有意思的事情。如何將循環中的迭代，使用迭代器的前向自加操作來代替呢？其實很簡單，讓我們來看一下。

## How to do it...

本節中，我們主要關注如何用一個迭代器實現生成斐波那契數列。

1. 為了打印斐波那契數列在終端，我們需要包含標準輸入輸出流頭文件。

   ```c++
   #include <iostream>
   ```

2. 我們調用斐波那契迭代器——`fibit`。其會指向一個值`i`，其保存的值為斐波那契數列對應的位置，`a`和`b`保存斐波那契數列中最後兩個值。實例化迭代器時，需要將斐波那契迭代器初始化為`F(0)`的值：

   ```c++
   class fibit
   {
       size_t i {0};
       size_t a {0};
       size_t b {1};
   ```

3. 下一步，定義標準構造函數和另一個構造函數用來初始化迭代器。

   ```c++
   public:
       fibit() = default;
       explicit fibit(size_t i_)
           : i{i_}
       {}
   ```

4. 當我們對迭代器解引用時，迭代器將返回對應位置的數值。

   ```c++
   	size_t operator*() const { return b; }
   ```

5. 當移動迭代器`++`時，其會移動到下一個斐波那契數上。這裡的實現與基於循環的實現幾乎是一樣的。

   ```c++
       fibit& operator++() {
           const size_t old_b {b};
           b += a;
           a = old_b;
           ++i;
           return *this;
       } 
   ```

6. 當使用循環時，增加後的迭代器將會和`end`迭代器進行比較，所以這裡需要為迭代器實現不等於`!=`操作符。我們只比較當且迭代器所對應的步數，這比循環1000000次再結束迭代器簡單許多，這樣我們就不需要計算太多的斐波那契數：

   ```c++
   	bool operator!=(const fibit &o) const { return i != o.i; }
   };
   ```

7. 為了能讓斐波那契迭代器適應`for`循環的範圍寫法，我們需要實現一個範圍類。我們稱這個類為`fib_range`，其構造函數只需要一個參數，這個參數能夠告訴我們我們想要遍歷的範圍：

   ```c++
   class fib_range
   {
   	size_t end_n;
   public:
       fib_range(size_t end_n_)
       	: end_n{end_n_}
       {}
   ```

8. `begin`和`end`函數將會返回對應位置上的迭代器，也就是`F(0)`和`F(end_n)`對應的迭代器。

   ```c++
       fibit begin() const { return fibit{}; }
       fibit end() const { return fibit{end_n}; }
   };
   ```

9. 好了，其他與迭代器相關的代碼我們就不管了。因為我們輔助類就能很好的幫助我們將這些細節的東西隱藏掉！讓我們打印10個斐波那契數字：

   ```c++
   int main()
   {
       for (size_t i : fib_range(10)) {
      		std::cout << i << ", ";
       }
       std::cout << '\n';
   }
   ```

10. 編譯運行後，我們會在終端上看到如下的打印：

    ```c++
    1, 1, 2, 3, 5, 8, 13, 21, 34, 55,
    ```

## There's more...

為了兼容STL中的迭代器，這裡實現的迭代器必須支持`std::iterator_traits`類。想要知道怎麼做，要參考一下3.2節(讓自己的迭代器與STL的迭代器兼容)，其對如何兼容進行了明確地說明。

> Note：
>
> 試著從迭代器的角度思考，這樣的代碼在很多情況下就顯得十分優雅。不用擔心性能，編譯器會根據模板對迭代器相關的代碼進行優化。

為了保證例子的簡潔性，我們並沒有對其做任何事情，不過要是作為斐波那契迭代器的發佈庫的話，其可用性還是比較差的——`fibit`傳入一個參數的構造函數，可以直接使用`end`迭代器替換，因為`fibit`並沒有包含任何一個合法的斐波那契值，這裡的庫並不強制使用這種方式。

還有些方面需要進行修復：

- 將`fibit(size_t i_)`聲明為私有構造函數，並在`fibit`類中將`fib_range`類聲明為一個友元類。這樣用戶就只能使用正確的方式進行迭代了。

- 可以使用迭代器哨兵，避免用戶引用`end`迭代器。可以參考一下3.6節(使用哨兵終止迭代)中內容，以獲得更多信息。
