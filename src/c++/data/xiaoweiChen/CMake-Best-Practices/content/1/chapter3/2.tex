虽然CMake可以用于任何文件结构，但有一些关于如何组织文件的良好实践。本书中的例子使用了以下模式:

\begin{tcblisting}{commandshell={}}
├── CMakeLists.txt
├── build
├── include/project_name
└── src
\end{tcblisting}

最小的项目结构中有三个文件夹和一个文件。

\begin{itemize}
\item 
build: 放置构建文件和二进制文件的文件夹。

\item 
include/project\_name: 此文件夹包含从项目外部公开访问的所有头文件，包含<project\_name/somefile.h>使它更容易看出头文件来自哪个库。

\item 
src: 此文件夹包含所有私有的源文件和头文件。

\item 
CMakeLists.txt: 这是主CMake文件。
\end{itemize}

构建文件夹可以放置在任何地方，放在项目根目录最方便，但强烈建议不要选择任何非空文件夹作为构建文件夹。特别是将构建好的文件放入include或src中，这是一种糟糕的实践。其他文件夹，如test或doc，在组织测试项目和文档页面时就很方便。

\subsubsubsection{3.2.1\hspace{0.2cm}嵌套项目}

将项目相互嵌套时，每个项目都应该映射上面的文件结构，并且应该编写每个CMakeLists.txt以便子项目可以独立构建。每个子项目的CMakeLists.txt文件应该指定\texttt{cmake\_minimum\_required}，以及可选的项目定义。我们将在第9章中深入介绍大型项目和超级构建。

嵌套项目看起来像这样:

\begin{tcblisting}{commandshell={}}
├── CMakeLists.txt
├── build
├── include/project_name
├── src
└── subproject
        ├── CMakeLists.txt
        ├── include
        │       └── subproject
        └── src
\end{tcblisting}

文件夹结构在子项目文件夹中重复。坚持这样的文件夹结构，并使子项目能够独立构建，这样就更容易移植项目。其还允许只构建项目的一部分，这对于构建时间可能相当长的大型项目非常有用。

现在已经了解了文件结构，让我们创建一个没有特殊依赖的可执行文件。本章的后面，我们将创建各种各样的库，并将它们集合在一起。


















