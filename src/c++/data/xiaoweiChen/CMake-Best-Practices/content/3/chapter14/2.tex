长期维护CMake项目时，经常会有一些任务定期出现，比如：向项目中添加新文件或增加依赖项的版本，这些相对容易处理；然后，是添加新的工具链或用于交叉编译的平台；最后，当要使用新功能(如预设)时，需要更新CMake。

定期更新CMake，并利用新特性可以保持项目的可维护性。虽然更新每一个新版本通常不现实，但检查CMake的新大特性，并在它们发布时使用它们可能会使项目更容易维护。例如，CMake 3.19版本中引入的CMake预设就是这样一个特性，可能使许多复杂的CMakeLists.txt文件变得更简单。

保持依赖关系处于最新状态，并处于控制之下，通常是维护者需要完成的任务。这里，使用一致的概念来处理依赖将使项目维护更容易。除了小项目，我们推荐使用第5章中介绍的包管理器。由于包管理器的设计目的是将管理依赖关系的复杂性转移给包管理器，而不是将其暴露给维护者，因此会使维护者的工作更加轻松。

使项目具有可维护性的根本是有效的项目结构，这样就可以很容易找到相应的东西，并彼此独立地进行改进。选择的结构在很大程度上取决于项目的环境和规模，因此适用于一个项目的方法可能并不适用于另一个项目。

保持大型项目可维护性的最大好处是使用合适的项目结构。虽然项目组织的细节取决于开发项目的实际情况，但良好的实践有助于保持对项目的描述。保持项目的可维护性，可以从项目的主CMakeLists.txt文件开始。对于大型项目，主CMakeLists.txt应该处理以下事情:

\begin{itemize}
\item 
整个项目的基本设置，例如使用\texttt{project()}、获取工具链、支持程序和辅助库。这还包括设置语言标准、搜索行为，以及在项目范围内设置编译器标志和搜索路径。

\item 
处理横向依赖关系，特别是像Boost和Qt这样的大型框架。根据依赖关系的复杂性，创建并包含一个子目录，通过其自带的CMakeLists.txt来处理获取依赖关系有助于保持项目的可维护性。我们推荐使用\texttt{add\_subdirectory}，这样搜索依赖项的临时变量的作用域都限于子目录，除非显式地标记为缓存变量。

\item 
若构建目标不止几个，可将它们移到各自的子目录中，并用\texttt{add\_subdirectory()}将它们包含进来，这将有助于保持各个文件短小且可以自包含。以松耦合和高内聚为设计原则，将使库和可执行程序更容易独立维护，可能每个库和可执行项目都要有自己的CMakeLists.txt。

\item 
单元测试保持在所测试的单元附近，还是作为根级别测试文件夹的子文件夹，取决于个人喜好。将测试放在独立的子目录中，带有自己的CMakeLists.txt，这样可以更容易地处理特定于测试的依赖项和编译器设置。

\item 
项目的打包和安装说明应该集中在项目的顶层。若安装说明和包装说明太大，可以将它们放在自己的CMakeLists.txt中，并在主CMakeLists.txt中进行包含。
\end{itemize}

以这种方式组织项目将简化项目中的导航，并有助于避免CMake文件中不必要的代码重复，特别是当项目随着时间的推移而变大时。

好的项目设置可能会决定是每天都和构建系统打交道，还可以平稳地运行。使用本书中的技术和实践将有助于CMake项目的可维护性。如第9章和第12章中所述，通过使用CMake预置和构建容器或sysroot，有一个明确定义的构建环境，将有助于使构建在开发人员和CI系统之间更具可移植性。最后，将自定义CMake代码组织成宏和函数，如第13章所述，这将有助于避免冗余和重复。

除了CMake文件的复杂性，当项目变大时，更长的配置和构建时间通常是另一个需要考虑的问题。为了管理不断增长的构建和配置时间，CMake提供了一些特性来进行优化。

















