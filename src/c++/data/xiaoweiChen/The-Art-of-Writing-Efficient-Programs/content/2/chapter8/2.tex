C++11之前，C++標準沒有併發。當然，開發者們早在2011年之前就用C++編寫多線程和分佈式程序了。使C++中使用併發的原因可能是編譯器作者進行了額外的限制和保證，通常是通過遵守C++標準(對於該語言)和另一個標準(如POSIX)來支持併發。

C++11通過引入C++內存模型，內存模型描述了線程如何通過內存進行交互。自此，C++第一次有了原生併發。內存模型的沒有副作用，因為新的C++內存模型與大多數編譯器支持的內存模型非常相似。這些模型之間有一些細微的差別，新標準保證了這些差異的可移植性。

一些直接支持多線程的語言特性更有用。首先，標準引入了線程的概念。對於線程的行為，很少有明確的說明，但是大多數實現只是簡單地使用系統線程來支持C++線程。在實現的最底層上這是沒問題的，但對於簡單的程序來說，這就不夠的。為程序必須執行的每個獨立任務創建一個新線程，就肯定會失敗。啟動新線程需要時間，而且很少有操作系統能夠有效地處理數百萬個線程。另一方面，對於開發線程調度器的開發者來說，C++線程接口沒有為線程行為提供足夠的控制(大多數線程屬性特定於操作系統)。

接下來，標準引入了幾個同步原語來控制對內存的併發訪問。標準提供了\texttt{std::mutex}，通常使用常規的系統互斥鎖來實現。在POSIX平臺上，這通常是POSIX互斥鎖。標準提供了計時和遞歸互斥鎖(緊隨POSIX)。為了簡化異常處理，應該避免直接鎖定和解鎖互斥對象，使用RAII模板\texttt{std::lock\_guard}。

為了安全鎖定多個互斥對象，避免死鎖的風險，標準提供了\texttt{std::lock()}(雖然保證沒有死鎖，但使用的算法未指定，而且特定實現的性能差別很大)。另一個常用的同步原語是一個條件變量\texttt{std::condition\_variable}，以及相應的等待和信號操作。這個功能也非常接近於POSIX相應的特性。

然後，支持底層的原子操作:\texttt{std::atomic}、比較-交換之類的原子操作，以及內存序。我們已經在第5章，第6章和第7章，瞭解了它們的行為和應用。

最後，語言增加了對異步執行的支持，可以使用\texttt{std::async}異步調用函數(可能在另一個線程上)。雖然這可能支持併發編程，但該特性對於高性能應用幾乎完全沒用。大多數實現要麼提供非常有限的並行性，要麼在自己的線程上執行異步函數。大多數操作系統在創建和匯入線程時有相當大的開銷(我所見過的唯一一個使併發編程簡單到為每個任務啟動一個線程的操作系統是AIX，如果需要的操作系統可能會啟用數百萬個線程。在其他操作系統上，這會造成混亂)。

總的來說，談到併發性時，C++11在概念上是一個重大的進步，C++14的改進集中在其他地方，所以在併發性方面沒有什麼值得注意的變化。然後，再瞭解一下C++17帶來了哪些新的特性。




































