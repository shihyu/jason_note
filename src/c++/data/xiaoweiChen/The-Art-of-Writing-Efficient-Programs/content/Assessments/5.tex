\begin{enumerate}
\item 
內存模型描述了線程通過共享內存的交互方式，當多個線程訪問內存中的相同數據時，內存模型是一組限制和保證。

\item 
一方面，如果不需要共享數據，所有線程都將完全獨立運行，只要有更多的處理器可用，程序就可以完美地擴展了。而且，編寫這樣的程序和編寫單線程程序差不多。另一方面，所有與併發相關的Bug最終都是對某些共享數據的無效訪問引起的。

\item 
整個內存模型是系統不同組件的幾個內存模型的疊加:首先，硬件有一個適用於運行任何程序的內存模型。操作系統和運行時環境可能提供額外的限制和保證。最後，編譯器實現語言(如C++)的內存模型，如果提供的內存模型比語言需要的更嚴格，那麼可能會有更多的限制。

\item
有幾個因素限制了併發程序的性能。首先是並行工作的可用性(這個問題要通過並行算法的改進來解決，這超出了本書的範圍)。其次，是硬件的可用性來完成這項工作(我們已經看到了程序被內存限制的例子)。最後，當線程必須併發訪問相同的數據(共享數據)時，這種訪問必須是同步的，編譯器和硬件在這些同步訪問之間優化執行的能力會受到限制。

\end{enumerate}