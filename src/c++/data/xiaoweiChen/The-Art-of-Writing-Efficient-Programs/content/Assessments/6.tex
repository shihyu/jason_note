\begin{enumerate}
\item 
基於鎖的程序，不能保證在隨時都朝著最終目標做有用的工作。無鎖程序，至少有一個線程保證會取得這樣的進展。無等待的程序，所有的線程都會朝著最終目標前進。

\item 
應該從算法的角度來理解“無等待”，每個線程完成算法的一個步驟，然後立即轉移到下一個步驟，並且計算的結果不會因為線程同步而浪費或丟棄。這並不意味著當計算機運行多個線程時，特定步驟所花費的時間與運行一個線程時相同，其中對硬件訪問的爭奪仍然存在。

\item 
鎖最常見的缺點是成本較高，這並不是避免使用它的主要原因。好的算法常常可以減少數據共享的數量，以至於鎖本身的成本不是主要問題。更嚴重的問題是需要細粒度數據同步的程序中，管理多個鎖的複雜性。鎖定大量數據意味著只有一個線程可以操作所有鎖定的數據，但是對小塊數據使用多個鎖會導致死鎖，或者使鎖的管理變的複雜。

\item
差異不在於計數器本身的實現，而在於數據依賴。計數器沒有依賴項，因此不需要提供任何內存序保證。另一方面，索引應該確保當線程讀取這個索引值時，特定值索引的數組或容器元素對線程是可見的。

\item
發佈協議的關鍵特性是，允許許多使用者線程在不鎖定的情況下訪問相同的數據。同時，保證使用者在訪問該數據之前，生產者線程生成的數據是可見的。

\end{enumerate}