\begin{enumerate}
\item 
為線程安全而設計的數據結構必須有一個事務接口，每個操作要麼不能更改數據結構的狀態，要麼不能將其從一個定義良好的狀態轉換為另一個定義良好的狀態。

\item 
從總體上觀察併發代碼的性能，共享變量越多，代碼就越慢。複雜數據結構通常需要在併發訪問的線程之間共享更多的數據。另外，有一些簡單的算法(有些是無等待的)允許對數據結構進行有限的線程安全操作。

\item 
使用有效的鎖，保護的數據結構不一定會變慢。通常，訪問更快。其涉及到共享多少變量，需要多個原子變量的無鎖模式可能比單個鎖還慢。還必須考慮訪問的位置，若數據結構只能在一兩個位置(比如一個隊列)訪問數據，那鎖就會非常有效。如果每次都必須鎖定整個數據結構，那麼可以同時多個訪問的數據結構，性能很可能會很差。

\item
主要的挑戰是，向數據結構添加內存通常是一種具有破壞性的操作，需要重排大部分內部數據。在允許對同一數據結構進行併發操作的情況下，很難做到這一點。這與是否由鎖保護的數據結構關係不大(有時當一個線程必須管理內存時，鎖持有的時間比通常要長得多，但是由於其他原因，長時間的延遲也會發生，程序必須瞭解到這一點)，無鎖數據結構中，若內存影響整個數據結構，則很難管理內存。節點數據結構在一個線程上完成所有的內存管理，並使用發佈協議向結構中添加新的節點，但是順序數據結構可能需要數據重新分配，或者需要複雜的內存管理。這種情況下，應該使用\textit{雙重檢查鎖定}來鎖定整個數據結構，同時對其內存進行重組。

\item
A-B-A問題是所有節點數據結構無鎖實現的常見問題，這些實現使用內存中的數據位置來判斷何時發生了更改。不過，在先前刪除的節點的內存中分配新節點時，就會出現問題。當另一個線程觀察到相同的內存地址時，假設數據結構沒有改變，就會產生潛在的數據競爭。這裡有多個解決方案，使用各種技術來延遲內存的重新分配，直到在同一地址的重新分配不再是一個問題。

\end{enumerate}