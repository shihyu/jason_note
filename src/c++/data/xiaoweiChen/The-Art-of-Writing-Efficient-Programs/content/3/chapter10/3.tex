本章中，我們研究了C++效率的第二個主要方面:幫助編譯器生成更高效的代碼。 

本書的目標是幫助讀者理解代碼、計算機和編譯器之間的相互作用，以便讀者們能夠判斷和理解編譯器做出的這些決定。 

幫助編譯器優化代碼的最簡單的方法是遵循有效優化的經驗規則，其中許多也是好的設計規則。儘量減少代碼不同部分之間的接口和交互，將代碼組織成塊、函數和模塊，每個模塊都有簡單的邏輯和定義良好的接口邊界，避免全局變量和其他隱藏交互等。這些也是最佳設計實踐其實並非巧合。通常，程序員容易閱讀的代碼，編譯器會更容易分析。

更高級的優化通常需要檢查編譯器生成的代碼。如果有注意到編譯器沒有做一些優化，考慮一下是否存在無效優化的情況。不要考慮程序中發生了什麼，而是考慮給定代碼片段中可能發生的事情(例如，可能知道自己從不使用全局變量，但編譯器會假設使用全局變量)。 

下一章中，我們將探索C++的一個非常微妙的領域(以及一般的軟件設計)，它可能與性能研究有意想不到的重疊。