我們用了整整一章專門討論C++和程序中的UB。為什麼這麼做？因為這個主題與性能有著千絲萬縷的關係。

首先，當程序接收到指定程序行為之外的輸入時，UB就會發生。此外，標準還說程序不需要檢測這樣的輸入和發出診斷。這對於C++標準定義的UB和自己程序的UB都是正確的。

其次，規範(或標準)沒有涵蓋所有可能的輸入和定義結果的原因，主要與性能有關。當可靠地生成特定結果的成本非常昂貴時，通常會引入UB。對於C++中的UB，處理器和內存架構的多樣性也會導致無法統一處理的情況。如果沒有一種可行的方法來保證一個特定的結果，這個標準就沒有明確結果的。

最後，程序不需要檢測(如果不處理)無效輸入的原因是，這樣的檢測可能也會非常昂貴。有時確認輸入是有效，會比計算結果花費更長的時間。

設計軟件時，應該牢記這些點:總是希望有一個一般性約定來定義任何或任何輸入的結果，但是這樣做會給那些只提供典型或“正常”輸入的用戶帶來不必要的性能開銷。當用戶可以在更快地執行想要執行的任務，以及可靠地執行一開始就不想執行的任務之間做出選擇時，大多數用戶會選擇性能。作為一種妥協，可以為用戶提供一種驗證輸入的方法。如果這種驗證的代價很高，那麼應該是可選的。

當涉及到C++標準的UB時，情況就變了，這時開發者就是用戶。有必要理解，如果一個程序包含了UB的代碼，那麼整個程序都是定義不清的，而不僅僅是有問題的那一行。這是因為編譯器可以假設UB永遠不會在運行時發生，並據此推斷對代碼進行的相應優化。現代的編譯器在某種程度上都會這樣做，而未來的編譯器可能會在他們的推斷中更加激進。 

最後，許多編譯器開發人員還提供了驗證工具，可以在運行時檢測未定義的行為——UB殺滅器。就像自己的程序的輸入驗證器一樣，這些工具需要時間來運行，這就是為什麼殺滅器是一個可選工具，應該在軟件測試和開發過程中使用。

這本書快結束了。下一章，也就是最後一章，我們將回顧我們所學到的一切，並著眼於軟件設計的含義和啟示。
