第4章中詳細討論了數據組織對性能的影響，要是沒有“熱代碼”，通常就會找到“熱數據”。換句話說，如果運行時分佈在大部分代碼上，並且沒有什麼明顯的優化機會，那麼很可能在整個程序中有一些數據(一個或多個數據結構)正在訪問，而這些訪問限制了整體性能。

分析器沒有顯示出易於優化的結果，只能找到一些次優代碼，但測試表明，只能從這些地方節省總運行時間的百分之一左右。除非知道要優化什麼，否則很難找到提高此類代碼性能的方法。 

現在知道了如何需要尋找“熱數據”，那麼應該怎麼做呢？首先，若所有的數據訪問通過函數調用完成，而不是直接讀寫公共數據成員，那麼就容易了。即使這些訪問函數本身不需要花費太多時間，也可以使用它們來對訪問操作進行計數，這將直接顯示哪些數據是熱的。這種方法類似於代碼分析，只不過不是查找多次執行的指令，而是查找多次訪問的內存位置(有些數據文件將為進行此類測試，從而不需要檢測代碼)。再次回到設計準則，該準則規定了明確定義的接口，這些接口不公開內部細節，如內存中的數據佈局——監視數據訪問的能力是這種方法的另一個優點。

每個設計本身都涉及代碼(組件、接口等)的組織和數據的組織。設計者可能還沒有考慮具體的數據結構，但必須考慮數據流，每個組件都需要一些信息來完成其工作。系統的哪些部分生成這些信息？誰擁有這些信息？誰負責將這些信息交付給特定的組件或模塊？計算通常會產生一些新的信息。再一次，應該送到哪裡？誰將擁有這些數據？每一個設計都包含這樣的數據流分析。若沒有這樣的數據流分析，那麼需要通過接口的文檔隱式地進行分析。信息流及其所有權可以從API上推斷出來，但這就複雜了。 

當明確地描述了信息流，就知道在執行的每個步驟中出現了哪些數據，以及每個組件訪問了哪些數據。還可以知道組件之間必須傳輸哪些數據，現在就可以考慮組織這些數據的方法了。

當涉及到數據組織時，在設計階段可以採用兩種方法。一種方法是依賴於接口來提供數據的抽象視圖，同時隱藏有關其真實組織方式的所有細節。這是本章開始的第一個指導方針，最低限度的信息原則，需要發揮到極致。若有效，可以在以後需要時實現接口數據結構的優化。需要注意的是，設計一個不限制底層數據組織的接口是不可能的，而且這樣做通常會付出很高的代價。若有一個有序的數據集合，是否允許在集合中間進行插入操作？如果答案是肯定的，數據將不會存儲在類似數組的結構中，這種結構需要移動一半的元素以在中間打開一個空間(這是對實現的限制)。另一方面，如果堅定地拒絕限制，那麼最終將會得到一個非常有限的接口，並且可能無法使用最快的算法(不盡早提交到特定數據組織的代價)。

第二種方法是將部分數據組織作為設計的一部分。這將降低實現的靈活性，但將放鬆對接口設計的一些限制。例如，為了按特定順序訪問數據，可以使用指向數據元素存儲位置的索引。把間接訪問的代價嵌入到系統架構的基礎中，獲得了數據訪問的靈活性。元素可以以最佳方式存儲，並且可以為任何類型的隨機或有序訪問正確的索引。\texttt{index\_tree}就是這種設計的例子。 

注意，在討論如何為性能設計數據組織時，必須使用一些非常底層的概念。通常，像“通過指針訪問”這樣的細節會視為實現問題。但是在設計高性能系統時，必須考慮諸如緩存位置和間接引用之類的問題。 

最好的結果通常是通過結合這兩種方法獲得的:確定最重要的數據，並提出一個有效的組織方式。當然，不需要特別細，若程序多次搜索大量字符串，這時可能需要將所有字符串存儲在一個大的、連續的內存塊中，並使用索引進行搜索和其他目標訪問。然後，設計一個高級接口來構建索引，並通過迭代器使用它，但這種索引的確切組織留給實現。需要為接口施加了一些限制，例如：可以決定調用者在構建索引時，可以進行隨機訪問或使用雙向迭代器，這反過來也會影響實現。 

併發系統的設計需要注意數據共享。設計階段，應該注意將數據分類為非共享、只讀或共享以便寫入。當然，後者應該最小化。如在第6章中所看到的，訪問共享數據的代價很高。另一方面，用於獨佔單線程訪問的組件或數據結構重新設計為線程安全的是很困難的，而且會導致較差的性能(很難將線程安全移植到根本不安全的設計上)。在數據流分析的設計階段，應該花時間明確定義數據所有權和訪問限制。因為“數據所有權”通常指的是非常底層的細節，比如“是否使用智能指針，以及哪個類擁有它？”，可能更適合討論信息所有權和獲取信息的途徑。必須同時對可用的信息片段進行分類，確定哪個組件產生和擁有信息，哪些組件修改信息，以及是否併發執行。設計應該通過訪問對所有數據進行高級分類:單線程(獨佔)、只讀或共享。注意，這些角色可能會隨時間而改變:一些數據可能由單個線程生成，但稍後會被多個線程讀取。這也應該反映在設計中。 

將數據流或信息流視為設計的一部分的總體指導方針會經常被開發者遺忘，但其他方面還是相當簡單的。更具體的指導原則是考慮數據組織限制和接口的組合，這在設計過程中給實現留下了很大的發揮空間，這通常會看作為\textit{過早的優化}。許多開發者會堅持認為“緩存局部化”在設計階段不需要，當我們將性能作為設計目標之一時，這裡確實需要做出的妥協。系統設計期間，經常需要權衡這些相互競爭的因素，從而將我們引入了在為設計為性能時，需要進行利弊權衡的話題。



































