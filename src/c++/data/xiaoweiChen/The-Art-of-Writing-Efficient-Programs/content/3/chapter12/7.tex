不僅僅是在做出權衡的決定時，我們必須站在性能數據的基礎上。畢竟，如果不知道以緩存最優順序和隨機順序訪問數據要花費多少成本時，要如何才能決定以實現高效的內存訪問呢？這又回到了性能的第一條規則，現在應該已經記住了:\textit{永遠不要猜測性能}。如果程序是散佈在白板上的設計圖，那麼這就是說起來容易做起來難了。

無法運行設計，如何獲得測試數據來指導和支持設計決策呢？有些知識來自於經驗。並不是指那種“我們一直都是這麼做的”的體驗。開發者可能已經設計和實現了類似的組件和新系統的其他部分。如果可以重用，則會提供可靠的性能信息。但即使必須修改它們或設計類似的東西，也已經有了高度相關的性能指標數據，並且可以很好地轉移到新設計中。 

如果沒有可以用來衡量性能的相關程序，是否應該這樣做呢？這時需要依靠模型和原型。模型需要人工構造，據我們所知，它可以模擬未來程序某些部分的預期工作的負載和性能。一種模型是，若必須決定在內存中組織大量的數據，需要知道經常處理整個數據語料庫，微基準。另一種模型，也可能會使用為鏈表和數組處理相同體積的數據組織。不是對未來項目性能的精確測試，但它提供了有價值的信息，併為決策提供了良好的數據支持。記住，模型越接近，預測就越不準確。若對兩個可選設計進行建模，並且得出的性能測量值相差不超過10\%時，可能會認為這是完全正確的。順便說一下，這並不是浪費時間。這樣做會獲得了重要的信息，兩種設計選項都提供了類似的性能，所以可以根據其他標準自由選擇。 

並非所有的模型都是微基準測試，可以使用現有的程序來建模新的行為。假設有一個分佈式程序，它對某些數據的操作與下一個程序需要處理的數據類似。新程序將有更多的數據，而且相似性只是表面上的(可能兩個程序都處理字符串)，因此舊程序不能用於處理新數據的實際測試。沒關係，可以修改代碼來發送和接收更長的字符串。如果現有的程序不使用它們怎麼辦？也沒關係，可以編寫一些代碼以一種比較實際的方式生成和使用這些字符串，並將其嵌入到程序中。現在可以啟動程序中進行分佈式計算的部分，看看發送和接收預期的數據量需要多長時間(假設它需要足夠長的時間來壓縮)。這裡可以做得更好，向代碼中添加壓縮，並比較網絡傳輸速度與壓縮和解壓縮的成本。如果不想花費大量時間為特定數據編寫實際的壓縮算法，那麼可以嘗試使用現有的壓縮庫。在免費的庫中比較幾種壓縮算法可以提供更有價值的數據，以便在以後根據數據量決定使用哪個壓縮庫。 

仔細注意剛才所做的。使用一個現有程序作為框架來運行一些新代碼，這些新代碼近似於未來程序的行為。換句話說，我們已經構建了一個原型。這是另一種獲得原型設計性能評估的方法。當然，為性能構建原型與基於功能的原型有所不同。在後一種情況下，希望快速地組合一個系統來演示所需的行為，通常不考慮實現的性能或質量。性能原型應該給我們提供合理的性能數字，因此底層實現必須高效，可以忽略特殊情況和錯誤處理。也可以跳過許多特性，只要原型能夠執行想要進行基準測試代碼即可。有時，原型根本沒有任何功能。相反，在代碼的某個地方，可以硬編碼一個條件。在實際系統中，在執行某些功能時，會發生這種情況。在這樣的原型創建過程中，創建的高性能代碼通常會形成底層庫的基礎。

所有的模型都是近似的，而且即使有一個完整的、最終的代碼實現，仍然是近似。微基準測試通常不如大型框架準確，這就產生了像“微基準測試是謊言”這樣吸引眼球的標題。微基準測試和其他性能模型，並不總是與最終結果匹配的主要原因是，程序的性能都受其環境的影響。若為最佳內存訪問對一段代碼進行基準測試，結果卻發現它通常與其他完全飽和內存總線的線程一起運行。 

正如理解模型的侷限性很重要一樣，不要\textit{反應過度}也很重要。基準測試確實提供了有用的信息。測試軟件越完整、越真實，測量結果越準確。如果基準測試顯示一段代碼比另一段快幾倍，那麼當代碼在最終上下文中運行，這種差異完全消失的可能性就很低。除了運行在真實數據上的代碼的最終版本之外，嘗試從其他任何地方獲得最後5\%的效率就是很愚蠢的想法了。

原型——模擬真實程序以某種方式再現我們感興趣的特性的方法——允許從不同的設計決策中獲得合理的性能評估。可以是微觀基準冊測試，也可以是大型的、已經存在的項目的實驗，但它們都有一個目標:將性能設計從猜測的領域，轉移到基於測試驅動的決策上。 
