
本章中，提供了如何检查代码、依赖和环境的潜在威胁的信息，但遵循本章中列出的每一步并不一定能避免所有问题。我们的目的是展示一些可能的危险，以及应对的方法。因此，应该时刻注意系统的安全性，并将审计作为常规事件。

在互联网普及之前，软件作者并不太关心设计的安全性。毕竟，如果用户提供了错误的数据，最多只会让自己的机器崩溃。为了利用软件漏洞访问受保护的数据，攻击者必须获得对保存数据机器的物理访问权。

即使在设计用于网络内部的软件中，安全问题也常常事后才考虑。以HTTP协议为例，尽管它允许对某些资产进行密码保护，但所有数据都以明文传输，这意味着在同一网络上的每个人都可以窃听正在传输的数据。

现在，应该从设计的第一阶段就拥抱安全性，并在软件开发、操作和维护的每一个阶段都要牢记安全性。我们每天生产的大多数软件都是为了以某种方式与其他现有系统连接。

由于忽略了安全措施，不仅让自己，也让合作伙伴面临潜在的攻击、数据泄露，并最终导致对簿公堂。请记住，未能保护个人数据可能会导致数百万美元的罚款。

\subsubsubsection{10.1.1\hspace{0.2cm}安全设计}

何设计安全架构？最好的方法是像攻击者一样思考。有很多方法可以打破盒子，但会从不同角度寻找元素之间的缝隙。(对于盒子来说，这可能是在盖子和盒子底部之间。)

软件体系结构中，元素之间的连接称为接口。因为主要任务是与外部互动，所以是整个系统中最脆弱的部分。确保接口是受保护的、直观的和健壮的，这将解决软件容易破坏的问题。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{使界面易于使用，不易误用}

要以一种既易于使用，又不易误用的方式设计接口，请考虑以下练习。假设有一个界面的客户，想实现一个使用支付网关的电子商务商店，或者想实现一个VR应用程序，连接到本书示例系统的Customer API。

作为界面设计的一般规则，应避免以下设计:

\begin{itemize}
\item 
传递给函数/方法的参数太多

\item 
参数名称不明确

\item 
使用输出参数

\item 
参数依赖于其他参数
\end{itemize}

为什么这些是有问题的呢？

\begin{itemize}
\item 
第一个，不仅很难记住，而且很难记住参数的顺序。这可能会导致使用上的错误，而错误又可能导致崩溃和安全问题。

\item 
第二个，与第一个有着相似的结果。通过减少使用界面的直觉性，用户更容易犯错误。

\item 
第三个，是第二个的变体。用户不仅记住哪些参数是输入的，哪些是输出的，而且还需要记住应该如何处理输出。谁管理资源的创建和删除？这是如何实现的？它背后的内存管理模型是什么？

现代C++中，返回包含所有必要数据的值，比以往要容易。对于pair、tuple和vector，没有理由使用输出参数。除此之外，返回值还有助于接受不修改对象状态的做法，这反过来可以减少与并发相关的问题。

\item 
最后一个引入了不必要的认知负担，就像前面的例子一样，这会导致错误和最终的失败。这样的代码也更难测试和维护，因为引入的每个更改都必须考虑到所有可能的组合。不能正确处理的组合，都是对系统的威胁。
\end{itemize}

上述规则适用于对外接口分，还应该有对内部接口应用类似的方式。方法是验证输入，确保值是正确和合理的，并防止不必要地使用接口提供的服务。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{启用资源自动管理}

内存泄漏、数据竞争和死锁也会导致系统不稳定，这些症状都是资源管理不善的表现。尽管资源管理是一个令人头痛的话题，但有一种机制可以减少这些问题的数量。其中一种机制是自动资源管理。

资源可以通过操作系统访问，必须确保正确地使用。使用动态分配的内存、打开文件、套接字、进程或线程，所有这些都需要在获取和释放时采取特定的行动，其中一些还需要在其生命周期中进行特定的操作。如果不能在正确的时间释放这些资源，就会导致泄漏。由于资源是有限的，从长远来看，当无法创建新资源时，泄漏将成为意外行为。 

资源管理在C++中是为什么如此重要？因为与许多其他高级语言不同，C++中没有垃圾收集机制，软件开发人员负责资源的生命周期。了解这个生命周期有助于创建安全和稳定的系统。

资源管理最常见的习惯性用法是资源获取即初始化(RAII)。它起源于C++，也用于其他语言，如Vala和Rust。这种习惯性用法使用对象的构造函数和析构函数分别分配和释放资源。通过这种方式，可以保证当保存资源的对象超出作用域时，使用的资源将释放。

标准库中这种用法的例子是\texttt{std::unique\_ptr}和\texttt{std::shared\_ptr}智能指针类型。其他的例子包括互斥对象——\texttt{std::lock\_guard}，\texttt{std::unique\_lock}和\texttt{std:shared\_lock}，或者文件——\texttt{std::ifstream}和\texttt{std::ofstream}。

稍后将详细讨论的指南支持库(GSL)，其也实现了一个用于自动化资源管理的指南。通过在代码中使用\texttt{gsl::finally()}，创建了一个\texttt{gsl::final\_action()}对象，并添加了一些在调用对象的析构函数时执行的代码。这意味着该代码将在函数成功返回时，以及在异常期间堆栈展开时执行。

这种方法不应该经常使用，因为在设计类时考虑到RAII通常是一个更好的主意。但是，如果正在与第三方模块进行对接，并且希望确保包装器的安全性，\texttt{finally()}可以实现这一点。

假设有一个支付运营商，只允许每个帐户同时登录一次。如果不想阻止用户进行未来的支付，应该在完成交易处理后立即注销。当一切都按照设计进行时，不会有任何不愉快。但在发生异常的情况下，也希望安全并释放资源。下面是使用\texttt{gsl::finally()}实现的方法:

\begin{lstlisting}[style=styleCXX]
TransactionStatus processTransaction(AccountName account, ServiceToken
token,
Amount amount)
{
	payment::login(account, token);
	auto _ = gsl::finally([] { payment::logout(); });
	payment::process(amount); // We assume this can lead to exception
	
	return TransactionStatus::TransactionSuccessful;
}
\end{lstlisting}

不管在调用\texttt{payment::process()}期间发生了什么，至少可以保证，当超出了\texttt{processTransaction()}的作用域，用户就会注销。

简而言之，使用RAII会让类设计阶段更多地考虑资源管理，同时可以完全控制代码。而当意图不清晰时，可能会较少地考虑何时使用接口。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{并发性的缺点}

虽然并发性提高了性能和资源利用率，但它也使代码更难设计和调试。因为与单线程流不同，操作的时间不能提前确定。单线程代码中，可以向资源写入或从资源读取，但总是知道操作的顺序，因此可以预测对象的状态。

使用并发性，多个线程或进程可以同时从一个对象中读取或修改。如果修改不是原子的，就会遇到问题。

\begin{lstlisting}[style=styleCXX]
TransactionStatus chargeTheAccount(AccountNumber acountNumber, Amount
amount)
{
	Amount accountBalance = getAcountBalance(accountNumber);
	if (accountBalance > amount)
	{
		setAccountBalance(accountNumber, accountBalance - amount);
		return TransactionStatus::TransactionSuccessful;
	}
	return TransactionStatus::InsufficientFunds;
}
\end{lstlisting}

当从非并发调用\texttt{chargeTheAccount}函数时，一切都会结束。如果可能的话，程序会检查账户余额并收取费用。然而，并发执行可能导致负余额。这是因为两个线程可以一个接一个地调用\texttt{getAccountBalance()}，并返回相同的数量，比如20。执行该后，两个线程都检查当前余额是否高于可用金额。检查后，再修改帐户余额。假设两个事务的金额都是10，每个线程将设置余额为20 - 10 = 10。在两次操作后，该帐户的余额为10，但它会是0!

为了缓解类似的问题，可以使用互斥锁和临界区、CPU提供的原子操作或并发安全的数据结构等解决方案。

互斥锁、临界区和其他类似的并发设计模式防止多个线程修改(或读取)数据。尽管设计并发应用程序时很有用，但与其相关的是一种权衡。因为互斥锁保护的代码只允许单个线程执行，所以可以使部分代码成为单线程的。其他所有的线程都必须等待，直到释放互斥锁。由于引入了等待，会降低代码的性能，但使用并发最初的目标是提高性能。

原子操作意味着使用单个CPU指令来获得所需的效果，这个术语可以指任何转换为单个CPU指令的高级操作。当单个指令实现的功能超过正常情况下可能实现的功能时，就特别有趣。例如，compare-and-swap(CAS)是一条指令，它将内存位置与给定值进行比较，只有当比较成功时才将该位置的内容修改为新的值。自C++11起，有\texttt{<std::atomic>}头文件可用，其包含几个原子数据类型和操作。例如，CAS可以实现为一个\texttt{compare\_and\_exchange\_*}函数集。

最后，并发安全的数据结构(也称为并发数据结构)为需要某种同步的数据结构提供了安全的抽象，例如Boost。Lockfree(https://www.boost.org/doc/libs/1\_66\_0/doc/html/lockfree.html)库提供了用于多个生产者和多个消费者的并发队列和栈。 libcds(https://github.com/khizmax/libcds)还提供了有序list、set和map，但在本书写作时，它已经几年没有更新了。

在设计并发处理时要记住一些有用的规则:

\begin{itemize}
\item 
考虑是否需要并发。

\item 
通过值传递数据，而不是通过指针或引用。这可以防止在其他线程读取该值时修改该值。

\item 
如果数据的大小无法按值共享，请使用\texttt{shared\_ptr}。这样，可以避免资源泄漏。
\end{itemize}

\subsubsubsection{10.1.2\hspace{0.2cm}安全编码指南和GSL}

标准C++基金会发布了一套指导方针，以记录构建C++系统的最佳实践，是在\url{https://github.com/isocpp/CppCoreGuidelines}下发布的Markdown文档。它是一个没有发布时间表的演进文档(不像C++标准本身)。这些准则针对的是现代C++，这意味着至少要基于C++11特性进行实现。

指南中提出的许多规则涵盖了在本章中提出的主题，有一些与接口设计、资源管理和并发性相关的规则。指导方针的编辑是Bjarne Stroustrup和Herb Sutter，都是C++社区中的元老级成员。

这里不会详细描述这些指导原则，但建议读者们自行阅读。本书的灵感来自于其提出的许多规则，本书的例子也遵循这些规则。

为了方便在各种代码库中使用这些规则，Microsoft将指南支持库(GSL)作为一个开源项目发布在\url{https://github.com/microsoft/GSL}上。它是一个头文件库，可以包含在项目中以使用已定义的类型。可以包含整个GSL，也可以有选择地只使用或计划使用的一些类型。

这个库的另一个有趣之处在于，它使用CMake进行构建，使用Travis进行持续集成，使用Catch进行单元测试。因此，它是的一个很好的例子，应用了在第7章、第8章和第9章中所了解的知识。

\subsubsubsection{10.1.3\hspace{0.2cm}防御性编码，验证一切}

在关于可测试性的章节中，提到了防御性编程的方法。尽管这个方法严格来说不是一个安全特性，但有助于创建一个健壮的接口。这样的接口反过来可以增加了系统的总体安全性。

作为一种良好的启发式方法，可以将所有外部数据视为不安全数据。这里所说的外部数据，是指通过某些接口(编程接口或用户接口)进入系统的每一个输入。为了明确表达这一点，可以在适当的类型前加上不安全的前缀:

\begin{lstlisting}[style=styleCXX]
RegistrationResult registerUser(UnsafeUsername username, PasswordHash
passwordHash)
{
	SafeUsername safeUsername = username.sanitize();
	try
	{
		std::unique_ptr<User> user = std::make_unique<User>(safeUsername,
		passwordHash);
		CommitResult result = user->commit();
		if (result == CommitResult::CommitSuccessful)
		{
			return RegistrationResult::RegistrationSuccessful;
		}
		else
		{
			return RegistrationResult::RegistrationUnsuccessful;
		}
	}
	catch (UserExistsException _)
	{
		return RegistrationResult::UserExists;
	}
}
\end{lstlisting}

如果已经阅读了指南，就会知道通常应该避免直接使用C API。C API中的一些函数可能会以不安全的方式使用，需要注意以防御的方式使用。相反，最好使用C++中的概念，以确保更好的类型安全性和保护(例如，防止缓冲区溢出)。

防御性编程的另一个方面是对现有代码的重用。每次当尝试某些技术时，确保没有其他人在你之前执行过。在学习一门新的编程语言时，自己编写排序算法可能是一项有趣的挑战，但对于生产代码来说，使用标准库中提供的排序算法要好得多，哈希密码也是如此。毫无疑问，可以找到一些聪明的方法来计算哈希密码，并将它们存储在数据库中，但更明智的做法是使用经过验证的(不要忘记同行评审!)方式，或是bcrypt(跨平台文件加密工具)。请记住，代码重用假定检查和审计第三方解决方案，需要与人工检查和审计自己的代码时一样仔细。这个话题将在下一节“依赖关系安全吗?”中继续探讨。

防御性编程不应该变成偏执型编程。检查用户输入是一件合理的事情，而在初始化之后断言初始化的变量是否仍然等于初始值就过分了。需要控制数据和算法的完整性，以及第三方解决方案的完整性。没谁想通过包含语言特性来验证编译器的正确性吧。

简而言之，从安全性和可读性的角度来看，使用C++ Core Guidelines中的\texttt{expect()}和\texttt{ensure()}并通过输入和转换区分不安全数据和安全数据是一种不错的方式。

\subsubsubsection{10.1.4\hspace{0.2cm}最常见的漏洞}

要检查代码对于最常见的漏洞是否安全，首先要了解常见漏洞。只有当知道进攻是什么样子，才可能进行防守。开放Web应用程序安全项目(OWASP)已经编目了最常见的漏洞，并在\url{https://www.owasp.org/index.php/Category:OWASP\_Top\_Ten\_Project}上发布了它们。撰写本书时，这些漏洞有以下几种:

\begin{itemize}
\item 
注入:也称为\textit{SQL注入}，但不仅限于SQL。当不受信任的数据直接传递给解释器(如SQL数据库、NoSQL数据库、shell或eval函数)时，就会出现此漏洞。攻击者可以通过这种方式访问系统中应该受到保护的部分。

\item 
失效的身份验证:如果身份验证实现不正确，攻击者可能会利用漏洞泄露秘密数据或冒充其他用户。

\item 
敏感数据暴露:由于缺乏加密和适当的访问权限，可能导致敏感数据被公开。

\item 
XML外部实体(XXE):一些XML处理器可能会公开服务器文件系统的内容或允许远程代码执行。

\item 
失效的访问控制:当访问控制没有正确执行时，攻击者可能会获得对应该限制的文件或数据的访问。

\item 
安全错误配置:使用不安全的默认值和配置不当是最常见的漏洞来源。

\item 
跨站脚本(XSS):包括和执行不受信任的外部数据，特别是使用JavaScript，这允许控制用户的Web浏览器。

\item 
不安全的反序列化:有缺陷的解析器可能成为拒绝服务攻击或远程代码执行的牺牲品。

\item 
使用有已知漏洞的组件:现代应用程序中的很多代码都作为第三方组件出现。应该定期审计和更新这些组件，因为单个依赖项中的已知安全缺陷可能会导致整个应用程序和数据受损。幸运的是，有一些工具可以自动化实现这个过程。

\item 
日志记录和(或)监控不足:如果系统受到攻击，而日志记录和监控不是很彻底，攻击者可能会获得更深入的访问，但仍然不被注意。
\end{itemize}

这里不会详细讨论每个提到的漏洞。但在要强调的是，可以通过前面提到的防御性编程技术来防止注入、XML外部实体和不安全的反序列化。通过将所有外部数据视为不安全数据，可以在开始实际处理之前先删除所有不安全的内容，从而对其进行消杀。

当谈到日志和监控不足时，将在第15章中详细介绍。届时，将了解一些可能的可观察性方法，包括日志、监视和分布式跟踪。

















