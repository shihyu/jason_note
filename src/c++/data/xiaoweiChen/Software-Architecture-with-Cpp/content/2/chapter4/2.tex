
有许多不同类型的软件系统，每一种都适合于不同的场景，为不同的需求构建，并使用不同的假设集。编写和部署一个经典的、独立的桌面应用程序与编写和部署一个需要通过网络与许多其他应用程序通信的微服务完全不同。

这一节中，将介绍可以用来部署软件的各种模型，以及在创建分布式系统时会遇到的常见错误，以及为了创建这样的系统需要做出的一些妥协

\subsubsubsection{4.2.1\hspace{0.2cm}不同的服务模型}

从服务模型开始。当设计一个更大的系统时，需要决定管理多少基础设施，以及可以在现有的构建块上构建多少基础设施。有时，可能希望利用现有的软件，而不需要手动部署应用程序或备份数据，例如通过其API使用Google Drive作为应用程序的存储。也可以依赖现有的云平台，如Google的App Engine来部署解决方案，而无需担心提供语言运行时或数据库。如果可以想要以自己的方式部署一切，那么可以利用来自云提供商的基础设施，也可以使用商业的基础设施。

先来了解一下不同的模型，以及它们各自的用处。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{本地(on-premises)模型}

经典的方法，也是在前云时代可用的唯一方法。在一切自己部署的前提下，需要购买所需的所有硬件和软件，并确保能提供足够的容量。如果是一家初创公司工作，这可能是一笔很大的前期成本。随着用户基础的增长，需要购置更多的资源，以便服务能够处理偶尔出现的负载高峰。所有这些都需要预测解决方案的增长，并主动采取行动，因为这时不可能根据当前的负载继进行扩展。

即使在云时代，本地部署仍然很有用，而且经常在云外使用。有时，由于数据隐私问题或硬性规定，有些数据不能处理，甚至不能带离公司。其他时候，需要尽可能少的延迟，并且需要有自己的数据中心来进行实现。有时，可能需要计算成本，并且需要确定本地部署比云解决方案的开销更低。最后，公司也可能已经有了可以使用的数据中心。

本地部署并不需要完整的系统。通常，公司有自己的私有云部署在内部。可以通过利用可用的基础设施来降低成本。还可以将私有云解决方案与其他服务模型混合使用，这在不时需要额外容量时非常有用，这也称为\textbf{混合部署}，所有主流云提供商，以及OpenStack的Omni项目都会提供这样的服务。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{基础设施即服务(IaaS)模型}

谈到其他模型，最基本的云服务模型称为\textbf{基础设施即服务(IaaS)}。它也是最类似于内部部署的:可以将IaaS视为拥有虚拟数据中心的一种方式。顾名思义，云提供商提供他们托管的基础设施，其中包含三种类型的资源:

\begin{itemize}
\item 
计算。例如虚拟机、容器或裸机(不包括操作系统)

\item 
网络。除了网络本身，还包括DNS服务器、路由和防火墙

\item 
存储。包括备份和恢复能力
\end{itemize}

提供所有软件仍然取决于:操作系统、中间件和应用程序。

IaaS可以用于各种场景，从托管网站(可能比传统的网站托管更便宜)，通过存储(例如，Amazon的S3和冰川服务)，到高性能计算和大数据分析(需要巨大的计算能力)。一些公司使用它在需要时，可以对开发环境进行快速设置和清除测试。

使用IaaS(而不是本地基础设施)是测试的一种低开销方案，同时可以节省配置所需的时间。

如果服务观察到使用的高峰期(例如在周末)，可能希望利用云的自动扩展能力:在需要时向上扩展，过了高峰期后再向下扩展，从而节省成本。

所有云服务提供商都提供IaaS解决方案。

有时认为\textbf{容器即服务(CaaS)}是IaaS的子集。在CaaS中，服务不是提供裸机系统和虚拟机，而是提供容器和编排功能，可以构建自己的容器集群。CaaS产品可以在Google云平台和AWS中找到。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{平台即服务(PaaS)模型}

如果基础设施本身不能满足需求，可以使用\textbf{平台即服务(PaaS)}模型。这个模型中，云服务提供商不仅管理基础设施(就像在IaaS中一样)，还管理操作系统、任何必需的中间件和运行时(可以部署软件的平台)。

通常，PaaS解决方案将提供程序版本控制功能、服务监视和发现、数据库管理、商业智能，甚至开发工具。

使用PaaS的整个开发过程都会涉及:从构建和测试到部署、更新和管理服务。然而，PaaS解决方案比IaaS成本更高。另一方面，通过提供整个平台，可以减少开发部分软件的成本和时间，并轻松地为分布在全球的开发团队提供相同的设置。

所有主流的云提供商都有自己的产品，例如Google App Engine或Azure App Service。也有一些独立的，如Heroku。

除了更通用的PaaS之外，还有\textbf{通信平台即服务(CPaaS)}，可以使用整个通信后端，包括音频和视频，可以将它们集成到解决方案中。这项技术可以提供视频支持的帮助，或者将实时聊天集成到应用程序中。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{软件即服务(SaaS)模型}

有时，可能不想自己开发软件组件，而只想使用现有的组件。\textbf{软件即服务(SaaS)}提供了一个托管应用程序。使用SaaS，不需要担心基础设施或构建在其上的平台，甚至不需要担心软件本身。提供商负责安装、运行、更新和维护整个软件堆栈，以及备份、许可和扩展。

在SaaS模型中，可以得到各种各样的软件。示例从office 365和Google Docs这样的办公套件到Slack这样的信息软件，通过\textbf{客户关系管理(CRM)}系统，甚至延伸到游戏解决方案，如云游戏服务，允许玩托管在云上的视频游戏。

通常要访问这些服务，只需要一个浏览器，所以这可能是为公司员工提供远程工作能力的重要一步。

可以创建自己的SaaS应用程序，并通过喜欢的方式或AWS Marketplace等方式向用户提供服务。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{功能即服务(FaaS)模型和无服务器架构}

随着原生云的出现，另一种日益流行的模型是\textbf{功能即服务(FaaS)}。如果想要实现一个无服务器的架构，这个模型会很有拥。使用FaaS，可以获得一个平台(类似于PaaS)，可以在其上运行短期应用程序或功能。

在PaaS中，通常需要至少运行一个服务实例。而在FaaS中，只能在实际需要时运行它们，函数可以使处理请求的时间更长(以秒为单位，需要启动该函数)。但是，可以缓存其中一些请求，以减少延迟和成本。谈到成本，如果要长时间运行这些功能，FaaS的成本可能比PaaS高得多，因此在设计系统时必须进行计算。

如果使用正确，FaaS将服务器从开发人员那里抽象出来，因为它可以基于事件，而不是资源，所以可以降低成本，并提供更好的扩展性。该模型通常用于运行预定的或手动触发的任务，处理批量或数据流，以及处理传入的不那么紧急的请求。一些流行的FaaS提供商有AWS Lambda、Azure Functions和Google Cloud Functions。

已经讨论了云中常见的服务模型，现在来了解在设计分布式系统时的错误假设。

\subsubsubsection{4.2.2\hspace{0.2cm}避免分布式计算的错误}

当刚接触分布式计算的人开始设计这类系统时，往往会忘记或忽略这类系统的一些方面。虽然早在90年代就有人注意到了，但现在仍然存在。

这些错误将在下面进行讨论，先了解一下。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{可靠的网络}

网络设备为长期完美运行而设计，但仍然会发生包丢失的情况，其原因包括由于无线网络信号不良而导致的停电、配置错误、有人被电缆绊倒，甚至是动物咬断电线。例如，Google必须用Kevlar纤维保护他们的水下电缆，因为他们被鲨鱼咬怕了(是的，这是真的)。应该始终假定数据可能在网络的某个地方丢失。即使没有发生这种情况，软件问题仍然可能在网络的另一端发生。

要避免此类问题，请确保有自动重试失败网络请求的策略，以及处理常见网络问题的方法。在重试时尽量不要使另一方超载，也不要多次提交相同的事务。可以使用消息队列存储并重新发送。

像断路器这样的模式，将在本章后面展示，也会有帮助。哦，还要确保不要无限等待，因为每次失败的请求都会占用资源。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{延迟为零}

在正常情况下，运行的网络和服务也需要一些时间来响应。有时需要花更长的时间，特别是当负载大于平均水平时。有时，请求可能需要几秒钟才能完成。

尝试设计系统，使它不会等待太多细粒度的远程调用，因为每个调用都会增加总处理时间。即使在本地网络中，1万条记录的1万条请求，也要比1万条记录的1条请求慢得多。为了减少网络延迟，请考虑批量发送和处理请求。还可以通过在等待结果的同时，执行其他处理任务来隐藏调用的成本。

其他处理延迟的方法是引入缓存，在发布者-订阅者模型中推送数据而不是等待请求，或者部署更靠近客户，例如使用\textbf{内容分发网络(CDN)}。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{无限带宽}

在向架构添加新服务时，请确保注意它将使用多少流量。有时，可能希望通过压缩数据或引入节流策略来降低带宽。

这种错误也与移动设备有关。如果信号较弱，往往网络会成为瓶颈。从而，手机应用使用的数据量通常应该保持在较低水平，使用\textit{面向前端的后端}中描述的模式(第2章)可以帮助节省宝贵的带宽。

如果后端需要在一些组件之间传输大量数据，请确保这些组件是紧密连接在一起的:不要在单独的数据中心运行。对于数据库，这通常可以归结为复制。像CQRS(本章后面会讨论)这样的模式也很方便。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{安全的网络}

这是一个危险的假设。一条链的强度取决于它最薄弱的环节，不幸的是，在分布式系统中有许多环节。下面是一些增强链接的方法:

\begin{itemize}
\item 
一定要始终对使用的每个组件、基础设施、操作系统和其他组件应用安全补丁。

\item 
培训你的员工，努力保护系统不受人为因素的影响。有时，就是一个流氓员工破坏了系统。

\item 
如果系统处于在线状态，就会受到攻击，并且有可能在某一点上发生漏洞。一定要有如何应对此类事件的书面计划。

\item 
可能听说过纵深防御原则。这可以归结为对系统的不同部分(基础设施、应用程序等等)进行不同的检查，以便在发生漏洞时，其范围和相关的损害将得到限制。

\item 
使用防火墙、证书、加密和适当的身份验证。
\end{itemize}

关于安全性的更多信息，请参考\textit{第10章}。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{不变的拓扑结构}

在微服务时代尤其正确。自动扩展和物尽其用基础设施管理方法，意味着拓扑结构将不断变化。这可能会影响延迟和带宽，因此这种假设的一些结果与前面描述的相同。

幸运的是，上述方法还提供了关于如何有效管理服务器群的指导方针。依赖主机名和DNS(而不是硬编码IP)是朝着正确方向迈出的一步，本书后面将介绍的服务发现是另一个步骤。第三步(更大的一步)是始终假设实例可能会失败，并自动对此类场景做出反应。Netflix的\textit{Chaos Monkey}工具也可以对相应的情况进行测试。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{只有一个管理员}

关于分布式系统的知识，由于其性质，通常是分布式的。不同的人负责此类系统，及其基础设施的开发、配置、部署和管理。不同的组件通常由不同的人进行升级，不一定是同步的。还有所谓的总线因素，就是项目关键成员被巴士撞到的风险因素。

该如何应对这一切？答案由几个部分组成，其中之一就是DevOps文化。通过促进开发和操作之间的密切协作，可以共享关于系统的知识，从而减少总线因素。引入持续交付，可以升级项目并使其保持正常运行。

尝试对系统进行松散耦合和向后兼容的建模，这样一个组件的升级就不需要带动对其他组件的升级。一种简单的解耦方法是在它们之间引入消息传递，因此可以考虑添加一个或两个队列，将有助于确定在升级期间的停机时间。

最后，尝试监视系统，并在一个集中的地方收集日志。分散系统不必在十几台不同的机器上手动查看日志。\textbf{ELK(Elasticsearch，Logstash，Kibana)}栈是宝贵的。Grafana，Prometheus，Loki和Jaeger也很受欢迎，尤其是Kubernetes。如果正在寻找比Logstash更轻量级的工具，请考虑Fluentd和Filebeat，尤其是处理容器的时候。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{传输成本为零}

这种假设对于计划项目及其预算非常重要。为分布式系统构建和维护网络需要时间和金钱，无论是在本地部署还是在云中部署——只是何时支付成本的问题。试着估算设备、要传输的数据(云提供商为此收费)和所需人力的成本。

如果依赖于压缩，请注意，虽然这可以降低网络成本，但可能会提高计算的成本。通常，使用二进制API(比如基于gRPC的API)将比基于JSON的API更廉价(也更快)，而且也比XML廉价。如果需要发送图像、音频或视频，必须评估其开销。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{同构的网络}

即使计划在网络上使用什么硬件和运行什么软件，也很容易出现一些异构性。某些机器上略有不同的配置、需要集成的遗留系统使用的不同通信协议，或者向系统发送请求的不同移动电话，这些只是其中的几个例子。另一个是通过在云中使用额外的人工服务来扩展本地的解决方案。

尽量限制所使用的协议和格式的数量，使用标准的协议和格式，并避免供应商锁定，以确保系统可以在此类异构环境中正常通信。异构性也可能意味着弹性的差异。尝试使用断路器模式，重新处理此问题。

现在已经讨论了错误的假设，接下来就来了解分布式架构的另一个重要的方面。

\subsubsubsection{4.2.3\hspace{0.2cm}CAP定理和最终一致性}

要设计跨多个节点的系统，需要了解并使用某些定理，其中之一就是\textbf{CAP定理}。其是在设计分布式系统时，需要做出的重要选择，其名称来源于分布式系统的三个属性。具体如下:

\begin{itemize}
\item 
\textbf{一致性}: 每次读取都将获得最近一次写入(或错误)之后的数据。

\item 
\textbf{可用性}: 每个请求都会得到无误的响应(不保证会获得最新的数据)。

\item 
\textbf{分区容错性}: 即使两个节点之间出现网络故障，系统作为一个整体仍可以继续工作。
\end{itemize}

这个定理说明，对于一个分布式系统，最多只能选择这三个属性中的两个。

只要系统正常运行，就可以满足这三个特性。然而，从错误假设中知道“网络不可靠”，因此就需要分区。这种情况下，分布式系统仍然可以正常运行。这意味着该定理实际上是需要在交付分区容错和一致性(即CP)或交付分区容错和可用性(即AP)之间做出选择。通常，后者是更好的选择。如果选择CA，则必须完全删除网络，只剩下单节点系统。

分区下使用交付一致性，在等待数据一致性时，要么返回一个错误，要么会有超时风险。如果选择可用性而不是一致性，则可能会返回旧数据——最新写入的数据可能无法跨分区传播。

这两种方法适用于不同的需求。如果系统需要原子读写，例如：客户可能会亏钱，那么就使用CP。如果系统必须继续在分区下运行，或者可以允许最终的一致性，那么就使用AP。

嗯，那一致性是什么呢？为了理解这一点，来了解一下不同层次的一致性。

提供强一致性的系统中，每个写操作都同步传播。从而所有的读操作将总是看到最新写入的数据，甚至以更高的延迟或更低的可用性为代价。这是DBMS关系模型提供的(基于ACID保证)最适合需要事务的系统。

另一方面，在提供最终一致性的系统中，只能保证在写操作之后，读操作最终会看到更改。通常，“最终”指的是几毫秒。这是由于此类系统中的数据复制具有异步特性，而不是上一段提到的同步传播。这里没有提供ACID保证(例如，使用RDBMS)，而是使用了BASE语义，通常由NoSQL数据库提供。

如果系统是异步的，并且为最终一致(AP系统通常是这样的)，就需要有一种方法来解决状态冲突。一种常见的方法是在实例之间交换更新，并选择第一次或最后一次写入作为可接受的写入。

接下来，来了解两个可以帮助实现一致性的模式。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Saga机制和补偿事务}

当需要执行分布式事务时，Saga模式非常有用。在微服务时代之前，如果有一台主机和数据库，那么可以依赖数据库引擎来处理事务。在一台主机上有多个数据库，可以使用\textbf{两阶段提交(2PCs)}来完成。对于2PCs，会有一个协调器，它首先告诉所有数据库准备好，当数据库都报告准备好了，它将告诉所有数据库进行事务提交。

现在，由于每个微服务可能都有自己的数据库(如果想要可扩展性，就应该这样)，并且它们遍布于基础设施，因此不能再依赖简单的事务和2PCs(失去这种能力通常意味着不再需要RDBMS，因为NoSQL数据库可以更快)。

相反，可以使用saga模式。用一个例子演示一下。

假设要创建一个在线仓库，跟踪它有多少供应，并允许信用卡支付。要处理订单，在所有其他服务中，需要三个服务:一个用于处理订单，一个用于保留供应，一个用于刷卡。

现在，有两种方式可以实现Saga模式:\textbf{基于无中心协调器}和\textbf{基于中心化控制器}。

\hspace*{\fill} \\ %插入空行
\noindent
\textit{基于无中心协调器的Saga}

第一种情况下，Saga的第一部分将是订单处理服务向供应服务发送事件。这个将完成它的部分，并将另一个事件发送给支付服务。然后支付服务将另一个事件发送回订单服务。这将完成交易(Saga)，现在可以愉快地发送订单了。

如果订单服务想要跟踪事务的状态，只需要侦听所有这些事件。

当然，有时订单无法完成，需要进行回滚。Saga的每个步骤都需要分别小心地回滚，因为其他事务可以并行运行，例如：修改供应状态。这种回滚称为\textbf{补偿事务}。

这种实现Saga模式的方法非常简单，但是如果所涉及的服务之间存在许多依赖关系，使用中心化方法可能会更好。说到这个，现在让我们来看看Saga的第二种方法。

\hspace*{\fill} \\ %插入空行
\noindent
\textit{基于中心化控制器的Saga}

需要消息代理来处理服务之间的通信，还需要协调器来协调整个过程。订单服务将向协调器发送一个请求，然后协调器将向供应服务和支付服务发送命令。然后，其中每一个都将完成自己的工作，并通过代理上可用的应答通道将应答发送回协调器。

此场景中，编排器拥有编排事务所需的所有逻辑，服务本身不需要知道参与该Saga的其他服务。

如果向编排器发送一条消息，说明其中一个服务失败了(例如，信用卡已经过期)，将需要启动回滚。在示例中，它将再次使用代理向特定的服务发送适当的回滚命令。

好了，关于一致性就聊到这里。现在让我们切换到与可用性相关的话题吧。




