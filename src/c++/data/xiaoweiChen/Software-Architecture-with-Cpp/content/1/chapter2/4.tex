
由于整体架构的缺点，应运而生了其他方法。一个常见的想法是将解决方案拆分为多个服务，这些服务相互通信。然后，可以将开发工作分配给不同的团队，每个团队负责单独的服务。每个团队的工作范围都很明确，这与整体架构风格完全不同。

\textbf{面向服务架构}，或简称为\textbf{SOA}，其业务功能是模块化的，并作为单独的服务提供给消费者应用使用。每个服务都应自描述的接口，并隐藏实现细节，比如：内部架构、技术或编程语言。这允许多个团队以其感觉舒服的方式开发服务，所以在内部，每个团队都可以使用合适的服务。假如有两个开发团队，一个精通C\#，另一个精通C++，他们可以开发两个可以相互通信的服务。

SOA的倡导者提出了一个宣言，优先考虑以下几点:

\begin{itemize}
\item
业务价值 \textit{高于} 技术策略

\item
战略目标 \textit{高于} 项目效益

\item
内在操作性 \textit{高于} 定制化集成

\item
共享服务 \textit{高于} 目标实现

\item
灵活 \textit{高于} 优化

\item
迭代式演进 \textit{高于} 开始即完美
\end{itemize}

尽管此宣言没有绑定到技术栈、实现或服务类型，但最常见的两种服务类型是SOAP和REST。除了这些，还有第三种越来越受欢迎的类型——基于gRPC的。可以在关于面向服务架构和微服务的章节中找到更多信息。

\subsubsubsection{2.4.1\hspace{0.2cm}微服务}

微服务是一种软件开发模式，在这种模式中，应用划分为使用轻量级协议进行通信的松耦合服务集合。微服务模式类似于UNIX哲学，即一个程序应该只有一个用途。根据UNIX哲学，高级问题可以将这些程序组合到UNIX流水线上来解决。类似地，基于微服务的系统由许多微服务和支持服务组成。

先概述一下这种架构风格的优缺点。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务的利弊}

微服务架构中服务的规模较小，它们的开发、部署和理解速度更快。由于服务是相互独立构建的，因此编译新版本所需的时间不需要很久。由于这一点，在处理这种架构风格时，使用快速原型和开发会更容易。这使得缩短交付时间成为可能，从而可以更快地引入和评估业务需求。

基于微服务的其他一些优点包括:

\begin{itemize}
\item
模块化，这是这种架构风格所固有的。

\item
良好的可测试性。

\item
替换系统部件(例如单个服务、数据库、消息代理或云提供商)时的灵活性。

\item
与遗留系统的集成:不需要迁移整个应用，只需迁移需要开发的部分即可。

\item
支持分布式开发:独立开发团队可以并行地处理多个微服务。

\item
可扩展性:微服务可以独立于其他服务进行扩展。
\end{itemize}

另一方面，微服务也有缺点:

\begin{itemize}
\item	
需要成熟的DevOps方法和对自动化CI/CD的依赖。

\item
更难调试，并且需要更好的监视和分布式跟踪。

\item
额外的开销(就辅助服务而言)可能会抵消小应用所带来的好处。

\end{itemize}

现在，了解一下以这种风格编写的服务特征。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务的特点}

由于微服务风格是最近才出现的，所以对微服务没有明确的定义。根据Martin Fowler的说法，微服务有几个基本特征:

\begin{itemize}
\item	
每个服务都是可替换和可升级的组件。这与服务之间更容易部署和松耦合相关联，而不是将组件作为单应用程序中的库。后一种情况下，当替换库时，常常要重新部署整个应用。

\item
每个服务都应该由一个跨职能团队开发，专注于特定的业务功能。听说过康威定律吗？

\begin{flushleft}
\tt
"设计系统的架构受制于产生这些设计组织的沟通结构。"
\end{flushleft}
\begin{flushright}
\texttt{—— Melvyn Conway, 1967}
\end{flushright}

如果没有跨职能的团队，最终会陷入软件孤岛。

\item
每个服务都应该是一个产品，在其生命周期内由开发团队把控，这与项目思维形成了鲜明对比。项目思维中开发软件，然后把它交给别人维护。

\item
服务应该有智能终端，并使用转储管道。这与传统服务不同，传统服务通常依赖于\textbf{企业服务总线(ESB)}逻辑，通常管理消息的路由，并根据业务规则进行转换。在微服务中，通过将逻辑存储在服务，中并避免与消息传递组件耦合，可以实现内聚。使用“哑”消息队列(如ZeroMQ)有助于实现这一目标。

\item
服务应该以分布式方式进行管理，组织中通常使用一种特定的技术栈编写。当划分为微服务时，每个人都可以选择最适合自己需求的服务。管理并确保每个微服务24/7运行是由负责该特定服务的团队完成的，而非中央部门。Amazon、Netflix和Facebook等公司遵循这一方法，让开发人员对其服务在生产过程中的完美执行负责，有助于确保产品的高质量。

\item
服务应该以分布式方式管理它们的数据。每个微服务都可以选择适合的数据库，而不是为所有微服务提供统一的数据库。拥有分布式数据可能会给数据更新带来一些挑战，但这样的实现具有更好的扩展性。这就是为什么微服务经常以无事务的方式进行协调，并提供最终一致的结果。

\item
服务使用的基础设施应该自动化管理。为了有效的处理几十个微服务，就需要有持续集成和持续交付，否则部署服务将是地狱般的体验。所有测试的自动化运行将节省大量时间。在此基础上实施持续部署将缩短反馈周期，并可以让客户更快地使用新特性。

\item
微服务应该为依赖服务的失败做好准备。在具有多部件的分布式部署环境中，有一些部件偶尔会出现中断是很正常的现象。服务应该能够优雅地处理此类故障，例如断路器或隔板(在后面会进行介绍)。为了使架构具有自愈能力，需要能恢复出现故障的服务，甚至提前知道哪些服务即将崩溃。为此，实时监控延迟、吞吐量和资源使用情况就很重要。可以去了解一下Netflix的Simian Army工具包，它是创建自愈架构特别好的工具。

\item
基于微服务的框架应该可持续发展。在设计微服务与架构一起工作时，应该考虑到如何替换单个微服务，甚至是替换一组微服务。恰当地设计服务是一件棘手的事情，特别是因为曾经的代码模块中的复杂性，现在可以作为服务间复杂的通信方案出现，但这就更难管理了——这就是“意大利面集成”(Spaghetti Integration)。这意味着架构师的经验和技能集比传统服务或单体方法更加重要。

\end{itemize}

在此基础上，以下是许多(但不是所有)微服务的共同特征:

\begin{itemize}
\item	
通过网络协议，独立进程可以互相通信
	
\item
使用与技术无关的协议(如HTTP和JSON)

\item
保持小规模服务，运行时开销低
\end{itemize}

现在，了解了基于微服务的系统特征，接下来，来看看这种方法与其他架构风格的比较。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务和其他架构风格}

微服务可以作为架构模式使用。但经常与其他架构组合使用，例如本地云计算、无服务器应用，并且主要与轻量级应用容器组合使用。

面向服务的架构带来了低耦合和高内聚。如果应用得当，微服务也可以做到这一点。然而，这可能有点难度，因为需要良好的直觉，将系统划分为数量众多的微服务。

微服务与其较大的同类服务之间有很多相似之处，可以使用基于SOAP、REST或gRPC的消息传递，并使用消息队列等技术来进行事件驱动。也有众所周知的模式来实现所需的质量属性，例如容错(通过隔离故障组件)，但是为了拥有一个高效的架构，必须决定处理组件的方法，如API网关、服务注册、负载平衡、容错、监视、配置管理，当然还有要使用的技术栈。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{扩展微服务}

微服务与单应用的扩展性不同。在单应用中，整个功能由单个进程处理。扩展应用程序意味着，会在不同的机器上重复这个过程。这种可扩展性不考虑哪些功能会大量使用，哪些功能不需要额外的资源。

对于微服务，每个功能组件都可以作为单独的服务处理，这就是一个独立的流程。为了扩展基于微服务的应用，只需要将使用更多资源的部分复制到不同的机器上即可，这种方法可以更容易且更好地利用现有资源。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{过渡到微服务}

大多数公司都有某种程度的整体代码，他们不希望立即使用微服务重写这些代码，但仍然希望过渡到这种架构。这样，可以通过渐进式添加与集成块交互的服务，来逐步适应微服务。可以创建新的功能作为微服务，或只是删除整体的一些部分，然后创建微服务。 

更多关于微服务的信息，包括如何从零开始构建自己的微服务，可以在第13章中看到。













