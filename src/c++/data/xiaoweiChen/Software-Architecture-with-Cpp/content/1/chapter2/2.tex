
有状态和无状态是两种完全相反的软件编写方法，每种方法都有各自的优缺点。

顾名思义，有状态软件的行为取决于其内部状态，这里以Web服务为例。如果记住了自己的状态，服务的使用者就可以在每个请求中发送更少的数据。然而，在请求大小和带宽上节省的成本，可能会让Web服务端具有隐藏的成本开销。如果用户同时发送许多请求，服务必须进行同步。因为多个请求可能同时改变状态，所以不同步可能会导致数据竞争。

若服务是无状态的，那么每个请求需要包含所需的全部数据。这意味着请求将变得更大，占用更多带宽。但另一方面，将获得更好的性能和服务的扩展性。如果熟悉函数式编程，会发现无状态服务很简洁。处理每个请求可以理解为对纯函数的调用，无状态编程提供的许多优势都源于函数式编程。可变状态是并发的敌人，函数式编程依赖于不可变值，这意味着需要复制对象，而不是修改现有对象。因此，每个线程都可以独立工作，不存在数据竞争。

没有竞争条件，所以不需要锁，这对性能来说是一个巨大的利好，没有锁就不需要处理死锁。纯函数代码也更容易调试，反过来对编译器也有帮助，优化代码也成了一项简单的任务。以函数式编写代码的另一个好处是，编写的源代码往往更简洁和具有表达力，特别是与严重依赖于\textbf{四人帮(GoF)}设计模式的代码相比。

但并不是说带宽没有问题，就应该使用无状态服务。这些决策可以在许多层次上进行，从单个类或函数到整个应用程序。

比如类，如果正在建模，创建一个\textit{Consultant}，那么将包含诸如顾问的姓名、联系数据、每小时的费率、当前和过去的项目等字段。这是有意义的，它有状态是很自然的事。现在，需要计算其工作所得，还要创建一个\textit{PaymentCalculator}类吗？这时，应该添加一个成员，还是一个自由函数来进行计算？如果使用类，应该传递一个\textit{Consultant}作为构造函数参数，还是方法参数？这个类应该有津贴之类的属性吗？

添加一个成员函数来计算薪酬将打破\textbf{单一职责原则(SRP)}，因为这个类将有两个职责：计算薪酬和存储顾问的数据(状态)。所以，应该为此引入一个自由函数或单独的类，而不是使用混合类。

首先，在这样的类中必须有这样的状态吗？讨论一下几种不同的\textit{PaymentCalculator}类。

一种是公开计算所需的属性:

\begin{lstlisting}[style=styleCXX]
class PaymentCalculator;
{
public:
	double calculate() const;
	
	void setHours(double hours);
	void setHourlyRate(double rate);
	void setTaxPercentage(double tax);
	
private:
	double hours_;
	double netHourlyRate_;
	double taxPercentage_;
};
\end{lstlisting}

这种方法有两个缺点。第一，线程不安全。这样的\textit{PaymentCalculator}类的单例不能在没有锁的多线程中使用。第二，当计算复杂时，这个类可能会开始从\textit{Consultant}类中复制更多的字段。

为了消除重复，可以重新编写类来存储顾问实例，如下所示:

\begin{lstlisting}[style=styleCXX]
class PaymentCalculator {
public:
	double calculate() const;
	
	void setConsultant(const Consultant &c);
	void setTaxPercentage(double tax);
	
private:
	gsl::not_null<const Consultant *> consultant_;
	double taxPercentage_;
};
\end{lstlisting}

注意，因为不能轻易地重新绑定引用，所以使用了来自\textbf{指南支持库(GSL)}的辅助类在包装器中存储一个可重新绑定的指针，从而确保没有存储空值。

这种方法仍然有线程不安全的缺点。这里能做得更好吗？事实证明，可以通过使类无状态，保证线程安全:

\begin{lstlisting}[style=styleCXX]
class PaymentCalculator {
public:
	static double calculate(const Consultant &c, double taxPercentage);
};
\end{lstlisting}

如果没有要管理的状态，那么可以创建自由函数(可能在不同的命名空间中)，或作为类的静态函数(就像前面的代码段中的那样)，但这都不那么重要。就类而言，区分值(实体)类型和操作类型很有用，因为混合使用可能会违反SRP。

\subsubsubsection{2.2.1\hspace{0.2cm}无状态和有状态服务}

在类中讨论的相同原则可以映射到更高级的概念，例如：微服务。

有状态服务是什么样子的？以FTP为例，若不是匿名的，则需要用户发送用户名和密码来创建会话。服务器存储这些数据，以识别用户仍然处于连接状态，因此不断地存储状态。每当用户更改工作目录时，状态就会更新。用户所做的每个更改都反映为状态的更改，即使断开连接也是如此。使用有状态服务意味着，根据不同的状态，可以为两个看起来相同的\textit{GET}请求返回不同的结果。如果服务器失去状态，请求甚至会停止处理。

有状态服务还可能存在不完整的会话或未完成的事务，以及增加复杂性的问题。会议应持续多久？如何验证客户端是否崩溃或断开连接？应该何时回滚所做的更改？虽然可以找到这些问题的答案，但通常会以动态的、智能的方式与其进行通信。因为服务将维护某种状态，所以让一个服务去维护状态不仅没有必要，而且也是一种浪费。

无状态服务，如本书后面描述的\textit{REST}，采用了相反的方法。每个请求必须包含所需的全部数据，因此两个相同的幂等请求(例如\textit{GET})将有相同的响应。这是在假定存储在服务器上的数据没有更改的情况下，但是数据不一定与状态相同。重要的是每个请求都是自包含的。

现代互联网服务的本质也是无状态。HTTP协议是无状态的，而许多服务API(例如Twitter的API)也是无状态的。Twitter的API所依赖的REST设计即为功能无状态的。这个缩写词背后的概念为\textbf{表征状态转移(Representational State Transfer，REST)}，包含了处理请求所需的状态必须传输的概念。如果不这样，就不能拥有REST的服务。然而，由于实际需要，这也有一些例外。

如果正在构建一个在线商店，可能希望存储与客户相关的信息，例如：订单历史和送货地址。客户端的客户端可能存储身份验证cookie，而服务器可能将一些用户数据存储在数据库中。cookie代替了管理会话的需要，因为这是在有状态服务中完成的。

对于服务来说，将会话保留在服务器端是一种糟糕的方式，原因有以下几点:增加了许多本可以避免的复杂性，使Bug更难复现，更为重要的是，无法进行扩展。如果想要将负载分配到另一个服务器，那么可能在复制会话和负载，以及在服务器之间同步会话时遇到困难。所以，会话信息都应该都保存在客户端。

如果希望有一个有状态的架构，就需要这样做的理由。以FTP协议为例，必须在客户端和服务器端复制更改。为了进行数据传输，用户只对单个特定的服务器进行身份验证。与Dropbox这样的服务相比，数据通常在用户之间共享，文件访问是通过API抽象出来的。接下来了解一下，为什么无状态模型更适合这种情况。












