Nathan Myers是第一个将特征参数的概念形式化的人。他最初把它们提交给C++标准化委员会，作为定义在标准库组件(例如输入和输出流)中应该如何处理字符类型的工具。当时，他称它们为“包模板”，并指出它们包含特征。然而，一些C++委员会成员并不喜欢“包”这个词，取而代之的是使用名称特征。从那时起，这个术语逐渐广泛使用。

外部代码通常根本不处理特征:默认的特征类满足最常见的需求，而且因为是默认的模板参数，根本不需要出现在外部源码中。这就可以为默认特征模板使用较长的描述性名称。当外部代码确实通过提供自定义特征参数来调整模板行为时，为产生的特化声明一个适合自定义行为的类型别名，是一个很好的方式。特征类可以赋予一个很长的描述性名称，而不会浪费太多的资源。

特征可以作为反射的一种形式，程序检查自己的高级属性(比如类型结构)。像IsClassT和PlusResultT这样的特征，以及许多其他检查程序中类型的类型特征，实现了一种编译时反射的形式，是元编程的强大盟友(参见第23章和第17.9节)。

将类型属性存储为模板特化成员的想法，至少可以追溯到20世纪90年代中期。在类型分类模板的早期应用中，有SGI(当时称为硅图形)发布的STL实现中的\_\_type\_traits程序。SGI模板意在表示其模板参数的一些属性(是否是一个普通的旧数据类型(POD)或析构函数是简单)。然后，使用这些信息对给定类型的某些STL算法进行优化。SGI解决方案的有趣特性是，一些SGI编译器能够识别\_\_type\_traits特化，并提供关于不能使用标准技术派生的参数的信息(\_\_type\_traits模板的通用实现使用起来尽管不是最优的，但是安全的)。

Boost提供了一套相当完整的类型分类模板(参见[BoostTypeTraits])，构成了2011 C++标准库中<type\_traits>头文件的基础。这些特征中的许多特性都可以通过本章描述的技术实现，但其他的(用于检测POD的std::is\_pod)需要编译器的支持，就像SGI编译器提供的\_\_type\_traits特化一样。

第一次标准化工作期间描述类型推演和替代规则时，就注意到SFINAE原则用于类型分类的目的。然而，这没有正式的文档记录，后来花费了大量的精力创建本章中描述的一些技术。本书的第一版是这种技术最早的来源之一，介绍了术语SFINAE。这一领域的另一位著名的早期贡献者是Andrei Alexandrescu，他普及了sizeof操作符来确定重载解析的结果。使这种技术变得流行，以至于2011年的标准将SFINAE的范围从简单的类型错误，扩展为函数模板的错误(参见[SpicerSFINAE])。这个扩展结合了decltype、右值引用和可变参数模板的添加，极大地扩展了在特征中测试特定属性的能力。

使用像isValid这样的泛型Lambda来提取SFINAE条件，是Louis Dionne在2015年引入的一种技术，Boost.Hana使用了这种技术(参见[boostana]，一个适合在编译时对类型和值进行计算的元编程库)。

策略类是由许多开发者开发的。Andrei Alexandrescu使策略类这个术语流行起来，他的书《现代C++设计》比我们的简短介绍(参见[AlexandrescuDesign])更加详细地介绍了策略类。