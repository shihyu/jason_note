
函数重载允许在多个函数中使用相同的函数名，需要通过参数类型区分这些函数即可:

\begin{lstlisting}[style=styleCXX]
void f(int);
void f(char const*);
\end{lstlisting}

使用函数模板，可以重载类型模式，如T的指针或Array<T>:

\begin{lstlisting}[style=styleCXX]
template<typename T> void f(T*);
template<typename T> void f(Array<T>);
\end{lstlisting}

鉴于类型特征的存在(第19章)，希望使用基于模板参数的属性重载函数模板。例如:

\begin{lstlisting}[style=styleCXX]
template<typename Number> void f(Number); // only for numbers
template<typename Container> void f(Container); // only for containers
\end{lstlisting}

但C++目前没有提供直接的方法来表示基于类型属性的重载，上面的两个f函数模板实际上是同一个函数模板的声明，因为在比较两个函数模板时，模板参数的名称会忽略。

幸运的是，有许多技术可以用来模拟基于类型属性的函数模板的重载。本章将讨论这些技术，以及使用这种重载的动机。






























