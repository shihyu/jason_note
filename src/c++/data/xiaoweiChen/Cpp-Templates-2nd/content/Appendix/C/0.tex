重载解析是为给定调用表达式选择要调用函数的过程。看看下面这个简单的例子:

\begin{lstlisting}[style=styleCXX]
void display_num(int); // #1
void display_num(double); // #2

int main()
{
	display_num(399); // #1 matches better than #2
	display_num(3.99); // #2 matches better than #1
}
\end{lstlisting}

例子中，函数名display\_num()重载，当在调用中使用这个名称时，C++编译器必须使用更多信息来区分不同的候选名称;大多数情况下，这些信息是调用参数的类型。我们的例子中，当函数调用一个整型参数时调用整型版本，当函数提供一个浮点参数时调用双精度浮点版本就很简单。尝试对这种简单选择建模的流程就是重载解析。

指导重载解析规则背后的思想很简单，但在C++标准化过程中，细节变得相当复杂。这种复杂性主要是由支持各种实际示例愿望所驱使，这些示例似乎具有“明显的最佳匹配”，但试图将这种直觉形式化时，各种微妙的问题就出现了。

本附录中，我们将对重载解析规则进行较为详细的介绍。这个过程非常复杂，我们不能涵盖该主题的每个部分。
























