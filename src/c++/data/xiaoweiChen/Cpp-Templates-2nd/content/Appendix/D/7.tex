

C++标准库提供了一些其他实用工具，这些工具对于编写可移植的泛型代码非常有用。

\begin{table}[H]
	\begin{center}
	\begin{tabular}{l|l}
		\hline
		\textbf{特性}                       & \textbf{作用}                                                         \\ \hline
		declval\textless{}T \textgreater{}() & 生成一个不构造类型的“对象”(右值引用) \\ \hline
		addressof(r)                         & 生成对象或函数的地址                             \\ \hline
	\end{tabular}
	\end{center}
\end{table}

\begin{center}
表D.9. 用于元编程的其他工具
\end{center}

\textbf{std::declval<T> ()}

\begin{itemize}
\item 
头文件<utility>中定义。

\item 
生成类型的“对象”或函数，而不使用构造函数或初始化。

\item 
若T为void，则返回类型为void。

可以用于处理未求值表达式中的对象或函数类型。

\item 
其简单定义如下:
\begin{lstlisting}[style=styleCXX]
template<typename T>
add_rvalue_reference_t<T> declval() noexcept;
\end{lstlisting}

因此:

\begin{itemize}
\item[-]
若T是普通类型或右值引用，则生成T\&\&。

\item[-]
若T是一个左值引用，它会产生一个T\&。

\item[-]
若T是void，它就产生void。
\end{itemize}

\item 
参阅第19.3.4节和第11.2.3节，以及第D.5节中common\_type<>类型特性，可以看看它的示例。
\end{itemize}

\textbf{std::addressof(r)}

\begin{itemize}
\item
头文件<memory>中定义。

\item
即使为对象或函数的类型重载了操作符\&，也会产生对象或函数r的地址。

\item
详见第11.2.2节。
\end{itemize}



















