另一个即将到来的扩展——模块，只与模板有外围关系，但它仍然值得一提，因为模板库是最大受益者之一。

目前，库接口在头文件中指定，这些头文件以文本形式包含在翻译单元中。这种方法有几个缺点，令人讨厌的两个是(a)之前包含的代码可能会修改界面文本的含义(例如，通过宏)，以及(b)每次重新处理文本迅速占据构建时间。

模块是一种特性，其允许库接口编译成编译器特定的格式，然后这些接口可以“导入”到翻译单元中，而不需要进行宏扩展，也不需要因为偶然出现的添加声明而修改代码的含义。此外，编译器可以安排只读取已编译模块文件中与外部代码相关的部分，从而大大加快编译过程。

模块定义可能是这样:

\begin{lstlisting}[style=styleCXX]
module MyLib;

void helper() {
	...
}

export inline void libFunc() {
	...
	helper();
	...
}
\end{lstlisting}

这个模块导出了一个函数libFunc()，可以在外部代码中使用，如下所示:

\begin{lstlisting}[style=styleCXX]
import MyLib;
int main() {
	libFunc();
}
\end{lstlisting}

libFunc()对外部代码可见，但函数helper()不是，即使编译的模块文件可能包含helper()的信息以启用内联。

向C++添加模块的提议正在进行中，标准化委员会的目标是在C++17之后将其集成入语言。在开发这样一个提议时，需要考虑的问题是如何从头文件过渡到模块。已经有一些工具在某种程度上实现了这一点(例如，包含头文件而不使其内容成为模块的一部分的能力)，以及其他仍在讨论中的功能(例如，从模块导出宏的能力)。

模块对于模板库特别有用，因为模板几乎总是在头文件中定义。即使包含一个像<vector>这样的基本标准头文件，也相当于处理数万行C++代码(即使只有该头文件中少量的声明会使用)。其他流行库会将其代码量增加一个数量级。对于处理大型复杂代码库的C++开发者来说，避免所有这些编译成本会让他们很感兴趣。































