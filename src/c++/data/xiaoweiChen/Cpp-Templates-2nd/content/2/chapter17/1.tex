
第一版中，本节建议将来可能会对typename的使用规则进行两种放宽(请参阅第13.3.2节):以前不允许使用typename的地方，现在可以用typename了，编译器可以相对容易地推导出带有依赖限定符的限定名，所以不必为命名类型使用typename。前者实现了(C++11中的typename冗余使用)，但后者没有。

最近，在对类型说明符的期望明确的各种类型，可以选用typename:

\begin{itemize}
\item 
命名空间和类作用域中的函数，以及成员函数声明的返回类型和参数类型。类似地，函数和成员函数模板，以及出现在作用域中的Lambda表达式。

\item 
变量、变量模板和静态数据成员声明的类型。同样，变量模板也类似。

\item 
别名类型或别名模板声明中等号表示后的类型。

\item 
模板的类型参数的默认参数。

\item 
出现在尖括号中的类型，紧跟在satatic\_cast、const\_cast、dynamic\_cast或reinterpret\_cast之后。

\item 
new表达式中命名的类型。
\end{itemize}

尽管这是一个相对特别的列表，但语言中的这种更改允许删除typename，会使代码更紧凑和可读更强。

