对于具有依赖于模板参数的基类类模板，即使成员x被继承，使用名称x本身并不总是等同于this\texttt{->}x。例如:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Base {
public:
	void bar();
};

template<typename T>
class Derived : Base<T> {
public:
	void foo() {
		bar(); // calls external bar() or error
	}
};
\end{lstlisting}

本例中，解析foo()内部的符号bar，不会考虑Base中定义的bar()。因此，要么出现错误，要么调用另一个bar()实现(例如全局bar())。

我们将在第13.4.2节详细讨论这个问题。目前，建议始终对基类中声明的符号进行限定，这些符号在某种程度上依赖于模板参数this\texttt{->}或Base<T>::。














































