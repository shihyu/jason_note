
这个术语表是本书中使用的术语汇总。参见[StroustrupGlossary]了解C++程序员使用的全面、通用的术语表。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{抽象类(abstract class)}

不可能创建具体对象(实例)的类。抽象类可以用于在单一类型中收集不同类的公共属性，或者定义多态接口。因为抽象类可作为基类，所以缩写ABC有时用来表示抽象基类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ADL}

参数相关查找的缩写。ADL是一个进程，在命名空间和类中查找函数(或操作符)名称，这些命名空间和类以某种方式与出现该函数(或操作符名称)的函数调用的参数相关联。由于历史原因，有时称为扩展Koenig查找，或是Koenig查找(后者也用于仅应用于操作符的ADL)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{别名模板(alias template)}  

表示一组类型别名的构造，指定了一个模式，通过用特定的实体替换模板参数，可以从该模式生成实际的类型别名。别名模板可以是类成员。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{尖括号黑客(angle bracket hack)}

一种C++特性，要求编译器接受两个连续的右尖括号字符作为两个结束尖括号，尖括号黑客会使vector<list<int>{}>与vector<list<int>{}>以相同地方式处理。其称为(词法)黑客，因为它不适合C++的正式规范(尤其是语法)，也不适合典型编译器的架构。另一个类似的黑客处理形成临时有向图(见有向图)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{尖括号(angle brackets)}

字符<和>用作分隔符，而不是用作小于和大于操作符。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ANSI}

美国国家标准协会(American National Standard Institute)的首字母缩写，该协会是一家私人非营利组织，负责协调各种标准规范的制定工作。参见INCITS。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数(argument)}

替代编程实体的参数的值(广义上)。在函数abs(-3)调用中，参数是-3。一些编程社区中，参数称为实际参数(而声明参数称为形式参数)。参见模板参数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数依赖查询(argument-dependent lookup)}

参见ADL。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类(class)}
 
对一类对象的描述,类为该类型的对象定义了一组特征。这包括数据(属性、数据成员)以及操作(方法、成员函数)。C++中，类是具有成员(也可以是函数)的结构，并且受到访问限制，使用关键字class或struct声明。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类模板(class template)}

表示类集的构造。其指定了一个模式，通过用特定的类型替换模板参数，可以从该模式生成实际的类。类模板有时称为参数化类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类类型(class type)}

用class、struct或union声明的C++类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{集合类(collection class)}

用于管理一组对象的类。在C++中，集合类也称为容器。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{编译器(compiler)}

将翻译单元中的源代码转换为目标代码的程序或库组件(带有符号注释的机器代码，允许链接器跨翻译单元解析引用)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{完整的类型(complete type)}

已定义的类、包含完整元素和已知大小的数组、具有已定义底层类型的枚举类型，以及除void(可选使用const和/或volatile)之外的基本数据类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{概念(concept)}

可应用于一个或多个模板参数的命名约束集。请参阅附录E。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{常量表达式(constant-expression)}

编译器可以在编译时计算表达式的值。有时称它为真常量，以避免与常量表达式(没有连字符)混淆。后者包含常量表达式，但编译器在编译时不一定会计算这些表达式。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{常量成员函数(const member function)}

可以为常量和临时对象调用的成员函数，通常不修改*this对象的成员。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{容器(container)}

参见集合类(collection class)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转换函数(conversion function)}

特殊的成员函数，定义了如何隐式(或显式)的将对象转换为另一类型的对象，使用函数操作符的形式声明。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转换操作符(conversion operator)}

转换函数的同义词。后者是标准术语，但前者也常用。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{CPP文件(CPP file)}

存放变量和非内联函数定义的文件。程序的大多数可执行(与声明性相反)代码通常放在CPP文件中，之所以命名为CPP文件，是因为通常以.CPP后缀命名。但由于历史原因，后缀也可以是.C、.c、.cc或.cxx。参见头文件和翻译单元。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{奇异递归模板模式(CRTP)}

奇异递归模板模式的缩写。这指的是一种代码模式，其中类X派生自具有X作为模板参数的基类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{奇异递归模板模式(curiously recurring template pattern)}

参见CRTP。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{衰变(decay)}

数组或函数到指针的隐式转换。字符串字面值"Hello"具有char类型const[6]，但在许多C++中，会隐式转换为char类型const*指针(指向字符串的第一个字符)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{声明(declaration)}

C++作用域中引入或重新引入名称的C++构造。参见定义(definition)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{推导(deduction)}

使用模板隐式确定模板参数的过程，完整的术语是模板参数推导。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{定义(definition)}

一种形式的声明，使已声明的实体为人所知。若是变量，则强制为已声明实体保留存储空间。对于类类型和函数定义，这相当于包含大括号括起来的主体的声明。对于外部变量声明，要么声明没有extern关键字，要么声明有初始化式。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{依赖基类(dependent base class)}

依赖于模板参数的基类。必须特别注意访问从属基类的成员。另请参见两阶段查找。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{依赖名称(dependent name)}

其含义依赖于模板参数的名称。当A或T是模板参数时，A<T>::x是一个依赖名称。若函数调用中的实参类型依赖于模板形参，那么函数调用中的函数名也依赖于模板形参。例如，f((T*)0)中的f是依赖于T是模板参数的。但是，模板参数的名称不是依赖，请参见两阶段查找。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{有向图(digraph)}

C++代码中相当于另一个字符的两个连续字符的组合。有向图的目的是用缺少某些字符的键盘输入C++源代码。虽然很少使用，但当左尖括号后面跟着一个范围解析操作符(::)而没有必要的中间空格时，有时会意外地形成有向图<:。C++11引入了一个词法黑客，在这种情况下禁用有向图解释。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空基类优化(EBCO)}

由大多数现代编译器执行的优化，其中“空”基类子对象不占用存储空间。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空基类优化(empty base class optimization)}

参见EBCO。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{显式实例化指令(explicit instantiation directive)}

一个C++构造，其唯一目的是创建一个实例化点(POI)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{显式特化(explicit specialization)}

为替换模板声明或定义替代定义的构造，原始(通用)模板称为主模板。若替代定义仍然依赖于一个或多个模板参数，则称为偏特化。否则，就是全特化。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{表达式模板(expression template)}

用来表示表达式一部分的类模板，模板本身表示一种特定的操作。模板参数表示操作所应用的操作数类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转发引用(forwarding reference)}

T\&\&的右值引用的两个术语之一，其中T是一个可推导的模板参数，适用不同于普通右值引用的特殊规则(参见第6.1节)。这个术语由C++17引入，因为引用的主要用途是转发对象，所以作为通用引用的替代，但它不会自动转发。这个术语并不描述它具体是什么，而是用于做什么。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{友元名称注入(friend name injection)}

当函数名的唯一声明是友元声明时，使函数名可见的过程。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{全特化(full specialization)}

参见显示特化(explicit specialization)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函数对象(function object)}

可以使用函数调用语法调用的对象。C++中，这些指针是指向函数的指针、带有重载函数操作符的类(参见functor)，以及带有转换函数的类，这些转换函数产生指向函数的指针或指向函数的引用。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函数模板(function template)}

表示函数族的构造，其指定了一个模式，通过使用特定的参数替换模板参数，可以从该模式生成实际的函数。函数模板是模板，不是函数。函数模板有时称为参数化函数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函子/仿函数(functor)}

具有重载函数操作符的类类型对象，可以使用函数调用的方式调用它。包括Lambda表达式的闭包类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{广义可本地化值(glvalue)}

为存储值(广义可本地化值)生成位置的一类表达式，glvalue可以是左值或xvalue。参见值类别章节和B.2节。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{头文件(header file)}

通过\#include指令成为翻译单元的一部分的文件。这些文件通常包含从多个翻译单元引用的变量和函数的声明，以及类型、内联函数、模板、常量和宏的定义。通常以.hpp、.h、.H、.hh或.hxx等后缀命名，也称为包含文件。参见CPP文件和翻译单元。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{国际信息技术标准委员会(INCITS)}

国际信息技术标准委员会(InterNational Committee for Information Technology Standards)是ANSI认可的美国标准开发组织(原名X3)的缩写。名为J16的小组委员会是C++标准化背后的驱动力，它与国际标准化组织(ISO)合作密切。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{包含文件(include file)}

参见头文件(header file)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{不完整类型(incomplete type)}

声明但未定义的类、元素类型不完整或大小未知的数组、未定义底层类型的枚举类型或void(可选使用const和/或volatile)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{间接调用(indirect call)}

在调用实际发生之前(在运行时)，调用的函数是未知的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{初始化式(initializer)}

指定如何初始化对象的构造。例如，初始化式为 = 1.0和(0.0,1.0)
\begin{lstlisting}[style=styleCXX]
std::complex<float> z1 = 1.0, z2(0.0, 1.0);
\end{lstlisting}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{初始化列表(initializer list)}

用大括号括起来的以逗号分隔的表达式列表，用于初始化对象和引用。初始化列表通常用于初始化变量，也用于(例如)初始化构造函数定义中的成员和基类。初始化可以直接进行，也可以通过std::initializer\_list对象进行。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类名称注入(injected class name)}

类的称在它自己的定义范围内可见。对于类模板，如果模板名后面没有模板参数列表，则模板名在模板的作用域内作为类名。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例(instance)}

实例一词在C++编程中有两层含义。源自面向对象术语的含义是类的实例:是类的实现的对象，C++中std::cout是std::ostream类的一个实例。另一种含义是模板实例:通过用特定值替换所有模板参数获得的类、函数或成员函数。所以，实例也称为特化，尽管后一个术语经常误认为是显式特化。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化(instantiation)}

在模板定义中替换模板参数，以创建具体实体(函数、类、变量或别名)。若只替换模板的声明而不替换模板的定义，则有时会使用术语“部分模板实例化”。参见替换。创建类的实例(对象)的另一种含义在本书中没有提及(参见instance)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{国际标准化组织(ISO)}

国际标准化组织的全球首字母缩写，名为WG21的ISO工作组是标准化和开发C++的幕后推手。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{迭代器(iterator)}

了解如何遍历元素序列的对象，这些元素属于一个集合(参见集合类)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{可链接的对象(linkable entity)}

以下任何一种:函数或成员函数、全局变量或静态数据成员，包括从模板生成的，并对链接器可见。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{连接器(linker)}

一种程序或操作系统服务，将已编译的翻译单元链接在一起，并跨翻译单元对可链接的实体进行引用和解析。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{左值(lvalue)}

一种表达式的类别，为假定不可移动的存储值(即非xvalue的glvalues)产生一个地址。典型的例子是表示命名对象(变量或成员)和字符串字面符的表达式。参见的值类别章节和B.1节。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员类模板(member class template)}

一个表示成员类族的类型，在另一个类或类模板定义中声明的类模板。并有自己的一组模板参数(不像类模板的成员类)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员函数模板(member function template)}

表示一组成员函数的构造，有自己的一组模板参数形参(与类模板的成员函数不同)。非常类似于函数模板，但当替换所有模板参数时，结果是一个成员函数(而不是普通函数)。成员函数模板不能为虚模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员模板(member template)}

成员类模板、成员函数模板或静态数据成员模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{现代C++(Modern C++)}

本书中指的是C++11或更高版本(即C++11、C++14或C++17)的标准化语言。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{不相关名称(nondependent name)}

不依赖于模板参数的名称。参见依赖名称和两阶段查找。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{单一定义规则(ODR)}

单一定义规则的首字母缩略词，该规则对C++程序中出现的定义施加了一些限制。详细信息请参见第10.4节和附录A。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{单一定义规则(one-definition rule)}

参见单一定义规则(ODR)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{重载解析(overload resolution)}

当存在多个候选函数(通常都有相同的名称)时，描述了选择调用哪个函数的过程。参见附录C。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数(parameter)}

占位符实体，某些时候会使用实际“值”(参数)替换。对于宏参数和模板参数，替换发生在编译时。对于函数调用参数，发生在运行时。在一些编程社区中，参数会称为形式参数(而实参称为实际参数)。参见参数和模板参数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数化类(parameterized class)}

类模板或嵌套在类模板中的类。因为在指定模板参数之前，都不对应于唯一的类，所以这两个类都是参数化的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数化函数(parameterized function)}

一个函数或成员函数模板或类模板的成员函数。因为在指定模板实参之前，并不对应于唯一的函数(或成员函数)，所以所有函数都是参数化的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{偏特化(partial specialization)}

为模板的某些替换声明或定义替代定义的构造，原始(通用)模板称为主模板，另一种定义仍然依赖于模板参数，这个构造只存在于类模板中。另请参见显式特化。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{普通的旧数据(POD)}

“普通旧数据(类型)”的缩写。POD类型可以在没有某些C++特性(如虚成员函数、访问关键字等)的情况下定义，每个普通的C结构体都是一个POD。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化点(POI)}

实例化点的缩写。POI是源代码中的一个位置，模板(或模板的成员)在这里通过用模板参数替换模板参数，从而在概念上展开。实践中，这种扩展并不需要在每个POI中都发生。另请参见显式实例化指令。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化点(point of instantiation)}

参见实例化点(POI)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{策略类(policy class)}

类或类模板，其成员描述泛型组件的可配置行为。策略通常作为模板参数传递，排序模板可能有一个排序策略，策略类也称为策略模板或策略。参见特性模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{多态性(polymorphism)}

操作(由其名称确定)应用于不同类型对象的能力。C++中，传统的面向对象的多态性概念(也称为运行时或动态多态性)是通过在派生类中重写的虚函数实现的。另外，C++模板也支持静态多态性。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{预编译头文件(precompiled header)}

编译器可以快速加载的一种经过处理的源代码形式。预编译头文件的源代码必须是翻译单元的第一部分(不能从翻译单元中间的某个地方开始)，预编译头文件对应许多头文件。使用预编译头文件可以大大减少构建用C++编写的大型应用程序所需的时间。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{主模板(primary template)}

非偏特化的模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{纯右值(prvalue)}

执行初始化的一类表达式。预值可以假定为指定纯数值，如1或true和临时值(特别是由值返回的值)。C++11前的右值在，C++11中都是纯右值。参见值类别和B.2节。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{限定名(qualified name)}

包含作用域限定符(::)的名称。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{引用计数(reference counting)}

一种资源管理策略，记录有多少实体引用了特定的资源。当计数减到0时，可以回收资源。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{右值(rvalue)}

不是左值的一类表达式。右值可以是prvalue(例如临时值)或xvalue(例如，用std::move()标记的左值)。C++11之前的右值，C++11中为纯右值。参见674页的值类别和B.2节。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{替换失败不为过(SFINAE)}

替换失败不为过的缩写。当以无效的方式替换模板参数时，一种静默丢弃模板的机制，而不是触发编译错误。弱替换成功，重载集中的其他模板就有机会选中。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{源文件(source file)}

头文件或CPP文件。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{特化(specialization)}

用实际值替换模板参数的结果。特化可以通过实例化创建，也可以通过显式特化创建。这个术语有时会错误地等同于显式特化。参见实例。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{静态数据成员模板(static data member template)}

作为类或类模板成员的变量模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{替换(substitution)}

将模板实体中的模板参数替换为实际类型、值或模板的过程。替换的程度取决于上下文，在重载解析期间，只执行建立候选函数类型的最小替换，若该替换导致无效构造，则应用SFINAE规则。参见实例化。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板(template)}

表示一系列类型、函数、成员函数或变量的方式，指定了一个模式，通过使用特定的实体替换模板参数，可以从该模式生成实际的类型、函数、成员函数或变量。本书中，这个术语不包括函数、类、静态数据成员和仅作为类模板成员而参数化的类型别名。请参见别名模板、变量模板、类模板、参数化类、函数模板和参数化函数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数(template argument)}

替换模板参数的“值”。这个值通常是一个类型，某些常量值和模板也可以是有效的模板参数。参见参数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数推导(template argument deduction)}

参见推导(deduction)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板标识(template-id)}

模板名后跟尖括号中指定的模板参数的组合(例如，std::list<int>)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数(template parameter)}

模板中的通用占位符。最常见的模板参数是类型参数。非类型参数表示某一类型的常量值，模板模板参数表示类型模板。参见参数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板化实体(templated entity)}

模板中定义或创建的模板或实体。后者包括类模板的普通成员函数或模板中出现的Lambda闭包类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{特征模板(traits template)}

一种类模板，其成员描述模板参数的特征。通常，特征模板的目的是避免模板参数过多。请参见策略类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{翻译单元(translation unit)}

包含所有头文件和标准库头文件的CPP文件，使用\#include指令，减去条件编译指令(如\#if)排除的程序文本，也可以认为是对CPP文件进行预处理的结果。参见CPP文件和头文件。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{真常量(true constant)}

编译器可以在编译时计算其值的表达式。参见常数表达式。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{元组(tuple)}

C结构体概念的泛化，成员可以通过编号访问。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{两阶段查找(two-phase lookup)}

用于模板中名称的名称查找机制。这两个阶段是(1)处理模板定义，(2)为特定的模板参数实例化模板。非依赖名称只在第一阶段查找，在该阶段不考虑非依赖基类。具有作用域限定符(::)的相关名称只在第二阶段查找。在两个阶段中都可以查找没有作用域限定符的相关名称，但在第二个阶段中，只执行与参数相关的查找。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类型别名(type alias)}

类型的另一种名称，使用typedef声明、别名声明或别名模板的实例化引入。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类型模板(type template)}

类模板、成员类模板或别名模板。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{通用引用(universal reference)}

T\&\&右值引用的两个术语之一，其中T是一个可推导的模板参数。适用不同于普通右值引用的特殊规则(参见第6.1节)。这个术语是由Scott Meyers创造的，作为左值引用和右值引用的共同术语。因为“通用”太通用了，所以在C++17中引入了转发引用。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{用户定义的转换(user-defined conversion)}

由开发者定义的类型转换，可以是用一个参数或转换函数调用的构造函数。除非构造函数或转换函数使用关键字explicit声明，否则可以隐式地进行类型转换。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{值类别(value category)}

表达式的分类。传统的值类别左值和右值是从C继承而来的。C++11引入了替代类别:glvalue(广义左值)，其求值标识存储的对象，以及prvalue(纯右值)，其求值初始化对象。其他类别将glvalue细分为lvalue(可本地化值)和xvalue(过期值)。在C++11中，右值作为xvalue和prvalue的一般类别(C++11之前，右值就是C++11中的prvalue)。详见附录B。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{变量模板(variable template)}

表示一组变量或静态数据成员的构造，指定了一种模式，通过使用特定的实体替换模板参数，可以从该模式生成实际变量和静态数据成员。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空白(whitespace)}

C++中，这是在源代码中分隔标记(标识符、文字、符号等)的空格。除了传统的空格、新行和制表字符外，还包括注释。其他空白字符(例如，页面提要控制字符)有时也是有效的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{过期值(xvalue)}

为存储的对象生成位置的一类表达式，该对象可以假定不再需要。一个典型的例子是用std::move()标记的左值。参见值类别和B.2节。




















