# 6.1 為併發設計的意義何在？ 

設計併發數據結構，意味著多個線程可以併發的訪問這個數據結構，線程可對這個數據結構做相同或不同的操作，並且每一個線程都能在自己的自治域中看到該數據結構。且在多線程環境下，無數據丟失和損毀，所有的數據需要維持原樣，且無條件競爭。這樣的數據結構，稱之為“線程安全”的數據結構。通常情況下，當多個線程對數據結構進行同一併發操作是安全的，但不同操作則需要單線程獨立訪問數據結構。或相反，當線程執行不同的操作時，對同一數據結構的併發操作是安全的，而多線程執行同樣的操作，則會出現問題。

實際的設計意義並不止上面提到的那樣：這就意味著，要為線程提供併發訪問數據結構的機會。本質上，是使用互斥量提供互斥特性：在互斥量的保護下，同一時間內只有一個線程可以獲取互斥鎖。互斥量為了保護數據，顯式的阻止了線程對數據結構的併發訪問。

這被稱為*串行化*(serialzation)：線程輪流訪問被保護的數據。這其實是對數據進行串行的訪問，而非併發。因此，你需要對數據結構的設計進行仔細斟酌，確保其能真正併發訪問。雖然，一些數據結構有著比其他數據結構多的併發訪問範圍，但是在所有情況下的思路都是一樣的：減少保護區域，減少序列化操作，就能提升併發訪問的潛力。

在我們進行數據結構的設計之前，讓我們快速的瀏覽一下，在併發設計中的指導建議。

## 6.1.1 數據結構併發設計的指導與建議(指南)

如之前提到的，當設計併發數據結構時，有兩方面需要考量：一是確保訪問是安全的，二是能真正的併發訪問。在第3章的時候，已經對如何保證數據結構是線程安全的做過簡單的描述：

- 確保無線程能夠看到，數據結構的“不變量”破壞時的狀態。

- 小心那些會引起條件競爭的接口，提供完整操作的函數，而非操作步驟。

- 注意數據結構的行為是否會產生異常，從而確保“不變量”的狀態穩定。

- 將死鎖的概率降到最低。使用數據結構時，需要限制鎖的範圍，且避免嵌套鎖的存在。

在你思考設計細節前，你還需要考慮這個數據結構對於使用者來說有什麼限制；當一個線程通過一個特殊的函數對數據結構進行訪問時，那麼還有哪些函數能被其他的線程安全調用呢？

這是一個很重要的問題，普通的構造函數和析構函數需要獨立訪問數據結構，所以用戶在使用的時候，就不能在構造函數完成前，或析構函數完成後對數據結構進行訪問。當數據結構支持賦值操作，swap()，或拷貝構造時，作為數據結構的設計者，即使數據結構中有大量的函數被線程所操縱時，你也需要保證這些操作在併發環境下是安全的(或確保這些操作能夠獨立訪問)，以保證併發訪問時不會出現錯誤。

第二個方面是，確保真正的併發訪問。這裡沒法提供更多的指導意見；不過，作為一個數據結構的設計者，在設計數據結構時，自行考慮以下問題：

- 鎖的範圍中的操作，是否允許在鎖外執行？

- 數據結構中不同的區域是否能被不同的互斥量所保護？

- 所有操作都需要同級互斥量保護嗎？

- 能否對數據結構進行簡單的修改，以增加併發訪問的概率，且不影響操作語義？

這些問題都源於一個指導思想：如何讓序列化訪問最小化，讓真實併發最大化？允許線程併發讀取的數據結構並不少見，而對數據結構的修改，必須是單線程獨立訪問。這種結構，類似於`boost::shared_mutex`。同樣的，這種數據結構也很常見——支持在多線程執行不同的操作時，並序列化執行相同的操作的線程(你很快就能看到)。

最簡單的線程安全結構，通常使用的是互斥量和鎖，對數據進行保護。雖然，這麼做還是有問題（如同在第3中提到的那樣），不過這樣相對簡單，且保證只有一個線程在同一時間對數據結構進行一次訪問。為了讓你輕鬆的設計線程安全的數據結構，接下來了解一下基於鎖的數據結構，以及第7章將提到的無鎖併發數據結構的設計。
