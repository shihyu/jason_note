# 10.1 與併發相關的錯誤類型

你可以在併發代碼中發現各式各樣的錯誤，這些錯誤不會集中於某個方面。不過，有一些錯誤與使用併發直接相關，本章重點關注這些錯誤。通常，併發相關的錯誤通常有兩大類：

- 不必要阻塞

- 條件競爭

這兩大類的顆粒度很大，讓我們將其分成顆粒度較小的問題。

##10.1.1 不必要阻塞

“不必要阻塞”是什麼意思？一個線程被阻塞的時候，不能處理任何任務，因為它在等待其他“條件”的達成。通常這些“條件”就是一個互斥量、一個條件變量或一個future，也可能是一個I/O操作。這是多線程代碼的先天特性，不過這也不是在任何時候都可取的——衍生成“不必要阻塞”。你會問：為什麼不需要阻塞？通常，是因為其他線程在等待該阻塞線程上的某些操作完成，如果該線程阻塞了，那那些線程必然會被阻塞。

這個主題可以分成以下幾個問題：

- 死鎖——如你在第3章所見，在死鎖的情況下，兩個線程會互相等待。當線程產生死鎖，應該完成的任務就會持續擱置。舉個例子來說，一些線程是負責對用戶界面操作的線程，在死鎖的情況下，用戶界面就會無響應。在另一些例子中，界面接口會保持響應，不過有些任務就無法完成，比如：查詢無結果返回，或文檔未打印。

- 活鎖——與死鎖的情況類似。不同的地方在於線程不是阻塞等待，而是在循環中持續檢查，例如：自旋鎖。一些比較嚴重的情況下，其表現和死鎖一樣(應用不會做任何處理，停止響應)，CPU的使用率還居高不下；因為線程還在循環中被檢查，而不是阻塞等待。在一些不太嚴重的情況下，因為使用隨機調度，活鎖的問題還是可以解決的。

- I/O阻塞或外部輸入——當線程被外部輸入所阻塞，線程也就不能做其他事情了(即使，等待輸入的情況永遠不會發生)。因此，被外部輸入所阻塞，就會讓人不太高興，因為可能有其他線程正在等待這個線程完成某些任務。

簡單的介紹了一下“不必要阻塞”的組成。

那麼，條件競爭呢？

## 10.1.2 條件競爭

條件競爭在多線程代碼中很常見——很多條件競爭表現為死鎖與活鎖。而且，並非所有條件競爭都是惡性的——對獨立線程相關操作的調度，決定了條件競爭發生的時間。很多條件競爭是良性的，比如：哪一個線程去處理任務隊列中的下一個任務。不過，很多併發錯誤的引起也是因為條件競爭。

特別是，條件競爭經常會產生以下幾種類型的錯誤：

- 數據競爭——因為未同步訪問一塊共享內存，將會導致代碼產生未定義行為。在第5章已經介紹了數據競爭，也瞭解了`C++`的內存模型。數據競爭通常發生在錯誤的使用原子操作，做同步線程的時候，或沒使用互斥量所保護的共享數據的時候。

- 破壞不變量——主要表現為懸空指針(因為其他線程已經將要訪問的數據刪除了)，隨機存儲錯誤(因為局部更新，導致線程讀取了不一樣的數據)，以及雙重釋放(比如：當兩個線程對同一個隊列同時執行pop操作，想要刪除同一個關聯數據)，等等。不變量被破壞可以看作為“基於數據”的問題。當獨立線程需要以一定順序執行某些操作時，錯誤的同步會導致條件競爭，比如：順序被破壞。

- 生命週期問題——雖然這類問題也能歸結為破壞了不變量，不過這裡將其作為一個單獨的類別給出。這裡的問題是，線程會訪問不存在的數據，這可能是因為數據被刪除或銷燬了，或者轉移到其他對象中去了。生命週期問題，通常是在一個線程引用了局部變量，在線程還沒有完成前，局部變量的“死期”就已經到了，不過這個問題並不止存在這種情況下。當你手動調用join()等待線程完成工作，你需要保證異常拋出的時候，join()還會等待其他未完成工作的線程。這是線程中基本異常安全的應用。

惡性條件競爭就如同一個殺手。死鎖和活鎖會表現為：應用掛起和反應遲鈍，或超長時間完成任務。當一個線程產生死鎖或活鎖，可以用調試器附著到該線程上進行調試。條件競爭，破壞不變量，以及生命週期問題，其表現都是代碼可見的(比如，隨機崩潰或錯誤輸出)——可能重寫了系統部分的內存使用方式(不會改太多)。其中，可能是因為執行時間，導致問題無法定位到具體的位置。這是共享內存系統的詛咒——需要通過線程嘗試限制可訪問的數據，並且還要正確的使用同步，應用中的任何線程都可以複寫(可被其他線程訪問的)數據。

現在已經瞭解了這兩大類中都有哪些具體問題了。

下面就讓我們來瞭解，如何在你的代碼中定位和修復這些問題。