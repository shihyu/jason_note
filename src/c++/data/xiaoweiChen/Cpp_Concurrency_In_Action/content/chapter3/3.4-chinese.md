# 3.4 本章總結

本章討論了當兩個線程間的共享數據發生惡性條件競爭會帶來多麼嚴重的災難，還討論瞭如何使用`std::mutex`，和如何避免這些問題。如你所見，互斥量並不是靈丹妙藥，其還有自己的問題(比如：死鎖)，雖然C++標準庫提供了一類工具來避免這些(例如：`std::lock()`)。你還見識了一些用於避免死鎖的先進技術，之後瞭解了鎖所有權的轉移，以及一些圍繞如何選取適當粒度鎖產生的問題。最後，討論了在具體情況下，數據保護的替代方案，例如:`std::call_once()`和`boost::shared_mutex`。

還有一個方面沒有涉及到，那就是等待其他線程作為輸入的情況。我們的線程安全棧，僅是在棧為空時，拋出一個異常，所以當一個線程要等待其他線程向棧壓入一個值時(這是一個線程安全棧的主要用途之一)，它不得不多次嘗試去彈出一個值，當捕獲拋出的異常時，再次進行嘗試。這種消耗資源的檢查，沒有任何意義。並且，不斷的檢查會影響系統中其他線程的運行，這反而會妨礙程序的進展。我們需要一些方法讓一個線程等待其他線程完成任務，但在等待過程中不佔用CPU。第4章中，會去建立一些工具，用於保護共享數據，還會介紹一些線程同步操作的機制；第6章中，如何構建更大型的可複用的數據類型。