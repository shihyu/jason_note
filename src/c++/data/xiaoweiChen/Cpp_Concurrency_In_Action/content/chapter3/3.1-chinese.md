# 3.1 共享數據帶來的問題

當涉及到共享數據時，問題很可能是因為共享數據修改所導致。如果共享數據是隻讀的，那麼只讀操作不會影響到數據，更不會涉及對數據的修改，所以所有線程都會獲得同樣的數據。但是，當一個或多個線程要修改共享數據時，就會產生很多麻煩。這種情況下，就必須小心謹慎，才能確保一切所有線程都工作正常。

*不變量*(invariants)的概念對程序員們編寫的程序會有一定的幫助——對於特殊結構體的描述；比如，“變量包含列表中的項數”。不變量通常會在一次更新中被破壞，特別是比較複雜的數據結構，或者一次更新就要改動很大的數據結構。

雙鏈表中每個節點都有一個指針指向列表中下一個節點，還有一個指針指向前一個節點。其中不變量就是節點A中指向“下一個”節點B的指針，還有前向指針。為了從列表中刪除一個節點，其兩邊節點的指針都需要更新。當其中一邊更新完成時，不變量就被破壞了，直到另一邊也完成更新；在兩邊都完成更新後，不變量就又穩定了。

從一個列表中刪除一個節點的步驟如下(如圖3.1)

1. 找到要刪除的節點N<br>
2. 更新前一個節點指向N的指針，讓這個指針指向N的下一個節點<br>
3. 更新後一個節點指向N的指針，讓這個指正指向N的前一個節點<br>
4. 刪除節點N<br>

![](../../images/chapter3/3-1.png)

圖3.1 從一個雙鏈表中刪除一個節點

圖中b和c在相同的方向上指向和原來已經不一致了，這就破壞了不變量。

線程間潛在問題就是修改共享數據，致使不變量遭到破壞。當不做些事來確保在這個過程中不會有其他線程進行訪問的話，可能就有線程訪問到剛剛刪除一邊的節點；這樣的話，線程就讀取到要刪除節點的數據(因為只有一邊的連接被修改，如圖3.1(b))，所以不變量就被破壞。破壞不變量的後果是多樣，當其他線程按從左往右的順序來訪問列表時，它將跳過被刪除的節點。在一方面，如有第二個線程嘗試刪除圖中右邊的節點，那麼可能會讓數據結構產生永久性的損壞，使程序崩潰。無論結果如何，都是並行代碼常見錯誤：條件競爭。

## 3.1.1 條件競爭

假設你去電影院買電影票。如果去的是一家大電影院，有很多收銀臺，很多人就可以在同一時間買電影票。當另一個收銀臺也在賣你想看的這場電影的電影票，那麼你的座位選擇範圍就取決於在之前已預定的座位。當只有少量的座位剩下，這就意味著，這可能是一場搶票比賽，看誰能搶到最後一張票。這就是一個條件競爭的例子：你的座位(或者你的電影票)都取決於兩種購買方式的相對順序。

併發中競爭條件的形成，取決於一個以上線程的相對執行順序，每個線程都搶著完成自己的任務。大多數情況下，即使改變執行順序，也是良性競爭，其結果可以接受。例如，有兩個線程同時向一個處理隊列中添加任務，因為系統提供的不變量保持不變，所以誰先誰後都不會有什麼影響。當不變量遭到破壞時，才會產生條件競爭，比如雙向鏈表的例子。併發中對數據的條件競爭通常表示為惡性條件競爭，我們對不產生問題的良性條件競爭不感興趣。`C++`標準中也定義了數據競爭這個術語，一種特殊的條件競爭：併發的去修改一個獨立對象(參見5.1.2節)，數據競爭是(可怕的)未定義行為的起因。

惡性條件競爭通常發生於完成對多於一個的數據塊的修改時，例如，對兩個連接指針的修改(如圖3.1)。因為操作要訪問兩個獨立的數據塊，獨立的指令將會對數據塊將進行修改，並且其中一個線程可能正在進行時，另一個線程就對數據塊進行了訪問。因為出現的概率太低，條件競爭很難查找，也很難復現。如CPU指令連續修改完成後，即使數據結構可以讓其他併發線程訪問，問題再次復現的幾率也相當低。當系統負載增加時，隨著執行數量的增加，執行序列的問題復現的概率也在增加，這樣的問題只可能會出現在負載比較大的情況下。條件競爭通常是時間敏感的，所以程序以調試模式運行時，它們常會完全消失，因為調試模式會影響程序的執行時間(即使影響不多)。

當你以寫多線程程序為生，條件競爭就會成為你的夢魘；編寫軟件時，我們會使用大量複雜的操作，用來避免惡性條件競爭。

## 3.1.2 避免惡性條件競爭

這裡提供一些方法來解決惡性條件競爭，最簡單的辦法就是對數據結構採用某種保護機制，確保只有進行修改的線程才能看到不變量被破壞時的中間狀態。從其他訪問線程的角度來看，修改不是已經完成了，就是還沒開始。`C++`標準庫提供很多類似的機制，下面會逐一介紹。

另一個選擇是對數據結構和不變量的設計進行修改，修改完的結構必須能完成一系列不可分割的變化，也就是保證每個不變量保持穩定的狀態，這就是所謂的無鎖編程。不過，這種方式很難得到正確的結果。如果到這個級別，無論是內存模型上的細微差異，還是線程訪問數據的能力，都會讓工作變的複雜。內存模型將在第5章討論，無鎖編程將在第7章討論。

另一種處理條件競爭的方式是，使用事務的方式去處理數據結構的更新(這裡的"處理"就如同對數據庫進行更新一樣)。所需的一些數據和讀取都存儲在事務日誌中，然後將之前的操作合為一步，再進行提交。當數據結構被另一個線程修改後，或處理已經重啟的情況下，提交就會無法進行，這稱作為“軟件事務內存”。理論研究中，這是一個很熱門的研究領域。這個概念將不會在本書中再進行介紹，因為在`C++`中沒有對STM進行直接支持。但是，基本思想會在後面提及。

保護共享數據結構的最基本的方式，是使用C++標準庫提供的互斥量。