# 2.1 線程管理的基礎

每個程序至少有一個線程：執行main\(\)函數的線程，其餘線程有其各自的入口函數。線程與原始線程\(以main\(\)為入口函數的線程\)同時運行。如同main\(\)函數執行完會退出一樣，當線程執行完入口函數後，線程也會退出。在為一個線程創建了一個`std::thread`對象後，需要等待這個線程結束；不過，線程需要先進行啟動。下面就來啟動線程。

## 2.1.1 啟動線程

第1章中，線程在`std::thread`對象創建\(為線程指定任務\)時啟動。最簡單的情況下，任務也會很簡單，通常是無參數無返回的函數。這種函數在其所屬線程上運行，直到函數執行完畢，線程也就結束了。在一些極端情況下，線程運行時，任務中的函數對象需要通過某種通訊機制進行參數的傳遞，或者執行一系列獨立操作;可以通過通訊機制傳遞信號，讓線程停止。線程要做什麼，以及什麼時候啟動，其實都無關緊要。總之，使用C++線程庫啟動線程，可以歸結為構造`std::thread`對象：

```
void do_some_work();
std::thread my_thread(do_some_work);
```

為了讓編譯器識別`std::thread`類，這個簡單的例子也要包含`<thread>`頭文件。如同大多數C++標準庫一樣，`std::thread`可以用可調用類型構造，將帶有函數調用符類型的實例傳入`std::thread`類中，替換默認的構造函數。

```
class background_task
{
public:
  void operator()() const
  {
    do_something();
    do_something_else();
  }
};

background_task f;
std::thread my_thread(f);
```

代碼中，提供的函數對象會複製到新線程的存儲空間當中，函數對象的執行和調用都在線程的內存空間中進行。函數對象的副本應與原始函數對象保持一致，否則得到的結果會與我們的期望不同。

有件事需要注意，當把函數對象傳入到線程構造函數中時，需要避免“[最令人頭痛的語法解析](http://en.wikipedia.org/wiki/Most_vexing_parse)”\(_C++’s most vexing parse_, [中文簡介](http://qiezhuifeng.diandian.com/post/2012-08-27/40038339477)\)。如果你傳遞了一個臨時變量，而不是一個命名的變量；C++編譯器會將其解析為函數聲明，而不是類型對象的定義。

例如：

```
std::thread my_thread(background_task());
```

這裡相當與聲明瞭一個名為my\_thread的函數，這個函數帶有一個參數\(函數指針指向沒有參數並返回background\_task對象的函數\)，返回一個`std::thread`對象的函數，而非啟動了一個線程。

使用在前面命名函數對象的方式，或使用多組括號①，或使用新統一的初始化語法②，可以避免這個問題。

如下所示：

```
std::thread my_thread((background_task()));  // 1
std::thread my_thread{background_task()};    // 2
```

使用lambda表達式也能避免這個問題。lambda表達式是C++11的一個新特性，它允許使用一個可以捕獲局部變量的局部函數\(可以避免傳遞參數，參見2.2節\)。想要具體的瞭解lambda表達式，可以閱讀附錄A的A.5節。之前的例子可以改寫為lambda表達式的類型：

```
std::thread my_thread([]{
  do_something();
  do_something_else();
});
```

啟動了線程，你需要明確是要等待線程結束\(_加入式_——參見2.1.2節\)，還是讓其自主運行\(_分離式_——參見2.1.3節\)。如果`std::thread`對象銷燬之前還沒有做出決定，程序就會終止\(`std::thread`的析構函數會調用`std::terminate()`\)。因此，即便是有異常存在，也需要確保線程能夠正確的_加入_\(joined\)或_分離_\(detached\)。2.1.3節中，會介紹對應的方法來處理這兩種情況。需要注意的是，必須在`std::thread`對象銷燬之前做出決定，否則你的程序將會終止\(std::thread的析構函數會調用std::terminate\(\)，這時再去決定會觸發相應異常\)。

如果不等待線程，就必須保證線程結束之前，可訪問的數據得有效性。這不是一個新問題——單線程代碼中，對象銷燬之後再去訪問，也會產生未定義行為——不過，線程的生命週期增加了這個問題發生的幾率。

這種情況很可能發生在線程還沒結束，函數已經退出的時候，這時線程函數還持有函數局部變量的指針或引用。下面的清單中就展示了這樣的一種情況。

清單2.1  函數已經結束，線程依舊訪問局部變量

```
struct func
{
  int& i;
  func(int& i_) : i(i_) {}
  void operator() ()
  {
    for (unsigned j=0 ; j<1000000 ; ++j)
    {
      do_something(i);           // 1. 潛在訪問隱患：懸空引用
    }
  }
};

void oops()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread my_thread(my_func);
  my_thread.detach();          // 2. 不等待線程結束
}                              // 3. 新線程可能還在運行
```

這個例子中，已經決定不等待線程結束\(使用了detach\(\)②\)，所以當oops\(\)函數執行完成時③，新線程中的函數可能還在運行。如果線程還在運行，它就會去調用do\_something\(i\)函數①，這時就會訪問已經銷燬的變量。如同一個單線程程序——允許在函數完成後繼續持有局部變量的指針或引用；當然，這從來就不是一個好主意——這種情況發生時，錯誤並不明顯，會使多線程更容易出錯。

處理這種情況的常規方法：使線程函數的功能齊全，將數據複製到線程中，而非複製到共享數據中。如果使用一個可調用的對象作為線程函數，這個對象就會複製到線程中，而後原始對象就會立即銷燬。但對於對象中包含的指針和引用還需謹慎，例如清單2.1所示。使用一個能訪問局部變量的函數去創建線程是一個糟糕的主意\(除非**十分確定**線程會在函數完成前結束\)。此外，可以通過join\(\)函數來確保線程在函數完成前結束。

## 2.1.2 等待線程完成

如果需要等待線程，相關的`std::thread`實例需要使用join\(\)。清單2.1中，將`my_thread.detach()`替換為`my_thread.join()`，就可以確保局部變量在線程完成後，才被銷燬。在這種情況下，因為原始線程在其生命週期中並沒有做什麼事，使得用一個獨立的線程去執行函數變得收益甚微，但在實際編程中，原始線程要麼有自己的工作要做；要麼會啟動多個子線程來做一些有用的工作，並等待這些線程結束。

join\(\)是簡單粗暴的等待線程完成或不等待。當你需要對等待中的線程有更靈活的控制時，比如，看一下某個線程是否結束，或者只等待一段時間\(超過時間就判定為超時\)。想要做到這些，你需要使用其他機制來完成，比如條件變量和_期待_\(futures\)，相關的討論將會在第4章繼續。調用join\(\)的行為，還清理了線程相關的存儲部分，這樣`std::thread`對象將不再與已經完成的線程有任何關聯。這意味著，只能對一個線程使用一次join\(\);一旦已經使用過join\(\)，`std::thread`對象就不能再次加入了，當對其使用joinable\(\)時，將返回false。

## 2.1.3 特殊情況下的等待

如前所述，需要對一個還未銷燬的`std::thread`對象使用join\(\)或detach\(\)。如果想要分離一個線程，可以在線程啟動後，直接使用detach\(\)進行分離。如果打算等待對應線程，則需要細心挑選調用join\(\)的位置。當在線程運行之後產生異常，在join\(\)調用之前拋出，就意味著這次調用會被跳過。

避免應用被拋出的異常所終止，就需要作出一個決定。通常，當傾向於在無異常的情況下使用join\(\)時，需要在異常處理過程中調用join\(\)，從而避免生命週期的問題。下面的程序清單是一個例子。

清單 2.2 等待線程完成

```
struct func; // 定義在清單2.1中
void f()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread t(my_func);
  try
  {
    do_something_in_current_thread();
  }
  catch(...)
  {
    t.join();  // 1
    throw;
  }
  t.join();  // 2
}
```

清單2.2中的代碼使用了`try/catch`塊確保訪問本地狀態的線程退出後，函數才結束。當函數正常退出時，會執行到②處；當函數執行過程中拋出異常，程序會執行到①處。`try/catch`塊能輕易的捕獲輕量級錯誤，所以這種情況，並非放之四海而皆準。如需確保線程在函數之前結束——查看是否因為線程函數使用了局部變量的引用，以及其他原因——而後再確定一下程序可能會退出的途徑，無論正常與否，可以提供一個簡潔的機制，來做解決這個問題。

一種方式是使用“資源獲取即初始化方式”\(RAII，Resource Acquisition Is Initialization\)，並且提供一個類，在析構函數中使用**join\(\)**，如同下面清單中的代碼。看它如何簡化f\(\)函數。

清單 2.3 使用RAII等待線程完成

```
class thread_guard
{
  std::thread& t;
public:
  explicit thread_guard(std::thread& t_):
    t(t_)
  {}
  ~thread_guard()
  {
    if(t.joinable()) // 1
    {
      t.join();      // 2
    }
  }
  thread_guard(thread_guard const&)=delete;   // 3
  thread_guard& operator=(thread_guard const&)=delete;
};

struct func; // 定義在清單2.1中

void f()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread t(my_func);
  thread_guard g(t);
  do_something_in_current_thread();
}    // 4
```

當線程執行到④處時，局部對象就要被逆序銷燬了。因此，thread\_guard對象g是第一個被銷燬的，這時線程在析構函數中被加入②到原始線程中。即使do\_something\_in\_current\_thread拋出一個異常，這個銷燬依舊會發生。

在thread\_guard的析構函數的測試中，首先判斷線程是否已加入①，如果沒有會調用join\(\)②進行加入。這很重要，因為join\(\)只能對給定的對象調用一次，所以對給已加入的線程再次進行加入操作時，將會導致錯誤。

拷貝構造函數和拷貝賦值操作被標記為`=delete`③，是為了不讓編譯器自動生成它們。直接對一個對象進行拷貝或賦值是危險的，因為這可能會弄丟已經加入的線程。通過刪除聲明，任何嘗試給thread\_guard對象賦值的操作都會引發一個編譯錯誤。想要了解刪除函數的更多知識，請參閱附錄A的A.2節。

如果不想等待線程結束，可以_分離_\(_detaching\)線程，從而避免_異常安全\*\(exception-safety\)問題。不過，這就打破了線程與`std::thread`對象的聯繫，即使線程仍然在後臺運行著，分離操作也能確保`std::terminate()`在`std::thread`對象銷燬才被調用。

## 2.1.4 後臺運行線程

使用detach\(\)會讓線程在後臺運行，這就意味著主線程不能與之產生直接交互。也就是說，不會等待這個線程結束；如果線程分離，那麼就不可能有`std::thread`對象能引用它，分離線程的確在後臺運行，所以分離線程不能被加入。不過C++運行庫保證，當線程退出時，相關資源的能夠正確回收，後臺線程的歸屬和控制C++運行庫都會處理。

通常稱分離線程為_守護線程_\(daemon threads\),UNIX中守護線程是指，沒有任何顯式的用戶接口，並在後臺運行的線程。這種線程的特點就是長時間運行；線程的生命週期可能會從某一個應用起始到結束，可能會在後臺監視文件系統，還有可能對緩存進行清理，亦或對數據結構進行優化。另一方面，分離線程的另一方面只能確定線程什麼時候結束，_發後即忘_\(fire and forget\)的任務就使用到線程的這種方式。

如2.1.2節所示，調用`std::thread`成員函數detach\(\)來分離一個線程。之後，相應的`std::thread`對象就與實際執行的線程無關了，並且這個線程也無法加入：

```
std::thread t(do_background_work);
t.detach();
assert(!t.joinable());
```

為了從`std::thread`對象中分離線程\(前提是有可進行分離的線程\),不能對沒有執行線程的`std::thread`對象使用detach\(\),也是join\(\)的使用條件，並且要用同樣的方式進行檢查——當`std::thread`對象使用t.joinable\(\)返回的是true，就可以使用t.detach\(\)。

試想如何能讓一個文字處理應用同時編輯多個文檔。無論是用戶界面，還是在內部應用內部進行，都有很多的解決方法。雖然，這些窗口看起來是完全獨立的，每個窗口都有自己獨立的菜單選項，但他們卻運行在同一個應用實例中。一種內部處理方式是，讓每個文檔處理窗口擁有自己的線程；每個線程運行同樣的的代碼，並隔離不同窗口處理的數據。如此這般，打開一個文檔就要啟動一個新線程。因為是對獨立的文檔進行操作，所以沒有必要等待其他線程完成。因此，這裡就可以讓文檔處理窗口運行在分離的線程上。

下面代碼簡要的展示了這種方法：

清單2.4 使用分離線程去處理其他文檔

```
void edit_document(std::string const& filename)
{
  open_document_and_display_gui(filename);
  while(!done_editing())
  {
    user_command cmd=get_user_input();
    if(cmd.type==open_new_document)
    {
      std::string const new_name=get_filename_from_user();
      std::thread t(edit_document,new_name);  // 1
      t.detach();  // 2
    }
    else
    {
       process_user_input(cmd);
    }
  }
}
```

如果用戶選擇打開一個新文檔，需要啟動一個新線程去打開新文檔①，並分離線程②。與當前線程做出的操作一樣，新線程只不過是打開另一個文件而已。所以，edit\_document函數可以複用，通過傳參的形式打開新的文件。

這個例子也展示了傳參啟動線程的方法：不僅可以向`std::thread`構造函數①傳遞函數名，還可以傳遞函數所需的參數\(實參\)。C++線程庫的方式也不是很複雜。當然，也有其他方法完成這項功能，比如:使用一個帶有數據成員的成員函數，代替一個需要傳參的普通函數。

