# A.8 線程本地變量

線程本地變量允許程序中的每個線程都有一個獨立的實例拷貝。可以使用`thread_local`關鍵字來對這樣的變量進行聲明。命名空間內的變量，靜態成員變量，以及本地變量都可以聲明成線程本地變量，為了在線程運行前對這些數據進行存儲操作：

```
thread_local int x;  // 命名空間內的線程本地變量

class X
{
  static thread_local std::string s;  // 線程本地的靜態成員變量
};
static thread_local std::string X::s;  // 這裡需要添加X::s

void foo()
{
  thread_local std::vector<int> v;  // 一般線程本地變量
}
```

由命名空間或靜態數據成員構成的線程本地變量，需要在線程單元對其進行使用**前**進行構建。有些實現中，會將對線程本地變量的初始化過程，放在線程中去做；還有一些可能會在其他時間點做初始化，在一些有依賴的組合中，根據具體情況來進行決定。將沒有構造好的線程本地變量傳遞給線程單元使用，不能保證它們會在線程中進行構造。這樣就可以動態加載帶有線程本地變量的模塊——變量首先需要在一個給定的線程中進行構造，之後其他線程就可以通過動態加載模塊對線程本地變量進行引用。

函數中聲明的線程本地變量，需要使用一個給定線程進行初始化(通過第一波控制流將這些聲明傳遞給指定線程)。如果函數沒有被指定線程調用，那麼這個函數中聲明的線程本地變量就不會構造。本地靜態變量也是同樣的情況，除非其單獨的應用於每一個線程。

靜態變量與線程本地變量會共享一些屬性——它們可以做進一步的初始化(比如，動態初始化)；如果在構造線程本地變量時拋出異常，`srd::terminate()`就會將程序終止。

析構函數會在構造線程本地變量的那個線程返回時調用，析構順序是構造的逆順序。當初始化順序沒有指定時，確定析構函數和這些變量是否有相互依存關係就尤為重要了。當線程本地變量的析構函數拋出異常時，`std::terminate()`會被調用，將程序終止。

當線程調用`std::exit()`或從main()函數返回(等價於調用`std::exit()`作為main()的“返回值”)時，線程本地變量也會為了這個線程進行銷燬。應用退出時還有線程在運行，對於這些線程來說，線程本地變量的析構函數就沒有被調用。

雖然，線程本地變量在不同線程上有不同的地址，不過還是可以獲取指向這些變量的一般指針。指針會在線程中，通過獲取地址的方式，引用相應的對象。當引用被銷燬的對象時，會出現未定義行為，所以在向其他線程傳遞線程本地變量指針時，就需要保證指向對象所在的線程結束後，不能對相應的指針進行解引用。