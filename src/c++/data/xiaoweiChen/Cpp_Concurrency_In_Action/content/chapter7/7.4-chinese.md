# 7.4 本章總結

從第6章中的基於鎖的數據結構起，本章簡要的描述了一些無鎖數據結構的實現(通過實現棧和隊列)。在這個過程中，需要小心使用原子操作的內存序，為了保證無數據競爭，以及讓每個線程看到一個預製相關的數據結構。也能瞭解到，在無鎖結構中對內存的管理是越來越難。還有，如何通過幫助線程的方式，來避免忙等待循環。

設計無鎖數據結構是一項很困難的任務，並且很容易犯錯；不過，這樣的數據結構在某些重要情況下可對其性能進行擴展。但願，通過本章的的一些例子，以及一些指導意見，可以幫助你設計出自己的無鎖數據結構，或是實現一份研究報告中的數據結構，或用以發現離職同事代碼中的bug。

不管在線程間共享怎麼樣的數據，你需要考慮數據結構如何使用，並且怎麼樣在線程間同步數據。通過設計併發訪問的數據結構，就能對數據結構的功能進行封裝，其他部分的代碼就著重於對數據的執行，而非數據的同步。你將會在第8章中看到類似的行為：將併發數據結構轉為一般的併發代碼。並行算法是使用多線程的方式提高性能，因為算法需要工作線程共享它們的數據，所以對併發數據結構的選擇就很關鍵了。