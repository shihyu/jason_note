# 7.2 無鎖數據結構的例子

為了演示一些在設計無鎖數據結構中所使用到的技術，我們將看到一些無鎖實現的簡單數據結構。這裡不僅要在每個例子中描述一個有用的數據結構實現，還將使用這些例子的某些特別之處來闡述對於無鎖數據結構的設計。

如之前所提到的，無鎖結構依賴與原子操作和內存序及相關保證，以確保多線程以正確的順序訪問數據結構。最初，所有原子操作默認使用的是memory_order_seq_cst內存序；因為簡單，所以使用(所有memory_order_seq_cst都遵循一種順序)。不過，在後面的例子中，我們將會降低內存序的要求，使用memory_order_acquire, memory_order_release, 甚至memory_order_relaxed。雖然這個例子中沒有直接的使用鎖，但需要注意的是對`std::atomic_flag`的使用。一些平臺上的無鎖結構實現(實際上在C++的標準庫的實現中)，使用了內部鎖(詳見第5章)。另一些平臺上，基於鎖的簡單數據結構可能會更適合;當然，還有很多平臺不能一一說明；在選擇一種實現前，需要明確需求，並且配置各種選項以滿足要求。

那麼，回到數據結構上來吧，最簡單的數據結構——棧。

## 7.2.1 寫一個無鎖的線程安全棧

棧的要求很簡單：查詢順序是添加順序的逆序——先入後出(LIFO)。所以，要確保一個值安全的添加入棧就十分重要，因為很可能在添加後，馬上被其他線程索引，同時確保只有一個線程能索引到給定值也是很重要。最簡單的棧就是鏈表，head指針指向第一個節點(可能是下一個被索引到的節點)，並且每個節點依次指向下一個節點。

在這樣的情況下，添加一個節點相對來說很簡單：

1. 創建一個新節點。
2. 將當新節點的next指針指向當前的head節點。
3. 讓head節點指向新節點。

在單線程的上下文中，這種方式沒有問題，不過當多線程對棧進行修改時，這幾步就不夠用了。至關重要的是，當有兩個線程同時添加節點的時候，在第2步和第3步的時候會產生條件競爭：一個線程可能在修改head的值時，另一個線程正在執行第2步，並且在第3步中對head進行更新。這就會使之前那個線程的工作被丟棄，亦或是造成更加糟糕的後果。在瞭解如何解決這個條件競爭之前，還要注意一個很重要的事：當head更新，並指向了新節點時，另一個線程就能讀取到這個節點了。因此，在head設置為指向新節點前，讓新節點完全準備就緒就變得很重要了；因為，在這之後就不能對節點進行修改了。

OK，那如何應對討厭的條件競爭呢？答案就是：在第3步的時候使用一個原子“比較/交換”操作，來保證當步驟2對head進行讀取時，不會對head進行修改。當有修改時，可以循環“比較/交換”操作。下面的代碼就展示了，不用鎖來實現線程安全的push()函數。

清單7.2 不用鎖實現push()

```
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    T data;
    node* next;

    node(T const& data_):  // 1
     data(data_)
    {}
  };

  std::atomic<node*> head;
public:
  void push(T const& data)
  {
    node* const new_node=new node(data); // 2
    new_node->next=head.load();  // 3
    while(!head.compare_exchange_weak(new_node->next,new_node));  // 4
  }
};
```

上面代碼近乎能匹配之前所說的三個步驟：創建一個新節點②，設置新節點的next指針指向當前head③，並設置head指針指向新節點④。node結構用其自身的構造函數來進行數據填充①，必須保證節點在構造完成後隨時能被彈出。之後需要使用compare_exchange_weak()來保證在被存儲到new_node->next的head指針和之前的一樣③。代碼的亮點是使用“比較/交換”操作：當其返回false時，因為比較失敗(例如，head被其他線程鎖修改)，會使用head中的內容更新new_node->next(第一個參數)的內容。循環中不需要每次都重新加載head指針，因為編譯器會幫你完成這件事。同樣，因為循環可能直接就失敗了，所以這裡使用compare_exchange_weak要好於使用compare_exchange_strong(詳見第5章)。

所以，這裡暫時不需要pop()操作，可以先快速檢查一下push()的實現是否有違指導意見。這裡唯一一個能拋出異常的地方就構造新node的時候①，不過其會自行處理，且鏈表中的內容沒有被修改，所以這裡是安全的。因為在構建數據的時候，是將其作為node的一部分作為存儲的，並且使用compare_exchange_weak()來更新head指針，所以這裡沒有惡性的條件競爭。“比較/交換”成功時，節點已經準備就緒，且隨時可以提取。因為這裡沒有鎖，所以就不存在死鎖的情況，這裡的push()函數實現的很成功。

那麼，你現在已經有往棧中添加數據的方法了，現在需要刪除數據的方法。其步驟如下，也很簡單：

1. 讀取當前head指針的值。
2. 讀取head->next。
3. 設置head到head->next。
4. 通過索引node，返回data數據。
5. 刪除索引節點。

但在多線程環境下，就不像看起來那麼簡單了。當有兩個線程要從棧中移除數據，兩個線程可能在步驟1中讀取到同一個head(值相同)。當其中一個線程處理到步驟5，而另一個線程還在處理步驟2時，這個還在處理步驟2的線程將會解引用一個懸空指針。這只是寫無鎖代碼所遇到的最大問題之一，所以現在只能跳過步驟5，讓節點洩露。

另一個問題就是：當兩個線程讀取到同一個head值，他們將返回同一個節點。這就違反了棧結構的意圖，所以你需要避免這樣的問題產生。你可以像在push()函數中解決條件競爭那樣來解決這個問題：使用“比較/交換”操作更新head。當“比較/交換”操作失敗時，不是一個新節點已被推入，就是其他線程已經彈出了想要彈出的節點。無論是那種情況，都得返回步驟1(“比較/交換”操作將會重新讀取head)。

當“比較/交換”成功，就可以確定當前線程是彈出給定節點的唯一線程，之後就可以放心的執行步驟4了。這裡先看一下pop()的雛形：

```
template<typename T>
class lock_free_stack
{
public:
  void pop(T& result)
  {
    node* old_head=head.load();
    while(!head.compare_exchange_weak(old_head,old_head->next));
    result=old_head->data;
  }
};
```

雖然這段代碼很優雅，但這裡還有兩個節點洩露的問題。首先，這段代碼在空鏈表的時候不工作：當head指針式一個空指針時，當要訪問next指針時，將引起未定義行為。這很容易通過對nullptr的檢查進行修復(在while循環中)，要不對空棧拋出一個異常，要不返回一個bool值來表明成功與否。

第二個問題就是異常安全問題。當在第3章中介紹棧結構時，瞭解了在返回值的時候會出現異常安全問題：當有異常被拋出時，複製的值將丟失。在這種情況下，傳入引用是一種可以接受的解決方案；因為這樣就能保證，當有異常拋出時，棧上的數據不會丟失。不幸的是，不能這樣做；只能在單一線程對值進行返回的時候，才進行拷貝，以確保拷貝操作的安全性，這就意味著在拷貝結束後這個節點就被刪除了。因此，通過引用獲取返回值的方式就沒有任何優勢：直接返回也是可以的。若想要安全的返回值，你必須使用第3章中的其他方法：返回指向數據值的(智能)指針。

當返回的是智能指針時，就能返回nullptr以表明沒有值可返回，但是要求在堆上對智能指針進行內存分配。將分配過程做為pop()的一部分時(也沒有更好的選擇了)，堆分配時可能會拋出一個異常。與此相反，可以在push()操作中對內存進行分配——無論怎樣，都得對node進行內存分配。返回一個`std::shared_ptr<>`不會拋出異常，所以在pop()中進行分配就是安全的。將上面的觀點放在一起，就能看到如下的代碼。

清單7.3 帶有節點洩露的無鎖棧

```
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    std::shared_ptr<T> data;  // 1 指針獲取數據
    node* next;

    node(T const& data_):
      data(std::make_shared<T>(data_))  // 2 讓std::shared_ptr指向新分配出來的T
    {}
  };

  std::atomic<node*> head;
public:
  void push(T const& data)
  {
    node* const new_node=new node(data);
    new_node->next=head.load();
    while(!head.compare_exchange_weak(new_node->next,new_node));
  }
  std::shared_ptr<T> pop()
  {
    node* old_head=head.load();
    while(old_head && // 3 在解引用前檢查old_head是否為空指針
      !head.compare_exchange_weak(old_head,old_head->next));
    return old_head ? old_head->data : std::shared_ptr<T>();  // 4
  }
};
```

智能指針指向當前數據①，這裡必須在堆上為數據分配內存(在node結構體中)②。而後，在compare_exchage_weak()循環中③，需要在old_head指針前，檢查指針是否為空。最終，如果存在相關節點，那麼將會返回相關節點的值；當不存在時，將返回一個空指針④。注意，結構是無鎖的，但並不是無等待的，因為在push()和pop()函數中都有while循環，當compare_exchange_weak()總是失敗的時候，循環將會無限循環下去。

## 7.2.2 停止內存洩露：使用無鎖數據結構管理內存

第一次瞭解pop()時，為了避免條件競爭(當有線程刪除一個節點的同時，其他線程還持有指向該節點的指針，並且要解引用)選擇了帶有內存洩露的節點。但是，不論什麼樣的`C++`程序，存在內存洩露都不可接受。所以，現在來解決這個問題！

基本問題在於，當要釋放一個節點時，需要確認其他線程沒有持有這個節點。當只有一個線程調用pop()，就可以放心的進行釋放。當節點添加入棧後，push()就不會與節點有任何的關係了，所以只有調用pop()函數的線程與已加入節點有關，並且能夠安全的將節點刪除。

另一方面，當棧同時處理多線程對pop()的調用時，就需要知道節點在什麼時候被刪除。這實際上就需要你寫一個節點專用的垃圾收集器。這聽起來有些可怖，同時也相當棘手，不過並不是多麼糟糕：這裡需要檢查節點，並且檢查哪些節點被pop()訪問。不需要對push()中的節點有所擔心，因為這些節點推到棧上以後，才能被訪問到，而多線程只能通過pop()訪問同一節點。

當沒有線程調用pop()時，這時可以刪除棧上的任意節點。因此，當添加節點到“可刪除”列表中時，就能從中提取數據了。而後，當沒有線程通過pop()訪問節點時，就可以安全的刪除這些節點了。那怎麼知道沒有線程調用pop()了呢？很簡單——計數即可。當計數器數值增加時，就是有節點推入；當減少時，就是有節點被刪除。這樣從“可刪除”列表中刪除節點就很安全了，直到計數器的值為0為止。當然，這個計數器必須是原子的，這樣它才能在多線程的情況下正確的進行計數。下面的清單中，展示了修改後的pop()函數，有些支持功能的實現將在清單7.5中給出。

清單7.4 沒有線程通過pop()訪問節點時，就對節點進行回收

```
template<typename T>
class lock_free_stack
{
private:
  std::atomic<unsigned> threads_in_pop;  // 1 原子變量
  void try_reclaim(node* old_head);
public:
  std::shared_ptr<T> pop()
  {
    ++threads_in_pop;  // 2 在做事之前，計數值加1
    node* old_head=head.load();
    while(old_head &&
      !head.compare_exchange_weak(old_head,old_head->next));
    std::shared_ptr<T> res;
    if(old_head)
    { 
      res.swap(old_head->data);  // 3 回收刪除的節點
    }
    try_reclaim(old_head);  // 4 從節點中直接提取數據，而非拷貝指針
    return res;
  }
};
```

threads_in_pop①原子變量用來記錄有多少線程試圖彈出棧中的元素。當pop()②函數調用的時候，計數器加一；當調用try_reclaim()時，計數器減一，當這個函數被節點調用時，說明這個節點已經被刪除④。因為暫時不需要將節點刪除，可以通過swap()函數來刪除節點上的數據③(而非只是拷貝指針)，當不再需要這些數據的時候，這些數據會自動刪除，而不是持續存在著(因為這裡還有對未刪除節點的引用)。接下來看一下try_reclaim()是如何實現的。

清單7.5 採用引用計數的回收機制

```
template<typename T>
class lock_free_stack
{
private:
  std::atomic<node*> to_be_deleted;

  static void delete_nodes(node* nodes)
  {
    while(nodes)
    {
      node* next=nodes->next;
      delete nodes;
      nodes=next;
    }
  }
  void try_reclaim(node* old_head)
  {
    if(threads_in_pop==1)  // 1
    {
      node* nodes_to_delete=to_be_deleted.exchange(nullptr);  // 2 聲明“可刪除”列表
      if(!--threads_in_pop)  // 3 是否只有一個線程調用pop()？
      {
        delete_nodes(nodes_to_delete);  // 4
      }
      else if(nodes_to_delete)  // 5
      {
         chain_pending_nodes(nodes_to_delete);  // 6
      }
      delete old_head;  // 7
    }
    else
    {
      chain_pending_node(old_head);  // 8
      --threads_in_pop;
    }
  }
  void chain_pending_nodes(node* nodes)
  {
    node* last=nodes;
    while(node* const next=last->next)  // 9 讓next指針指向鏈表的末尾
    {
      last=next;
    }
    chain_pending_nodes(nodes,last);
  }

  void chain_pending_nodes(node* first,node* last)
  {
    last->next=to_be_deleted;  // 10
    while(!to_be_deleted.compare_exchange_weak(  // 11 用循環來保證last->next的正確性
      last->next,first));
    }
    void chain_pending_node(node* n)
    {
      chain_pending_nodes(n,n);  // 12
    }
};
```

回收節點時①，threads_in_pop的數值是1，也就是當前線程正在對pop()進行訪問，這時就可以安全的將節點進行刪除了⑦(將等待節點刪除也是安全的)。當數值不是1時，刪除任何節點都不安全，所以需要向等待列表中繼續添加節點⑧。

假設在某一時刻，threads_in_pop的值為1。那就可以嘗試回收等待列表，如果不回收，節點就會繼續等待，直到整個棧被銷燬。要做到回收，首先要通過一個原子exchange操作聲明②刪除列表，並將計數器減一③。如果之後計數的值為0，就意味著沒有其他線程訪問等待節點鏈表。出現新的等待節點時，不必為其煩惱，因為它們將被安全的回收。而後，可以使用delete_nodes對鏈表進行迭代，並將其刪除④。

當計數值在減後不為0，回收節點就不安全；所以如果存在⑤，就需要將其掛在等待刪除鏈表之後⑥，這種情況會發生在多個線程同時訪問數據結構的時候。一些線程在第一次測試threads_in_pop①和對“回收”鏈表的聲明②操作間調用pop()，這可能新填入一個已經被線程訪問的節點到鏈表中。在圖7.1中，線程C添加節點Y到to_be_deleted鏈表中，即使線程B仍將其引用作為old_head，之後會嘗試訪問其next指針。在線程A刪除節點的時候，會造成線程B發生未定義的行為。

![](../../images/chapter7/7-1.png)

圖7.1 三個線程同時調用pop()，說明為什麼要在try_reclaim()對聲明節點進行刪除前，對threads_in_pop進行檢查。

為了將等待刪除的節點添加入等待刪除鏈表，需要複用節點的next指針將等待刪除節點鏈接在一起。在這種情況下，將已存在的鏈表鏈接到刪除鏈表後面，通過遍歷的方式找到鏈表的末尾⑨，將最後一個節點的next指針替換為當前to_be_deleted指針⑩，並且將鏈表中的第一個節點作為新的to_be_deleted指針進行存儲⑪。這裡需要在循環中使用compare_exchange_weak來保證，通過其他線程添加進來的節點不會發生內存洩露。這樣，在鏈表發生改變時，更新next指針很方便。添加單個節點是一種特殊情況，因為這需要將這個節點作為第一個節點，同時也是最後一個節點進行添加⑫。

在低負荷的情況下，這種方式沒有問題，因為在沒有線程訪問pop()，有一個合適的靜態指針。不過，這只是一個瞬時的狀態，也就是為什麼在回收前，需要檢查threads_in_pop計數為0③的原因；同樣也是刪除節點⑦前進行對計數器檢查的原因。刪除節點是一項耗時的工作，並且希望其他線程能對鏈表做的修改越小越好。從第一次發現threads_in_pop是1，到嘗試刪除節點，會用很長的時間，這樣就會讓線程有機會調用pop()，會讓threads_in_pop不為0，阻止節點的刪除操作。

在高負荷的情況，不會存在靜態；因為，其他線程在初始化之後，都能進入pop()。在這樣的情況下，to_ne_deleted鏈表將會無界的增加，並且會再次洩露。當這裡不存在任何靜態的情況時，就得為回收節點尋找替代機制。關鍵是要確定沒有線程訪問一個給定節點，那麼這個節點就能被回收。現在，最簡單的替換機制就是使用*風險指針*(hazard pointer)。

## 7.2.3 檢測使用風險指針(不可回收)的節點

“風險指針”這個術語引用於Maged Michael的技術發現[1]。之所以這樣叫，是因為刪除一個節點可能會讓其他引用其的線程處於危險之中。當其他線程持有這個刪除的節點的指針，並且解引用進行操作的時候，將會出現未定義行為。這裡的基本觀點就是，當有線程去訪問要被(其他線程)刪除的對象時，會先設置對這個對象設置一個風險指針，而後通知其他線程，刪除這個指針是一個危險的行為。一旦這個對象不再被需要，那麼就可以清除風險指針了。如果瞭解牛津/劍橋的龍舟比賽，那麼這裡使用到的機制和龍舟比賽開賽時差不多：每個船上的舵手都舉起手來，以表示他們還沒有準備好。只要有舵手的手是舉著的，那麼裁判就不能讓比賽開始。當所有舵手的手都放下後，比賽才能開始；在比賽還未開始或感覺自己船隊的情況有變時，舵手可以再次舉手。

當線程想要刪除一個對象，那麼它就必須檢查系統中其他線程是否持有風險指針。當沒有風險指針的時候，那麼它就可以安全刪除對象。否則，它就必須等待風險指針的消失了。這樣，線程就得週期性的檢查其想要刪除的對象是否能安全刪除。

看起來很簡單，在`C++`中應該怎麼做呢？

首先，需要一個地點能存儲指向訪問對象的指針，這個地點就是風險指針。這個地點必須能讓所有線程看到，需要其中一些線程可以對數據結構進行訪問。如何正確和高效的分配這些線程，的確是一個挑戰，所以這個問題可以放在後面解決，而後假設你有一個get_hazard_pointer_for_current_thread()的函數，這個函數可以返回風險指針的引用。當你讀取一個指針，並且想要解引用它的時候，你就需要這個函數——在這種情況下head數值源於下面的列表：

```
std::shared_ptr<T> pop()
{
  std::atomic<void*>& hp=get_hazard_pointer_for_current_thread();
  node* old_head=head.load();  // 1
  node* temp;
  do
  {
    temp=old_head;
    hp.store(old_head);  // 2
    old_head=head.load();
  } while(old_head!=temp); // 3
  // ...
}
```

在while循環中就能保證node不會在讀取舊head指針①時，以及在設置風險指針的時被刪除了。這種模式下，其他線程不知道有線程對這個給定的節點進行了訪問。幸運的是，當舊head節點要被刪除時，head本身是要改變的，所以需要對head進行檢查，並持續循環，直到head指針中的值與風險指針中的值相同③。使用風險指針，如同依賴對已刪除對象的引用。當使用默認的new和delete操作對風險指針進行操作時，會出現未定義行為，所以需要確定實現是否支持這樣的操作，或使用自定義分配器來保證這種用法的正確性。

現在已經設置了風險指針，那就可以對pop()進行處理了，基於現在瞭解到的安全知識，這裡不會有其他線程來刪除節點。啊哈！這裡每一次重新加載old_head時，解引用剛剛讀取到的指針時，就需要更新風險指針。當從鏈表中提取一個節點時，就可以將風險指針清除了。如果沒有其他風險指針引用節點，就可以安全的刪除節點了；否則，就需要將其添加到鏈表中，之後再將其刪除。下面的代碼就是對該方案的完整實現。

清單7.6 使用風險指針實現的pop()

```
std::shared_ptr<T> pop()
{
  std::atomic<void*>& hp=get_hazard_pointer_for_current_thread();
  node* old_head=head.load();
  do
  {
    node* temp;
    do  // 1 直到將風險指針設為head指針
    {
      temp=old_head;
      hp.store(old_head);
      old_head=head.load();
    } while(old_head!=temp);
  }
  while(old_head &&
    !head.compare_exchange_strong(old_head,old_head->next));
  hp.store(nullptr);  // 2 當聲明完成，清除風險指針
  std::shared_ptr<T> res;
  if(old_head)
  {
    res.swap(old_head->data);
    if(outstanding_hazard_pointers_for(old_head))  // 3 在刪除之前對風險指針引用的節點進行檢查
    {
      reclaim_later(old_head);  // 4
    }
    else
    {
      delete old_head;  // 5
    }
    delete_nodes_with_no_hazards();  // 6
  }
  return res;
}
```

首先，循環內部會對風險指針進行設置，在當“比較/交換”操作失敗會重載old_head，再次進行設置①。使用compare_exchange_strong()，是因為需要在循環內部做一些實際的工作：當compare_exchange_weak()偽失敗後，風險指針將被重置(沒有必要)。這個過程能保證風險指針在解引用(old_head)之前，能被正確的設置。當已聲明瞭一個風險指針，那麼就可以將其清除了②。如果想要獲取一個節點，就需要檢查其他線程上的風險指針，檢查是否有其他指針引用該節點③。如果有，就不能刪除節點，只能將其放在鏈表中，之後再進行回收④；如果沒有，就能直接將這個節點刪除了⑤。最後，如果需要對任意節點進行檢查，可以調用reclaim_later()。如果鏈表上沒有任何風險指針引用節點，就可以安全的刪除這些節點⑥。當有節點持有風險指針，就只能讓下一個調用pop()的線程離開。

當然，這些函數——get_hazard_pointer_for_current_thread(), reclaim_later(), outstanding_hazard_pointers_for(), 和delete_nodes_with_no_hazards()——的實現細節我們還沒有看到，先來看看它們是如何工作的。

為線程分配風險指針實例的具體方案：使用get_hazard_pointer_for_current_thread()與程序邏輯的關係並不大(不過會影響效率，接下會看到具體的情況)。可以使用一個簡單的結構體：固定長度的“線程ID-指針”數組。get_hazard_pointer_for_curent_thread()就可以通過這個數據來找到第一個釋放槽，並將當前線程的ID放入到這個槽中。當線程退出時，槽就再次置空，可以通過默認構造`std::thread::id()`將線程ID放入槽中。這個實現就如下所示：

清單7.7 get_hazard_pointer_for_current_thread()函數的簡單實現

```
unsigned const max_hazard_pointers=100;
struct hazard_pointer
{
  std::atomic<std::thread::id> id;
  std::atomic<void*> pointer;
};
hazard_pointer hazard_pointers[max_hazard_pointers];

class hp_owner
{
  hazard_pointer* hp;

public:
  hp_owner(hp_owner const&)=delete;
  hp_owner operator=(hp_owner const&)=delete;
  hp_owner():
    hp(nullptr)
  {
    for(unsigned i=0;i<max_hazard_pointers;++i)
    {
      std::thread::id old_id;
      if(hazard_pointers[i].id.compare_exchange_strong(  // 6 嘗試聲明風險指針的所有權
         old_id,std::this_thread::get_id()))
      {
        hp=&hazard_pointers[i];
        break;  // 7
      }
    }
    if(!hp)  // 1
    {
      throw std::runtime_error("No hazard pointers available");
    }
  }

  std::atomic<void*>& get_pointer()
  {
    return hp->pointer;
  }

  ~hp_owner()  // 2
  {
    hp->pointer.store(nullptr);  // 8
    hp->id.store(std::thread::id());  // 9
  }
};

std::atomic<void*>& get_hazard_pointer_for_current_thread()  // 3
{
  thread_local static hp_owner hazard;  // 4 每個線程都有自己的風險指針
  return hazard.get_pointer();  // 5
}
```

get_hazard_pointer_for_current_thread()的實現看起來很簡單③：一個hp_owner④類型的thread_local(本線程所有)變量，用來存儲當前線程的風險指針，可以返回這個變量所持有的指針⑤。之後的工作：第一次有線程調用這個函數時，新hp_owner實例就被創建。這個實例的構造函數⑥，會通過查詢“所有者/指針”表，尋找沒有所有者的記錄。其用compare_exchange_strong()來檢查某個記錄是否有所有者，並進行析構②。當compare_exchange_strong()失敗，其他線程的擁有這個記錄，所以可以繼續執行下去。當交換成功，當前線程就擁有了這條記錄，而後對其進行存儲，並停止搜索⑦。當遍歷了列表也沒有找到物所有權的記錄①，就說明有很多線程在使用風險指針，所以這裡將拋出一個異常。

一旦hp_owner實例被一個給定的線程所創建，那麼之後的訪問將會很快，因為指針在緩存中，所以表不需要再次遍歷。

當線程退出時，hp_owner的實例將會被銷燬。析構函數會在`std::thread::id()`設置擁有者ID前，將指針重置為nullptr,這樣就允許其他線程對這條記錄進行復用⑧⑨。

實現get_hazard_pointer_for_current_thread()後，outstanding_hazard_pointer_for()實現就簡單了：只需要對風險指針表進行搜索，就可以找到對應記錄。

```
bool outstanding_hazard_pointers_for(void* p)
{
  for(unsigned i=0;i<max_hazard_pointers;++i)
  {
    if(hazard_pointers[i].pointer.load()==p)
    {
      return true;
    }
  }
  return false;
}
```

實現都不需要對記錄的所有者進行驗證：沒有所有者的記錄會是一個空指針，所以比較代碼將總返回false，通過這種方式將代碼簡化。

reclaim_later()和delete_nodes_with_no_hazards()可以對簡單的鏈表進行操作；reclaim_later()只是將節點添加到列表中，delete_nodes_with_no_hazards()就是搜索整個列表，並將無風險指針的記錄進行刪除。下面將展示它們的具體實現。

清單7.8 回收函數的簡單實現

```
template<typename T>
void do_delete(void* p)
{
  delete static_cast<T*>(p);
}

struct data_to_reclaim
{
  void* data;
  std::function<void(void*)> deleter;
  data_to_reclaim* next;

  template<typename T>
  data_to_reclaim(T* p):  // 1
    data(p),
    deleter(&do_delete<T>),
    next(0)
  {}

  ~data_to_reclaim()
  {
    deleter(data);  // 2
  }
};

std::atomic<data_to_reclaim*> nodes_to_reclaim;

void add_to_reclaim_list(data_to_reclaim* node)  // 3
{
  node->next=nodes_to_reclaim.load();
  while(!nodes_to_reclaim.compare_exchange_weak(node->next,node));
}

template<typename T>
void reclaim_later(T* data)  // 4
{
  add_to_reclaim_list(new data_to_reclaim(data));  // 5
}

void delete_nodes_with_no_hazards()
{
  data_to_reclaim* current=nodes_to_reclaim.exchange(nullptr);  // 6
  while(current)
  {
    data_to_reclaim* const next=current->next;
    if(!outstanding_hazard_pointers_for(current->data))  // 7
    {
      delete current;  // 8
    }
    else
    {
      add_to_reclaim_list(current);  // 9
    }
    current=next;
  }
}
```

首先，reclaim_later()是一個函數模板④。因為風險指針是一個通用解決方案，所以這裡就不能將棧節點的類型寫死。使用`std::atomic<void*>`對風險指針進行存儲。需要對任意類型的指針進行處理，不過不能使用`void*`形式，因為當要刪除數據項時，delete操作只能對實際類型指針進行操作。data_to_reclaim的構造函數處理的就很優雅：reclaim_later()只是為指針創建一個data_to_reclaim的實例，並且將實例添加到回收鏈表中⑤。add_to_reclaim_list()③就是使用compare_exchange_weak()循環來訪問鏈表頭(就如你之前看到的那樣)。

當將節點添加入鏈表時，data_to_reclaim的析構函數不會被調用；析構函數會在沒有風險指針指向節點的時候調用，這也就是delete_nodes_with_no_hazards()的作用。

delete_nodes_with_no_hazards()將已聲明的鏈表節點進行回收，使用的是exchange()函數⑥(這個步驟簡單且關鍵，是為了保證只有一個線程回收這些節點)。這樣，其他線程就能自由將節點添加到鏈表中，或在不影響回收指定節點線程的情況下，對節點進行回收。

只要有節點存在於鏈表中，就需要檢查每個節點，查看節點是否被風險指針所指向⑦。如果沒有風險指針，那麼就可以安全的將記錄刪除(並且清除存儲的數據)⑧。否則，就只能將這個節點添加到鏈表的後面，再進行回收⑨。

雖然這個實現很簡單，也的確安全的回收了被刪除的節點，不過這個過程增加了很多開銷。遍歷風險指針數組需要檢查max_hazard_pointers原子變量，並且每次pop()調用時，都需要再檢查一遍。原子操作很耗時——在臺式CPU上，100次原子操作要比100次非原子操作慢——所以，這裡pop()成為了性能瓶頸。這種方式，不僅需要遍歷節點的風險指針鏈表，還要遍歷等待鏈表上的每一個節點。顯然，這種方式很糟糕。當有max_hazard_pointers在鏈表中，那麼就需要檢查max_hazard_pointers多個已存儲的風險指針。我去！還有更好一點的方法嗎？

**對風險指針(較好)的回收策略**

當然有更好的辦法。這裡只展示一個風險指針的簡單實現，來幫助解釋技術問題。首先，要考慮的是內存性能。比起對回收鏈表上的每個節點進行檢查都要調用pop()，除非有超過max_hazard_pointer數量的節點存在於鏈表之上，要不就不需要嘗試回收任何節點。這樣就能保證至少有一個節點能夠回收，如果只是等待鏈表中的節點數量達到max_hazard_pointers+1，那比之前的方案也沒好到哪裡去。當獲取了max_hazard_pointers數量的節點時，可以調用pop()對節點進行回收，所以這樣也不是很好。不過，當有2max_hazard_pointers個節點在列表中時，就能保證至少有max_hazard_pointers可以被回收，在再次嘗試回收任意節點前，至少會對pop()有max_hazard_pointers次調用。這就很不錯了。比起檢查max_hazard_pointers個節點就調用max_hazard_pointers次pop()(而且還不一定能回收節點)，當檢查2max_hazard_pointers個節點時，每max_hazard_pointers次對pop()的調用，就會有max_hazard_pointers個節點能被回收。這就意味著，對兩個節點檢查調用pop()，其中就有一個節點能被回收。

這個方法有個缺點(有增加內存使用的情況)：就是得對回收鏈表上的節點進行計數，這就意味著要使用原子變量，並且還有很多線程爭相對回收鏈表進行訪問。如果還有多餘的內存，可以增加內存的使用來實現更好的回收策略：每個線程中的都擁有其自己的回收鏈表，作為線程的本地變量。這樣就不需要原子變量進行計數了。這樣的話，就需要分配max_hazard_pointers x max_hazard_pointers個節點。所有節點被回收完畢前時，有線程退出，那麼其本地鏈表可以像之前一樣保存在全局中，並且添加到下一個線程的回收鏈表中，讓下一個線程對這些節點進行回收。

風險指針另一個缺點：與IBM申請的專利所衝突[2]。要讓寫的軟件在一個國家中使用，那麼就必須擁有合法的知識產權，所以需要擁有合適的許可證。這對所有無鎖的內存回收技術都適用(這是一個活躍的研究領域)，所以很多大公司都會有自己的專利。你可能會問，“為什麼用了這麼大的篇幅來介紹一個大多數人都沒辦法的技術呢？”，這公平性的問題。首先，使用這種技術可能不需要買一個許可證。比如，當你使用GPL下的免費軟件許可來進行軟件開發，那麼你的軟件將會包含到IBM不主張聲明中。其次，也是很重要的，在設計無鎖代碼的時候，還需要從使用的技術角度進行思考，比如，高消耗的原子操作。

所以，是否有非專利的內存回收技術，且能被大多數人所使用呢？很幸運，的確有。引用計數就是這樣一種機制。

## 7.2.4 檢測使用引用計數的節點

回到7.2.2節的問題，“想要刪除節點還能被其他讀者線程訪問，應該怎麼辦?"。當能安全並精確的識別，節點是否還被引用，以及沒有線程訪問這些節點的具體時間，以便將對應節點進行刪除。風險指針是通過將使用中的節點存放到鏈表中，解決問題。而引用計數是通過對每個節點上訪問的線程數量進行統計，解決問題。

看起來簡單粗暴……不，優雅；實際上管理起來卻是很困難：首先，你會想到的就是由`std::shared_ptr<>`來完成這個任務，其是有內置引用計數的指針。不幸的是，雖然`std::shared_ptr<>`上的一些操作是原子的，不過其也不能保證是無鎖的。智能指針上的原子操作和對其他原子類型的操作並沒有什麼不同，但是`std::shared_ptr<>`旨在用於有多個上下文的情況下，並且在無鎖結構中使用原子操作，無異於對該類增加了很多性能開銷。如果平臺支持`std::atomic_is_lock_free(&some_shared_ptr)`實現返回true，那麼所有內存回收問題就都迎刃而解了。使用`std::shared_ptr<node>`構成的鏈表實現，如下所示：

清單7.9 無鎖棧——使用無鎖`std::shared_ptr<>`的實現

```
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    std::shared_ptr<T> data;
    std::shared_ptr<node> next;
    node(T const& data_):
      data(std::make_shared<T>(data_))
    {}
  };

  std::shared_ptr<node> head;
public:
  void push(T const& data)
  {
    std::shared_ptr<node> const new_node=std::make_shared<node>(data);
    new_node->next=head.load();
    while(!std::atomic_compare_exchange_weak(&head,
        &new_node->next,new_node));
  }
  std::shared_ptr<T> pop()
  {
    std::shared_ptr<node> old_head=std::atomic_load(&head);
    while(old_head && !std::atomic_compare_exchange_weak(&head,
        &old_head,old_head->next));
    return old_head ? old_head->data : std::shared_ptr<T>();
  }
};
```

在一些情況下，使用`std::shared_ptr<>`實現的結構並非無鎖，這就需要手動管理引用計數。

一種方式是對每個節點使用兩個引用計數：內部計數和外部計數。兩個值的總和就是對這個節點的引用數。外部計數記錄有多少指針指向節點，即在指針每次進行讀取的時候，外部計數加一。當線程結束對節點的訪問時，內部計數減一。指針在讀取時，外部計數加一；在讀取結束時，內部計數減一。

當不需要“外部計數-指針”對時(該節點就不能被多線程所訪問了)，在外部計數減一和在被棄用的時候，內部計數將會增加。當內部計數等於0，那麼就沒有指針對該節點進行引用，就可以將該節點安全的刪除。使用原子操作來更新共享數據也很重要。現在，就讓我們來看一下使用這種技術實現的無鎖棧，只有確定節點能安全刪除的情況下，才能進行節點回收。

下面程序清單中就展示了內部數據結構，以及對push()簡單優雅的實現。

清單7.10 使用分離引用計數的方式推送一個節點到無鎖棧中

```
template<typename T>
class lock_free_stack
{
private:
  struct node;

  struct counted_node_ptr  // 1
  {
    int external_count;
    node* ptr;
  };

  struct node
  {
    std::shared_ptr<T> data;
    std::atomic<int> internal_count;  // 2
    counted_node_ptr next;  // 3

    node(T const& data_):
      data(std::make_shared<T>(data_)),
      internal_count(0)
    {}
  };

  std::atomic<counted_node_ptr> head;  // 4

public:
  ~lock_free_stack()
  {
    while(pop());
  }

  void push(T const& data)  // 5
  {
    counted_node_ptr new_node;
    new_node.ptr=new node(data);
    new_node.external_count=1;
    new_node.ptr->next=head.load();
    while(!head.compare_exchange_weak(new_node.ptr->next,new_node));
  }
};
```

外部計數包含在counted_node_ptr的指針中①，且這個結構體會被node中的next指針③和內部計數②用到。counted_node_ptr是一個簡單的結構體，所以可以使用特化`std::atomic<>`模板來對鏈表的頭指針進行聲明④。

且counted_node_ptr體積夠小，能夠讓`std::atomic<counted_node_ptr>`無鎖。在一些平臺上支持雙字比較和交換操作，可以直接對結構體進行操作。當你的平臺不支持這樣的操作時，最好使用`std::shared_ptr<>`變量(如清單7.9那樣)；當類型的體積過大，超出了平臺支持指令，那麼原子`std::atomic<>`將使用鎖來保證其操作的原子性(從而會讓你的“無鎖”算法“基於鎖”來完成)。另外，如果想要限制計數器的大小，需要已知平臺上指針所佔的空間(比如，地址空間只剩下48位，而一個指針就要佔64位)，可以將計數存在一個指針空間內，不過為了適應平臺，也可以存在一個機器字當中。這樣的技巧需要對特定系統有足夠的瞭解，當然已經超出本書討論的範圍。

push()相對簡單⑤，可以構造一個counted_node_ptr實例，去引用新分配出來的(帶有相關數據的)node，並且將node中的next指針設置為當前head。之後使用compare_exchange_weak()對head的值進行設置，就像之前代碼清單中所示。因為internal_count剛被設置，所以其值為0，並且external_count是1。因為這是一個新節點，那麼這個節點只有一個外部引用(head指針)。

通常，pop()都有一個從繁到簡的過程，實現代碼如下。

清單7.11 使用分離引用計數從無鎖棧中彈出一個節點

```
template<typename T>
class lock_free_stack
{
private:
  void increase_head_count(counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;

    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!head.compare_exchange_strong(old_counter,new_counter));  // 1

    old_counter.external_count=new_counter.external_count;
  }
public:
  std::shared_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load();
    for(;;)
    {
      increase_head_count(old_head);
      node* const ptr=old_head.ptr;  // 2
      if(!ptr)
      {
        return std::shared_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next))  // 3
      {
        std::shared_ptr<T> res;
        res.swap(ptr->data);  // 4

        int const count_increase=old_head.external_count-2;  // 5

        if(ptr->internal_count.fetch_add(count_increase)==  // 6
           -count_increase)
        {
          delete ptr;
        }

        return res;  // 7
      }
      else if(ptr->internal_count.fetch_sub(1)==1)
      {
        delete ptr;  // 8
      }
    }
  }
};
```

當加載head的值之後，就必須將外部引用加一，是為了表明這個節點正在引用，並且保證在解引用時的安全性。在引用計數增加前解引用指針，那麼就會有線程能夠訪問這個節點，從而當前引用指針就成為了一個懸空指針。這就是將引用計數分離的主要原因：通過增加外部引用計數，保證指針在訪問期間的合法性。在compare_exchange_strong()的循環中①完成增加，通過比較和設置整個結構體來保證指針不會在同一時間內被其他線程修改。

當計數增加，就能安全的解引用ptr，並讀取head指針的值，就能訪問指向的節點②。如果指針是空指針，那麼將會訪問到鏈表的最後。當指針不為空時，就能嘗試對head調用compare_exchange_strong()來刪除這個節點③。

當compare_exchange_strong()成功時，就擁有對應節點的所有權，並且可以和data進行交換④，然後返回。這樣數據就不會持續保存，因為其他線程也會對棧進行訪問，所以會有其他指針指向這個節點。而後，可以使用原子操作fetch_add⑥，將外部計數加到內部計數中去。如果現在引用計數為0，那麼之前的值(fetch_add返回的值)，在相加之前肯定是一個負數，這種情況下就可以將節點刪除。這裡需要注意的是，相加的值要比外部引用計數少2⑤;當節點已經從鏈表中刪除，就要減少一次計數，並且這個線程無法再次訪問指定節點，所以還要再減一。無論節點是否被刪除，都能完成操作，所以可以將獲取的數據進行返回⑦。

當“比較/交換”③失敗，就說明其他線程在之前把對應節點刪除了，或者其他線程添加了一個新的節點到棧中。無論是哪種原因，需要通過“比較/交換”的調用，對具有新值的head重新進行操作。不過，首先需要減少節點(要刪除的節點)上的引用計數。這個線程將再也沒有辦法訪問這個節點了。如果當前線程是最後一個持有引用(因為其他線程已經將這個節點從棧上刪除了)的線程，那麼內部引用計數將會為1，所以減一的操作將會讓計數器為0。這樣，你就能在循環⑧進行之前將對應節點刪除了。

目前，使用默認`std::memory_order_seq_cst`內存序來規定原子操作的執行順序。在大多數系統中，這種操作方式都很耗時，且同步操作的開銷要高於內存序。現在，就可以考慮對數據結構的邏輯進行修改，對數據結構的部分放寬內存序要求；就沒有必要在棧上增加過度的開銷了。現在讓我們來檢查一下棧的操作，並且捫心自問，這裡能對一些操作使用更加寬鬆的內存序麼？如果使用了，能確保同級安全嗎？

## 7.2.5 應用於無鎖棧上的內存模型

在修改內存序之前，需要檢查一下操作之間的依賴關係。而後，再去確定適合這種需求關係的最小內存序。為了保證這種方式能夠工作，需要在從線程的視角進行觀察。其中最簡單的視角就是，向棧中推入一個數據項，之後讓其他線程從棧中彈出這個數據。

即使在簡單的例子中，都需要三個重要的數據參與。1、counted_node_ptr轉移的數據head。2、head引用的node。3、節點所指向的數據項。

做push()的線程，會先構造數據項和節點，再設置head。做pop()的線程，會先加載head的值，再做在循環中對head做“比較/交換”操作，並增加引用計數，再讀取對應的node節點，獲取next的指向的值，現在就可以看到一組需求關係。next的值是普通的非原子對象，所以為了保證讀取安全，這裡必須確定存儲(推送線程)和加載(彈出線程)的先行關係。因為唯一的原子操作就是push()函數中的compare_exchange_weak()，這裡需要釋放操作來獲取兩個線程間的先行關係，這裡compare_exchange_weak()必須是`std::memory_order_release`或更嚴格的內存序。當compare_exchange_weak()調用失敗，什麼都不會改變，並且可以持續循環下去，所以使用`std::memory_order_relaxed`就足夠了。

```
void push(T const& data)
{
  counted_node_ptr new_node;
  new_node.ptr=new node(data);
  new_node.external_count=1;
  new_node.ptr->next=head.load(std::memory_order_relaxed)
  while(!head.compare_exchange_weak(new_node.ptr->next,new_node,
    std::memory_order_release,std::memory_order_relaxed));
}
```

那pop()的實現呢？為了確定先行關係，必須在訪問next值之前使用`std::memory_order_acquire`或更嚴格內存序的操作。因為，在increase_head_count()中使用compare_exchange_strong()就獲取next指針指向的舊值，所以想要其獲取成功就需要確定內存序。如同調用push()那樣，當交換失敗，循環會繼續，所以在失敗的時候使用鬆散的內存序：

```
void increase_head_count(counted_node_ptr& old_counter)
{
  counted_node_ptr new_counter;

  do
  {
    new_counter=old_counter;
    ++new_counter.external_count;
  }
  while(!head.compare_exchange_strong(old_counter,new_counter,
        std::memory_order_acquire,std::memory_order_relaxed));

  old_counter.external_count=new_counter.external_count;
}
```

當compare_exchange_strong()調用成功，那麼ptr中的值就被存到old_counter中。存儲操作是push()中的一個釋放操作，並且compare_exchange_strong()操作是一個獲取操作，現在存儲同步於加載，並且能夠獲取先行關係。因此，在push()中存儲ptr的值，要先行於在pop()中對ptr->next的訪問。現在的操作就安全了。

要注意的是，內存序對head.load()的初始化並不妨礙分析，所以現在就可以使用`std::memory_order_relaxed`。

接下來，compare_exchange_strong()將old_head.ptr->next設置為head。是否需要做什麼來保證操作線程中的數據完整性呢？當交換成功，你就能訪問ptr->data，所以這裡需要保證在push()線程中已經對ptr->data進行了存儲(在加載之前)。在increase_head_count()中的獲取操作，能保證與push()線程中的存儲和“比較/交換”同步。這裡的先行關係是：在push()線程中存儲數據，先行於存儲head指針；調用increase_head_count()先行於對ptr->data的加載。即使，pop()中的“比較/交換”操作使用`std::memory_order_relaxed`，這些操作還是能正常運行。唯一不同的地方就是，調用swap()讓ptr->data有所變化，且沒有其他線程可以對同一節點進行操作(這就是“比較/交換”操作的作用)。

當compare_exchange_strong()失敗，那麼新值就不會去更新old_head，繼續循環。這裡，已確定在increase_head_count()中使用`std::memory_order_acquire`內存序的可行性，所以這裡使用`std::memory_order_relaxed`也可以。

其他線程呢？是否需要設置一些更為嚴格的內存序來保證其他線程的安全呢？回答是“不用”。因為，head只會因“比較/交換”操作有所改變；對於“讀-改-寫”操作來說，push()中的“比較/交換”操作是構成釋放序列的一部分。因此，即使有很多線程在同一時間對head進行修改，push()中的compare_exchange_weak()與increase_head_count()(讀取已存儲的值)中的compare_exchange_strong()也是同步的。

剩餘操作就可以用來處理fetch_add()操作(用來改變引用計數的操作)，因為已知其他線程不可能對該節點的數據進行修改，所以從節點中返回數據的線程可以繼續執行。不過，當線程獲取其他線程修改後的值時，就代表操作失敗(swap()是用來提取數據項的引用)。那麼，為了避免數據競爭，需要保證swap()先行於delete操作。一種簡單的解決辦法，在“成功返回”分支中對fetch_add()使用`std::memory_order_release`內存序，在“再次循環”分支中對fetch_add()使用`std::memory_order_qcquire`內存序。不過，這就有點矯枉過正：只有一個線程做delete操作(將引用計數設置為0的線程)，所以只有這個線程需要獲取操作。幸運的是，因為fetch_add()是一個“讀-改-寫”操作，是釋放序列的一部分，所以可以使用一個額外的load()做獲取。當“再次循環”分支將引用計數減為0時，fetch_add()可以重載引用計數，這裡使用`std::memory_order_acquire`為了保持需求的同步關係；並且，fetch_add()本身可以使用`std::memory_order_relaxed`。使用新pop()的棧實現如下。

清單7.12 基於引用計數和鬆散原子操作的無鎖棧

```
template<typename T>
class lock_free_stack
{
private:
  struct node;
  struct counted_node_ptr
  {
    int external_count;
    node* ptr;
  };

  struct node
  {
    std::shared_ptr<T> data;
    std::atomic<int> internal_count;
    counted_node_ptr next;

    node(T const& data_):
      data(std::make_shared<T>(data_)),
      internal_count(0)
    {}
  };

  std::atomic<counted_node_ptr> head;

  void increase_head_count(counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;
   
    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!head.compare_exchange_strong(old_counter,new_counter,
                                        std::memory_order_acquire,
                                        std::memory_order_relaxed));
    old_counter.external_count=new_counter.external_count;
  }
public:
  ~lock_free_stack()
  {
    while(pop());
  }

  void push(T const& data)
  {
    counted_node_ptr new_node;
    new_node.ptr=new node(data);
    new_node.external_count=1;
    new_node.ptr->next=head.load(std::memory_order_relaxed)
    while(!head.compare_exchange_weak(new_node.ptr->next,new_node,
                                      std::memory_order_release,
                                      std::memory_order_relaxed));
  }
  std::shared_ptr<T> pop()
  {
    counted_node_ptr old_head=
       head.load(std::memory_order_relaxed);
    for(;;)
    {
      increase_head_count(old_head);
      node* const ptr=old_head.ptr;
      if(!ptr)
      {
        return std::shared_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next,
                                      std::memory_order_relaxed))
      {
        std::shared_ptr<T> res;
        res.swap(ptr->data);

        int const count_increase=old_head.external_count-2;

        if(ptr->internal_count.fetch_add(count_increase,
              std::memory_order_release)==-count_increase)
        {
          delete ptr;
        }

        return res;
      }
      else if(ptr->internal_count.fetch_add(-1,
                   std::memory_order_relaxed)==1)
      {
        ptr->internal_count.load(std::memory_order_acquire);
        delete ptr;
      }
    }
  }
};
```

這是一種鍛鍊，不過鍛鍊要告一段落了，我們已經獲得比之前好很多的棧實現。在深思熟慮後，通過使用更多的鬆散操作，在不影響併發性的同時提高性能。實現中的pop()有37行，而功能等同於清單6.1中的那7行的基於鎖的棧實現，和清單7.2中無內存管理的無鎖棧實現。對於接下來要設計的無鎖隊列，將看到類似的情況：無鎖結構的複雜性，主要在於內存的管理。

## 7.2.6 寫一個無鎖的線程安全隊列

隊列的提供的挑戰與棧的有些不同，因為push()和pop()在隊列中，操作的不是同一個地方。因此，同步的需求就不一樣了。需要保證對一端的修改是正確的，且對另一端是可見的。不過，在清單6.6中隊列有一個try_pop()成員函數，其作用和清單7.2中簡單的無鎖棧的pop()功能差不多，那麼就可以合理的假設無鎖代碼都很相似。這是為什麼呢？

如果將清單6.6中的代碼作為基礎，就需要兩個node指針：head和tail。可以讓多線程對它們進行訪問，所以這兩個節點最好是原子的，這樣就不用考慮互斥問題了。讓我們對清單6.6中的代碼做一些修改，並且看一下應該從哪裡開始設計。先來看一下下面的代碼。

清單7.13 單生產者/單消費者模型下的無鎖隊列

```
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    std::shared_ptr<T> data;
    node* next;
    
    node():
       next(nullptr)
    {}
  };

  std::atomic<node*> head;
  std::atomic<node*> tail;

  node* pop_head()
  {
    node* const old_head=head.load();
    if(old_head==tail.load())  // 1
    {
      return nullptr;
    }
    head.store(old_head->next);
    return old_head;
  }
public:
  lock_free_queue():
      head(new node),tail(head.load())
  {}

  lock_free_queue(const lock_free_queue& other)=delete;
  lock_free_queue& operator=(const lock_free_queue& other)=delete;

  ~lock_free_queue()
  {
    while(node* const old_head=head.load())
    {
      head.store(old_head->next);
      delete old_head;
    }
  }
  std::shared_ptr<T> pop()
  {
    node* old_head=pop_head();
    if(!old_head)
    {
      return std::shared_ptr<T>();
    }

    std::shared_ptr<T> const res(old_head->data);  // 2
    delete old_head;
    return res;
  }

  void push(T new_value)
  {
    std::shared_ptr<T> new_data(std::make_shared<T>(new_value));
    node* p=new node;  // 3
    node* const old_tail=tail.load();  // 4
    old_tail->data.swap(new_data);  // 5
    old_tail->next=p;  // 6
    tail.store(p);  // 7
  }
};
```

一眼望去，這個實現並沒什麼不好，當只有一個線程調用一次push()，且只有一個線程調用pop()。在這種情況下，隊列完美工作。push()和pop()之間的先行關係就很重要了，這直接關係到獲取到的data。對tail的存儲⑦同步於對tail的加載①；存儲之前節點的data指針⑤先行於存儲tail；並且，加載tail先行於加載data指針②，所以對data的存儲要先行於加載，一切都沒問題。因此，這是一個完美的*單生產者，單消費者*(SPSC, single-producer, single-consume)隊列。

問題在於當多線程對push()或pop()併發調用。先看一下push()：如果有兩個線程併發調用push()，那麼它們會新分配兩個節點作為虛擬節點③，也會讀取到相同的tail值④，因此也會同時修改同一個節點，同時設置data和next指針⑤⑥。明顯的數據競爭！

pop_head()函數也有類似的問題。當有兩個線程併發的調用這個函數時，這兩個線程就會讀取到同一個head中同樣的值，並且會同時通過next指針去複寫舊值。兩個線程現在都能索引到同一個節點——真是一場災難！這裡，不僅要保證只有一個pop()線程可以訪問給定項，還要保證其他線程在讀取head指針時，可以安全的訪問節點中的next。這就和無鎖棧中pop()的問題一樣了，那麼就有很多解決方案可以在這裡使用。

pop()的問題解決了，那麼push()呢？問題在於為了獲取push()和pop()間的先行關係，就需要在為虛擬節點設置數據項前，更新tail指針。這就意味著，併發訪問push()時，因為每個線程所讀取到的是同一個tail指針，所以線程會為同一個數據項進行競爭。

**多線程下的push()**

第一個選擇是在兩個真實節點中添加一個虛擬節點。這種方法，需要當前tail節點更新next指針，這樣讓節點看起來像一個原子變量。當一個線程成功將next指針指向一個新節點，就說明其成功的添加了一個指針；否則，就不得不再次讀取tail，並重新對指針進行添加。這裡就需要對pop()進行簡單的修改，為了消除持有空指針的節點再次進行循環。這個方法的缺點：每次pop()函數的調用，通常都要刪除兩個節點，每次添加一個節點，都需要分配雙份內存。

第二個選擇是讓data指針原子化，並通過“比較/交換”操作對其進行設置。如果“比較/交換”成功，就說明你能獲取tail指針，並能夠安全的對其next指針進行設置，也就是更新tail。因為有其他線程對數據進行了存儲，所以會導致“比較/交換”操作的失敗，這時就要重新讀取tail，重新循環。當原子操作對於`std::shared_ptr<>`是無鎖的，那麼就可以輕鬆一下了。如果不是，你就需要一個替代方案了；一種可能是讓pop()函數返回一個`std::unique_ptr<>`(畢竟，這個指針指針只能引用指定對象)，並且將數據作為一個普通指針存儲在隊列中的方案。這就需要隊列支持存儲`std::atomic<T*>`類型，對於compare_exchange_strong()的調用就很有必要了。當使用的是類似於清單7.11中的引用計數模式，來解決多線程對pop()和push()的訪問。

清單7.14 push()的第一次修訂(不正確的)

```
void push(T new_value)
{
  std::unique_ptr<T> new_data(new T(new_value));
  counted_node_ptr new_next;
  new_next.ptr=new node;
  new_next.external_count=1;
  for(;;)
  {
    node* const old_tail=tail.load();  // 1
    T* old_data=nullptr;
    if(old_tail->data.compare_exchange_strong(
      old_data,new_data.get()))  // 2
    {
      old_tail->next=new_next;
      tail.store(new_next.ptr);  // 3
      new_data.release();
      break;
    }
  }
}
```

使用引用計數方案可以避免競爭，不過競爭不只在push()中。可以再看一下7.14中的修訂版push()，與棧中模式相同：加載一個原子指針①，並且對該指針解引用②。同時，另一個線程可以對指針進行更新③，最終回收該節點(在pop()中)。當節點回收後，再對指針進行解引用，就對導致未定義行為。啊哈！這裡有個誘人的方案，就是給tail也添加計數器，就像給head做的那樣，不過隊列中的節點的next指針中都已經擁有了一個外部計數。在同一個節點上有兩個外部計數，為了避免過早的刪除節點，這就是對之前引用計數方案的修改。通過對node結構中外部計數器數量的統計，解決這個問題。當外部計數器銷燬時，統計值減一(將對應的外部計數添加到內部)。當內部計數是0，且沒有外部計數器時，對應節點就可以被安全刪除了。這個技術，是我查閱Joe Seigh的*原子指針+*項目[5]的時候看到的。下面push()的實現就使用的就是這種方案。

清單7.15 使用帶有引用計數tail，實現的無鎖隊列中的push()

```
template<typename T>
class lock_free_queue
{
private:
  struct node;
  struct counted_node_ptr
  {
    int external_count;
    node* ptr;
  };

  std::atomic<counted_node_ptr> head;
  std::atomic<counted_node_ptr> tail;  // 1

  struct node_counter
  {
    unsigned internal_count:30;
    unsigned external_counters:2;  // 2
  };

  struct node
  {
    std::atomic<T*> data;
    std::atomic<node_counter> count;  // 3
    counted_node_ptr next;

    node()
    {
      node_counter new_count;
      new_count.internal_count=0;
      new_count.external_counters=2;  // 4
      count.store(new_count);

      next.ptr=nullptr;
      next.external_count=0;
     }
  };
public:
  void push(T new_value)
  {
    std::unique_ptr<T> new_data(new T(new_value));
    counted_node_ptr new_next;
    new_next.ptr=new node;
    new_next.external_count=1;
    counted_node_ptr old_tail=tail.load();

    for(;;)
    {
      increase_external_count(tail,old_tail);  // 5

      T* old_data=nullptr;
      if(old_tail.ptr->data.compare_exchange_strong(  // 6
           old_data,new_data.get()))
      {
        old_tail.ptr->next=new_next;
        old_tail=tail.exchange(new_next);
        free_external_counter(old_tail);  // 7
        new_data.release();
        break;
      }
      old_tail.ptr->release_ref();
    }
  }
};
```

清單7.15中，tail和head一樣都是atomic<counted_node_ptr>類型①，並且node結構體中用count成員變量替換了之前的internal_count③。count成員變量包括了internal_count和外部external_counters成員②。注意，這裡你需要2bit的external_counters，因為最多就有兩個計數器。因為使用了位域，所以就將internal_count指定為30bit的值，就能保證計數器的總體大小是32bit。內部計數值就有充足的空間來保證這個結構體能放在一個機器字中(包括32位和64位平臺)。重要的是，為的就是避免條件競爭，將結構體作為一個單獨的實體來更新。讓結構體的大小保持在一個機器字內，對其的操作就如同原子操作一樣，還可以在多個平臺上使用。

node初始化時，internal_count設置為0，external_counter設置為2④，因為當新節點加入隊列中時，都會被tail和上一個節點的next指針所指向。push()與清單7.14中的實現很相似，除了為了對tail中的值進行解引用，需要調用節點data成員變量的compare_exchange_strong()成員函數⑥保證值的正確性；在這之前還要調用increase_external_count()增加計數器的計數⑤，而後在對尾部的舊值調用free_external_counter()⑦。

push()處理完畢，再來看一下pop()。下面的實現，是將清單7.11中的引用計數pop()與7.13中隊列彈出pop()混合的版本。

清單7.16 使用尾部引用計數，將節點從無鎖隊列中彈出

```
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    void release_ref();
  };
public:
  std::unique_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load(std::memory_order_relaxed);  // 1
    for(;;)
    {
      increase_external_count(head,old_head);  // 2
      node* const ptr=old_head.ptr;
      if(ptr==tail.load().ptr)
      {
        ptr->release_ref();  // 3
        return std::unique_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next))  // 4
      {
        T* const res=ptr->data.exchange(nullptr);
        free_external_counter(old_head);  // 5
        return std::unique_ptr<T>(res);
      }
      ptr->release_ref();  // 6
    }
  }
};
```

在進入循環，並將加載值的外部計數增加②之前，需要加載old_head值作為啟動①。當head與tail節點相同的時候，就能對引用進行釋放③，因為這時隊列中已經沒有數據，所以返回的是空指針。如果隊列中還有數據，可以嘗試使用compare_exchange_strong()來做聲明④。與7.11中的棧一樣，將外部計數和指針做為一個整體進行比較的；當外部計數或指針有所變化時，需要將引用釋放後，再次進行循環⑥。當交換成功時，已聲明的數據就歸你所有，那麼為已彈出節點釋放外部計數後⑤，就能把對應的指針返回給調用函數了。當兩個外部引用計數都被釋放，且內部計數降為0時，節點就可以被刪除。對應的引用計數函數將會在7.17,7.18和7.19中展示。

清單7.17 在無鎖隊列中釋放一個節點引用

```
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    void release_ref()
    {
      node_counter old_counter=
        count.load(std::memory_order_relaxed);
      node_counter new_counter;
      do
      {
        new_counter=old_counter;
        --new_counter.internal_count;  // 1
      }
      while(!count.compare_exchange_strong(  // 2
            old_counter,new_counter,
            std::memory_order_acquire,std::memory_order_relaxed));
      if(!new_counter.internal_count &&
         !new_counter.external_counters)
      {
        delete this;  // 3
      }
    }
  };
};
```

node::release_ref()的實現，只是對7.11中lock_free_stack::pop()進行小幅度的修改得到。不過，7.11中的代碼僅是處理單個外部計數的情況，所以想要修改internal_count①，只需要使用fetch_sub就能讓count結構體自動更新。因此，需要一個“比較/交換”循環②。降低internal_count時，在內外部計數都為0時，就代表這是最後一次引用，之後就可以將這個節點刪除③。

清單7.18 從無鎖隊列中獲取一個節點的引用

```
template<typename T>
class lock_free_queue
{
private:
  static void increase_external_count(
    std::atomic<counted_node_ptr>& counter,
    counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;
    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!counter.compare_exchange_strong(
      old_counter,new_counter,
      std::memory_order_acquire,std::memory_order_relaxed));

    old_counter.external_count=new_counter.external_count;
  }
};
```

清單7.18展示的是另一方面。這次，並不是對引用的釋放，會得到一個新引用，並增加外部計數的值。increase_external_count()和7.12中的increase_head_count()很相似，不同的是increase_external_count()這裡作為靜態成員函數，通過將外部計數器作為第一個參數傳入函數，對其進行更新，而非只操作一個固定的計數器。

清單7.19 無鎖隊列中釋放節點外部計數器

```
template<typename T>
class lock_free_queue
{
private:
  static void free_external_counter(counted_node_ptr &old_node_ptr)
  {
    node* const ptr=old_node_ptr.ptr;
    int const count_increase=old_node_ptr.external_count-2;
    
    node_counter old_counter=
      ptr->count.load(std::memory_order_relaxed);
    node_counter new_counter;
    do
    {
      new_counter=old_counter;
      --new_counter.external_counters;  // 1
      new_counter.internal_count+=count_increase;  // 2
    }
    while(!ptr->count.compare_exchange_strong(  // 3
           old_counter,new_counter,
           std::memory_order_acquire,std::memory_order_relaxed));

    if(!new_counter.internal_count &&
       !new_counter.external_counters)
    {
      delete ptr;  // 4
    }
  }
};
```

與increase_external_count()對應的是free_external_counter()。這裡的代碼和7.11中的lock_free_stack::pop()類似，不過做了一些修改用來處理external_counters計數。使用單個compare_exchange_strong()對計數結構體中的兩個計數器進行更新③，就像之前release_ref()降低internal_count一樣。和7.11中一樣，internal_count會進行更新②，並且external_counters將會減一①。當內外計數值都為0，就沒有更多的節點可以被引用，所以節點就可以安全的刪除④。這個操作需要作為獨立的操作來完成(因此需要“比較/交換”循環)，來避免條件競爭。如果將兩個計數器分開來更新，在兩個線程的情況下，可能都會認為自己最後一個引用者，從而將節點刪除，最後導致未定義行為。

雖然現在的隊列工作正常，且無競爭，但是還是有一個性能問題。當一個線程對old_tail.ptr->data成功的完成compare_exchange_strong()(7.15中的⑥)，就可以執行push()操作；並且，能確定沒有其他線程在同時執行push()操作。這裡，讓其他線程看到有新值的加入，要比只看到空指針的好，因此在compare_exchange_strong()調用失敗的時候，線程就會繼續循環。這就是忙等待，這種方式會消耗CPU的運算週期，且什麼事情都沒做。因此，忙等待這就是一個鎖。push()的首次調用，是要在其他線程完成後，將阻塞去除後才能完成，所以這裡的實現只是*半無鎖*(no longer lock-free)結構。不僅如此，還有當線程被阻塞的時候，操作系統會給不同的線程以不同優先級，用於獲取互斥鎖。在當前情況下，不可能出現不同優先級的情況，所以阻塞線程將會浪費CPU的運算週期，直到第一個線程完成其操作。處理的技巧出自於“無鎖技巧包”：等待線程可以幫助push()線程完成操作。

**無鎖隊列中的線程間互助**

為了恢復代碼無鎖的屬性，就需要讓等待線程，在push()線程沒什麼進展時，做一些事情，就是幫進展緩慢的線程完成其工作。

在這種情況下，可以知道線程應該去做什麼：尾節點的next指針需要指向一個新的虛擬節點，且tail指針之後也要更新。因為虛擬節點都是一樣的，所以是誰創建的都不重要。當將next指針放入一個原子節點中時，就可以使用compare_exchange_strong()來設置next指針。當next指針已經被設置，就可以使用compare_exchange_weak()循環對tail進行設置，能保證next指針始終引用的是同一個原始節點。如果引用的不是同一個原始節點，那麼其他部分就已經更新，可以停止嘗試再次循環。這個需求只需要對pop()進行微小的改動，其目的就是為了加載next指針；這個實現將在下面展示。

清單7.20 修改pop()用來幫助push()完成工作

```
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    std::atomic<T*> data;
    std::atomic<node_counter> count;
    std::atomic<counted_node_ptr> next;  // 1
  };
public:
  std::unique_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load(std::memory_order_relaxed);
    for(;;)
    {
      increase_external_count(head,old_head);
      node* const ptr=old_head.ptr;
      if(ptr==tail.load().ptr)
      {
        return std::unique_ptr<T>();
      }
      counted_node_ptr next=ptr->next.load();  // 2
      if(head.compare_exchange_strong(old_head,next))
      {
        T* const res=ptr->data.exchange(nullptr);
        free_external_counter(old_head);
        return std::unique_ptr<T>(res);
      } 
      ptr->release_ref();
    }
  }
};
```

如之前所說，改變很簡單：next指針線程就是原子的①，所以load②也是原子的。在這個例子中，可以使用默認memory_order_seq_cst內存序，所以這裡可以忽略對load()的顯式調用，並且依賴於加載對象隱式轉換成counted_node_ptr，不過這裡的顯式調用就可以用來提醒：哪裡需要顯式添加內存序。

以下代碼對push()有更多的展示。

清單7.21 無鎖隊列中簡單的幫助性push()的實現

```
template<typename T>
class lock_free_queue
{
private:
  void set_new_tail(counted_node_ptr &old_tail,  // 1
                    counted_node_ptr const &new_tail)
  {
    node* const current_tail_ptr=old_tail.ptr;
    while(!tail.compare_exchange_weak(old_tail,new_tail) &&  // 2
          old_tail.ptr==current_tail_ptr);
    if(old_tail.ptr==current_tail_ptr)  // 3
      free_external_counter(old_tail);  // 4
    else
      current_tail_ptr->release_ref();  // 5
  }
public:
  void push(T new_value)
  {
    std::unique_ptr<T> new_data(new T(new_value));
    counted_node_ptr new_next;
    new_next.ptr=new node;
    new_next.external_count=1;
    counted_node_ptr old_tail=tail.load();

    for(;;)
    {
      increase_external_count(tail,old_tail);

      T* old_data=nullptr;
      if(old_tail.ptr->data.compare_exchange_strong(  // 6
         old_data,new_data.get()))
      {
        counted_node_ptr old_next={0};
        if(!old_tail.ptr->next.compare_exchange_strong(  // 7
           old_next,new_next))
        {
          delete new_next.ptr;  // 8
          new_next=old_next;  // 9
        }
        set_new_tail(old_tail, new_next);
        new_data.release();
        break;
      }
      else  // 10
      {
        counted_node_ptr old_next={0};
        if(old_tail.ptr->next.compare_exchange_strong(  // 11
           old_next,new_next))
        {
          old_next=new_next;  // 12
          new_next.ptr=new node;  // 13
        }
        set_new_tail(old_tail, old_next);  // 14
      }
    }
  }
};
```

與清單7.15中的原始push()相似，不過還是有些不同。當對data進行設置⑥，就需要對另一線程幫忙的情況進行處理，在else分支就是具體的幫助⑩。

對節點中的data指針進行設置⑥時，新版push()對next指針的更新使用的是compare_exchange_strong()⑦(這裡使用compare_exchange_strong()來避免循環),當交換失敗，就能知道另有線程對next指針進行設置，所以就可以刪除一開始分配的那個新節點⑧。還需要獲取next指向的值——其他線程對tail指針設置的值。

對tail指針的更新，實際在set_new_tail()中完成①。這裡使用一個compare_exchange_weak()循環②來更新tail，如果其他線程嘗試push()一個節點時，external_count部分將會改變。不過，當其他線程成功的修改了tail指針時，就不能對其值進行替換；否則，隊列中的循環將會結束，這是一個相當糟糕的主意。因此，當“比較/交換”操作失敗的時候，就需要保證ptr加載值要與tail指向的值相同。當新舊ptr相同時，循環退出③，這就代表對tail的設置已經完成，所以需要釋放舊外部計數器④。當ptr值不一樣時，那麼另一線程可能已經將計數器釋放了，所以這裡只需要對該線程持有的單次引用進行釋放即可⑤。

當線程調用push()時，未能在循環階段對data指針進行設置，那麼這個線程可以幫助成功的線程完成更新。首先，會嘗試更新next指針，讓其指向該線程分配出來的新節點⑪。當指針更新成功，就可以將這個新節點作為新的tail節點⑫，且需要分配另一個新節點，用來管理隊列中新推送的數據項⑬。在再進入循環之前，可以通過調用set_new_tail來設置tail節點⑭。

讀者可能已經意識到，比起大量的new和delete操作，這樣的代碼更加短小精悍，因為新節點實在push()中被分配，而在pop()中被銷燬。因此，內存分配器的效率也需要考慮到；一個糟糕的分配器可能會讓無鎖容器的擴展特性消失的一乾二淨。選擇和實現高效的分配器，已經超出了本書的範圍，不過需要牢記的是：測試以及衡量分配器效率最好的辦法，就是對使用前和使用後進行比較。為優化內存分配，包括每個線程有自己的分配器，以及使用回收列表對節點進行回收，而非將這些節點返回給分配器。

例子已經足夠多了；那麼，讓我們從這些例子中提取出一些指導建議吧。

-------

[1] “Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes,” Maged M.Michael, *in PODC ’02: Proceedings of the Twenty-first Annual Symposium on Principles of Distributed Computing* (2002), ISBN 1-58113-485-1.

[2] Maged M. Michael, U.S. Patent and Trademark Office application number 20040107227, “Method for efficient implementation of dynamic lock-free data structures with safe memory reclamation.”

[3] GNU General Public License http://www.gnu.org/licenses/gpl.html.

[4] IBM Statement of Non-Assertion of Named Patents Against OSS, http://www.ibm.com/ibm/licensing/patents/pledgedpatents.pdf.

[5] Atomic Ptr Plus Project, http://atomic-ptr-plus.sourceforge.net/.