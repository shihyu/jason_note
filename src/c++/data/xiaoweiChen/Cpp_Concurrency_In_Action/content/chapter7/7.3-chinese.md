# 7.3 對於設計無鎖數據結構的指導建議

本章中的例子中，看到了一些複雜的代碼可讓無鎖結構工作正常。如果要設計自己的數據結構，一些指導建議可以幫助你找到設計重點。第6章中關於併發通用指導建議還適用，不過這裡需要更多的建議。我從例子中抽取了幾個實用的指導建議，在你設計無鎖結構數據的時候就可以直接引用。

## 7.3.1 指導建議：使用`std::memory_order_seq_cst`的原型

`std::memory_order_seq_cst`比起其他內存序要簡單的多，因為所有操作都將其作為總序。本章的所有例子，都是從`std::memory_order_seq_cst`開始，只有當基本操作正常工作的時候，才放寬內存序的選擇。在這種情況下，使用其他內存序就是進行優化(早起可以不用這樣做)。通常，當你看整套代碼對數據結構的操作後，才能決定是否要放寬該操作的內存序選擇。所以，嘗試放寬選擇，可能會讓你輕鬆一些。在測試後的時候，工作的代碼可能會很複雜(不過，不能完全保證內存序正確)。除非你有一個算法檢查器，可以系統的測試，線程能看到的所有可能性組合，這樣就能保證指定內存序的正確性(這樣的測試的確存在)，僅是執行實現代碼是遠遠不夠的。

## 7.3.2 指導建議：對無鎖內存的回收策略

這裡與無鎖代碼最大的區別就是內存管理。當有其他線程對節點進行訪問的時候，節點無法被任一線程刪除；為避免過多的內存使用，還是希望這個節點在能刪除的時候儘快刪除。本章中介紹了三種技術來保證內存可以被安全的回收：

- 等待無線程對數據結構進行訪問時，刪除所有等待刪除的對象。

- 使用風險指針來標識正在被線程訪問的對象。

- 對對象進行引用計數，當沒有線程對對象進行引用時，將其刪除。

在所有例子中，主要的想法都是使用一種方式去跟蹤指定對象上的線程訪問數量，當沒有現成對對象進行引用的時候，將對象刪除。當然，在無鎖數據結構中，還有很多方式可以用來回收內存。例如，理想情況下使用一個垃圾收集器。比起算法來說，其實現更容易一些。只需要讓回收器知道，當節點沒被引用的時候，回收節點，就可以了。

其他替代方案就是循環使用節點，只在數據結構被銷燬的時候才將節點完全刪除。因為節點能被複用，那麼就不會有非法的內存，所以這就能避免未定義行為的發生。這種方式的缺點：產生“ABA問題”。

## 7.3.3 指導建議：小心[ABA問題](https://en.wikipedia.org/wiki/ABA_problem)

在“基於比較/交換”的算法中要格外小心“ABA問題”。其流程是:

1. 線程1讀取原子變量x，並且發現其值是A。
2. 線程1對這個值進行一些操作，比如，解引用(當其是一個指針的時候)，或做查詢，或其他操作。
3. 操作系統將線程1掛起。
4. 其他線程對x執行一些操作，並且將其值改為B。
5. 另一個線程對A相關的數據進行修改(線程1持有)，讓其不再合法。可能會在釋放指針指向的內存時，代碼產生劇烈的反應(大問題)；或者只是修改了相關值而已(小問題)。
6. 再來一個線程將x的值改回為A。如果A是一個指針，那麼其可能指向一個新的對象，只是與舊對象共享同一個地址而已。
7. 線程1繼續運行，並且對x執行“比較/交換”操作，將A進行對比。這裡，“比較/交換”成功(因為其值還是A)，不過這是一個*錯誤的A*(the wrong A value)。從第2步中讀取的數據不再合法，但是線程1無法言明這個問題，並且之後的操作將會損壞數據結構。

本章提到的算法不存在這個問題，不過在無鎖的算法中，這個問題很常見。解決這個問題的一般方法是，讓變量x中包含一個ABA計數器。“比較/交換”會對加入計數器的x進行操作。每次的值都不一樣，計數隨之增長，所以在x還是原值的前提下，即使有線程對x進行修改，“比較/交換”還是會失敗。

“ABA問題”在使用釋放鏈表和循環使用節點的算法中很是普遍，而將節點返回給分配器，則不會引起這個問題。

## 7.3.4 指導建議：識別忙等待循環和幫助其他線程

在最終隊列的例子中，已經見識到線程在執行push操作時，必須等待另一個push操作流程的完成。等待線程就會被孤立，將會陷入到忙等待循環中，當線程嘗試失敗的時候，會繼續循環，這樣就會浪費CPU的計算週期。當忙等待循環結束時，就像一個阻塞操作解除，和使用互斥鎖的行為一樣。通過對算法的修改，當之前的線程還沒有完成操作前，讓等待線程執行未完成的步驟，就能讓忙等待的線程不再被阻塞。在隊列例中，需要將一個數據成員轉換為一個原子變量，而不是使用非原子變量和使用“比較/交換”操作來做這件事；要是在更加複雜的數據結構中，這將需要更加多的變化來滿足需求。