# 第5章 C++內存模型和原子類型操作

**本章主要內容**

- C++11內存模型詳解<br>
- 標準庫提供的原子類型<br>
- 使用各種原子類型<br>
- 原子操作實現線程同步功能<br>

C++11標準中，有一個十分重要特性，常被程序員們所忽略。它不是一個新語法特性，也不是新工具，它就是多線程(感知)內存模型。內存模型沒有明確的定義基本部件應該如何工作的話，之前介紹的那些工具就無法正常工作。那為什麼大多數程序員都沒有注意到它呢？當你使用互斥量保護你的數據和條件變量，或者是“期望”上的信號事件時，對於互斥量*為什麼*能起到這樣作用，大多數人不會去關心。只有當你試圖去“接觸硬件”，你才能詳盡的瞭解到內存模型是如何起作用的。

C++是一個系統級別的編程語言，標準委員會的目標之一就是不需要比`C++`還要底層的高級語言。`C++`應該向程序員提供足夠的靈活性，無障礙的去做他們想要做的事情；當需要的時候，可以讓他們“接觸硬件”。原子類型和原子操作就允許他們“接觸硬件”，並提供底層級別的同步操作，通常會將常規指令數縮減到1~2個CPU指令。

本章，我們將討論內存模型的基本知識，而後再瞭解一下原子類型和操作，最後瞭解與原子類型操作相關的各種同步。這個過程會比較複雜：除非你已經打算使用原子操作(比如，第7章的無鎖數據結構)同步你的代碼，否則，就沒有必要了解過多的細節。

讓我們先輕鬆愉快的來看一下有關內存模型的基本知識。