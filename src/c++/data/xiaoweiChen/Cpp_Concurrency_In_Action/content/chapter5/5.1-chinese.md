# 5.1 內存模型基礎

這裡從兩方面來講內存模型：一方面是基本結構，這與事務在內存中是怎樣佈局的有關；另一方面就是併發。對於併發基本結構很重要，特別是在低層原子操作。所以我將會從基本結構講起。`C++`中它與所有的對象和內存位置有關。

## 5.1.1 對象和內存位置

在一個`C++`程序中的所有數據都是由對象(objects)構成。這不是說你可以創建一個int的衍生類，或者是基本類型中存在有成員函數，或是像在Smalltalk和Ruby語言下討論程序那樣——“一切都是對象”。“對象”僅僅是對C++數據構建塊的一個聲明。`C++`標準定義類對象為“存儲區域”，但對象還是可以將自己的特性賦予其他對象，比如，其類型和生命週期。

像int或float這樣的對象就是簡單基本類型；當然，也有用戶定義類的實例。一些對象(比如，數組，衍生類的實例，特殊（具有非靜態數據成員）類的實例)擁有子對象，但是其他對象就沒有。

無論對象是怎麼樣的一個類型，一個對象都會存儲在一個或多個內存位置上。每一個內存位置不是一個標量類型的對象，就是一個標量類型的子對象，比如，unsigned short、my_class*或序列中的相鄰位域。當你使用位域，就需要注意：雖然相鄰位域中是不同的對象，但仍視其為相同的內存位置。如圖5.1所示，將一個struct分解為多個對象，並且展示了每個對象的內存位置。

![](../../images/chapter5/5-1.png)

圖5.1 分解一個struct，展示不同對象的內存位置

首先，完整的struct是一個有多個子對象(每一個成員變量)組成的對象。位域bf1和bf2共享同一個內存位置(int是4字節、32位類型)，並且`std::string`類型的對象s由內部多個內存位置組成，但是其他的每個成員都擁有自己的內存位置。注意，位域寬度為0的bf3是如何與bf4分離，並擁有各自的內存位置的。(譯者注：圖中bf3是一個錯誤展示，在`C++`和C中規定，寬度為0的一個未命名位域強制下一位域對齊到其下一type邊界，其中type是該成員的類型。這裡使用命名變量為0的位域，可能只是想展示其與bf4是如何分離的。有關位域的更多可以參考[wiki](https://en.wikipedia.org/wiki/Bit_field)的頁面)。

這裡有四個需要牢記的原則：<br>

1. 每一個變量都是一個對象，包括作為其成員變量的對象。<br>
2. 每個對象至少佔有一個內存位置。<br>
3. 基本類型都有確定的內存位置(無論類型大小如何，即使他們是相鄰的，或是數組的一部分)。<br>
4. 相鄰位域是相同內存中的一部分。<br>

我確定你會好奇，這些在併發中有什麼作用，那麼下面就讓我們來見識一下。

## 5.1.2 對象、內存位置和併發

這部分對於`C++`的多線程應用來說是至關重要的：所有東西都在內存中。當兩個線程訪問不同的內存位置時，不會存在任何問題，一切都工作順利。而另一種情況下，當兩個線程訪問同一個內存位置，你就要小心了。如果沒有線程更新內存位置上的數據，那還好；只讀數據不需要保護或同步。當有線程對內存位置上的數據進行修改，那就有可能會產生條件競爭，就如第3章所述的那樣。

為了避免條件競爭，兩個線程就需要一定的執行順序。第一種方式，如第3章所述那樣，使用互斥量來確定訪問的順序；當同一互斥量在兩個線程同時訪問前被鎖住，那麼在同一時間內就只有一個線程能夠訪問到對應的內存位置，所以後一個訪問必須在前一個訪問之後。另一種方式是使用原子操作同步機制(詳見5.2節中對於原子操作的定義)，決定兩個線程的訪問順序。使用原子操作來規定順序在5.3節中會有介紹。當多於兩個線程訪問同一個內存地址時，對每個訪問這都需要定義一個順序。

如果不去規定兩個不同線程對同一內存地址訪問的順序，那麼訪問就不是原子的；並且，當兩個線程都是“作者”時，就會產生數據競爭和未定義行為。

以下的聲明由為重要：未定義的行為是`C++`中最黑暗的角落。根據語言的標準，一旦應用中有任何未定義的行為，就很難預料會發生什麼事情；因為，未定義行為是難以預料的。我就知道一個未定義行為的特定實例，讓某人的顯示器起火的案例。雖然，這種事情應該不會發生在你身上，但是數據競爭絕對是一個嚴重的錯誤，並且需要不惜一切代價避免它。

另一個重點是：當程序中的對同一內存地址中的數據訪問存在競爭，你可以使用原子操作來避免未定義行為。當然，這不會影響競爭的產生——原子操作並沒有指定訪問順序——但原子操作把程序拉回了定義行為的區域內。

在我們瞭解原子操作前，還有一個有關對象和內存地址的概念需要重點了解：修改順序。

## 5.1.3 修改順序

每一個在C++程序中的對象，都有(由程序中的所有線程對象)確定好的修改順序，在的初始化開始階段確定。在大多數情況下，這個順序不同於執行中的順序，但是在給定的執行程序中，所有線程都需要遵守這順序。如果對象不是一個原子類型(將在5.2節詳述)，你必要確保有足夠的同步操作，來確定每個線程都遵守了變量的修改順序。當不同線程在不同序列中訪問同一個值時，你可能就會遇到數據競爭或未定義行為(詳見5.1.2節)。如果你使用原子操作，編譯器就有責任去替你做必要的同步。

這一要求意味著：投機執行是不允許的，因為當線程按修改順序訪問一個特殊的輸入，之後的讀操作，必須由線程返回較新的值，並且之後的寫操作必須發生在修改順序之後。同樣的，在同一線程上允許讀取對象的操作，要不返回一個已寫入的值，要不在對象的修改順序後(也就是在讀取後)再寫入另一個值。雖然，所有線程都需要遵守程序中每個獨立對象的修改順序，但它們沒有必要遵守在獨立對象上的相對操作順序。在5.3.3節中會有更多關於不同線程間操作順序的內容。

所以，什麼是原子操作？它如何來規定順序？接下來的一節中，會為你揭曉答案。

