# 1.2 為什麼使用併發？

主要原因有兩個：關注點分離(SOC)和性能。事實上，它們應該是使用併發的唯一原因；如果你觀察得足夠仔細，所有因素都可以歸結到其中的一個原因(或者可能是兩個都有。當然，除了像“就因為我願意”這樣的原因之外)。

## 1.2.1 為了分離關注點

編寫軟件時，分離關注點是個好主意；通過將相關的代碼與無關的代碼分離，可以使程序更容易理解和測試，從而減少出錯的可能性。即使一些功能區域中的操作需要在同一時刻發生的情況下，依舊可以使用併發分離不同的功能區域；若不顯式地使用併發，就得編寫一個任務切換框架，或者在操作中主動地調用一段不相關的代碼。

考慮一個有用戶界面的處理密集型應用——DVD播放程序。這樣的應用程序，應具備這兩種功能：一，要從光盤中讀出數據，對圖像和聲音進行解碼，之後把解碼出的信號輸出至視頻和音頻硬件，從而實現DVD的無誤播放；二，還需要接受來自用戶的輸入，當用戶單擊“暫停”、“返回菜單”或“退出”按鍵的時候執行對應的操作。當應用是單個線程時，應用需要在回放期間定期檢查用戶的輸入，這就需要把“DVD播放”代碼和“用戶界面”代碼放在一起，以便調用。如果使用多線程方式來分隔這些關注點，“用戶界面”代碼和“DVD播放”代碼就不再需要放在一起：一個線程可以處理“用戶界面”事件，另一個進行“DVD播放”。它們之間會有交互(用戶點擊“暫停”)，不過任務間需要人為的進行關聯。

這會給響應性帶來一些錯覺，因為用戶界面線程通常可以立即響應用戶的請求，在當請求傳達給忙碌線程，這時的相應可以是簡單地顯示代表忙碌的光標或“請等待”字樣的消息。類似地，獨立的線程通常用來執行那些必須在後臺持續運行的任務，例如，桌面搜索程序中監視文件系統變化的任務。因為它們之間的交互清晰可辨，所以這種方式會使每個線程的邏輯變的更加簡單。

在這種情況下，線程的數量不再依賴CPU中的可用內核的數量，因為對線程的劃分是基於概念上的設計，而不是一種增加吞吐量的嘗試。

## 1.2.2 為了性能

多處理器系統已經存在了幾十年，但直到最近，它們也只在超級計算機、大型機和大型服務器系統中才能看到。然而，芯片製造商越來越傾向於多核芯片的設計，即在單個芯片上集成2、4、16或更多的處理器，從而獲取更好的性能。因此，多核臺式計算機、多核嵌入式設備，現在越來越普遍。它們計算能力的提高不是源自使單一任務運行的更快，而是並行運行多個任務。在過去，程序員曾坐看他們的程序隨著處理器的更新換代而變得更快，無需他們這邊做任何事。但是現在，就像Herb Sutter所說的，“沒有免費的午餐了。”[1] *如果想要利用日益增長的計算能力，那就必須設計多任務併發式軟件*。程序員必須留意這個，尤其是那些迄今都忽略併發的人們，現在很有必要將其加入工具箱中了。

兩種方式利用併發提高性能：第一，將一個單個任務分成幾部分，且各自並行運行，從而降低總運行時間。這就是任務並行（*task parallelism*）。雖然這聽起來很直觀，但它是一個相當複雜的過程，因為在各個部分之間可能存在著依賴。區別可能是在過程方面——一個線程執行算法的一部分，而另一個線程執行算法的另一個部分——或是在數據方面——每個線程在不同的數據部分上執行相同的操作（第二種方式）。後一種方法被稱為數據並行（*data parallelism*）。

第一種並行方式影響的算法常被稱為易並行(*embarrassingly parallel*)算法。儘管易並行算法的代碼會讓你感覺到頭痛，但這對於你來說是一件好事：我曾遇到過自然並行(*naturally parallel*)和便利併發(*conveniently concurrent*)的算法。易並行算法具有良好的可擴展特性——當可用硬件線程的數量增加時，算法的並行性也會隨之增加。這種算法能很好的體現*人多力量大*。如果算法中有不易並行的部分，你可以把算法劃分成固定(不可擴展)數量的並行任務。第8章將會再來討論，在線程之間劃分任務的技巧。

第二種方法是使用可並行的方式，來解決更大的問題；與其同時處理一個文件，不如酌情處理2個、10個或20個。雖然，這是數據並行的一種應用(通過對多組數據同時執行相同的操作)，但著重點不同。處理一個數據塊仍然需要同樣的時間，但在相同的時間內處理了更多的數據。當然，這種方法也有限制，並非在所有情況下都是有益的。不過，這種方法所帶來的吞吐量提升，可以讓某些新功能成為可能，例如，可以並行處理圖片的各部分，就能提高視頻的分辨率。

## 1.2.3 什麼時候不使用併發

知道何時**不使用**併發與知道何時**使用**它一樣重要。基本上，不使用併發的唯一原因就是，收益比不上成本。使用併發的代碼在很多情況下難以理解，因此編寫和維護的多線程代碼就會產生直接的腦力成本，同時額外的複雜性也可能引起更多的錯誤。除非潛在的性能增益足夠大或關注點分離地足夠清晰，能抵消所需的額外的開發時間以及與維護多線程代碼相關的額外成本(代碼正確的前提下)；否則，別用併發。

同樣地，性能增益可能會小於預期；因為操作系統需要分配內核相關資源和堆棧空間，所以在啟動線程時存在固有的開銷，然後才能把新線程加入調度器中，所有這一切都需要時間。如果在線程上的任務完成得很快，那麼任務實際執行的時間要比啟動線程的時間小很多，這就會導致應用程序的整體性能還不如直接使用“產生線程”的方式。

此外，線程是有限的資源。如果讓太多的線程同時運行，則會消耗很多操作系統資源，從而使得操作系統整體上運行得更加緩慢。不僅如此，因為每個線程都需要一個獨立的堆棧空間，所以運行太多的線程也會耗盡進程的可用內存或地址空間。對於一個可用地址空間為4GB(32bit)的平坦架構的進程來說，這的確是個問題：如果每個線程都有一個1MB的堆棧(很多系統都會這樣分配)，那麼4096個線程將會用盡所有地址空間，不會給代碼、靜態數據或者堆數據留有任何空間。即便64位(或者更大)的系統不存在這種直接的地址空間限制，但其他資源有限：如果你運行了太多的線程，最終也是出會問題的。儘管線程池(參見第9章)可以用來限制線程的數量，但這也並不是什麼靈丹妙藥，它也有自己的問題。

當客戶端/服務器(C/S)應用在服務器端為每一個鏈接啟動一個獨立的線程，對於少量的鏈接是可以正常工作的，但當同樣的技術用於需要處理大量鏈接的高需求服務器時，也會因為線程太多而耗盡系統資源。在這種場景下，使用線程池可以對性能產生優化（參見第9章）。

最後，運行越多的線程，操作系統就需要做越多的上下文切換，每一次切換都需要耗費本可以花在有價值工作上的時間。所以在某些時候，增加一個額外的線程實際上會降低，而非提高應用程序的整體性能。為此，如果你試圖得到系統的最佳性能，可以考慮使用硬件併發(或不用)，並調整運行線程的數量。

為性能而使用併發就像所有其他優化策略一樣:它擁有大幅度提高應用性能的潛力，但它也可能使代碼複雜化，使其更難理解，並更容易出錯。因此，只有應用中具有顯著增益潛力的性能關鍵部分，才值得併發化。當然，如果性能收益的潛力僅次於設計清晰或關注點分離，可能也值得使用多線程設計。

假設你已經決定確實要在應用中使用併發，無論是為了性能、關注點分離，亦或是因為*多線程星期一*(multithreading Monday)(譯者：可能是學習多線程的意思)。

問題又來了，對於C++程序員來說，多線程意味著什麼？

----------

[1] “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software,” Herb Sutter, Dr. Dobb’s Journal, 30(3), March 2005. http://www.gotw.ca/publications/concurrency-ddj.htm.