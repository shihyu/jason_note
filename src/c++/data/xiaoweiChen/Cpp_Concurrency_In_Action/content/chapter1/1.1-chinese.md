# 1.1 何謂併發

最簡單和最基本的併發,是指兩個或更多獨立的活動同時發生。

併發在生活中隨處可見，我們可以一邊走路一邊說話，也可以兩隻手同時作不同的動作，還有我們每個人都過著相互獨立的生活——當我在游泳的時候，你可以看球賽，等等。

## 1.1.1 計算機系統中的併發

計算機領域的併發指的是在單個系統裡同時執行多個獨立的任務，而非順序的進行一些活動。

計算機領域裡，併發不是一個新事物：很多年前，一臺計算機就能通過多任務操作系統的切換功能，同時運行多個應用程序；高端多處理器服務器在很早就已經實現了真正的並行計算。那“老東西”上有哪些“新東西”能讓它在計算機領域越來越流行呢？——真正任務並行，而非一種錯覺。

以前，大多數計算機只有一個處理器，具有單個*處理單元*(processing unit)或*核心*(core),如今還有很多這樣的臺式機。這種機器只能在某一時刻執行一個任務，不過它可以每秒進行多次任務切換。通過“這個任務做一會，再切換到別的任務，再做一會兒”的方式，讓任務看起來是並行執行的。這種方式稱為*任務切換*。如今,我們仍然將這樣的系統稱為*併發*:因為任務切換得太快，以至於無法感覺到任務在何時會被暫時掛起，而切換到另一個任務。任務切換會給用戶和應用程序造成一種“併發的假象”。因為這種假象，當應用在任務切換的環境下和真正併發環境下執行相比，行為還是有著微妙的不同。特別是對內存模型不正確的假設(詳見第5章),在多線程環境中可能不會出現(詳見第10章)。

多處理器計算機用於服務器和高性能計算已有多年。基於單芯多核處理器(多核處理器)的臺式機，也越來越大眾化。無論擁有幾個處理器，這些機器都能夠真正的並行多個任務。我們稱其為*硬件併發*(hardware concurrency)”。

圖1.1顯示了一個計算機處理恰好兩個任務時的理想情景，每個任務被分為10個相等大小的塊。在一個雙核機器(具有兩個處理核心)上，每個任務可以在各自的處理核心上執行。在單核機器上做任務切換時，每個任務的塊交織進行。但它們中間有一小段分隔(圖中所示灰色分隔條的厚度大於雙核機器的分隔條);為了實現交織進行，系統每次從一個任務切換到另一個時都需要切換一次*上下文*(context switch)，任務切換也有時間開銷。進行上下文的切換時，操作系統必須為當前運行的任務保存CPU的狀態和指令指針，並計算出要切換到哪個任務，併為即將切換到的任務重新加載處理器狀態。然後，CPU可能要將新任務的指令和數據的內存載入到緩存中，這會阻止CPU執行任何指令，從而造成的更多的延遲。

![](../../images/chapter1/1-1.png)

圖 1.1 併發的兩種方式：雙核機器的真正並行 Vs. 單核機器的任務切換

有些處理器可以在一個核心上執行多個線程,但硬件併發在多處理器或多核系統上效果更加顯著。*硬件線程*最重要的因素是數量,也就是硬件上可以併發運行多少獨立的任務。即便是具有真正硬件併發的系統，也很容易擁有比硬件“可並行最大任務數”還要多的任務需要執行，所以任務切換在這些情況下仍然適用。例如，在一個典型的臺式計算機上可能會有成百上千個的任務在運行，即便是在計算機處於空閒時，還是會有後臺任務在運行。正是任務切換使得這些後臺任務可以運行，並使得你可以同時運行文字處理器、編譯器、編輯器和web瀏覽器(或其他應用的組合)。圖1.2顯示了四個任務在雙核處理器上的任務切換，仍然是將任務整齊地劃分為同等大小塊的理想情況。實際上，許多因素會使得分割不均和調度不規則。部分因素將在第8章中討論，那時我們再來看一看影響並行代碼性能的因素。

無論應用程序在單核處理器，還是多核處理器上運行；也不論是任務切換還是真正的硬件併發，這裡提到的技術、功能和類(本書所涉及的)都能使用得到。如何使用併發，將很大程度上取決於可用的硬件併發。我們將在第8章中再次討論這個問題，並具體研究C++代碼並行設計的問題。

![](../../images/chapter1/1-2.png)

圖 1.2 四個任務在兩個核心之間的切換

## 1.1.2 併發的途徑

試想當兩個程序員在兩個獨立的辦公室一起做一個軟件項目，他們可以安靜地工作、不互相干擾，並且他們人手一套參考手冊。但是，他們溝通起來就有些困難，比起可以直接互相交談，他們必須使用電話、電子郵件或到對方的辦公室進行直接交流。並且，管理兩個辦公室需要有一定的經費支出，還需要購買多份參考手冊。

假設，讓開發人員同在一間辦公室辦公，他們可以自由的對某個應用程序設計進行討論，也可以在紙或白板上輕易的繪製圖表，對設計觀點進行輔助性闡釋。現在，你只需要管理一個辦公室，只要有一套參考資料就夠了。遺憾的是，開發人員可能難以集中注意力，並且還可能存在資源共享的問題(比如，“參考手冊哪去了?”)

以上兩種方法，描繪了併發的兩種基本途徑。每個開發人員代表一個線程，每個辦公室代表一個進程。第一種途徑是每個進程只要一個線程，這就類似讓每個開發人員擁有自己的辦公室，而第二種途徑是每個進程有多個線程，如同一個辦公室裡有兩個開發人員。讓我們在一個應用程序中簡單的分析一下這兩種途徑。

##### 多進程併發

使用併發的第一種方法，是將應用程序分為多個獨立的進程，它們在同一時刻運行，就像同時進行網頁瀏覽和文字處理一樣。如圖1.3所示，獨立的進程可以通過進程間常規的通信渠道傳遞訊息(信號、套接字、文件、管道等等)。不過，這種進程之間的通信通常不是設置複雜，就是速度慢，這是因為操作系統會在進程間提供了一定的保護措施，以避免一個進程去修改另一個進程的數據。還有一個缺點是，運行多個進程所需的固定開銷：需要時間啟動進程，操作系統需要內部資源來管理進程，等等。

當然，以上的機制也不是一無是處：操作系統在進程間提供附加的保護操作和更高級別的通信機制，意味著可以更容易編寫安全的併發代碼。實際上，在類似於Erlang的編程環境中，將進程作為併發的基本構造塊。

使用多進程實現併發還有一個額外的優勢———可以使用遠程連接(可能需要聯網)的方式，在不同的機器上運行獨立的進程。雖然，這增加了通信成本，但在設計精良的系統上，這可能是一個提高並行可用行和性能的低成本方式。

![](../../images/chapter1/1-3.png)

圖 1.3 一對併發運行的進程之間的通信

##### 多線程併發

併發的另一個途徑，在單個進程中運行多個線程。線程很像輕量級的進程：每個線程相互獨立運行，且線程可以在不同的指令序列中運行。但是，進程中的所有線程都共享地址空間，並且所有線程訪問到大部分數據———全局變量仍然是全局的，指針、對象的引用或數據可以在線程之間傳遞。雖然，進程之間通常共享內存，但是這種共享通常是難以建立和管理的。因為，同一數據的內存地址在不同的進程中是不相同。圖1.4展示了一個進程中的兩個線程通過共享內存進行通信。

![](../../images/chapter1/1-4.png)

圖 1.4 同一進程中的一對併發運行的線程之間的通信

地址空間共享，以及缺少線程間數據的保護，使得操作系統的記錄工作量減小，所以使用多線程相關的開銷遠遠小於使用多個進程。不過，共享內存的靈活性是有代價的：如果數據要被多個線程訪問，那麼程序員必須確保每個線程所訪問到的數據是一致的(在本書第3、4、5和8章中會涉及，線程間數據共享可能會遇到的問題，以及如何使用工具來避免這些問題)。問題並非無解，只要在編寫代碼時適當地注意即可，這同樣也意味著需要對線程通信做大量的工作。

多個單線程/進程間的通信(包含啟動)要比單一進程中的多線程間的通信(包括啟動)的開銷大，若不考慮共享內存可能會帶來的問題，多線程將會成為主流語言(包括`C++`)更青睞的併發途徑。此外，`C++`標準並未對進程間通信提供任何原生支持，所以使用多進程的方式實現，這會依賴與平臺相關的API。因此，本書只關注使用多線程的併發，並且在此之後所提到“併發”，均假設為多線程來實現。

瞭解併發後，讓來看看為什麼要使用併發。