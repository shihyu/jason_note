# 目錄

* [前言](content/preface/preface-chinese.md)
* [關於封面](content/about_cover_illustration/about_cover_illustration-chinese.md)
* [關於本書](content/about_this_book/about_this_book-chinese.md)
* [第1章 你好，C++的併發世界](content/chapter1/1.0-chinese.md)
	* [1.1 何謂併發](content/chapter1/1.1-chinese.md)
	* [1.2 為什麼使用併發？](content/chapter1/1.2-chinese.md)
	* [1.3 `C++`中的併發和多線程](content/chapter1/1.3-chinese.md)
	* [1.4 開始入門](content/chapter1/1.4-chinese.md)
	* [1.5 本章總結](content/chapter1/1.5-chinese.md)
* [第2章 線程管理](content/chapter2/2.0-chinese.md)
	* [2.1 線程管理的基礎](content/chapter2/2.1-chinese.md)
	* [2.2 向線程函數傳遞參數](content/chapter2/2.2-chinese.md)
	* [2.3 轉移線程所有權](content/chapter2/2.3-chinese.md)
	* [2.4 運行時決定線程數量](content/chapter2/2.4-chinese.md)
	* [2.5 標識線程](content/chapter2/2.5-chinese.md)
	* [2.6 本章總結](content/chapter2/2.6-chinese.md)
* [第3章 線程間共享數據](content/chapter3/3.0-chinese.md)
	* [3.1 共享數據帶來的問題](content/chapter3/3.1-chinese.md)
	* [3.2 使用互斥量保護共享數據](content/chapter3/3.2-chinese.md)
	* [3.3 保護共享數據的替代設施](content/chapter3/3.3-chinese.md)
	* [3.4 本章總結](content/chapter3/3.4-chinese.md)
* [第4章 同步併發操作](content/chapter4/4.0-chinese.md)
	* [4.1 等待一個事件或其他條件](content/chapter4/4.1-chinese.md)
	* [4.2 使用期望等待一次性事件](content/chapter4/4.2-chinese.md)
	* [4.3 限定等待時間](content/chapter4/4.3-chinese.md)
	* [4.4 使用同步操作簡化代碼](content/chapter4/4.4-chinese.md)
	* [4.5 本章總結](content/chapter4/4.5-chinese.md)
* [第5章 `C++`內存模型和原子類型操作](content/chapter5/5.0-chinese.md)
	* [5.1 內存模型基礎](content/chapter5/5.1-chinese.md)
	* [5.2 `C++`中的原子操作和原子類型](content/chapter5/5.2-chinese.md)
	* [5.3 同步操作和強制排序](content/chapter5/5.3-chinese.md)
	* [5.4 本章總結](content/chapter5/5.4-chinese.md)
* [第6章 基於鎖的併發數據結構設計](content/chapter6/6.0-chinese.md)
	* [6.1 為併發設計的意義何在？](content/chapter6/6.1-chinese.md)
	* [6.2 基於鎖的併發數據結構](content/chapter6/6.2-chinese.md)
	* [6.3 基於鎖設計更加複雜的數據結構](content/chapter6/6.3-chinese.md)
	* [6.4 本章總結](content/chapter6/6.4-chinese.md)
* [第7章 無鎖併發數據結構設計](content/chapter7/7.0-chinese.md)
	* [7.1 定義和意義](content/chapter7/7.1-chinese.md)
	* [7.2 無鎖數據結構的例子](content/chapter7/7.2-chinese.md)
	* [7.3 對於設計無鎖數據結構的指導建議](content/chapter7/7.3-chinese.md)
	* [7.4 本章總結](content/chapter7/7.4-chinese.md)
* [第8章 併發代碼設計](content/chapter8/8.0-chinese.md)
	* [8.1 線程間劃分工作的技術](content/chapter8/8.1-chinese.md)
	* [8.2 如何讓數據緊湊？](content/chapter8/8.2-chinese.md)
	* [8.3 為多線程性能設計數據結構](content/chapter8/8.3-chinese.md)
	* [8.4 設計併發代碼的注意事項](content/chapter8/8.4-chinese.md)
	* [8.5 在實踐中設計併發代碼](content/chapter8/8.5-chinese.md)
	* [8.6 本章總結](content/chapter8/8.6-chinese.md)
* [第9章 高級線程管理](content/chapter9/9.0-chinese.md)
	* [9.1 線程池](content/chapter9/9.1-chinese.md)
	* [9.2 中斷線程](content/chapter9/9.2-chinese.md)
	* [9.3 本章總結](content/chapter9/9.3-chinese.md)
* [第10章 多線程程序的測試和調試](content/chapter10/10.0-chinese.md)
	* [10.1 與併發相關的錯誤類型](content/chapter10/10.1-chinese.md)
	* [10.2 定位併發錯誤的技術](content/chapter10/10.2-chinese.md)
	* [10.3 本章總結](content/chapter10/10.3-chinese.md)
* [附錄A `C++`11語言特性簡明參考(部分)](content/appendix_A/A.0-chinese.md)
	* [A.1 右值引用](content/appendix_A/A.1-chinese.md)
	* [A.2 刪除函數](content/appendix_A/A.2-chinese.md)
	* [A.3 默認函數](content/appendix_A/A.3-chinese.md)
	* [A.4 常量表達式函數](content/appendix_A/A.4-chinese.md)
	* [A.5 Lambda函數](content/appendix_A/A.5-chinese.md)
	* [A.6 變參模板](content/appendix_A/A.6-chinese.md)
	* [A.7 自動推導變量類型](content/appendix_A/A.7-chinese.md)
	* [A.8 線程本地變量](content/appendix_A/A.8-chinese.md)
	* [A.9 本章總結](content/appendix_A/A.9-chinese.md)
* [附錄B 併發庫簡要對比](content/appendix_B/B.0-chinese.md)
* [附錄C 消息傳遞框架與完整的ATM示例](content/appendix_C/C.0-chinese.md)
* [附錄D C++線程類庫參考](content/appendix_D/D.0-chinese.md)
	* [D.1 chrono頭文件](content/appendix_D/D.1-chinese.md)
	* [D.2 condition_variable頭文件](content/appendix_D/D.2-chinese.md)
	* [D.3 atomic頭文件](content/appendix_D/D.3-chinese.md)
	* [D.4 future頭文件](content/appendix_D/D.4-chinese.md)
	* [D.5 mutex頭文件](content/appendix_D/D.5-chinese.md)
	* [D.6 ratio頭文件](content/appendix_D/D.6-chinese.md)
	* [D.7 thread頭文件](content/appendix_D/D.7-chinese.md)
* [資源](content/resources/resource.md)
