是否自动生成或自动生成哪个特殊成员函数取决于刚才的规则，许多开发者并不知道这些规则。因此，即使在C++11之前，指导方针是不提供任何或所有用于复制、赋值和销毁的特殊成员函数。\par

\begin{itemize}
	\item C++11之前，这条原则称为“3法则”:要么声明全部三种(复制构造函数、赋值操作符和析构函数)，要么一个都不声明。
	\item 从C++11开始，该规则就变成了“5法则”，通常的表述方式是:要么声明所有5种(复制构造函数、移动构造函数、复制赋值操作符、移动赋值操作符和析构函数)，要么一个都不声明。
\end{itemize}

在这里，声明的意思是:\par

\begin{itemize}
	\item 要么实现 (\{...\})
	\item 或者声明为默认 (=default)
	\item 或声明为已删除 (=delete)
\end{itemize}

当其中一个特殊成员函数被实现、默认或删除时，应该同时实现、默认或删除所有其他四个特殊成员函数。\par

但是，您应该注意这条规则。我建议更多地把它作为一个指导方针，当其中一个特殊成员函数是用户声明的时候，仔细考虑这5个特殊成员函数。\par

为了只启用复制语义，应该使用默认复制特殊成员函数，而不声明特殊的移动成员函数(删除和默认特殊移动成员函数是行不通的，实现它们会使类变得复杂)。如果生成的移动语义创建了无效状态，则建议使用此选项，我们将在关于无效已移动状态的章节中讨论这一点。\par

当应用5规则时，有时开发者使用它来为新的移动操作添加声明，却不理解这意味着什么。开发者只是用=default来声明移动操作，因为已经实现了复制操作，所以他们希望遵循5规则。\par

因此，我通常教授的“5法则”或“3法则”是:\par

\begin{itemize}
	\item 如果声明了复制构造函数、移动构造函数、复制赋值操作符、移动赋值操作符或析构函数，则必须仔细考虑如何处理其他特殊成员函数。
	\item 如果不理解移动语义，只考虑复制构造函数、复制赋值操作符和析构函数(如果声明其中之一)。如果有疑问，可以使用=default声明复制特殊成员函数来禁用移动语义。
\end{itemize}






















































