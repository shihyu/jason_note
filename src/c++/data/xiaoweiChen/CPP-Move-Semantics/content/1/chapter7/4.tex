noexcept在C++11中引入，是为了解决在vector中重新分配元素时不能使用移动语义的问题。\par

原则上，可以用noexcept(条件式)标记每个函数。这不仅有助于像vector重新分配这样的情况(注意，移动构造函数可能会调用其他需要noexcept保证的函数)，还有助于编译器优化代码，因为不需要生成代码来处理异常。所以问题是，应该在哪使用noexcept?\par

对于C++11标准库，会急于确定将noexcept放在哪里(重新分配问题很晚才发现，noexcept的最终语义在发布C++11的那一周才解释清楚)。因此，遵循http://wg21.link/n3279中提出方案是一种相当保守的方法，但对代码编写是一个有用的指导方针。大致来说，指导方针为:\par

\begin{itemize}
	\item 每个库的工作组同意不能抛出异常，且具有“广泛契约”的库函数(即，由于前提条件而没有指定未定义的行为)都应该标记为“无条件的noexcept”。
	\item 如果库中的交换函数、移动构造函数或移动赋值操作符是“条件宽松”的(即，可以通过应用noexcept操作符保证不抛出异常)，则应将其标记为有条件的noexcept。任何其他函数都不应该使用条件noexcept。
	\item 任何标准库析构函数都不应该抛出异常，应该使用隐式提供的(非抛出的)异常规范。
	\item 为兼容C代码而设计的库函数，可以标记为无条件的noexcept。
\end{itemize}

下面的例子阐明了第一项的意思:\par

\begin{itemize}
	\item 对于容器和字符串，成员函数empty()和clear()标记为noexcept，因为没有方法来实现它们并抛出异常。
	\item 即使在正确使用时保证不会抛出异常，vector和string的索引操作符不会标记为noexcept。然而，当传递无效索引时，会出现有未定义的行为。不使用noexcept来声明时，这些实现会在这种情况下抛出异常。
\end{itemize}

第二项是在实现移动语义时应该遵循的指导原则。建议只在实现移动构造函数、移动赋值操作符或swap()函数时，使用条件noexcept。对于所有其他函数，考虑态详细的条件，可能会透露太多的实现细节。\par

对于http://wg21.link/p0884，包装类型也应该有条件noexcept声明:\par

\begin{itemize}
	\item 如果标准库类型具有包装语义，以提供与底层类型相同的行为，则默认构造函数、复制构造函数和复制赋值操作符应有条件地标记为noexcept，而底层异常规范仍然有效。
\end{itemize}

最后，请注意，根据规则，任何析构函数都总是隐式声明为noexcept。\par

代码的应该这么写:\par

\begin{itemize}
	\item 应该实现移动构造函数、移动赋值操作符和一个带有noexcept(条件)的swap()函数。
	\item 对于所有其他函数，在知道不能抛出异常时，就使用无条件的noexcept。
	\item 析构函数不需要noexcept规范。
\end{itemize}







