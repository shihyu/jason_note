# 目錄

* [序言](content/Foreword/Foreword-chinese.md)
* [第1章 簡介異構計算](content/chapter1/1.0-chinese.md)
	* [1.1 關於異構計算](content/chapter1/1.1-chinese.md)
	* [1.2 本書目的](content/chapter1/1.2-chinese.md)
	* [1.3 並行思想](content/chapter1/1.3-chinese.md)
	* [1.4 併發和並行編程模型](content/chapter1/1.4-chinese.md)
	* [1.5 線程和共享內存](content/chapter1/1.5-chinese.md)
	* [1.6 消息通訊機制](content/chapter1/1.6-chinese.md)
	* [1.7 並行性的粒度](content/chapter1/1.7-chinese.md)
	* [1.8 使用OpenCL進行異構計算](content/chapter1/1.8-chinese.md)
	* [1.9 本書結構](content/chapter1/1.9-chinese.md)
* [第2章 設備架構](content/chapter2/2.0-chinese.md)
	* [2.1 介紹](content/chapter2/2.1-chinese.md)
	* [2.2 硬件的權衡](content/chapter2/2.2-chinese.md)
	* [2.3 架構設計空間](content/chapter2/2.3-chinese.md)
	* [2.4 本章總結](content/chapter2/2.4-chinese.md)
* [第3章 介紹OpenCL](content/chapter3/3.0-chinese.md)
	* [3.1 簡介OpenCL](content/chapter3/3.1-chinese.md)
	* [3.2 OpenCL平臺模型](content/chapter3/3.2-chinese.md)
	* [3.3 OpenCL執行模型](content/chapter3/3.3-chinese.md)
	* [3.4 內核和OpenCL編程模型](content/chapter3/3.4-chinese.md)
	* [3.5 OpenCL內存模型](content/chapter3/3.5-chinese.md)
	* [3.6 OpenCL運行時(例子)](content/chapter3/3.6-chinese.md)
	* [3.7 OpenCL C++ Wapper向量加法](content/chapter3/3.7-chinese.md)
	* [3.8 CUDA編程者使用OpenCL的注意事項](content/chapter3/3.8-chinese.md)
* [第4章 OpenCL案例](content/chapter4/4.0-chinese.md)
	* [4.1 OpenCL實例](content/chapter4/4.1-chinese.md)
	* [4.2 直方圖](content/chapter4/4.2-chinese.md)
	* [4.3 圖像旋轉](content/chapter4/4.3-chinese.md)
	* [4.4 圖像卷積](content/chapter4/4.4-chinese.md)
	* [4.5 生產者-消費者](content/chapter4/4.5-chinese.md)
	* [4.6 基本功能函數](content/chapter4/4.6-chinese.md)
	* [4.7 本章總結](content/chapter4/4.7-chinese.md)
* [第5章 OpenCL運行時和併發模型](content/chapter5/5.0-chinese.md)
	* [5.1 命令和排隊模型](content/chapter5/5.1-chinese.md)
	* [5.2 多命令隊列](content/chapter5/5.2-chinese.md)
	* [5.3 內核執行域:工作項、工作組和NDRange](content/chapter5/5.3-chinese.md)
	* [5.4 原生和內置內核](content/chapter5/5.4-chinese.md)
	* [5.5 設備端排隊](content/chapter5/5.5-chinese.md)
	* [5.6 本章總結](content/chapter5/5.6-chinese.md)
* [第6章 OpenCL主機端內存模型](content/chapter6/6.0-chinese.md)
	* [6.1 內存對象](content/chapter6/6.1-chinese.md)
	* [6.2 內存管理](content/chapter6/6.2-chinese.md)
	* [6.3 共享虛擬內存](content/chapter6/6.3-chinese.md)
	* [6.4 本章總結](content/chapter6/6.4-chinese.md)
* [第7章 OpenCL設備端內存模型](content/chapter7/7.0-chinese.md)
	* [7.1 同步和交互](content/chapter7/7.1-chinese.md)
	* [7.2 全局內存](content/chapter7/7.2-chinese.md)
	* [7.3 常量內存](content/chapter7/7.3-chinese.md)
	* [7.4 局部內存](content/chapter7/7.4-chinese.md)
	* [7.5 私有內存](content/chapter7/7.5-chinese.md)
	* [7.6 統一地址空間](content/chapter7/7.6-chinese.md)
	* [7.7 內存序](content/chapter7/7.7-chinese.md)
	* [7.8 本章總結](content/chapter7/7.8-chinese.md)
* [第8章 異構系統下解析OpenCL](content/chapter8/8.0-chinese.md)
	* [8.1 AMD FX-8350 CPU](content/chapter8/8.1-chinese.md)
	* [8.2 AMD RADEON R9 290X CPU](content/chapter8/8.2-chinese.md)
	* [8.3 OpenCL內存性能的考量](content/chapter8/8.3-chinese.md)
	* [8.4 本章總結](content/chapter8/8.4-chinese.md)
* [第9章 案例分析：圖像聚類](content/chapter9/9.0-chinese.md)
	* [9.1 圖像聚類簡介](content/chapter9/9.1-chinese.md)
	* [9.2 直方圖的特性——CPU實現](content/chapter9/9.2-chinese.md)
	* [9.3 OpenCL實現](content/chapter9/9.3-chinese.md)
	* [9.4 性能分析](content/chapter9/9.4-chinese.md)
	* [9.5 本章總結](content/chapter9/9.5-chinese.md)
* [第10章 OpenCL的分析和調試](content/chapter10/10.0-chinese.md)
	* [10.1 設置本章的原因](content/chapter10/10.1-chinese.md)
	* [10.2 使用事件分析OpenCL代碼](content/chapter10/10.2-chinese.md)
	* [10.3 AMD CodeXL](content/chapter10/10.3-chinese.md)
	* [10.4 如何使用AMD CodeXL](content/chapter10/10.4-chinese.md)
	* [10.5 使用CodeXL分析內核](content/chapter10/10.5-chinese.md)
	* [10.6 使用CodeXL調試OpenCL內核](content/chapter10/10.6-chinese.md)
	* [10.7 使用`printf`調試](content/chapter10/10.7-chinese.md)
	* [10.8 本章總結](content/chapter10/10.8-chinese.md)
* [第11章 高級語言映射到OpenCL2.0 —— 從編譯器作者的角度](content/chapter11/11.0-chinese.md)
	* [11.1 簡要介紹現狀](content/chapter11/11.1-chinese.md)
	* [11.2 簡單介紹C++ AMP](content/chapter11/11.2-chinese.md)
	* [11.3 編譯器的目標 —— OpenCL 2.0](content/chapter11/11.3-chinese.md)
	* [11.4 C++ AMP與OpenCL對比](content/chapter11/11.4-chinese.md)
	* [11.5 C++ AMP的編譯流](content/chapter11/11.5-chinese.md)
	* [11.6 編譯之後的C++ AMP代碼](content/chapter11/11.6-chinese.md)
	* [11.7 OpenCL 2.0提出共享虛擬內存的原因](content/chapter11/11.7-chinese.md)
	* [11.8 編譯器怎樣支持C++ AMP的線程塊劃分](content/chapter11/11.8-chinese.md)
	* [11.9 地址空間的推斷](content/chapter11/11.9-chinese.md)
	* [11.10 優化數據搬運](content/chapter11/11.10-chinese.md)
	* [11.11 完整例子:二項式](content/chapter11/11.11-chinese.md)
	* [11.12 初步結果](content/chapter11/11.12-chinese.md)
	* [11.13 本章總結](content/chapter11/11.13-chinese.md)
* [第12章 WebCL：使用OpenCL加速Web應用](content/chapter12/12.0-chinese.md)
	* [12.1 介紹WebCL](content/chapter12/12.1-chinese.md)
	* [12.2 如何使用WebCL編程](content/chapter12/12.2-chinese.md)
	* [12.3 同步機制](content/chapter12/12.3-chinese.md)
	* [12.4 WebCL的交互性](content/chapter12/12.4-chinese.md)
	* [12.5 應用實例](content/chapter12/12.5-chinese.md)
	* [12.6 增強安全性](content/chapter12/12.6-chinese.md)
	* [12.7 服務器端使用WebCL](content/chapter12/12.7-chinese.md)
	* [12.8 WebCL的狀態和特性](content/chapter12/12.8-chinese.md)
* [第13章 其他高級語言中OpenCL的使用](content/chapter13/13.0-chinese.md)
	* [13.1 本章簡介](content/chapter13/13.1-chinese.md)
	* [13.2 越過C和C++](content/chapter13/13.2-chinese.md)
	* [13.3 Haskell中使用OpenCL](content/chapter13/13.3-chinese.md)
	* [13.4 本章總結](content/chapter13/13.4-chinese.md)
