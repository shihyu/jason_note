# 目录

* [序言](content/Foreword/Foreword-chinese.md)
* [第1章 简介异构计算](content/chapter1/1.0-chinese.md)
	* [1.1 关于异构计算](content/chapter1/1.1-chinese.md)
	* [1.2 本书目的](content/chapter1/1.2-chinese.md)
	* [1.3 并行思想](content/chapter1/1.3-chinese.md)
	* [1.4 并发和并行编程模型](content/chapter1/1.4-chinese.md)
	* [1.5 线程和共享内存](content/chapter1/1.5-chinese.md)
	* [1.6 消息通讯机制](content/chapter1/1.6-chinese.md)
	* [1.7 并行性的粒度](content/chapter1/1.7-chinese.md)
	* [1.8 使用OpenCL进行异构计算](content/chapter1/1.8-chinese.md)
	* [1.9 本书结构](content/chapter1/1.9-chinese.md)
* [第2章 设备架构](content/chapter2/2.0-chinese.md)
	* [2.1 介绍](content/chapter2/2.1-chinese.md)
	* [2.2 硬件的权衡](content/chapter2/2.2-chinese.md)
	* [2.3 架构设计空间](content/chapter2/2.3-chinese.md)
	* [2.4 本章总结](content/chapter2/2.4-chinese.md)
* [第3章 介绍OpenCL](content/chapter3/3.0-chinese.md)
	* [3.1 简介OpenCL](content/chapter3/3.1-chinese.md)
	* [3.2 OpenCL平台模型](content/chapter3/3.2-chinese.md)
	* [3.3 OpenCL执行模型](content/chapter3/3.3-chinese.md)
	* [3.4 内核和OpenCL编程模型](content/chapter3/3.4-chinese.md)
	* [3.5 OpenCL内存模型](content/chapter3/3.5-chinese.md)
	* [3.6 OpenCL运行时(例子)](content/chapter3/3.6-chinese.md)
	* [3.7 OpenCL C++ Wapper向量加法](content/chapter3/3.7-chinese.md)
	* [3.8 CUDA编程者使用OpenCL的注意事项](content/chapter3/3.8-chinese.md)
* [第4章 OpenCL案例](content/chapter4/4.0-chinese.md)
	* [4.1 OpenCL实例](content/chapter4/4.1-chinese.md)
	* [4.2 直方图](content/chapter4/4.2-chinese.md)
	* [4.3 图像旋转](content/chapter4/4.3-chinese.md)
	* [4.4 图像卷积](content/chapter4/4.4-chinese.md)
	* [4.5 生产者-消费者](content/chapter4/4.5-chinese.md)
	* [4.6 基本功能函数](content/chapter4/4.6-chinese.md)
	* [4.7 本章总结](content/chapter4/4.7-chinese.md)
* [第5章 OpenCL运行时和并发模型](content/chapter5/5.0-chinese.md)
	* [5.1 命令和排队模型](content/chapter5/5.1-chinese.md)
	* [5.2 多命令队列](content/chapter5/5.2-chinese.md)
	* [5.3 内核执行域:工作项、工作组和NDRange](content/chapter5/5.3-chinese.md)
	* [5.4 原生和内置内核](content/chapter5/5.4-chinese.md)
	* [5.5 设备端排队](content/chapter5/5.5-chinese.md)
	* [5.6 本章总结](content/chapter5/5.6-chinese.md)
* [第6章 OpenCL主机端内存模型](content/chapter6/6.0-chinese.md)
	* [6.1 内存对象](content/chapter6/6.1-chinese.md)
	* [6.2 内存管理](content/chapter6/6.2-chinese.md)
	* [6.3 共享虚拟内存](content/chapter6/6.3-chinese.md)
	* [6.4 本章总结](content/chapter6/6.4-chinese.md)
* [第7章 OpenCL设备端内存模型](content/chapter7/7.0-chinese.md)
	* [7.1 同步和交互](content/chapter7/7.1-chinese.md)
	* [7.2 全局内存](content/chapter7/7.2-chinese.md)
	* [7.3 常量内存](content/chapter7/7.3-chinese.md)
	* [7.4 局部内存](content/chapter7/7.4-chinese.md)
	* [7.5 私有内存](content/chapter7/7.5-chinese.md)
	* [7.6 统一地址空间](content/chapter7/7.6-chinese.md)
	* [7.7 内存序](content/chapter7/7.7-chinese.md)
	* [7.8 本章总结](content/chapter7/7.8-chinese.md)
* [第8章 异构系统下解析OpenCL](content/chapter8/8.0-chinese.md)
	* [8.1 AMD FX-8350 CPU](content/chapter8/8.1-chinese.md)
	* [8.2 AMD RADEON R9 290X CPU](content/chapter8/8.2-chinese.md)
	* [8.3 OpenCL内存性能的考量](content/chapter8/8.3-chinese.md)
	* [8.4 本章总结](content/chapter8/8.4-chinese.md)
* [第9章 案例分析：图像聚类](content/chapter9/9.0-chinese.md)
	* [9.1 图像聚类简介](content/chapter9/9.1-chinese.md)
	* [9.2 直方图的特性——CPU实现](content/chapter9/9.2-chinese.md)
	* [9.3 OpenCL实现](content/chapter9/9.3-chinese.md)
	* [9.4 性能分析](content/chapter9/9.4-chinese.md)
	* [9.5 本章总结](content/chapter9/9.5-chinese.md)
* [第10章 OpenCL的分析和调试](content/chapter10/10.0-chinese.md)
	* [10.1 设置本章的原因](content/chapter10/10.1-chinese.md)
	* [10.2 使用事件分析OpenCL代码](content/chapter10/10.2-chinese.md)
	* [10.3 AMD CodeXL](content/chapter10/10.3-chinese.md)
	* [10.4 如何使用AMD CodeXL](content/chapter10/10.4-chinese.md)
	* [10.5 使用CodeXL分析内核](content/chapter10/10.5-chinese.md)
	* [10.6 使用CodeXL调试OpenCL内核](content/chapter10/10.6-chinese.md)
	* [10.7 使用`printf`调试](content/chapter10/10.7-chinese.md)
	* [10.8 本章总结](content/chapter10/10.8-chinese.md)
* [第11章 高级语言映射到OpenCL2.0 —— 从编译器作者的角度](content/chapter11/11.0-chinese.md)
	* [11.1 简要介绍现状](content/chapter11/11.1-chinese.md)
	* [11.2 简单介绍C++ AMP](content/chapter11/11.2-chinese.md)
	* [11.3 编译器的目标 —— OpenCL 2.0](content/chapter11/11.3-chinese.md)
	* [11.4 C++ AMP与OpenCL对比](content/chapter11/11.4-chinese.md)
	* [11.5 C++ AMP的编译流](content/chapter11/11.5-chinese.md)
	* [11.6 编译之后的C++ AMP代码](content/chapter11/11.6-chinese.md)
	* [11.7 OpenCL 2.0提出共享虚拟内存的原因](content/chapter11/11.7-chinese.md)
	* [11.8 编译器怎样支持C++ AMP的线程块划分](content/chapter11/11.8-chinese.md)
	* [11.9 地址空间的推断](content/chapter11/11.9-chinese.md)
	* [11.10 优化数据搬运](content/chapter11/11.10-chinese.md)
	* [11.11 完整例子:二项式](content/chapter11/11.11-chinese.md)
	* [11.12 初步结果](content/chapter11/11.12-chinese.md)
	* [11.13 本章总结](content/chapter11/11.13-chinese.md)
* [第12章 WebCL：使用OpenCL加速Web应用](content/chapter12/12.0-chinese.md)
	* [12.1 介绍WebCL](content/chapter12/12.1-chinese.md)
	* [12.2 如何使用WebCL编程](content/chapter12/12.2-chinese.md)
	* [12.3 同步机制](content/chapter12/12.3-chinese.md)
	* [12.4 WebCL的交互性](content/chapter12/12.4-chinese.md)
	* [12.5 应用实例](content/chapter12/12.5-chinese.md)
	* [12.6 增强安全性](content/chapter12/12.6-chinese.md)
	* [12.7 服务器端使用WebCL](content/chapter12/12.7-chinese.md)
	* [12.8 WebCL的状态和特性](content/chapter12/12.8-chinese.md)
* [第13章 其他高级语言中OpenCL的使用](content/chapter13/13.0-chinese.md)
	* [13.1 本章简介](content/chapter13/13.1-chinese.md)
	* [13.2 越过C和C++](content/chapter13/13.2-chinese.md)
	* [13.3 Haskell中使用OpenCL](content/chapter13/13.3-chinese.md)
	* [13.4 本章总结](content/chapter13/13.4-chinese.md)
