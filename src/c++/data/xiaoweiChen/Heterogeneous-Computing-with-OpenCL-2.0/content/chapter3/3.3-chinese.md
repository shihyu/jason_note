#3.3 OpenCL執行模型

OpenCL執行模型允許我們建立一個拓撲系統來協調主處理器和其他能夠執行OpenCL 內核的設備。為了讓內核執行在設備上，還需要對OpenCL上下文進行設置，進而傳遞執行命令和數據到設備端。

##3.3.1 上下文

OpenCL中上下文為了內核的正確執行，進行協調和內存管理。上下文是為了協調主機和設備端的交互，管理設備端可用的內存對象，並持續跟蹤在設備上創建出來的程序對象和內核對象。上下文對象可以通過OpenCL API`clCreateContext()`進行創建。

```c++
cl_context
clCreateContext(
  const cl_context_properties *properties,
  cl_uint num_devices,
  const cl_device_id *devices,
  void (CL_CALL_BACK *pfn_notify)(
    const char *errinfo,
	const void *private_info,
	size_t cb,
	void *user_data),
  void *user_data,
  cl_int *errcode_ret)
```

`properties`參數用於限制上下文作用的範圍。這個參數可由特定的平臺提供，其能夠使能與圖像的互用性，或使能其他能力。通過限制給定平臺的上下文，允許編程者使用多個平臺創建的不同的上下文，並且能在一個平臺中混用多個供應商提供的設備。另外，創建上下文時必須要使用設備對象，並且編程者可以設置一個用戶回調函數，還可以額外傳遞一個錯誤碼(需要在錯誤碼對象的生命週期內)用於獲取API運行的狀態。

OpenCL提供了另一個API也能用來創建上下文，其能使用設備列表來創建上下文。通過`clCreateContextFromType()`可以使用所有的設備類型(CPU、GPU和ALL)創建上下文。創建上下文之後，可以通過使用`clGetContextInfo()`來查詢上下文中設備的數量，以及具體的設備對象。OpenCL中可使用上下文查詢指定平臺對象和設備對象，通過以上的步驟即可創建上下文，這些步驟也可用於任意OpenCL程序。

##3.3.2 命令隊列

執行模型是指設備端執行的任務，是基於主機端發送的命令。命令指定的行為包括執行內核，進行數據傳遞和執行同步。某些設備也能自發一些命令，這種設備以及方式，我們在後面的章節中再進行討論。

命令隊列作為一種通信機制，可以讓host發請求到對應的device。當host需要device執行任務的時候，就需要一個命令隊列。命令隊列需要在每個設備上都進行創建，並且命令隊列要在上下文的基礎上進行創建。host需要將一條命令提交到對應的命令隊列中，因為命令隊列不是以分發的形式，而是以指定的形式，所以如果平臺上有多個設備時，就需要每個設備上創建一個命令隊列。OpenCL中`clCreateCommandQueueWithProperties()`就是用來創建命令隊列，且將命令隊列與一個device進行關聯。

```c++
cl_command_queue
clCreateCommandQueueWithProperties(
  cl_context context,
  cl_device_id device,
  cl_command_queue_properties peoperties,
  cl_int *errcode_ret)
```

`peoperties`參數是由一個位域值組成，其可使能命令性能分析功能(CL_QUEUE_PROFILING_ENABLE)，以及/或允許命令亂序執行(CL_QUEUE_OUT_OF_DRDER_EXEC_MODE_ENABLE)。這兩個功能將在第5章詳細討論。

對於順序命令隊列(默認創建)，會將命令順序的推入對應的隊列中。亂序命令隊列允許OpenCL實現不按入隊順序執行對應的命令，這樣的執行方式在某種情況下更為高效。如果使用亂序命令隊列，其會根據用戶指定的依賴關係，按正確的命令依賴順序進行執行。

任何以`clEnqueue`開頭的OpenCL API都能向命令隊列提交一個命令，並且這些API都需要一個命令隊列對象作為輸入參數。例如，`clEnqueueReadBuffer()`將device上的數據傳遞到host，`clEnqueueNDRangeKernel()`申請一個內核在對應device執行。如何調用這些API將在後續的章節中進行討論。

除了向命令隊列提交命令的API，OpenCL還包括執行柵欄操作API，這種操作可以用來同步命令隊列。`clFlush()`和`clFinish()`這兩個API都能對命令隊列進行柵欄操作。其中，`clFinish()`的調用將會阻塞host上的執行線程，直到命令隊列上的所有命令執行完畢，其功能就是和同步柵欄操作一樣。`clFlush()`將會阻塞host上的執行線程，直到命令隊列上的命令都從隊列上移出。移出命令隊列後的命令，就已經提交到device端，不過不一定完全執行完成。這兩個API都需要一個命令隊列作為參數。

```c++
cl_int clFlush(cl_command_queue command_queue);
cl_int clFinish(cl_command_queue command_queue);
```

##3.3.3 事件

OpenCL API中，用來指定命令之間依賴關係的對象稱為事件(event)，所有的`clEnqueue`開頭的API，均有三個共同的參數：事件鏈表的指針，其指定了當前命令依賴的事件列表，等待列表的長度，以及表示當前命令執行的事件指針，這個指針用於依賴該命令的其他命令。使用事件來指定依賴關係的方式將在第5章介紹。

除了能提供命令依賴順序，還能通過事件對命令執行的狀態隨時進行查詢。當事件所對應的命令處以執行狀態時，其狀態就會發生變化。命令狀態一共有以下6中：

- **Queued**：命令處於命令隊列中。
- **Submitted**：命令從命令隊列中移除，已經提交到設備端執行。
- **Ready**：命令已經準備好在設備上執行。
- **Running**：命令正在設備上執行。
- **Ended**：命令已經在設備上執行完成。
- **Complete**：所有命令以及其子命令都執行完成。

子命令與設備端入隊有關，我們會在下一節進行討論。當命令成功的執行完成，事件的狀態將會被設置為`CL_COMPLETE`。如果命令非正常終止，事件的狀態將會為一個負數值。這種情況下，有非正常終止的命令隊列，以及其他在同一上下文上創建的命令隊列，都將不能正常使用或運行。查詢事件所使用的API為`clGetEventInfo()`。

除了記錄了不同入隊命令間的依賴關係，OpenCL也提供了用於和host同步的API`clWaitForEvents()`，該API阻塞host的執行線程，等待指定事件隊列上的所有命令執行完畢。

```c++
cl_int
clWaitForEvents(
  cl_uint num_events,
  const cl_event *event_list)
```

##3.3.4 設備端入隊

目前為止，我們所描述的執行模型是依據“老闆-職員”式例來說的，host(老闆)向device(職員)發送命令。這樣的模型提供了一種簡單的主從合作模式。不過，在很多情況下任務的分發並不能靜態確定——尤其是算法的下一個階段要依賴上一個階段的結果。例如，在組合優化的應用中，查詢範圍的大小決定著工作組的數量，不過，範圍大小隻有在上一次迭代的時候才能知道。之前版本的OpenCL，處理這種情況通常是使用一個新的內核對象來執行下一階段的任務。為了滿足這個需求，以及提升性能，OpenCL 2.0為執行模型添加了一項新的特性——設備端入隊。

執行中的內核現在可以讓另外一個內核進入命令隊列中(具體可以看圖3.5)。這種情況下，正在執行的內核可以稱為“父內核”，剛入隊的內核稱為“子內核”。雖然，父子內核是以異步的方式執行，但是父內核需要在子內核全部結束後才能結束。我們可通過與父內核關聯的事件對象來對執行狀態進行查詢，當事件對象的狀態為CL_COMPLETE時，就代表父內核結束執行。設備端的命令隊列是無序命令隊列，其具有無序命令隊列的所有特性。設備端命令會進入到設備端產生的命令隊列中，並且使用事件的方式來存儲各個命令間的依賴關係。這些事件對象只有執行在設備端的父內核可見。更多有關設備端入隊的內容，將會在第5章進行討論。