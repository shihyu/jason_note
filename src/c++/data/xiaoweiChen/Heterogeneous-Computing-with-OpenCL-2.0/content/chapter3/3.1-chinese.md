#3.1 簡介OpenCL

本章就來介紹一下OpenCL，使用OpenCL可以讓我們的程序內部併發的執行。編程者們只要熟悉C和C++，上手OpenCL幾乎就不是什麼難事。我們先從OpenCL的標準說起。

##3.1.1 OpenCL標準

OpenCL最初由蘋果公司(Apple)提出(其他合作公司有AMD，IBM，Qualcomm(高通)，Intel和NVIDIA)，之後交由非盈利組織Khronos維護。最初的1.0版標準，由Khronos在2008年發佈。OpenCL 1.0定義了主機端的接口，以及使用C語言作為OpenCL內核書寫的語言，內核就是在不同的異構設備上並行處理數據的單位。之後的幾年，發佈了OpenCL 1.1和OpenCL 1.2，新標準為OpenCL增加了很多特性，比如：提高與OpenGL的互動性，補充了很多圖像格式，同步事件，設備劃分等特性。2013年11月，Khronos組織正式發佈了OpenCL 2.0標準。為OpenCL添加了更多的新特性，比如：共享虛擬內存、內核嵌套並行和通用地址空間。這些更加高級的功能會讓並行開發變得越來越簡單，並且提高了OpenCL應用執行的效率。

開源編程標準設計者也要面對很多的挑戰，為了形成一套通用的編程標準，要對一些要求進行一定的取捨。Khronos在這方面做得很不錯，其設計的API都能很好的兼容不同的架構，並且能讓硬件發揮其最大的性能。只要正確的遵循編程標準，那麼一套程序幾乎不用做什麼修改，就可以從一個硬件平臺，移植到另一個硬件平臺上。供應商和設備分離的編程模型給OpenCL帶來了極佳的可移植性，使其能充分發揮不同平臺的加速能力。

執行在OpenCL設備上的代碼，與執行在CPU上的不同，其使用OpenCL C進行書寫。OpenCl C遵循更加嚴格的C99標準，在此基礎上進行了適當的擴展，使其能在各種異構設備上以數據並行的方式執行。新標準中OpenCL C編程實現了C11標準中的原子操作(其子集)和同步操作。因為OpenCL API本身是C API，那麼第三方就將其綁定到很多語言上，比如：Java，C++，Python和.NET。除此之外，很多主流庫(線性代數和機器視覺)都集成了OpenCL，為的就是在異構平臺上獲得實質性的性能提升。

##3.1.2 OpenCL標準

OpenCL標準分為四部分，每一部分都用“模型”來定義。這裡先簡單的介紹一下，之後的章節中會進行詳細的介紹：

**平臺模型**：指定一個host處理器，用於任務的調度。以及一個或多個device處理器，用於執行OpenCL任務(OpenCL C Kernel)。這裡將硬件抽象成了對應的設備(host或device)。

**執行模型**：定義了OpenCL在host上運行的環境應該如何配置，以及host如何指定設備執行某項工作。這裡就包括host運行的環境，host-device交互的機制，以及配置內核時使用到的併發模型。併發模型定義瞭如何將算法分解成OpenCL工作項和工作組。

**內核編程模型**：定義了併發模型如何映射到實際物理硬件。

**內存模型**：定義了內存對象的類型，並且抽象了內存層次，這樣內核就不用瞭解其使用內存的實際架構。其也包括內存排序的要求，並且選擇性支持host和device的共享虛擬內存。

通常情況下，OpenCL實現的執行平臺包括一個x86 CPU主處理器，和一個GPU設備作為加速器。主處理器會將內核放置在GPU上運行，並且發出指令讓GPU按照某個特定的並行方式進行執行。內核使用到的內存數據都由編程者依據層級內存模型分配或開闢。運行時和驅動層會將抽象的內存區域映射到物理內存層面。最後，由GPU開闢硬件線程來對內核進行執行，並且將每個線程映射到對應的硬件單元上。這些模型的細節將會在之後進行詳細的討論。

本章開始介紹OpenCL模型，包括OpenCL的API和相關的模型。介紹完API之後，我們將會使用矢量相加的例子讓大家更好地對OpenCL編程進行了解。矢量相加的源碼會在3.6節的末尾給出。我們將會使用OpenCL C++ API對矢量相加進行實現，並對CUDA編程和OpenCL編程進行比較。