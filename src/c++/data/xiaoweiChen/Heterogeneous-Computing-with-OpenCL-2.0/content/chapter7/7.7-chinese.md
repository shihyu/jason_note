#7.7 內存序

對於任何編程語言來說，內存序對於內存模型來說十分重要，需要用一定的順序來保證線程得到的是期望的結果。當我們使用多線程和共享數據時，內存一致性模型能幫助保證線程得到的是正確的結果。OpenCL需要提供可移植化的高度並行代碼，那麼內存模型在正式發佈的標準文檔中就尤為重要。

之前我們提到過，執行內核中的所有工作項都可以訪問全局內存上的數據。另外，在同一工作組的工作項可以共享局部內存。直到現在，我們在處理內存時，更多的是使用OpenCL的“鬆散型”一致模型。對於全局內存，我們沒有使用更加複雜的內存模型，並且默認讓不同工作組中的工作項更新不同位置的全局內存。關於更新內存對象，我們不能認為和該對象有關的命令狀態為CL_COMPLETE時，內存對象更新完成。在實踐中，簡單的內存模型覆蓋了絕大多數的內核。第4章中，我們看到這種內存一致性模型也能支持直方圖和卷積相關的應用。

近幾年中，C/C++和Java都在支持“獲取-釋放”操作，為了就是在不使用鎖的情況下，進行線程同步。這些操作有助於並行應用中核心代碼的處理。OpenCL 2.0在基於C11標準的基礎上，也支持“獲取-釋放”操作。另外，OpenCL的開發者可以將這種問題解決方式擴展到其他類型的應用上，使得支持OpenCL的高級語言可以更加容易進行線程同步。

對於編程者來說，順序一致模型是最為直觀的內存模型。如果系統由順序一致模型實現，那麼各個處理器上的內存操作將會按照程序的執行順序進行，並且所有處理器上的操作順序一致。不過，對於順序一致性模型很難進行優化，因為對程序的正確性沒有影響(比如，由編譯器重拍指令順序或在處理器上使用一個存儲內存塊)。因此，鬆散的內存模型需要和順序一致性模型輸出一樣的結果才算正確。鬆散序一致性模型需要硬件和軟件遵循某些規則，才能得到正確的結果。對於編程者來說，需要花點時間告訴硬件，數據在什麼時候才能對其他線程可見。

不過有時同步操作，會成為程序性能的瓶頸。因此，OpenCL提供對應不同類型選項，供同步操作使用(供編程者指定)，每種選項的粒度都有不同的粒度和範圍。這些選項稱為*內存序*(memory order)和*內存域*(memory scope)。

OpenCL提供三種不同程度的一致性順序(從弱到強)：鬆散、獲取-釋放和順序。這些選項則由內存序選項指定：

- **鬆散**(memory_order_relaxed):這種內存序不會對內存序有任何的約束——編譯器可以自由的對操作進行重排，包括後續的加載和存儲操作。不過該方式可能會帶來一些副作用，可能會造成結果錯誤。2.0之前的OpenCL標準中，原子操作就包含在鬆散的內存序中。因為缺少限制，所以編程者可能使用鬆散序獲得最好的性能。
- **獲取**(memory_order_acquire):獲取操作和加載操作成對出現。當為同步操作指定該選項時，任何共享內存需要被其他執行單元(例如，其他工作項，或主機端線程)“釋放”後才能進行存儲。編譯器需要將加載和存儲操作移到同步操作之後。
- **釋放**(memory_order_release):與獲取操作不同，釋放操作會和存儲操作成對出現。當為同步操作指定釋放序時，其會影響同步點之前的存儲操作，使其操作對其他線程可見，並且在同步點之前的所有加載操作，必須在達到同步點前全部完成。編譯器會將加載和同步操作移至同步點之前。
- **獲取-釋放**(memory_order_acq_rel):該內存序具有獲取和釋放的屬性：其會在獲取到其他執行單元的內存時，釋放自己所獲取的內存。這個選項通常用於“讀改寫”操作。
- **順序**(memory_order_seq_cst):順序一致性的內存序不存在數據數據競爭[1]。該內存序中，加載和存儲操作的執行順序和程序的執行順序一致，這樣加載和存儲操作也就是簡單的交錯與不同的執行單元中。該選項要比memory_order_acq_rel更加嚴格，因為最後程序可以說是在串行執行。

當對全局內存進行同步時，指定內存序帶來的性能開銷，可能要超過計算時的開銷。試想一個系統中具有多個設備，共享一個上下文，並且包含一個細粒度的SVM內存。當某個工作項使用釋放型同步操作，那麼就需要對所有設備上的工作項進行同步——如果不考慮算法的正確性，這將帶來很大的性能開銷。因此，對於很多操作來說，內存序參數會伴隨一個內存域，其限制了指定執行單元可見操作的範圍。

可以作為內存域指定的選項如下：

- 工作項(memory_scope_work_item):指定內存序要應用到每個工作項中。這裡需要對圖像對象進行行操作。
- 工作組(memory_scope_work_group):指定的內存序應用於工作組中的每個工作項。這個操作與柵欄操作相比，相當於一個輕量級的同步。
- 設備(memory_scope_device):指定內存序用於某一個執行設備。
- 所有設備(memory_scope_all_svm_devices):指定內存序應用於所有設備上的所有工作項，以及主機端(對細粒度SVM使用原子操作)。

與訪問全局內存不同，訪問局部內存不需要指定內存域(實際上指定了也會忽略)——局部原子操作通常具有默認內存域memory_scope_work_group。因為局部內存的訪問只在同一工作組中存在，所以在外部設置memory_scope_device和memory_scope_all_svm_devices對於局部內存沒有任何意義。

##7.7.1 原子訪問

本章開始時，我們說到OpenCL 2.0支持原子操作。那麼就來介紹一下內存序和內存域，這裡我們簡單的回顧一下原子操作。

回想一下我們介紹過的原子操作，比如：加載、存儲和“預取後修改”。我們展示一下“預取後修改”操作的函數聲明：

```c++
C atomic_fetch_<key>(volatile A *object, M operand)
```

這裡的key可以替換成add、min或max。object參數為一種原子類型的變量的指針，operand代表操作數。返回值C，其類型是非原子的A類型。返回值時object地址中存儲的值，這個返回值是沒有進行操作前的數值。

上面的描述中，可以認為C/C++和OpenCL 2.0利用原子操作對內存序進行控制。因此，所有的原子操作都具有傳入內存序和內存域的原子操作。例如，“預取後修改”函數具有以下函數聲明：

```c++
C atomic_fetch_<key>_explicit(volatile A *object, M operand, memory_order order)

C atomic_fetch_<key>_explicit(volatile A *object, M operand, memory_order order, memory_scope scope)
```

通過這樣的設計，就可以將線程間同步的任務交給原子操作來完成了。使用原子操作來做的同步的原因：其設置的標識可以讓其他線程知道，應該在什麼時候對某個區域的內存進行訪問。因此，當一個線程想要看到其他線程所修改的內存時，通過對原子操作進行設置一些標誌，然後等待共享數據釋放。其他線程需要讀取對應標誌，在條件滿足的情況下，將最後更新的數據拷貝到共享內存中。

另外，OpenCL除了支持加載、存儲和“預取後修改”類型的原子操作之外，還支持交換、“比較後交換”和“測試後設置”類型的原子操作。這裡列出一個“比較後交換”函數的聲明：

```c++
bool
atomic_compare_exchange_strong_explicit(
  volatile A *object,
  C *expected,
  C desired,
  memory_order success,
  memory_order failure,
  memory_scope scope)
```

與之前看到函數聲明不一樣atomic_compare_exchange_strong_explicit()具有兩個內存序參數——success和failure。這兩個參數指定的是當比較操作成功和沒成功時所使用到的內存序。編程者可以使用這種操作，來控制沒有必要同步操作。比如，編程者將memory_order_relaxed傳入failure，就是想在條件不成功的時候，不讓工作項等待交換完成。

我們之前一直在討論原子操作如何使用，並沒有討論如何對原子操作進行初始化。OpenCL C有兩種方式對原子操作的操作域進行初始化。在程序範圍內聲明一個原子變量，可以使用ATOMIC_VAR_INIT()宏，該宏的聲明如下所示：

```c++
#define ATOMIC_VAR_INIT(C value)
```

這種方式初始化的原子對象是在程序域內進行聲明，且分配在去全局地址空間內。例如：

```c++
global atomic_int sync = ATOMIC_VAR_INIT(0);
```

原子變量在內核端需要使用非原子函數atomic_init()進行聲明和初始化。注意，因為atomic_init()是非原子函數，但是也不能被多個工作項同時調用。也就是，初始化需要串行且同步的進行，例如下面代碼所示：

```c++
local atomic_int sync;
if (get_local_id(0) == 0){
  atomic_init(&sync, 0);
}
work_group_barrier(CLK_LOCAL_MEM_FENCE);
```

##7.7.2 柵欄

柵欄同步操作與內存的位置無關。雖然，實踐中我們使用柵欄對工作組進行同步，但是我們從來沒有說過柵欄操作如何使用內存序。在OpenCL C中，柵欄操作可以由atomic_work_item_fence()函數執行，其聲明如下：

```c++
void
atomic_work_item_fence(
  cl_mem_fence_flags flags,
  memory_order order,
  memory_scope scope)
```

flags參數可以傳入CLK_GLOBAL_MEM_FENCE, CLK_LOCAL_MEM_FENCE和CLK_IMAGE_MEM_FENCE，或將這幾個參數使用“位或”(OR)的方式共同傳入。共同傳入的方式，與單獨傳入的效果是一樣的。

很多系統上圖像對象還是限制在非通用顯示硬件上。OpenCL標準當然也注意到了這點，所以可向atomic_work_item_fence()傳入CLK_IMAGE_MEM_FENCE，來保證圖像對象在寫之後才可讀——即使對同一個工作項。如果有多個工作項要進行同步，然後可以讀取同一工作組中前一工作項所寫入圖像中的數據，最後需要使用CLK_IMAGE_MEM_FENCE作為參數傳入work_group_barrier()。另一種特別的方式，可以使用工作項柵欄對局部和全局內存的訪問順序進行統一控制。

之前我們介紹過，使用工作組柵欄和內存柵欄作為同步操作。理論上，這還是兩種柵欄操作——就像出入柵欄一樣。入欄就是指定標誌和作用域釋放柵欄。同樣的，出欄也需要指定對應的標誌和作用域。

-------------

[1] 多線程/多工作項訪問同一變量會產生數據競爭。