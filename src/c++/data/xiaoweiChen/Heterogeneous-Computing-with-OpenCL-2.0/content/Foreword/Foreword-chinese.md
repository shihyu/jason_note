#序

計算時代在這已經進入異構計算時代，其意味著CPU和GPU可以同時處理同一計算任務。異構計算設計師們正在擴展異構計算的範圍，為的就是讓異構機器和硬件供應商能在更廣闊的空間發揮自己的能量。硬件層面的變化為未來出現的新應用提供了更廣闊的平臺。不過，因為設計結構不同，傳統編程模型在異構平臺上的表現很難令人滿意，這樣就意味著要對新的編程模型進行學習，例如OpenCL中的編程模型。

OpenCL設計之初，設計們注意到，傳統算法實現可以分為兩類：第一類是延遲密集型(比如：電子表格遍歷)，算法工程師們使用C或C++在CPU上進行實現；第二類是吞吐密集型(比如：矩陣相乘)，算法工程師會使用CUDA在GPU上進行實現。兩種方式雖有關聯，但是每種方式只工作在一種處理器上——C++不能在GPU上運行，CUDA無法在CPU上運行。開發者在實現算法時，只能使用其中一種。不過，算法應該能在不同的設備上混合實現，這才是異構設備的正式能力。現在的問題是如何在這樣的設備上進行混合編程？

一種解決方案就是為現有的平臺添加新的特性，C++和CUDA也都在積極的向好的方向發展，以迎接新硬件平臺的挑戰。另一種解決方式就是為異構計算創造一種新的編程模式，Apple公司為這種新的方式提供了提案和範例。這個提案被很多公司的技術部門重新定義，最終形成OpenCL。在設計之初，我很幸運是這些技術部門的一員。我們對kernel語言有著很多的預期：(1)讓開發者只寫一次kernel代碼；(2)讓已經寫好的kernel代碼可以在CPU，GPU，FPGA等設備上有效移植和運行；(3)kernel代碼和硬件底層緊密相關，開發者就可充分利用每個設備來提升應用的性能；(4)最大抽象化編程模型，這樣在每個公司的機器上只要編譯一遍，就可以在其他同型號機器上使用。當然，和任何項目一樣，我們想快速完成這些目標。為了加速實現，我們基於C99進行kernel語言的實現。在6個月內，OpenCL 1.0標準就誕生了，並且在1年內第一版的代碼實現就出現了。之後，OpenCL就與“真正的”開發者見面了……

之後發生了什麼？首先，C開發者說，一些C++特性(內存模型，原子操作等等)的添加讓他們的工作更加高效。CUDA開發者說，NVIDIA將所有新特性都添加入CUDA(比如：嵌套並行)，這讓寫程序更加簡單，應用運行起來更加快。第二，硬件架構也是作為異構計算的一種探索，硬件供應商會提，如何移除CPU和GPU都需要獨立內存的問題。近期，集成設備技術發展對於硬件來說是一重大的改變，這使得GPU和CPU可以放在同一芯片上(NVIDIA的tegra和AMD的APU都是這方面的例子)。第三，即使標準寫的很謹慎，並且有一致性檢查套件，不過在編譯器實現方面，並不是總按標準來——有時同一套代碼會在不同的設備上得到不同的結果。

所以就會之後的再修訂，併產生出更加成熟的標準——OpenCL 2.0。

新標準的最大改進，就是能讓開發者充分利用集成CPU和GPU的處理器。

較大的改變有如下內容：

- 共享虛擬內存——主機和設備端可以共享複雜數據結構指針，比如：樹和鏈表；以減少花在數據結構轉換上的精力。
- 動態並行——可以在不用主機代碼參與的情況下，進行內核的加載，為的就是減小加載內核所產生的瓶頸。
- 統一地址空間——這樣同樣的函數就可以處理GPU和CPU上的數據，以減少編程的難度。
- C++原子操作——工作項可以跨越工作組共享數據和設備，可以讓更多的算法使用OpenCL實現。

這本書充分的介紹了OpenCL，可以作為OpenCL編程課的教材，也可以作為並行編程課的一部分。不管怎麼說，這本書對於想要學習OpenCL的開發者來說是很值得擁有的。

本書的作者也在高性能GPU和CPU混合編程方面，做了很多時間，花費了很多精力。我個人對他們的工作表示尊敬。之前版本對之前版本的OpenCL的覆蓋的很全面，本版本將會覆蓋到所有OpenCL 2.0添加的新特性。

我在這裡希望讀者們通過這本書，能對OpenCL進行了解，並在未來寫出牛逼的異構應用。

------------------

Norm Rubin

NVIDIA研究科學家

東北大學訪問學者

2015年1月




