#第6章 OpenCL主機端內存模型

為了保證在各種硬件上都具有良好的可移植性，OpenCL提供了一個較為完善的抽象內存模型。這個內存模型足以應對各種硬件設備，提供足夠強的內存序保證開發者所寫的表達式的正確性，並且能夠並行的完成。抽象的內存模型也作為連接編程者和硬件的重要接口。編程者可以基於模型規則進行代碼的書寫，而無需考慮設備端在執行內核時將如何處理這段內存。硬件供應商在實現其SDK運行時部分時，也需要將其硬件的具體組件映射到內存模型中。並且提前定義組件映射關係，即可保證編程者只能和相應的組件進行互動。

之前的章節中，已經涉及到一些關於OpenCL內存模型的內容。例如，在第3章和第4章已經使用到的數組和圖像內存。也介紹了內存區域，例如：全局和局部。本章和第7章將要討論內存模型更多的細節。我們將內存模型分為兩個部分：主機端內存模型和設備端內存模型。設備端內存模型將在下章進行討論，其內容與“內核在運行時如何使用內存對象和其他數據”相關。

OpenCL設備包括GPU和其他加速器，這些設備上的內存系統與CPU所使用的主存是分開的。通常，OpenCL主機端內存模型的一致性是鬆散的，這使得全局內存同步只能使用事件來完成。OpenCL 2.0標準中添加了對內存一致性的保證，其借鑑了C/C++11和Java類似的機制。

為了在系統中支持多個離散內存系統，以及各種一致性模型，這就使得OpenCL內存對象的定義與主機CPU的內存有所不同。需要使用對應API來完成，數據從CPU指針搬入OpenCL內存對象，或是CPU指針接收OpenCL內存對象的數據的操作。對於OpenCL內存對象來說，對其尤為重要的是上下文對象，而非設備對象。所以，數據在轉移的時不會專門去指定具體的設備。這部分的工作就交由運行時來完成，運行時需要確保正確的數據，在正確的時間內出現在正確的位置上。

本章我們先要聊一下OpenCL中定義的內存對象的類型，然後在瞭解一下如何使用主機端API來管理內存對象。

