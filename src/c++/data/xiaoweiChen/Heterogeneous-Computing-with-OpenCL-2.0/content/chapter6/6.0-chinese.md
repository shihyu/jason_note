#第6章 OpenCL主机端内存模型

为了保证在各种硬件上都具有良好的可移植性，OpenCL提供了一个较为完善的抽象内存模型。这个内存模型足以应对各种硬件设备，提供足够强的内存序保证开发者所写的表达式的正确性，并且能够并行的完成。抽象的内存模型也作为连接编程者和硬件的重要接口。编程者可以基于模型规则进行代码的书写，而无需考虑设备端在执行内核时将如何处理这段内存。硬件供应商在实现其SDK运行时部分时，也需要将其硬件的具体组件映射到内存模型中。并且提前定义组件映射关系，即可保证编程者只能和相应的组件进行互动。

之前的章节中，已经涉及到一些关于OpenCL内存模型的内容。例如，在第3章和第4章已经使用到的数组和图像内存。也介绍了内存区域，例如：全局和局部。本章和第7章将要讨论内存模型更多的细节。我们将内存模型分为两个部分：主机端内存模型和设备端内存模型。设备端内存模型将在下章进行讨论，其内容与“内核在运行时如何使用内存对象和其他数据”相关。

OpenCL设备包括GPU和其他加速器，这些设备上的内存系统与CPU所使用的主存是分开的。通常，OpenCL主机端内存模型的一致性是松散的，这使得全局内存同步只能使用事件来完成。OpenCL 2.0标准中添加了对内存一致性的保证，其借鉴了C/C++11和Java类似的机制。

为了在系统中支持多个离散内存系统，以及各种一致性模型，这就使得OpenCL内存对象的定义与主机CPU的内存有所不同。需要使用对应API来完成，数据从CPU指针搬入OpenCL内存对象，或是CPU指针接收OpenCL内存对象的数据的操作。对于OpenCL内存对象来说，对其尤为重要的是上下文对象，而非设备对象。所以，数据在转移的时不会专门去指定具体的设备。这部分的工作就交由运行时来完成，运行时需要确保正确的数据，在正确的时间内出现在正确的位置上。

本章我们先要聊一下OpenCL中定义的内存对象的类型，然后在了解一下如何使用主机端API来管理内存对象。

