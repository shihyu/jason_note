#6.1 內存對象

OpenCL定義了三種內存對象——數組，圖像和管道——這幾種內存對象可以通過主機端的API進行創建。數組和圖像內存對象上存儲的數據，可以在主機端和設備端進行隨機訪問。管道對象上的數據對象只能在內核端先進先出(FIFO)，並且主機端無法訪問這些數據。

數組對象可以看做為CPU上的一維數組，並且其分配過程與C的malloc()函數類似。數組對象可以包含任何標量數據，向量數據或自定義結構體。數據在數組中是順序存儲的，這樣OpenCL內核就能以隨機訪問的方式對數組進行訪問(就如同C中的一維數組)。

圖像對象就有些不同，其數據的佈局或存放方式在硬件上進行過一些優化，這樣指針就很難直接一個一個的訪問對應的數據，並且硬件上的數據佈局方式對於開發者來說是不可見的。這樣，內核端只能使用內置函數對圖像對象進行訪問。因為GPU設計之初就是為了處理圖形任務，所以GPU對圖像數據訪問效率已有較高優化。圖像有三個優勢：

1. GPU上的層級緩存和數據流結構就是為了優化訪問圖像類型數組所準備
2. GPU驅動會在硬件層面上優化圖像數據的排布，從而提升訪問圖像數據的效率，尤其是二維圖像模式
3. 硬件支持圖像是一個很複雜的數據訪問過程，在這個過程中硬件會將一些存儲的數據進行壓縮

下面的幾個子節，將分別對這三種內存對象進行更為詳盡的描述。

##6.1.1 數組對象

數組對象的分配有點類似使用malloc()，其分配方式非常簡單。創建數組對象只需要提供上下文對象，數組大小，以及一些標識就可以。創建數組對象的API為`clCreateBuffer()`。

```c++
cl_mem
clCreateBuffer(
  cl_context context,
  cl_mem_flags flags,
  size_t size,
  void *host_ptr,
  cl_int *err)
```

函數會返回一個數組對象，如果需要將錯誤碼傳出，則需要傳入最後一個參數。flags參數可以將數組配置成只讀或只寫的數據，以及設置其他分配選項。例如，下面的代碼，我們就創建了一個只讀的數組對象，其存儲的數據與主機端a數組數分佈相同，二者也具有同樣的大小。這裡，我們將詳細討論一些分配選項在之後的章節(例如：CL_MEM_USE_HOST_PTR)。錯誤碼將從err傳出，對應的錯誤碼在OpenCL標準文檔中都有定義。通常OpenCL函數執行成功，都會以CL_SUCCESS作為錯誤碼返回。

{%ace edit=false, lang='c_cpp'%}
cl_int err;
int a[16];

cl_mem newBuffer = clCreateBuffer(
  context,
  CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
  16 * sizeof(int),
  a,
  &err);

if (err != CL_SUCCESS){
  // Handle error as necessary
}
{%endace%}

OpenCL也支持*子數組對象*(subbuffer)，也就是可以將單獨的數組對象再進行劃分為更小的數組對象，這些數組對象可以相互覆蓋，可以讀或寫和拷貝，以及和其父數組以相同的方式使用。注意有覆蓋和包含關係的子數組對象，會讓其父數組對象結構變的更加複雜，並且在實際使用過程中這種情況會造成一些未定義的行為。

##6.1.2 圖像對象

OpenCL中，圖像與數組對象有三點不同：

1. 圖像數據排布的不透明性，使其不能直接在內核中使用指針進行數據讀取
2. 多維結構
3. 圖像對數據成員有一定的要求，並不能像數組那讓接受任意數據類型

圖像對象之所以在OpenCL中存在，因為GPU硬件設計已經對圖像的存儲方式進行過優化，這樣會讓設備在訪問圖像數據時的效率更高。訪問圖像的內置函數，並不能像數組對象那樣提供各種方式的訪存模式，不過其能作用就是能讓一些濾波方式在硬件方面得到很好的支持，從而具有較高的效率。濾波操作中，會有基於一組以特定方式排布的像素進行變換，高效的內存訪問則會對濾波操作進行加速。這些操作需要多次讀取的長指令隊列，不過有硬件的支持其執行效率很高。

圖像數據可在內核端，通過特定的函數進行訪問(第7章設備端內存模型會詳細討論)。主機端訪問圖像對象的方式與數組對象沒有太大的區別，不過對圖像對象操作的主機函數支持多維度的尋址。`clEnqueueReadImage()`更像`clEnqueueReadBufferRect()`，而非`clEnqueuReadBuffer()`。

圖像對象和數組對象最大的區別，就是圖像對象支持的格式。圖像格式包括通道序和通道類型。通道順序定義了有多少通道需要使用——例如,CL_RGB，CL_R或CL_ARGB。通道類型就是要選擇通道內數據存儲的格式，從CL_FLOAT到充分利用內存的CL_UNORM_SHORT_565(其將一個16比特字打包後放入內存)。當內核代碼要訪問這些數據時，讀取到的數據結果都上轉換成標準的OpenCL C類型數據。圖像格式支持的列表可以通過`clGetSupportedImageFormats()`獲取。

圖像對象可通過`clCreateImage()`進行創建，其聲明如下：

```c++
cl_mem
clCreateImage(
  cl_context context,
  cl_mem_flags flags,
  const cl_image_format *image_format,
  const cl_image_desc *image_desc,
  void *host_ptr,
  cl_int *errcode_ret)
```

context，flags和host_ptr這些與創建數組對象所需要的參數一致。圖像類型(image_format)和圖像描述符(image_desc)參數定義了圖像的維度，數據格式和數據分佈。這種結構已經在第4章進行詳細的描述(一個初始化圖像對象的完整例子)。

##6.1.3 管道對象

OpenCL 2.0支持一種新的內存對象——管道對象。管道對象的數據結構是FIFO結構，其用來將一個內核對象的數據傳遞給另一個內核對象。因為之前OpenCL標準中的內存模型十分鬆散，所以根本無法實現管道，因為沒有辦法在上一個內核結束前確定內存的狀態。通道的意義就是為了在兩個內核中共享一部分數據，並且保證這些共享數據的狀態。這種標識對於處理器來說是一種趨勢，對於支持管道對象的任意設備，至少有能力實現內核間共享數據的原子操作，並且必須要有一套內存一致模型來支持內存獲取和釋放語義。

可以設想一下，如果設備具有這樣的能力，編程者都可以用一個數組對象來實現屬於自己的“管道對象”。OpenCL 2.0的內存模型中這個方案是可行的，其背後是很多設計師和工程師的努力。管道具有併發“生產者-消費者”機制，這種方式比起之前的標準，讓很多問題變的簡單了許多(例如，當每個工作項生成了大量的輸出數據，就可以對這些數據進行打包處理)。在同一設備上執行“生產者-消費者”任務時，就可以使用管道對象，這樣也允許硬件供應商能將這塊內存映射到一個延遲較低的內存區域中。管道對象是不允許主機端對其進行讀寫的，所以訪問管道對象屬於設備端內存模型。

管道數據通常稱為*包*(packets)，其包含了OpenCL C或用戶自定義的類型。創建管道對象的API為`clCreatePipe()`，其聲明如下：

```c++
cl_mem
clCreatePipe(
  cl_context context,
  cl_mem_flags flags,
  cl_uint pipe_packet_size,
  cl_uint pipe_max_packets,
  const cl_pipe_properties *properties,
  cl_int *errcode_ret)
```

當創建一個管道，需要提供包大小(pipe_packed_size)和最大包數(pipe_max_packets)。如同其他創建內存對象的API，這個API也需要設置一些與內存相關標識。對於管道對象來說，只有設置CL_MEM_READ_WRITE標識是合法的，其也是管道對象默認的標識參數。以後，管道對象不可在主機端訪問，即便是編程者沒有意識到，也需要使用CL_MEM_HOST_NO_ACCESS來顯式表明管道對象在主機端不可訪問。