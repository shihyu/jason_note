#11.10 優化數據搬運

隨著處理器的發展，執行的速度是越來越快，計算能力也逐漸不再是高性能系統的主要瓶頸。對於數據敏感的計算來說，其主要瓶頸是在內存帶寬上。很多例子中，數據在主機端和加速器間的搬運時間，要遠遠大於其計算所消耗的時間。為了最小化這段開銷，OpenCL為加速器提供了多種創建內存對象的方法。OpenCL中`CL_MEM_READ_ONLY`索引就代表了這段內存不能在計算時進行修改。如果使用這個索引創建的內存對象，需要在其中放置一些常量數據，這些數據在計算完成後也不需要拷貝回主機。與之相反，`CL_MEM_WRITE_ONLY`索引所創建的內存，大多數情況下是用來存放結果數據的。如果使用這個索引創建出的內存對象，不需要在加速器計算之前拷貝數據到這個內存當中。要將`C++ AMP`與OpenCL這些特性對應起來，我們就可以對應用的性能進行提升

##11.10.1 discard_data()

`C++ AMP`中discard_data()是array_view的一個成員函數。在運行時調用這個函數會將對應對象上的數據進行復寫，因此就沒有必要在計算開始之前，將數據拷貝到設備端。這種情況下，我們可以使用`CL_MEM_WRITE_ONLY`創建一個內存對象。

##11.10.2 `array_view<const T, N>`

如果一個array_view對象的第一個模板參數的限定符是const，那麼我們只能通過`CL_MEM_READ_ONLY`創建相應的內存對象。這樣的話，OpenCL運行時就能知道，哪段內存在計算的時候不能夠被修改。因此，這個內存對象上所存儲的數據，在計算完成後不需要拷貝回主機。
