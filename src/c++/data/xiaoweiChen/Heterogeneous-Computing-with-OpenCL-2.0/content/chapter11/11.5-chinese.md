#11.5 C++ AMP的編譯流

上一節中我們瞭解了`C++ AMP`與OpenCL的對應關係，那麼對於編譯和鏈接`C++ AMP`程序的方式也應該很容易理解。具體到CLamp編譯器上，其進行如下的一些操作：

1. 寫完代碼之後，將`C++ AMP`源碼以“設備端模式”進行編譯(所有`C++ AMP`指定的語言規則都會檢查並應用)。CLamp編譯器可以產生相應的OpenCL內核(基於AMP的約束函數)，並將其編譯成LLVM的位碼文件。內核所調用的函數都必須是內聯函數。主機端程序也會編譯成生成相應的位代碼，然後生成對應的`C++`函數。
2. LLVM位代碼通過一些變化來保證底層OpenCL程序的正確性。首先是對主機端代碼的修整，然後確保在OpenCL程序中內核和指令中所使用的指針地址空間的正確性(__global, __constant, __local, __private)。這裡需要注意的是，`C++ AMP`和OpenCL的指針在地址空間上是不相同的。OpenCL中，地址空間值指針類型的一種，而在`C++ AMP`中其為指針值的一種。因此，靜態編譯分析器會，通過指針的負值和使用操作，自行推斷所使用的指針的地址空間。另外，對LLVM位數據的轉換也會使用到元數據，使其能與OpenCL SPIR格式兼容。
3. 將LLVM位碼編譯成OpenCL SPIR位碼之後，就可以在支持cl_khr_spir擴展特性的平臺上直接鏈接和執行。編譯後的二進制文件會以另外的形式保存，其格式與主機端程序的格式是不一樣的。另外，OpenCL C格式的內核代碼可以使用在任何支持OpenCL平臺的設備上，即使對應的設備不支持SPIR模式。
4. 輸入的`C++ AMP`源碼會以“主機模式”對主機端代碼進行編譯。`C++ AMP`頭文件都是設計好的，所以不會有內核代碼在主機端模式下進行編譯。不過，程序會調用`C++ AMP`運行時API函數來取代內核執行部分的代碼。
5. 主機端和設備端代碼最終都會鏈接在一起，併產生一個可執行文件