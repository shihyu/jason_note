#1.5 線程和共享內存

一個執行的程序(稱為進程)可能有很多子程序組成，並且這些子程序都有獨立的控制流。當該進程啟動時，這些子程序就併發的開始執行。這些子程序可以稱之為線程。進程中的所有線程都會共享一些資源(比如：內存、打開的文件、全局變量)，不過他們也有屬於自己的資源(比如：堆棧、[自動變量](https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F))。線程使用全局共享地址空間分配出的變量進行通訊。通訊時需要有同步機制來保證同一個內存區域的內容，不會被多個線程更新。

具有共享內存的系統中，所有的處理器都能訪問到同一地址空間(比如：能看到同一個全局變量)。共享內存模型中一個關鍵的特性，就是不需要編程者去管理數據的移動。在這樣的系統中，線程如何去更新全局變量，底層硬件和編程者要達成共識，並遵守相關的訪問協議。“相關協議”的學術名稱為“內存一致性模型”，內存一致性模型已經被很多高級語言所支持，比如：Java、C/C++11和OpenCL。相關的高級結構有互斥量和信號量，以及“獲取-釋放”語義。程序員會顯式告知底層硬件需要使用哪種同步方式，從而能讓硬件更加高效的執行併發任務。

隨著處理器數量的增加，底層硬件也要花費很大的精力來對共享內存進行支持和管理。總線的長度(與延遲和功耗相關)，硬件結構上接口的數量，以及共享傳輸總線的數量都將佔用很多資源。當我們嘗試增加處理器的數量時，這些額外的硬件設備數量將會呈指數級別增長。我們的系統將變得更復雜，同時也增加了很多的額外開銷。這些是多核或多處理器系統的弊端，並且這也限制著一起工作處理器的數量。內存一致性模型下，能夠使用的處理器相對較少，這是因為共享總線和相干性協議將會成為性能瓶頸。系統中多一些鬆散的共享內存，相對來說會好一些；當有成規模的內核在共享內存系統中時，其會讓系統變得複雜，並且內核間的互相通訊也要付出很高的代價。大多數多核CPU平臺都支持某一種共享內存，OpenCL也可以在支持共享內存的設備上運行。