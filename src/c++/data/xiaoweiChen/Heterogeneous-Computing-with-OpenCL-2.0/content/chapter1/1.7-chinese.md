#1.7 并行性的粒度

不论是在线程中使用共享内存，还在使用消息传递机制，我们都能调整线程的粒度。研究并行计算时，粒度是线程中计算量与通讯量(比如，需要在线程间进行同步的变量)。

并行的粒度由算法的特点所决定，选择合适的并行粒度对于编程者来说很重要，合适的粒度能够在当前设备上获得最优的性能。有时对于粒度选择就像是在分块，然后决定哪些数据给予哪个任务，选择了合适的块大小可以就能在并行硬件上获得性能收益。如何选择并行程序的粒度，可以参考下面列出一些经验。

使用细粒度并行时，需要考虑如下几点：

- 计算量不要过大，这样每个线程都有足够的工作可做。
- 尽可能减少在数据同步上的开销，这样每个线程能够独立的完成自己的任务。
- 负载的划分也很重要，因为有大量的独立任务需要并行执行，设计良好的任务调度器都能灵活控制负载，并保证在多任务运行的同时，让线程上的达到均衡。

使用粗粒度并行时，需要考虑如下几点：

- 计算量肯定要高于细粒度并行时的计算量，因为不会像细粒度并行那样，有很多线程同时执行。
- 编程者使用粗粒度编程时，需要了解应用的整体结构，让粗粒度中的每个线程作为任务，服务于应用。

结合给出的建议，考虑一下自己的应用要选择哪种粒度的实现。其实，最合理的粒度取决于所要使用的算法和运行的硬件平台。大多数情况下，当同步和通讯的开销大于计算，那么将并行粒度加大，更有利于控制同步和通讯所需的过高开销。细粒度并行能减少负载不均和访存延迟在性能上的开销(对于GPU来说更是如此，其为粒度之细可以切换线程时达到零开销，同时也能隐藏访存延迟)。

当一个算法需要对大量数据进行同一组操作时，就可将数据视为向量，执行同一操作时，多个数据作为输入，经过向量操作后输出多个数据。这种执行方式就是利用单指令多数据(SIMD)的方式对数据进行处理，可并行硬件可以利用这种执行方式，并行的对不同的数据进行处理。这种粒度的并行与向量的大小有关，通过SIMD执行单元的多数据处理来获得应用性能的提升。

寻找和尝试最好的计算粒度时，是否考虑过为什么不将统一程序中的所有副本拷贝到其他处理单元和节点上，如果能够这样，是不是就不用理会执行单元的执行顺序，并且能让程序高效的运行在一个有着多处理器的共享系统上呢？SIMD模型与单程序多数据(SPMD)模型很相似，SPMD模型和SIMD模型都不会对指令边界进行同步的限制，并且允许这些副本任务或内核能够并发的执行。

##1.7.1 数据共享与同步

开发异构软件还有一个很关键的因素——数据量。像想一下，两个任务没有任何数据需要共享，当运行环境或操作系统中的运算资源充足，那么这两个任务可以并行执行。如果在系统运行第一个任务时，第二个任务需要使用到第一个任务产出的结果。要是存在这样的数据依赖关系，那么就必选要介绍一下如何在并行或并发任务时，进行数据的同步。并行程序至少需要执行到一个同步点，才能够进行数据的同步。当然，这会让编程的难度加大，让异构编程更具有挑战性。

编写并发软件的时候，数据共享和同步扮演着很重要的角色。数据共享就有如下的用途：

- 一个任务中的输入，依赖于另外一个任务的输出——例如：生产者-消费者模型、流水线执行模型。
- 需要将中间结果进行综合(比如：归约，还有图1.5里的例子)。

理想状态下，可以尝试将应用能并行的部分剥离出来，确保并行的部分没有数据依赖，不过这只是理想状态而已。栅栏和锁有时会用来做数据的同步。虽然，现在只是举了这个例子，不过在后面的章节中我们将在OpenCL中重温这个问题。OpenCL提供相应的机制，来完成主机端和设备端的数据同步，或者是完成任务间的数据同步。

##1.7.2 共享虚拟内存

很多异构系统，会将任务分散在不同的设备上执行，并且使用显式同步和通讯机制，来完成不同任务在不同设备上的数据同步。共享虚拟内存设置在硬件和软件层面，能够让不同的设备看到的是同一块内存。这个机制让编程更加简单，并且能节省显式的通讯开销。OpenCL 2.0标准开始支持共享虚拟内存，减少了在程序执行中高昂的通讯开销。同样，这样的机制就不需要在每个设备上都存储一组数据副本，也就可以节省内存的开销。当然，我们会在后面章节中，在与OpenCL上下文的相关章节中，讨论更多共享虚拟内存的细节。

OpenCL2.0提供了三种共享虚拟内存：

- 粗粒度共享缓存
- 细粒度共享缓存
- 系统级细粒度共享缓存

使用共享虚拟内存需要OpenCL实现将系统中主机和设备端的地址链接起来。这就允许在OpenCL内核中使用数据结构的指针(比如：链表)，之前版本的OpenCL标准是不支持内核中使用自定义数据结构指针。粗粒度缓存支持通过API的调用，来更新整个缓存的内容。细粒度缓存和系统级细粒度的粒度为字节级，这就意味着无论是主机端，还是设备端，对数据的更新将会立即同步。细粒度共享内存是按内存一致模型中定义好的内存序，在同步点对数据进行同步。第6和第7章中，我们会对这部分内容进行更深层次的探讨。




