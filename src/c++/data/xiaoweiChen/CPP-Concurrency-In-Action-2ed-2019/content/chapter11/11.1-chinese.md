# 11.1 與併發相關的錯誤類型

在併發代碼中可以發現各式各樣的錯誤，這些錯誤不會集中於某個方面。不過，有一些錯誤與使用併發直接相關，本章重點關注這些錯誤。通常，併發相關的錯誤通常有兩大類：

- 不必要的阻塞

- 條件競爭

這兩大類的顆粒度很大，讓我們將其細分為較小的問題。

## 11.1.1 不必要的阻塞

“不必要的阻塞”是什麼意思？線程阻塞的時候，不能處理任何任務，因為它在等待其他“條件”的達成。通常這些“條件”就是一個互斥量、一個條件變量或一個future，也可能是一個I/O操作。這是多線程代碼的先天特性，不過也不是任何時候都會衍生成“不必要的阻塞”。

為什麼阻塞是不必要的？通常，因為其他線程在等待該阻塞線程上的某些操作完成，如果該線程阻塞了，那些線程必然會阻塞。

這個主題可以分成以下幾個種類：

- 死鎖——如在第3章所見，死鎖的情況下，兩個線程會互相等待。當線程產生死鎖，應該完成的任務就會擱置。舉個例子來說，一些線程是負責對用戶界面操作的線程，在死鎖的情況下，用戶界面就會無響應。或者，界面接口會保持響應，不過有些任務就無法完成，比如：查詢無結果返回或文檔未打印。

- 活鎖——與死鎖的情況類似。不同的地方在於線程不是阻塞等待，而是在循環中持續檢查，例如：自旋鎖。比較嚴重的情況下，其表現和死鎖一樣(應用不會做任何處理，停止響應)，因為線程還在循環中被檢查，而不是阻塞等待，所以CPU的使用率還居高不下。不太嚴重的情況下，使用隨機調度，活鎖的問題還可以解決。

- I/O阻塞或外部輸入——當線程被外部輸入所阻塞，線程也就不能做其他事情了(即使，等待輸入的情況永遠不會發生)。當為外部輸入所阻塞，就會讓人不太高興，因為可能有其他線程正在等待這個線程完成某些任務。

簡單的介紹了“不必要阻塞”的組成。那麼，條件競爭呢？

## 11.1.2 條件競爭

條件競爭在多線程代碼中很常見——很多條件競爭表現為死鎖與活鎖。而且，並非所有條件競爭都是惡性的——對獨立線程相關操作的調度，決定了條件競爭發生的時間。很多條件競爭是良性的，比如：哪一個線程去處理任務隊列中的下一個任務。不過，很多併發錯誤的引起也是因為條件競爭。

條件競爭常會產生以下幾種類型的錯誤：

- 數據競爭——因為未同步訪問一塊共享內存，將會導致代碼產生未定義行為。第5章已經介紹了數據競爭，也瞭解了C++的內存模型。數據競爭通常發生在錯誤的使用原子操作上，做同步線程的時候，或沒使用互斥量保護共享數據時。

- 破壞不變量——主要表現為懸空指針(因為其他線程已經將要訪問的數據刪除了)，隨機存儲錯誤(因為局部更新，導致線程讀取了不一樣的數據)，以及雙重釋放(比如：當兩個線程對同一個隊列同時執行pop操作，想要刪除同一個關聯數據)等等。破壞不變量可以看作為“基於數據”的問題。當獨立線程需要以一定順序執行某些操作時，錯誤的同步會導致條件競爭，比如：破壞訪問順序。

- 生命週期問題——雖然這類問題也能歸結為破壞了不變量，不過這裡將其作為一個單獨的類別給出。這裡的問題是線程會訪問不存在的數據，這可能是因為刪除或銷燬了數據，或者轉移到其他對象中去了。生命週期問題，通常是在一個線程引用了局部變量，在線程還沒有完成前，局部變量的“死期”就到了。不過這個問題並不只存在這種情況下。當手動調用join()等待線程完成工作，需要保證異常拋出時，join()還會等待其他未完成工作的線程。這是線程中基本異常安全的應用。

惡性條件競爭就如同一個殺手。死鎖和活鎖會表現為：應用掛起和反應遲鈍，或超長時間完成任務。當一個線程產生死鎖或活鎖，可以用調試器附著到該線程上進行調試。條件競爭，破壞不變量，以及生命週期問題，其表現代碼都是可見的(比如，隨機崩潰或錯誤輸出)——可能重寫了系統部分的內存使用方式(不會改太多)。其中，可能是因為執行時間，導致問題無法定位到具體的位置。這就是共享內存系統的詛咒——需要通過線程嘗試限制可訪問的數據，並且還要正確的使用同步，應用中的任何線程都可以複寫(可被其他線程訪問的)數據。

現在已經瞭解了這兩大類中都有哪些具體問題了。下面就讓我們來瞭解，如何在代碼中定位和修復這些問題。