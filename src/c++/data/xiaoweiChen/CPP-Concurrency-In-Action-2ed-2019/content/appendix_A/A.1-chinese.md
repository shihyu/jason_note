# A.1 右值引用

如果從事過C++編程，就會對引用比較熟悉，引用允許為已經存在的對象創建一個新的名字。對新引用所做的訪問和修改操作，都會影響它的原型。

例如：

```c++
int var=42;
int& ref=var;  // 創建一個var的引用
ref=99;
assert(var==99);  // 原型的值被改變了，因為引用被賦值了
```

目前為止，我們用過的所有引用都是左值引用(C++11之前)——對左值的引用。lvalue指的是可以放在賦值表達式左邊的事物——在棧上或堆上分配的命名對象，或者其他對象成員——有明確的內存地址。rvalue指的是可以出現在賦值表達式右側的對象——例如，文字常量和臨時變量。因此，左值引用只能被綁定在左值上，而不是右值。

不能這樣寫：

```c++
int& i=42;  // 編譯失敗
```

例如，因為42是一個右值。你可能通常使用下面的方式講一個右值綁定到一個const左值引用上：

```c++
int const& i = 42;
```

這算是鑽了標準的一個空子吧。不過，這種情況我們之前也介紹過，我們通過對左值的const引用創建臨時性對象，作為參數傳遞給函數。其允許隱式轉換，所以你可這樣寫：

```c++
void print(std::string const& s);
print("hello");  //創建了臨時std::string對象
```

C++11標準介紹了*右值引用*(rvalue reference)，這種方式只能綁定右值，不能綁定左值，其通過兩個`&&`來進行聲明：

```c++
int&& i=42;
int j=42;
int&& k=j;  // 編譯失敗
```

因此，可以使用函數重載的方式來確定：函數有左值或右值為參數的時候，看是否能被同名且對應參數為左值或右值引用的函數所重載。其基礎就是C++11新添語義——*移動語義*(move semantics)。

## A.1.1 移動語義

右值通常都是臨時的，可以隨意修改。如果知道函數的某個參數是一個右值，就可以將其看作為一個臨時存儲，不影響程序的正確性。比起拷貝右值參數的內容，不如移動其內容。動態數組比較大時，能節省很多內存，提供更多的優化空間。試想，一個函數以`std::vector<int>`作為一個參數，就需要將其拷貝進來，而不對原始的數據做任何操作。C++03/98的辦法是，將這個參數作為一個左值的const引用傳入，然後做內部拷貝：

```c++
void process_copy(std::vector<int> const& vec_)
{
  std::vector<int> vec(vec_);
  vec.push_back(42);
}
```

這就允許函數能以左值或右值的形式進行傳遞，不過任何情況下都是通過拷貝來完成的。如果使用右值引用版本的函數來重載這個函數，就能避免在傳入右值的時，進行內部拷貝，從而可以對原始值進行任意的修改：

```c++
void process_copy(std::vector<int> && vec)
{
  vec.push_back(42);
}
```

如果這個問題存在於類的構造函數中，內部右值會在新的實例中使用。可以參考一下代碼中的例子(默認構造函數會分配很大一塊內存，在析構函數中釋放)。

代碼A.1 使用移動構造函數的類

```c++
class X
{
private:
  int* data;

public:
  X():
    data(new int[1000000])
  {}

  ~X()
  {
    delete [] data;
  }

  X(const X& other):  // 1
   data(new int[1000000])
  {
    std::copy(other.data,other.data+1000000,data);
  }
  
  X(X&& other):  // 2
    data(other.data)
  {
    other.data=nullptr;
  }
};
```

一般情況下，拷貝構造函數①都是這麼定義：分配一塊新內存，然後將數據拷貝進去。不過，現在有了一個新的構造函數，可以接受右值引用來獲取老數據②，就是移動構造函數。在這個例子中，只是將指針拷貝到數據中，將other以空指針的形式留在了新實例中。使用右值裡創建變量，就能避免了空間和時間上的多餘消耗。

X類(代碼A.1)中的移動構造函數，僅作為一次優化。在其他例子中，有些類型的構造函數只支持移動構造函數，而不支持拷貝構造函數。例如，智能指針`std::unique_ptr<>`的非空實例中，只允許這個指針指向其對象，所以拷貝函數在這裡就不能用了(如果使用拷貝函數，就會有兩個`std::unique_ptr<>`指向該對象，不滿足`std::unique_ptr<>`定義)。不過，移動構造函數允許對指針的所有權進行傳遞，並且允許`std::unique_ptr<>`像一個帶有返回值的函數一樣使用——指針的轉移是通過移動，而非拷貝。

如果你已經知道，某個變量在之後就不會在用到了，這時候可以選擇顯式的移動，你可以使用`static_cast<X&&>`將對應變量轉換為右值，或者通過調用`std::move()`函數來做這件事：

```c++
X x1;
X x2=std::move(x1);
X x3=static_cast<X&&>(x2);
```

想要將參數值不通過拷貝，轉化為本地變量或成員變量時，就可以使用這個辦法。雖然右值引用參數綁定了右值，不過在函數內部，會當做左值來進行處理：

```c++
void do_stuff(X&& x_)
{
  X a(x_);  // 拷貝
  X b(std::move(x_));  // 移動
}
do_stuff(X());  // ok，右值綁定到右值引用上
X x;
do_stuff(x);  // 錯誤，左值不能綁定到右值引用上
```

移動語義在線程庫中用的比較廣泛，無拷貝操作對數據進行轉移可以作為一種優化方式，避免對將要被銷燬的變量進行額外的拷貝。在2.2節中看到，在線程中使用`std::move()`轉移`std::unique_ptr<>`得到一個新實例。在2.3節中，瞭解了`std:thread`實例可以使用移動語義來轉移線程的所有權。

`std::thread`、`std::unique_lock<>`、`std::future<>`、 `std::promise<>`和`std::packaged_task<>`都不能拷貝，不過這些類都有移動構造函數，能讓相關資源在實例中進行傳遞，並且支持用一個函數將其進行返回。`std::string`和`std::vector<>`也可以拷貝，不過它們也有移動構造函數和移動賦值操作符，就是為了避免拷貝拷貝大量數據。

C++標準庫不會將一個對象顯式的轉移到另一個對象中，除非是將其銷燬或賦值的時候(拷貝和移動的操作很相似)。不過，實踐中移動能保證類中的所有狀態保持不變，表現良好。一個`std::thread`實例可以作為移動源，轉移到新(以默認構造方式)`std::thread`實例中。`std::string`可以通過移動原始數據進行構造，並且保留原始數據的狀態，不過不能保證的是原始數據中該狀態是否正確(根據字符串長度或字符數量決定)。

## A.1.2 右值引用和函數模板

使用右值引用作為函數模板的參數時，與之前的用法有些不同：如果函數模板參數以右值引用作為一個模板參數，當對應位置提供左值的時候，模板會自動將其類型認定為左值引用。當提供右值的時候，會當做普通數據使用。可能有些口語化，來看幾個例子吧。

考慮一下下面的函數模板：

```c++
template<typename T>
void foo(T&& t)
{}
```

隨後傳入一個右值，T的類型將被推導為：

```c++
foo(42);  // foo<int>(42)
foo(3.14159);  // foo<double><3.14159>
foo(std::string());  // foo<std::string>(std::string())
```

不過，向foo傳入左值的時候，T會被推導為一個左值引用：

```c++
int i = 42;
foo(i);  // foo<int&>(i)
```

因為函數參數聲明為`T&&`，所以就是引用的引用，可以視為是原始的引用類型。那麼foo<int&>()就相當於：

```c++
foo<int&>(); // void foo<int&>(int& t);
```

這就允許一個函數模板可以即接受左值，又可以接受右值參數。這種方式已在`std::thread`的構造函數所使用(2.1節和2.2節)，所以能夠將可調用對象移動到內部存儲，而非當參數是右值的時候再進行拷貝。