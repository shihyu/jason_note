# A.3 默認函數

刪除函數的函數可以不進行實現，默認函數就則不同：編譯器會創建函數實現，通常都是“默認”實現。當然，這些函數可以直接使用(它們都會自動生成)：默認構造函數，析構函數，拷貝構造函數，移動構造函數，拷貝賦值操作符和移動賦值操作符。

為什麼要這樣做呢？這裡列出一些原因：

- 改變函數的可訪問性——編譯器生成的默認函數通常都是聲明為public(如果想讓其為protected或private成員，必須自己實現)。將其聲明為默認，可以讓編譯器來幫助你實現函數和改變訪問級別。

- 作為文檔——編譯器生成版本已經足夠使用，那麼顯式聲明就利於其他人閱讀這段代碼，會讓代碼結構看起來很清晰。

- 沒有單獨實現的時候，編譯器自動生成函數——通常默認構造函數來做這件事，如果用戶沒有定義構造函數，編譯器將會生成一個。當需要自定一個拷貝構造函數時(假設)，如果將其聲明為默認，也可以獲得編譯器為你實現的拷貝構造函數。

- 編譯器生成虛析構函數。

- 聲明一個特殊版本的拷貝構造函數。比如：參數類型是非const引用，而不是const引用。

- 利用編譯生成函數的特殊性質(如果提供了對應的函數，將不會自動生成對應函數——會在後面具體講解)。

就像刪除函數是在函數後面添加`= delete`一樣，默認函數需要在函數後面添加`= default`，例如：

```c++
class Y
{
private:
  Y() = default;  // 改變訪問級別
public:
  Y(Y&) = default;  // 以非const引用作為參數
  T& operator=(const Y&) = default; // 作為文檔的形式，聲明為默認函數
protected:
  virtual ~Y() = default;  // 改變訪問級別，以及添加虛函數標籤
};
```

編譯器生成函數都有獨特的特性，這是用戶定義版本所不具備的。最大的區別就是編譯器生成的函數都很簡單。

列出了幾點重要的特性：

- 對象具有簡單的拷貝構造函數，拷貝賦值操作符和析構函數，都能通過memcpy或memmove進行拷貝。

- 字面類型用於constexpr函數(可見A.4節)，必須有簡單的構造，拷貝構造和析構函數。

- 類的默認構造、拷貝、拷貝賦值操作符和析構函數，也可以用在一個已有構造和析構函數(用戶定義)的聯合體內。

- 類的簡單拷貝賦值操作符可以使用`std::atomic<>`類型模板(見5.2.6節)，為某種類型的值提供原子操作。

僅添加`=default`不會讓函數變得簡單——如果類還支持其他相關標準的函數，那這個函數就是簡單的——不過，用戶顯式的實現就不會讓這些函數變簡單。

第二個區別，編譯器生成函數和用戶提供的函數等價，也就是類中無用戶提供的構造函數可以看作為一個aggregate，並且可以通過聚合初始化函數進行初始化：

```c++
struct aggregate
{
  aggregate() = default;
  aggregate(aggregate const&) = default;
  int a;
  double b;
};
aggregate x={42,3.141};
```

例子中，x.a被42初始化，x.b被3.141初始化。

第三個區別，編譯器生成的函數只適用於構造函數；換句話說，只適用於符合某些標準的默認構造函數。

```c++
struct X
{
  int a;
};
```

如果創建了一個X的實例(未初始化)，其中int(a)將會被默認初始化。如果對象有靜態存儲過程，那麼a將會被初始化為0；另外，當a沒賦值的時候，其不定值可能會觸發未定義行為：

```c++
X x1;  // x1.a的值不明確
```

另外，當使用顯示調用構造函數的方式對X進行初始化，a就會被初始化為0：

```c++
X x2 = X();  // x2.a == 0
```

這種奇怪的屬性會擴展到基礎類和成員函數中。當類的默認構造函數是由編譯器提供，並且一些數據成員和基類都是有編譯器提供默認構造函數時，還有基類的數據成員和該類中的數據成員都是內置類型的時候，其值要不就是不確定的，要不就是初始化為0(與默認構造函數是否能被顯式調用有關)。

雖然這條規則令人困惑，並且容易造成錯誤，不過也很有用。當你編寫構造函數的時候，就不會用到這個特性。數據成員，通常都可以被初始化(指定了一個值或調用了顯式構造函數)，或不會被初始化(因為不需要)：

```c++
X::X():a(){}  // a == 0
X::X():a(42){}  // a == 42
X::X(){}  // 1
```

第三個例子中①，省略了對a的初始化，X中a就是一個未被初始化的非靜態實例，初始化的X實例都會有靜態存儲過程。

通常的情況下，如果寫了其他構造函數，編譯器就不會生成默認構造函數。所以，想要自己寫一個的時候，就意味著你放棄了這種奇怪的初始化特性。不過，將構造函數顯式聲明成默認，就能強制編譯器為你生成一個默認構造函數，並且剛才說的那種特性會保留：

```c++
X::X() = default;  // 應用默認初始化規則
```

這種特性用於原子變量(見5.2節)，默認構造函數顯式為默認。初始值通常都沒有定義，除非具有(a)一個靜態存儲的過程(靜態初始化為0)，(b)顯式調用默認構造函數，將成員初始化為0，(c)指定一個特殊的值。注意，這種情況下的原子變量，為允許靜態初始化過程，構造函數會通過一個聲明為constexpr(見A.4節)的值為原子變量進行初始化。