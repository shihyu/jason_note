# 7.4 本章總結

從第6章中的基於鎖的數據結構起，本章簡要的描述了一些無鎖數據結構的實現(通過實現棧和隊列)。這個過程中，需要小心使用原子操作的內存序，為了保證無數據競爭，以及讓每個線程看到一個數據結構實例。並且，在無鎖結構中對內存的管理是越來越難。還有，如何通過幫助線程的方式，來避免忙等待循環。

設計無鎖數據結構是一項很困難的任務，並且很容易犯錯。不過，這樣的數據結構在某些重要情況下可對其性能進行增強。但願通過本章的的一些例子，以及一些指導意見，可以幫助你設計出自己的無鎖數據結構，或實現一份研究報告中的數據結構，或用以發現離職同事代碼中的bug。

不管在線程間共享怎麼樣的數據，需要考慮數據結構應該如何使用，並且如何在線程間同步數據。通過設計併發訪問的數據結構，就能對數據結構進行功能性封裝，其他部分的代碼就著重於對數據的執行，而非數據的同步。在第8章中會看到類似的行為：將併發數據結構轉為一般的併發代碼。並行算法是使用多線程的方式提高性能，因為算法需要工作線程共享它們的數據，所以對併發數據結構的選擇就很關鍵了。