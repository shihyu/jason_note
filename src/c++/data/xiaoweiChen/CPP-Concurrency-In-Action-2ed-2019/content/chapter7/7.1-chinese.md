# 7.1 定義和意義

使用互斥量、條件變量，以及future可以用來同步算法和數據結構。調用庫函數將會掛起執行線程，直到其他線程完成某個特定動作。庫函數將調用阻塞操作來對線程進行阻塞，在阻塞解除前線程無法繼續自己的任務。通常，操作系統會完全掛起一個阻塞線程(並將其時間片交給其他線程)，直到解阻塞。“解阻塞”的方式很多，比如互斥鎖解鎖、通知條件變量達成，或讓“future狀態”就緒。

不使用阻塞庫的數據結構和算法稱為“無阻塞結構”。不過，無阻塞的數據結構並非都是無鎖的，那麼就來見識一下各種各樣的無阻塞的數據結構吧！

## 7.1.1 非阻塞數據結構

第5章中，使用`std::atomic_flag`實現了一個簡單的自旋鎖。

代碼7.1 使用`std::atomic_flag`實現了一個簡單的自旋鎖

```c++
class spinlock_mutex
{
  std::atomic_flag flag;
public:
  spinlock_mutex():
    flag(ATOMIC_FLAG_INIT)
  {}
  void lock()
  {
    while(flag.test_and_set(std::memory_order_acquire));
  }
  void unlock()
  {
    flag.clear(std::memory_order_release);
  }
};
```

這段代碼沒有調用任何阻塞函數，lock()只是讓循環持續調用test_and_set()，並返回false。這就是為什麼取名為“自旋鎖”的原因——代碼“自旋”於循環當中。所以沒有阻塞調用，任意代碼使用互斥量來保護共享數據都是非阻塞的。不過，自旋鎖並不是無鎖結構。這裡用了一個鎖，並且一次能鎖住一個線程。讓我們來看一下無鎖結構的具體定義，這將有助於你判斷哪些類型的數據結構是無鎖的。這些類型有：

* 無阻礙——如果其他線程都暫停了，任何給定的線程都將在一定時間內完成操作。
* 無鎖——如果多個線程對一個數據結構進行操作，經過一定時間後，其中一個線程將完成其操作。
* 無等待——即使有其他線程也在對該數據結構進行操作，每個線程都將在一定的時間內完成操作。

大多數情況下無阻塞算法用的很少——其他線程都暫停的情況太少見了，因此這種方式用於描述一個失敗的無鎖實現更為合適。從無鎖結構開始，來瞭解這些特性到都涉及到了哪些數據結構。

## 7.1.2 無鎖數據結構

無鎖結構意味著線程可以併發的訪問數據結構，線程不能做相同的操作。一個無鎖隊列可能允許一個線程壓入數據，另一個線程彈出數據，當有兩個線程同時添加元素時，將破壞這個數據結構。不僅如此，當調度器中途掛起其中一個訪問線程時，其他線程必須能夠繼續完成自己的工作，而無需等待掛起線程。

具有“比較/交換”操作的數據結構，通常有一個循環。使用“比較/交換”操作的原因：當有其他線程同時對指定的數據進行修改時，代碼將嘗試恢復數據。當其他線程掛起時，“比較/交換”操作執行成功，這樣的代碼就是無鎖的。當執行失敗時，就需要一個自旋鎖，且這個結構就是“無阻塞-有鎖”的結構。

無鎖算法中的循環會讓一些線程處於“飢餓”狀態。如有線程在“錯誤”時間執行，那麼第一個線程將會不停的嘗試所要完成的操作(其他程序繼續執行)。“無鎖-無等待”數據結構的出現，就為了避免這種問題。

## 7.1.3 無等待數據結構

無等待數據結構：首先是無鎖數據結構，並且每個線程都能在有限的時間內完成操作，暫且不管其他線程是如何工作的。由於可能會和其他線程的行為衝突，從而算法會進行了若干次嘗試，因此無法做到無等待。本章的大多數例子都有一種特性——對compare_exchange_weak或compare_exchange_strong操作進行循環，並且循環次數沒有上限。操作系統對線程進行進行管理，有些線程的循環次數非常多，有些線程的循環次數就非常少。因此，這些操作不是無等待的。

正確實現一個無等待結構十分困難，要保證每個線程都能在有限的步驟內完成操作，必須確保每次執行的操作都是一次性的，並且當前線程中的操作不會影響其他線程的操作，這就會讓所使用到的操作變的相當複雜。

考慮到實現無鎖或無等待的數據結構非常困難，索性就實現一個數據結構吧。不過，需要保證收益要大於成本，那麼先來找一下成本和收益的平衡點吧！

## 7.1.4 無鎖數據結構的利與弊

使用無鎖結構的主要原因：最大化併發。使用基於鎖的容器，會讓線程阻塞或等待，並且互斥鎖削弱了結構的併發性。無鎖數據結構中，某些線程可以逐步執行。無等待數據結構中，每一個線程都可以獨自向前運行，這種理想的方式實現起來很難。結構太簡單，反而不容易實現。

使用無鎖數據結構的第二個原因就是魯棒性。當一個線程在持有鎖時被終止，那麼數據結構將會永久性的破壞。不過，當線程在無鎖數據結構上執行操作，在執行到一半終止時，數據結構上的數據沒有丟失(除了線程本身的數據)，其他線程依舊可以正常執行。

另一方面，當不能限制訪問數據結構的線程數量時，就需要注意不變量的狀態，或選擇替代品來保持不變量的狀態。同時，還需要注意操作的順序。為了避免未定義行為，及相關的數據競爭，必須使用原子操作對修改操作進行限制。不過，僅使用原子操作是不夠的，需要確定其他線程看到的修改，是否遵循正確的順序。

因為，沒有任何鎖(有可能存在活鎖)，死鎖問題不會困擾無鎖數據結構。活鎖的產生是兩個線程同時嘗試修改數據結構，但每個線程所做的修改操作都會讓另一個線程重啟，所以兩個線程就會陷入循環，多次的嘗試完成自己的操作。試想有兩個人要過獨木橋，當兩個人從兩頭向中間走的時候，他們會在中間碰到，然後需要再走回出發的地方，再次嘗試過獨木橋。要打破僵局，除非有人先到獨木橋的另一端(或是商量好了，或是走的快，或純粹是運氣)，要不這個循環將一直重複下去。不過活鎖的存在時間並不久，因為其依賴於線程調度。所以只是對性能有所消耗，而不是一個長期問題，但這個問題仍需要關注。根據定義，因其操作執行步驟有上限，無等待的代碼不會受活鎖所困擾。換句話說，無等待的算法要比等待算法的複雜度高，即使沒有其他線程訪問數據結構，也可能需要更多步驟來完成相應操作。

“無鎖-無等待”代碼的缺點：雖然提高了併發訪問的能力，減少了單個線程的等待時間，但是其可能會將整體性能拉低。首先，原子操作的無鎖代碼要慢於無原子操作的代碼，原子操作就相當於無鎖數據結構中的鎖。不僅如此，硬件必須通過同一個原子變量對線程間的數據進行同步。第8章將看到與“乒乓緩存”相關的原子變量(多個線程訪問同時進行訪問)，將會形成一個明顯的性能瓶頸。提交代碼之前，無論是基於鎖的數據結構，還是無鎖的數據結構，對性能的檢查都很重要(最壞的等待時間，平均等待時間，整體執行時間或者其他指標)。
