# 7.2 無鎖數據結構的例子

為了展示在設計無鎖數據結構中使用到的技術，我們將瞭解一些無鎖實現的簡單數據結構。不僅要在每個例子中描述一個數據結構的實現，還將使用這些例子的某些特別之處來闡述對於無鎖數據結構的設計。

無鎖結構依賴於原子操作和內存序，以確保多線程以正確的順序訪問數據結構，原子操作默認使用memory_order_seq_cst內存序。不過，後面的例子中會降低內存序的要求。雖然例子中沒有直接使用鎖，但需要注意`std::atomic_flag`。一些平臺上無鎖結構的實現(實際上在C++標準庫中實現)使用了內部鎖。另一些平臺上，基於鎖的簡單數據結構可能會更加合適，還有很多平臺的實現細節不明確。選擇一種實現前，需要明確需求，並且配置各種選項以滿足需求。

回到數據結構上，從最簡單的數據結構開始——棧。

## 7.2.1 實現一個無鎖的線程安全棧

棧的要求很簡單：查詢順序是添加順序的逆序——先入後出(LIFO)。所以，確保值能安全的入棧就十分重要，因為可能在入棧後，會馬上被其他線程索引，同時確保只有一個線程能索引到指定數據。最簡單的棧就是鏈表，head指針指向第一個節點(可能是下一個被索引到的節點)，並且每個節點依次指向下一個節點。

這樣的情況下，添加一個節點很簡單：

1. 創建新節點node。
2. 讓node->next指向head->next。
3. head->next指向node。

單線程中這種方式沒有問題，不過使用多線程對棧進行修改時，這幾步就不夠用了。有兩個線程同時添加節點時，第2步和第3步會產生條件競爭：一個線程可能在修改head值時，另一個線程正在執行第2步，並且在第3步中對head進行更新。就會使之前那個線程的結果丟棄，亦或是造成更加糟糕的後果。瞭解瞭如何解決這個條件競爭前，還要注意當head更新並指向了新節點時，另一個線程就能讀取到這個節點，因此head設置在指向新節點前。因為在這之後就不能對節點進行修改了，所以新節點準備就緒就很重要。

那如何應對條件競爭呢？答案就是：第3步的時候使用原子“比較/交換”操作，來保證步驟2對head進行讀取時，不會對head進行修改，有修改時可以循環“比較/交換”操作。下面的代碼中，就不用鎖來實現線程安全的push()函數。

代碼7.2 不用鎖實現push()

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    T data;
    node* next;

    node(T const& data_):  // 1
     data(data_)
    {}
  };

  std::atomic<node*> head;
public:
  void push(T const& data)
  {
    node* const new_node=new node(data); // 2
    new_node->next=head.load();  // 3
    while(!head.compare_exchange_weak(new_node->next,new_node));  // 4
  }
};
```

上面代碼能匹配之前的三個步驟：創建一個新節點②，設置新節點的next指針指向當前head③，並設置head指針指向新節點④。node結構用其自身的構造函數來進行數據填充①，必須保證節點在構造完成後能隨時彈出。之後需要使用compare_exchange_weak()來保證在被存儲到new_node->next的head指針和之前的一樣③。代碼的亮點是使用“比較/交換”操作：返回false時，因為比較失敗(例如，head被其他線程鎖修改)，會使用head中的內容更新new_node->next(第一個參數)的內容。因為編譯器會重新加載head指針，所以循環中不需要每次都重新加載head指針。同樣，因為循環可能直接就失敗了，所以使用compare_exchange_weak要好於使用compare_exchange_strong(詳見第5章)。

所以，暫時不需要pop()操作，可以先快速檢查一下push()的實現是否有違指導意見。這裡能拋出異常的點就在構造新node時①，其會自行處理且鏈表中的內容，所以是安全的。構建數據時將其作為node的一部分進行存儲，並且使用compare_exchange_weak()來更新head指針，所以沒有惡性條件競爭。“比較/交換”成功時，節點已經準備就緒且隨時可以提取。因為沒有鎖，所以不存在死鎖，這裡的push()函數實現的很成功。

已經有往棧中添加數據的方法了，現在需要刪除數據的方法。也很簡單，其步驟如下：

1. 獲取head。
2. 讀取head->next指向的結點node。
3. 設置head->next指向node->next。
4. 通過node返回攜帶的數據data。
5. 刪除node節點。

多線程環境下，就不那麼簡單了。有兩個線程要從棧中移除數據時，兩個線程可能在步驟1中讀取到同一個head(值相同)。其中一個線程處理到步驟5時，另一個線程還在處理步驟2，這個還在處理步驟2的線程將會解引用一個懸空指針。這是書寫無鎖代碼的問題之一，所以現在只能跳過步驟5，讓節點洩露。

另一個問題：兩個線程讀取到同一個head值時，將它們返回給同一個節點。這就違反了棧結構的意圖，所以需要避免這樣的情況發生。可以像在push()函數中解決條件競爭那樣來解決這個問題：使用“比較/交換”操作更新head。當“比較/交換”操作失敗時，不是一個新節點已被推入，就是其他線程已經彈出了節點。無論是哪種情況，都得返回步驟1(“比較/交換”操作將會重新讀取head)。

當“比較/交換”成功，就可以確定當前線程是彈出指定節點的唯一線程，之後就可以放心的執行步驟4了。這裡先看一下pop()的雛形：

```c++
template<typename T>
class lock_free_stack
{
public:
  void pop(T& result)
  {
    node* old_head=head.load();
    while(!head.compare_exchange_weak(old_head,old_head->next));
    result=old_head->data;
  }
};
```

這段代碼很優雅，但有兩個節點洩露的問題。首先，這段代碼在空鏈表時不工作：當head指針是空指針時，要訪問next指針時，將引起未定義行為。很容易通過對nullptr的檢查進行修復(在while循環中)，要不對空棧拋出一個異常，要不返回一個bool值來表明成功與否。

第二個問題就是異常安全。第3章中介紹棧結構時，瞭解了在返回值時會出現異常安全問題：有異常拋出時，複製的值將丟失。這種情況下，傳入引用是一種可以接受的解決方案，這樣就能保證當有異常拋出時，棧上的數據不會丟失。不幸的是， 當線程返回節點時才能安全地進行拷貝，這時這個節點已經從隊列中刪除了。因此，通過引用獲取返回值的方式不可取。若想要安全的返回，必須使用第3章中的其他方法：返回指向數據值的(智能)指針。

返回的是智能指針時，返回nullptr表明沒有值可返回，但是要求在堆上對智能指針進行內存分配。將分配過程做為pop()的一部分時(也沒有更好的選擇了)，堆分配內存時可能會拋出一個異常。與此相反，在push()操作中對內存進行分配——無論怎樣，都需要對node進行內存分配。返回一個`std::shared_ptr<>`不會拋出異常，所以在pop()中進行內存分配是安全的。

代碼7.3 帶有節點洩露的無鎖棧

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    std::shared_ptr<T> data;  // 1 指針獲取數據
    node* next;

    node(T const& data_):
      data(std::make_shared<T>(data_))  // 2 讓std::shared_ptr指向新分配出來的T
    {}
  };

  std::atomic<node*> head;
public:
  void push(T const& data)
  {
    node* const new_node=new node(data);
    new_node->next=head.load();
    while(!head.compare_exchange_weak(new_node->next,new_node));
  }
  std::shared_ptr<T> pop()
  {
    node* old_head=head.load();
    while(old_head && // 3 在解引用前檢查old_head是否為空指針
      !head.compare_exchange_weak(old_head,old_head->next));
    return old_head ? old_head->data : std::shared_ptr<T>();  // 4
  }
};
```

智能指針指向當前數據①，必須在堆上為數據分配內存(node結構體中)②。而後，compare_exchage_weak()循環中③，需要在old_head指針前，檢查指針是否為空。如果存在相關節點，將會返回相關節點的值。不存在時，將返回一個空指針④。注意，結構是無鎖的，不是無等待的，因為在push()和pop()函數中都有while循環，當compare_exchange_weak()失敗的時候，循環將會持續下去。

如果一個垃圾收集機制(就像在管理語言中，比如C#語言或Java語言)，那到這就結束了，節點一旦它不再被任何線程訪問，將被收集和循環利用。然而，並不是所有C++編譯器都有垃圾回收機制。

## 7.2.2 終止內存洩露：使用無鎖數據結構管理內存

第一次瞭解pop()時，為了避免條件競爭(當有線程刪除一個節點的同時，其他線程還持有指向該節點的指針，並且要解引用)選擇了帶有內存洩露的節點。因為內存洩露是不可接受的，所以現在來解決這個問題！

基本問題在於，當釋放一個節點時，需要確認其他線程沒有持有這個節點。只有一個線程調用pop()時，可以放心的釋放。當節點添加入棧後，push()就不會與節點有任何的關係了，所以調用pop()函數的線程只和已加入節點有關，並且能夠安全的將節點刪除。

另一方面，棧處理多線程對pop()的調用時，就知道節點什麼時候刪除，這需要一個專用的垃圾回收器。聽起來相當棘手，不過也沒多難：檢查pop()可訪問哪些節點。不需擔心push()中的節點，因為這些節點要推到棧上以後才能訪問，而多線程只能通過pop()訪問同一節點。

沒有線程調用pop()時，就可以刪除棧上的節點。添加節點到“可刪除”列表中時，就能從結點中提取數據了。沒有線程通過pop()訪問節點時，可以安全的刪除這些節點了。

怎麼知道沒有線程調用pop()？計數即可。當計數器數值增加時，就有節點推入。當減少時，就有節點刪除。從“可刪除”列表中刪除節點就很安全，直到計數器的值為0為止。計數器必須是原子的，這樣才能在多線程的情況下正確的進行計數。下面的代碼中，展示了修改後的pop()函數，有些功能實現將在代碼7.5中給出。

代碼7.4 沒有線程使用pop()訪問節點時，就對節點進行回收

```c++
template<typename T>
class lock_free_stack
{
private:
  std::atomic<unsigned> threads_in_pop;  // 1 原子變量
  void try_reclaim(node* old_head);
public:
  std::shared_ptr<T> pop()
  {
    ++threads_in_pop;  // 2 在做事之前，計數值加1
    node* old_head=head.load();
    while(old_head &&
      !head.compare_exchange_weak(old_head,old_head->next));
    std::shared_ptr<T> res;
    if(old_head)
    { 
      res.swap(old_head->data);  // 3 回收刪除的節點
    }
    try_reclaim(old_head);  // 4 從節點中直接提取數據，而非拷貝指針
    return res;
  }
};
```

threads_in_pop①原子變量用來記錄有多少線程試圖彈出棧中的元素。調用pop()②函數時，計數器加1。調用try_reclaim()時，計數器減1。節點調用函數時，說明節點已刪除④。因為暫時不需要將節點刪除，可以通過swap()函數來刪除節點上的數據③(而非只是拷貝指針)，當不再需要這些數據時，數據會自動刪除，而不是持續存在(因為還有對未刪除節點的引用)。接下來看一下try_reclaim()是如何實現的。

代碼7.5 使用引用計數的回收機制

```c++
template<typename T>
class lock_free_stack
{
private:
  std::atomic<node*> to_be_deleted;

  static void delete_nodes(node* nodes)
  {
    while(nodes)
    {
      node* next=nodes->next;
      delete nodes;
      nodes=next;
    }
  }
  void try_reclaim(node* old_head)
  {
    if(threads_in_pop==1)  // 1
    {
      node* nodes_to_delete=to_be_deleted.exchange(nullptr);  // 2 聲明“可刪除”列表
      if(!--threads_in_pop)  // 3 是否只有一個線程調用pop()?
      {
        delete_nodes(nodes_to_delete);  // 4
      }
      else if(nodes_to_delete)  // 5
      {
         chain_pending_nodes(nodes_to_delete);  // 6
      }
      delete old_head;  // 7
    }
    else
    {
      chain_pending_node(old_head);  // 8
      --threads_in_pop;
    }
  }
  void chain_pending_nodes(node* nodes)
  {
    node* last=nodes;
    while(node* const next=last->next)  // 9 讓next指針指向鏈表的末尾
    {
      last=next;
    }
    chain_pending_nodes(nodes,last);
  }

  void chain_pending_nodes(node* first,node* last)
  {
    last->next=to_be_deleted;  // 10
    while(!to_be_deleted.compare_exchange_weak(  // 11 用循環來保證last->next的正確性
      last->next,first));
    }
    void chain_pending_node(node* n)
    {
      chain_pending_nodes(n,n);  // 12
    }
};
```

回收節點時①，threads_in_pop是1，當前線程對pop()進行訪問時，就可以安全的將節點刪除⑦(將等待節點刪除也是安全的)。當數值不是1時，刪除任何節點都不安全，所以需要向等待列表中繼續添加節點⑧。

假設某一時刻，threads_in_pop值為1。就可以嘗試回收等待列表，如果不回收，節點就會繼續等待，直到整個棧被銷燬。要做到回收，首先要通過原子exchange操作聲明②刪除列表，並將計數器減1③。如果之後計數的值為0，意味著沒有其他線程訪問等待節點鏈表。不必為出現新的等待節點而煩惱，因為它們會安全的回收。而後，可以使用delete_nodes對鏈表進行迭代，並將其刪除④。

計數值在減後不為0時，回收節點就不安全。如果存在⑤，就需要將其掛在等待刪除鏈表後⑥，這種情況會發生在多個線程同時訪問數據結構的時候。一些線程在第一次測試threads_in_pop①和對“回收”鏈表的聲明②操作間調用pop()，這可能會將已經訪問的節點新填入到鏈表中。圖7.1中，線程C添加節點Y到to_be_deleted鏈表中，即使線程B仍將其引用作為old_head，之後會嘗試訪問其next指針。線程A刪除節點時，會造成線程B發生未定義行為。

![](../../images/chapter7/7-1.png)

圖7.1 三個線程同時調用pop()，要在try_reclaim()對聲明節點進行刪除前對threads_in_pop進行檢查。

為了將等待刪除的節點加入刪除鏈表，需要複用節點的next指針將等待刪除節點鏈接在一起。將已存在的鏈表鏈接到刪除鏈表後面，通過遍歷的方式找到鏈表的末尾⑨，將最後一個節點的next指針替換為當前to_be_deleted指針⑩，並且將鏈表的第一個節點作為新的to_be_deleted指針進行存儲⑪。這需要在循環中使用compare_exchange_weak來保證通過線程添加進來的節點，不會發生內存洩露。鏈表發生改變時，更新next指針會很方便。添加單個節點是一種特殊情況，因為需要將這個節點作為第一個節點進行添加(同時作為最後一個節點)⑫。

棧處於低負荷狀態時，這種方式沒有問題，因為在沒有線程訪問pop()。不過，這只是瞬時的狀態，也就是在回收前，需要檢查threads_in_pop計數為0③的原因，也是刪除節點⑦前進行對計數器檢查的原因。刪除節點是一項非常耗時的工作，並且希望其他線程對鏈表做的修改越少越好。從第一次發現threads_in_pop是1，到嘗試刪除節點，會用耗費很長的時間，就會讓線程有機會調用pop()，讓threads_in_pop不為0，阻止節點的刪除操作。

棧處於高負荷狀態時，因為其他線程在初始化後都能使用pop()，所以to_ne_deleted鏈表將會無限增加，會再次洩露。不存在任何靜態情況時，就得為回收節點尋找替代機制。關鍵是要確定無線程訪問給定節點，這樣給定節點就能回收，所以最簡單的替換機制就是使用*風險指針*(hazard pointer)。

## 7.2.3 使用風險指針檢測不可回收的節點

“風險指針”這個術語引用於Maged Michael的研究[1]，之所以這樣叫是因為刪除一個節點可能會讓其他引用線程處於危險狀態。其他線程持有已刪除節點的指針對其進行解引用操作時，會出現未定義行為。基本觀點就是，當有線程去訪問(其他線程)刪除的對象時，會先對這個對象設置風險指針，而後通知其他線程——使用這個指針是危險的行為。當這個對象不再需要，就可以清除風險指針。如果瞭解牛津/劍橋的龍舟比賽，其實這裡使用的機制和龍舟比賽開賽時差不多：每個船上的舵手都舉起手來，以表示他們還沒有準備好。只要有舵手舉著手，裁判就不能讓比賽開始。當所有舵手的手都放下後，比賽才能開始。比賽未開始或感覺自己船隊的情況有變時，舵手可以再次舉手。

當線程想要刪除一個對象，就必須檢查系統中其他線程是否持有風險指針。當沒有風險指針時，就可以安全刪除對象。否則，就必須等待風險指針消失。這樣，線程就需要週期性的檢查要刪除的對象是否能安全刪除。

看起來很簡單，在C++中應該怎麼做呢？

首先，需要能存儲指向訪問對象的指針，也就是風險指針。指針必須能讓所有線程看到，需要線程能夠對數據結構進行訪問。正確且高效的分配這些線程的確是一個挑戰，所以這個問題放在後面解決。假設有一個get_hazard_pointer_for_current_thread()函數，可以返回風險指針的引用。當讀取一個指針，並且想要解引用它的時候，就需要這個函數——這種情況下head數值源於下面的列表：

```c++
std::shared_ptr<T> pop()
{
  std::atomic<void*>& hp=get_hazard_pointer_for_current_thread();
  node* old_head=head.load();  // 1
  node* temp;
  do
  {
    temp=old_head;
    hp.store(old_head);  // 2
    old_head=head.load();
  } while(old_head!=temp); // 3
  // ...
}
```

while循環能保證node不會在讀取舊head指針①時，以及設置風險指針②時被刪除。這種模式下，其他線程不知道有線程對這個節點進行了訪問。幸運的是，舊head節點要刪除時，head本身會發生變化，所以需要對head進行檢查並持續循環，直到head指針中的值與風險指針中的值相同③。使用默認的new和delete操作對風險指針進行操作時，會出現未定義行為，所以需要確定實現是否支持這樣的操作，或使用自定義內存分配器來保證用法的正確性。

現在已經設置了風險指針，就可以對pop()進行處理了，基於瞭解到的安全知識，不會有其他線程來刪除節點。每一次重新加載old_head後，解引用讀取到指針時，就需要更新風險指針。從鏈表中提取節點時，就可以清除風險指針。如果沒有其他風險指針引用節點，就可以安全的刪除節點了；否則，就需要將其添加到鏈表中，之後再進行刪除。下面的代碼就是對該方案的完整實現。

代碼7.6 使用風險指針實現的pop()

```c++
std::shared_ptr<T> pop()
{
  std::atomic<void*>& hp=get_hazard_pointer_for_current_thread();
  node* old_head=head.load();
  do
  {
    node* temp;
    do  // 1 直到將風險指針設為head指針
    {
      temp=old_head;
      hp.store(old_head);
      old_head=head.load();
    } while(old_head!=temp);
  }
  while(old_head &&
    !head.compare_exchange_strong(old_head,old_head->next));
  hp.store(nullptr);  // 2 當聲明完成，清除風險指針
  std::shared_ptr<T> res;
  if(old_head)
  {
    res.swap(old_head->data);
    if(outstanding_hazard_pointers_for(old_head))  // 3 在刪除之前對風險指針引用的節點進行檢查
    {
      reclaim_later(old_head);  // 4
    }
    else
    {
      delete old_head;  // 5
    }
    delete_nodes_with_no_hazards();  // 6
  }
  return res;
}
```

首先，循環內部會對風險指針進行設置。“比較/交換”操作失敗時會重載old_head，再次進行設置①。因為需要在循環內部做一些實際的工作，所以要使用compare_exchange_strong()：當compare_exchange_weak()偽失敗後，風險指針將重置(沒有必要)。過程能保證風險指針在解引用(old_head)之前被正確的設置。已聲明瞭一個風險指針時，就可以將其清除了②。如果想要獲取一個節點，就需要檢查其他線程上的風險指針，檢查是否有其他指針引用該節點③。如果有，就不能刪除節點，需要將其放回鏈表中，之後再進行回收④；如果沒有，就能直接將這個節點刪除⑤。最後需要對任意節點進行檢查，可以調用reclaim_later()。如果鏈表上沒有任何風險指針引用節點，就可以安全的刪除這些節點⑥。當有節點持有風險指針，就只能等待下一個調用pop()的線程退出。

當然，這些函數——get_hazard_pointer_for_current_thread(), reclaim_later(), outstanding_hazard_pointers_for(), 和delete_nodes_with_no_hazards()——的實現細節我們還沒有看到，先來看看它們是如何工作的。

為線程分配風險指針實例的具體方案：使用get_hazard_pointer_for_current_thread()與程序邏輯沒什麼關係(不過會影響效率，接下會看到具體的情況)。可以使用一個簡單的結構體：固定長度的“線程ID-指針”數組。get_hazard_pointer_for_curent_thread()可以通過這個數據來找到第一個釋放槽，並將當前線程的ID放入到這個槽中。線程退出時，槽就再次置空，可以通過默認構造`std::thread::id()`將線程ID放入槽中。實現如下：

代碼7.7 get_hazard_pointer_for_current_thread()函數的簡單實現

```c++
unsigned const max_hazard_pointers=100;
struct hazard_pointer
{
  std::atomic<std::thread::id> id;
  std::atomic<void*> pointer;
};
hazard_pointer hazard_pointers[max_hazard_pointers];

class hp_owner
{
  hazard_pointer* hp;

public:
  hp_owner(hp_owner const&)=delete;
  hp_owner operator=(hp_owner const&)=delete;
  hp_owner():
    hp(nullptr)
  {
    for(unsigned i=0;i<max_hazard_pointers;++i)
    {
      std::thread::id old_id;
      if(hazard_pointers[i].id.compare_exchange_strong(  // 6 嘗試聲明風險指針的所有權
         old_id,std::this_thread::get_id()))
      {
        hp=&hazard_pointers[i];
        break;  // 7
      }
    }
    if(!hp)  // 1
    {
      throw std::runtime_error("No hazard pointers available");
    }
  }

  std::atomic<void*>& get_pointer()
  {
    return hp->pointer;
  }

  ~hp_owner()  // 2
  {
    hp->pointer.store(nullptr);  // 8
    hp->id.store(std::thread::id());  // 9
  }
};

std::atomic<void*>& get_hazard_pointer_for_current_thread()  // 3
{
  thread_local static hp_owner hazard;  // 4 每個線程都有自己的風險指針
  return hazard.get_pointer();  // 5
}
```

get_hazard_pointer_for_current_thread()的實現看起來很簡單③：一個hp_owner④類型的thread_local(本線程所有)變量，用來存儲當前線程的風險指針，返回這個變量所持有的指針⑤。之後的工作：有線程第一次調用這個函數時，新hp_owner實例就被創建。這個實例的構造函數⑥會通過查詢“所有者/指針”表，用compare_exchange_strong()來檢查某個記錄是否有所有者，並進行析構②。compare_exchange_strong()失敗時，其他線程也可擁有這個記錄，所以可以繼續執行下去。當交換成功，當前線程就擁有了這些記錄，而後進行存儲並停止搜索⑦。遍歷了列表也沒有找到物所有權的記錄①時，就說明有很多線程在使用風險指針，所以會拋出一個異常。

當創建hp_owner後的訪問會很快，因為指針在緩存中，所以表不需要再次遍歷。

當線程退出時，hp_owner的實例將會銷燬。析構函數會在`std::thread::id()`設置擁有者ID前，將指針重置為nullptr，這樣就允許其他線程對這條記錄進行復用⑧⑨。

實現get_hazard_pointer_for_current_thread()後，outstanding_hazard_pointer_for()實現就簡單了：只需要對風險指針表進行搜索，就可以找到對應的記錄。

```c++
bool outstanding_hazard_pointers_for(void* p)
{
  for(unsigned i=0;i<max_hazard_pointers;++i)
  {
    if(hazard_pointers[i].pointer.load()==p)
    {
      return true;
    }
  }
  return false;
}
```

實現不需要對記錄的所有者進行驗證：沒有所有者的記錄會是空指針，所以比較代碼將總返回false。

reclaim_later()和delete_nodes_with_no_hazards()可以對簡單的鏈表進行操作，reclaim_later()只是將節點添加到列表中，delete_nodes_with_no_hazards()就是搜索整個列表，並將無風險指針的記錄進行刪除。

代碼7.8 回收函數的簡單實現

```c++
template<typename T>
void do_delete(void* p)
{
  delete static_cast<T*>(p);
}

struct data_to_reclaim
{
  void* data;
  std::function<void(void*)> deleter;
  data_to_reclaim* next;

  template<typename T>
  data_to_reclaim(T* p):  // 1
    data(p),
    deleter(&do_delete<T>),
    next(0)
  {}

  ~data_to_reclaim()
  {
    deleter(data);  // 2
  }
};

std::atomic<data_to_reclaim*> nodes_to_reclaim;

void add_to_reclaim_list(data_to_reclaim* node)  // 3
{
  node->next=nodes_to_reclaim.load();
  while(!nodes_to_reclaim.compare_exchange_weak(node->next,node));
}

template<typename T>
void reclaim_later(T* data)  // 4
{
  add_to_reclaim_list(new data_to_reclaim(data));  // 5
}

void delete_nodes_with_no_hazards()
{
  data_to_reclaim* current=nodes_to_reclaim.exchange(nullptr);  // 6
  while(current)
  {
    data_to_reclaim* const next=current->next;
    if(!outstanding_hazard_pointers_for(current->data))  // 7
    {
      delete current;  // 8
    }
    else
    {
      add_to_reclaim_list(current);  // 9
    }
    current=next;
  }
}
```

首先，reclaim_later()是一個函數模板④。風險指針是一個通用解決方案，不能將棧節點的類型寫死。使用`std::atomic<void*>`對風險指針進行存儲，需要對任意類型的指針進行處理。但不能使用`void*`形式，因為當要刪除數據項時，delete操作只能對實際類型指針進行操作。data_to_reclaim的構造函數就很優雅：reclaim_later()只創建一個data_to_reclaim的實例，並且將實例添加到回收鏈表中⑤。add_to_reclaim_list()③就是使用compare_exchange_weak()循環來訪問鏈頭。

回到data_to_reclaim的構造函數①：構造函數也是模板函數。會刪除的成員數據類型為`void*`，併為do_deltete()函數提供一個合適的指針實例——將`void*`類型轉換成要刪除的類型，然後刪除指針所指向的對象。`std::function<>`可以安全的產生函數指針，所以data_to_reclaim的析構函數可以通過調用存儲的函數對數據進行刪除②。

將節點添加入鏈表時，不會調用data_to_reclaim的析構函數。析構函數會在沒有風險指針指向節點的時候調用，這也就是delete_nodes_with_no_hazards()的作用。

delete_nodes_with_no_hazards()將已聲明的鏈表節點進行回收，使用的是exchange()函數⑥(這個步驟簡單且關鍵，是為了保證只有一個線程進行回收操作)。其他線程就能自由將節點添加到鏈表中，或在不影響回收指定節點線程的情況下對節點進行回收。

只要有節點存在於鏈表中，就需要檢查每個節點，查看風險指針是否指向節點⑦。如果沒有風險指針，就可以安全的將記錄刪除(並且清除存儲的數據)⑧。否則，只能將這個節點添加到鏈表的後面，再進行回收⑨。

實現雖然很簡單，也的確安全的回收了刪除的節點，不過增加了很多開銷。遍歷風險指針數組需要檢查max_hazard_pointers原子變量，並且每次pop()調用時，都需要再檢查一遍。原子操作很耗時，所以pop()成為了性能瓶頸，不僅需要遍歷節點的風險指針鏈表，還要遍歷等待鏈表上的每一個節點。有max_hazard_pointers在鏈表中時，就需要檢查max_hazard_pointers個已存儲的風險指針。

還有更好一點的方法嗎？

**對風險指針(較好)的回收策略**

當然有，這裡展示一個風險指針的簡單實現，從而來解釋技術問題。首先，考慮內存性能。比起對回收鏈表上的每個節點進行檢查都要調用pop()，除非有超過max_hazard_pointer數量的節點存在於鏈表之上，否則就不需要嘗試回收任何節點。這樣就能保證至少有一個節點能夠回收，如果等待鏈表中的節點數量達到max_hazard_pointers+1，那和之前的方案差不多。當獲取了max_hazard_pointers數量的節點時，可以調用pop()對節點進行回收，所以這樣也不好。不過，當有2×max_hazard_pointers個節點在列表中時，就能保證至少有max_hazard_pointers個節點可以回收。再次嘗試回收任意節點前，至少會對pop()有max_hazard_pointers次調用，這就很不錯了。比起檢查max_hazard_pointers個節點就調用max_hazard_pointers次pop()(而且還不一定能回收節點)，檢查2×max_hazard_pointers個節點時，每max_hazard_pointers次對pop()的調用，就會有max_hazard_pointers個節點可回收。就意味著，對兩個節點檢查調用pop()，就有一個節點能回收。

這個方法的缺點(有增加內存使用的情況)：需要對回收鏈表上的節點進行原子計數，並且還有很多線程爭相對回收的鏈表進行訪問。如果內存盈餘，可以使用更多內存的來實現更好的回收策略：作為線程的本地變量，每個線程中的都擁有其自己的回收鏈表，這樣就不需要原子計數了。這樣的話，只需要分配max_hazard_pointers x max_hazard_pointers個節點。所有節點被回收完畢前時有線程退出，其本地鏈表可以像之前一樣保存在全局中，並且添加到下一個線程的回收鏈表中，讓下一個線程對這些節點進行回收。

風險指針另一個缺點：與IBM申請的專利所衝突[2]。要讓寫軟件能夠被他人使用，就必須擁有合法的知識產權，所以需要擁有合適的許可證。這對所有無鎖內存回收技術都適用(這是一個活躍的研究領域)，很多大公司都會有自己的專利。你可能會問，“為什麼用了這麼大的篇幅來介紹一個大多數人都沒辦法的技術呢？”。首先，使用這種技術可能不需要買一個許可證。比如，當使用GPL下的免費軟件許可來進行軟件開發，軟件將不會包含到IBM的專利。其次，設計無鎖代碼時，還需要從使用者的角度進行思考，比如：高消耗的原子操作。最後，有一個建議將風險指針納入到C++標準的未來修訂中，這種指針的確很好用，希望將來能夠使用到編譯器供應商的實現。

所以，是否有非專利的內存回收技術能使用呢？很幸運，的確有。引用計數就是這樣的機制。

## 7.2.4 使用引用計數

回到7.2.2節的問題，“想要刪除還能被其他讀者線程訪問的節點，該怎麼辦?"。當能安全並準確的瞭解節點是否還被引用，以及沒有線程訪問這些節點的具體時間，即可判斷是夠能將對應節點進行刪除。風險指針是通過將使用中的節點存放到鏈表中，而引用計數是通過對每個節點上訪問的線程數量進行統計。

看起來簡單粗暴……不，優雅，實際上管理起來卻是很困難：首先，由`std::shared_ptr<>`來完成這個任務，其有內置引用計數的指針。不幸的是，雖然`std::shared_ptr<>`上的一些操作是原子的，不過其也不能保證是無鎖的。智能指針上的原子操作和對其他原子類型的操作並沒有什麼不同，但是`std::shared_ptr<>`旨在用於有多個上下文的情況下，並且在無鎖結構中使用原子操作，無異於對該類增加了很多性能開銷。如果平臺支持`std::atomic_is_lock_free(&some_shared_ptr)`實現返回true，那麼所有內存回收問題就都迎刃而解了。使用`std::shared_ptr<node>`構成的鏈表實現，如代碼7.9所示。需要注意的是，next指針是從已彈出的結構中獲取，為了避免指針讓所有node陷入深度自旋中，所以`std::shared_ptr`引用的最後一個node會被銷燬。

代碼7.9 無鎖棧——使用無鎖`std::shared_ptr<>`的實現

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    std::shared_ptr<T> data;
    std::shared_ptr<node> next;
    node(T const& data_):
      data(std::make_shared<T>(data_))
    {}
  };

  std::shared_ptr<node> head;
public:
  void push(T const& data)
  {
    std::shared_ptr<node> const new_node=std::make_shared<node>(data);
    new_node->next=head.load();
    while(!std::atomic_compare_exchange_weak(&head,
        &new_node->next,new_node));
  }
  std::shared_ptr<T> pop()
  {
    std::shared_ptr<node> old_head=std::atomic_load(&head);
    while(old_head && !std::atomic_compare_exchange_weak(&head,
        &old_head,old_head->next));
    if (old_head){
      std::atomic_store(&old_head->next, std::shared_ptr<node>());
      return old_head->data;
    }
    return std::shared_ptr<T>();
  }
  ~lock_free_stack(){
    while(pop());
  }
};
```

對`std::shared_ptr<>`使用無鎖原子操作的實現不僅很少見，而且能為其使用一致性的原子操作也很難。併發技術規範擴展提供了工具，可以來解決這個問題，擴展中在頭文件`<experimental/atomic>`中提供了` std::experimental::atomic_shared_ptr<T>`。多數情況下這與` std::atomic<std::shared_ptr<T>> `等價(除非是`std::atomic<> `不使用`std::shared_ptr<T>`)，因為其具有特殊的複製語義，可以正確的處理引用計數。也就是`std::experimental::atomic_shared_ptr<T>`能在確保原子操作的同事，正確的處理引用計數。與第5章中的其他原子類型一樣，其實現也不確定是否無鎖。代碼7.10是對代碼7.9的重寫，不需要記住atomic_load和atomic_store調用順序。

代碼7.10 使用` std::experimental::atomic_shared_ptr<>`實現的棧結構

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    std::shared_ptr<T> data;
    std::experimental::atomic_shared_ptr<node> next;
    node(T const& data_):
      data(std::make_shared<T>(data_))
    {}
  };
  std::experimental::atomic_shared_ptr<node> head;
public:
  void push(T const& data)
  {
    std::shared_ptr<node> const new_node=std::make_shared<node>(data);
    new_node->next=head.load();
    while(!head.compare_exchange_weak(new_node->next,new_node));
  }
  std::shared_ptr<T> pop()
  {
    std::shared_ptr<node> old_head=head.load();
    while(old_head && !head.compare_exchange_weak(
      old_head,old_head->next.load()));
    if(old_head) {
      old_head->next=std::shared_ptr<node>();
      return old_head->data;
    }
    return std::shared_ptr<T>();
  }
  ~lock_free_stack(){
    while(pop());
  }
};
```

一些情況下，使用`std::shared_ptr<>`實現的結構並非無鎖，需要手動管理引用計數。

一種方式是對每個節點使用兩個引用計數：內部計數和外部計數。兩個值的總和就是對這個節點的引用數。外部計數記錄有多少指針指向節點，即在指針每次進行讀取的時候，外部計數加1。當線程結束對節點的訪問時，內部計數減1。指針在讀取時，外部計數加1；讀取結束時，內部計數減1。

不需要“外部計數-指針”時(該節點就不能被多線程所訪問了)，外部計數減1和在被棄用的時候，內部計數將會增加。當內部計數等於0，就沒有指針對該節點進行引用，就可以將該節點安全的刪除。使用原子操作來更新共享數據也很重要。來看一下使用這種技術實現的無鎖棧，只有確定節點能安全刪除的情況下才能進行節點回收。

下面程序清單中就展示了內部數據結構，以及對push()簡單優雅的實現。

代碼7.11 使用分離引用計數的方式推送一個節點到無鎖棧中

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node;

  struct counted_node_ptr  // 1
  {
    int external_count;
    node* ptr;
  };

  struct node
  {
    std::shared_ptr<T> data;
    std::atomic<int> internal_count;  // 2
    counted_node_ptr next;  // 3

    node(T const& data_):
      data(std::make_shared<T>(data_)),
      internal_count(0)
    {}
  };

  std::atomic<counted_node_ptr> head;  // 4

public:
  ~lock_free_stack()
  {
    while(pop());
  }

  void push(T const& data)  // 5
  {
    counted_node_ptr new_node;
    new_node.ptr=new node(data);
    new_node.external_count=1;
    new_node.ptr->next=head.load();
    while(!head.compare_exchange_weak(new_node.ptr->next,new_node));
  }
};
```

外部計數包含在counted_node_ptr的指針中①，這個結構體會被node中的next指針③和內部計數②用到。counted_node_ptr是一個簡單的結構體，可以特化`std::atomic<>`模板來對鏈表的頭指針進行聲明④。

counted_node_ptr體積夠小，能夠讓`std::atomic<counted_node_ptr>`無鎖。一些平臺上支持雙字比較和交換操作，可以直接對結構體進行操作。平臺不支持這樣的操作時，最好使用`std::shared_ptr<>`變量，當類型的體積過大，超出了平臺支持指令，那麼原子`std::atomic<>`將使用鎖來保證其操作的原子性(從而會讓“無鎖”算法“基於鎖”來完成)。另外，如果想要限制計數器的大小，需要已知平臺上指針所佔的空間(比如，地址空間只剩下48位，而一個指針就要佔64位)，可以將計數存在一個指針空間內，為了適應平臺也可以存在一個機器字當中。這樣的技巧需要對特定系統有足夠的瞭解，不過這些討論超出本書的範疇。

push()相對簡單⑤，可構造一個counted_node_ptr實例，去引用新分配出來的(帶有相關數據的)node，並且將node中的next指針設置為當前head，之後使用compare_exchange_weak()對head的值進行設置。因為internal_count剛被設置其值為0，並且external_count是1，所以這個新節點只有一個外部引用(head指針)。

通常，pop()都有一個從繁到簡的過程，實現代碼如下。

代碼7.12 使用分離引用計數從無鎖棧中彈出一個節點

```c++
template<typename T>
class lock_free_stack
{
private:
  void increase_head_count(counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;

    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!head.compare_exchange_strong(old_counter,new_counter));  // 1

    old_counter.external_count=new_counter.external_count;
  }
public:
  std::shared_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load();
    for(;;)
    {
      increase_head_count(old_head);
      node* const ptr=old_head.ptr;  // 2
      if(!ptr)
      {
        return std::shared_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next))  // 3
      {
        std::shared_ptr<T> res;
        res.swap(ptr->data);  // 4

        int const count_increase=old_head.external_count-2;  // 5

        if(ptr->internal_count.fetch_add(count_increase)==  // 6
           -count_increase)
        {
          delete ptr;
        }

        return res;  // 7
      }
      else if(ptr->internal_count.fetch_sub(1)==1)
      {
        delete ptr;  // 8
      }
    }
  }
};
```

當加載head值後就必須將外部引用加1，表明這個節點正在引用，可保證解引用時的安全性。在引用計數增加前解引用指針，線程就能夠訪問這個節點，從而當前引用指針就成為了一個懸空指針，這就是將引用計數分離的主要原因：通過增加外部引用計數，保證指針在訪問期間的合法性。compare_exchange_strong()的循環中①完成增加，通過比較和設置整個結構體來保證，指針不會在同一時間內受其他線程修改。

計數增加就能安全的解引用ptr，並讀取head指針的值，訪問指向的節點②。當訪問到鏈表的末尾，指針就是空指針。當指針不為空時，就嘗試對head調用compare_exchange_strong()來刪除這個節點③。

compare_exchange_strong()成功時就擁有對應節點的所有權，並且可以和data進行交換④後返回。這樣數據就不會持續保存，因為其他線程也會對棧進行訪問，所以會有其他指針指向這個節點。而後，可以使用原子操作fetch_add⑥，將外部計數加到內部計數中去。如果引用計數為0，那麼之前的值(fetch_add返回的值)，在相加之前肯定是負數，這種情況下就可以將節點刪除。這裡需要注意的是，相加的值要比外部引用計數少2⑤。當節點已經從鏈表中刪除，就要減少一次計數，並且這個線程無法再次訪問指定節點，所以還要再減1。無論節點是否被刪除，都能完成操作，所以可以將獲取的數據進行返回⑦。

“比較/交換”③失敗時，就說明其他線程已經把對應節點刪除了，或者其他線程添加了一個新的節點到棧中。無論是哪種原因，需要通過“比較/交換”的調用，對具有新值的head重新進行操作。不過，首先需要減少節點(要刪除的節點)上的引用計數。這個線程將再也沒有辦法訪問這個節點了。如果當前線程持有最後一個引用(因為其他線程已經將這個節點從棧上刪除了)，那麼內部引用計數將會為1，所以減1的操作將會讓計數器為0。這樣，就能在循環⑧之前將對應節點刪除。

目前，使用默認`std::memory_order_seq_cst`內存序來規定原子操作的執行順序。大多數系統中，這種操作方式很耗時，且同步操作的開銷要高於內存序。現在，可以考慮對數據結構的邏輯進行修改，放寬內存序要求，沒有必要在棧上增加過度的開銷。現在讓我們來檢查一下棧的操作，並且思考，能對一些操作使用更加寬鬆的內存序麼？如果使用了，能確保安全性麼？

## 7.2.5 無鎖棧上的內存模型

修改內存序之前，需要檢查一下操作間的依賴關係，再去確定適合這種關係的最佳內存序。為了保證這種方式能夠工作，需要從線程的視角進行觀察。其中最簡單的視角就是向棧中推入一個數據項，之後讓其他線程從棧中彈出這個數據項。

這裡需要三個重要數據參與。

1. counted_node_ptr轉移的數據head。
2. head引用的node。
3. 節點所指向的數據項。

做push()的線程，會先構造數據項，並設置head。做pop()的線程，會先加載head，再做“比較/交換”操作，並增加引用計數，讀取對應的node節點，獲取next的指向值。next的值是非原子對象，所以為了保證讀取安全，必須確定存儲(推送線程)和加載(彈出線程)的先行關係。因為原子操作就是push()函數中的compare_exchange_weak()，所以需要獲取兩個線程間的先行關係。compare_exchange_weak()必須是`std::memory_order_release`或更嚴格的內存序。不過，compare_exchange_weak()調用失敗時，什麼都不會改變，並且可以持續循環下去，所以使用`std::memory_order_relaxed`就足夠了。

```c++
void push(T const& data)
{
  counted_node_ptr new_node;
  new_node.ptr=new node(data);
  new_node.external_count=1;
  new_node.ptr->next=head.load(std::memory_order_relaxed)
  while(!head.compare_exchange_weak(new_node.ptr->next,new_node,
    std::memory_order_release,std::memory_order_relaxed));
}
```

pop()的實現呢？為了確定先行關係，必須在訪問next值之前使用`std::memory_order_acquire`或更嚴格的內存序操作。因為，increase_head_count()中使用compare_exchange_strong()，會獲取next指針指向的舊值，所以要其獲取成功就需要確定內存序。如同調用push()那樣，當交換失敗，循環會繼續，所以在失敗時可使用自由序：

```c++
void increase_head_count(counted_node_ptr& old_counter)
{
  counted_node_ptr new_counter;

  do
  {
    new_counter=old_counter;
    ++new_counter.external_count;
  }
  while(!head.compare_exchange_strong(old_counter,new_counter,
        std::memory_order_acquire,std::memory_order_relaxed));

  old_counter.external_count=new_counter.external_count;
}
```

compare_exchange_strong()調用成功時，ptr中的值就被存到old_counter中。存儲操作是push()中的一個釋放操作，compare_exchange_strong()操作是一個獲取操作，現在存儲同步於加載，並且能夠獲取先行關係。因此，push()中存儲ptr的值要先行於在pop()中對ptr->next的訪問，目前的操作完全安全。

內存序對head.load()的初始化並不妨礙分析，現在就可以使用`std::memory_order_relaxed`。

接下來compare_exchange_strong()將old_head.ptr->next設置為head。是否需要做什麼來保證操作線程中的數據完整性呢？交換成功就能訪問ptr->data，所以需要保證在push()線程中對ptr->data進行存儲(在加載之前)。increase_head_count()中的獲取操作，保證與push()線程中的存儲和“比較/交換”操作同步。在push()線程中存儲數據，先行於存儲head指針；調用increase_head_count()先行於對ptr->data的加載。即使，pop()中的“比較/交換”操作使用`std::memory_order_relaxed`，這些操作還是能正常運行。唯一不同的地方就是，調用swap()讓ptr->data有所變化，且沒有其他線程可以對同一節點進行操作(這就是“比較/交換”操作的作用)。

compare_exchange_strong()失敗時，新值不會更新old_head，並繼續循環。因為確定了`std::memory_order_acquire`內存序在increase_head_count()中使用的可行性，所以使用`std::memory_order_relaxed`也可以。

其他線程呢？是否需要設置一些更為嚴格的內存序來保證其他線程的安全呢？回答是“不用”。因為，head只會因“比較/交換”操作有所改變，對於“讀-改-寫”操作來說，push()中的“比較/交換”操作是構成釋放序列的一部分。因此，即使有很多線程在同一時間對head進行修改，push()中的compare_exchange_weak()與increase_head_count()(讀取已存儲的值)中的compare_exchange_strong()也是同步的。

剩餘的就可以用來處理fetch_add()操作(用來改變引用計數的操作)，因為已知其他線程不可能對該節點的數據進行修改，所以從節點中返回數據的線程可以繼續執行。不過，當線程獲取修改後的值時，就代表操作失敗(swap()是用來提取數據項的引用)。為了避免數據競爭，要保證swap()先行於delete操作。一種簡單的解決辦法：在“成功返回”分支中對fetch_add()使用`std::memory_order_release`內存序，在“再次循環”分支中對fetch_add()使用`std::memory_order_acquire`內存序。不過，這·有點矯枉過正：只有一個線程做delete操作(將引用計數設置為0的線程)，所以只有這個線程需要獲取操作。因為fetch_add()是一個“讀-改-寫”操作，是釋放序列的一部分，所以可以使用一個額外的load()做獲取。當“再次循環”分支將引用計數減為0時，fetch_add()可以重載引用計數，使用`std::memory_order_acquire`為了保持需求的同步關係。並且，fetch_add()本身可以使用`std::memory_order_relaxed`。使用新pop()的棧實現如下。

代碼7.13 基於引用計數和自由原子操作的無鎖棧

```c++
template<typename T>
class lock_free_stack
{
private:
  struct node;
  struct counted_node_ptr
  {
    int external_count;
    node* ptr;
  };

  struct node
  {
    std::shared_ptr<T> data;
    std::atomic<int> internal_count;
    counted_node_ptr next;

    node(T const& data_):
      data(std::make_shared<T>(data_)),
      internal_count(0)
    {}
  };

  std::atomic<counted_node_ptr> head;

  void increase_head_count(counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;
   
    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!head.compare_exchange_strong(old_counter,new_counter,
                                        std::memory_order_acquire,
                                        std::memory_order_relaxed));
    old_counter.external_count=new_counter.external_count;
  }
public:
  ~lock_free_stack()
  {
    while(pop());
  }

  void push(T const& data)
  {
    counted_node_ptr new_node;
    new_node.ptr=new node(data);
    new_node.external_count=1;
    new_node.ptr->next=head.load(std::memory_order_relaxed)
    while(!head.compare_exchange_weak(new_node.ptr->next,new_node,
                                      std::memory_order_release,
                                      std::memory_order_relaxed));
  }
  std::shared_ptr<T> pop()
  {
    counted_node_ptr old_head=
       head.load(std::memory_order_relaxed);
    for(;;)
    {
      increase_head_count(old_head);
      node* const ptr=old_head.ptr;
      if(!ptr)
      {
        return std::shared_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next,
                                      std::memory_order_relaxed))
      {
        std::shared_ptr<T> res;
        res.swap(ptr->data);

        int const count_increase=old_head.external_count-2;

        if(ptr->internal_count.fetch_add(count_increase,
              std::memory_order_release)==-count_increase)
        {
          delete ptr;
        }

        return res;
      }
      else if(ptr->internal_count.fetch_add(-1,
                   std::memory_order_relaxed)==1)
      {
        ptr->internal_count.load(std::memory_order_acquire);
        delete ptr;
      }
    }
  }
};
```

這段歷練就要告一段落了，我們已經獲得比之前好很多的棧實現。深思熟慮後，通過使用更多的自由操作，在不影響併發性的同時提高性能。實現中的pop()有37行，而功能等同於代碼6.1中基於鎖的棧實現和代碼7.2中無內存管理的無鎖棧實現。接下來要設計的無鎖隊列，將看到類似的情況：無鎖結構的複雜性(主要在於內存的管理)。

## 7.2.6 實現一個無鎖的線程安全隊列

隊列的挑戰與棧的有些不同，因為push()和pop()在隊列中，操作的不是同一個地方。因此，同步需求就不一樣。需要保證對一端的修改是正確的，且對另一端是可見的。不過，代碼6.6中隊列有一個try_pop()成員函數，其作用和代碼7.2中簡單的無鎖棧的pop()功能差不多，就可以合理的假設無鎖代碼都很相似。這是為什麼呢？

如果將代碼6.6中的代碼作為基礎，就需要兩個node指針：head和tail。可以讓多線程對它們進行訪問，所以這兩個節點最好是原子的(就不用考慮互斥問題了)。讓我們對代碼6.6做一些修改，並看下應該從哪裡開始設計。

代碼7.14 單生產者/單消費者模型下的無鎖隊列

```c++
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    std::shared_ptr<T> data;
    node* next;
    
    node():
       next(nullptr)
    {}
  };

  std::atomic<node*> head;
  std::atomic<node*> tail;

  node* pop_head()
  {
    node* const old_head=head.load();
    if(old_head==tail.load())  // 1
    {
      return nullptr;
    }
    head.store(old_head->next);
    return old_head;
  }
public:
  lock_free_queue():
      head(new node),tail(head.load())
  {}

  lock_free_queue(const lock_free_queue& other)=delete;
  lock_free_queue& operator=(const lock_free_queue& other)=delete;

  ~lock_free_queue()
  {
    while(node* const old_head=head.load())
    {
      head.store(old_head->next);
      delete old_head;
    }
  }
  std::shared_ptr<T> pop()
  {
    node* old_head=pop_head();
    if(!old_head)
    {
      return std::shared_ptr<T>();
    }

    std::shared_ptr<T> const res(old_head->data);  // 2
    delete old_head;
    return res;
  }

  void push(T new_value)
  {
    std::shared_ptr<T> new_data(std::make_shared<T>(new_value));
    node* p=new node;  // 3
    node* const old_tail=tail.load();  // 4
    old_tail->data.swap(new_data);  // 5
    old_tail->next=p;  // 6
    tail.store(p);  // 7
  }
};
```

一眼望去，這個實現沒什麼毛病，當只有一個線程調用push()和pop()時，這種情況下隊列一點毛病沒有。這裡push()和pop()之間的先行關係就很重要了，這直接關係到獲取到的data。對tail的存儲⑦同步於對tail的加載①，存儲之前節點的data指針⑤先行於存儲tail。並且，加載tail先行於加載data指針②，所以對data的存儲要先行於加載，一切都沒問題。因此，這是一個完美的*單生產者，單消費者*(SPSC, single-producer, single-consume)隊列。

問題在於當多線程對push()或pop()併發調用。先看一下push()：如果有兩個線程併發調用push()，會新分配兩個節點作為虛擬節點③，也會讀取到相同的tail值④，因此也會同時修改同一個節點，同時設置data和next指針⑤⑥，明顯的數據競爭！

pop_head()函數也有類似的問題。當有兩個線程併發的調用這個函數時，這兩個線程就會讀取到同一個head，並且會通過next指針去修改舊值。兩個線程都能索引到同一個節點——真是一場災難！不僅要保證只有一個pop()線程可以訪問給定項，還要保證其他線程在讀取head時，可以安全的訪問節點中的next。這就和無鎖棧中pop()的問題一樣了。

pop()的問題解決了，那麼push()呢？問題在於為了獲取push()和pop()間的先行關係，就需要在為虛擬節點設置數據項前，更新tail指針。併發訪問push()時，因為每個線程所讀取到的是同一個tail，所以線程會進行競爭。

**多線程下的push()**

第一個選擇是，在兩個真實節點中添加一個虛擬節點。這種方法，需要當前tail節點更新next指針，這樣讓節點看起來像一個原子變量。當一個線程成功將next指針指向一個新節點，就說明其成功的添加了一個指針。否則，就需要再次讀取tail，並重新對指針進行添加。這裡就需要對pop()進行簡單的修改，為了消除持有空指針的節點再次進行循環。這個方法的缺點：每次pop()函數的調用，通常都要刪除兩個節點，每次添加一個節點，都需要分配雙份內存。

第二個選擇是，讓data指針原子化，通過“比較/交換”操作對其進行設置。如果“比較/交換”成功，就說明能獲取tail，並能夠安全的對其next指針進行設置，也就是更新tail。因為有其他線程對數據進行了存儲，所以會導致“比較/交換”操作的失敗，這時就要重新讀取tail，重新循環。當原子操作對於`std::shared_ptr<>`是無鎖的，就可以輕鬆一下了。如果不是，就需要一個替代方案：一種可能是讓pop()函數返回`std::unique_ptr<>`(畢竟，這個指針只能引用指定對象)，並且將數據作為普通指針存儲在隊列中的方案。這就需要隊列支持存儲`std::atomic<T*>`類型，對於compare_exchange_strong()的調用就很有必要了。使用類似於代碼7.11中的引用計數模式，來解決多線程對pop()和push()的訪問。

代碼7.15 push()的第一次修訂(不正確的)

```c++
void push(T new_value)
{
  std::unique_ptr<T> new_data(new T(new_value));
  counted_node_ptr new_next;
  new_next.ptr=new node;
  new_next.external_count=1;
  for(;;)
  {
    node* const old_tail=tail.load();  // 1
    T* old_data=nullptr;
    if(old_tail->data.compare_exchange_strong(
      old_data,new_data.get()))  // 2
    {
      old_tail->next=new_next;
      tail.store(new_next.ptr);  // 3
      new_data.release();
      break;
    }
  }
}
```

使用引用計數方案可以避免競爭，不過競爭不只在push()中。可以再看一下7.14中的修訂版push()，與棧中模式相同：加載原子指針①，並且對該指針解引用②。同時，另一個線程可以對指針進行更新③，最終回收該節點(在pop()中)。當節點回收後，再對指針進行解引用，就會導致未定義行為。有個誘人的方案，就是給tail也添加計數器，就像給head做的那樣，不過隊列中的節點的next指針中都已經擁有了一個外部計數。同一個節點上有兩個外部計數，為了避免過早的刪除節點，需要對之前引用計數方案進行修改。通過對node結構中外部計數器數量的統計，解決這個問題。外部計數器銷燬時，統計值減1(將對應的外部計數添加到內部)。當內部計數是0，且沒有外部計數器時，對應節點就可以安全的刪除了。這個技術是我查閱Joe Seigh的“原子指針+”項目[5]的時候看到的。下面push()的實現，使用的就是這種方案。

代碼7.16 使用帶有引用計數tail，實現的無鎖隊列中的push()

```c++
template<typename T>
class lock_free_queue
{
private:
  struct node;
  struct counted_node_ptr
  {
    int external_count;
    node* ptr;
  };

  std::atomic<counted_node_ptr> head;
  std::atomic<counted_node_ptr> tail;  // 1

  struct node_counter
  {
    unsigned internal_count:30;
    unsigned external_counters:2;  // 2
  };

  struct node
  {
    std::atomic<T*> data;
    std::atomic<node_counter> count;  // 3
    counted_node_ptr next;

    node()
    {
      node_counter new_count;
      new_count.internal_count=0;
      new_count.external_counters=2;  // 4
      count.store(new_count);

      next.ptr=nullptr;
      next.external_count=0;
     }
  };
public:
  void push(T new_value)
  {
    std::unique_ptr<T> new_data(new T(new_value));
    counted_node_ptr new_next;
    new_next.ptr=new node;
    new_next.external_count=1;
    counted_node_ptr old_tail=tail.load();

    for(;;)
    {
      increase_external_count(tail,old_tail);  // 5

      T* old_data=nullptr;
      if(old_tail.ptr->data.compare_exchange_strong(  // 6
           old_data,new_data.get()))
      {
        old_tail.ptr->next=new_next;
        old_tail=tail.exchange(new_next);
        free_external_counter(old_tail);  // 7
        new_data.release();
        break;
      }
      old_tail.ptr->release_ref();
    }
  }
};
```

代碼7.16中，tail和head一樣都是`atomic<counted_node_ptr>`類型①，並且node結構體中用count成員變量替換了之前的internal_count③。count成員變量包括了internal_count和外部external_counters成員②。注意，這裡需要2bit的external_counters，因為最多就有兩個計數器。因為使用了位域，所以就將internal_count指定為30bit的值，就能保證計數器的總體大小是32bit。內部計數值就有充足的空間來保證這個結構體能放在一個機器字中(包括32位和64位平臺)。為的就是避免條件競爭，將結構體作為單獨的實體來更新。讓結構體的大小保持在一個機器字內，對其的操作就如同原子操作一樣，還可以在多個平臺上使用。

node初始化時，internal_count設置為0，external_counter設置為2④，因為當新節點加入隊列中時，都會被tail和上一個節點的next指針所指向。push()與代碼7.14中的實現很相似，除了為了對tail中的值進行解引用，需要調用節點data成員變量的compare_exchange_strong()成員函數⑥保證值的正確性。在這之前還要調用increase_external_count()增加計數器的計數⑤，而後在對尾部的舊值調用free_external_counter()⑦。

push()處理完畢再來看一下pop()。下面的實現，將代碼7.12中的引用計數pop()與7.14中隊列pop()混合的版本。

代碼7.17 使用尾部引用計數，將節點從無鎖隊列中彈出

```c++
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    void release_ref();
  };
public:
  std::unique_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load(std::memory_order_relaxed);  // 1
    for(;;)
    {
      increase_external_count(head,old_head);  // 2
      node* const ptr=old_head.ptr;
      if(ptr==tail.load().ptr)
      {
        ptr->release_ref();  // 3
        return std::unique_ptr<T>();
      }
      if(head.compare_exchange_strong(old_head,ptr->next))  // 4
      {
        T* const res=ptr->data.exchange(nullptr);
        free_external_counter(old_head);  // 5
        return std::unique_ptr<T>(res);
      }
      ptr->release_ref();  // 6
    }
  }
};
```

進入循環時，在將加載值的外部計數增加②之前，需要加載old_head值作為啟動①。當head與tail節點相同的時候，就能對引用進行釋放③，因為隊列中沒有數據，所以返回的是空指針。如果隊列中還有數據，可以使用compare_exchange_strong()來做聲明④。與7.11中的棧一樣，將外部計數和指針做為一個整體進行比較。當外部計數或指針有所變化時，需要將引用釋放後，再次進行循環⑥。當交換成功時，已聲明的數據就歸線程所有。為已彈出節點釋放外部計數後⑤，就能把對應的指針返回給調用函數了。當兩個外部引用計數都被釋放，且內部計數降為0時，節點就可以刪除了。對應的引用計數函數將會在代碼7.18，7.19和7.20中展示。

代碼7.18 在無鎖隊列中釋放一個節點引用

```c++
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    void release_ref()
    {
      node_counter old_counter=
        count.load(std::memory_order_relaxed);
      node_counter new_counter;
      do
      {
        new_counter=old_counter;
        --new_counter.internal_count;  // 1
      }
      while(!count.compare_exchange_strong(  // 2
            old_counter,new_counter,
            std::memory_order_acquire,std::memory_order_relaxed));
      if(!new_counter.internal_count &&
         !new_counter.external_counters)
      {
        delete this;  // 3
      }
    }
  };
};
```

node::release_ref()的實現，只是對7.12中lock_free_stack::pop()進行了小幅度修改。不過，代碼7.12中的代碼僅是處理單個外部計數的情況，所以要修改internal_count①，只需要使用fetch_sub就能讓count結構體自動更新。因此，需要一個“比較/交換”循環②。當內外部計數都為0時，就代表這是最後一次引用，之後就可以將這個節點刪除③。

代碼7.19 從無鎖隊列中獲取一個節點的引用

```c++
template<typename T>
class lock_free_queue
{
private:
  static void increase_external_count(
    std::atomic<counted_node_ptr>& counter,
    counted_node_ptr& old_counter)
  {
    counted_node_ptr new_counter;
    do
    {
      new_counter=old_counter;
      ++new_counter.external_count;
    }
    while(!counter.compare_exchange_strong(
      old_counter,new_counter,
      std::memory_order_acquire,std::memory_order_relaxed));

    old_counter.external_count=new_counter.external_count;
  }
};
```

代碼7.19展示的是，並不是所有引用的釋放，都會得到一個新引用，並增加外部計數的值。increase_external_count()和代碼7.13中的increase_head_count()很相似，不同的是increase_external_count()作為靜態成員函數，通過將外部計數器作為第一個參數傳入函數進行更新，而非只操作一個固定的計數器。

代碼7.19 無鎖隊列中釋放節點外部計數器

```c++
template<typename T>
class lock_free_queue
{
private:
  static void free_external_counter(counted_node_ptr &old_node_ptr)
  {
    node* const ptr=old_node_ptr.ptr;
    int const count_increase=old_node_ptr.external_count-2;
    
    node_counter old_counter=
      ptr->count.load(std::memory_order_relaxed);
    node_counter new_counter;
    do
    {
      new_counter=old_counter;
      --new_counter.external_counters;  // 1
      new_counter.internal_count+=count_increase;  // 2
    }
    while(!ptr->count.compare_exchange_strong(  // 3
           old_counter,new_counter,
           std::memory_order_acquire,std::memory_order_relaxed));

    if(!new_counter.internal_count &&
       !new_counter.external_counters)
    {
      delete ptr;  // 4
    }
  }
};
```

與increase_external_count()對應的是free_external_counter()。這裡的代碼和代碼7.11中的lock_free_stack::pop()類似，不過做了一些修改用來處理external_counters計數。使用單個compare_exchange_strong()對計數結構體中的兩個計數器進行更新③。和代碼7.11一樣，internal_count會進行更新②，並且external_counters將會減1①。當內外計數值都為0，就沒有更多的節點可以引用，所以節點可以安全的刪除④，這個操作需要作為獨立的操作來完成(因此需要“比較/交換”循環)來避免條件競爭。如果將兩個計數器分開來更新，兩個線程的情況下，可能都會認為自己是最後一個引用者，從而將節點刪除，從而導致未定義行為。

現在的隊列工作正常且無競爭，但是有一個性能問題。當一個線程對old_tail.ptr->data成功的完成compare_exchange_strong()(7.15中的⑥)，就可以執行push()操作。並且，能確定沒有其他線程在同時執行push()操作。讓其他線程看到有新值的加入，因此在compare_exchange_strong()調用失敗的時候，線程會繼續循環。忙等待會消耗CPU的運算週期，因此這就是一個鎖。push()的首次調用是要在其他線程完成後，將阻塞去除後才能完成，所以實現只是*半無鎖*(no longer lock-free)結構。不僅如此，當線程阻塞時，操作系統會給不同的線程不同的優先級，用於獲取互斥鎖。當前情況下優先級相同，所以阻塞線程將會浪費CPU的運算週期，直到第一個線程完成其操作。處理的技巧出自於“無鎖技巧包”：等待線程可以幫助push()線程完成操作。

**無鎖隊列中的線程互助**

為了恢復代碼的無鎖屬性，需要讓等待線程做一些事情，也就是幫進展緩慢的線程完成工作。

這種情況下，可以知道線程應該去做什麼：尾節點的next指針需要指向一個新的虛擬節點，且tail之後也要更新，虛擬節是誰創建的並不重要。將next指針放入一個原子節點中時，就可以使用compare_exchange_strong()來設置next指針。next指針已經被設置，就可以使用compare_exchange_weak()循環對tail進行設置，能保證next指針始終引用的是同一個原始節點。如果引用的不是同一個原始節點，其他部分就已經更新，可以停止嘗試再次循環。只需要對pop()進行微小的改動，其目的就是為了加載next指針。

代碼7.21 修改pop()幫助push()完成工作

```c++
template<typename T>
class lock_free_queue
{
private:
  struct node
  {
    std::atomic<T*> data;
    std::atomic<node_counter> count;
    std::atomic<counted_node_ptr> next;  // 1
  };
public:
  std::unique_ptr<T> pop()
  {
    counted_node_ptr old_head=head.load(std::memory_order_relaxed);
    for(;;)
    {
      increase_external_count(head,old_head);
      node* const ptr=old_head.ptr;
      if(ptr==tail.load().ptr)
      {
        return std::unique_ptr<T>();
      }
      counted_node_ptr next=ptr->next.load();  // 2
      if(head.compare_exchange_strong(old_head,next))
      {
        T* const res=ptr->data.exchange(nullptr);
        free_external_counter(old_head);
        return std::unique_ptr<T>(res);
      } 
      ptr->release_ref();
    }
  }
};
```

修改很簡單：next指針線程就是原子的①，所以load②也是原子的。在這個例子中，可以使用默認memory_order_seq_cst內存序，所以這裡可以忽略對load()的顯式調用，並且依賴於加載對象隱式轉換成counted_node_ptr，不過這裡的顯式調用就可以用來提醒：哪裡需要顯式添加內存序。

以下代碼對push()有更多的展示。

代碼7.22 無鎖隊列中簡單的幫助性push()的實現

```c++
template<typename T>
class lock_free_queue
{
private:
  void set_new_tail(counted_node_ptr &old_tail,  // 1
                    counted_node_ptr const &new_tail)
  {
    node* const current_tail_ptr=old_tail.ptr;
    while(!tail.compare_exchange_weak(old_tail,new_tail) &&  // 2
          old_tail.ptr==current_tail_ptr);
    if(old_tail.ptr==current_tail_ptr)  // 3
      free_external_counter(old_tail);  // 4
    else
      current_tail_ptr->release_ref();  // 5
  }
public:
  void push(T new_value)
  {
    std::unique_ptr<T> new_data(new T(new_value));
    counted_node_ptr new_next;
    new_next.ptr=new node;
    new_next.external_count=1;
    counted_node_ptr old_tail=tail.load();

    for(;;)
    {
      increase_external_count(tail,old_tail);

      T* old_data=nullptr;
      if(old_tail.ptr->data.compare_exchange_strong(  // 6
         old_data,new_data.get()))
      {
        counted_node_ptr old_next={0};
        if(!old_tail.ptr->next.compare_exchange_strong(  // 7
           old_next,new_next))
        {
          delete new_next.ptr;  // 8
          new_next=old_next;  // 9
        }
        set_new_tail(old_tail, new_next);
        new_data.release();
        break;
      }
      else  // 10
      {
        counted_node_ptr old_next={0};
        if(old_tail.ptr->next.compare_exchange_strong(  // 11
           old_next,new_next))
        {
          old_next=new_next;  // 12
          new_next.ptr=new node;  // 13
        }
        set_new_tail(old_tail, old_next);  // 14
      }
    }
  }
};
```

與代碼7.15中的push()相似，對data進行設置⑥，就需要對另一線程幫忙的情況進行處理，else分支就是具體的幫助內容⑩。

對節點中的data指針進行設置⑥時，新版push()對next指針的更新使用的是compare_exchange_strong()⑦(使用compare_exchange_strong()來避免循環)，當交換失敗就能知道另有線程對next指針進行設置，所以就可以刪除開始分配的那個新節點⑧。還需要獲取next指向的值——其他線程對tail指針設置的值。

對tail的更新是在set_new_tail()中完成①。使用一個compare_exchange_weak()循環②來更新tail，如果其他線程嘗試push()一個節點時，external_count部分將會改變。不過，當其他線程成功的修改了tail時，就不能對其值進行替換。否則，隊列中的循環將會結束，這是一個相當糟糕的主意。因此，“比較/交換”操作失敗時，就需要保證ptr加載值要與tail指向的值相同。當新舊ptr相同時，循環退出③就代表對tail的設置已經完成，所以需要釋放舊外部計數器④。當ptr值不一樣時另一線程可能已經將計數器釋放了，所以只需要對該線程持有的單次引用進行釋放即可⑤。

當線程調用push()時，未能在循環階段對data指針進行設置，這個線程可以幫助成功的線程完成更新。首先，會嘗試更新next指針，讓其指向該線程分配出來的新節點⑪。指針更新成功時，就可以將這個新節點作為新的tail節點⑫，且需要分配另一個新節點，用來管理隊列中新推送的數據項⑬。再進入循環之前，可以通過調用set_new_tail來設置tail節點⑭。

讀者們可能已經意識到，比起大量的new和delete操作，這樣的代碼更加短小精悍，因為新節點實在push()中分配，在pop()中銷燬。因此，內存分配器的效率也需要考慮到，糟糕的分配器可能會讓無鎖容器的擴展特性消失。選擇和實現高效的分配器，超出了本書的範疇，不過需要牢記：測試以及衡量分配器效率最好的辦法，就是對使用前和使用後進行比較。為優化內存分配，包括每個線程有自己的分配器，以及使用回收列表對節點進行回收，而非將這些節點返回給分配器。

例子已經足夠多了，讓我們從這些例子中提取出一些指導建議吧。

-------

[1] “Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes,” Maged M.Michael, *in PODC ’02: Proceedings of the Twenty-first Annual Symposium on Principles of Distributed Computing* (2002), ISBN 1-58113-485-1.

[2] Maged M. Michael, U.S. Patent and Trademark Office application number 20040107227, “Method for efficient implementation of dynamic lock-free data structures with safe memory reclamation.”

[3] GNU General Public License http://www.gnu.org/licenses/gpl.html.

[4] IBM Statement of Non-Assertion of Named Patents Against OSS, http://www.ibm.com/ibm/licensing/patents/pledgedpatents.pdf.

[5] Atomic Ptr Plus Project, http://atomic-ptr-plus.sourceforge.net/.