# 8.3 為多線程性能設計數據結構

8.1節瞭解了各種劃分方法，8.2節中瞭解了影響性能的各種因素。如何在設計數據結構時，使用這些信息提高多線程代碼的性能？與第6、7章中的問題不同，之前是關於如何設計安全、併發訪問的數據結構。

當為多線程性能設計數據結構時，需要考慮*競爭*(contention)，*偽共享*(false sharing)和*鄰近數據*(data proximity)，這三個對於性能都有著重大的影響的因素，改善數據佈局，或者將數據進行修改。首先，讓我們來看一個簡單的方案：線程間劃分數組。

## 8.3.1 劃分數組元素

假設有一些偏數學的計算任務，比如：需要將兩個很大的矩陣進行相乘。對於矩陣相乘來說，將第一個矩陣中的首行每個元素和第二個矩陣中首列每個元素相乘後再相加，從而產生新矩陣中左上角的第一個元素。然後，第二行和第一列，產生新矩陣第一列上的第二個結果，第二行和第二列，產生新矩陣中第二列的第一個結果，以此類推。如圖8.3所示，高亮展示的就是在新矩陣中第二行-第三列中的元素產生的過程。

![](../../images/chapter8/8-3.png)

圖8.3 矩陣相乘

現在，假設兩個矩陣都有上千行和上千列，使用多線程來優化矩陣乘法。通常，非稀疏矩陣可以用大數組來代表，也就是第二行的元素緊隨著第一行的，以此類推。為了完成矩陣乘法，就需要三個大數組。為了優化性能，需要仔細考慮數據訪問的模式，特別是向第三個數組中寫入的方式。

線程間劃分工作的方式有很多，假設矩陣的行或列數量大於處理器的數量，可以讓每個線程計算出結果矩陣列上的元素，或是行上的元素，亦或計算一個子矩陣。

回顧一下8.2.3和8.2.4節，對於數組來說訪問連續元素是最好的方式，因為這會減少緩存的刷新，降低偽共享的概率。如果要讓每個線程處理幾行，線程需要讀取第一個矩陣中的每一個元素，並且讀取第二個矩陣上的相關數據，不過這裡只需要對列進行寫入。給定的兩個矩陣是以行連續的方式存儲，這就意味著當訪問第一個矩陣的第一行的前N個元素，而後是第二行的前N個元素，以此類推(N是列的數量)。其他線程會訪問每行的的其他元素，訪問相鄰的列，所以從行上讀取的N個元素也是連續的，這將最大程度降低偽共享的幾率。當然，如果N個元素已佔有相應的空間，且N個元素也就是每個緩存行上具體的存儲元素數量，就會讓偽共享的情況消失，因為線程將會對獨立緩存行上的數據進行操作。

另一方面，當每個線程處理一組行數據，就需要讀取第二個矩陣上的數據，還要讀取第一個矩陣中的相關行上的值，不過只需要對行上的值進行寫入即可。因為矩陣是以行連續的方式存儲，那麼可以以N行的方式訪問所有的元素。如果再次選擇相鄰行，這就意味著線程現在只能寫入N行，就有不能被其他線程所訪問的連續內存塊。讓線程對每組列進行處理就是一種改進，因為偽共享只可能有在一個內存塊的最後幾個元素和下一個元素的開始幾個上發生，不過具體的時間還要根據目標架構來決定。

第三個選擇——將矩陣分成小矩陣塊？這可以看作先對列進行劃分，再對行進行劃分。因此，劃分列的時候，同樣有偽共享的問題存在。如果可以選擇內存塊所擁有行的數量，就可以有效的避免偽共享。將大矩陣劃分為小塊，對於讀取來說是有好處的：就不再需要讀取整個源矩陣了。只需要讀取目標矩形裡面相關行列的值就可以了。具體的來看，考慮1,000行和1,000列的兩個矩陣相乘，就會有1百萬個元素。如果有100個處理器，這樣就可以每次處理10行的數據，也就是10,000個元素。不過，為了計算著10,000個元素，就需要對第二個矩陣中的全部內容進行訪問(1百萬個元素)，再加上10,000個相關行(第一個矩陣)上的元素，大概就要訪問1,010,000個元素。另外，硬件能處理100x100的數據塊(總共10,000個元素)，這就需要對第一個矩陣中的100行進行訪問(100x1,000=100,000個元素)，還有第二個矩陣中的100列(另外100,000個)。這才只有200,000個元素，就需要5輪讀取才能完成。如果讀取的元素少一些，緩存缺失的情況就會少一些。

因此，將矩陣分成小塊或正方形的塊，要比使用單線程來處理少量的列好的多。當然，可以根據源矩陣的大小和處理器的數量，在運行時對塊的大小進行調整。性能是很重要的指標時，就需要對目標架構上的各項指標進行測量，並且查閱相關領域的文獻——如果只是做矩陣乘法，我認為這並不是最好的選擇。

如果不做矩陣乘法，該如何進行呢？同樣的原理可以應用於任何情況，這種情況就是有很大的數據塊需要在線程間進行劃分。仔細觀察所有數據訪問的各個方面，以及確定性能問題產生的原因。各種領域中，出現問題的情況都很相似：改變劃分方式就能夠提高性能，不需要對基本算法進行任何修改。

OK，我們已經瞭解了訪問數組是如何對性能產生影響的，那麼其他類型的數據結構呢？

## 8.3.2 其他數據結構中的訪問模式

同樣的考慮適用於數據結構的數據訪問模式，如同優化對數組的訪問：

- 嘗試調整數據在線程間的分佈，讓同一線程中的數據緊密聯繫在一起。

- 嘗試減少線程上所需的數據量。

- 嘗試讓不同線程訪問不同的存儲位置，以避免偽共享。

應用於其他數據結構上會比較麻煩。例如：對二叉樹劃分就要比其他結構困難，有用與沒用要取決於樹的平衡性，以及需要劃分的節點數量。同樣，樹的屬性決定了其節點會動態的進行分配，並在不同的地方進行釋放。

現在，節點在不同的地方釋放倒不是問題，不過處理器需要在緩存中存儲很多東西。當多線程需要對樹進行旋轉時，就需要對樹中的所有節點進行訪問，不過當樹中的節點只包括指向實際值的指針時，處理器只能從主存中對數據進行加載。如果訪問線程正在修改數據，就能避免節點數據，以及樹數據結構的偽共享。

和用互斥量來保護數據類似。假設有一個類，包含一些數據項和一個用於保護數據的互斥量(多線程環境下)。如果互斥量和數據項在內存中很接近，對於一個需要獲取互斥量的線程來說是很理想的情況。因為在之前為了對互斥量進行修改，已經加載了需要的數據，所以需要的數據可能早已存入處理器的緩存中。不過，還有一個缺點：當其他線程嘗試鎖住互斥量時(第一個線程還沒有是釋放)，線程就能對數據項進行訪問。互斥鎖是作為“讀-改-寫”原子操作實現的，對於相同位置的操作都需要先獲取互斥量，如果互斥量已鎖，就會調用系統內核。這種“讀-改-寫”操作可能會讓數據存儲在緩存中，讓線程獲取的互斥量變得毫無作用。從目前互斥量的發展來看，這並不是個問題，因為線程不會直到互斥量解鎖才接觸互斥量。不過，當互斥量共享同一緩存行時，其中存儲的是線程已使用的數據，這時擁有互斥量的線程將會遭受到性能打擊，因為其他線程也在嘗試鎖住互斥量。

一種測試偽共享問題的方法：填充大量的數據塊，讓不同線程併發訪問。

```c++
struct protected_data
{
  std::mutex m;
  char padding[65536];  // 如果你的編譯器不支持std::hardware_destructive_interference_size，可以使用類似65536字節，這個數字肯定超過一個緩存行
  my_data data_to_protect;
};
```

用來測試互斥量競爭或

```c++
struct my_data
{
  data_item1 d1;
  data_item2 d2;
  char padding[65536];
};
my_data some_array[256];
```

用來測試數組數據中的偽共享。

如果這樣能夠提高性能，就能知道偽共享在這裡的確存在。

當然，設計併發的時候有更多的數據訪問模式需要考慮。