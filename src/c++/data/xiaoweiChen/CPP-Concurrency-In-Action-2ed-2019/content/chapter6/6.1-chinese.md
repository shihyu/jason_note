# 6.1 併發設計的意義 

設計併發數據結構是為了讓多線程併發訪問，並且線程可對數據結構做相同或不同的操作。多線程環境下，無數據丟失和損毀，所有的數據需要維持原樣，且無條件競爭的數據結構，稱之為“線程安全”的數據結構。通常情況下，多個線程對數據結構進行併發操作是安全的，但不同操作需要單線程獨立訪問數據結構。當線程執行不同的操作時，對同一數據結構的併發操作是安全的，而多線程執行同樣的操作時，可能會出現問題。

實際的設計意義並不止上面提到的那樣，而是要為線程提供併發訪問數據結構的機會。本質上，在互斥量的保護下同一時間內只有一個線程可以獲取鎖。互斥量為了保護數據，會顯式阻止線程對數據結構的併發訪問。

*串行化*(serialzation)則是線程輪流訪問數據，對數據進行串行訪問。因此，需要對數據結構仔細斟酌，確保能進行真正的併發。雖然，有些數據結構比其他結構的併發訪問範圍更大，但思路都是一樣的：減少保護區域，減少序列化操作，提升併發訪問的能力。

進行數據結構的設計之前，快速瀏覽一下併發設計的指導指南。

## 6.1.1 併發數據結構設計的指南

設計併發數據結構時，需要考量兩方面：一是確保訪問安全，二是真正併發訪問。第3章已經對如何保證數據結構是線程安全的做過簡單的描述：

- 確保無線程能夠看到“不變量”變化時的狀態。

- 小心會引起條件競爭的接口，提供完整操作的函數，而非操作步驟。

- 注意數據結構的行為是否會產生異常，從而確保“不變量”的狀態。

- 將死鎖的概率降到最低。限制鎖的範圍，避免嵌套鎖的存在。

還需要考慮數據結構對於使用者有什麼限制，當線程通過特殊的函數對數據結構進行訪問時，其他的線程還有哪些函數能安全調用？

這是一個很重要的問題，普通的構造函數和析構函數需要獨立訪問數據結構，所以用戶使用時，就不能在構造函數完成前或析構函數完成後對數據結構進行訪問。當數據結構支持賦值操作swap()或拷貝構造時，作為數據結構的設計者，即使線程操縱數據結構中有大量的函數，也需要保證這些操作在併發下是安全的(或確保這些操作能夠獨立訪問)，以保證併發訪問時不會出錯。

第二個方面是確保真正的併發訪問，這裡沒有更多的指導意見。不過，作為一個數據結構的設計者，需要考慮以下問題：

- 操作在鎖的範圍中進行，是否允許在鎖外執行？

- 數據結構中不同的互斥量能否保護不同的區域？

- 所有操作都需要同級互斥量的保護嗎？

- 能否對數據結構進行簡單的修改，增加併發訪問的概率？

這些問題都源於一個指導思想：如何讓序列化訪問最小化，讓真實併發最大化？允許線程併發讀取的數據結構並不少見，但修改必須是單線程的，這種結構類似於`std::shared_mutex`。同樣，這種數據結構也很常見——支持多線程的不同操作時，也能串行執行相同的操作。

最簡單的線程安全結構通常會對數據使用互斥量或鎖。雖然，這麼做還有問題，不過這樣做相對簡單，並且能保證只有一個線程在同一時間對數據結構進行獨立訪問。為了更輕鬆的設計線程安全的數據結構，接下來了解一下基於鎖的數據結構。

