# 1.1 何謂併發

併發，指兩個或兩個以上的獨立活動同時發生。

併發在生活中隨處可見，我們可以一邊走路一邊說話，也可以兩隻手同時做不同的動作，還有每個人都過著相互獨立的生活——當我在游泳的時候，你可以看球賽等等。

## 1.1.1 計算機的併發

計算機的併發，指在單個系統裡同時執行多個獨立的任務。

併發在計算機領域不是一個新鮮事物。很多年前，一臺計算機就能通過多任務操作系統的切換功能，同時運行多個應用，並且多處理器服務器很早就實現了並行計算。那併發為什麼在計算機領域越來越流行呢？——真正的並行。

以前，大多數計算機只有一個處理器，具有單個處理單元或核芯。這種機器只能在某一時刻執行一個任務，不過可以在單位時間內對任務進行多次切換。通過“這個任務做一會，另一個任務再做一會兒”的方式，讓任務看起來是並行的，這種方式稱為任務切換。如今，這樣的方式仍稱為“併發“，因為任務切換得太快，以至於無法感覺到任務會暫時掛起。任務切換會給用戶造成一種“併發的假象”，任務切換和真正併發執行相比，行為上還是有著微妙的不同。

多核計算機用於高性能計算已有多年。基於單芯多核處理器(多核處理器)的臺式機，也越來越大眾化。無論有多少個處理器，這些機器都能夠真正的並行多個任務，我們稱其為”硬件併發“。

圖1.1顯示了處理兩個任務時的理想情景，每個任務被分為10個相等大小的子任務塊。在一個雙核機器上，每個任務可以在各自的處理核心上執行。在單核機器上做任務切換時，每個任務的塊交替進行，但中間有一小段分隔(圖中所示灰色分隔條)，這表示切換任務的開銷。進行任務切換時，操作系統必須保存當前任務CPU的狀態和指令指針，並計算要切換到哪個任務，再將切換到的任務加載處理器中。CPU可能要將新任務的指令和數據載入到緩存，這會讓CPU停止執行指令，從而造成的更多的延遲。

![](../../images/chapter1/1-1.png)

圖 1.1 併發的兩種方式：真正並行 vs. 任務切換

有些處理器可以在一個核心上執行多個線程，但硬件併發在多處理器上效果更加顯著。硬件線程最重要的是數量，也就是可以併發運行獨立任務的數量。即便是硬件併發的系統，也有比硬件“可並行最大任務數”還要多的任務需要執行，所以任務切換在這些情況下仍然適用。例如，一個臺計算機上可能會有成百上千個的任務在運行，即便是在計算機處於空閒時，還是會有後臺任務在運行。正是任務切換使得這些後臺任務可以運行，這樣系統使用者就可以同時運行文字處理器、編譯器、編輯器和Web瀏覽器了。

圖1.2顯示了四個任務在雙核處理器上的任務切換，仍是將任務整齊地劃分為同等大小子任務塊的理想情況。實際上，許多因素會使得任務分割不均或調度不規則。

![](../../images/chapter1/1-2.png)

圖 1.2 四個任務在兩個核心之間的切換

無論應用是在單核處理器，還是多核處理器上運行，不論是任務切換，還是硬件併發，這裡提到的技術、功能和類(本書所涉及的)都會涉及。如何使用併發，很大程度上取決於可用的硬件併發。

## 1.1.2 併發的方式

試想當兩個程序員在兩個獨立的辦公室一起做一個軟件項目，他們可以安靜地工作、互不幹擾，並且人手一套參考手冊。但溝通起來就有些困難，比起可以直接交談，他們必須使用電話、電子郵件或到對方的辦公室進行面對面交流。並且，管理兩個辦公室需要有一定的經費支出，還需要購買多份參考手冊。

假設，讓開發人員同在一間辦公室辦公，他們可以自由的對某個程序設計進行討論，也可以在紙或白板上繪製圖表，對設計觀點進行輔助性闡釋。現在，只需要管理一個辦公室和一套參考資料就夠了。遺憾的是，開發人員可能難以集中注意力，並且還可能存在資源共享的問題(比如，“參考手冊哪去了?”)

以上兩種方法，描繪了併發的兩種基本途徑。開發人員代表線程，辦公室代表進程。第一種方式是每個進程只要一個線程，這就類似讓每個開發人員擁有自己的辦公室。而第二種方式是每個進程有多個線程，如同一個辦公室裡有兩個開發人員。讓我們在一個應用中，簡單的分析一下這兩種方式。

##### 多進程併發

使用併發的第一種方式，是將應用程序分為多個獨立的進程同時運行，就像同時進行網頁瀏覽和文字處理一樣。如圖1.3所示，獨立的進程可以通過進程間的通信渠道傳遞訊息(信號、套接字、文件、管道等等)。不過，這種進程間的通信通常非常複雜，或是速度很慢。這是因為操作系統會對進程進行保護，以避免一個進程去修改另一個進程的數據。還有一個缺點是運行多個進程的固定開銷：需要時間啟動進程，操作系統需要資源來管理進程等等。

![](../../images/chapter1/1-3.png)

圖 1.3 一對併發運行的進程之間的通信

當然，以上的機制也不是一無是處：操作系統在進程間提供了保護和更高級別的通信機制，可以更容易編寫安全的併發代碼。實際上，在類似於[Erlang](www.erlang.org)的編程環境中，會將進程作為併發的基礎塊。

使用多進程實現併發還有一個優勢——可以使用遠程連接(可能需要聯網)的方式，在不同的機器上運行獨立的進程。雖然，這增加了通信成本，但在設計精良的系統中，這種低成本方案可提高程序的並行可用性和性能。

##### 多線程併發

併發的另一個方式，在單進程中運行多個線程。線程很像輕量級的進程：每個線程相互獨立運行，並且可以在不同的指令序列中運行。不過，進程中的所有線程都共享地址空間，並且能訪問到大部分數據———全局變量仍然是全局的，指針、對象的引用或數據可以在線程之間傳遞。雖然，進程之間通常共享內存，但同一數據的內存地址在不同的進程中不相同，所以這種共享難以建立和管理。圖1.4展示了一個進程中的兩個線程，正在通過共享內存進行通信。

![](../../images/chapter1/1-4.png)

圖 1.4 同一進程中，一對併發線程間的通信

地址空間共享，以及缺少線程間的數據保護，使得操作系統記錄的工作量減小，所以使用多線程的開銷遠遠小於多進程。不過，共享內存的靈活性是有代價的：如果多個線程訪問數據，那麼必須確保每個線程所訪問到的數據一致，這就需要對線程通信做大量的工作。

多個單線程/進程間的通信，要比單一進程中多線程通信的開銷大，若不考慮共享內存可能帶來的問題，多線程將會成為主流語言(包括C++)更青睞的併發方式。此外，C++標準並未對進程通信提供原生支持，所以實現會依賴於平臺相關的API。因此，本書只關注多線程的併發，之後所提到“併發”，均為多線程實現。

多線程應用中，還有一種方式：並行。

## 1.1.3 併發與並行

對多線程來說，這兩個概念大部分是重疊的。對於很多人來說，它們沒有什麼區別。這兩個詞是用來描述硬件同時執行多個任務的方式，而“並行”更加註重性能。使用硬件提高數據處理速度時，會討論程序的並行性。當關注重點在於任務分離或任務響應時，會討論程序的併發性。這兩個術語存在的目的，就是為了區別多線程中不同的關注點。

瞭解了併發後，來看看為什麼要使用併發。