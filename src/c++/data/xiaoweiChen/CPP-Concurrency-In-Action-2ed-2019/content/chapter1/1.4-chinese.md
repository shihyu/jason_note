# 1.4 開始入門

OK！準備一個能與C++11/C++14/C++17標準兼容的編譯器。C++多線程程序是什麼樣子呢？其實，和其他C++程序差不多。唯一的區別在於某些函數可以併發運行，所以需要確保共享數據在併發訪問時是安全的。當然，為了併發地運行，必須使用特定函數以及對象來管理各個線程。

## 1.4.1 歡迎來到併發世界

從一個經典的例子開始：一個打印“Hello World”的程序。一個非常簡單的在單線程中運行的Hello World程序如下所示，當我們談到多線程時，可以作為一個基準。

```c++
#include <iostream>
int main()
{
  std::cout << "Hello World\n";
}
```

這個程序所做的就是將“Hello World”寫進標準輸出流。讓我們將它與下面清單所示的簡單的“Hello, Concurrent World”程序做個比較，它啟動了一個獨立的線程來顯示這個信息。

代碼 1.1  一個簡單的Hello, Concurrent World程序：

```c++
#include <iostream>
#include <thread>  // 1
void hello()  // 2
{
  std::cout << "Hello Concurrent World\n";
}
int main()
{
  std::thread t(hello);  // 3
  t.join();  // 4
}
```

第一個區別是增加了`#include <thread>`①，包括標準庫中對多線程支持的聲明，管理線程的函數和類在`<thread>`中聲明(保護共享數據的函數和類在其他頭文件中聲明)。

其次，打印信息移到了一個獨立的函數中②。因為每個線程都必須一個執行單元，新線程的執行從這裡開始。對於應用程序來說，初始線程是main()，但是對於其他線程，可以在`std::thread`對象的構造函數中指定——本例中命名為`t`③的`std::thread`對象擁有新函數hello()作為其執行函數。

下一個區別：與直接寫入標準輸出或是從main()調用hello()不同，該程序啟動了一個全新的線程來實現，將線程數量一分為二——初始線程始於main()，而新線程始於hello()。

新的線程啟動之後③，初始線程繼續執行。如果它不等待新線程結束，就運行到main()函數結束——有可能發生在新線程運行之前。這就是為什麼在④這裡調用`join()`的原因——詳見第2章，這會讓創建線程等待`std::thread`對象創建的線程。

這看起來僅是為了將一條信息寫入標準輸出，確實如此——正如上文1.2.3節所描述的，一般來說並不值得為了如此簡單的任務而使用多線程，尤其是在這期間初始線程並沒做什麼。後面的章節中，將通過更加複雜的實例來展示，在哪些情景下使用多線程更有意義。
