# 1.3 併發和多線程

使用C++11標準，可以編寫不依賴平臺擴展的多線程代碼。瞭解C++線程庫前，先來了解一下C++多線程的發展史。

## 1.3.1 C++多線程歷史

C++98(1998)標準不承認線程的存在，並且各種語義以順序抽象的形式編寫。不僅如此，也沒有內存模型，所以C++98標準在缺少編譯器擴展的情況下，沒辦法編寫多線程應用。

當然，編譯器供應商可以自由地向語言添加擴展，C語言中流行的多線程API——POSIX標準中的C標準和Microsoft Windows API——很多C++編譯器供應商，通過各種平臺相關的擴展來支持多線程。這種支持受限於平臺，並且需要相應平臺的運行庫(例如，異常處理機制的代碼)能在多線程情況下正常工作。因為編譯器和處理器的實際表現很不錯，所以在少數編譯器供應商提供正式的多線程內存模型之前，開發者們已經寫了很多的C++多線程程序了。

由於不滿足於使用平臺相關的API來處理多線程，C++開發者們希望使用面向對象的多線程工具。像MFC這樣的應用框架，和Boost和ACE這樣的通用庫，這些庫提供了很多簡化任務的多線程工具。各種庫在細節方面差異很大，但在啟動線程的方面，卻大同小異。其使用一種便利的設計，也就是使用帶鎖的獲取資源即初始化(RAII, Resource Acquisition Is Initialization)的方式。

編寫多線程代碼需要紮實的編程基礎，當前的很多C++編譯器為多線程編程者提供了對應的API，還有一些與平臺無關的C++庫。這樣，開發者們就可以通過這些API來實現多線程。不過，由於缺乏統一的標準，以及內存模型，就會產生一些問題，這些問題在跨平臺的多線程應用上表現得尤為明顯。

## 1.3.2 支持併發

這些隨著C++11標準的發佈而改變，新標準中不僅有了全新的內存模型，C++標準庫也擴展了：管理線程(參見第2章)、保護共享數據(參見第3章)、線程間同步操作(參見第4章)，以及原子操作(參見第5章)。

標準線程庫很大程度上，基於之前C++庫的經驗積累。特別是Boost線程庫，作為新標準庫的很多類與Boost庫中的相關類有著相同名稱和結構。隨著C++標準的進步，Boost線程庫也隨著C++標準在許多方面做出改變，這樣之前使用Boost的用戶會發現自己非常熟悉C++11的線程庫。

支持併發僅是C++11標準的變化之一，為了讓開發者們的工作變得更加輕鬆，還有很多對於語言自身的改善。這些內容不在本書的討論範圍內，但是其中的一些變化對線程庫及其使用方式有著很大的影響。附錄A會對這些特性做一些介紹。

## 1.3.3 C++14和C++17對併發和並行的更多支持

C++14中為併發和並行添加了一個新的互斥量類型，用於保護共享數據(參見第3章)。C++17考慮的更多：添加了一整套的並行算法(參見第10章)。兩個標準將整個標準庫進行了補強，這讓書寫多線程代碼變得更加容易。

之前還提到了一個併發技術標準，其描述C++標準對於函數和類的擴展，尤其是對線程同步方面(參見第4章)。

C++新標準直接支持原子操作，允許開發者通過指定語義的方式編寫代碼，從而無需瞭解與平臺相關的彙編指令。這對於編寫高效、可移植的代碼來說，無疑是一個好消息。編譯器不僅可以搞定具體平臺，還可以編寫優化器來解釋操作語義，從而讓程序得到更好的優化。

## 1.3.4 C++線程庫的效率

這是高性能計算開發者的擔憂之一。為了效率，C++整合了一些底層工具。這樣就需要了解使用高級工具和使用低級工具的開銷差，這個開銷差就是抽象代價(abstraction penalty)。

C++標準委員會在設計標準庫時，特別是線程庫，就注意到了這點。目的就是在實現相同功能的前提下，確保使用高級API和使用底層API帶來的性能收益相當。這樣，標準庫在主流平臺上都能有高效實現(帶有非常低的抽象代價)。

為了達到終極性能，需要給與硬件打交道的開發者提供足夠多的底層工具。為了這個目的，形成了原子操作庫，可直接控制單個位、字節、內部線程間的同步，以及對所有變化的可見性。原子類型可以在很多地方使用，使用新標準的代碼會有更好的可移植性，並且容易維護。

標準庫也提供了更高級別工具，使得編寫多線程代碼更加簡單。因為有額外的代碼需要執行，這些工具確實會帶來性能開銷。總的來說，性能開銷和手工編寫的函數差不多，並且編譯器會內聯大部分代碼。

某些情況下，高級工具會提供一些額外的功能。極少的情況下，一些未使用的功能會影響其他代碼的性能。如果很看重程序的性能，並且高級工具帶來的開銷過高，最好是通過較低層工具來實現功能。絕大多數情況下，用過高的複雜性和過大的出錯率，來交換小幅度的性能收益是不划算的。即便是瓶頸出現在C++標準庫的工具中，也可能由低劣的程序設計造成。例如，如果過多的線程競爭一個互斥單元，將會很明顯的影響性能。與其在互斥操作上耗費時間，不如重新設計，減少互斥單元上的競爭。

C++標準庫沒有提供所需的性能或行為時，就需要使用與平臺相關的工具了。

## 1.3.5 平臺相關的工具

雖然C++線程庫為多線程和併發處理提供了較全面的工具，但某些平臺會提供額外的工具。為了方便地使用這些工具，又使用標準C++線程庫，在C++線程庫中提供一個`native_handle()`的成員函數，允許通過使用平臺相關API直接操作底層實現。就其本質而言，任何使用`native_handle()`執行的操作都是完全依賴於平臺，這也超出了本書(同時也是標準C++庫本身)討論的範圍。

所以，使用平臺相關的工具之前，先了解一下標準庫能夠做些什麼吧。