# 1.2 為什麼使用併發

原因有二：分離關注點(SOC)和性能(或者可能是兩個都有。當然，除了“我樂意”這樣的原因)。

## 1.2.1 分離關注點

編寫軟件時，分離關注點是個好辦法。通過將相關的代碼與無關的代碼分離，可以使程序更容易理解和測試，從而減少出錯的可能。即使一些操作需要同時進行，依舊可以使用併發，分離不同的功能區域。若不顯式地使用併發，就得編寫一個任務切換機制，或者在操作中主動地調用一段不相關的代碼。

假設有一個用戶界面的處理密集型應用——DVD播放程序。這樣的應用程序，應具備這兩種功能：一，要從光盤中讀出數據，對圖像和聲音進行解碼，之後把解碼出的信號輸出至視頻和音頻硬件中進行處理，從而實現DVD的播放；二，接收來自用戶的輸入，當用戶單擊“暫停”、“返回菜單”或“退出”按鍵的時候執行對應的操作。當應用是單個線程時，應用需要在回放期間定期檢查用戶的輸入，這就需要把“DVD播放”代碼和“用戶界面”代碼放在一起。如果使用多線程方式來分離這些關注點，“用戶界面”代碼和“播放DVD”代碼不需要放在一起：一個線程可以處理“用戶界面”，另一個進行“播放DVD”。它們之間會有交互(用戶點擊“暫停”)，不過任務需要人為的進行關聯。

這會帶來響應上的錯覺，因為用戶界面線程通常可以立即響應用戶的請求，儘管當請求傳遞給工作中的線程時，其響應可能只是顯示“忙碌中”的光標或“請等待”的消息。同理，獨立的線程通常用來執行那些必須在後臺持續運行的任務，例如：桌面搜索程序中監視文件系統變化的任務。因為交互清晰可辨，所以會使每個線程變的更加簡單。

這種情況下，對線程的劃分是基於概念上的設計，所以線程數不再依賴CPU核芯數。

## 1.2.2 性能

重核系統已經存在了幾十年，直至現今，它們也只在超級計算機、大型機和大型服務器系統中才能看到。然而，芯片製造商越來越傾向於芯片的多核設計，即在單芯片上集成2、4、16或更多的處理器，從而獲取更好的性能。因此，多核計算機、多核嵌入式設備，現在越來越普遍。它們計算能力的提高不是使單一任務運行的更快，而是並行多個任務。曾今，開發者無需做任何事，可以看著程序隨著處理器的更新換代而變得更快。但是現在，如Herb Sutter所說的，“沒有免費的午餐了。”[1] *如果想要利用日益增長的計算能力，那就必須設計多任務併發式軟件*，那些迄今都忽略併發的開發者們要上心了。

有兩種利用併發來提高性能的方式：第一，將一個單個任務分成幾部分並行運行，從而降低總運行時間，這就是任務並行(task parallelism)。雖然，這聽起來很直觀，但是一個相當複雜的過程，因為各個部分之間可能存在著依賴。區別可能是在過程方面——一個線程執行算法的一部分，而另一個線程執行算法的另一個部分——或是在處理數據——每個線程在不同的數據塊上執行相同的操作(第二種方式)。後一種方法被稱為數據並行(data parallelism)。

容易並行的算法稱為是“易並行的”(embarrassingly parallel)。易並行算法具有良好的可擴展特性——當可用硬件線程的數量增加時，算法的並行性也會隨之增加，這種算法很好的體現了“人多力量大”。如果算法中有不易並行的部分，可以把算法劃分成固定(不可擴展)數量的並行任務。

併發提升性能的第二種方式，是利用並行來解決更大的問題：每次只處理一個文件，不如處理2個、10個或20個。雖然，這是數據並行的一種應用(通過對多組數據同時執行相同的操作)，但著重點不同。處理等量數據仍然需要同樣的時間，但現在在相同的時間內處理了更多的數據。這種方法也有限制，並非所有情況下都是有效的。不過，這種方法所帶來的吞吐量提升，可以讓某些功能成為可能——如果圖片的不同區域能被並行地處理，程序就可以處理更高分辨率的視頻。

## 1.2.3 什麼時候不使用併發

知道何時不使用併發與知道何時使用一樣重要。

不使用併發的唯一原因就是收益比不上成本。使用併發的代碼在很多情況下難以理解，因此編寫和維護多線程代碼會產生腦力成本，而增加的複雜性也可能會引起更多的錯誤。除非潛在的性能增益足夠大或關注點分離地足夠清晰，能抵消為確保正確開發所需的額外時間，以及維護代碼的額外成本；否則，勿用併發。

同樣地，性能增益可能會小於預期。啟動線程時存在固有開銷，因為操作系統需要分配內核資源和堆棧空間，才能把新線程加入調度器中。如果在線程上的任務完成得很快，那麼實際執行任務的時間要比啟動線程的時間小很多，這會導致應用的整體性能不如直接使用單線程。

此外，線程的資源有限。如果太多的線程同時運行，則會消耗很多操作系統資源，從而使得操作系統整體上運行得更加緩慢。不僅如此，因為每個線程都需要一個獨立的堆棧，所以運行太多的線程也會耗盡進程的可用內存或地址空間。對於一個可用地址空間為4GB(32bit)的架構來說，這的確是個問題：如果每個線程都有一個1MB的堆棧(很多系統都會這樣分配)，那麼4096個線程將會用盡所有地址空間(不會給代碼、靜態數據或者堆數據留有任何空間)。即便是64位(或者更大)的系統，不存在這種地址空間限制，但其他資源也是有限的：如果你運行了太多的線程，也會出問題。儘管線程池(參見第9章)可以用來限制線程的數量，但也並不是什麼靈丹妙藥。

當客戶端/服務器(C/S)應用在服務端為每一個鏈接啟動一個獨立的線程時，對於少量鏈接沒有問題，但當用於需要處理大量鏈接的高需求服務器時，就會因為線程太多而耗盡系統資源。這種場景下，使用線程池可以對性能進行優化(參見第9章)。

最後，運行越多的線程，操作系統就需要越多的上下文切換，每一次切換都需要耗費時間。所以在某些時候，增加線程實際上會降低應用的整體性能。如果試圖得到系統的最佳性能，可以考慮使用硬件併發(或不用)，並調整運行線程的數量。

和所有其他優化策略一樣，我們為了性能而使用併發：它可以大幅度提高應用的性能，但也可能讓代碼更加複雜，難以理解，並且更容易出錯。因此，應用中只有性能關鍵部分，才值得併發化。當然，如果性能收益僅次於設計清晰或分離關注點，也可以使用多線程。

既然已經看到了這裡，那無論是為了性能、關注點分離，亦或是因為多線程星期一(multithreading Monday)(譯者：可能是學習多線程的意思)，你應該確定要在應用中使用併發了。

好！那對於C++開發者來說，多線程意味著什麼呢？

----------

[1] “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software,” Herb Sutter, Dr. Dobb’s Journal, 30(3), March 2005. http://www.gotw.ca/publications/concurrency-ddj.htm.
