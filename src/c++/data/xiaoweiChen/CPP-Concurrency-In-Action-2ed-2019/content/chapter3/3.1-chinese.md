# 3.1 共享數據的問題

涉及到共享數據時，問題就是因為共享數據的修改所導致。如果共享數據只讀，那麼不會影響到數據，更不會對數據進行修改，所有線程都會獲得同樣的數據。但當一個或多個線程要修改共享數據時，就會產生很多麻煩。這種情況下，需要小心謹慎，才能確保所有線程都正常工作。

不變量(invariants)的概念對開發者們編寫的程序會有一定的幫助——對於特殊結構體的描述，比如：“變量包含列表中的項數”。更新通常會破壞不變量，特別是複雜的數據結構。

雙鏈表中每個節點都有一個指針指向列表中下一個節點，還有一個指針指向前一個節點。其中不變量就是節點A中指向“下一個”節點B的指針，還有前向指針。為了從列表中刪除一個節點，其兩邊節點的指針都需要更新。當其中一邊更新完成時，就破壞了不變量，直到另一邊也完成更新。在兩邊都完成更新後，不變量就穩定了。

從一個列表中刪除一個節點的步驟如下(如圖3.1)

   a. 找到要刪除的節點N

   b. 更新前一個節點指向N的指針，讓這個指針指向N的下一個節點

   c. 更新後一個節點指向N的指針，讓這個指正指向N的前一個節點

   d. 刪除節點N

![](../../images/chapter3/3-1.png)

圖3.1 從一個雙鏈表中刪除一個節點

圖中b和c在相同方向上的指向和原來已經不一致了，這就破壞了不變量。

線程間的問題在於修改共享數據，會使不變量遭到破壞。刪除過程中不確定是否有其他線程能夠進行訪問，可能就有線程訪問到剛剛刪除一邊的節點。這樣破壞了不變量，線程就讀取到要刪除節點的數據(因為一邊的連接被修改，如圖3.1(b))。破壞不變量的後果是不確定的，當其他線程按從左到右的順序訪問列表時，將跳過被刪除的節點。如有第二個線程嘗試刪除圖中右邊的節點，可能會讓數據結構產生永久性的損壞，並使程序崩潰。這就是並行中常見錯誤：條件競爭(race condition)。

## 3.1.1 條件競爭

假如你去一家大電影院買電影票，有很多收銀臺，很多人可以同時買票。當另一個收銀臺也在賣你想看電影的電影票時，你的座位選擇範圍取決於在之前已預定的座位。當只有少量的座位剩下，就可能是一場搶票比賽，看誰能搶到最後一張票。這就是一個條件競爭的例子：你的座位(或者電影票)都取決於購買的順序。

併發中的競爭條件，取決於一個以上線程的執行順序，每個線程都搶著完成自己的任務。大多數情況下，即使改變執行順序，也是良性競爭，結果是可以接受的。例如，兩個線程同時向一個處理隊列中添加任務，因為不變量保持不變，所以誰先誰後都不會有什麼影響。

當不變量遭到破壞時，才會產生條件競爭，比如：雙向鏈表的例子。併發中對數據的條件競爭通常表示為惡性競爭(我們對不產生問題的良性條件競爭不感興趣)。C++標準中也定義了數據競爭這個術語，一種特殊的條件競爭：併發的去修改一個獨立對象(參見5.1.2節)，數據競爭是未定義行為的起因。

惡性條件競爭通常發生於對多個數據塊的修改，例如：對兩個連接指針的修改(如圖3.1)。操作要訪問兩個獨立的數據塊，獨立的指令會對數據塊將進行修改，並且其中一個線程可能正在進行修改，另一個線程就對數據塊進行了訪問。因為出現的概率低，很難查找，也很難復現。如CPU指令連續修改完成後，即使數據結構可以讓其他併發線程訪問，問題再次復現的幾率也相當低。當系統負載增加時，隨著執行數量的增加，執行序列問題復現的概率也在增加，這樣的問題可能會出現在負載比較大的情況下。條件競爭通常是時間敏感的，所以程序以調試模式運行時，錯誤常會完全消失，因為調試模式會影響程序的執行時間(即使影響不多)。

當你以寫多線程程序為生，條件競爭就會成為你的夢魘。編寫軟件時，我們會使用大量複雜的操作，來避免惡性條件競爭。

## 3.1.2 避免惡性條件競爭

這裡提供一些方法來解決惡性條件競爭，最簡單的辦法就是對數據結構採用某種保護機制，確保只有修改線程才能看到不變量的中間狀態。從其他訪問線程的角度來看，修改不是已經完成了，就是還沒開始。C++標準庫提供很多類似的機制，下面會逐一介紹。

另一個選擇是對數據結構和不變量進行修改，修改完的結構必須能完成一系列不可分割的變化，也就保證了每個不變量的狀態，這就是所謂的無鎖編程。不過，這種方式很難得到正確的結果。到這個級別，無論是內存模型上的細微差異，還是線程訪問數據的能力，都會讓工作量變的很大。

另一種處理條件競爭的方式，是使用事務的方式去處理數據結構的更新(這裡的"處理"就如同對數據庫進行更新一樣)。所需的一些數據和讀取都存儲在事務日誌中，然後將之前的操作進行合併，再進行提交。當數據結構被另一個線程修改後，或處理已經重啟的情況下，提交就會無法進行，這稱作為“軟件事務內存”(software transactional memory (STM))，這是一個很熱門的理論研究領域。這個概念將不會在本書中再進行介紹，因為在C++中沒有對STM進行直接支持(儘管C++有事務性內存擴展的技術規範[1])。

保護共享數據結構的最基本的方式，使用C++標準庫提供的互斥量。

-----

[1] SO/IEC TS 19841:2015—Technical Specification for C++ Extensions for Transactional Memory http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=66343 .