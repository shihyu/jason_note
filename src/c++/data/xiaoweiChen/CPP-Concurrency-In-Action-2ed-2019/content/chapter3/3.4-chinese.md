# 3.4 本章總結

本章討論了當線程間的共享數據發生惡性條件競爭時，將會帶來多麼嚴重的災難。還討論瞭如何使用`std::mutex`和如何避免這些問題。雖然C++標準庫提供了一些工具來避免這些問題，但互斥量並不是靈丹妙藥，也還有自己的問題(比如：死鎖)。還見識了一些用於避免死鎖的技術，之後瞭解了鎖的所有權轉移，以及圍繞如何選取適當粒度鎖產生的問題。最後，在具體情況下討論了其他數據保護的方案，例如:`std::call_once()`和`std::shared_mutex`。

還有一個方面沒有涉及，那就是等待其他線程作為輸入的情況。我們的線程安全棧，僅是在棧為空時，拋出一個異常，所以當一個線程要等待其他線程向棧壓入一個值時(這是線程安全棧的主要用途之一)，它需要多次嘗試去彈出一個值，當捕獲拋出的異常時，再次進行嘗試。這種消耗資源的檢查，沒有任何意義。並且，不斷的檢查會影響系統中其他線程的運行，這反而會妨礙程序的運行。我們需要一些方法讓一個線程等待其他線程完成任務，但在等待過程中不佔用CPU。第4章中，會去建立一些保護共享數據的工具，還會介紹一些線程同步的操作機制。第6章中會展示，如何構建更大型的可複用的數據類型。