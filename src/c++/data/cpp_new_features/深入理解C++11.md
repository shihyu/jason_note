# 前言

## 說到C++11，應該想到什麼？

- 什麼是 lambda，及怎麼樣使用它是最好的？
- decltype 和 auto 型別推導有什麼關係？

- 什麼是移動語意，以及(右值參照)是如何解決轉發問題的？
- default/deleted 函式以及 override 是怎麼回事?

- 異常描述符被什麼替代了? noexcept 是如何工作的?
- 什麼是原子型別以及新的記憶體模型?

- 如何在 C++11 中做並行編程?



## 語言的哪些關鍵字和C++11有關？

- alignas
- alignof decltype

- auto(重新定義)
- static_assert

- using(重新定義)
- noexcept

- export(棄用，不過未來可能留作他用)
- nullptr

- constexpr
- thread_local



# 保證穩定性和兼容性

## 將C99標準納入C++11

### 確定編譯環境的預定義巨集

- __STDC_HOSTED__：編譯器的目標系統環境中是否包含完整的C庫
- __STDC__：編譯器對於標準C庫的實現是否和C標準一致（是否定義、如何定義由編譯器決定）

-  __STDC_VERSION__：編譯器支援的C標準的版本（是否定義、如何定義由編譯器決定）
- __STDC_ISO_10646__：yyyymmL格式的整數常數，表示C++編譯環境符合某個版本的ISO/IEC 10646標準



### __func__ 預定義標識符

函式中可以使用__func__標識符函式名稱，編譯器會在函式定義開始時隱式地插入__func__標識符定義：

static const char* __func__ = "<函式名稱>";



### _Pragma 操作符

在之前的C/C++標準中已經規定了可以使用#pragma預處理指令向編譯器傳遞資訊，比如可以通過在頭檔案首行放置#pragma once來告訴編譯器這個頭檔案只應該被include一次。

C++11中，規定了一個新的操作符_Pragma，它的作用與#pragma完全相同，_Pragma("once")就相當於#pragma once。但是，_Pragma由於是一個操作符而不是預處理指令，它的使用更為靈活，可以在巨集中展開。



### 不定參數巨集定義以及 __VA_ARGS__

C99規定巨集定義中，在參數列表的最後，可以使用...省略參數定義，而__VA_ARGS__可以用來替換被省略號代表的字串。



### 寬窄字串連接



## long long整形

## 擴展的整形

## 巨集__cplusplus

一般會和extern "C"配合使用，來讓一個頭檔案即可以同時被include到C和C++中編譯，使用extern "C"避免C++對符號名稱進行重整，確保C++編譯器編譯出的目標檔案中的符號名維持原樣。

```c++
#ifdef __cplusplus
extern "C" {
#endif
// 一些程式碼
#ifdef __cplusplus 
}
#endif
```



## 靜態斷言

標準C庫assert.h中，提供了assert函式來進行運行時的斷言，表明某些情況一定不會發生。（在 C++ 中，程式員也可以定義巨集 NDEBUG 來禁用 assert 巨集。這對發佈程式來說還是必 要的。因為程式用戶對程式退出總是敏感的，而且部分的程式錯誤也未必會導致程式全部功 能失效。那麼通過定義 NDEBUG 巨集發佈程式就可以儘量避免程式退出的狀況。而當程式有 問題時，通過沒有定義巨集 NDEBUG 的版本，程式員則可以比較容易地找到出問題的位元元置。）

如果希望在預處理時確定某些情況一定不會發生，也可以使用#if進行判斷，使用#error終止編譯流程並給出錯誤提示。

C++11引入static_assert來補充編譯時斷言。之前Boost庫也實現了類似的功能，它是利用編譯器在編譯時會檢查除以0這個特性，如果條件為假就構建一個除以0的語句迫使編譯器報錯來實現的，雖然可以達成編譯時檢查的目的，但報錯資訊比較不明確。使用C++11的static_assert，在斷言失敗時，可以得到明確的錯誤提示。



## noexcept修飾符與noexcept操作符

### 作為修飾符

noexcept作為修飾符可以用來表明函式是否會拋出異常，noexcept修飾符後面可以跟隨一個常數表達式，當常數表達式可以轉為true時表示不會拋出異常，false則表示會拋出異常。被noexcept修飾符標記為不會拋出異常的函式如果運行時拋出異常，會直接導致程式調用std::terminate終止執行，異常不會繼續沿棧傳播。

### 作為操作符

noexcept作為操作符可以用來判斷某個表達式是否會拋出異常。該操作符幫助我們在進行泛型編程時通過noexcept操作符判斷一個依賴樣板參數的表達式是否會拋出異常。

```c++
template <class T>
void fun() noexcept(noexcept(T())) {}
```



### 替代廢棄的throw

C++98曾經定義了throw修飾符，用來表明表達式是否會拋出異常，一個空的throw()就和noexcept(true)表達的意思一樣，但throw要求明確指出會拋出哪些型別的異常，實際編程中大家很少需要了解異常型別，只希望瞭解是否會拋出異常，因此新的noexcept(false)用於替代throw(<異常型別>)。



## 快速初始化成員變數

C++98中，允許直接在類的靜態常數整型成員聲明時使用“=”對其初始化，這種聲明+初始化的做法被叫做“就地”聲明。這種聲明方式很便捷，但僅能對【靜態】【常數】【整型】成員進行這樣的聲明，使用場景很少，語法也不一致。

C++11中允許對非靜態成員進行就地的初始化，不再必須在建構函式中通過initializer-list進行初始化了。可以使用等號或者一對花括號{}進行就地初始化，其他形式無法通過編譯。

在成員同時使用就地初始化，並且在建構函式的初始化列表中進行初始化時，最終僅會以初始化列表為準對其進行初始化。



## 非靜態成員的sizeof

C++98中，sizeof可以作用於類的靜態成員，但對於非靜態成員，必須通過一個類實體來參照，因此之前為了獲取一個非靜態成員的大小，同時避免創建無用的類實體，通常會使用下面的技巧：

sizeof(((People*)0)->hand);

C++11後，sizeof可以直接作用於類成員表達式了，上面的技巧可以簡化成：

sizeof(People::hand)



## 擴展的friend語法

在C++98，如果要指定另一個類是當前類的友元，必須要使用friend class/struct <友元類>這樣的寫法，並且無法使用樣板參數作為友元類，C++11允許省略class，而且可以使用樣板參數作為友元類。

https://zh.cppreference.com/w/cpp/language/friend



## final/override

final用於在繼承關係的中間終止一個虛擬函式被子類多載的可能性。override用於顯式聲明某個函式是父類虛擬函式的多載，提升了程式碼可讀性和健壯性（因為virtual修飾符只有在頂級父類聲明虛擬函式時才是必須的，子類為同名虛擬函式添加virtual修飾符會被忽略，而override修飾符會被編=‘譯器檢查以確保函式的確多載了虛擬函式）。它們都在函式聲明的參數列表之後。

為了儘可能兼容已有程式，C++11沒有將final和override規定為關鍵字，因此可以在程式碼中使用final，override變數，但最好別這麼做。



## 樣板函式的預設樣板參數

C++98允許為類樣板參數指定預設參數，但卻禁止為函式樣板參數指定預設參數，語法上不一致，邏輯上不合理。

C++11放寬了這一限制，可以為函式樣板指定預設樣板參數了。



## 外部樣板

C++中，如果多個原始檔都使用了同一個樣板，會對該樣板進行多次實體化，但最後編譯時，編譯器會僅保留一份樣板實體化產生的程式碼。在一些比較大的專案中，冗餘的樣板實體化會明顯拖慢編譯速度，可以使用“外部樣板”技術告訴編譯器不需要對樣板進行實體化，在某一個原始檔中僅進行一次顯式實體化。

template void fun<int>(int); // 顯示地實體化

extern template void fun<int>(int); // 外部樣板的聲明



## 局部和匿名型別作為樣板實際參數

C++98禁止局部或者匿名的型別作為樣板參數，這個限制沒什麼道理，因此C++11放寬了該限制。



```c++
// C++98中，只有A或者a可以作為樣板參數
struct A {int a;} a;
// 匿名型別
typedef struct {int a;} B;
// 匿名型別變數
struct {int a;} b;

void test() {
    // 局部型別
 	struct C {int a;} c;
}
```



# 通用為本，專用為末

## 繼承建構函式

繼承關係中，子類可以自動或得父類的成員和介面，但建構函式無法自動地被子類繼承。因為通常子類也有自己的成員，我們要定義子類自己的建構函式，在子類建構函式中去調用父類建構函式以及初始化自己的成員。

但是，如果子類中沒有任何成員，或者其成員都用C++11的新特性“快速初始化成員變數”進行了初始化乃至於沒有必要再用建構函式初始化了，那這時候我們很可能希望直接將父類的建構函式繼承到子類，畢竟這時候只需要初始化父類成員。C++11允許我們使用using <父類名>::<父類名>來將所有父類建構函式引入子類，被using引入的父類建構函式是隱式聲明的（也就是說，只有用到的函式才會被生成，以節省生成的程式碼）。

（書中這一節很多描述都和XCode實驗現象對不上，很可能是因為成書時還無實驗環境，導致描述有誤）



## 委派建構函式

可以在建構函式的initializer-list中調用另一個建構函式來完成建構，這種將建構委託給另一個建構函式的行為  就叫委派建構函式。

一旦在initializer-list中進行了委派建構，就不能再用正常的initializer-list初始化成員變數了。因此，通常被委派的建構函式會負責初始化類的所有成員變數。



## 右值參照

可以使用兩個參照符號 && 來聲明並定義一個右值參照。和左值參照一樣，右值參照的聲明和定義必須在一塊。

在C++98中，已經對右值有了一些描述，C++11對右值進行了更進一步的定義：右值就是將亡值。

**C++98中，可以使用常數左值參照來參照右值**，比如：

const MyCls &myRef = getTemp();

這樣的常數左值參照的確參照了getTemp返回的臨時變數，延長了它的聲明週期，但由於C++98對於右值的定義是“不可被改變的常數”，因此之前只能使用對const的參照來參照右值。

C++11改變了對右值的定義，因此使用C++11的右值參照方式參照的右值，其內容可以被修改。



### 移動語意

在C++中，如果自定義類中含有指標，通常需要自定義複製建構函式和賦值運算子，在對指標進行賦值時，要為指標開闢新的堆記憶體，並將原指標內容複製過來，不要使用編譯器生成的預設函式。因為預設函式在賦值時通通採用淺複製，會導致兩個物件的指標指向同一地址，幾乎一定會導致野指標問題。

但是，有時候我們複製或賦值時，比如a = b，其中b如果是一個右值，那麼直接將b的指標賦值給a，並且阻止b物件在解構函式被調用時釋放指標記憶體，是更合適的做法。因此如果b是一個右值，這意味著b馬上就要被解構了，與其為a的指標開闢一片記憶體，不如直接利用b的指標現在使用的記憶體。**這種做法就被稱作“移動”b的資源到a，也就是“移動語意”。**

C++11中可以通過聲明移動建構函式/賦值函式實現移動語意，這樣的函式和普通函式的區別在於它們接受的參數型別是右值參照，因此當這樣的函式被調用時，可以確保被參照的值馬上就要被銷燬，可以直接移動其資源。

移動建構函式應該是不會拋出異常的，因為如果移動到一半被終止了，會導致物件的一部分指標成員變成懸掛指標。標準庫提供了move_if_noexcept函式，它會判斷物件是否實現了noexcept的移動建構函式，如果實現了才返回右值參照，不然就返回左值參照，避免使用移動語意，退化為使用普通的複製。



### 完美轉送

#### 右值參照的問題

有了右值參照，看起來我們可以完美地實現移動語意了，但是，需要留意的是，我們在將右值賦給一個右值參照後，這個右值參照其實會被當成一個左值參照（畢竟移動語意本身就要求對右值參照進行修改）！類似的，右值參照的成員也是一個左值。

因此，在訪問右值參照，或者在訪問右值參照的成員時，必須將其轉換成右值參照，否則就會被當成普通的左值參照。

```c++
// 像這樣的聲明賦值沒有意義，實際上，a依然會成為一個左值參照
// A &&a = getTemp();
A &a = getTemp();
acceptRValueRef(std::move(a));	// OK，這裡使用move把一個被當作左值參照的右值參照轉成右值參照
accestRValueRef(std::forward<A>(a));	// OK，forward也能起到轉為右值參照的作用
```

這個現象要求我們在創建移動建構函式時，必須要使用標準庫<utility>中提供的std::move對右值參照的每一個成員轉為右值參照，來保證移動語意。std::move會將其參數轉化為一個右值參照。之所以可以進行這樣的轉換，是因為我們已經知道了擁有成員的物件是一個右值參照，既然成員物件的擁有者本身馬上就要被銷燬，那麼成員物件也一定馬上就會被銷燬，此時將成員物件轉為左值處理才是正確的。

在將右值參照傳入參數為右值參照的函式時，編譯器會報錯，因為右值參照實際上一旦被賦給參照變數，就會被當成左值參照。要讓編譯器重新將其重新當成一個右值參照，必須使用std::move，std::forward將其轉成右值參照。



#### 參照摺疊

為了在樣板編程時，讓樣板能夠同時處理左值和右值參照，C++11引入了參照摺疊的規則：



```c++
using MyClsLRef = MyCls&;
using MyClsRRef = MyCls&&;

// C++11中被參照摺疊規則理解為左值參照
MyClsLRef&& lRef = getMyCls();
// 下面兩行是一樣的，其中第一行在C++11中被參照摺疊規則理解為右值參照
MyClsRRef&& rRef = getMyCls();
MyClsRRef rRef = getMyCls();

// 利用參照摺疊規則，可以在樣板編寫中將參數聲明為左值參照型別，這樣的樣板函式實際上可以同時接收
// 左值參照和右值參照
template <typename T>
void test(T&& t) { ... }
// 當T是一個右值參照時，T&&&&被摺疊成右值參照
// 當T是一個左值參照時，T&&&被摺疊成左值參照
// 不用考慮T不是一個參照，會有這樣的考慮說明對C++不夠熟悉，函式參數被聲明為參照，傳進來的肯定是參照
```



除了std::move，標準庫還提供了std::forward，它的作用其實和std::move有重疊，都可以用來將變數轉換為右值參照的。只不過它被規定應該專門用於“轉發”場景，並且在調用時必須指定樣板參數，從而可以利用參照摺疊規則，將參數的左右值參照保留下來：

```c++
A getTemp() {
    return A();
}

// 轉發函式
void forwardToTest(A&& a) {
    // do something
//    test(a);  無法通過編譯，因為一旦右值參照被賦給變數，這個變數就表現成了左值參照
    test(std::forward<A&&>(a));
}

// 轉發函式
template<typename T>
void forwardToTestTemplate(T&& a) {
//    test(a);	同樣無法通過編譯
    test(std::forward<T>(a));
}

template<typename T>
void test(T&& a) {
    
}
          

int main() {
    forwardToTest(getTemp());
    forwardToTestTemplate(getTemp());
    A a;
//    forwardToTest(a); 無法通過編譯，因為a不是右值參照
    forwardToTestTemplate(a);   // 可以通過編譯，因為樣板方法有參照摺疊規則
}
```



### move和forward的區別

- move調用時不需要提供樣板參數，它僅被用於將參數強制轉為右值參照；
- forward調用時必須要提供樣板參數，通常會提供這樣的樣板參數：forward<T&&>，這樣的好處是T如果被聲明為左值，轉換後還是左值，T如果被聲明為右值，轉換後還是右值。



## explicit 顯示轉換操作符

預設情況下，C++編譯器會在函式調用的參數和函式聲明不匹配時，想方設法地將參數轉為匹配的型別，讓函式調用能夠通過，這中間會檢查：

- 實際參數的型別轉換運算子，如果有轉換為目標型別的轉換運算子就調用；
- 目標型別的建構函式，看是否有接收實際參數型別的建構函式，如果有就調用；

有時這很方便，但更多場景下這樣的行為只會導致語意上的混亂。為了避免編譯器的隱式轉換，可以使用explicit修飾型別轉換運算子或建構函式，這樣編譯器就不會嘗試使用對應函式進行轉換。



## initializer_list 初始化列表

### 如何使用初始化列表

C++98中，僅允許使用initializer-list初始化陣列，C++11擴展了initializer-list的概念，使得普通型別也可以使用initializer-list初始化（不要把它和類的成員初始化搞混，它們的確都叫initializer-list，要區分時，可以將類的成員初始化叫做member initializer list）：



```c++
int a[]={1,3,5};//C++98通過，C++11通過
int b[]{2,4,6};//C++98失敗，C++11通過
vector<int> c{1,3,5};//C++98失敗，C++11通過
map<int,float> d = {{1,1.0f},{2,2.0f},{5,3.2f}};//C++98失敗，C++11通過
```



如果要讓自定義的類支援這種初始化方式，只要聲明一個接收在<initializer_list>中定義的initializer_list型別的建構函式就可以了。該型別是一個Iterable型別，可以使用begin, end等標準走訪方法。



### 防止型別收窄

使用初始化列表還可以促使編譯器檢查型別收窄的情況。初始化列表是目前唯一一種檢查型別收窄的方式（不過事實上現在的大多數編譯器在沒有使用初始化列表時也會檢查型別收窄並給出警告，但使用初始化列表編譯器會直接給出錯誤）。



## POD型別

POD，也就是Plain Ordinary Data，純數據型別。

C++11對POD的定義是：平凡的，且是標準佈局的。定義上，比C++98更寬容了，C++98只規定了C風格的struct是POD，但從POD的定義上，只要類物件佈局是標準的，這樣的類應該都是POD類。

（但是，對POD定義得更寬容似乎並沒有什麼意義？C++11更多的是對於哪些情況會導致物件佈局變化進行了更進一步的明確，只有不導致物件佈局變化的類定義才是POD類。）



## union 非受限聯合

C++11將C++98對union的一些限制移除了。

- 在C++98，union中只能包含基礎型別和POD型別，並且不能包含靜態方法，但在C++11中，union中可以包含任意非參照型別。
- C++11中，如果union任何一個成員擁有非平凡的建構函式，那麼編譯器就不會為union生成預設建構函式。

- C++11中，允許在類定義使用union聲明成員變數，用這種方式聲明的union不需要有型別名稱，被稱為匿名的非受限聯合，此時聯合內的所有成員都會自動的成為類的“變長成員”，即實際上它們共享同一處記憶體，應該只使用它們中的某一個。



## 用戶定義字面量

### 字面量操作符

- 接收字串：<用戶型別> operator "" _<後綴字符>(const char* col, size_t size)
- 接收整數：<用戶型別> operator "" _<後綴字符>(unsigned long long val)

- 接收整數，但整數越界，此時會傳入'\0'結尾的char*：<用戶型別> operator "" _<後綴字符>(const char*)
- 接收浮點：<用戶型別> operator "" _<後綴字符>(long double val)

- 接收字符：<用戶型別> operator "" _<後綴字符>(char val)



## 內聯名字空間

C++11規定可以在namespace前加上inline，將名字空間預設導出到聲明名字空間的作用域。

這樣的行為和C++98就有的匿名名字空間非常類似，除了內聯名字空間有自己的名字以外。不過，它們被創建出來的目的是不同的：

- 匿名名字空間在C++98中用於替代static修飾符，因為C++為類引入了static成員後，static的語意變得非常模糊且矛盾，因此在原本使用static聲明檔案作用域的變數的地方，可以改成使用匿名名字空間來包圍這些變數起到同樣的效果；
- 內聯名字空間則是被標準庫用於和巨集配合使用，根據當前編譯環境決定預設導出同一個功能的哪一個版本的實現，這樣做的好處是不關心具體實現的用戶可以直接使用預設導出的功能，而瞭解更全面的細節的用戶也可以使用名字空間來指定使用的是哪一個版本的功能。



## 使用using聲明樣板別名

在C++11中，已經可以使用using完全替代typedef了。

using不僅有更清晰的語意，還可以部分聲明樣板參數：



```c++
template <typename T> using StringObjectMap = std::map<string, T>;
StringObjectMap<MyCls> myMap;
```



## SFINAE規則

SFINAE，就是Substitution Failure Is Not An Error。

指的是，編譯器在嘗試樣板參數匹配時，只要能夠最終找到合適的匹配，中間嘗試過的任何匹配失敗都不會報錯。

只不過，C++98對於樣板參數中使用表達式的情況支援的不友好，C++11明確了任何在編譯期合法的表達式都能夠作為樣板參數，比如下面的這個例子就在C++98中無法通過編譯，而在C++11中可以：



```c++
template<int I> struct A{};char xxx(int);char xxx(float);template <class T> A<sizeof(xxx((T)0))> f(T){}
```



# 新手易學，老兵易用

## 右尖括號的改進

C++98曾經規定應該把 >> 優先判定為右移操作符，但這個規定在C++11被取消了，C++11規定編譯器可以自行智能地判斷>>是否是右移操作符。



## auto型別推導

在C++98中，auto其實是用於聲明一個變數具有“自動存儲期”，但實際上除了static以外的變數都是預設具有自動存儲期的，因此過去的auto幾乎沒有人使用。

C++11中，auto被賦予了新的含義，以前的auto含義被取消了。auto成為了新的型別指示符，auto聲明的變數的型別必須在編譯期由編譯器推導出來。



## decltype

decltype是在編譯時對錶達式進行型別推導，推導出的型別可用於定義新的變數。decltype主要是為了解決泛型編程中由於泛型參數型別不確定，導致和泛型參數相關的表達式型別無法確定的問題的。比如：

t1是泛型Type1型別，t2是泛型Type2型別，由於開發泛型程式碼時無法確定Type1和Type2的型別，自然無法確定t1 + t2的型別，但該型別其實是可以由編譯器推導出來的，decltype如今即可用在此處：

auto add(t1, t2) -> decltype(t1 + t2) {return t1 + t2;}

或者可以聲明原本無法聲明的變數：decltype(t1 + t2) addResult = t1 + t2;（當然，auto也可以完成此工作）。



有時會將decltype和auto搭配使用：decltype(auto)。這是因為一方面，我們希望依賴C++11的型別推導能力（auto的作用），但另一方面，又想保留cv限定符和參照（decltype的作用）（auto的型別推導規則和樣板類似，如果不把auto聲明為auto&或者auto*，auto就會被視為不具備cv限定符的值型別，如果auto被聲明為auto&或者auto*，auto推導出的型別才會保留cv限定符）。但是使用這樣的寫法時要小心：decltype在推導型別時，如果表達式是一個簡單的名字，它會推導出名字的型別，但如果表達式不只是一個名字，比如decltype((x))，那麼即使x只是一個int，該decltype也會推導出參照型別：int&。



## 追蹤返回型別

auto func(char* a,int b) -> int;



## 基於範圍的for迴圈

自定義集合型別要想支援這樣的for迴圈，需要實現begin, end, ++, ==四個函式。



# 提高型別安全

## 強型別列舉

C++98: enum X {...};

C++11: enum class X {...};



## 堆記憶體管理：智慧指標與垃圾回收



# 提高性能及操作硬體的能力

## 常數表達式

C++11規定使用constexpr修飾符來修飾常數表達式。常數表達式可以是函式或者值。常數表達式函式中不可以出現非常數表達式。常數表達式可以在編譯期使用，但如果常數表達式並沒有一定要在編譯期被計算出來，標準規定編譯器在這種情況下可以將常數表達式編譯成普通的表達式，表達式會在運行時被計算。



## 變長樣板

過去，C++可以使用C風格的方法來實現可變參函式，但這種實現方式是型別不安全的。

現在，C++11為可變參函式提出了更合理（型別安全）的解決方案：變長樣板。可以使用變長樣板來聲明變長樣板函式或者變長樣板類。



### 樣板參數包與遞歸

使用template <typename... Elements>這種方式可以聲明一個變長樣板參數，使用Elements...這種方式可以將變長樣板參數展開成實際的多個參數型別；

不定長的變長樣板類可以通過樣板類的遞歸來解包：



```c++
template <typename... Elements> class tuple;	// 變長樣板聲明
// 以下是兩個樣板偏特化定義，利用樣板偏特化會被優先匹配的規則，讓變長樣板參數遞歸地被解包
// 對於型別，可以使用遞歸的繼承
template <typename Head, typename... Tail> 
class tuple <Head, Tail...> : private tuple<Tail...> {
	Head head;
}
template <> class tuple {};

// 對於函式，可以使用遞歸的函式調用
// 下面實現一個更強大的Printf，不論%後面跟的是什麼符號，這個Printf總是會印出正確的型別
void Printf(const char* s) {
    while (*s) {
        if (*s == '%' && ++s != '%') {
         	   throw runtime_error("invalide format");
        }
        cout *s++;
    }
}

template <typename T, typename... Args>
void Printf(char* s, T value, Args... args) {
	while(*s) {
    	if (*s == '%' && *s++ != '%') {
        	cout << value;
            return Printf(++s, args...);
        }
        cout << *s++;
    }
    // 若百分號的數量和參數數量對不上，就拋異常
    throw runtime_error("extra arguments provided");
}
```



### 進階

#### 參照型別

定義了樣板參數包後，還可以在展開樣板參數包時使用參照標記：Args&&...，這樣的寫法是合法的；

#### 特殊展開

解包時，有些非常特殊的規則，需要特別說明一下：



```c++
template <typename... Args> class MyCls: private A<Args>... {};
// 上面的表達式在解包時會解包成多繼承：
T<Parent1, Parent2>  t;	// t的型別是：class MyCls: private A<Parent1>, A<Parent2>

template <typename Args...> class MyCls: private A<Args...> {};
// 而這個表達式在解包時，會在泛型參數表達式中直接展開
T<Parent1, Parent2>  t;	// t的型別是：class MyCls: private A<Parent1, Parent2>

template <typename Args...> void test(Args... args) {
    // 下面這個會被展開成call(a(arg1), a(arg2), ...)
	call(a(args)...);
    // 而下面這個會被展開成call(a(arg1, arg2, ...))
    call(a(args...));
}
```

#### 獲取變長參數包長度

可以使用sizeof...獲取樣板參數包的長度；



#### 樣板的樣板（的樣板的樣板...）

變長參數的樣板型別本身也可以是一個樣板，這一點和以前的非變長樣板參數一樣。





## 原子型別和原子操作

C++11以前，已經有很多使用多執行緒能力的C++程式了，但之前語言本身並沒有定義任何同多執行緒有關的內容，這些多執行緒能力來自於多執行緒介面pthread。pthread是一套C的介面。

通常情況下，如果我們不需要太精細的互斥控制，可以直接使用posix提供的mutex互斥鎖API，而如果想達到更最佳化的性能，可能會考慮為不同處理器編寫內斂彙編程式碼。

C++11標準為多執行緒程式在標準庫中添加了原子型別，並允許指定原子型別的記憶體訪問順序一致性，讓開發者可以不必操心作業系統和處理器的底層細節，也可以獲得最最佳化的性能。



## 執行緒局部存儲

C++11定義了thread_local關鍵字來定義執行緒局部存儲變數，這樣的變數生命期是執行緒啟動到執行緒結束，除了本執行緒外，沒有其他執行緒可以訪問到這樣的變數。

C++11僅規定了執行緒局部存儲的行為，而沒有規定其具體實現，不同的編譯器在不同的環境中可能會有不同的實現方式。



## 快速退出：quick_exit, at_quick_exit

在過去，大體上有三種退出程式的方式：terminate(), abort(), exit()。

- terminate是有未處理的異常時會被調用的方法，可以使用set_terminate方法更改預設行為，terminate預設調用abort；
- abort是行程不得不終止時，被調用的函式，它會向本行程發送一個SIGABRT信號，該信號預設會導致作業系統直接釋放該行程的所有資源並終止行程；

- exit是行程自發調用的退出函式，它代表著行程運行到了某個節點，該退出了，它會導致每一個自動變數的解構函式被調用（是的，僅自動變數，也就是棧變數會被調用解構函式，至於單例什麼的需要自己處理），並調用at_exit註冊的函式，然後才會回收行程；

C++11新增了quick_exit標準方法，該方法語意上和exit一樣，都是程式自發終止，但和exit不同的是，它不會進行本行程的清理工作，在多執行緒環境下也不會先等待執行緒結束，而是直接讓作業系統終止行程並回收資源。



# 為改變思想方式而改變

## 指標空值-nullptr

C++11定義了nullptr_t和nullptr，前者是型別，後者是該型別的值。

nullptr可以隱式轉換為任何指標，但無法被隱式轉換為bool型別，無法使用if (nullptr)這樣的表達式；此外它所屬的nullptr_t是一個基礎型別，nullptr無法被推導為T*這樣的樣板參數。



## 預設函式的控制

C++11規定可以使用 = default 來使編譯器生成預設版本的成員函式，可以由編譯器生成的函式包括：

- 空建構函式
- 複製建構函式

- 複製賦值函式
- 移動建構函式

- 移動複製函式
- 解構函式

此外，編譯器還為所有自定義型別提供以下全局預設操作符函式：

- operator, 
- operator&

- operator&&
- operator*

- operator->
- operator->*

- operator new
- operator delete



## lambda函式

lambda語法：

[<捕獲外部變數>]<(可選)mutable>(<(可選)參數列表>) -> <(可選)回傳值> {<函式體>}

- 捕獲外部變數：變數需要用&或者=開頭來參照，直接寫&或者=後面不跟變數表示捕獲所有外部變數，=表示按值捕獲，&表示參照捕獲；
- mutable：labmda預設是內聯的const函式，不可以修改任何捕獲的外部的按值捕獲的變數（因為目前lambda的語意其實和仿函式完全一致，在仿函式中，所有捕獲的外部變數都是仿函式類的成員，因此const函式不可以修改類成員，到lambda這裡變成了lambda不可以修改捕獲變數），但是參照捕獲的變數則可以修改（這個行為也是和仿函式一致的，const函式內可以調用任意成員參照的方法，修改其屬性，因為將參照聲明成const，和將指標聲明成const類似，都僅僅是禁止修改參照本身，但並沒有限制對參照或者指標指向的變數進行修改）。如果希望lambda不是一個const函式，就要添加mutable聲明；

- 參數列表：
- 回傳值：當能夠從函式體中推測出明確的回傳值型別時，可以忽略；

- 函式體：



# 融入實際應用

## 對齊支援

C和C++都是具備直接操作底層硬體能力的語言，因此某些開發者會對數據結構的對齊方式特別關注。

C++11規定了alignof和alignas關鍵字，前者可以查詢某個型別的對齊方式（一般來說都是32位元元-4位元元組或者64位元元-8位元元組對齊），而後者可以規定某個自定義類的對齊方式。比如如果我們想要使用內聯彙編的向量指令（可以同時處理4組處理器位元元數的數據）來最佳化處理速度，就可能想要將數據對齊到4*處理器位元元數的位元元置處。

需要注意的是，之前很多編譯器也規定了指定數據對齊方式的方式，比如GNU就規定可以使用如下方式規定對齊位元元組：__attribute__((__aligned__(8)))；

需要注意的是，雖然標準規定了指定對齊的方式，但每個平臺具體支援對齊到多少是不確定的。如果使用alignas(2^64)，那顯然是不合法的。不幸的是，目前標準似乎沒辦法查詢每個平臺支援的最大對齊位元元組。不過一般來說我們也用不到太大的對齊位元元組。



## 通用屬性

有時C/C++提供的語言能力無法完全滿足開發者的需求，編譯器廠商為了解決這些問題，提供了一系列的語言擴展來擴展C/C++的語法。這其中最常見的就是“屬性”，可以告訴編譯器一個符號的額外資訊，讓編譯器做一些語言規範之外的處理。

- GNU使用__attribute__((<屬性列表>))來聲明屬性；
- Windows使用__declspec(<屬性列表>)來聲明屬性

C++11也規定了類似的屬性，之所以在語言中添加屬性，是為了避免再給C++增加更多的關鍵字。C++11的屬性和之前各個平臺的編譯器實現的屬性的目的是一致的，它們提供的能力都是一般用不到，可以忽略的能力，語言規範不會考慮使用關鍵字來實現這些能力，因此將它們定義到通用屬性裡。C++規定通用屬性的寫法是：[[<屬性列表>]]，這樣的通用屬性可以用來修飾任何語言元素。不過目前C++11只定義了兩個通用屬性：[[noreturn]]和[[carries_dependency]]。



## Unicode支援

### 字符集和編碼

ASCII碼是最早的編碼，使用7位元元二進制位元元來表示所有英文字母和在英文排版印刷中用到的字符，後來ISO和Unicode組織共同制定了一套能夠唯一的表示世界上所有字符的標準字符集，稱為ISO/Unicode字符集或者Unicode字符集。Unicode規定了每個字符在整個字符集中的具體值（範圍0x0-0x10FFFFF），但並沒有規定電腦中如何存儲這樣的值，UTF-8 UTF-16 UTF-32是Unicode字符集事實上的編碼標準。

UTF-8使用1～6位元元組的變長編碼方式來編碼Unicode，由於UTF-8較為節約存儲空間，因此使用的比較廣泛。

![img](https://cdn.nlark.com/yuque/0/2019/png/244132/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png)

GB2312早於Unicode被定義，是和Unicode不同的一種編碼（不過Unicode漢字部分編碼其實就是GB2312的變種），採用2位元元組表示一箇中文字符，和Unicode不一樣的是，GB2312既是字符集，又是字符編碼。

### C++中的Unicode支援

C++98已經規定了wchar_t型別，但是C++98對wchar_t的定義不夠明確，不同的編譯器中wchar_t的位元元數不一致，導致移植性問題。

C++11重新規定了char16_t char32_t，用於存儲UTF-16 UTF-32編碼的Unicode數據，UTF-8的數據則直接使用char來存儲。C++中可以在字串常數前加前綴來讓編譯器產生不同編碼的數據：

- u8 - UTF8
- u - UTF-16

- U - UTF-32
- L - wchar_t

之所以沒有為UTF-8規定型別，是因為UTF-16和UTF-32都是定長編碼，而UTF-8是變長編碼（有誤，過去某段時間Unicode還比較少，當時UTF16編碼Unicode的確是事實上的定長編碼，但現在Unicode字符集已經收錄了更多字符，早已超出了UTF-16的表示範圍，UTF-16已經成為了事實上的變長編碼，一些歷史程式如果還假定UTF-16是定長編碼的話，遇到超出UTF-16表示範圍的字符時就會出問題。），變長編碼會導致很多演演算法變得極其複雜（比如無法確定一個utf_8[]中的第N個字符究竟被存儲在陣列中的哪個位元元置）。對於語言來說，定長編碼處理起來更自然，且增加的記憶體佔用和減少的程式設計複雜度也大體可以認為相互抵消，可以使用定長編碼進行處理，需要保存時再存成變長編碼以節省存儲空間。

C++中，影響Unicode字符能夠正確保存和輸出的因素有以下三點：

- 檔案編碼
- 編譯器編碼設置

- 輸出設備

為了確保得到正確的輸出，需要確保原始檔的編碼同系統編碼一致、並且用於輸出的設備支援被輸出的編碼（比如不少shell就只支援UTF-8編碼，非UTF-8編碼的會直接輸出十六進制的編碼值）。

### 標準庫支援

C++11新增了幾個字符型別，也同步地在標準庫中新增了字符型別的轉換函式。
