# 前言

## 說到C++11，應該想到什麼？

- 什麼是 lambda，及怎麼樣使用它是最好的？
- decltype 和 auto 類型推導有什麼關係？

- 什麼是移動語義，以及(右值引用)是如何解決轉發問題的？
- default/deleted 函數以及 override 是怎麼回事?

- 異常描述符被什麼替代了? noexcept 是如何工作的?
- 什麼是原子類型以及新的內存模型?

- 如何在 C++11 中做並行編程?



## 語言的哪些關鍵字和C++11有關？

- alignas
- alignof decltype

- auto(重新定義)
- static_assert

- using(重新定義)
- noexcept

- export(棄用，不過未來可能留作他用)
- nullptr

- constexpr
- thread_local



# 保證穩定性和兼容性

## 將C99標準納入C++11

### 確定編譯環境的預定義宏

- __STDC_HOSTED__：編譯器的目標系統環境中是否包含完整的C庫
- __STDC__：編譯器對於標準C庫的實現是否和C標準一致（是否定義、如何定義由編譯器決定）

-  __STDC_VERSION__：編譯器支持的C標準的版本（是否定義、如何定義由編譯器決定）
- __STDC_ISO_10646__：yyyymmL格式的整數常量，表示C++編譯環境符合某個版本的ISO/IEC 10646標準



### __func__ 預定義標識符

函數中可以使用__func__標識符函數名稱，編譯器會在函數定義開始時隱式地插入__func__標識符定義：

static const char* __func__ = "<函數名稱>";



### _Pragma 操作符

在之前的C/C++標準中已經規定了可以使用#pragma預處理指令向編譯器傳遞信息，比如可以通過在頭文件首行放置#pragma once來告訴編譯器這個頭文件只應該被include一次。

C++11中，規定了一個新的操作符_Pragma，它的作用與#pragma完全相同，_Pragma("once")就相當於#pragma once。但是，_Pragma由於是一個操作符而不是預處理指令，它的使用更為靈活，可以在宏中展開。



### 不定參數宏定義以及 __VA_ARGS__

C99規定宏定義中，在參數列表的最後，可以使用...省略參數定義，而__VA_ARGS__可以用來替換被省略號代表的字符串。



### 寬窄字符串連接



## long long整形

## 擴展的整形

## 宏__cplusplus

一般會和extern "C"配合使用，來讓一個頭文件即可以同時被include到C和C++中編譯，使用extern "C"避免C++對符號名稱進行重整，確保C++編譯器編譯出的目標文件中的符號名維持原樣。

```c++
#ifdef __cplusplus
extern "C" {
#endif
// 一些代碼
#ifdef __cplusplus 
}
#endif
```



## 靜態斷言

標準C庫assert.h中，提供了assert函數來進行運行時的斷言，表明某些情況一定不會發生。（在 C++ 中，程序員也可以定義宏 NDEBUG 來禁用 assert 宏。這對發佈程序來說還是必 要的。因為程序用戶對程序退出總是敏感的，而且部分的程序錯誤也未必會導致程序全部功 能失效。那麼通過定義 NDEBUG 宏發佈程序就可以儘量避免程序退出的狀況。而當程序有 問題時，通過沒有定義宏 NDEBUG 的版本，程序員則可以比較容易地找到出問題的位置。）

如果希望在預處理時確定某些情況一定不會發生，也可以使用#if進行判斷，使用#error終止編譯流程並給出錯誤提示。

C++11引入static_assert來補充編譯時斷言。之前Boost庫也實現了類似的功能，它是利用編譯器在編譯時會檢查除以0這個特性，如果條件為假就構建一個除以0的語句迫使編譯器報錯來實現的，雖然可以達成編譯時檢查的目的，但報錯信息比較不明確。使用C++11的static_assert，在斷言失敗時，可以得到明確的錯誤提示。



## noexcept修飾符與noexcept操作符

### 作為修飾符

noexcept作為修飾符可以用來表明函數是否會拋出異常，noexcept修飾符後面可以跟隨一個常量表達式，當常量表達式可以轉為true時表示不會拋出異常，false則表示會拋出異常。被noexcept修飾符標記為不會拋出異常的函數如果運行時拋出異常，會直接導致程序調用std::terminate終止執行，異常不會繼續沿棧傳播。

### 作為操作符

noexcept作為操作符可以用來判斷某個表達式是否會拋出異常。該操作符幫助我們在進行泛型編程時通過noexcept操作符判斷一個依賴模板參數的表達式是否會拋出異常。

```c++
template <class T>
void fun() noexcept(noexcept(T())) {}
```



### 替代廢棄的throw

C++98曾經定義了throw修飾符，用來表明表達式是否會拋出異常，一個空的throw()就和noexcept(true)表達的意思一樣，但throw要求明確指出會拋出哪些類型的異常，實際編程中大家很少需要了解異常類型，只希望瞭解是否會拋出異常，因此新的noexcept(false)用於替代throw(<異常類型>)。



## 快速初始化成員變量

C++98中，允許直接在類的靜態常量整型成員聲明時使用“=”對其初始化，這種聲明+初始化的做法被叫做“就地”聲明。這種聲明方式很便捷，但僅能對【靜態】【常量】【整型】成員進行這樣的聲明，使用場景很少，語法也不一致。

C++11中允許對非靜態成員進行就地的初始化，不再必須在構造函數中通過initializer-list進行初始化了。可以使用等號或者一對花括號{}進行就地初始化，其他形式無法通過編譯。

在成員同時使用就地初始化，並且在構造函數的初始化列表中進行初始化時，最終僅會以初始化列表為準對其進行初始化。



## 非靜態成員的sizeof

C++98中，sizeof可以作用於類的靜態成員，但對於非靜態成員，必須通過一個類實例來引用，因此之前為了獲取一個非靜態成員的大小，同時避免創建無用的類實例，通常會使用下面的技巧：

sizeof(((People*)0)->hand);

C++11後，sizeof可以直接作用於類成員表達式了，上面的技巧可以簡化成：

sizeof(People::hand)



## 擴展的friend語法

在C++98，如果要指定另一個類是當前類的友元，必須要使用friend class/struct <友元類>這樣的寫法，並且無法使用模板參數作為友元類，C++11允許省略class，而且可以使用模板參數作為友元類。

https://zh.cppreference.com/w/cpp/language/friend



## final/override

final用於在繼承關係的中間終止一個虛函數被子類重載的可能性。override用於顯式聲明某個函數是父類虛函數的重載，提升了代碼可讀性和健壯性（因為virtual修飾符只有在頂級父類聲明虛函數時才是必須的，子類為同名虛函數添加virtual修飾符會被忽略，而override修飾符會被編=‘譯器檢查以確保函數的確重載了虛函數）。它們都在函數聲明的參數列表之後。

為了儘可能兼容已有程序，C++11沒有將final和override規定為關鍵字，因此可以在代碼中使用final，override變量，但最好別這麼做。



## 模板函數的默認模板參數

C++98允許為類模板參數指定默認參數，但卻禁止為函數模板參數指定默認參數，語法上不一致，邏輯上不合理。

C++11放寬了這一限制，可以為函數模板指定默認模板參數了。



## 外部模板

C++中，如果多個源文件都使用了同一個模板，會對該模板進行多次實例化，但最後編譯時，編譯器會僅保留一份模板實例化產生的代碼。在一些比較大的項目中，冗餘的模板實例化會明顯拖慢編譯速度，可以使用“外部模板”技術告訴編譯器不需要對模板進行實例化，在某一個源文件中僅進行一次顯式實例化。

template void fun<int>(int); // 顯示地實例化

extern template void fun<int>(int); // 外部模板的聲明



## 局部和匿名類型作為模板實參

C++98禁止局部或者匿名的類型作為模板參數，這個限制沒什麼道理，因此C++11放寬了該限制。



```c++
// C++98中，只有A或者a可以作為模板參數
struct A {int a;} a;
// 匿名類型
typedef struct {int a;} B;
// 匿名類型變量
struct {int a;} b;

void test() {
    // 局部類型
 	struct C {int a;} c;
}
```



# 通用為本，專用為末

## 繼承構造函數

繼承關係中，子類可以自動或得父類的成員和接口，但構造函數無法自動地被子類繼承。因為通常子類也有自己的成員，我們要定義子類自己的構造函數，在子類構造函數中去調用父類構造函數以及初始化自己的成員。

但是，如果子類中沒有任何成員，或者其成員都用C++11的新特性“快速初始化成員變量”進行了初始化乃至於沒有必要再用構造函數初始化了，那這時候我們很可能希望直接將父類的構造函數繼承到子類，畢竟這時候只需要初始化父類成員。C++11允許我們使用using <父類名>::<父類名>來將所有父類構造函數引入子類，被using引入的父類構造函數是隱式聲明的（也就是說，只有用到的函數才會被生成，以節省生成的代碼）。

（書中這一節很多描述都和XCode實驗現象對不上，很可能是因為成書時還無實驗環境，導致描述有誤）



## 委派構造函數

可以在構造函數的initializer-list中調用另一個構造函數來完成構造，這種將構造委託給另一個構造函數的行為  就叫委派構造函數。

一旦在initializer-list中進行了委派構造，就不能再用正常的initializer-list初始化成員變量了。因此，通常被委派的構造函數會負責初始化類的所有成員變量。



## 右值引用

可以使用兩個引用符號 && 來聲明並定義一個右值引用。和左值引用一樣，右值引用的聲明和定義必須在一塊。

在C++98中，已經對右值有了一些描述，C++11對右值進行了更進一步的定義：右值就是將亡值。

**C++98中，可以使用常量左值引用來引用右值**，比如：

const MyCls &myRef = getTemp();

這樣的常量左值引用的確引用了getTemp返回的臨時變量，延長了它的聲明週期，但由於C++98對於右值的定義是“不可被改變的常量”，因此之前只能使用對const的引用來引用右值。

C++11改變了對右值的定義，因此使用C++11的右值引用方式引用的右值，其內容可以被修改。



### 移動語意

在C++中，如果自定義類中含有指針，通常需要自定義拷貝構造函數和賦值運算符，在對指針進行賦值時，要為指針開闢新的堆內存，並將原指針內容拷貝過來，不要使用編譯器生成的默認函數。因為默認函數在賦值時通通採用淺拷貝，會導致兩個對象的指針指向同一地址，幾乎一定會導致野指針問題。

但是，有時候我們拷貝或賦值時，比如a = b，其中b如果是一個右值，那麼直接將b的指針賦值給a，並且阻止b對象在析構函數被調用時釋放指針內存，是更合適的做法。因此如果b是一個右值，這意味著b馬上就要被析構了，與其為a的指針開闢一片內存，不如直接利用b的指針現在使用的內存。**這種做法就被稱作“移動”b的資源到a，也就是“移動語意”。**

C++11中可以通過聲明移動構造函數/賦值函數實現移動語意，這樣的函數和普通函數的區別在於它們接受的參數類型是右值引用，因此當這樣的函數被調用時，可以確保被引用的值馬上就要被銷燬，可以直接移動其資源。

移動構造函數應該是不會拋出異常的，因為如果移動到一半被終止了，會導致對象的一部分指針成員變成懸掛指針。標準庫提供了move_if_noexcept函數，它會判斷對象是否實現了noexcept的移動構造函數，如果實現了才返回右值引用，不然就返回左值引用，避免使用移動語意，退化為使用普通的拷貝。



### 完美轉發

#### 右值引用的問題

有了右值引用，看起來我們可以完美地實現移動語意了，但是，需要留意的是，我們在將右值賦給一個右值引用後，這個右值引用其實會被當成一個左值引用（畢竟移動語意本身就要求對右值引用進行修改）！類似的，右值引用的成員也是一個左值。

因此，在訪問右值引用，或者在訪問右值引用的成員時，必須將其轉換成右值引用，否則就會被當成普通的左值引用。

```c++
// 像這樣的聲明賦值沒有意義，實際上，a依然會成為一個左值引用
// A &&a = getTemp();
A &a = getTemp();
acceptRValueRef(std::move(a));	// OK，這裡使用move把一個被當作左值引用的右值引用轉成右值引用
accestRValueRef(std::forward<A>(a));	// OK，forward也能起到轉為右值引用的作用
```

這個現象要求我們在創建移動構造函數時，必須要使用標準庫<utility>中提供的std::move對右值引用的每一個成員轉為右值引用，來保證移動語意。std::move會將其參數轉化為一個右值引用。之所以可以進行這樣的轉換，是因為我們已經知道了擁有成員的對象是一個右值引用，既然成員對象的擁有者本身馬上就要被銷燬，那麼成員對象也一定馬上就會被銷燬，此時將成員對象轉為左值處理才是正確的。

在將右值引用傳入參數為右值引用的函數時，編譯器會報錯，因為右值引用實際上一旦被賦給引用變量，就會被當成左值引用。要讓編譯器重新將其重新當成一個右值引用，必須使用std::move，std::forward將其轉成右值引用。



#### 引用摺疊

為了在模板編程時，讓模板能夠同時處理左值和右值引用，C++11引入了引用摺疊的規則：



```c++
using MyClsLRef = MyCls&;
using MyClsRRef = MyCls&&;

// C++11中被引用摺疊規則理解為左值引用
MyClsLRef&& lRef = getMyCls();
// 下面兩行是一樣的，其中第一行在C++11中被引用摺疊規則理解為右值引用
MyClsRRef&& rRef = getMyCls();
MyClsRRef rRef = getMyCls();

// 利用引用摺疊規則，可以在模板編寫中將參數聲明為左值引用類型，這樣的模板函數實際上可以同時接收
// 左值引用和右值引用
template <typename T>
void test(T&& t) { ... }
// 當T是一個右值引用時，T&&&&被摺疊成右值引用
// 當T是一個左值引用時，T&&&被摺疊成左值引用
// 不用考慮T不是一個引用，會有這樣的考慮說明對C++不夠熟悉，函數參數被聲明為引用，傳進來的肯定是引用
```



除了std::move，標準庫還提供了std::forward，它的作用其實和std::move有重疊，都可以用來將變量轉換為右值引用的。只不過它被規定應該專門用於“轉發”場景，並且在調用時必須指定模板參數，從而可以利用引用摺疊規則，將參數的左右值引用保留下來：

```c++
A getTemp() {
    return A();
}

// 轉發函數
void forwardToTest(A&& a) {
    // do something
//    test(a);  無法通過編譯，因為一旦右值引用被賦給變量，這個變量就表現成了左值引用
    test(std::forward<A&&>(a));
}

// 轉發函數
template<typename T>
void forwardToTestTemplate(T&& a) {
//    test(a);	同樣無法通過編譯
    test(std::forward<T>(a));
}

template<typename T>
void test(T&& a) {
    
}
          

int main() {
    forwardToTest(getTemp());
    forwardToTestTemplate(getTemp());
    A a;
//    forwardToTest(a); 無法通過編譯，因為a不是右值引用
    forwardToTestTemplate(a);   // 可以通過編譯，因為模板方法有引用摺疊規則
}
```



### move和forward的區別

- move調用時不需要提供模板參數，它僅被用於將參數強制轉為右值引用；
- forward調用時必須要提供模板參數，通常會提供這樣的模板參數：forward<T&&>，這樣的好處是T如果被聲明為左值，轉換後還是左值，T如果被聲明為右值，轉換後還是右值。



## explicit 顯示轉換操作符

默認情況下，C++編譯器會在函數調用的參數和函數聲明不匹配時，想方設法地將參數轉為匹配的類型，讓函數調用能夠通過，這中間會檢查：

- 實參的類型轉換運算符，如果有轉換為目標類型的轉換運算符就調用；
- 目標類型的構造函數，看是否有接收實參類型的構造函數，如果有就調用；

有時這很方便，但更多場景下這樣的行為只會導致語意上的混亂。為了避免編譯器的隱式轉換，可以使用explicit修飾類型轉換運算符或構造函數，這樣編譯器就不會嘗試使用對應函數進行轉換。



## initializer_list 初始化列表

### 如何使用初始化列表

C++98中，僅允許使用initializer-list初始化數組，C++11擴展了initializer-list的概念，使得普通類型也可以使用initializer-list初始化（不要把它和類的成員初始化搞混，它們的確都叫initializer-list，要區分時，可以將類的成員初始化叫做member initializer list）：



```c++
int a[]={1,3,5};//C++98通過，C++11通過
int b[]{2,4,6};//C++98失敗，C++11通過
vector<int> c{1,3,5};//C++98失敗，C++11通過
map<int,float> d = {{1,1.0f},{2,2.0f},{5,3.2f}};//C++98失敗，C++11通過
```



如果要讓自定義的類支持這種初始化方式，只要聲明一個接收在<initializer_list>中定義的initializer_list類型的構造函數就可以了。該類型是一個Iterable類型，可以使用begin, end等標準遍歷方法。



### 防止類型收窄

使用初始化列表還可以促使編譯器檢查類型收窄的情況。初始化列表是目前唯一一種檢查類型收窄的方式（不過事實上現在的大多數編譯器在沒有使用初始化列表時也會檢查類型收窄並給出警告，但使用初始化列表編譯器會直接給出錯誤）。



## POD類型

POD，也就是Plain Ordinary Data，純數據類型。

C++11對POD的定義是：平凡的，且是標準佈局的。定義上，比C++98更寬容了，C++98只規定了C風格的struct是POD，但從POD的定義上，只要類對象佈局是標準的，這樣的類應該都是POD類。

（但是，對POD定義得更寬容似乎並沒有什麼意義？C++11更多的是對於哪些情況會導致對象佈局變化進行了更進一步的明確，只有不導致對象佈局變化的類定義才是POD類。）



## union 非受限聯合體

C++11將C++98對union的一些限制移除了。

- 在C++98，union中只能包含基礎類型和POD類型，並且不能包含靜態方法，但在C++11中，union中可以包含任意非引用類型。
- C++11中，如果union任何一個成員擁有非平凡的構造函數，那麼編譯器就不會為union生成默認構造函數。

- C++11中，允許在類定義使用union聲明成員變量，用這種方式聲明的union不需要有類型名稱，被稱為匿名的非受限聯合體，此時聯合體內的所有成員都會自動的成為類的“變長成員”，即實際上它們共享同一處內存，應該只使用它們中的某一個。



## 用戶定義字面量

### 字面量操作符

- 接收字符串：<用戶類型> operator "" _<後綴字符>(const char* col, size_t size)
- 接收整數：<用戶類型> operator "" _<後綴字符>(unsigned long long val)

- 接收整數，但整數越界，此時會傳入'\0'結尾的char*：<用戶類型> operator "" _<後綴字符>(const char*)
- 接收浮點：<用戶類型> operator "" _<後綴字符>(long double val)

- 接收字符：<用戶類型> operator "" _<後綴字符>(char val)



## 內聯名字空間

C++11規定可以在namespace前加上inline，將名字空間默認導出到聲明名字空間的作用域。

這樣的行為和C++98就有的匿名名字空間非常類似，除了內聯名字空間有自己的名字以外。不過，它們被創建出來的目的是不同的：

- 匿名名字空間在C++98中用於替代static修飾符，因為C++為類引入了static成員後，static的語意變得非常模糊且矛盾，因此在原本使用static聲明文件作用域的變量的地方，可以改成使用匿名名字空間來包圍這些變量起到同樣的效果；
- 內聯名字空間則是被標準庫用於和宏配合使用，根據當前編譯環境決定默認導出同一個功能的哪一個版本的實現，這樣做的好處是不關心具體實現的用戶可以直接使用默認導出的功能，而瞭解更全面的細節的用戶也可以使用名字空間來指定使用的是哪一個版本的功能。



## 使用using聲明模板別名

在C++11中，已經可以使用using完全替代typedef了。

using不僅有更清晰的語意，還可以部分聲明模板參數：



```c++
template <typename T> using StringObjectMap = std::map<string, T>;
StringObjectMap<MyCls> myMap;
```



## SFINAE規則

SFINAE，就是Substitution Failure Is Not An Error。

指的是，編譯器在嘗試模板參數匹配時，只要能夠最終找到合適的匹配，中間嘗試過的任何匹配失敗都不會報錯。

只不過，C++98對於模板參數中使用表達式的情況支持的不友好，C++11明確了任何在編譯期合法的表達式都能夠作為模板參數，比如下面的這個例子就在C++98中無法通過編譯，而在C++11中可以：



```c++
template<int I> struct A{};char xxx(int);char xxx(float);template <class T> A<sizeof(xxx((T)0))> f(T){}
```



# 新手易學，老兵易用

## 右尖括號的改進

C++98曾經規定應該把 >> 優先判定為右移操作符，但這個規定在C++11被取消了，C++11規定編譯器可以自行智能地判斷>>是否是右移操作符。



## auto類型推導

在C++98中，auto其實是用於聲明一個變量具有“自動存儲期”，但實際上除了static以外的變量都是默認具有自動存儲期的，因此過去的auto幾乎沒有人使用。

C++11中，auto被賦予了新的含義，以前的auto含義被取消了。auto成為了新的類型指示符，auto聲明的變量的類型必須在編譯期由編譯器推導出來。



## decltype

decltype是在編譯時對錶達式進行類型推導，推導出的類型可用於定義新的變量。decltype主要是為了解決泛型編程中由於泛型參數類型不確定，導致和泛型參數相關的表達式類型無法確定的問題的。比如：

t1是泛型Type1類型，t2是泛型Type2類型，由於開發泛型代碼時無法確定Type1和Type2的類型，自然無法確定t1 + t2的類型，但該類型其實是可以由編譯器推導出來的，decltype如今即可用在此處：

auto add(t1, t2) -> decltype(t1 + t2) {return t1 + t2;}

或者可以聲明原本無法聲明的變量：decltype(t1 + t2) addResult = t1 + t2;（當然，auto也可以完成此工作）。



有時會將decltype和auto搭配使用：decltype(auto)。這是因為一方面，我們希望依賴C++11的類型推導能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的類型推導規則和模板類似，如果不把auto聲明為auto&或者auto*，auto就會被視為不具備cv限定符的值類型，如果auto被聲明為auto&或者auto*，auto推導出的類型才會保留cv限定符）。但是使用這樣的寫法時要小心：decltype在推導類型時，如果表達式是一個簡單的名字，它會推導出名字的類型，但如果表達式不只是一個名字，比如decltype((x))，那麼即使x只是一個int，該decltype也會推導出引用類型：int&。



## 追蹤返回類型

auto func(char* a,int b) -> int;



## 基於範圍的for循環

自定義集合類型要想支持這樣的for循環，需要實現begin, end, ++, ==四個函數。



# 提高類型安全

## 強類型枚舉

C++98: enum X {...};

C++11: enum class X {...};



## 堆內存管理：智能指針與垃圾回收



# 提高性能及操作硬件的能力

## 常量表達式

C++11規定使用constexpr修飾符來修飾常量表達式。常量表達式可以是函數或者值。常量表達式函數中不可以出現非常量表達式。常量表達式可以在編譯期使用，但如果常量表達式並沒有一定要在編譯期被計算出來，標準規定編譯器在這種情況下可以將常量表達式編譯成普通的表達式，表達式會在運行時被計算。



## 變長模板

過去，C++可以使用C風格的方法來實現可變參函數，但這種實現方式是類型不安全的。

現在，C++11為可變參函數提出了更合理（類型安全）的解決方案：變長模板。可以使用變長模板來聲明變長模板函數或者變長模板類。



### 模板參數包與遞歸

使用template <typename... Elements>這種方式可以聲明一個變長模板參數，使用Elements...這種方式可以將變長模板參數展開成實際的多個參數類型；

不定長的變長模板類可以通過模板類的遞歸來解包：



```c++
template <typename... Elements> class tuple;	// 變長模板聲明
// 以下是兩個模板偏特化定義，利用模板偏特化會被優先匹配的規則，讓變長模板參數遞歸地被解包
// 對於類型，可以使用遞歸的繼承
template <typename Head, typename... Tail> 
class tuple <Head, Tail...> : private tuple<Tail...> {
	Head head;
}
template <> class tuple {};

// 對於函數，可以使用遞歸的函數調用
// 下面實現一個更強大的Printf，不論%後面跟的是什麼符號，這個Printf總是會打印正確的類型
void Printf(const char* s) {
    while (*s) {
        if (*s == '%' && ++s != '%') {
         	   throw runtime_error("invalide format");
        }
        cout *s++;
    }
}

template <typename T, typename... Args>
void Printf(char* s, T value, Args... args) {
	while(*s) {
    	if (*s == '%' && *s++ != '%') {
        	cout << value;
            return Printf(++s, args...);
        }
        cout << *s++;
    }
    // 若百分號的數量和參數數量對不上，就拋異常
    throw runtime_error("extra arguments provided");
}
```



### 進階

#### 引用類型

定義了模板參數包後，還可以在展開模板參數包時使用引用標記：Args&&...，這樣的寫法是合法的；

#### 特殊展開

解包時，有些非常特殊的規則，需要特別說明一下：



```c++
template <typename... Args> class MyCls: private A<Args>... {};
// 上面的表達式在解包時會解包成多繼承：
T<Parent1, Parent2>  t;	// t的類型是：class MyCls: private A<Parent1>, A<Parent2>

template <typename Args...> class MyCls: private A<Args...> {};
// 而這個表達式在解包時，會在泛型參數表達式中直接展開
T<Parent1, Parent2>  t;	// t的類型是：class MyCls: private A<Parent1, Parent2>

template <typename Args...> void test(Args... args) {
    // 下面這個會被展開成call(a(arg1), a(arg2), ...)
	call(a(args)...);
    // 而下面這個會被展開成call(a(arg1, arg2, ...))
    call(a(args...));
}
```

#### 獲取變長參數包長度

可以使用sizeof...獲取模板參數包的長度；



#### 模板的模板（的模板的模板...）

變長參數的模板類型本身也可以是一個模板，這一點和以前的非變長模板參數一樣。





## 原子類型和原子操作

C++11以前，已經有很多使用多線程能力的C++程序了，但之前語言本身並沒有定義任何同多線程有關的內容，這些多線程能力來自於多線程接口pthread。pthread是一套C的接口。

通常情況下，如果我們不需要太精細的互斥控制，可以直接使用posix提供的mutex互斥鎖API，而如果想達到更優化的性能，可能會考慮為不同處理器編寫內斂彙編代碼。

C++11標準為多線程程序在標準庫中添加了原子類型，並允許指定原子類型的內存訪問順序一致性，讓開發者可以不必操心操作系統和處理器的底層細節，也可以獲得最優化的性能。



## 線程局部存儲

C++11定義了thread_local關鍵字來定義線程局部存儲變量，這樣的變量生命期是線程啟動到線程結束，除了本線程外，沒有其他線程可以訪問到這樣的變量。

C++11僅規定了線程局部存儲的行為，而沒有規定其具體實現，不同的編譯器在不同的環境中可能會有不同的實現方式。



## 快速退出：quick_exit, at_quick_exit

在過去，大體上有三種退出程序的方式：terminate(), abort(), exit()。

- terminate是有未處理的異常時會被調用的方法，可以使用set_terminate方法更改默認行為，terminate默認調用abort；
- abort是進程不得不終止時，被調用的函數，它會向本進程發送一個SIGABRT信號，該信號默認會導致操作系統直接釋放該進程的所有資源並終止進程；

- exit是進程自發調用的退出函數，它代表著進程運行到了某個節點，該退出了，它會導致每一個自動變量的析構函數被調用（是的，僅自動變量，也就是棧變量會被調用析構函數，至於單例什麼的需要自己處理），並調用at_exit註冊的函數，然後才會回收進程；

C++11新增了quick_exit標準方法，該方法語意上和exit一樣，都是程序自發終止，但和exit不同的是，它不會進行本進程的清理工作，在多線程環境下也不會先等待線程結束，而是直接讓操作系統終止進程並回收資源。



# 為改變思想方式而改變

## 指針空值-nullptr

C++11定義了nullptr_t和nullptr，前者是類型，後者是該類型的值。

nullptr可以隱式轉換為任何指針，但無法被隱式轉換為bool類型，無法使用if (nullptr)這樣的表達式；此外它所屬的nullptr_t是一個基礎類型，nullptr無法被推導為T*這樣的模板參數。



## 默認函數的控制

C++11規定可以使用 = default 來使編譯器生成默認版本的成員函數，可以由編譯器生成的函數包括：

- 空構造函數
- 拷貝構造函數

- 拷貝賦值函數
- 移動構造函數

- 移動拷貝函數
- 析構函數

此外，編譯器還為所有自定義類型提供以下全局默認操作符函數：

- operator, 
- operator&

- operator&&
- operator*

- operator->
- operator->*

- operator new
- operator delete



## lambda函數

lambda語法：

[<捕獲外部變量>]<(可選)mutable>(<(可選)參數列表>) -> <(可選)返回值> {<函數體>}

- 捕獲外部變量：變量需要用&或者=開頭來引用，直接寫&或者=後面不跟變量表示捕獲所有外部變量，=表示按值捕獲，&表示引用捕獲；
- mutable：labmda默認是內聯的const函數，不可以修改任何捕獲的外部的按值捕獲的變量（因為目前lambda的語意其實和仿函數完全一致，在仿函數中，所有捕獲的外部變量都是仿函數類的成員，因此const函數不可以修改類成員，到lambda這裡變成了lambda不可以修改捕獲變量），但是引用捕獲的變量則可以修改（這個行為也是和仿函數一致的，const函數內可以調用任意成員引用的方法，修改其屬性，因為將引用聲明成const，和將指針聲明成const類似，都僅僅是禁止修改引用本身，但並沒有限制對引用或者指針指向的變量進行修改）。如果希望lambda不是一個const函數，就要添加mutable聲明；

- 參數列表：
- 返回值：當能夠從函數體中推測出明確的返回值類型時，可以忽略；

- 函數體：



# 融入實際應用

## 對齊支持

C和C++都是具備直接操作底層硬件能力的語言，因此某些開發者會對數據結構的對齊方式特別關注。

C++11規定了alignof和alignas關鍵字，前者可以查詢某個類型的對齊方式（一般來說都是32位-4字節或者64位-8字節對齊），而後者可以規定某個自定義類的對齊方式。比如如果我們想要使用內聯彙編的向量指令（可以同時處理4組處理器位數的數據）來優化處理速度，就可能想要將數據對齊到4*處理器位數的位置處。

需要注意的是，之前很多編譯器也規定了指定數據對齊方式的方式，比如GNU就規定可以使用如下方式規定對齊字節：__attribute__((__aligned__(8)))；

需要注意的是，雖然標準規定了指定對齊的方式，但每個平臺具體支持對齊到多少是不確定的。如果使用alignas(2^64)，那顯然是不合法的。不幸的是，目前標準似乎沒辦法查詢每個平臺支持的最大對齊字節。不過一般來說我們也用不到太大的對齊字節。



## 通用屬性

有時C/C++提供的語言能力無法完全滿足開發者的需求，編譯器廠商為了解決這些問題，提供了一系列的語言擴展來擴展C/C++的語法。這其中最常見的就是“屬性”，可以告訴編譯器一個符號的額外信息，讓編譯器做一些語言規範之外的處理。

- GNU使用__attribute__((<屬性列表>))來聲明屬性；
- Windows使用__declspec(<屬性列表>)來聲明屬性

C++11也規定了類似的屬性，之所以在語言中添加屬性，是為了避免再給C++增加更多的關鍵字。C++11的屬性和之前各個平臺的編譯器實現的屬性的目的是一致的，它們提供的能力都是一般用不到，可以忽略的能力，語言規範不會考慮使用關鍵字來實現這些能力，因此將它們定義到通用屬性裡。C++規定通用屬性的寫法是：[[<屬性列表>]]，這樣的通用屬性可以用來修飾任何語言元素。不過目前C++11只定義了兩個通用屬性：[[noreturn]]和[[carries_dependency]]。



## Unicode支持

### 字符集和編碼

ASCII碼是最早的編碼，使用7位二進制位來表示所有英文字母和在英文排版印刷中用到的字符，後來ISO和Unicode組織共同制定了一套能夠唯一的表示世界上所有字符的標準字符集，稱為ISO/Unicode字符集或者Unicode字符集。Unicode規定了每個字符在整個字符集中的具體值（範圍0x0-0x10FFFFF），但並沒有規定計算機中如何存儲這樣的值，UTF-8 UTF-16 UTF-32是Unicode字符集事實上的編碼標準。

UTF-8使用1～6字節的變長編碼方式來編碼Unicode，由於UTF-8較為節約存儲空間，因此使用的比較廣泛。

![img](https://cdn.nlark.com/yuque/0/2019/png/244132/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png)

GB2312早於Unicode被定義，是和Unicode不同的一種編碼（不過Unicode漢字部分編碼其實就是GB2312的變種），採用2字節表示一箇中文字符，和Unicode不一樣的是，GB2312既是字符集，又是字符編碼。

### C++中的Unicode支持

C++98已經規定了wchar_t類型，但是C++98對wchar_t的定義不夠明確，不同的編譯器中wchar_t的位數不一致，導致移植性問題。

C++11重新規定了char16_t char32_t，用於存儲UTF-16 UTF-32編碼的Unicode數據，UTF-8的數據則直接使用char來存儲。C++中可以在字符串常量前加前綴來讓編譯器產生不同編碼的數據：

- u8 - UTF8
- u - UTF-16

- U - UTF-32
- L - wchar_t

之所以沒有為UTF-8規定類型，是因為UTF-16和UTF-32都是定長編碼，而UTF-8是變長編碼（有誤，過去某段時間Unicode還比較少，當時UTF16編碼Unicode的確是事實上的定長編碼，但現在Unicode字符集已經收錄了更多字符，早已超出了UTF-16的表示範圍，UTF-16已經成為了事實上的變長編碼，一些歷史程序如果還假定UTF-16是定長編碼的話，遇到超出UTF-16表示範圍的字符時就會出問題。），變長編碼會導致很多算法變得極其複雜（比如無法確定一個utf_8[]中的第N個字符究竟被存儲在數組中的哪個位置）。對於語言來說，定長編碼處理起來更自然，且增加的內存佔用和減少的程序設計複雜度也大體可以認為相互抵消，可以使用定長編碼進行處理，需要保存時再存成變長編碼以節省存儲空間。

C++中，影響Unicode字符能夠正確保存和輸出的因素有以下三點：

- 文件編碼
- 編譯器編碼設置

- 輸出設備

為了確保得到正確的輸出，需要確保源文件的編碼同系統編碼一致、並且用於輸出的設備支持被輸出的編碼（比如不少shell就只支持UTF-8編碼，非UTF-8編碼的會直接輸出十六進制的編碼值）。

### 標準庫支持

C++11新增了幾個字符類型，也同步地在標準庫中新增了字符類型的轉換函數。
