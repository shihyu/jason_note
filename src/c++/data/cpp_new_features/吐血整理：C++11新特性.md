### auto & decltype

關於C++11新特性，最先提到的肯定是型別推導，C++11引入了auto和decltype關鍵字，使用他們可以在編譯期就推導出變數或者表達式的型別，方便開發者編碼也簡化了程式碼。

- auto：讓編譯器在編譯器就推導出變數的型別，可以通過=右邊的型別推導出變數的型別。

```c++
auto a = 10; // 10是int型，可以自動推導出a是int
```

- decltype：相對於auto用於推導變數型別，而decltype則用於推導表達式型別，這裡只用於編譯器分析表達式的型別，表達式實際不會進行運算。

```c++
cont int &i = 1;int a = 2;decltype(i) b = 2; // b是const int&
```

### 左值右值

眾所周知C++11新增了右值參照，這裡涉及到很多概念：

- 左值：可以取地址並且有名字的東西就是左值。
- 右值：不能取地址的沒有名字的東西就是右值。

- 純右值：運算表達式產生的臨時變數、不和物件關聯的原始字面量、非參照返回的臨時變數、lambda表達式等都是純右值。
- 將亡值：可以理解為即將要銷燬的值。

- 左值參照：對左值進行參照的型別。
- 右值參照：對右值進行參照的型別。

- 移動語意：轉移資源所有權，類似於轉讓或者資源竊取的意思，對於那塊資源，轉為自己所擁有，別人不再擁有也不會再使用。
- 完美轉送：可以寫一個接受任意實際參數的函式樣板，並轉發到其它函式，目標函式會收到與轉發函式完全相同的實際參數。

- 回傳值最佳化：當函式需要返回一個物件實體時候，就會創建一個臨時物件並通過複製建構函式將目標物件複製到臨時物件，這裡有複製建構函式和解構函式會被多餘的調用到，有代價，而通過回傳值最佳化，C++標準允許省略調用這些複製建構函式。

### 列表初始化

在C++11中可以直接在變數名後面加上初始化列表來進行物件的初始化。

### std::function & std::bind & lambda表達式

c++11新增了std::function、std::bind、lambda表達式等封裝使函式調用更加方便。

### 樣板的改進

C++11關於樣板有一些細節的改進：

- 樣板的右尖括號
- 樣板的別名

- 函式樣板的預設樣板參數

### 併發

c++11關於併發引入了好多好東西，有：

- std::thread相關
- std::mutex相關

- std::lock相關
- std::atomic相關

- std::call_once相關
- volatile相關

- std::condition_variable相關
- std::future相關

- async相關

### 智慧指標

很多人談到c++，說它特別難，可能有一部分就是因為c++的記憶體管理，不像java那樣有虛擬機動態的管理記憶體，在程式運行過程中可能就會出現記憶體洩漏，然而這種問題其實都可以通過c++11引入的智慧指標來解決，這種記憶體管理還是c++語言的優勢，因為盡在掌握。

c++11引入了三種智慧指標：

- std::shared_ptr
- std::weak_ptr

- std::unique_ptr

### 基於範圍的for迴圈

看程式碼

```c++
vector<int> vec;

for (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11
    cout << *iter << endl;
}

for (int i : vec) { // c++11基於範圍的for迴圈
    cout << "i" << endl;
}
```

### 委託建構函式

委託建構函式允許在同一個類中一個建構函式調用另外一個建構函式，可以在變數初始化時簡化操作，通過程式碼來感受下委託建構函式的妙處：

不使用委託建構函式：

```c++
struct A {
    A(){}
    A(int a) { a_ = a; }

    A(int a, int b) { // 好麻煩
        a_ = a;
        b_ = b;
    }

    A(int a, int b, int c) { // 好麻煩
        a_ = a;
        b_ = b;
        c_ = c;
    }

    int a_;
    int b_;
    int c_;
};
```

使用委託建構函式：

```c++
struct A {
    A(){}
    A(int a) { a_ = a; }

    A(int a, int b) : A(a) { b_ = b; }

    A(int a, int b, int c) : A(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};
```

初始化變數是不是方便了許多。

### 繼承建構函式

繼承建構函式可以讓派生類直接使用基類的建構函式，如果有一個派生類，希望派生類採用和基類一樣的建構方式，可以直接使用基類的建構函式，而不是再重新寫一遍建構函式，老規矩，看程式碼：

不使用繼承建構函式：

```c++
struct Base {
    Base() {}
    Base(int a) { a_ = a; }

    Base(int a, int b) : Base(a) { b_ = b; }

    Base(int a, int b, int c) : Base(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};

struct Derived : Base {
    Derived() {}
    Derived(int a) : Base(a) {} // 好麻煩
    Derived(int a, int b) : Base(a, b) {} // 好麻煩
    Derived(int a, int b, int c) : Base(a, b, c) {} // 好麻煩
};
int main() {
    Derived a(1, 2, 3);
    return 0;
}
```

使用繼承建構函式：

```c++
struct Base {
    Base() {}
    Base(int a) { a_ = a; }

    Base(int a, int b) : Base(a) { b_ = b; }

    Base(int a, int b, int c) : Base(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};

struct Derived : Base {
    using Base::Base;
};

int main() {
    Derived a(1, 2, 3);
    return 0;
}
```

只需要使用using Base::Base繼承建構函式，就免去了很多覆寫程式碼的麻煩。

### nullptr

nullptr是c++11用來表示空指標新引入的常數值，在c++中如果表示空指標語義時建議使用nullptr而不要使用NULL，因為NULL本質上是個int型的0，其實不是個指標。舉例：

```c++
void func(void *ptr) {
    cout << "func ptr" << endl;
}

void func(int i) {
    cout << "func i" << endl;
}

int main() {
    func(NULL); // 編譯失敗，會產生二義性
    func(nullptr); // 輸出func ptr
    return 0;
}
```

### final & override

c++11關於繼承新增了兩個關鍵字，final用於修飾一個類，表示禁止該類進一步派生和虛擬函式的進一步多載，override用於修飾派生類中的成員函式，標明該函式覆寫了基類函式，如果一個函式聲明瞭override但父類卻沒有這個虛擬函式，編譯報錯，使用override關鍵字可以避免開發者在覆寫基類函式時無意產生的錯誤。

示例程式碼1：

```c++
struct Base {
    virtual void func() {
        cout << "base" << endl;
    }
};

struct Derived : public Base{
    void func() override { // 確保func被覆寫
        cout << "derived" << endl;
    }

    void fu() override { // error，基類沒有fu()，不可以被覆寫
    }
};
```

示例程式碼2：

```c++
struct Base final {
    virtual void func() {
        cout << "base" << endl;
    }
};

struct Derived : public Base{ // 編譯失敗，final修飾的類不可以被繼承
    void func() override {
        cout << "derived" << endl;
    }
};
```

### default

c++11引入default特性，多數時候用於聲明建構函式為預設建構函式，如果類中有了自定義的建構函式，編譯器就不會隱式生成預設建構函式，如下程式碼：

```c++
struct A {
    int a;
    A(int i) { a = i; }
};

int main() {
    A a; // 編譯出錯
    return 0;
}
```

上面程式碼編譯出錯，因為沒有匹配的建構函式，因為編譯器沒有生成預設建構函式，而通過default，程式員只需在函式聲明後加上“=default;”，就可將該函式聲明為 defaulted 函式，編譯器將為顯式聲明的 defaulted 函式自動生成函式體，如下：

```c++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a;
    return 0;
}
```

編譯通過。

### delete

c++中，如果開發人員沒有定義特殊成員函式，那麼編譯器在需要特殊成員函式時候會隱式自動生成一個預設的特殊成員函式，例如複製建構函式或者複製賦值操作符，如下程式碼：

```c++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 正確，調用編譯器隱式生成的預設複製建構函式
    A a3;
    a3 = a1;  // 正確，調用編譯器隱式生成的預設複製賦值操作符
}
```

有時候想禁止物件的複製與賦值，可以使用delete修飾，如下：

```c++
struct A {
    A() = default;
    A(const A&) = delete;
    A& operator=(const A&) = delete;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 錯誤，複製建構函式被禁用
    A a3;
    a3 = a1;  // 錯誤，複製賦值操作符被禁用
}
```

delele函式在c++11中很常用，std::unique_ptr就是通過delete修飾來禁止物件的複製的。

### explicit

explicit專用於修飾建構函式，表示只能顯式建構，不可以被隱式轉換，根據程式碼看explicit的作用：

不用explicit：

```c++
struct A {
    A(int value) { // 沒有explicit關鍵字
        cout << "value" << endl;
    }
};

int main() {
    A a = 1; // 可以隱式轉換
    return 0;
}
```

使用explicit:

```c++
struct A {
    explicit A(int value) {
        cout << "value" << endl;
    }
};

int main() {
    A a = 1; // error，不可以隱式轉換
    A aa(2); // ok
    return 0;
}
```

### const

因為要講後面的constexpr，所以這裡簡單介紹下const。

const字面意思為只讀，可用於定義變數，表示變數是隻讀的，不可以更改，如果更改，編譯期間就會報錯。

主要用法如下：

1. 用於定義常數，const的修飾的變數不可更改。

```c++
const int value = 5;
```

1. 指標也可以使用const，這裡有個小技巧，從右向左讀，即可知道const究竟修飾的是指標還是指標所指向的內容。

```c++
char *const ptr; // 指標本身是常數
const char* ptr; // 指標指向的變數為常數
```

1. 在函式參數中使用const，一般會傳遞類物件時會傳遞一個const的參照或者指標，這樣可以避免物件的複製，也可以防止物件被修改。

```c++
class A{};
void func(const A& a);
```

1. const修飾類的成員變數，表示是成員常數，不能被修改，可以在初始化列表中被賦值。

```c++
class A {
    const int value = 5;
};
class B {
    const int value;
    B(int v) : value(v){}
};
```

1. 修飾類成員函式，表示在該函式內不可以修改該類的成員變數。

```c++
class A{
    void func() const;
};
```

1. 修飾類物件，類物件只能調用該物件的const成員函式。

```c++
class A {
    void func() const;
};
const A a;
a.func();
```

### constexpr

constexpr是c++11新引入的關鍵字，用於編譯時的常數和常數函式，這裡直接介紹constexpr和const的區別：

兩者都代表可讀，const只表示read only的語義，只保證了運行時不可以被修改，但它修飾的仍然有可能是個動態變數，而constexpr修飾的才是真正的常數，它會在編譯期間就會被計算出來，整個運行過程中都不可以被改變，constexpr可以用於修飾函式，這個函式的回傳值會盡可能在編譯期間被計算出來當作一個常數，但是如果編譯期間此函式不能被計算出來，那它就會當作一個普通函式被處理。如下程式碼：

```c++
#include<iostream>
using namespace std;

constexpr int func(int i) {
    return i + 1;
}

int main() {
    int i = 2;
    func(i);// 普通函式
    func(2);// 編譯期間就會被計算出來
}
```

### enum class

c++11新增有作用域的列舉型別，看程式碼

不帶作用域的列舉程式碼：

```c++
enum AColor {
    kRed,
    kGreen,
    kBlue
};

enum BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (kRed == kWhite) {
        cout << "red == white" << endl;
    }
    return 0;
}
```

如上程式碼，不帶作用域的列舉型別可以自動轉換成整形，且不同的列舉可以相互比較，程式碼中的紅色居然可以和白色比較，這都是潛在的難以除錯的bug，而這種完全可以通過有作用域的列舉來規避。

有作用域的列舉程式碼：

```c++
enum class AColor {
    kRed,
    kGreen,
    kBlue
};

enum class BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (AColor::kRed == BColor::kWhite) { // 編譯失敗
        cout << "red == white" << endl;
    }
    return 0;
}
```

使用帶有作用域的列舉型別後，對不同的列舉進行比較會導致編譯失敗，消除潛在bug，同時帶作用域的列舉型別可以選擇底層型別，預設是int，可以改成char等別的型別。

```c++
enum class AColor : char {
    kRed,
    kGreen,
    kBlue
};
```

平時編程過程中使用列舉，一定要使用有作用域的列舉取代傳統的列舉。

### 非受限聯合

c++11之前union中數據成員的型別不允許有非POD型別，而這個限制在c++11被取消，允許數據成員型別有非POD型別，看程式碼：

```c++
struct A {
    int a;
    int *b;
};

union U {
    A a; // 非POD型別 c++11之前不可以這樣定義聯合
    int b;
};
```

對於什麼是POD型別，大家可以自行查下資料，大體上可以理解為物件可以直接memcpy的型別。

### sizeof

c++11中sizeof可以用的類的數據成員上，看程式碼：

c++11前：

```c++
struct A {
    int data[10];
    int a;
};

int main() {
    A a;
    cout << "size " << sizeof(a.data) << endl;
    return 0;
}
```

c++11後：

```c++
struct A {
    int data[10];
    int a;
};

int main() {
    cout << "size " << sizeof(A::data) << endl;
    return 0;
}
```

想知道類中數據成員的大小在c++11中是不是方便了許多，而不需要定義一個物件，在計算物件的成員大小。

### assertion

```c++
static_assert(true/false, message);
```

c++11引入static_assert聲明，用於在編譯期間檢查，如果第一個參數值為false，則印出message，編譯失敗。

### 自定義字面量

c++11可以自定義字面量，平時c++中都或多或少使用過chrono中的時間，例如：

```c++
std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 100ms
std::this_thread::sleep_for(std::chrono::seconds(100)); // 100s
```

其實沒必要這麼麻煩，也可以這麼寫：

```c++
std::this_thread::sleep_for(100ms); // c++14裡可以這麼使用，這裡只是舉個自定義字面量使用的例子
std::this_thread::sleep_for(100s);
```

這就是自定義字面量的使用，示例如下：

```c++
struct mytype {
    unsigned long long value;
};
constexpr mytype operator"" _mytype ( unsigned long long n ) {
    return mytype{n};
}
mytype mm = 123_mytype;
cout << mm.value << endl;
```

關於自定義字面量，可以看下chrono的原始碼。

### 記憶體對齊

#### 什麼是記憶體對齊

理論上電腦對於任何變數的訪問都可以從任意位元元置開始，然而實際上系統會對這些變數的存放地址有限制，通常將變數首地址設為某個數N的倍數，這就是記憶體對齊。

#### 為什麼要記憶體對齊

1. 硬體平臺限制，記憶體以位元元組為單位元元，不同硬體平臺不一定支援任何記憶體地址的存取，一般可能以雙位元元組、4位元元組等為單位元元存取記憶體，為了保證處理器正確存取數據，需要進行記憶體對齊。
2. 提高CPU記憶體訪問速度，一般處理器的記憶體存取粒度都是N的整數倍，假如訪問N大小的數據，沒有進行記憶體對齊，有可能就需要兩次訪問才可以讀取出數據，而進行記憶體對齊可以一次性把數據全部讀取出來，提高效率。

在c++11之前如果想創建記憶體對齊需要：

```c++
void align_cpp11_before(){
    static char data[sizeof(void *) + sizeof(A)];
    const uintptr_t kAlign = sizeof(void *) - 1;
    char *align_ptr =
        reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(data + kAlign) & ~kAlign);
    A *attr = new (align_ptr) A;
}
```

c++11關於記憶體對齊新增了一些函式：

```c++
void align_cpp11_after()
{
    static std::aligned_storage<sizeof(A),
    alignof(A)>::type data;
    A *attr = new (&data) A;
}
```

還有：alignof()、std::alignment_of()、alignas()。

### thread_local

c++11引入thread_local，用thread_local修飾的變數具有thread週期，每一個執行緒都擁有並只擁有一個該變數的獨立實體，一般用於需要保證執行緒安全的函式中。

```c++
#include <iostream>
#include <thread>

class A {
    public:
    A() {}
    ~A() {}

    void test(const std::string &name) {
        thread_local int count = 0;
        ++count;
        std::cout << name << ": " << count << std::endl;
    }
};

void func(const std::string &name) {
    A a1;
    a1.test(name);
    a1.test(name);
    A a2;
    a2.test(name);
    a2.test(name);
}

int main() {
    std::thread(func, "thread1").join();
    std::thread(func, "thread2").join();
    return 0;
}
```

輸出：

```c++
thread1: 1
thread1: 2
thread1: 3
thread1: 4
thread2: 1
thread2: 2
thread2: 3
thread2: 4
```

驗證上述說法，對於一個執行緒私有變數，一個執行緒擁有且只擁有一個該實體，類似於static。

### 基礎數值型別

c++11新增了幾種數據型別：long long、char16_t、char32_t等

### 隨機數功能

c++11關於隨機數功能則較之前豐富了很多，典型的可以選擇概率分佈型別，先看如下程式碼：

```c++
#include <time.h>

#include <iostream>
#include <random>

using namespace std;

int main() {
    std::default_random_engine random(time(nullptr));

    std::uniform_int_distribution<int> int_dis(0, 100); // 整數均勻分佈
    std::uniform_real_distribution<float> real_dis(0.0, 1.0); // 浮點數均勻分佈

    for (int i = 0; i < 10; ++i) {
        cout << int_dis(random) << ' ';
    }
    cout << endl;

    for (int i = 0; i < 10; ++i) {
        cout << real_dis(random) << ' ';
    }
    cout << endl;

    return 0;
}
```

輸出：

```c++
38 100 93 7 66 0 68 99 41 7
0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863
```

程式碼中舉例的是整數均勻分佈和浮點數均勻分佈，c++11提供的概率分佈型別還有好多，例如伯努利分佈、正態分佈等，具體可以見最後的參考資料。

### 正則表達式

c++11引入了regex庫更好的支援正則表達式，見程式碼：

```c++
#include <iostream>
#include <iterator>
#include <regex>
#include <string>

int main() {
    std::string s = "I know, I'll use2 regular expressions.";
    // 忽略大小寫
    std::regex self_regex("REGULAR EXPRESSIONS", std::regex_constants::icase);
    if (std::regex_search(s, self_regex)) {
        std::cout << "Text contains the phrase 'regular expressions'\n";
    }

    std::regex word_regex("(\\w+)");  // 匹配字母數字等字符
    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);
    auto words_end = std::sregex_iterator();

    std::cout << "Found " << std::distance(words_begin, words_end) << " words\n";

    const int N = 6;
    std::cout << "Words longer than " << N << " characters:\n";
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() > N) {
            std::cout << " " << match_str << '\n';
        }
    }

    std::regex long_word_regex("(\\w{7,})");
    // 超過7個字符的單詞用[]包圍
    std::string new_s = std::regex_replace(s, long_word_regex, "[$&]");
    std::cout << new_s << '\n';
}
```

### chrono

c++11關於時間引入了chrono庫，源於boost，功能強大，chrono主要有三個點：

- duration
- time_point

- clocks

### duration

std::chrono::duration表示一段時間，常見的單位元元有s、ms等，示例程式碼：

```c++
// 拿休眠一段時間舉例，這裡表示休眠100ms
std::this_thread::sleep_for(std::chrono::milliseconds(100));
```

sleep_for裡面其實就是std::chrono::duration，表示一段時間，實際是這樣：

```c++
typedef duration<int64_t, milli> milliseconds;
typedef duration<int64_t> seconds;
```

duration具體樣板如下：

```c++
template <class Rep, class Period = ratio<1> > class duration;
```

Rep表示一種數值型別，用來表示Period的數量，比如int、float、double，Period是ratio型別，用來表示【用秒錶示的時間單位元元】比如second，常用的duration<Rep, Period>已經定義好了，在std::chrono::duration下：

- ratio<3600, 1>：hours
- ratio<60, 1>：minutes

- ratio<1, 1>：seconds
- ratio<1, 1000>：microseconds

- ratio<1, 1000000>：microseconds
- ratio<1, 1000000000>：nanosecons

ratio的具體樣板如下：

```c++
template <intmax_t N, intmax_t D = 1> class ratio;
```

N代表分子，D代表分母，所以ratio表示一個分數，可以自定義Period，比如ratio<2, 1>表示單位元元時間是2秒。

#### time_point

表示一個具體時間點，如2020年5月10日10點10分10秒，拿獲取當前時間舉例：

```c++
std::chrono::time_point<std::chrono::high_resolution_clock> Now() {
    return std::chrono::high_resolution_clock::now();
}
// std::chrono::high_resolution_clock為高精度時鐘，下面會提到
```

clocks

時鐘，chrono裡面提供了三種時鐘：

- steady_clock
- system_clock

- high_resolution_clock

#### steady_clock

穩定的時間間隔，表示相對時間，相對於系統開機啟動的時間，無論系統時間如何被更改，後一次調用now()肯定比前一次調用now()的數值大，可用於計時。

#### system_clock

表示當前的系統時鐘，可以用於獲取當前時間：

```c++
int main() {
    using std::chrono::system_clock;
    system_clock::time_point today = system_clock::now();

    std::time_t tt = system_clock::to_time_t(today);
    std::cout << "today is: " << ctime(&tt);

    return 0;
}
// today is: Sun May 10 09:48:36 2020
```

#### high_resolution_clock

high_resolution_clock表示系統可用的最高精度的時鐘，實際上就是system_clock或者steady_clock其中一種的定義，官方沒有說明具體是哪個，不同系統可能不一樣，看gcc chrono源碼中high_resolution_clock是steady_clock的typedef。

### 新增數據結構

- std::forward_list：單向鏈結串列，只可以前進，在特定場景下使用，相比於std::list節省了記憶體，提高了性能

```c++
std::forward_list<int> fl = {1, 2, 3, 4, 5};
for (const auto &elem : fl) {
    cout << elem;
}
```

- std::unordered_set：基於hash表實現的set，內部不會排序，使用方法和set類似
- std::unordered_map：基於hash表實現的map，內部不會排序，使用方法和set類似

- std::array：陣列，在越界訪問時拋出異常，建議使用std::array替代普通的陣列
- std::tuple：元組型別，類似pair，但比pair擴展性好

```c++
typedef std::tuple<int, double, int, double> Mytuple;
Mytuple t(0, 1, 2, 3);
std::cout << "0 " << std::get<0>(t);
std::cout << "1 " << std::get<1>(t);
std::cout << "2 " << std::get<2>(t);
std::cout << "3 " << std::get<3>(t);
```

### 新增演演算法

- all_of：檢測表達式是否對範圍[first, last)中所有元素都返回true，如果都滿足，則返回true

```c++
std::vector<int> v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
    std::cout << "All numbers are even\n";
}
```

- any_of：檢測表達式是否對範圍[first, last)中至少一個元素返回true，如果滿足，則返回true，否則返回false，用法和上面一樣
- none_of：檢測表達式是否對範圍[first, last)中所有元素都不返回true，如果都不滿足，則返回true，否則返回false，用法和上面一樣

- find_if_not：找到第一個不符合要求的元素疊代器，和find_if相反
- copy_if：複製滿足條件的元素

- itoa：對容器內的元素按序遞增

```c++
std::vector<int> l(10);
std::iota(l.begin(), l.end(), 19); // 19為初始值
for (auto n : l) std::cout << n << ' ';
// 19 20 21 22 23 24 25 26 27 28
```

- minmax_element：返回容器內最大元素和最小元素位元元置

```c++
int main() {
    std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};

    auto result = std::minmax_element(v.begin(), v.end());
    std::cout << "min element at: " << *(result.first) << '\n';
    std::cout << "max element at: " << *(result.second) << '\n';
    return 0;
}
// min element at: 1
// max element at: 9
```

- is_sorted、is_sorted_until：返回容器內元素是否已經排好序。
