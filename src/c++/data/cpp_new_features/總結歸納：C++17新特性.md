## 關鍵字

### constexpr

擴展constexpr使用範圍，可用於if語句中，也可用於lambda表達式中。

```c++
#include<iostream>
 
template<bool ok>
constexpr void foo()
{
    //在編譯期進行判斷，if和else語句不生成程式碼
    if constexpr (ok == true)
    {
        //當ok為true時，下面的else塊不生成彙編程式碼
        std::cout << "ok" << std::endl;
    }
    else
    {
        //當ok為false時，上面的if塊不生成彙編程式碼
        std::cout << "not ok" << std::endl;
    }
}
 
int main()
{
    foo<true>();//輸出ok，並且彙編程式碼中只有std::cout << "ok" << std::endl;這一句
    foo<false>();//輸出not ok，並且彙編程式碼中只有std::cout << "not ok" << std::endl;這一句
    return 0;
}
```

### static_assert

擴展static_assert用法，靜態斷言的顯示文本可選。

如：

```c++
static_assert(true, "");
static_assert(true);//c++17支援
```

### typename

擴展用法，允許出現在樣板的樣板的參數中。

首先回顧一下typename的用法，①用於樣板中，表示樣板參數為型別；②用於聲明某名字是變數名

如

```c++
struct A
{
    typedef int Example;
};
//第一種用法：聲明樣板參數為型別
template<typename T>
struct B { };
 
struct C
{
    typedef typename A::Example E;//第二種用法：聲明某名字為一種型別
};
 
int main()
{
    typename A::Example e;//第二種用法：聲明某名字為一種型別
    return 0;
}
```

新特性下的typename用法，

如：

```c++
#include<iostream>
#include<typeinfo>
 
template<typename T>
struct A
{
    int num;
    A()
    {
        std::cout << "A Construct" << std::endl;
        std::cout << "template typename is: " << typeid (T).name() << std::endl;
    }
};
//此處的T可省略，X代表樣板型別，T和X前的typename可替換成class
template<template<typename T> typename X>
struct B
{
    X<double> e;
    B() { std::cout << "B Construct" << std::endl; }
};
 
int main()
{
    A<B<A>> a;
    std::cout << "***************************" << std::endl;
    B<A> b;
    return 0;
}
```

### inline

Inline 變數, inline變數可以讓變數有多於一次的定義。C++17之前，我們定義全局變數， 總需要將變數定義在cpp檔案中，然後在通過extern關鍵字來告訴編譯器 這個變數已經在其他地方定義過了。 inline變數出現後，我們可以直接將全局變數定義在頭檔案中，而不用擔心出現redefine的錯誤資訊。

擴展用法，可用於定義內聯變數，功能與內聯函式相似。inline可避免函式或變數多重定義的問題，如果已定義相同的函式或變數（且該函式或變數聲明為inline），編譯器會自動連結到該函式或變數。

如（不發生錯誤）：

```c++
//  test.h
inline void print()
{
    std::cout << "hello world" << std::endl;
}
 
inline int num = 0;
//  func.h
include "test.h"
inline void add(int arg)
{
    num += arg;
    print();
}
//  main.cpp
include "func.h"
int main()
{
    num = 0;
    print();
    add(10);
    return 0;
}
```

### auto

從c++11開始，auto關鍵字能夠通過初始化器推導出變數的型別。在c++14中，auto關鍵字的能力進一步提升，能夠通過return語句推導出函式的返回型別。

使用auto關鍵字能夠提高編碼效率，同時能夠簡化重構流程。但是，C++11中的auto推導，往往結果與預期的不同。

c++11 中為了支援統一初始化，引入了新的統一初始化語法，如下所示。

```c++
// c++11
auto x3{ 1, 2 }; // std::initializer_list<int>
auto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>
auto x5{ 3 };    // std::initializer_list<int>
```

這三種方式初始化的變數，最終型別推導的結果都是 std::initializer_list ， 而不是我們認為的int。 這是因為

當用於auto聲明變數的表達式是{}括起來的，推導的型別就會變成 std::initializer_list。

在C++17中，對auto表達式推導的規則進行了改變

```c++
// c++17
auto x3{ 1, 2 }; // error: not a single element
auto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>
auto x5{ 3 };    // decltype(x5) is int
```

對比發現， auto x5{3}, 會直接將變數推導成 x5， 而 x3{1, 2} 這種方式也會編譯失敗。auto推導的規則變得更加直觀。

## 語法

### lambda表達式

lambda也是c++11中引入的，在C++11中，lambda表達式只能用捕獲this，this是當前物件的一個只讀的參照。

在C++17中，可以捕獲this, this是當前物件的一個複製，捕獲當前物件的複製，能夠確保當前物件釋放後，

lambda表達式能安全的調用this中的變數和方法。

### 條件表達式中支援初始化語句

c++17中支援在 if 或者switch 語句中進行初始化， 這個能力的出現能夠讓程式碼更加的簡潔。

```c++
// c++17之前
map<int, string> c = { {1,"a"}};
{
    auto res = c.insert(make_pair(2, "b"));
    if(!res.second) {
	    cout << "key 1 exist" << endl;
    } else {
	    cout << "insert success, value:" << res.first->second << endl;
    }
}
```

上面的一段程式碼，由於res是一個臨時變數，不想影響到後面的程式碼，所以用一對花括號限制了其作用域。但是如果使用c++17的語法，

在if條件中初始化res，則程式碼就會顯得更加簡潔

```c++
// c++17
map<int, string> c = { {1,"a"}};
if(auto res = c.insert(make_pair(2, "b")); !res.second ) {
	cout << "key 1 exist" << endl;
} else {
	cout << "insert success, value:" << res.first->second << endl;
}
```

### 摺疊表達式

用於變長參數樣板的解包，只支援各種運算子（和操作符），分左、右摺疊

如：
```c++
#include<string>
 
template<typename ... T>
auto sum(T ... arg)
{
    return (arg + ...);//右摺疊
}
 
template<typename ... T>
double sum_strong(T ... arg)
{
    return (arg + ... + 0);//右摺疊
}
 
template<typename ... T>
double sub1(T ... arg)
{
    return (arg - ...);//右摺疊
}
 
template<typename ... T>
double sub2(T ... arg)
{
    return (... - arg);//左摺疊
}
 
int main()
{
    int s1 = sum(1, 2, 2, 4, 5);//解包：((((1+)2+)3+)4+)5 = 15
    double s2 = sum(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
    double s3 = sum(1, 2.2, 3, 4.4, 5);
 
    double s4 = sub1(5, 2, 1, 1);//解包：((((5-)2-)1-)1) = 1
    double s5 = sub2(5, 2, 1, 1);//解包：(5-(2-(1-(1)))) = 3
 
    double s6 = sum_strong();//s6 = 0
 
    std::string str1("he");
    std::string str2("ll");
    std::string str3("o ");
    std::string str4("world");
    std::string str5 = sum(str1, str2, str3, str4);//str5 = "hello world"
    return 0;
}
```

### 結構化綁定

用一對包含一個或多個變數的中括號，表示結構化綁定，但是使用結構化綁定時，須用auto關鍵字，即綁定時聲明變數

例子：

```c++
/*
 * 例子：多值返回
 */
struct S
{
    double num1;
    long num2;
};
 
S foo(int arg1, double arg2)
{
    double result1 = arg1 * arg2;
    long result2 = arg2 / arg1;
    return {result1, result2};//返回結構S物件
};
 
int main()
{
    auto [num1, num2] = foo(10, 20.2);//自動推導num1為double，num2為long
    return 0;
}
```

### 允許非型別樣板參數進行常數計算

非型別樣板參數可傳入類的靜態成員

如：

```c++
class MyClass
{
public:
    static int a;
};
 
template<int *arg>
void foo() {}
 
int main()
{
    foo<&MyClass::a>();
    return 0;
}
```

### 條件分支語句初始化

在if和switch中可進行初始化

如：

```c++
template<long value>
void foo(int &ok)
{
    if constexpr (ok = 10; value > 0)
    {
 
    }
}
 
int main()
{
    int num = 0;
    if(int i = 0; i == 0)
    {
 
    }
    foo<10>(num);
    switch(int k = 10; k)
    {
        case 0:break;
        case 1:break;
        default:break;
    }
    return 0;
}
``` 

### 聚合初始化

在初始化物件時，可用花括號進行對其成員進行賦值

如：

```c++
struct MyStruct1
{
    int a;
    int b;
};
 
struct MyStruct2
{
    int a;
    MyStruct1 ms;
};
 
int main()
{
    MyStruct1 a{10};
    MyStruct2 b{10, 20};
    MyStruct2 c{1, {}};
    MyStruct2 d{ {}, {}};
    MyStruct2 e{ {}, {1, 2}};
    return 0;
}
```

### 嵌套命名空間

簡化多層命名空間的寫法

如：

```c++
//傳統寫法
namespace A
{
    namespace B
    {
        namespace C
        {
 
        };
    };
};
//新寫法
namespace A::B::C
{
 
};
```

### lambda表達式捕獲*this的值

lambda表達式可捕獲*this的值，但this及其成員為只讀

如：

```c++
struct MyStruct {
    double ohseven = 100.7;
    auto f() {
        return [this] {
            return [*this] {
                this->ohseven = 200.2;//錯誤，只讀變數不可賦值
                return ohseven;//正確
            };
        }();
    }
    auto g() {
        return []{
            return [*this]{};//錯誤，外層lambda表達式沒有捕獲this
        }();
    }
};
```

### 列舉[類]物件的建構

可以給列舉[類]物件賦值

如：

```c++
enum MyEnum { value };
MyEnum me {10};//錯誤：不能用int右值初始化MyEnum型別物件
 
enum byte : unsigned char { };
byte b { 42 }; //正確
byte c = { 42 }; //錯誤：不能用int右值初始化byte型別物件
byte d = byte{ 42 }; //正確，其值與b相等
byte e { -1 }; //錯誤：常數表達式-1不能縮小範圍為byte型別
 
struct A { byte b; };
A a1 = { { 42 } }; //錯誤：不能用int右值初始化byte型別物件
A a2 = { byte{ 42 } }; //正確
 
void f(byte);
f({ 42 }); //錯誤：無型別說明符
 
enum class Handle : unsigned int { value = 0 };
Handle h { 42 }; //正確
```

### 十六進制單精度浮點數字面值

以0x前綴開頭的十六進制數，以f後綴的單精度浮點數，合併，就有了十六進制的單精度浮點數

如：

```c++
int main()
{
    float value = 0x1111f;
    return 0;
}
```

### 基於對齊記憶體的動態記憶體分配

談到動態記憶體分配，少不了new和delete運算子，新標準中的new和delete運算子新增了按照對齊記憶體值來分配、釋放記憶體空間的功能（即一個新的帶對齊記憶體值的new、delete運算子多載）

函式原型：

```c++
void* operator new(std::size_t size, std::align_val_t alignment);
void* operator new[](std::size_t size, std::align_val_t alignment);
void operator delete(void*, std::size_t size, std::align_val_t alignment);
```

### 細化表達式的計算順序

為了支援泛型編程和多載運算子的廣泛使用，新特性將計算順序進行的細化

如以下爭議程式碼段：

```c++
#include<map>
 
int main()
{
    std::map<int, int> tmp;
    //對於std::map的[]運算子多載函式，在使用[]新增key時，std::map就已經插入了一個新的鍵值對
    tmp[0] = tmp.size();//此處不知道插入的是{0, 0}還是{0, 1}
    return 0;
}
```

為了解決該情況，新計算順序規則為：

1. 後綴表達式從左到右求值。這包括函式調用和成員選擇表達式。
2. 賦值表達式從右向左求值。這包括複合賦值。
3. 從左到右計算移位元元操作符的操作數。

### 樣板類的樣板參數自動推導

定義樣板類的物件時，可以不指定樣板參數，但必須要在建構函式中能推導出樣板參數

如：

```c++
template<class T> struct A {
    explicit A(const T&, ...) noexcept {} // #1
    A(T&&, ...){} // #2
};
 
int i;
 
A a1 = { i, i }; //錯誤，不能根據#1推導為右值參照，也不能通過#1實現複製初始化
A a2{i, i}; //正確，調用#1初始化成功，a2推導為A<int>型別
A a3{0, i}; //正確，調用#2初始化成功，a2推導為A<int>型別
A a4 = {0, i}; //正確，調用#2初始化成功，a2推導為A<int>型別
 
template<class T> A(const T&, const T&) -> A<T&>; // #3
template<class T> explicit A(T&&, T&&) -> A<T>; // #4
 
A a5 = {0, 1}; //錯誤，#1和#2建構函式結果相同（即衝突）。根據#3推導為A<int&>型別
A a6{0, 1}; //正確，通過#2推斷為A<int>型別
A a7 = {0, i}; //錯誤，不能將非靜態左值參照綁定到右值。根據#3推導為A<int&>型別
A a8{0, i}; //錯誤，不能將非靜態左值參照綁定到右值。根據#3推導為A<int&>型別
 
template<class T> 
struct B {
 
    template<class U> 
    using TA = T;//定義別名
 
    template<class U> 
    B(U, TA<U>);//建構函式
};
 
B b{(int*)0, (char*)0}; //正確，推導為B<char *>型別
```

### 簡化重複命名空間的屬性列表

如：

```c++
[[ using CC: opt(1), debug ]] void f() {}
//作用相同於 [[ CC::opt(1), CC::debug ]] void f() {}
```

### 不支援、非標準的屬性

在添加屬性列表時，編譯器會忽略不支援的非標準的屬性，不會發出警告和錯誤。

### 改寫與繼承建構函式

在類的繼承體系中，建構函式的自動調用是一個令人頭疼的問題。新特性引入繼承與改寫建構函式的用法。

例：

```c++
#include<iostream>
 
struct B1
{
    B1(int) { std::cout << "B1" << std::endl; }
};
 
struct D1 : B1 {
    using B1::B1;//表示繼承B1的建構函式
};
 
D1 d1(0);    //正確，委託基類建構函式進行初始化，調用B1::B1(int)
```

## 巨集

### __has_include

判斷有沒有包含某檔案

如：

```c++
int main()
{
#if __has_include(<cstdio>)
    printf("hehe");
#endif
#if __has_include("iostream")
    std::cout << "hehe" << std::endl;
#endif
return 0;
}
```

## 屬性

### fallthrough

用於switch語句塊內，表示會執行下一個case或default

如：

```cpp
int main()
{
    int ok1, ok2;
    switch (0)
    {
        case 0:
        ok1 = 0;
        [[fallthrough]];
        case 1:
        ok2 = 1;
        [[fallthrough]];
    }
    return 0;
}
```

### nodiscard

可用於類聲明、函式聲明、列舉聲明中，表示函式的回傳值沒有被接收，在編譯時會出現警告。

如：

```cpp
[[nodiscard]] class A {}; //該屬性在這其實沒用
[[nodiscard]] enum class B {}; //該屬性在這其實沒用
class C {};
 
[[nodiscard]] int foo()
{ return 10; }
 
[[nodiscard]] A func1() { return A(); }
[[nodiscard]] B func2() { return B(); }
[[nodiscard]] C func3() { return C(); }
 
int main()
{
    foo();//warning: ignoring return value
    func1();//warning: ignoring return value
    func2();//warning: ignoring return value
    func3();//warning: ignoring return value
    return 0;
}
```

### maybe_unused

可用於類、typedef、變數、非靜態數據成員、函式、列舉或列舉值中。用於抑制編譯器對沒用實體的警告。即加上該屬性後，對某一實體不會發出“沒有用”的警告。

用法例子：

```cpp
[[maybe_unused]] class A {};
[[maybe_unused]] enum B {};
[[maybe_unused]] int C;
[[maybe_unused]] void fun();
```

## 數據型別

c++17的標準庫也進行了擴充， 新增了下面幾種數據型別：

### std::variant

std::variant是型別安全的聯合，是一個加強版的 union，variant支援更加複雜的數據型別，例如map，string等等

### std::optional

std::optional表示一個可能存在的值。 當我們通過函式創建一個物件時，通常使用通過函式返回錯誤碼，而通過出參返回物件本身。

如果通過optional返回創建的實體，就會變得更加直觀，

std::optional 提供了下面幾個方法：

has_value() // 檢查物件是否有值 value() // 返回物件的值，值不存在時則拋出 std::bad_optional_access 異常 value_or() // 值存在時回傳值，不存在時返回預設值

### std::any

一個型別安全的可以保存任何值的容器

### std::string_view

string_view我最早使用的是boost版本的，c++17中的string_view 和 boost類似。

string_view可以理解成原始字串一個只讀參照。 string_view 本身沒有申請額外的記憶體來存儲原始字串的data，

僅僅保存了原始字串地址和長度等資訊。 在很多情況下，我們只是臨時處理字串，本不需要對原始字串的一份複製。

使用string_view可以減少不必要的記憶體複製，可以提高程式性能。相比使用字串指標，string_view做了更好的封裝。

需要注意的是，string_view 由於沒有原始字串的所有權，使用string_view 一定要注意原始字串的生命週期。

當原始的字串已經銷燬，則不能再調用string_view。
