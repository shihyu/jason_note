# C++ 教程

![img](https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png)

C++ 是一種中級語言，它是由 Bjarne Stroustrup 於 1979 年在貝爾實驗室開始設計開發的。C++ 進一步擴充和完善了 C 語言，是一種面向物件的程式設計語言。C++ 可運行於多種平臺上，如 Windows、MAC 作業系統以及 UNIX 的各種版本。

本教程通過通俗易懂的語言來講解 C++ 編程語言。

**現在開始學習 C++ 編程！**

 

## 誰適合閱讀本教程？

本教程是專門為初學者打造的，幫助他們理解與 C++ 編程語言相關的基礎到高級的概念。

## 閱讀本教程前，您需要了解的知識：

在您開始練習本教程中所給出的各種實體之前，您需要對電腦程式和電腦程式設計語言有基本的瞭解。

## 編譯/執行 C++ 程式

## 實體

```cpp
#include <iostream>using namespace std;int main(){
    cout << "Hello, world!" << endl;    return 0;
}
```

運行結果：

```cpp
Hello, world!
```

你可以用 "\n" 代替以上程式碼裡的 "endl"。

# C++ 簡介

C++ 是一種靜態型別的、編譯式的、通用的、大小寫敏感的、不規則的編程語言，支援過程化編程、面向物件編程和泛型編程。

C++ 被認為是一種**中級**語言，它綜合了高級語言和低級語言的特點。

C++ 是由 Bjarne Stroustrup 於 1979 年在新澤西州美利山貝爾實驗室開始設計開發的。C++ 進一步擴充和完善了 C 語言，最初命名為帶類的C，後來在 1983 年更名為 C++。

C++ 是 C 的一個超集，事實上，任何合法的 C 程式都是合法的 C++ 程式。

**注意：**使用靜態型別的編程語言是在編譯時執行型別檢查，而不是在運行時執行型別檢查。

## 面向物件程式設計

C++ 完全支援面向物件的程式設計，包括面向物件開發的四大特性：

- 封裝
- 抽象
- 繼承
- 多型

## 標準庫

標準的 C++ 由三個重要部分組成：

- 核心語言，提供了所有構件塊，包括變數、數據型別和常數，等等。
- C++ 標準庫，提供了大量的函式，用於操作檔案、字串等。
- 標準樣板庫（STL），提供了大量的方法，用於操作數據結構等。

## ANSI 標準

ANSI 標準是為了確保 C++ 的便攜性 —— 您所編寫的程式碼在 Mac、UNIX、Windows、Alpha 電腦上都能通過編譯。

由於 ANSI 標準已穩定使用了很長的時間，所有主要的 C++ 編譯器的製造商都支援 ANSI 標準。

## 學習 C++

學習 C++，關鍵是要理解概念，而不應過於深究語言的技術細節。

學習程式設計語言的目的是為了成為一個更好的程式員，也就是說，是為了能更有效率地設計和實現新系統，以及維護舊系統。

C++ 支援多種編程風格。您可以使用 Fortran、C、Smalltalk 等任意一種語言的編程風格來編寫程式碼。每種風格都能有效地保證運行時間效率和空間效率。

## C++ 的使用

基本上每個應用程式領域的程式員都有使用 C++。

C++ 通常用於編寫設備驅動程式和其他要求實時性的直接操作硬體的軟體。

C++ 廣泛用於教學和研究。

任何一個使用蘋果電腦或 Windows PC 機的用戶都在間接地使用 C++，因為這些系統的主要用戶介面是使用 C++ 編寫的。

------

## 標準化

| 發佈時間 | 文件                  | 通稱   | 備註                |      |
| :------- | :-------------------- | :----- | :------------------ | :--- |
| 2015     | ISO/IEC TS 19570:2015 | -      | 用於並行計算的擴展  |      |
| 2015     | ISO/IEC TS 18822:2015 | -      | 檔案系統            |      |
| 2014     | ISO/IEC 14882:2014    | C++14  | 第四個C++標準       |      |
| 2011     | ISO/IEC TR 24733:2011 | -      | 十進制浮點數擴展    |      |
| 2011     | ISO/IEC 14882:2011    | C++11  | 第三個C++標準       |      |
| 2010     | ISO/IEC TR 29124:2010 | -      | 數學函式擴展        |      |
| 2007     | ISO/IEC TR 19768:2007 | C++TR1 | C++技術報告：庫擴展 |      |
| 2006     | ISO/IEC TR 18015:2006 | -      | C++性能技術報告     |      |
| 2003     | ISO/IEC 14882:2003    | C++03  | 第二個C++標準       |      |
| 1998     | ISO/IEC 14882:1998    | C++98  | 第一個C++標準       |      |

# C++ 環境設置

## 本地環境設置

如果您想要設置 C++ 語言環境，您需要確保電腦上有以下兩款可用的軟體，文本編輯器和 C++ 編譯器。

## 文本編輯器

這將用於輸入您的程式。文本編輯器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。

文本編輯器的名稱和版本在不同的作業系統上可能會有所不同。例如，Notepad 通常用於 Windows 作業系統上，vim/vi 可用於 Windows 和 Linux/UNIX 作業系統上。

通過編輯器創建的檔案通常稱為原始檔，原始檔包含程式原始碼。C++ 程式的原始檔通常使用擴展名 .cpp、.cp 或 .c。

在開始編程之前，請確保您有一個文本編輯器，且有足夠的經驗來編寫一個電腦程式，然後把它保存在一個檔案中，編譯並執行它。

## C++ 編譯器

寫在原始檔中的原始碼是人類可讀的源。它需要"編譯"，轉為機器語言，這樣 CPU 可以按給定指令執行程式。

C++ 編譯器用於把原始碼編譯成最終的可執行程式。

大多數的 C++ 編譯器並不在乎原始檔的擴展名，但是如果您未指定擴展名，則預設使用 .cpp。

最常用的免費可用的編譯器是 GNU 的 C/C++ 編譯器，如果您使用的是 HP 或 Solaris，則可以使用各自作業系統上的編譯器。

以下部分將指導您如何在不同的作業系統上安裝 GNU 的 C/C++ 編譯器。這裡同時提到 C/C++，主要是因為 GNU 的 gcc 編譯器適合於 C 和 C++ 編程語言。

## 安裝 GNU 的 C/C++ 編譯器

### UNIX/Linux 上的安裝

如果您使用的是 **Linux 或 UNIX**，請在命令行使用下面的命令來檢查您的系統上是否安裝了 GCC：

```cpp
$ g++ -v
```

如果您的電腦上已經安裝了 GNU 編譯器，則會顯示如下消息：

```cpp
Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
```

如果未安裝 GCC，那麼請按照 http://gcc.gnu.org/install/ 上的詳細說明安裝 GCC。

### Mac OS X 上的安裝

如果您使用的是 Mac OS X，最快捷的獲取 GCC 的方法是從蘋果的網站上下載 Xcode 開發環境，並按照安裝說明進行安裝。一旦安裝上 Xcode，您就能使用 GNU 編譯器。

Xcode 目前可從 developer.apple.com/technologies/tools/ 上下載。

### Windows 上的安裝

為了在 Windows 上安裝 GCC，您需要安裝 MinGW。為了安裝 MinGW，請訪問 MinGW 的主頁 www.mingw.org，進入 MinGW 下載頁面，下載最新版本的 MinGW 安裝程式，命名格式為 MinGW-<version>.exe。

當安裝 MinGW 時，您至少要安裝 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情況下都會安裝更多其他的項。

添加您安裝的 MinGW 的 bin 子目錄到您的 **PATH** 環境變數中，這樣您就可以在命令行中通過簡單的名稱來指定這些工具。

當完成安裝時，您可以從 Windows 命令行上運行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。

------

## 使用 Visual Studio (Graphical Interface) 編譯

1、下載及安裝 Visual Studio Community 2015。

2、打開 Visual Studio Community

3、點擊 File -> New -> Project

![img](https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png)

4、左側列表選擇 Templates -> Visual C++ -> Win32 Console Application，並設置專案名為 MyFirstProgram。

![img](https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png)

 

5、點擊 OK。

6、在以下窗口中點擊 Next

![img](https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png)

7、在彈出的窗口中選擇 Empty project 選項後，點擊 Finish 按鈕：

8、右擊檔案夾 Source File 並點擊 Add --> New Item... :

![img](https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png)

9、選擇 C++ File 然後設置檔案名為 main.cpp，然後點擊 Add：

![img](https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png)

 

10、複製以下程式碼到 main.cpp 中：

```cpp
#include <iostream>int main(){
    std::cout << "Hello World!\n";
    return 0;}
```

界面如下所示：

![img](https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png)

11、點擊選單上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :

![img](https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png)

12、完成以上操作後，你可以看到以下輸出：

![img](https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png)

------

## g++ 應用說明

程式 g++ 是將 gcc 預設語言設為 C++ 的一個特殊的版本，連結時它自動使用 C++ 標準庫而不用 C 標準庫。通過遵循源碼的命名規範並指定對應庫的名字，用 gcc 來編譯連結 C++ 程式是可行的，如下例所示：

```cpp
$ gcc main.cpp -lstdc++ -o main
```

下面是一個保存在檔案 helloworld.cpp 中一個簡單的 C++ 程式的程式碼：

```cpp
#include <iostream>using namespace std;int main(){
    cout << "Hello, world!" << endl;
    return 0;}
```

最簡單的編譯方式：

```cpp
$ g++ helloworld.cpp
```

由於命令行中未指定可執行程式的檔案名，編譯器採用預設的 a.out。程式可以這樣來運行：

```cpp
$ ./a.outHello, world!
```

通常我們使用 **-o** 選項指定可執行程式的檔案名，以下實體生成一個 helloworld 的可執行檔案：

```cpp
$ g++ helloworld.cpp -o helloworld
```

執行 helloworld:

```cpp
$ ./helloworldHello, world!
```

如果是多個 C++ 程式碼檔案，如 runoob1.cpp、runoob2.cpp，編譯命令如下：

```cpp
$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob
```

生成一個 runoob 可執行檔案。

g++ 有些系統預設是使用 C++98，我們可以指定使用 C++11 來編譯 main.cpp 檔案：

```cpp
g++ -g -Wall -std=c++11 main.cpp
```

### g++ 常用命令選項

| 選項         | 解釋                                                         |
| :----------- | :----------------------------------------------------------- |
| -ansi        | 只支援 ANSI 標準的 C 語法。這一選項將禁止 GNU C 的某些特色， 例如 asm 或 typeof 關鍵詞。 |
| -c           | 只編譯並生成目標檔案。                                       |
| -DMACRO      | 以字串"1"定義 MACRO 巨集。                                   |
| -DMACRO=DEFN | 以字串"DEFN"定義 MACRO 巨集。                                |
| -E           | 只運行 C 預編譯器。                                          |
| -g           | 生成除錯資訊。GNU 除錯器可利用該資訊。                       |
| -IDIRECTORY  | 指定額外的頭檔案搜尋路徑DIRECTORY。                          |
| -LDIRECTORY  | 指定額外的函式庫搜尋路徑DIRECTORY。                          |
| -lLIBRARY    | 連接時搜尋指定的函式庫LIBRARY。                              |
| -m486        | 針對 486 進行程式碼最佳化。                                      |
| -o           | FILE 生成指定的輸出檔案。用在生成可執行檔案時。              |
| -O0          | 不進行最佳化處理。                                             |
| -O           | 或 -O1 最佳化生成程式碼。                                        |
| -O2          | 進一步最佳化。                                                 |
| -O3          | 比 -O2 更進一步最佳化，包括 inline 函式。                      |
| -shared      | 生成共享目標檔案。通常用在建立共享庫時。                     |
| -static      | 禁止使用共享連接。                                           |
| -UMACRO      | 取消對 MACRO 巨集的定義。                                      |
| -w           | 不生成任何警告資訊。                                         |
| -Wall        | 生成所有警告資訊。                                           |

# C++ 基本語法

C++ 程式可以定義為物件的集合，這些物件通過調用彼此的方法進行交互。現在讓我們簡要地看一下什麼是類、物件，方法、即時變數。

- **物件 -** 物件具有狀態和行為。例如：一隻狗的狀態 - 顏色、名稱、品種，行為 - 搖動、叫喚、吃。物件是類的實體。
- **類 -** 類可以定義為描述物件行為/狀態的樣板/藍圖。
- **方法 -** 從基本上說，一個方法表示一種行為。一個類可以包含多個方法。可以在方法中寫入邏輯、操作數據以及執行所有的動作。
- **即時變數 -** 每個物件都有其獨特的即時變數。物件的狀態是由這些即時變數的值創建的。

## C++ 程式結構

讓我們看一段簡單的程式碼，可以輸出單詞 *Hello World*。

## 實體

```cpp
#include <iostream>using namespace std; // main() 是程式開始執行的地方 
	int main(){   
	cout << "Hello World"; // 輸出 Hello World   return 0;
	}
```

接下來我們講解一下上面這段程式：

- C++ 語言定義了一些頭檔案，這些頭檔案包含了程式中必需的或有用的資訊。上面這段程式中，包含了頭檔案 **<iostream>**。
- 行 **using namespace std;** 告訴編譯器使用 std 命名空間。命名空間是 C++ 中一個相對新的概念。
- 下一行 **// main() 是程式開始執行的地方** 是一個單行註釋。單行註釋以 // 開頭，在行末結束。
- 下一行 **int main()** 是主函式，程式從這裡開始執行。
- 下一行 **cout << "Hello World";** 會在螢幕上顯示消息 "Hello World"。
- 下一行 **return 0;** 終止 main( )函式，並向調用行程回傳值 0。

## 編譯 & 執行 C++ 程式

接下來讓我們看看如何把原始碼保存在一個檔案中，以及如何編譯並運行它。下面是簡單的步驟：

- 打開一個文本編輯器，添加上述程式碼。
- 保存檔案為 hello.cpp。
- 打開命令提示符，進入到保存檔案所在的目錄。
- 鍵入 'g++ hello.cpp '，輸入回車，編譯程式碼。如果程式碼中沒有錯誤，命令提示符會跳到下一行，並生成 a.out 可執行檔案。
- 現在，鍵入 ' a.out' 來運行程式。
- 您可以看到螢幕上顯示 ' Hello World '。

```cpp
$ g++ hello.cpp$ ./a.outHello World
```

請確保您的路徑中已包含 g++ 編譯器，並確保在包含原始檔 hello.cpp 的目錄中運行它。

您也可以使用 makefile 來編譯 C/C++ 程式。

## C++ 中的分號 & 塊

在 C++ 中，分號是語句結束符。也就是說，每個語句必須以分號結束。它表明一個邏輯實體的結束。

例如，下面是三個不同的語句：

```cpp
x = y;y = y+1;add(x, y);
```

塊是一組使用大括號括起來的按邏輯連接的語句。例如：

```cpp
{   cout << "Hello World"; // 輸出 Hello World   return 0;}
```

C++ 不以行末作為結束符的標識，因此，您可以在一行上放置多個語句。例如：

```cpp
x = y;y = y+1;add(x, y);
```

等同於

```cpp
x = y; y = y+1; add(x, y);
```

## C++ 標識符

C++ 標識符是用來標識變數、函式、類、模組，或任何其他用戶自定義專案的名稱。一個標識符以字母 A-Z 或 a-z 或下劃線 _ 開始，後跟零個或多個字母、下劃線和數字（0-9）。

C++ 標識符內不允許出現標點字符，比如 @、$ 和 %。C++ 是區分大小寫的編程語言。因此，在 C++ 中，**Manpower** 和 **manpower** 是兩個不同的標識符。

下面列出幾個有效的標識符：

```cpp
mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal
```

## C++ 關鍵字

下表列出了 C++ 中的保留字。這些保留字不能作為常數名、變數名或其他標識符名稱。

| asm          | else      | new              | this     |
| ------------ | --------- | ---------------- | -------- |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |

 

## 三字符組

三字符組就是用於表示另一個字符的三個字符序列，又稱為三字符序列。三字符序列總是以兩個問號開頭。

三字符序列不太常見，但 C++ 標準允許把某些字符指定為三字符序列。以前為了表示鍵盤上沒有的字符，這是必不可少的一種方法。

三字符序列可以出現在任何地方，包括字串、字符序列、註釋和預處理指令。

下面列出了最常用的三字符序列：

| 三字符組 | 替換 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

如果希望在源程式中有兩個連續的問號，且不希望被預處理器替換，這種情況出現在字符常數、字串字面值或者是程式註釋中，可選辦法是用字串的自動連接："...?""?..."或者轉義序列："...?\?..."。

從Microsoft Visual C++ 2010版開始，該編譯器預設不再自動替換三字符組。如果需要使用三字符組替換（如為了兼容古老的軟體程式碼），需要設置編譯器命令行選項/Zc:trigraphs

g++仍預設支援三字符組，但會給出編譯警告。

## C++ 中的空格

只包含空格的行，被稱為空白行，可能帶有註釋，C++ 編譯器會完全忽略它。

在 C++ 中，空格用於描述空白符、製表符、換行符和註釋。空格分隔語句的各個部分，讓編譯器能識別語句中的某個元素（比如 int）在哪裡結束，下一個元素在哪裡開始。因此，在下面的語句中：

```cpp
int age;
```

在這裡，int 和 age 之間必須至少有一個空格字符（通常是一個空白符），這樣編譯器才能夠區分它們。另一方面，在下面的語句中：

```cpp
fruit = apples + oranges;   // 獲取水果的總數
```

fruit 和 =，或者 = 和 apples 之間的空格字符不是必需的，但是為了增強可讀性，您可以根據需要適當增加一些空格。

# C++ 註釋

程式的註釋是解釋性語句，您可以在 C++ 程式碼中包含註釋，這將提高原始碼的可讀性。所有的編程語言都允許某種形式的註釋。

C++ 支援單行註釋和多行註釋。註釋中的所有字符會被 C++ 編譯器忽略。

C++ 註釋以 /* 開始，以 */ 終止。例如：

```cpp
/* 這是註釋 *//* C++ 註釋也可以
 * 跨行
 */
```

註釋也能以 // 開始，直到行末為止。例如：

```cpp
#include <iostream>using namespace std;main(){
   cout << "Hello World"; // 輸出 Hello World

   return 0;}
```

當上面的程式碼被編譯時，編譯器會忽略 **// 輸出 Hello World**，最後會產生以下結果：

```cpp
Hello World
```

在 /* 和 */ 註釋內部，// 字符沒有特殊的含義。在 // 註釋內，/* 和 */ 字符也沒有特殊的含義。因此，您可以在一種註釋內嵌套另一種註釋。例如：

```
 
/* 用於輸出 Hello World 的註釋

cout << "Hello World"; // 輸出 Hello World

*/
```

# C++ 數據型別

使用編程語言進行編程時，需要用到各種變數來存儲各種資訊。變數保留的是它所存儲的值的記憶體位元元置。這意味著，當您創建一個變數時，就會在記憶體中保留一些空間。

您可能需要存儲各種數據型別（比如字符型、寬字符型、整型、浮點型、雙浮點型、布爾型等）的資訊，作業系統會根據變數的數據型別，來分配記憶體和決定在保留記憶體中存儲什麼。

## 基本的內置型別

C++ 為程式員提供了種類豐富的內置數據型別和用戶自定義的數據型別。下表列出了七種基本的 C++ 數據型別：

| 型別     | 關鍵字  |
| :------- | :------ |
| 布爾型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮點型   | float   |
| 雙浮點型 | double  |
| 無型別   | void    |
| 寬字符型 | wchar_t |

一些基本型別可以使用一個或多個型別修飾符進行修飾：

- signed
- unsigned
- short
- long

下表顯示了各種變數型別在記憶體中存儲值時需要佔用的記憶體，以及該型別的變數所能存儲的最大值和最小值。

| 型別               | 位元元            | 範圍                                                    |
| :----------------- | :------------ | :------------------------------------------------------ |
| char               | 1 個位元元組      | -128 到 127 或者 0 到 255                               |
| unsigned char      | 1 個位元元組      | 0 到 255                                                |
| signed char        | 1 個位元元組      | -128 到 127                                             |
| int                | 4 個位元元組      | -2147483648 到 2147483647                               |
| unsigned int       | 4 個位元元組      | 0 到 4294967295                                         |
| signed int         | 4 個位元元組      | -2147483648 到 2147483647                               |
| short int          | 2 個位元元組      | -32768 到 32767                                         |
| unsigned short int | 2 個位元元組      | 0 到 65,535                                             |
| signed short int   | 2 個位元元組      | -32768 到 32767                                         |
| long int           | 8 個位元元組      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| signed long int    | 8 個位元元組      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| unsigned long int  | 8 個位元元組      | 0 to 18,446,744,073,709,551,615                         |
| float              | 4 個位元元組      | +/- 3.4e +/- 38 (~7 個數字)                             |
| double             | 8 個位元元組      | +/- 1.7e +/- 308 (~15 個數字)                           |
| long double        | 8 個位元元組      | +/- 1.7e +/- 308 (~15 個數字)                           |
| wchar_t            | 2 或 4 個位元元組 | 1 個寬字符                                              |

從上表可得知，變數的大小會根據編譯器和所使用的電腦而有所不同。

下面實體會輸出您電腦上各種數據型別的大小。

```cpp
#include <iostream>using namespace std;int main(){   
	cout << "Size of char : " << sizeof(char) << endl;   
	cout << "Size of int : " << sizeof(int) << endl;  
	cout << "Size of short int : " << sizeof(short int) << endl;  
	cout << "Size of long int : " << sizeof(long int) << endl;   
	cout << "Size of float : " << sizeof(float) << endl;   
	cout << "Size of double : " << sizeof(double) << endl;  
	cout << "Size of wchar_t : " << sizeof(wchar_t) << endl;   return 0;
}
```

本實體使用了 **endl**，這將在每一行後插入一個換行符，<< 運算子用於向螢幕傳多個值。我們也使用 **sizeof()** 函式來獲取各種數據型別的大小。

當上面的程式碼被編譯和執行時，它會產生以下的結果，結果會根據所使用的電腦而有所不同：

```cpp
Size of char : 1Size of int : 4Size of short int : 2Size of long int : 8Size of float : 4Size of double : 8Size of wchar_t : 4
```

## typedef 聲明

您可以使用 **typedef** 為一個已有的型別取一個新的名字。下面是使用 typedef 定義一個新型別的語法：

```cpp
typedef type newname;
```

例如，下面的語句會告訴編譯器，feet 是 int 的另一個名稱：

```cpp
typedef int feet;
```

現在，下面的聲明是完全合法的，它創建了一個整型變數 distance：

```cpp
feet distance;
```

## 列舉型別

列舉型別(enumeration)是C++中的一種派生數據型別，它是由用戶定義的若干列舉常數的集合。

如果一個變數只有幾種可能的值，可以定義為列舉(enumeration)型別。所謂"列舉"是指將變數的值一一列舉出來，變數的值只能在列舉出來的值的範圍內。

創建列舉，需要使用關鍵字 **enum**。列舉型別的一般形式為：

```cpp
enum enum-name { list of names } var-list;
```

在這裡，enum-name 是列舉型別的名稱。名稱列表 { list of names } 是用逗號分隔的。

例如，下面的程式碼定義了一個顏色列舉，變數 c 的型別為 color。最後，c 被賦值為 "blue"。

```cpp
enum color { red, green, blue } c;c = blue;
```

預設情況下，第一個名稱的值為 0，第二個名稱的值為 1，第三個名稱的值為 2，以此類推。但是，您也可以給名稱賦予一個特殊的值，只需要添加一個初始值即可。例如，在下面的列舉中，**green** 的值為 5。

```cpp
enum color { red, green=5, blue };
```

在這裡，**blue** 的值為 6，因為預設情況下，每個名稱都會比它前面一個名稱大 1。

# C++ 變數型別

變數其實只不過是程式可操作的存儲區的名稱。C++ 中每個變數都有指定的型別，型別決定了變數存儲的大小和佈局，該範圍內的值都可以存儲在記憶體中，運算子可應用於變數上。

變數的名稱可以由字母、數字和下劃線字符組成。它必須以字母或下劃線開頭。大寫字母和小寫字母是不同的，因為 C++ 是大小寫敏感的。

基於前一章講解的基本型別，有以下幾種基本的變數型別，將在下一章中進行講解：

| 型別    | 描述                                               |
| :------ | :------------------------------------------------- |
| bool    | 存儲值 true 或 false。                             |
| char    | 通常是一個八位元元位元元組（一個位元元組）。這是一個整數型別。 |
| int     | 對機器而言，整數的最自然的大小。                   |
| float   | 單精度浮點值。                                     |
| double  | 雙精度浮點值。                                     |
| void    | 表示型別的缺失。                                   |
| wchar_t | 寬字符型別。                                       |

C++ 也允許定義各種其他型別的變數，比如**列舉、指標、陣列、參照、數據結構、類**等等，這將會在後續的章節中進行講解。

下面我們將講解如何定義、聲明和使用各種型別的變數。

## C++ 中的變數定義

變數定義就是告訴編譯器在何處創建變數的存儲，以及如何創建變數的存儲。變數定義指定一個數據型別，幷包含了該型別的一個或多個變數的列表，如下所示：

```cpp
type variable_list;
```

在這裡，**type** 必須是一個有效的 C++ 數據型別，可以是 char、wchar_t、int、float、double、bool 或任何用戶自定義的物件，**variable_list** 可以由一個或多個標識符名稱組成，多個標識符之間用逗號分隔。下面列出幾個有效的聲明：

```cpp
int    i, j, k;char   c, ch;float  f, salary;double d;
```

行 **int i, j, k;** 聲明並定義了變數 i、j 和 k，這指示編譯器創建型別為 int 的名為 i、j、k 的變數。

變數可以在聲明的時候被初始化（指定一個初始值）。初始化器由一個等號，後跟一個常數表達式組成，如下所示：

```cpp
type variable_name = value;
```

下面列舉幾個實體：

```cpp
extern int d = 3, f = 5;   
	// d 和 f 的聲明 int d = 3, f = 5;          
	// 定義並初始化 d 和 fbyte z = 22;               
	// 定義並初始化 zchar x = 'x';              
	// 變數 x 的值為 'x'
```

不帶初始化的定義：帶有靜態存儲持續時間的變數會被隱式初始化為 NULL（所有位元元組的值都是 0），其他所有變數的初始值是未定義的。

## C++ 中的變數聲明

變數聲明向編譯器保證變數以給定的型別和名稱存在，這樣編譯器在不需要知道變數完整細節的情況下也能繼續進一步的編譯。變數聲明只在編譯時有它的意義，在程式連接時編譯器需要實際的變數聲明。

當您使用多個檔案且只在其中一個檔案中定義變數時（定義變數的檔案在程式連接時是可用的），變數聲明就顯得非常有用。您可以使用 **extern** 關鍵字在任何地方聲明一個變數。雖然您可以在 C++ 程式中多次聲明一個變數，但變數只能在某個檔案、函式或程式碼塊中被定義一次。

## 實體

嘗試下面的實體，其中，變數在頭部就已經被聲明，但它們是在主函式內被定義和初始化的：

```cpp
#include <iostream>using namespace std;// 變數聲明extern int a, b;extern int c;extern float f;
  int main (){
  // 變數定義
  int a, b;
  int c;
  float f;
 
  // 實際初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;

  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
3023.3333
```

同樣的，在函式聲明時，提供一個函式名，而函式的實際定義則可以在任何地方進行。例如：

```cpp
// 函式聲明int func();int main(){
    // 函式調用
    int i = func();}// 函式定義int func(){
    return 0;}
```

## C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有兩種型別的表達式：

- **左值（lvalue）：**指向記憶體位元元置的表達式被稱為左值（lvalue）表達式。左值可以出現在賦值號的左邊或右邊。
- **右值（rvalue）：**術語右值（rvalue）指的是存儲在記憶體中某些地址的數值。右值是不能對其進行賦值的表達式，也就是說，右值可以出現在賦值號的右邊，但不能出現在賦值號的左邊。

變數是左值，因此可以出現在賦值號的左邊。數值型的字面值是右值，因此不能被賦值，不能出現在賦值號的左邊。下面是一個有效的語句：

```cpp
int g = 20;
```

但是下面這個就不是一個有效的語句，會生成編譯時錯誤：

```cpp
10 = 20;
```

# C++ 變數作用域

作用域是程式的一個區域，一般來說有三個地方可以聲明變數：

- 在函式或一個程式碼塊內部聲明的變數，稱為局部變數。
- 在函式參數的定義中聲明的變數，稱為形式參數。
- 在所有函式外部聲明的變數，稱為全局變數。

我們將在後續的章節中學習什麼是函式和參數。本章我們先來講解聲明是局部變數和全局變數。

## 局部變數

在函式或一個程式碼塊內部聲明的變數，稱為局部變數。它們只能被函式內部或者程式碼塊內部的語句使用。下面的實體使用了局部變數：

```cpp
#include <iostream>using namespace std;
 int main (){
  // 局部變數聲明
  int a, b;
  int c;
 
  // 實際初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;}
```

## 全局變數

在所有函式外部定義的變數（通常是在程式的頭部），稱為全局變數。全局變數的值在程式的整個生命週期內都是有效的。

全局變數可以被任何函式訪問。也就是說，全局變數一旦聲明，在整個程式中都是可用的。下面的實體使用了全局變數和局部變數：

```cpp
#include <iostream>using namespace std;
 // 全局變數聲明int g;
 int main (){
  // 局部變數聲明
  int a, b;
 
  // 實際初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;}
```

在程式中，局部變數和全局變數的名稱可以相同，但是在函式內，局部變數的值會覆蓋全局變數的值。下面是一個實體：

```cpp
#include <iostream>using namespace std;
 // 全局變數聲明int g = 20;
 int main (){
  // 局部變數聲明
  int g = 10;
 
  cout << g;
 
  return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
10
```

## 初始化局部變數和全局變數

當局部變數被定義時，系統不會對其初始化，您必須自行對其初始化。定義全局變數時，系統會自動初始化為下列值：

| 數據型別 | 初始化預設值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正確地初始化變數是一個良好的編程習慣，否則有時候程式可能會產生意想不到的結果。

# C++ 常數

常數是固定值，在程式執行期間不會改變。這些固定的值，又叫做**字面量**。

常數可以是任何的基本數據型別，可分為整型數字、浮點數字、字符、字串和布爾值。

常數就像是常規的變數，只不過常數的值在定義後不能進行修改。

## 整數常數

整數常數可以是十進制、八進制或十六進制的常數。前綴指定基數：0x 或 0X 表示十六進制，0 表示八進制，不帶前綴則預設表示十進制。

整數常數也可以帶一個後綴，後綴是 U 和 L 的組合，U 表示無符號整數（unsigned），L 表示長整數（long）。後綴可以是大寫，也可以是小寫，U 和 L 的順序任意。

下面列舉幾個整數常數的實體：

```cpp
212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八進制的數字032UU       // 非法的：不能重複後綴
```

以下是各種型別的整數常數的實體：

```cpp
85         // 十進制0213       // 八進制 0x4b       // 十六進制 30         // 整數 30u        // 無符號整數 30l        // 長整數 30ul       // 無符號長整數
```

## 浮點常數

浮點常數由整數部分、小數點、小數部分和指數部分組成。您可以使用小數形式或者指數形式來表示浮點常數。

當使用小數形式表示時，必須包含整數部分、小數部分，或同時包含兩者。當使用指數形式表示時， 必須包含小數點、指數，或同時包含兩者。帶符號的指數是用 e 或 E 引入的。

下面列舉幾個浮點常數的實體：

```cpp
3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指數210f          // 非法的：沒有小數或指數.e55          // 非法的：缺少整數或分數
```

## 布爾常數

布爾常數共有兩個，它們都是標準的 C++ 關鍵字：

- **true** 值代表真。
- **false** 值代表假。

我們不應把 true 的值看成 1，把 false 的值看成 0。

## 字符常數

字符常數是括在單引號中。如果常數以 L（僅當大寫時）開頭，則表示它是一個寬字符常數（例如 L'x'），此時它必須存儲在 **wchar_t** 型別的變數中。否則，它就是一個窄字符常數（例如 'x'），此時它可以存儲在 **char** 型別的簡單變數中。

字符常數可以是一個普通的字符（例如 'x'）、一個轉義序列（例如 '\t'），或一個通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，當它們前面有反斜槓時，它們就具有特殊的含義，被用來表示如換行符（\n）或製表符（\t）等。下表列出了一些這樣的轉義序列碼：

| 轉義序列   | 含義                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警報鈴聲                   |
| \b         | 退格鍵                     |
| \f         | 換頁符                     |
| \n         | 換行符                     |
| \r         | 回車                       |
| \t         | 水平製表符                 |
| \v         | 垂直製表符                 |
| \ooo       | 一到三位元元的八進制數         |
| \xhh . . . | 一個或多個數字的十六進制數 |

下面的實體顯示了一些轉義序列字符：

```cpp
#include <iostream>using namespace std;int main(){   cout << "Hello\tWorld\n\n";   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Hello   World
```

## 字串常數

字串字面值或常數是括在雙引號 "" 中的。一個字串包含類似於字符常數的字符：普通的字符、轉義序列和通用的字符。

您可以使用空格做分隔符，把一個很長的字串常數進行分行。

下面的實體顯示了一些字串常數。下面這三種形式所顯示的字串是相同的。

```cpp
"quot;hello, dear""hello, \dear""hello, " "d" "ear"
```

## 定義常數

在 C++ 中，有兩種簡單的定義常數的方式：

- 使用 **#define** 預處理器。
- 使用 **const** 關鍵字。

## #define 預處理器

下面是使用 #define 預處理器定義常數的形式：

```cpp
#define identifier value
```

具體請看下面的實體：

```cpp
#include <iostream>using namespace std;#define LENGTH 10   #define WIDTH  5#define NEWLINE '\n'int main(){

   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
50
```

## const 關鍵字

您可以使用 **const** 前綴聲明指定型別的常數，如下所示：

```cpp
const type variable = value;
```

具體請看下面的實體：

```cpp
#include <iostream>using namespace std;int main(){
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
50
```

請注意，把常數定義為大寫字母形式，是一個很好的編程實踐。

# C++ 修飾符型別

C++ 允許在 **char、int 和 double** 數據型別前放置修飾符。修飾符用於改變基本型別的含義，所以它更能滿足各種情境的需求。

下面列出了數據型別修飾符：

- signed
- unsigned
- long
- short

修飾符 **signed、unsigned、long 和 short** 可應用於整型，**signed** 和 **unsigned** 可應用於字符型，**long** 可應用於雙精度型。

修飾符 **signed** 和 **unsigned** 也可以作為 **long** 或 **short** 修飾符的前綴。例如：**unsigned long int**。

C++ 允許使用速記符號來聲明**無符號短整數**或**無符號長整數**。您可以不寫 int，只寫單詞 **unsigned、short** 或 **unsigned、long**，int 是隱含的。例如，下面的兩個語句都聲明瞭無符號整型變數。

```cpp
unsigned x;
unsigned int y;
```

為了理解 C++ 解釋有符號整數和無符號整數修飾符之間的差別，我們來運行一下下面這個短程式：

```cpp
#include <iostream>
using namespace std;
 
/* 
 * 這個程式演示了有符號整數和無符號整數之間的差別
*/
int main()
{
   short int i;           // 有符號短整數
   short unsigned int j;  // 無符號短整數

   j = 50000;

   i = j;
   cout << i << " " << j;

   return 0;
}
```

當上面的程式運行時，會輸出下列結果：

```cpp
-15536 50000
```

上述結果中，無符號短整數 50,000 的位元元模式被解釋為有符號短整數 -15,536。

## C++ 中的型別限定符

型別限定符提供了變數的額外資訊。

| 限定符   | 含義                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 型別的物件在程式執行期間不能被修改改變。           |
| volatile | 修飾符 **volatile** 告訴編譯器，變數的值可能以程式未明確指定的方式被改變。 |
| restrict | 由 **restrict** 修飾的指標是唯一一種訪問它所指向的物件的方式。只有 C99 增加了新的型別限定符 restrict。 |

# C++ 存儲類

存儲類定義 C++ 程式中變數/函式的範圍（可見性）和生命週期。這些說明符放置在它們所修飾的型別之前。下面列出 C++ 程式中可用的存儲類：

- auto
- register
- static
- extern
- mutable
- thread_local (C++11)

從 C++ 11 開始，auto 關鍵字不再是 C++ 存儲類說明符，且 register 關鍵字被棄用。

## auto 存儲類

自 C++ 11 以來，**auto** 關鍵字用於兩種情況：聲明變數時根據初始化表達式自動推斷該變數的型別、聲明函式時函式回傳值的佔位元元符。

C++98標準中auto關鍵字用於自動變數的聲明，但由於使用極少且多餘，在C++11中已刪除這一用法。

根據初始化表達式自動推斷被聲明的變數的型別，如：

auto f=3.14;    //doubleauto s("hello");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//錯誤，必須是初始化為同一型別

## register 存儲類

**register** 存儲類用於定義存儲在寄存器中而不是 RAM 中的局部變數。這意味著變數的最大尺寸等於寄存器的大小（通常是一個詞），且不能對它應用一元的 '&' 運算子（因為它沒有記憶體位元元置）。

{  register int miles;}

寄存器只用於需要快速訪問的變數，比如計數器。還應注意的是，定義 'register' 並不意味著變數將被存儲在寄存器中，它意味著變數可能存儲在寄存器中，這取決於硬體和實現的限制。

## static 存儲類

**static** 存儲類指示編譯器在程式的生命週期內保持局部變數的存在，而不需要在每次它進入和離開作用域時進行創建和銷燬。因此，使用 static 修飾局部變數可以在函式調用之間保持局部變數的值。

static 修飾符也可以應用於全局變數。當 static 修飾全局變數時，會使變數的作用域限制在聲明它的檔案內。

在 C++ 中，當 static 用在類數據成員上時，會導致僅有一個該成員的副本被類的所有物件共享。

## 實體

```cpp
#include <iostream>
 // 函式聲明 void func(void); 
static int count = 10; /* 全局變數 */
 int main(){
    while(count--)
    {
       func();    }
    return 0;}// 函式定義void func( void ){
    static int i = 5; // 局部靜態變數
    i++;    std::cout << "變數 i 為 " << i ;    std::cout << " , 變數 count 為 " << count << std::endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
變數 i 為 6 , 變數 count 為 9變數 i 為 7 , 變數 count 為 8變數 i 為 8 , 變數 count 為 7變數 i 為 9 , 變數 count 為 6變數 i 為 10 , 變數 count 為 5變數 i 為 11 , 變數 count 為 4變數 i 為 12 , 變數 count 為 3變數 i 為 13 , 變數 count 為 2變數 i 為 14 , 變數 count 為 1變數 i 為 15 , 變數 count 為 0
```

## extern 存儲類

**extern** 存儲類用於提供一個全局變數的參照，全局變數對所有的程式檔案都是可見的。當您使用 'extern' 時，對於無法初始化的變數，會把變數名指向一個之前定義過的存儲位元元置。

當您有多個檔案且定義了一個可以在其他檔案中使用的全局變數或函式時，可以在其他檔案中使用 *extern* 來得到已定義的變數或函式的參照。可以這麼理解，*extern* 是用來在另一個檔案中聲明一個全局變數或函式。

extern 修飾符通常用於當有兩個或多個檔案共享相同的全局變數或函式的時候，如下所示：

第一個檔案：main.cpp

## 實體

```cpp
#include <iostream>
 int count ;extern void write_extern(); 
int main(){
   count = 5;   write_extern();}
```

第二個檔案：support.cpp

## 實體

```cpp
#include <iostream>
 extern int count; 
void write_extern(void){
   std::cout << "Count is " << count << std::endl;}
```

在這裡，第二個檔案中的 *extern* 關鍵字用於聲明已經在第一個檔案 main.cpp 中定義的 count。現在 ，編譯這兩個檔案，如下所示：

```cpp
$ g++ main.cpp support.cpp -o write
```

這會產生 **write** 可執行程式，嘗試執行 **write**，它會產生下列結果：

```cpp
$ ./writeCount is 5
```

## mutable 存儲類

**mutable** 說明符僅適用於類的物件，這將在本教程的最後進行講解。它允許物件的成員替代常數。也就是說，mutable 成員可以通過 const 成員函式修改。

## thread_local 存儲類

使用 thread_local 說明符聲明的變數僅可在它在其上創建的執行緒上訪問。 變數在創建執行緒時創建，並在銷燬執行緒時銷燬。 每個執行緒都有其自己的變數副本。

thread_local 說明符可以與 static 或 extern 合併。

可以將 thread_local 僅應用於數據聲明和定義，thread_local 不能用於函式聲明或定義。

以下演示了可以被聲明為 thread_local 的變數：

```cpp
thread_local int x;  // 命名空間下的全局變數class X{
    static thread_local std::string s; // 類的static成員變數};static thread_local std::string X::s;  // X::s 是需要定義的
 void foo(){
    thread_local std::vector<int> v;  // 本地變數}
```

# C++ 運算子

運算子是一種告訴編譯器執行特定的數學或邏輯操作的符號。C++ 內置了豐富的運算子，並提供了以下型別的運算子：

- 算術運算子
- 關係運算子
- 邏輯運算子
- 位元元運算子
- 賦值運算子
- 雜項運算子

本章將逐一介紹算術運算子、關係運算子、邏輯運算子、位元元運算子、賦值運算子和其他運算子。

## 算術運算子

下表顯示了 C++ 支援的算術運算子。

假設變數 A 的值為 10，變數 B 的值為 20，則：

| 運算子 | 描述                                                         | 實體             |
| :----- | :----------------------------------------------------------- | :--------------- |
| +      | 把兩個操作數相加                                             | A + B 將得到 30  |
| -      | 從第一個操作數中減去第二個操作數                             | A - B 將得到 -10 |
| *      | 把兩個操作數相乘                                             | A * B 將得到 200 |
| /      | 分子除以分母                                                 | B / A 將得到 2   |
| %      | 取模運算子，整除後的餘數                                     | B % A 將得到 0   |
| ++     | [自增運算子](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整數值增加 1 | A++ 將得到 11    |
| --     | [自減運算子](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整數值減少 1 | A-- 將得到 9     |

### 實體

請看下面的實體，瞭解 C++ 中可用的算術運算子。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int b = 10;   int c ; 
   c = a + b;   cout << "Line 1 - c 的值是 " << c << endl ;   c = a - b;   cout << "Line 2 - c 的值是 " << c << endl ;   c = a * b;   cout << "Line 3 - c 的值是 " << c << endl ;   c = a / b;   cout << "Line 4 - c 的值是 " << c << endl ;   c = a % b;   cout << "Line 5 - c 的值是 " << c << endl ; 
   int d = 10;   //  測試自增、自減
   c = d++;   cout << "Line 6 - c 的值是 " << c << endl ; 
   d = 10;    // 重新賦值
   c = d--;   cout << "Line 7 - c 的值是 " << c << endl ;   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10Line 7 - c 的值是 10
```

## 關係運算子

下表顯示了 C++ 支援的關係運算子。

假設變數 A 的值為 10，變數 B 的值為 20，則：

| 運算子 | 描述                                                         | 實體              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 檢查兩個操作數的值是否相等，如果相等則條件為真。             | (A == B) 不為真。 |
| !=     | 檢查兩個操作數的值是否相等，如果不相等則條件為真。           | (A != B) 為真。   |
| >      | 檢查左操作數的值是否大於右操作數的值，如果是則條件為真。     | (A > B) 不為真。  |
| <      | 檢查左操作數的值是否小於右操作數的值，如果是則條件為真。     | (A < B) 為真。    |
| >=     | 檢查左操作數的值是否大於或等於右操作數的值，如果是則條件為真。 | (A >= B) 不為真。 |
| <=     | 檢查左操作數的值是否小於或等於右操作數的值，如果是則條件為真。 | (A <= B) 為真。   |

### 實體

請看下面的實體，瞭解 C++ 中可用的關係運算子。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int b = 10;   int c ; 
   if( a == b )
   {
      cout << "Line 1 - a 等於 b" << endl ;   }
   else
   {
      cout << "Line 1 - a 不等於 b" << endl ;   }
   if ( a < b )
   {
      cout << "Line 2 - a 小於 b" << endl ;   }
   else
   {
      cout << "Line 2 - a 不小於 b" << endl ;   }
   if ( a > b )
   {
      cout << "Line 3 - a 大於 b" << endl ;   }
   else
   {
      cout << "Line 3 - a 不大於 b" << endl ;   }
   /* 改變 a 和 b 的值 */
   a = 5;   b = 20;   if ( a <= b )
   {
      cout << "Line 4 - a 小於或等於 b" << endl ;   }
   if ( b >= a )
   {
      cout << "Line 5 - b 大於或等於 a" << endl ;   }
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - a 不等於 bLine 2 - a 不小於 bLine 3 - a 大於 bLine 4 - a 小於或等於 bLine 5 - b 大於或等於 a
```

## 邏輯運算子

下表顯示了 C++ 支援的關係邏輯運算子。

假設變數 A 的值為 1，變數 B 的值為 0，則：

| 運算子 | 描述                                                         | 實體              |
| :----- | :----------------------------------------------------------- | :---------------- |
| &&     | 稱為邏輯與運算子。如果兩個操作數都非零，則條件為真。         | (A && B) 為假。   |
| \|\|   | 稱為邏輯或運算子。如果兩個操作數中有任意一個非零，則條件為真。 | (A \|\| B) 為真。 |
| !      | 稱為邏輯非運算子。用來逆轉操作數的邏輯狀態。如果條件為真則邏輯非運算子將使其為假。 | !(A && B) 為真。  |

### 實體

請看下面的實體，瞭解 C++ 中可用的邏輯運算子。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 5;   int b = 20;   int c ; 
   if ( a && b )
   {
      cout << "Line 1 - 條件為真"<< endl ;   }
   if ( a || b )
   {
      cout << "Line 2 - 條件為真"<< endl ;   }
   /* 改變 a 和 b 的值 */
   a = 0;   b = 10;   if ( a && b )
   {
      cout << "Line 3 - 條件為真"<< endl ;   }
   else
   {
      cout << "Line 4 - 條件不為真"<< endl ;   }
   if ( !(a && b) )
   {
      cout << "Line 5 - 條件為真"<< endl ;   }
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - 條件為真Line 2 - 條件為真Line 4 - 條件不為真Line 5 - 條件為真
```

## 位元元運算子

位元元運算子作用於位元元，並逐位元元執行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假設如果 A = 60，且 B = 13，現在以二進制格式表示，它們如下所示：

A = 0011 1100

B = 0000 1101

\-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011

下表顯示了 C++ 支援的位元元運算子。假設變數 A 的值為 60，變數 B 的值為 13，則：

| 運算子 | 描述                                                         | 實體                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 如果同時存在於兩個操作數中，二進制 AND 運算子複製一位元元到結果中。 | (A & B) 將得到 12，即為 0000 1100                            |
| \|     | 如果存在於任一操作數中，二進制 OR 運算子複製一位元元到結果中。   | (A \| B) 將得到 61，即為 0011 1101                           |
| ^      | 如果存在於其中一個操作數中但不同時存在於兩個操作數中，二進制異或運算子複製一位元元到結果中。 | (A ^ B) 將得到 49，即為 0011 0001                            |
| ~      | 二進制補碼運算子是一元運算子，具有"翻轉"位元元效果，即0變成1，1變成0。 | (~A ) 將得到 -61，即為 1100 0011，一個有符號二進制數的補碼形式。 |
| <<     | 二進制左移運算子。左操作數的值向左移動右操作數指定的位元元數。   | A << 2 將得到 240，即為 1111 0000                            |
| >>     | 二進制右移運算子。左操作數的值向右移動右操作數指定的位元元數。   | A >> 2 將得到 15，即為 0000 1111                             |

### 實體

請看下面的實體，瞭解 C++ 中可用的位元元運算子。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   unsigned int a = 60;      // 60 = 0011 1100  
   unsigned int b = 13;      // 13 = 0000 1101
   int c = 0;           
 
   c = a & b;             // 12 = 0000 1100
   cout << "Line 1 - c 的值是 " << c << endl ; 
   c = a | b;             // 61 = 0011 1101
   cout << "Line 2 - c 的值是 " << c << endl ; 
   c = a ^ b;             // 49 = 0011 0001
   cout << "Line 3 - c 的值是 " << c << endl ; 
   c = ~a;                // -61 = 1100 0011
   cout << "Line 4 - c 的值是 " << c << endl ; 
   c = a << 2;            // 240 = 1111 0000
   cout << "Line 5 - c 的值是 " << c << endl ; 
   c = a >> 2;            // 15 = 0000 1111
   cout << "Line 6 - c 的值是 " << c << endl ; 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```
 
Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15
```

## 賦值運算子

下表列出了 C++ 支援的賦值運算子：

| 運算子 | 描述                                                         | 實體                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 簡單的賦值運算子，把右邊操作數的值賦給左邊操作數             | C = A + B 將把 A + B 的值賦給 C |
| +=     | 加且賦值運算子，把右邊操作數加上左邊操作數的結果賦值給左邊操作數 | C += A 相當於 C = C + A         |
| -=     | 減且賦值運算子，把左邊操作數減去右邊操作數的結果賦值給左邊操作數 | C -= A 相當於 C = C - A         |
| *=     | 乘且賦值運算子，把右邊操作數乘以左邊操作數的結果賦值給左邊操作數 | C *= A 相當於 C = C * A         |
| /=     | 除且賦值運算子，把左邊操作數除以右邊操作數的結果賦值給左邊操作數 | C /= A 相當於 C = C / A         |
| %=     | 求模且賦值運算子，求兩個操作數的模賦值給左邊操作數           | C %= A 相當於 C = C % A         |
| <<=    | 左移且賦值運算子                                             | C <<= 2 等同於 C = C << 2       |
| >>=    | 右移且賦值運算子                                             | C >>= 2 等同於 C = C >> 2       |
| &=     | 按位元元與且賦值運算子                                           | C &= 2 等同於 C = C & 2         |
| ^=     | 按位元元異或且賦值運算子                                         | C ^= 2 等同於 C = C ^ 2         |
| \|=    | 按位元元或且賦值運算子                                           | C \|= 2 等同於 C = C \| 2       |

### 實體

請看下面的實體，瞭解 C++ 中可用的賦值運算子。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int c ; 
   c =  a;   cout << "Line 1 - =  運算子實體，c 的值 = : " <<c<< endl ; 
   c +=  a;   cout << "Line 2 - += 運算子實體，c 的值 = : " <<c<< endl ; 
   c -=  a;   cout << "Line 3 - -= 運算子實體，c 的值 = : " <<c<< endl ; 
   c *=  a;   cout << "Line 4 - *= 運算子實體，c 的值 = : " <<c<< endl ; 
   c /=  a;   cout << "Line 5 - /= 運算子實體，c 的值 = : " <<c<< endl ; 
   c  = 200;   c %=  a;   cout << "Line 6 - %= 運算子實體，c 的值 = : " <<c<< endl ; 
   c <<=  2;   cout << "Line 7 - <<= 運算子實體，c 的值 = : " <<c<< endl ; 
   c >>=  2;   cout << "Line 8 - >>= 運算子實體，c 的值 = : " <<c<< endl ; 
   c &=  2;   cout << "Line 9 - &= 運算子實體，c 的值 = : " <<c<< endl ; 
   c ^=  2;   cout << "Line 10 - ^= 運算子實體，c 的值 = : " <<c<< endl ; 
   c |=  2;   cout << "Line 11 - |= 運算子實體，c 的值 = : " <<c<< endl ; 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - =  運算子實體，c 的值 = 21Line 2 - += 運算子實體，c 的值 = 42Line 3 - -= 運算子實體，c 的值 = 21Line 4 - *= 運算子實體，c 的值 = 441Line 5 - /= 運算子實體，c 的值 = 21Line 6 - %= 運算子實體，c 的值 = 11Line 7 - <<= 運算子實體，c 的值 = 44Line 8 - >>= 運算子實體，c 的值 = 11Line 9 - &= 運算子實體，c 的值 = 2Line 10 - ^= 運算子實體，c 的值 = 0Line 11 - |= 運算子實體，c 的值 = 2
```

## 雜項運算子

下表列出了 C++ 支援的其他一些重要的運算子。

| 運算子               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 運算子](https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html)返回變數的大小。例如，sizeof(a) 將返回 4，其中 a 是整數。 |
| Condition ? X : Y    | [條件運算子](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 為真 ? 則值為 X : 否則值為 Y。 |
| ,                    | [逗號運算子](https://edu.aliyun.com/cplusplus/cpp-comma-operator.html)會順序執行一系列運算。整個逗號表達式的值是以逗號分隔的列表中的最後一個表達式的值。 |
| .（點）和 ->（箭頭） | [成員運算子](https://edu.aliyun.com/cplusplus/cpp-member-operators.html)用於參照類、結構和共用體的成員。 |
| Cast                 | [強制轉換運算子](https://edu.aliyun.com/cplusplus/cpp-casting-operators.html)把一種數據型別轉換為另一種數據型別。例如，int(2.2000) 將返回 2。 |
| &                    | [指標運算子 &](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 返回變數的地址。例如 &a; 將給出變數的實際地址。 |
| *                    | [指標運算子 *](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 指向一個變數。例如，*var; 將指向變數 var。 |

## C++ 中的運算子優先級

運算子的優先級確定表達式中項的組合。這會影響到一個表達式如何計算。某些運算子比其他運算子有更高的優先級，例如，乘除運算子具有比加減運算子更高的優先級。

例如 x = 7 + 3 * 2，在這裡，x 被賦值為 13，而不是 20，因為運算子 * 具有比 + 更高的優先級，所以首先計算乘法 3*2，然後再加上 7。

下表將按運算子優先級從高到低列出各個運算子，具有較高優先級的運算子出現在表格的上面，具有較低優先級的運算子出現在表格的下面。在表達式中，較高優先級的運算子會優先被計算。

| 類別       | 運算子                            | 結合性   |
| :--------- | :-------------------------------- | :------- |
| 後綴       | () [] -> . ++ - -                 | 從左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 從右到左 |
| 乘除       | * / %                             | 從左到右 |
| 加減       | + -                               | 從左到右 |
| 移位元元       | << >>                             | 從左到右 |
| 關係       | < <= > >=                         | 從左到右 |
| 相等       | == !=                             | 從左到右 |
| 位元元與 AND   | &                                 | 從左到右 |
| 位元元異或 XOR | ^                                 | 從左到右 |
| 位元元或 OR    | \|                                | 從左到右 |
| 邏輯與 AND | &&                                | 從左到右 |
| 邏輯或 OR  | \|\|                              | 從左到右 |
| 條件       | ?:                                | 從右到左 |
| 賦值       | = += -= *= /= %=>>= <<= &= ^= \|= | 從右到左 |
| 逗號       | ,                                 | 從左到右 |

### 實體

請看下面的實體，瞭解 C++ 中運算子的優先級。

複製並黏貼下面的 C++ 程式到 test.cpp 檔案中，編譯並運行程式。

對比有括號和沒有括號時的區別，這將產生不同的結果。因為 ()、 /、 * 和 + 有不同的優先級，高優先級的操作符將優先計算。

## 實體

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 20;   int b = 10;   int c = 15;   int d = 5;   int e; 
   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   cout << "(a + b) * c / d 的值是 " << e << endl ; 
   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   cout << "((a + b) * c) / d 的值是 " << e << endl ; 
   e = (a + b) * (c / d);   // (30) * (15/5)
   cout << "(a + b) * (c / d) 的值是 " << e << endl ; 
   e = a + (b * c) / d;     //  20 + (150/5)
   cout << "a + (b * c) / d 的值是 " << e << endl ;  
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生以下結果：

```cpp
(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50
```

# C++ 迴圈

有的時候，可能需要多次執行同一塊程式碼。一般情況下，語句是順序執行的：函式中的第一個語句先執行，接著是第二個語句，依此類推。

編程語言提供了允許更為複雜的執行路徑的多種控制結構。

迴圈語句允許我們多次執行一個語句或語句組，下面是大多數編程語言中迴圈語句的一般形式：

![img](https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png)

## 迴圈型別

C++ 編程語言提供了以下幾種迴圈型別。點擊連結查看每個型別的細節。

| 迴圈型別        | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| while 迴圈      | 當給定條件為真時，重複語句或語句組。它會在執行迴圈主體之前測試條件。 |
| for 迴圈        | 多次執行一個語句序列，簡化管理迴圈變數的程式碼。               |
| do...while 迴圈 | 除了它是在迴圈主體結尾測試條件外，其他與 while 語句類似。    |
| 嵌套迴圈        | 您可以在 while、for 或 do..while 迴圈內使用一個或多個迴圈。  |

 

## 迴圈控制語句

迴圈控制語句更改執行的正常序列。當執行離開一個範圍時，所有在該範圍中創建的自動物件都會被銷燬。

C++ 提供了下列的控制語句。點擊連結查看每個語句的細節。

| 控制語句      | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| break 語句    | 終止 **loop** 或 **switch** 語句，程式流將繼續執行緊接著 loop 或 switch 的下一條語句。 |
| continue 語句 | 引起迴圈跳過主體的剩餘部分，立即重新開始測試條件。           |
| goto 語句     | 將控制轉移到被標記的語句。但是不建議在程式中使用 goto 語句。 |

 

## 無限迴圈

如果條件永遠不為假，則迴圈將變成無限迴圈。**for** 迴圈在傳統意義上可用於實現無限迴圈。由於構成迴圈的三個表達式中任何一個都不是必需的，您可以將某些條件表達式留空來構成一個無限迴圈。

```cpp
#include <iostream>using namespace std;
 int main (){

   for( ; ; )
   {
      printf("This loop will run forever.\n");
   }

   return 0;}
```

當條件表達式不存在時，它被假設為真。您也可以設置一個初始值和增量表達式，但是一般情況下，C++ 程式員偏向於使用 for(;;) 結構來表示一個無限迴圈。

**注意：**您可以按 Ctrl + C 鍵終止一個無限迴圈。

# C++ 判斷

判斷結構要求程式員指定一個或多個要評估或測試的條件，以及條件為真時要執行的語句（必需的）和條件為假時要執行的語句（可選的）。

下面是大多數編程語言中典型的判斷結構的一般形式：

![img](https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png)

## 判斷語句

C++ 編程語言提供了以下型別的判斷語句。點擊連結查看每個語句的細節。

| 語句             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| if 語句          | 一個 **if 語句** 由一個布爾表達式後跟一個或多個語句組成。    |
| if...else 語句   | 一個 **if 語句** 後可跟一個可選的 **else 語句**，else 語句在布爾表達式為假時執行。 |
| 嵌套 if 語句     | 您可以在一個 **if** 或 **else if** 語句內使用另一個 **if** 或 **else if** 語句。 |
| switch 語句      | 一個 **switch** 語句允許測試一個變數等於多個值時的情況。     |
| 嵌套 switch 語句 | 您可以在一個 **switch** 語句內使用另一個 **switch** 語句。   |

 

## ? : 運算子

我們已經在前面的章節中講解了 [**條件運算子 ? :**](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)，可以用來替代 **if...else** 語句。它的一般形式如下：

```cpp
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表達式。請注意，冒號的使用和位元元置。

? 表達式的值是由 Exp1 決定的。如果 Exp1 為真，則計算 Exp2 的值，結果即為整個 ? 表達式的值。如果 Exp1 為假，則計算 Exp3 的值，結果即為整個 ? 表達式的值。

# C++ 函式

函式是一組一起執行一個任務的語句。每個 C++ 程式都至少有一個函式，即主函式 **main()** ，所有簡單的程式都可以定義其他額外的函式。

您可以把程式碼劃分到不同的函式中。如何劃分程式碼到不同的函式中是由您來決定的，但在邏輯上，劃分通常是根據每個函式執行一個特定的任務來進行的。

函式**聲明**告訴編譯器函式的名稱、返回型別和參數。函式**定義**提供了函式的實際主體。

C++ 標準庫提供了大量的程式可以調用的內置函式。例如，函式 **strcat()** 用來連接兩個字串，函式 **memcpy()** 用來複制記憶體到另一個位元元置。

函式還有很多叫法，比如方法、子例程或程式，等等。

## 定義函式

C++ 中的函式定義的一般形式如下：

```cpp
return_type function_name( parameter list ){   body of the function}
```

在 C++ 中，函式由一個函式頭和一個函式主體組成。下面列出一個函式的所有組成部分：

- **返回型別：**一個函式可以返回一個值。**return_type** 是函式返回的值的數據型別。有些函式執行所需的操作而不回傳值，在這種情況下，return_type 是關鍵字 **void**。
- **函式名稱：**這是函式的實際名稱。函式名和參數列表一起構成了函式簽名。
- **參數：**參數就像是佔位元元符。當函式被調用時，您向參數傳遞一個值，這個值被稱為實際參數。參數列表包括函式參數的型別、順序、數量。參數是可選的，也就是說，函式可能不包含參數。
- **函式主體：**函式主體包含一組定義函式執行任務的語句。

## 實體

以下是 **max()** 函式的原始碼。該函式有兩個參數 num1 和 num2，會返回這兩個數中較大的那個數：

```cpp
// 函式返回兩個數中較大的那個數 int max(int num1, int num2) {   // 局部變數聲明   int result;    if (num1 > num2)      result = num1;   else      result = num2;    return result; }
```

## 函式聲明

函式**聲明**會告訴編譯器函式名稱及如何調用函式。函式的實際主體可以單獨定義。

函式聲明包括以下幾個部分：

```cpp
return_type function_name( parameter list );
```

針對上面定義的函式 max()，以下是函式聲明：

```cpp
int max(int num1, int num2);
```

在函式聲明中，參數的名稱並不重要，只有參數的型別是必需的，因此下面也是有效的聲明：

```cpp
int max(int, int);
```

當您在一個原始檔中定義函式且在另一個檔案中調用函式時，函式聲明是必需的。在這種情況下，您應該在調用函式的檔案頂部聲明函式。

## 調用函式

創建 C++ 函式時，會定義函式做什麼，然後通過調用函式來完成已定義的任務。

當程式調用函式時，程式控制權會轉移給被調用的函式。被調用的函式執行已定義的任務，當函式的返回語句被執行時，或到達函式的結束括號時，會把程式控制權交還給主程式。

調用函式時，傳遞所需參數，如果函式返回一個值，則可以存儲回傳值。例如：

```cpp
#include <iostream>using namespace std;
 // 函式聲明int max(int num1, int num2);
 int main (){
   // 局部變數聲明
   int a = 100;
   int b = 200;
   int ret;
 
   // 調用函式來獲取最大值
   ret = max(a, b);
 
   cout << "Max value is : " << ret << endl;
 
   return 0;}
 // 函式返回兩個數中較大的那個數int max(int num1, int num2) {
   // 局部變數聲明
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; }
```

把 max() 函式和 main() 函式放一塊，編譯原始碼。當運行最後的可執行檔案時，會產生下列結果：

```cpp
Max value is : 200
```

## 函式參數

如果函式要使用參數，則必須聲明接受參數值的變數。這些變數稱為函式的**形式參數**。

形式參數就像函式內的其他局部變數，在進入函式時被創建，退出函式時被銷燬。

當調用函式時，有兩種向函式傳遞參數的方式：

| 調用型別                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [傳值調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html) | 該方法把參數的實際值複製給函式的形式參數。在這種情況下，修改函式內的形式參數對實際參數沒有影響。 |
| [指標調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html) | 該方法把參數的地址複製給形式參數。在函式內，該地址用於訪問調用中要用到的實際參數。這意味著，修改形式參數會影響實際參數。 |
| [參照調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html) | 該方法把參數的參照複製給形式參數。在函式內，該參照用於訪問調用中要用到的實際參數。這意味著，修改形式參數會影響實際參數。 |

預設情況下，C++ 使用**傳值調用**來傳遞參數。一般來說，這意味著函式內的程式碼不能改變用於調用函式的參數。之前提到的實體，調用 max() 函式時，使用了相同的方法。

## 參數的預設值

當您定義一個函式，您可以為參數列表中後邊的每一個參數指定預設值。當調用函式時，如果實際參數的值留空，則使用這個預設值。

這是通過在函式定義中使用賦值運算子來為參數賦值的。調用函式時，如果未傳遞參數的值，則會使用預設值，如果指定了值，則會忽略預設值，使用傳遞的值。請看下面的實體：

```cpp
#include <iostream>using namespace std;
 int sum(int a, int b=20){
  int result;

  result = a + b;
  
  return (result);}int main (){
   // 局部變數聲明
   int a = 100;
   int b = 200;
   int result;
 
   // 調用函式來添加值
   result = sum(a, b);
   cout << "Total value is :" << result << endl;

   // 再次調用函式
   result = sum(a);
   cout << "Total value is :" << result << endl;
 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Total value is :300Total value is :120
```

------

## Lambda 函式與表達式

C++11 提供了對匿名函式的支援,稱為 Lambda 函式(也叫 Lambda 表達式)。

Lambda 表達式把函式看作物件。Lambda 表達式可以像物件一樣使用，比如可以將它們賦給變數和作為參數傳遞，還可以像函式一樣對其求值。

Lambda 表達式本質上與函式聲明非常類似。Lambda 表達式具體形式如下:

```cpp
[capture](parameters)->return-type{body}
```

例如：

```
 
[](int x, int y){ return x < y ; }
```

如果沒有參數可以表示為：

```cpp
[capture](parameters){body}
```

例如：

```cpp
[]{ ++global_x; }
```

在一個更為複雜的例子中，返回型別可以被明確的指定如下：

```cpp
[](int x, int y) -> int { int z = x + y; return z + x; }
```

本例中，一個臨時的參數 z 被創建用來存儲中間結果。如同一般的函式，z 的值不會保留到下一次該不具名函式再次被調用時。

如果 lambda 函式沒有傳回值（例如 void），其回返型別可被完全忽略。

在Lambda表達式內可以訪問當前作用域的變數，這是Lambda表達式的閉包（Closure）行為。 與JavaScript閉包不同，C++變數傳遞有傳值和傳參照的區別。可以通過前面的[]來指定：

```cpp
[]      // 沒有定義任何變數。使用未定義變數會引發錯誤。[x, &y] // x以傳值方式傳入（預設），y以參照方式傳入。[&]     // 任何被使用到的外部變數都隱式地以參照方式加以參照。[=]     // 任何被使用到的外部變數都隱式地以傳值方式加以參照。[&, x]  // x顯式地以傳值方式加以參照。其餘變數以參照方式加以參照。[=, &z] // z顯式地以參照方式加以參照。其餘變數以傳值方式加以參照。
```

另外有一點需要注意。對於[=]或[&]的形式，lambda 表達式可以直接使用 this 指標。但是，對於[]的形式，如果要使用 this 指標，必須顯式傳入：

```cpp
[this]() { this->someFunc(); }();
```

# C++ 數字

通常，當我們需要用到數字時，我們會使用原始的數據型別，如 int、short、long、float 和 double 等等。這些用於數字的數據型別，其可能的值和數值範圍，我們已經在 C++ 數據型別一章中討論過。

## C++ 定義數字

我們已經在之前章節的各種實體中定義過數字。下面是一個 C++ 中定義各種型別數字的綜合實體：

```cpp
#include <iostream>using namespace std;
 int main (){
   // 數字定義
   short  s;
   int    i;
   long   l;
   float  f;
   double d;
   
   // 數字賦值
   s = 10;      
   i = 1000;    
   l = 1000000; 
   f = 230.47;  
   d = 30949.374;
   
   // 數字輸出
   cout << "short  s :" << s << endl;
   cout << "int    i :" << i << endl;
   cout << "long   l :" << l << endl;
   cout << "float  f :" << f << endl;
   cout << "double d :" << d << endl;
 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
short  s :10int    i :1000long   l :1000000float  f :230.47double d :30949.4
```

## C++ 數學運算

在 C++ 中，除了可以創建各種函式，還包含了各種有用的函式供您使用。這些函式寫在標準 C 和 C++ 庫中，叫做**內置**函式。您可以在程式中參照這些函式。

C++ 內置了豐富的數學函式，可對各種數字進行運算。下表列出了 C++ 中一些有用的內置的數學函式。

為了利用這些函式，您需要參照數學頭檔案 **<cmath>**。

| 序號 | 函式 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **double cos(double);** 該函式返回弧度角（double 型）的餘弦。 |
| 2    | **double sin(double);** 該函式返回弧度角（double 型）的正弦。 |
| 3    | **double tan(double);** 該函式返回弧度角（double 型）的正切。 |
| 4    | **double log(double);** 該函式返回參數的自然對數。           |
| 5    | **double pow(double, double);** 假設第一個參數為 x，第二個參數為 y，則該函式返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 該函式返回兩個參數的平方總和的平方根，也就是說，參數為一個直角三角形的兩個直角邊，函式會返回斜邊的長度。 |
| 7    | **double sqrt(double);** 該函式返回參數的平方根。            |
| 8    | **int abs(int);** 該函式返回整數的絕對值。                   |
| 9    | **double fabs(double);** 該函式返回任意一個十進制數的絕對值。 |
| 10   | **double floor(double);** 該函式返回一個小於或等於傳入參數的最大整數。 |

下面是一個關於數學運算的簡單實體：

```cpp
#include <iostream>#include <cmath>using namespace std;
 int main (){
   // 數字定義
   short  s = 10;
   int    i = -1000;
   long   l = 100000;
   float  f = 230.47;
   double d = 200.374;

   // 數學運算
   cout << "sin(d) :" << sin(d) << endl;
   cout << "abs(i)  :" << abs(i) << endl;
   cout << "floor(d) :" << floor(d) << endl;
   cout << "sqrt(f) :" << sqrt(f) << endl;
   cout << "pow( d, 2) :" << pow(d, 2) << endl;
 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
sign(d) :-0.634939abs(i)  :1000floor(d) :200sqrt(f) :15.1812pow( d, 2 ) :40149.7
```

## C++ 隨機數

在許多情況下，需要生成隨機數。關於隨機數生成器，有兩個相關的函式。一個是 **rand()**，該函式只返回一個偽隨機數。生成隨機數之前必須先調用 **srand()** 函式。

下面是一個關於生成隨機數的簡單實體。實體中使用了 **time()** 函式來獲取系統時間的秒數，通過調用 rand() 函式來生成隨機數：

```cpp
#include <iostream>#include <ctime>#include <cstdlib>using namespace std;
 int main (){
   int i,j;
 
   // 設置種子
   srand( (unsigned)time( NULL ) );

   /* 生成 10 個隨機數 */
   for( i = 0; i < 10; i++ )
   {
      // 生成實際的隨機數
      j= rand();
      cout <<"隨機數： " << j << endl;
   }

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
隨機數： 1748144778隨機數： 630873888隨機數： 2134540646隨機數： 219404170隨機數： 902129458隨機數： 920445370隨機數： 1319072661隨機數： 257938873隨機數： 1256201101隨機數： 580322989
```

# C++ 陣列

C++ 支援**陣列**數據結構，它可以存儲一個固定大小的相同型別元素的順序集合。陣列是用來存儲一系列數據，但它往往被認為是一系列相同型別的變數。

陣列的聲明並不是聲明一個個單獨的變數，比如 number0、number1、...、number99，而是聲明一個陣列變數，比如 numbers，然後使用 numbers[0]、numbers[1]、...、numbers[99] 來代表一個個單獨的變數。陣列中的特定元素可以通過索引訪問。

所有的陣列都是由連續的記憶體位元元置組成。最低的地址對應第一個元素，最高的地址對應最後一個元素。

## 聲明陣列

在 C++ 中要聲明一個陣列，需要指定元素的型別和元素的數量，如下所示：

```cpp
type arrayName [ arraySize ];
```

這叫做一維陣列。**arraySize** 必須是一個大於零的整數常數，**type** 可以是任意有效的 C++ 數據型別。例如，要聲明一個型別為 double 的包含 10 個元素的陣列 **balance**，聲明語句如下：

```cpp
double balance[10];
```

現在 *balance* 是一個可用的陣列，可以容納 10 個型別為 double 的數字。

## 初始化陣列

在 C++ 中，您可以逐個初始化陣列，也可以使用一個初始化語句，如下所示：

```cpp
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

大括號 { } 之間的值的數目不能大於我們在陣列聲明時在方括號 [ ] 中指定的元素數目。

如果您省略掉了陣列的大小，陣列的大小則為初始化時元素的個數。因此，如果：

```cpp
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

您將創建一個陣列，它與前一個實體中所創建的陣列是完全相同的。下面是一個為陣列中某個元素賦值的實體：

```cpp
balance[4] = 50.0;
```

上述的語句把陣列中第五個元素的值賦為 50.0。所有的陣列都是以 0 作為它們第一個元素的索引，也被稱為基索引，陣列的最後一個索引是陣列的總大小減去 1。以下是上面所討論的陣列的的圖形表示：

![陣列表示](https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg)

## 訪問陣列元素

陣列元素可以通過陣列名稱加索引進行訪問。元素的索引是放在方括號內，跟在陣列名稱的後邊。例如：

```cpp
double salary = balance[9];
```

上面的語句將把陣列中第 10 個元素的值賦給 salary 變數。下面的實體使用了上述的三個概念，即，聲明陣列、陣列賦值、訪問陣列：

```cpp
#include <iostream>using namespace std;
 #include <iomanip>using std::setw;
 int main (){
   int n[ 10 ]; // n 是一個包含 10 個整數的陣列
 
   // 初始化陣列元素          
   for ( int i = 0; i < 10; i++ )
   {
      n[ i ] = i + 100; // 設置元素 i 為 i + 100
   }
   cout << "Element" << setw( 13 ) << "Value" << endl;
 
   // 輸出陣列中每個元素的值                     
   for ( int j = 0; j < 10; j++ )
   {
      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;
   }
 
   return 0;}
```

上面的程式使用了 **setw()** 函式來格式化輸出。當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Element        Value
      0          100
      1          101
      2          102
      3          103
      4          104
      5          105
      6          106
      7          107
      8          108
      9          109
```

## C++ 中陣列詳解

在 C++ 中，陣列是非常重要的，我們需要了解更多有關陣列的細節。下面列出了 C++ 程式員必須清楚的一些與陣列相關的重要概念：

| 概念           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| 多維陣列       | C++ 支援多維陣列。多維陣列最簡單的形式是二維陣列。           |
| 指向陣列的指標 | 您可以通過指定不帶索引的陣列名稱來生成一個指向陣列中第一個元素的指標。 |
| 傳遞陣列給函式 | 您可以通過指定不帶索引的陣列名稱來給函式傳遞一個指向陣列的指標。 |
| 從函式返回陣列 | C++ 允許從函式返回陣列。                                     |

# C++ 字串

C++ 提供了以下兩種型別的字串表示形式：

- C 風格字串
- C++ 引入的 string 類型別

## C 風格字串

C 風格的字串起源於 C 語言，並在 C++ 中繼續得到支援。字串實際上是使用 **null** 字符 '\0' 終止的一維字符陣列。因此，一個以 null 結尾的字串，包含了組成字串的字符。

下面的聲明和初始化創建了一個 "Hello" 字串。由於在陣列的末尾存儲了空字符，所以字符陣列的大小比單詞 "Hello" 的字符數多一個。

```cpp
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

依據陣列初始化規則，您可以把上面的語句寫成以下語句：

```cpp
char greeting[] = "Hello";
```

以下是 C/C++ 中定義的字串的記憶體表示：

![img](https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg)

其實，您不需要把 *null* 字符放在字串常數的末尾。C++ 編譯器會在初始化陣列時，自動把 '\0' 放在字串的末尾。讓我們嘗試輸出上面的字串：

## 實體

```cpp
#include <iostream>
 using namespace std; 
int main (){
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; 
   cout << "Greeting message: ";   cout << greeting << endl; 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Greeting message: Hello
```

C++ 中有大量的函式用來操作以 null 結尾的字串：supports a wide range of functions that manipulate null-terminated strings:

| 序號 | 函式 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 複製字串 s2 到字串 s1。              |
| 2    | **strcat(s1, s2);** 連接字串 s2 到字串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字串 s1 的長度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，則返回 0；如果 s1<s2 則返回小於 0；如果 s1>s2 則返回大於 0。 |
| 5    | **strchr(s1, ch);** 返回一個指標，指向字串 s1 中字符 ch 的第一次出現的位元元置。 |
| 6    | **strstr(s1, s2);** 返回一個指標，指向字串 s1 中字串 s2 的第一次出現的位元元置。 |

下面的實體使用了上述的一些函式：

## 實體

```cpp
#include <iostream>#include <cstring>
 using namespace std; 
int main (){
   char str1[11] = "Hello";   char str2[11] = "World";   char str3[11];   int  len ; 
   // 複製 str1 到 str3
   strcpy( str3, str1);   cout << "strcpy( str3, str1) : " << str3 << endl; 
   // 連接 str1 和 str2
   strcat( str1, str2);   cout << "strcat( str1, str2): " << str1 << endl; 
   // 連接後，str1 的總長度
   len = strlen(str1);   cout << "strlen(str1) : " << len << endl; 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
strcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10
```

## C++ 中的 String 類

C++ 標準庫提供了 **string** 類型別，支援上述所有的操作，另外還增加了其他更多的功能。我們將學習 C++ 標準庫中的這個類，現在讓我們先來看看下面這個實體：

現在您可能還無法透徹地理解這個實體，因為到目前為止我們還沒有討論類和物件。所以現在您可以只是粗略地看下這個實體，等理解了面向物件的概念之後再回頭來理解這個實體。

## 實體

```cpp
#include <iostream>#include <string>
 using namespace std; 
int main (){
   string str1 = "Hello";   string str2 = "World";   string str3;   int  len ; 
   // 複製 str1 到 str3
   str3 = str1;   cout << "str3 : " << str3 << endl; 
   // 連接 str1 和 str2
   str3 = str1 + str2;   cout << "str1 + str2 : " << str3 << endl; 
   // 連接後，str3 的總長度
   len = str3.size();   cout << "str3.size() :  " << len << endl; 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
str3 : Hellostr1 + str2 : HelloWorldstr3.size() :  10
```

# C++ 指標

學習 C++ 的指標既簡單又有趣。通過指標，可以簡化一些 C++ 編程任務的執行，還有一些任務，如動態記憶體分配，沒有指標是無法執行的。所以，想要成為一名優秀的 C++ 程式員，學習指標是很有必要的。

正如您所知道的，每一個變數都有一個記憶體位元元置，每一個記憶體位元元置都定義了可使用連字號（&）運算子訪問的地址，它表示了在記憶體中的一個地址。請看下面的實體，它將輸出定義的變數地址：

```cpp
#include <iostream>using namespace std;int main (){
   int  var1;
   char var2[10];

   cout << "var1 變數的地址： ";
   cout << &var1 << endl;

   cout << "var2 變數的地址： ";
   cout << &var2 << endl;

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
var1 變數的地址： 0xbfebd5c0var2 變數的地址： 0xbfebd5b6
```

通過上面的實體，我們瞭解了什麼是記憶體地址以及如何訪問它。接下來讓我們看看什麼是指標。

## 什麼是指標？

**指標**是一個變數，其值為另一個變數的地址，即，記憶體位元元置的直接地址。就像其他變數或常數一樣，您必須在使用指標存儲其他變數地址之前，對其進行聲明。指標變數聲明的一般形式為：

```cpp
type *var-name;
```

在這裡，**type** 是指標的基型別，它必須是一個有效的 C++ 數據型別，**var-name** 是指標變數的名稱。用來聲明指標的星號 * 與乘法中使用的星號是相同的。但是，在這個語句中，星號是用來指定一個變數是指標。以下是有效的指標聲明：

```cpp
int    *ip;    /* 一個整型的指標 */double *dp;    /* 一個 double 型的指標 */float  *fp;    /* 一個浮點型的指標 */char   *ch;    /* 一個字符型的指標 */
```

所有指標的值的實際數據型別，不管是整型、浮點型、字符型，還是其他的數據型別，都是一樣的，都是一個代表記憶體地址的長的十六進制數。不同數據型別的指標之間唯一的不同是，指標所指向的變數或常數的數據型別不同。

## C++ 中使用指標

使用指標時會頻繁進行以下幾個操作：定義一個指標變數、把變數地址賦值給指標、訪問指標變數中可用地址的值。這些是通過使用一元運算子 ***** 來返回位元元於操作數所指定地址的變數的值。下面的實體涉及到了這些操作：

```cpp
#include <iostream>using namespace std;int main (){
   int  var = 20;   // 實際變數的聲明
   int  *ip;        // 指標變數的聲明

   ip = &var;       // 在指標變數中存儲 var 的地址

   cout << "Value of var variable: ";
   cout << var << endl;

   // 輸出在指標變數中存儲的地址
   cout << "Address stored in ip variable: ";
   cout << ip << endl;

   // 訪問指標中地址的值
   cout << "Value of *ip variable: ";
   cout << *ip << endl;

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Value of var variable: 20Address stored in ip variable: 0xbfc601acValue of *ip variable: 20
```

## C++ 指標詳解

在 C++ 中，有很多指標相關的概念，這些概念都很簡單，但是都很重要。下面列出了 C++ 程式員必須清楚的一些與指標相關的重要概念：

| 概念               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| C++ Null 指標      | C++ 支援空指標。NULL 指標是一個定義在標準庫中的值為零的常數。 |
| C++ 指標的算術運算 | 可以對指標進行四種算術運算：++、--、+、-                     |
| C++ 指標 vs 陣列   | 指標和陣列之間有著密切的關係。                               |
| C++ 指標陣列       | 可以定義用來存儲指標的陣列。                                 |
| C++ 指向指標的指標 | C++ 允許指向指標的指標。                                     |
| C++ 傳遞指標給函式 | 通過參照或地址傳遞參數，使傳遞的參數在調用函式中被改變。     |
| C++ 從函式返回指標 | C++ 允許函式返回指標到局部變數、靜態變數和動態記憶體分配。     |

# C++ 參照

參照變數是一個別名，也就是說，它是某個已存在變數的另一個名字。一旦把參照初始化為某個變數，就可以使用該參照名稱或變數名稱來指向變數。

## C++ 參照 vs 指標

參照很容易與指標混淆，它們之間有三個主要的不同：

- 不存在空參照。參照必須連接到一塊合法的記憶體。
- 一旦參照被初始化為一個物件，就不能被指向到另一個物件。指標可以在任何時候指向到另一個物件。
- 參照必須在創建時被初始化。指標可以在任何時間被初始化。

## C++ 中創建參照

試想變數名稱是變數附屬在記憶體位元元置中的標籤，您可以把參照當成是變數附屬在記憶體位元元置中的第二個標籤。因此，您可以通過原始變數名稱或參照來訪問變數的內容。例如：

```cpp
int i = 17;
```

我們可以為 i 聲明參照變數，如下所示：

```cpp
int&    r = i;
```

在這些聲明中，& 讀作**參照**。因此，第一個聲明可以讀作 "r 是一個初始化為 i 的整型參照"，第二個聲明可以讀作 "s 是一個初始化為 d 的 double 型參照"。下面的實體使用了 int 和 double 參照：

```cpp
#include <iostream>
 using namespace std;
 int main (){
   // 聲明簡單的變數
   int    i;
   double d;
 
   // 聲明參照變數
   int&    r = i;
   double& s = d;
   
   i = 5;
   cout << "Value of i : " << i << endl;
   cout << "Value of i reference : " << r  << endl;
 
   d = 11.7;
   cout << "Value of d : " << d << endl;
   cout << "Value of d reference : " << s  << endl;
   
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Value of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7
```

參照通常用於函式參數列表和函式回傳值。下面列出了 C++ 程式員必須清楚的兩個與 C++ 參照相關的重要概念：

| 概念             | 描述                                                     |
| :--------------- | :------------------------------------------------------- |
| 把參照作為參數   | C++ 支援把參照作為參數傳給函式，這比傳一般的參數更安全。 |
| 把參照作為回傳值 | 可以從 C++ 函式中返回參照，就像返回其他數據型別一樣。    |

# C++ 日期 & 時間

C++ 標準庫沒有提供所謂的日期型別。C++ 繼承了 C 語言用於日期和時間操作的結構和函式。為了使用日期和時間相關的函式和結構，需要在 C++ 程式中參照 <ctime> 頭檔案。

有四個與時間相關的型別：**clock_t、time_t、size_t** 和 **tm**。型別 clock_t、size_t 和 time_t 能夠把系統時間和日期表示為某種整數。

結構型別 **tm** 把日期和時間以 C 結構的形式保存，tm 結構的定義如下：

```cpp
struct tm {
  int tm_sec;   // 秒，正常範圍從 0 到 59，但允許至 61
  int tm_min;   // 分，範圍從 0 到 59
  int tm_hour;  // 小時，範圍從 0 到 23
  int tm_mday;  // 一月中的第幾天，範圍從 1 到 31
  int tm_mon;   // 月，範圍從 0 到 11
  int tm_year;  // 自 1900 年起的年數
  int tm_wday;  // 一週中的第幾天，範圍從 0 到 6，從星期日算起
  int tm_yday;  // 一年中的第幾天，範圍從 0 到 365，從 1 月 1 日算起
  int tm_isdst; // 夏令時}
```

下面是 C/C++ 中關於日期和時間的重要函式。所有這些函式都是 C/C++ 標準庫的組成部分，您可以在 C++ 標準庫中查看一下各個函式的細節。

| 序號 | 函式 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **time_t time(time_t \*time);** 該函式返回系統的當前日曆時間，自 1970 年 1 月 1 日以來經過的秒數。如果系統沒有時間，則返回 .1。 |
| 2    | **char \*ctime(const time_t \*time);** 該返回一個表示當地時間的字串指標，字串形式 *day month year hours:minutes:seconds year\n\0*。 |
| 3    | **struct tm \*localtime(const time_t \*time);** 該函式返回一個指向表示本地時間的 **tm** 結構的指標。 |
| 4    | **clock_t clock(void);** 該函式返回程式執行起（一般為程式的開頭），處理器時鐘所使用的時間。如果時間不可用，則返回 .1。 |
| 5    | **char \* asctime ( const struct tm \* time );** 該函式返回一個指向字串的指標，字串包含了 time 所指向結構中存儲的資訊，返回形式為：day month date hours:minutes:seconds year\n\0。 |
| 6    | **struct tm \*gmtime(const time_t \*time);** 該函式返回一個指向 time 的指標，time 為 tm 結構，用協調世界時（UTC）也被稱為格林尼治標準時間（GMT）表示。 |
| 7    | **time_t mktime(struct tm \*time);** 該函式返回日曆時間，相當於 time 所指向結構中存儲的時間。 |
| 8    | **double difftime ( time_t time2, time_t time1 );** 該函式返回 time1 和 time2 之間相差的秒數。 |
| 9    | **size_t strftime();** 該函式可用於格式化日期和時間為指定的格式。 |

## 當前日期和時間

下面的實體獲取當前系統的日期和時間，包括本地時間和協調世界時（UTC）。

```cpp
#include <iostream>#include <ctime>using namespace std;int main( ){
   // 基於當前系統的當前日期/時間
   time_t now = time(0);
   
   // 把 now 轉換為字串形式
   char* dt = ctime(&now);

   cout << "本地日期和時間：" << dt << endl;

   // 把 now 轉換為 tm 結構
   tm *gmtm = gmtime(&now);
   dt = asctime(gmtm);
   cout << "UTC 日期和時間："<< dt << endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
本地日期和時間：Sat Jan  8 20:07:41 2011UTC 日期和時間：Sun Jan  9 03:07:41 2011
```

## 使用結構 tm 格式化時間

**tm** 結構在 C/C++ 中處理日期和時間相關的操作時，顯得尤為重要。tm 結構以 C 結構的形式保存日期和時間。大多數與時間相關的函式都使用了 tm 結構。下面的實體使用了 tm 結構和各種與日期和時間相關的函式。

在練習使用結構之前，需要對 C 結構有基本的瞭解，並懂得如何使用箭頭 -> 運算子來訪問結構成員。

```cpp
#include <iostream>#include <ctime>using namespace std;int main( ){
   // 基於當前系統的當前日期/時間
   time_t now = time(0);

   cout << "Number of sec since January 1,1970:" << now << endl;

   tm *ltm = localtime(&now);

   // 輸出 tm 結構的各個組成部分
   cout << "Year: "<< 1900 + ltm->tm_year << endl;
   cout << "Month: "<< 1 + ltm->tm_mon<< endl;
   cout << "Day: "<<  ltm->tm_mday << endl;
   cout << "Time: "<< 1 + ltm->tm_hour << ":";
   cout << 1 + ltm->tm_min << ":";
   cout << 1 + ltm->tm_sec << endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Number of sec since January 1, 1970:1294548238Year: 2011Month: 1Day: 8Time: 22: 44:59
```

# C++ 基本的輸入輸出

C++ 標準庫提供了一組豐富的輸入/輸出功能，我們將在後續的章節進行介紹。本章將討論 C++ 編程中最基本和最常見的 I/O 操作。

C++ 的 I/O 發生在流中，流是位元元組序列。如果位元元組流是從設備（如鍵盤、磁碟驅動器、網路連接等）流向記憶體，這叫做**輸入操作**。如果位元元組流是從記憶體流向設備（如顯示屏、印出機、磁碟驅動器、網路連接等），這叫做**輸出操作**。

## I/O 庫頭檔案

下列的頭檔案在 C++ 編程中很重要。

| 頭檔案     | 函式和描述                                                   |
| :--------- | :----------------------------------------------------------- |
| <iostream> | 該檔案定義了 **cin、cout、cerr** 和 **clog** 物件，分別對應於標準輸入流、標準輸出流、非緩衝標準錯誤流和緩衝標準錯誤流。 |
| <iomanip>  | 該檔案通過所謂的參數化的流操縱器（比如 **setw** 和 **setprecision**），來聲明對執行標準化 I/O 有用的服務。 |
| <fstream>  | 該檔案為用戶控制的檔案處理聲明服務。我們將在檔案和流的相關章節討論它的細節。 |

## 標準輸出流（cout）

預定義的物件 **cout** 是 **ostream** 類的一個實體。cout 物件"連接"到標準輸出設備，通常是顯示屏。**cout** 是與流插入運算子 << 結合使用的，如下所示：

```cpp
#include <iostream> using namespace std; int main( ){   char str[] = "Hello C++";    cout << "Value of str is : " << str << endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Value of str is : Hello C++
```

C++ 編譯器根據要輸出變數的數據型別，選擇合適的流插入運算子來顯示值。<< 運算子被多載來輸出內置型別（整型、浮點型、double 型、字串和指標）的數據項。

流插入運算子 << 在一個語句中可以多次使用，如上面實體中所示，**endl** 用於在行末添加一個換行符。

## 標準輸入流（cin）

預定義的物件 **cin** 是 **istream** 類的一個實體。cin 物件附屬到標準輸入設備，通常是鍵盤。**cin** 是與流提取運算子 >> 結合使用的，如下所示：

```cpp
#include <iostream> using namespace std; int main( ){  
	char name[50];    cout << "請輸入您的名稱： ";   
	cin >> name;   cout << "您的名稱是： " << name << endl; }
```

當上面的程式碼被編譯和執行時，它會提示用戶輸入名稱。當用戶輸入一個值，並按回車鍵，就會看到下列結果：

```cpp
請輸入您的名稱： cplusplus您的名稱是： cplusplus
```

C++ 編譯器根據要輸入值的數據型別，選擇合適的流提取運算子來提取值，並把它存儲在給定的變數中。

流提取運算子 >> 在一個語句中可以多次使用，如果要求輸入多個數據，可以使用如下語句：

```cpp
cin >> name >> age;
```

這相當於下面兩個語句：

```cpp
cin >> name;cin >> age;
```

## 標準錯誤流（cerr）

預定義的物件 **cerr** 是 **ostream** 類的一個實體。cerr 物件附屬到標準錯誤設備，通常也是顯示屏，但是 **cerr** 物件是非緩衝的，且每個流插入到 cerr 都會立即輸出。

**cerr** 也是與流插入運算子 << 結合使用的，如下所示：

```cpp
#include <iostream>
 using namespace std;
 int main( ){
   char str[] = "Unable to read....";
 
   cerr << "Error message : " << str << endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Error message : Unable to read....
```

## 標準日誌流（clog）

預定義的物件 **clog** 是 **ostream** 類的一個實體。clog 物件附屬到標準錯誤設備，通常也是顯示屏，但是 **clog** 物件是緩衝的。這意味著每個流插入到 clog 都會先存儲在緩衝在，直到緩衝填滿或者緩衝區刷新時才會輸出。

**clog** 也是與流插入運算子 << 結合使用的，如下所示：

```cpp
#include <iostream>
 using namespace std;
 int main( ){
   char str[] = "Unable to read....";
 
   clog << "Error message : " << str << endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Error message : Unable to read....
```

通過這些小實體，我們無法區分 cout、cerr 和 clog 的差異，但在編寫和執行大型程式時，它們之間的差異就變得非常明顯。所以良好的編程實踐告訴我們，使用 cerr 流來顯示錯誤消息，而其他的日誌消息則使用 clog 流來輸出。

# C++ 數據結構

C/C++ 陣列允許定義可存儲相同型別數據項的變數，但是**結構**是 C++ 中另一種用戶自定義的可用的數據型別，它允許您存儲不同型別的數據項。

結構用於表示一條記錄，假設您想要跟蹤圖書館中書本的動態，您可能需要跟蹤每本書的下列屬性：

- Title ：標題
- Author ：作者
- Subject ：類目
- Book ID ：書的 ID

## 定義結構

為了定義結構，您必須使用 **struct** 語句。struct 語句定義了一個包含多個成員的新的數據型別，struct 語句的格式如下：

 

```cpp
struct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names;
```

**type_name** 是結構型別的名稱，**member_type1 member_name1** 是標準的變數定義，比如 **int i;** 或者 **float f;** 或者其他有效的變數定義。在結構定義的末尾，最後一個分號之前，您可以指定一個或多個結構變數，這是可選的。下面是聲明一個結構型別 **Books**，變數為 **book**：

```cpp
struct Books{   char  title[50];   char  author[50];   char  subject[100];      int   book_id;} book;
```

## 訪問結構成員

為了訪問結構的成員，我們使用**成員訪問運算子（.）**。成員訪問運算子是結構變數名稱和我們要訪問的結構成員之間的一個句號。

下面的實體演示了結構的用法：

## 實體

```cpp
#include <iostream>#include <cstring>
 using namespace std; 
// 聲明一個結構型別 Books struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構型別 Books 的變數 Book1
   Books Book2;        // 定義結構型別 Books 的變數 Book2
 
   // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 輸出 Book1 資訊
   cout << "第一本書標題 : " << Book1.title <<endl;   cout << "第一本書作者 : " << Book1.author <<endl;   cout << "第一本書類目 : " << Book1.subject <<endl;   cout << "第一本書 ID : " << Book1.book_id <<endl; 
   // 輸出 Book2 資訊
   cout << "第二本書標題 : " << Book2.title <<endl;   cout << "第二本書作者 : " << Book2.author <<endl;   cout << "第二本書類目 : " << Book2.subject <<endl;   cout << "第二本書 ID : " << Book2.book_id <<endl; 
   return 0;}
```

實體中定義了結構類似 Books 及其兩個變數 Book1 和 Book2。當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
第一本書標題 : C++ 教程第一本書作者 : Runoob第一本書類目 : 編程語言第一本書 ID : 12345第二本書標題 : CSS 教程第二本書作者 : Runoob第二本書類目 : 前端技術第二本書 ID : 12346
```

## 結構作為函式參數

您可以把結構作為函式參數，傳參方式與其他型別的變數或指標類似。您可以使用上面實體中的方式來訪問結構變數：

## 實體

```cpp
#include <iostream>#include <cstring>
 using namespace std;void printBook( struct Books book ); 
// 聲明一個結構型別 Books struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構型別 Books 的變數 Book1
   Books Book2;        // 定義結構型別 Books 的變數 Book2
 
    // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   
   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 輸出 Book1 資訊
   printBook( Book1 ); 
   // 輸出 Book2 資訊
   printBook( Book2 ); 
   return 0;}void printBook( struct Books book ){
   cout << "書標題 : " << book.title <<endl;   cout << "書作者 : " 
   << book.author <<endl;   cout << "書類目 : " << book.subject <<endl;   
   cout << "書 ID : " << book.book_id <<endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
書標題 : C++ 教程書作者 : Runoob書類目 : 編程語言書 ID : 12345書標題 : CSS 教程書作者 : Runoob書類目 : 前端技術書 ID : 12346
```

## 指向結構的指標

您可以定義指向結構的指標，方式與定義指向其他型別變數的指標相似，如下所示：

```cpp
struct Books *struct_pointer;
```

現在，您可以在上述定義的指標變數中存儲結構變數的地址。為了搜尋結構變數的地址，請把 & 運算子放在結構名稱的前面，如下所示：

```cpp
struct_pointer = &Book1;
```

為了使用指向該結構的指標訪問結構的成員，您必須使用 -> 運算子，如下所示：

```cpp
struct_pointer->title;
```

讓我們使用結構指標來覆寫上面的實體，這將有助於您理解結構指標的概念：

## 實體

```cpp
#include <iostream>#include <cstring>
 using namespace std;void printBook( struct Books *book ); 
struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構型別 Books 的變數 Book1
   Books Book2;        // 定義結構型別 Books 的變數 Book2
 
    // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   
   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 通過傳 Book1 的地址來輸出 Book1 資訊
   printBook( &Book1 ); 
   // 通過傳 Book2 的地址來輸出 Book2 資訊
   printBook( &Book2 ); 
   return 0;}// 該函式以結構指標作為參數void printBook( struct Books *book ){
   cout << "書標題  : " << book->title <<endl;   cout << "書作者 : " 
   << book->author <<endl;   cout << "書類目 : " << book->subject <<endl;   
   cout << "書 ID : " << book->book_id <<endl;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
書標題  : C++ 教程書作者 : Runoob書類目 : 編程語言書 ID : 12345書標題  : CSS 教程書作者 : Runoob書類目 : 前端技術書 ID : 12346
```

## typedef 關鍵字

下面是一種更簡單的定義結構的方式，您可以為創建的型別取一個"別名"。例如：

```cpp
typedef struct{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;}Books;
```

現在，您可以直接使用 *Books* 來定義 *Books* 型別的變數，而不需要使用 struct 關鍵字。下面是實體：

```cpp
Books Book1, Book2;
```

您可以使用 **typedef** 關鍵字來定義非結構型別，如下所示：

```cpp
typedef long int *pint32;
 pint32 x, y, z;
```

x, y 和 z 都是指向長整型 long int 的指標。

# C++ 類 & 物件

C++ 在 C 語言的基礎上增加了面向物件編程，C++ 支援面向物件程式設計。類是 C++ 的核心特性，通常被稱為用戶定義的型別。

類用於指定物件的形式，它包含了數據表示法和用於處理數據的方法。類中的數據和方法稱為類的成員。函式在一個類被稱為類的成員。

## C++ 類定義

定義一個類，本質上是定義一個數據型別的藍圖。這實際上並沒有定義任何數據，但它定義了類的名稱意味著什麼，也就是說，它定義了類的物件包括了什麼，以及可以在這個物件上執行哪些操作。

類定義是以關鍵字 **class** 開頭，後跟類的名稱。類的主體是包含在一對花括號中。類定義後必須跟著一個分號或一個聲明列表。例如，我們使用關鍵字 **class** 定義 Box 數據型別，如下所示：

```cpp
class Box{   public:      double length;   // Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box};
```

關鍵字 **public** 確定了類成員的訪問屬性。在類物件作用域內，公共成員在類的外部是可訪問的。您也可以指定類的成員為 **private** 或 **protected**，這個我們稍後會進行講解。

## 定義 C++ 物件

類提供了物件的藍圖，所以基本上，物件是根據類來創建的。聲明類的物件，就像聲明基本型別的變數一樣。下面的語句聲明瞭類 Box 的兩個物件：

```cpp
Box Box1;          // 聲明 Box1，型別為 BoxBox Box2;          // 聲明 Box2，型別為 Box
```

物件 Box1 和 Box2 都有它們各自的數據成員。

## 訪問數據成員

類的物件的公共數據成員可以使用直接成員訪問運算子 (.) 來訪問。為了更好地理解這些概念，讓我們嘗試一下下面的實體：

```cpp
#include <iostream>using namespace std;class Box{
   public:
      double length;   // 長度
      double breadth;  // 寬度
      double height;   // 高度};int main( ){
   Box Box1;        // 聲明 Box1，型別為 Box
   Box Box2;        // 聲明 Box2，型別為 Box
   double volume = 0.0;     // 用於存儲體積
 
   // box 1 詳述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;

   // box 2 詳述
   Box2.height = 10.0;
   Box2.length = 12.0;
   Box2.breadth = 13.0;

   // box 1 的體積
   volume = Box1.height * Box1.length * Box1.breadth;
   cout << "Box1 的體積：" << volume <<endl;

   // box 2 的體積
   volume = Box2.height * Box2.length * Box2.breadth;
   cout << "Box2 的體積：" << volume <<endl;
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Box1 的體積：210Box2 的體積：1560
```

需要注意的是，私有的成員和受保護的成員不能使用直接成員訪問運算子 (.) 來直接訪問。我們將在後續的教程中學習如何訪問私有成員和受保護的成員。

# 類 & 物件詳解

到目前為止，我們已經對 C++ 的類和物件有了基本的瞭解。下面的列表中還列出了其他一些 C++ 類和物件相關的概念，可以點擊相應的連結進行學習。

| 概念                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| 類成員函式          | 類的成員函式是指那些把定義和原型寫在類定義內部的函式，就像類定義中的其他變數一樣。 |
| 類訪問修飾符        | 類成員可以被定義為 public、private 或 protected。預設情況下是定義為 private。 |
| 建構函式 & 解構函式 | 類的建構函式是一種特殊的函式，在創建一個新的物件時調用。類的解構函式也是一種特殊的函式，在刪除所創建的物件時調用。 |
| C++ 複製建構函式    | 複製建構函式，是一種特殊的建構函式，它在創建物件時，是使用同一類中之前創建的物件來初始化新創建的物件。 |
| C++ 友元函式        | **友元函式**可以訪問類的 private 和 protected 成員。         |
| C++ 內聯函式        | 通過內聯函式，編譯器試圖在調用函式的地方擴展函式體中的程式碼。 |
| C++ 中的 this 指標  | 每個物件都有一個特殊的指標 **this**，它指向物件本身。        |
| C++ 中指向類的指標  | 指向類的指標方式如同指向結構的指標。實際上，類可以看成是一個帶有函式的結構。 |
| C++ 類的靜態成員    | 類的數據成員和函式成員都可以被聲明為靜態的。                 |

# C++ 繼承

面向物件程式設計中最重要的一個概念是繼承。繼承允許我們依據另一個類來定義一個類，這使得創建和維護一個應用程式變得更容易。這樣做，也達到了重用程式碼功能和提高執行時間的效果。

當創建一個類時，您不需要重新編寫新的數據成員和成員函式，只需指定新建的類繼承了一個已有的類的成員即可。這個已有的類稱為**基類**，新建的類稱為**派生類**。

繼承代表了 **is a** 關係。例如，哺乳動物是動物，狗是哺乳動物，因此，狗是動物，等等。

## 基類 & 派生類

一個類可以派生自多個類，這意味著，它可以從多個基類繼承數據和函式。定義一個派生類，我們使用一個類派生列表來指定基類。類派生列表以一個或多個基類命名，形式如下：

```cpp
class derived-class: access-specifier base-class
```

其中，訪問修飾符 access-specifier 是 **public、protected** 或 **private** 其中的一個，base-class 是之前定義過的某個類的名稱。如果未使用訪問修飾符 access-specifier，則預設為 private。

假設有一個基類 **Shape**，**Rectangle** 是它的派生類，如下所示：

```cpp
#include <iostream>
 using namespace std;// 基類class Shape {
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;};// 派生類class Rectangle: public Shape{
   public:
      int getArea()
      { 
         return (width * height); 
      }};int main(void){
   Rectangle Rect;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   // 輸出物件的面積
   cout << "Total area: " << Rect.getArea() << endl;

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```
 Total area: 35
```

## 訪問控制和繼承

派生類可以訪問基類中所有的非私有成員。因此基類成員如果不想被派生類的成員函式訪問，則應在基類中聲明為 private。

我們可以根據訪問權限總結出不同的訪問型別，如下所示：

| 訪問     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一個類 | yes    | yes       | yes     |
| 派生類   | yes    | yes       | no      |
| 外部的類 | yes    | no        | no      |

一個派生類繼承了所有的基類方法，但下列情況除外：

- 基類的建構函式、解構函式和複製建構函式。
- 基類的多載運算子。
- 基類的友元函式。

## 繼承型別

當一個類派生自基類，該基類可以被繼承為 **public、protected** 或 **private** 幾種型別。繼承型別是通過上面講解的訪問修飾符 access-specifier 來指定的。

我們幾乎不使用 **protected** 或 **private** 繼承，通常使用 **public** 繼承。當使用不同型別的繼承時，遵循以下幾個規則：

- **公有繼承（public）：**當一個類派生自**公有**基類時，基類的**公有**成員也是派生類的**公有**成員，基類的**保護**成員也是派生類的**保護**成員，基類的**私有**成員不能直接被派生類訪問，但是可以通過調用基類的**公有**和**保護**成員來訪問。
- **保護繼承（protected）：** 當一個類派生自**保護**基類時，基類的**公有**和**保護**成員將成為派生類的**保護**成員。
- **私有繼承（private）：**當一個類派生自**私有**基類時，基類的**公有**和**保護**成員將成為派生類的**私有**成員。

## 多繼承

多繼承即一個子類可以有多個父類，它繼承了多個父類的特性。

C++ 類可以從多個類繼承成員，語法如下：

```cpp
class <派生類名>:<繼承方式1><基類名1>,<繼承方式2><基類名2>,…{<派生類類體>};
```

其中，訪問修飾符繼承方式是 **public、protected** 或 **private** 其中的一個，用來修飾每個基類，各個基類之間用逗號分隔，如上所示。現在讓我們一起看看下面的實體：

```cpp
#include <iostream>
 using namespace std;// 基類 Shapeclass Shape {
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;};// 基類 PaintCostclass PaintCost {
   public:
      int getCost(int area)
      {
         return area * 70;
      }};// 派生類class Rectangle: public Shape, public PaintCost{
   public:
      int getArea()
      { 
         return (width * height); 
      }};int main(void){
   Rectangle Rect;
   int area;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   area = Rect.getArea();
   
   // 輸出物件的面積
   cout << "Total area: " << Rect.getArea() << endl;

   // 輸出總花費
   cout << "Total paint cost: $" << Rect.getCost(area) << endl;

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Total area: 35Total paint cost: $2450
```

# C++ 多載運算子和多載函式

C++ 允許在同一作用域中的某個**函式**和**運算子**指定多個定義，分別稱為**函式多載**和**運算子多載**。

多載聲明是指一個與之前已經在該作用域內聲明過的函式或方法具有相同名稱的聲明，但是它們的參數列表和定義（實現）不相同。

當您調用一個**多載函式**或**多載運算子**時，編譯器通過把您所使用的參數型別與定義中的參數型別進行比較，決定選用最合適的定義。選擇最合適的多載函式或多載運算子的過程，稱為**多載決策**。

## C++ 中的函式多載

在同一個作用域內，可以聲明幾個功能類似的同名函式，但是這些同名函式的形式參數（指參數的個數、型別或者順序）必須不同。您不能僅通過返回型別的不同來多載函式。

下面的實體中，同名函式 **print()** 被用於輸出不同的數據型別：

```cpp
#include <iostream>using namespace std;
 class printData 
{
   public:
      void print(int i) {
        cout << "Printing int: " << i << endl;
      }

      void print(double  f) {
        cout << "Printing float: " << f << endl;
      }

      void print(char* c) {
        cout << "Printing character: " << c << endl;
      }};int main(void){
   printData pd;
 
   // Call print to print integer
   pd.print(5);
   // Call print to print float
   pd.print(500.263);
   // Call print to print character
   pd.print("Hello C++");
 
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Printing int: 5Printing float: 500.263Printing character: Hello C++
```

## C++ 中的運算子多載

您可以重定義或多載大部分 C++ 內置的運算子。這樣，您就能使用自定義型別的運算子。

多載的運算子是帶有特殊名稱的函式，函式名是由關鍵字 operator 和其後要多載的運算子符號構成的。與其他函式一樣，多載運算子有一個返回型別和一個參數列表。

```cpp
Box operator+(const Box&);
```

聲明加法運算子用於把兩個 Box 物件相加，返回最終的 Box 物件。大多數的多載運算子可被定義為普通的非成員函式或者被定義為類成員函式。如果我們定義上面的函式為類的非成員函式，那麼我們需要為每次操作傳遞兩個參數，如下所示：

```cpp
Box operator+(const Box&, const Box&);
```

下面的實體使用成員函式演示了運算子多載的概念。在這裡，物件作為參數進行傳遞，物件的屬性使用 **this** 運算子進行訪問，如下所示：

```cpp
#include <iostream>using namespace std;class Box{
   public:

      double getVolume(void)
      {
         return length * breadth * height;
      }
      void setLength( double len )
      {
          length = len;
      }

      void setBreadth( double bre )
      {
          breadth = bre;
      }

      void setHeight( double hei )
      {
          height = hei;
      }
      // 多載 + 運算子，用於把兩個 Box 物件相加
      Box operator+(const Box& b)
      {
         Box box;
         box.length = this->length + b.length;
         box.breadth = this->breadth + b.breadth;
         box.height = this->height + b.height;
         return box;
      }
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度};// 程式的主函式int main( ){
   Box Box1;                // 聲明 Box1，型別為 Box
   Box Box2;                // 聲明 Box2，型別為 Box
   Box Box3;                // 聲明 Box3，型別為 Box
   double volume = 0.0;     // 把體積存儲在該變數中
 
   // Box1 詳述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 詳述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的體積
   volume = Box1.getVolume();
   cout << "Volume of Box1 : " << volume <<endl;
 
   // Box2 的體積
   volume = Box2.getVolume();
   cout << "Volume of Box2 : " << volume <<endl;

   // 把兩個物件相加，得到 Box3
   Box3 = Box1 + Box2;

   // Box3 的體積
   volume = Box3.getVolume();
   cout << "Volume of Box3 : " << volume <<endl;

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Volume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400
```

## 可多載運算子/不可多載運算子

下面是可多載的運算子列表：

| +    | -    | *    | /      | %      | ^         |
| ---- | ---- | ---- | ------ | ------ | --------- |
| &    | \|   | ~    | !      | ,      | =         |
| <    | >    | <=   | >=     | ++     | --        |
| <<   | >>   | ==   | !=     | &&     | \|\|      |
| +=   | -=   | /=   | %=     | ^=     | &=        |
| \|=  | *=   | <<=  | >>=    | []     | ()        |
| ->   | ->*  | new  | new [] | delete | delete [] |

下面是不可多載的運算子列表：

| ::   | .*   | .    | ?:   |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

## 運算子多載實體

下面提供了各種運算子多載的實體，幫助您更好地理解多載的概念。

| 序號 | 運算子和實體             |
| :--- | :----------------------- |
| 1    | 一元運算子多載           |
| 2    | 二元運算子多載           |
| 3    | 關係運算子多載           |
| 4    | 輸入/輸出運算子多載      |
| 5    | ++ 和 -- 運算子多載      |
| 6    | 賦值運算子多載           |
| 7    | 函式調用運算子 () 多載   |
| 8    | 下標運算子 [] 多載       |
| 9    | 類成員訪問運算子 -> 多載 |

# C++ 多型

**多型**按字面的意思就是多種形態。當類之間存在層次結構，並且類之間是通過繼承關聯時，就會用到多型。

C++ 多型意味著調用成員函式時，會根據調用函式的物件的型別來執行不同的函式。

下面的實體中，基類 Shape 被派生為兩個類，如下所示：

```cpp
#include <iostream> using namespace std;
 class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }};class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }};class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }};// 程式的主函式int main( ){
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // 存儲矩形的地址
   shape = &rec;
   // 調用矩形的求面積函式 area
   shape->area();

   // 存儲三角形的地址
   shape = &tri;
   // 調用三角形的求面積函式 area
   shape->area();
   
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Parent class areaParent class area
```

導致錯誤輸出的原因是，調用函式 area() 被編譯器設置為基類中的版本，這就是所謂的**靜態多型**，或**靜態連結** - 函式調用在程式執行前就準備好了。有時候這也被稱為**早綁定**，因為 area() 函式在程式編譯期間就已經設置好了。

但現在，讓我們對程式稍作修改，在 Shape 類中，area() 的聲明前放置關鍵字 **virtual**，如下所示：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }};
```

修改後，當編譯和執行前面的實體程式碼時，它會產生以下結果：

```cpp
Rectangle class areaTriangle class area
```

此時，編譯器看的是指標的內容，而不是它的型別。因此，由於 tri 和 rec 類的物件的地址存儲在 *shape 中，所以會調用各自的 area() 函式。

正如您所看到的，每個子類都有一個函式 area() 的獨立實現。這就是**多型**的一般使用方式。有了多型，您可以有多個不同的類，都帶有同一個名稱但具有不同實現的函式，函式的參數甚至可以是相同的。

## 虛擬函式

**虛擬函式** 是在基類中使用關鍵字 **virtual** 聲明的函式。在派生類中重新定義基類中定義的虛擬函式時，會告訴編譯器不要靜態連結到該函式。

我們想要的是在程式中任意點可以根據所調用的物件型別來選擇調用的函式，這種操作被稱為**動態連結**，或**後期綁定**。

## 純虛擬函式

您可能想要在基類中定義虛擬函式，以便在派生類中重新定義該函式更好地適用於物件，但是您在基類中又不能對虛擬函式給出有意義的實現，這個時候就會用到純虛擬函式。

我們可以把基類中的虛擬函式 area() 改寫如下：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;};
```

= 0 告訴編譯器，函式沒有主體，上面的虛擬函式是**純虛擬函式**。

# C++ 數據抽象

數據抽象是指，只向外界提供關鍵資訊，並隱藏其後臺的實現細節，即只表現必要的資訊而不呈現細節。

數據抽象是一種依賴於介面和實現分離的編程（設計）技術。

讓我們舉一個現實生活中的真實體子，比如一臺電視機，您可以打開和關閉、切換頻道、調整音量、添加外部組件（如喇叭、錄像機、DVD 播放器），但是您不知道它的內部實現細節，也就是說，您並不知道它是如何通過纜線接收信號，如何轉換信號，並最終顯示在螢幕上。

因此，我們可以說電視把它的內部實現和外部介面分離開了，您無需知道它的內部實現原理，直接通過它的外部介面（比如電源按鈕、遙控器、聲量控制器）就可以操控電視。

現在，讓我們言歸正傳，就 C++ 編程而言，C++ 類為**數據抽象**提供了可能。它們向外界提供了大量用於操作物件數據的公共方法，也就是說，外界實際上並不清楚類的內部實現。

例如，您的程式可以調用 **sort()** 函式，而不需要知道函式中排序數據所用到的演演算法。實際上，函式排序的底層實現會因庫的版本不同而有所差異，只要介面不變，函式調用就可以照常工作。

在 C++ 中，我們使用**類**來定義我們自己的抽象數據型別（ADT）。您可以使用類 **ostream** 的 **cout** 物件來輸出數據到標準輸出，如下所示：

```cpp
#include <iostream>using namespace std;int main( ){   cout << "Hello C++" <<endl;   return 0;}
```

在這裡，您不需要理解 **cout** 是如何在用戶的螢幕上顯示文本。您只需要知道公共介面即可，cout 的底層實現可以自由改變。

## 訪問標籤強制抽象

在 C++ 中，我們使用訪問標籤來定義類的抽象介面。一個類可以包含零個或多個訪問標籤：

- 使用公共標籤定義的成員都可以訪問該程式的所有部分。一個型別的數據抽象視圖是由它的公共成員來定義的。
- 使用私有標籤定義的成員無法訪問到使用類的程式碼。私有部分對使用型別的程式碼隱藏了實現細節。

訪問標籤出現的頻率沒有限制。每個訪問標籤指定了緊隨其後的成員定義的訪問級別。指定的訪問級別會一直有效，直到遇到下一個訪問標籤或者遇到類主體的關閉右括號為止。

## 數據抽象的好處

數據抽象有兩個重要的優勢：

- 類的內部受到保護，不會因無意的用戶級錯誤導致物件狀態受損。
- 類實現可能隨著時間的推移而發生變化，以便應對不斷變化的需求，或者應對那些要求不改變用戶級程式碼的錯誤報告。

如果只在類的私有部分定義數據成員，編寫該類的作者就可以隨意更改數據。如果實現發生改變，則只需要檢查類的程式碼，看看這個改變會導致哪些影響。如果數據是公有的，則任何直接訪問舊錶示形式的數據成員的函式都可能受到影響。

## 數據抽象的實體

C++ 程式中，任何帶有公有和私有成員的類都可以作為數據抽象的實體。請看下面的實體：

```cpp
#include <iostream>using namespace std;class Adder{
   public:
      // 建構函式
      Adder(int i = 0)
      {
        total = i;
      }
      // 對外的介面
      void addNum(int number)
      {
          total += number;
      }
      // 對外的介面
      int getTotal()
      {
          return total;
      };
   private:
      // 對外隱藏的數據
      int total;};int main( ){
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Total 60
```

上面的類把數字相加，並返回總和。公有成員 **addNum** 和 **getTotal** 是對外的介面，用戶需要知道它們以便使用類。私有成員 **total** 是用戶不需要了解的，但又是類能正常工作所必需的。

## 設計策略

抽象把程式碼分離為介面和實現。所以在設計組件時，必須保持介面獨立於實現，這樣，如果改變底層實現，介面也將保持不變。

在這種情況下，不管任何程式使用介面，介面都不會受到影響，只需要將最新的實現重新編譯即可。

# C++ 數據封裝

所有的 C++ 程式都有以下兩個基本要素：

- **程式語句（程式碼）：**這是程式中執行動作的部分，它們被稱為函式。
- **程式數據：**數據是程式的資訊，會受到程式函式的影響。

封裝是面向物件編程中的把數據和操作數據的函式綁定在一起的一個概念，這樣能避免受到外界的干擾和誤用，從而確保了安全。數據封裝引申出了另一個重要的 OOP 概念，即**數據隱藏**。

**數據封裝**是一種把數據和操作數據的函式捆綁在一起的機制，**數據抽象**是一種僅向用戶暴露介面而把具體的實現細節隱藏起來的機制。

C++ 通過創建**類**來支援封裝和數據隱藏（public、protected、private）。我們已經知道，類包含私有成員（private）、保護成員（protected）和公有成員（public）成員。預設情況下，在類中定義的所有專案都是私有的。例如：

```cpp
class Box{
   public:
      double getVolume(void)
      {
         return length * breadth * height;
      }
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度
	};
```

變數 length、breadth 和 height 都是私有的（private）。這意味著它們只能被 Box 類中的其他成員訪問，而不能被程式中其他部分訪問。這是實現封裝的一種方式。

為了使類中的成員變成公有的（即，程式中的其他部分也能訪問），必須在這些成員前使用 **public** 關鍵字進行聲明。所有定義在 public 標識符後邊的變數或函式可以被程式中所有其他的函式訪問。

把一個類定義為另一個類的友元類，會暴露實現細節，從而降低了封裝性。理想的做法是儘可能地對外隱藏每個類的實現細節。

## 數據封裝的實體

C++ 程式中，任何帶有公有和私有成員的類都可以作為數據封裝和數據抽象的實體。請看下面的實體：

```cpp
#include <iostream>using namespace std;class Adder{
   public:
      // 建構函式
      Adder(int i = 0)
      {
        total = i;
      }
      // 對外的介面
      void addNum(int number)
      {
          total += number;
      }
      // 對外的介面
      int getTotal()
      {
          return total;
      };
   private:
      // 對外隱藏的數據
      int total;};int main( ){
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Total 60
```

上面的類把數字相加，並返回總和。公有成員 **addNum** 和 **getTotal** 是對外的介面，用戶需要知道它們以便使用類。私有成員 **total** 是對外隱藏的，用戶不需要了解它，但它又是類能正常工作所必需的。

## 設計策略

通常情況下，我們都會設置類成員狀態為私有（private），除非我們真的需要將其暴露，這樣才能保證良好的**封裝性**。

這通常應用於數據成員，但它同樣適用於所有成員，包括虛擬函式。

# C++ 介面（抽象類）

介面描述了類的行為和功能，而不需要完成類的特定實現。

C++ 介面是使用**抽象類**來實現的，抽象類與數據抽象互不混淆，數據抽象是一個把實現細節與相關的數據分離開的概念。

如果類中至少有一個函式被聲明為純虛擬函式，則這個類就是抽象類。純虛擬函式是通過在聲明中使用 "= 0" 來指定的，如下所示：

```cpp
class Box{
   public:
      // 純虛擬函式
      virtual double getVolume() = 0;
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度};
```

設計**抽象類**（通常稱為 ABC）的目的，是為了給其他類提供一個可以繼承的適當的基類。抽象類不能被用於實體化物件，它只能作為**介面**使用。如果試圖實體化一個抽象類的物件，會導致編譯錯誤。

因此，如果一個 ABC 的子類需要被實體化，則必須實現每個虛擬函式，這也意味著 C++ 支援使用 ABC 聲明介面。如果沒有在派生類中多載純虛擬函式，就嘗試實體化該類的物件，會導致編譯錯誤。

可用於實體化物件的類被稱為**具體類**。

## 抽象類的實體

請看下面的實體，基類 Shape 提供了一個介面 **getArea()**，在兩個派生類 Rectangle 和 Triangle 中分別實現了 **getArea()**：

```cpp
#include <iostream>
 using namespace std;
 // 基類class Shape {public:
   // 提供介面框架的純虛擬函式
   virtual int getArea() = 0;
   void setWidth(int w)
   {
      width = w;
   }
   void setHeight(int h)
   {
      height = h;
   }protected:
   int width;
   int height;};
 // 派生類class Rectangle: public Shape{public:
   int getArea()
   { 
      return (width * height); 
   }};class Triangle: public Shape{public:
   int getArea()
   { 
      return (width * height)/2; 
   }};
 int main(void){
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   // 輸出物件的面積
   cout << "Total Rectangle area: " << Rect.getArea() << endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   // 輸出物件的面積
   cout << "Total Triangle area: " << Tri.getArea() << endl; 

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Total Rectangle area: 35Total Triangle area: 17
```

從上面的實體中，我們可以看到一個抽象類是如何定義一個介面 getArea()，兩個派生類是如何通過不同的計算面積的演演算法來實現這個相同的函式。

## 設計策略

面向物件的系統可能會使用一個抽象基類為所有的外部應用程式提供一個適當的、通用的、標準化的介面。然後，派生類通過繼承抽象基類，就把所有類似的操作都繼承下來。

外部應用程式提供的功能（即公有函式）在抽象基類中是以純虛擬函式的形式存在的。這些純虛擬函式在相應的派生類中被實現。

這個架構也使得新的應用程式可以很容易地被添加到系統中，即使是在系統被定義之後依然可以如此。

# C++ 檔案和流

到目前為止，我們已經使用了 **iostream** 標準庫，它提供了 **cin** 和 **cout** 方法分別用於從標準輸入讀取流和向標準輸出寫入流。

本教程介紹如何從檔案讀取流和向檔案寫入流。這就需要用到 C++ 中另一個標準庫 **fstream**，它定義了三個新的數據型別：

| 數據型別 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| ofstream | 該數據型別表示輸出檔案流，用於創建檔案並向檔案寫入資訊。     |
| ifstream | 該數據型別表示輸入檔案流，用於從檔案讀取資訊。               |
| fstream  | 該數據型別通常表示檔案流，且同時具有 ofstream 和 ifstream 兩種功能，這意味著它可以創建檔案，向檔案寫入資訊，從檔案讀取資訊。 |

要在 C++ 中進行檔案處理，必須在 C++ 原始碼檔案中包含頭檔案 <iostream> 和 <fstream>。

## 打開檔案

在從檔案讀取資訊或者向檔案寫入資訊之前，必須先打開檔案。**ofstream** 和 **fstream** 物件都可以用來打開檔案進行寫操作，如果只需要打開檔案進行讀操作，則使用 **ifstream** 物件。

下面是 open() 函式的標準語法，open() 函式是 fstream、ifstream 和 ofstream 物件的一個成員。

```cpp
void open(const char *filename, ios::openmode mode);
```

在這裡，**open()** 成員函式的第一參數指定要打開的檔案的名稱和位元元置，第二個參數定義檔案被打開的模式。

| 模式標誌   | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| ios::app   | 追加模式。所有寫入都追加到檔案末尾。                         |
| ios::ate   | 檔案打開後定位元元到檔案末尾。                                   |
| ios::in    | 打開檔案用於讀取。                                           |
| ios::out   | 打開檔案用於寫入。                                           |
| ios::trunc | 如果該檔案已經存在，其內容將在打開檔案之前被截斷，即把檔案長度設為 0。 |

您可以把以上兩種或兩種以上的模式結合使用。例如，如果您想要以寫入模式打開檔案，並希望截斷檔案，以防檔案已存在，那麼您可以使用下面的語法：

```cpp
ofstream outfile;outfile.open("file.dat", ios::out | ios::trunc );
```

類似地，您如果想要打開一個檔案用於讀寫，可以使用下面的語法：

```cpp
fstream  afile;afile.open("file.dat", ios::out | ios::in );
```

## 關閉檔案

當 C++ 程式終止時，它會自動關閉刷新所有流，釋放所有分配的記憶體，並關閉所有打開的檔案。但程式員應該養成一個好習慣，在程式終止前關閉所有打開的檔案。

下面是 close() 函式的標準語法，close() 函式是 fstream、ifstream 和 ofstream 物件的一個成員。

```cpp
void close();
```

## 寫入檔案

在 C++ 編程中，我們使用流插入運算子（ << ）向檔案寫入資訊，就像使用該運算子輸出資訊到螢幕上一樣。唯一不同的是，在這裡您使用的是 **ofstream** 或 **fstream** 物件，而不是 **cout** 物件。

## 讀取檔案

在 C++ 編程中，我們使用流提取運算子（ >> ）從檔案讀取資訊，就像使用該運算子從鍵盤輸入資訊一樣。唯一不同的是，在這裡您使用的是 **ifstream** 或 **fstream** 物件，而不是 **cin** 物件。

## 讀取 & 寫入實體

下面的 C++ 程式以讀寫模式打開一個檔案。在向檔案 afile.dat 寫入用戶輸入的資訊之後，程式從檔案讀取資訊，並將其輸出到螢幕上：

```cpp
#include <fstream>#include <iostream>using namespace std;
 int main (){
    
   char data[100];

   // 以寫模式打開檔案
   ofstream outfile;
   outfile.open("afile.dat");

   cout << "Writing to the file" << endl;
   cout << "Enter your name: "; 
   cin.getline(data, 100);

   // 向檔案寫入用戶輸入的數據
   outfile << data << endl;

   cout << "Enter your age: "; 
   cin >> data;
   cin.ignore();
   
   // 再次向檔案寫入用戶輸入的數據
   outfile << data << endl;

   // 關閉打開的檔案
   outfile.close();

   // 以讀模式打開檔案
   ifstream infile; 
   infile.open("afile.dat"); 
 
   cout << "Reading from the file" << endl; 
   infile >> data; 

   // 在螢幕上寫入數據
   cout << data << endl;
   
   // 再次從檔案讀取數據，並顯示它
   infile >> data; 
   cout << data << endl; 

   // 關閉打開的檔案
   infile.close();

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列輸入和輸出：

```cpp
$./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9
```

上面的實體中使用了 cin 物件的附加函式，比如 getline()函式從外部讀取一行，ignore() 函式會忽略掉之前讀語句留下的多餘字符。

## 檔案位元元置指標

**istream** 和 **ostream** 都提供了用於重新定位元元檔案位元元置指標的成員函式。這些成員函式包括關於 istream 的 **seekg**（"seek get"）和關於 ostream 的 **seekp**（"seek put"）。

seekg 和 seekp 的參數通常是一個長整型。第二個參數可以用於指定搜尋方向。搜尋方向可以是 **ios::beg**（預設的，從流的開頭開始定位元元），也可以是 **ios::cur**（從流的當前位元元置開始定位元元），也可以是 **ios::end**（從流的末尾開始定位元元）。

檔案位元元置指標是一個整數值，指定了從檔案的起始位元元置到指標所在位元元置的位元元組數。下面是關於定位元元 "get" 檔案位元元置指標的實體：

```cpp
// 定位元元到 fileObject 的第 n 個位元元組（假設是 ios::beg）fileObject.seekg( n );// 把檔案的讀指標從 fileObject 當前位元元置向後移 n 個位元元組fileObject.seekg( n, ios::cur );// 把檔案的讀指標從 fileObject 末尾往回移 n 個位元元組fileObject.seekg( n, ios::end );// 定位元元到 fileObject 的末尾fileObject.seekg( 0, ios::end );
```

# C++ 異常處理

異常是程式在執行期間產生的問題。C++ 異常是指在程式運行時發生的特殊情況，比如嘗試除以零的操作。

異常提供了一種轉移程式控制權的方式。C++ 異常處理涉及到三個關鍵字：**try、catch、throw**。

- **throw:** 當問題出現時，程式會拋出一個異常。這是通過使用 **throw** 關鍵字來完成的。
- **catch:** 在您想要處理問題的地方，通過異常處理程式捕獲異常。**catch** 關鍵字用於捕獲異常。
- **try:** **try** 塊中的程式碼標識將被啟用的特定異常。它後面通常跟著一個或多個 catch 塊。

如果有一個塊拋出一個異常，捕獲異常的方法會使用 **try** 和 **catch** 關鍵字。try 塊中放置可能拋出異常的程式碼，try 塊中的程式碼被稱為保護程式碼。使用 try/catch 語句的語法如下所示：

```cpp
try{
   // 保護程式碼}catch( ExceptionName e1 ){
   // catch 塊}catch( ExceptionName e2 ){
   // catch 塊}catch( ExceptionName eN ){
   // catch 塊}
```

如果 **try** 塊在不同的情境下會拋出不同的異常，這個時候可以嘗試羅列多個 **catch** 語句，用於捕獲不同型別的異常。

## 拋出異常

您可以使用 **throw** 語句在程式碼塊中的任何地方拋出異常。throw 語句的操作數可以是任意的表達式，表達式的結果的型別決定了拋出的異常的型別。

以下是嘗試除以零時拋出異常的實體：

```cpp
double division(int a, int b){
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);}
```

## 捕獲異常

**catch** 塊跟在 **try** 塊後面，用於捕獲異常。您可以指定想要捕捉的異常型別，這是由 catch 關鍵字後的括號內的異常聲明決定的。

```cpp
try{
   // 保護程式碼}catch( ExceptionName e ){
  // 處理 ExceptionName 異常的程式碼}
```

上面的程式碼會捕獲一個型別為 **ExceptionName** 的異常。如果您想讓 catch 塊能夠處理 try 塊拋出的任何型別的異常，則必須在異常聲明的括號內使用省略號 ...，如下所示：

```cpp
try{
   // 保護程式碼}catch(...){
  // 能處理任何異常的程式碼}
```

下面是一個實體，拋出一個除以零的異常，並在 catch 塊中捕獲該異常。

```cpp
#include <iostream>using namespace std;double division(int a, int b){
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);}int main (){
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }

   return 0;}
```

由於我們拋出了一個型別為 **const char\*** 的異常，因此，當捕獲該異常時，我們必須在 catch 塊中使用 const char*。當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Division by zero condition!
```

## C++ 標準的異常

C++ 提供了一系列標準的異常，定義在 **<exception>** 中，我們可以在程式中使用這些標準的異常。它們是以父子類層次結構組織起來的，如下所示：

![img](https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg)

下表是對上面層次結構中出現的每個異常的說明：

| 異常                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **std::exception**     | 該異常是所有標準 C++ 異常的父類。                            |
| std::bad_alloc         | 該異常可以通過 **new** 拋出。                                |
| std::bad_cast          | 該異常可以通過 **dynamic_cast** 拋出。                       |
| std::bad_exception     | 這在處理 C++ 程式中無法預期的異常時非常有用。                |
| std::bad_typeid        | 該異常可以通過 **typeid** 拋出。                             |
| **std::logic_error**   | 理論上可以通過讀取程式碼來檢測到的異常。                       |
| std::domain_error      | 當使用了一個無效的數學域時，會拋出該異常。                   |
| std::invalid_argument  | 當使用了無效的參數時，會拋出該異常。                         |
| std::length_error      | 當創建了太長的 std::string 時，會拋出該異常。                |
| std::out_of_range      | 該異常可以通過方法拋出，例如 std::vector 和 std::bitset<>::operator[]()。 |
| **std::runtime_error** | 理論上不可以通過讀取程式碼來檢測到的異常。                     |
| std::overflow_error    | 當發生數學上溢時，會拋出該異常。                             |
| std::range_error       | 當嘗試存儲超出範圍的值時，會拋出該異常。                     |
| std::underflow_error   | 當發生數學下溢時，會拋出該異常。                             |

## 定義新的異常

您可以通過繼承和多載 **exception** 類來定義新的異常。下面的實體演示瞭如何使用 std::exception 類來實現自己的異常：

```cpp
#include <iostream>#include <exception>using namespace std;struct MyException : public exception{
  const char * what () const throw ()
  {
    return "C++ Exception";
  }};
 int main(){
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的錯誤
  }}
```

這將產生以下結果：

```cpp
MyException caught
C++ Exception
```

在這裡，**what()** 是異常類提供的一個公共方法，它已被所有子異常類多載。這將返回異常產生的原因。

# C++ 動態記憶體

瞭解動態記憶體在 C++ 中是如何工作的是成為一名合格的 C++ 程式員必不可少的。C++ 程式中的記憶體分為兩個部分：

- **棧：**在函式內部聲明的所有變數都將佔用棧記憶體。
- **堆：**這是程式中未使用的記憶體，在程式運行時可用於動態分配記憶體。

很多時候，您無法提前預知需要多少記憶體來存儲某個定義變數中的特定資訊，所需記憶體的大小需要在運行時才能確定。

在 C++ 中，您可以使用特殊的運算子為給定型別的變數在運行時分配堆內的記憶體，這會返回所分配的空間地址。這種運算子即 **new** 運算子。

如果您不需要動態分配記憶體，可以使用 **delete** 運算子，刪除之前由 new 運算子分配的記憶體。

## new 和 delete 運算子

下面是使用 new 運算子來為任意的數據型別動態分配記憶體的通用語法：

```cpp
new data-type;
```

在這裡，**data-type** 可以是包括陣列在內的任意內置的數據型別，也可以是包括類或結構在內的用戶自定義的任何數據型別。讓我們先來看下內置的數據型別。例如，我們可以定義一個指向 double 型別的指標，然後請求記憶體，該記憶體在執行時被分配。我們可以按照下面的語句使用 **new** 運算子來完成這點：

```cpp
double* pvalue  = NULL; // 初始化為 null 的指標pvalue  = new double;   // 為變數請求記憶體
```

如果自由存儲區已被用完，可能無法成功分配記憶體。所以建議檢查 new 運算子是否返回 NULL 指標，並採取以下適當的操作：

```cpp
double* pvalue  = NULL;if( !(pvalue  = new double )){
   cout << "Error: out of memory." <<endl;
   exit(1);}
```

**malloc()** 函式在 C 語言中就出現了，在 C++ 中仍然存在，但建議儘量不要使用 malloc() 函式。new 與 malloc() 函式相比，其主要的優點是，new 不只是分配了記憶體，它還創建了物件。

在任何時候，當您覺得某個已經動態分配記憶體的變數不再需要使用時，您可以使用 delete 操作符釋放它所佔用的記憶體，如下所示：

```cpp
delete pvalue;        // 釋放 pvalue 所指向的記憶體
```

下面的實體中使用了上面的概念，演示瞭如何使用 new 和 delete 運算子：

```cpp
#include <iostream>using namespace std;int main (){
   double* pvalue  = NULL; // 初始化為 null 的指標
   pvalue  = new double;   // 為變數請求記憶體
 
   *pvalue = 29494.99;     // 在分配的地址存儲值
   cout << "Value of pvalue : " << *pvalue << endl;

   delete pvalue;         // 釋放記憶體

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Value of pvalue : 29495
```

## 陣列的動態記憶體分配

假設我們要為一個字符陣列（一個有 20 個字符的字串）分配記憶體，我們可以使用上面實體中的語法來為陣列動態地分配記憶體，如下所示：

```cpp
char* pvalue  = NULL;   // 初始化為 null 的指標pvalue  = new char[20]; // 為變數請求記憶體
```

要刪除我們剛才創建的陣列，語句如下：

```cpp
delete [] pvalue;        // 刪除 pvalue 所指向的陣列
```

下面是 new 操作符的通用語法，可以為多維陣列分配記憶體，如下所示：

```cpp
int ROW = 2;int COL = 3;double **pvalue  = new double* [ROW]; // 為行分配記憶體// 為列分配記憶體for(int i = 0; i < COL; i++) {
    pvalue[i] = new double[COL];}
```

釋放多維陣列記憶體：

```cpp
for(int i = 0; i < COL; i++) {
    delete[] pvalue[i];}delete [] pvalue;
```

## 物件的動態記憶體分配

物件與簡單的數據型別沒有什麼不同。例如，請看下面的程式碼，我們將使用一個物件陣列來理清這一概念：

```cpp
#include <iostream>using namespace std;class Box{
   public:
      Box() { 
         cout << "調用建構函式！" <<endl; 
      }
      ~Box() { 
         cout << "調用解構函式！" <<endl; 
      }};int main( ){
   Box* myBoxArray = new Box[4];

   delete [] myBoxArray; // Delete array

   return 0;}
```

如果要為一個包含四個 Box 物件的陣列分配記憶體，建構函式將被調用 4 次，同樣地，當刪除這些物件時，解構函式也將被調用相同的次數（4次）。

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
調用建構函式！調用建構函式！調用建構函式！調用建構函式！調用解構函式！調用解構函式！調用解構函式！調用解構函式！
```

# C++ 命名空間

假設這樣一種情況，當一個班上有兩個名叫 Zara 的學生時，為了明確區分它們，我們在使用名字之外，不得不使用一些額外的資訊，比如他們的家庭住址，或者他們父母的名字等等。

同樣的情況也出現在 C++ 應用程式中。例如，您可能會寫一個名為 xyz() 的函式，在另一個可用的庫中也存在一個相同的函式 xyz()。這樣，編譯器就無法判斷您所使用的是哪一個 xyz() 函式。

因此，引入了**命名空間**這個概念，專門用於解決上面的問題，它可作為附加資訊來區分不同庫中相同名稱的函式、類、變數等。使用了命名空間即定義了上下文。本質上，命名空間就是定義了一個範圍。

## 定義命名空間

命名空間的定義使用關鍵字 **namespace**，後跟命名空間的名稱，如下所示：

```cpp
namespace namespace_name {   // 程式碼聲明}
```

為了調用帶有命名空間的函式或變數，需要在前面加上命名空間的名稱，如下所示：

```cpp
name::code;  // code 可以是變數或函式
```

讓我們來看看命名空間如何為變數或函式等實體定義範圍：

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }}// 第二個命名空間namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }}int main (){
 
   // 調用第一個命名空間中的函式
   first_space::func();
   
   // 調用第二個命名空間中的函式
   second_space::func(); 

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Inside first_spaceInside second_space
```

## using 指令

您可以使用 **using namespace** 指令，這樣在使用命名空間時就可以不用在前面加上命名空間的名稱。這個指令會告訴編譯器，後續的程式碼將使用指定的命名空間中的名稱。

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }}// 第二個命名空間namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }}using namespace first_space;int main (){
 
   // 調用第一個命名空間中的函式
   func();
   
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Inside first_space
```

using 指令也可以用來指定命名空間中的特定專案。例如，如果您只打算使用 std 命名空間中的 cout 部分，您可以使用如下的語句：

```cpp
using std::cout;
```

隨後的程式碼中，在使用 cout 時就可以不用加上命名空間名稱作為前綴，但是 **std** 命名空間中的其他專案仍然需要加上命名空間名稱作為前綴，如下所示：

```cpp
#include <iostream>using std::cout;int main (){   
	cout << "std::endl is used with std!" << std::endl;      
	return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
std::endl is used with std!
```

**using** 指令引入的名稱遵循正常的範圍規則。名稱從使用 **using** 指令開始是可見的，直到該範圍結束。此時，在範圍以外定義的同名實體是隱藏的。

## 不連續的命名空間

命名空間可以定義在幾個不同的部分中，因此命名空間是由幾個單獨定義的部分組成的。一個命名空間的各個組成部分可以分散在多個檔案中。

所以，如果命名空間中的某個組成部分需要請求定義在另一個檔案中的名稱，則仍然需要聲明該名稱。下面的命名空間定義可以是定義一個新的命名空間，也可以是為已有的命名空間增加新的元素：

```cpp
namespace namespace_name {
   // 程式碼聲明}
```

## 嵌套的命名空間

命名空間可以嵌套，您可以在一個命名空間中定義另一個命名空間，如下所示：

```cpp
namespace namespace_name1 {
   // 程式碼聲明
   namespace namespace_name2 {
      // 程式碼聲明
   }}
```

您可以通過使用 :: 運算子來訪問嵌套的命名空間中的成員：

```cpp
// 訪問 namespace_name2 中的成員using namespace namespace_name1::namespace_name2;// 訪問 namespace:name1 中的成員using namespace namespace_name1;
```

在上面的語句中，如果使用的是 namespace_name1，那麼在該範圍內 namespace_name2 中的元素也是可用的，如下所示：

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
   // 第二個命名空間
   namespace second_space{
      void func(){
         cout << "Inside second_space" << endl;
      }
   }}using namespace first_space::second_space;int main (){
 
   // 調用第二個命名空間中的函式
   func();
   
   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Inside second_space
```

# C++ 樣板

樣板是泛型編程的基礎，泛型編程即以一種獨立於任何特定型別的方式編寫程式碼。

樣板是創建泛型類或函式的藍圖或公式。庫容器，比如疊代器和演演算法，都是泛型編程的例子，它們都使用了樣板的概念。

每個容器都有一個單一的定義，比如 **向量**，我們可以定義許多不同型別的向量，比如 **vector <int>** 或 **vector <string>**。

您可以使用樣板來定義函式和類，接下來讓我們一起來看看如何使用。

## 函式樣板

樣板函式定義的一般形式如下所示：

```cpp
template <class type> ret-type func-name(parameter list){   // 函式的主體}
```

在這裡，type 是函式所使用的數據型別的佔位元元符名稱。這個名稱可以在函式定義中使用。

下面是函式樣板的實體，返回兩個數種的最大值：

```cpp
#include <iostream>#include <string>using namespace std;template <typename T>inline T const& Max (T const& a, T const& b) { 
    return a < b ? b:a; } int main (){
 
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 

    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 

    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Max(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World
```

## 類樣板

正如我們定義函式樣板一樣，我們也可以定義類樣板。泛型類聲明的一般形式如下所示：

```cpp
template <class type> class class-name {...}
```

在這裡，**type** 是佔位元元符型別名稱，可以在類被實體化的時候進行指定。您可以使用一個逗號分隔的列表來定義多個泛型數據型別。

下面的實體定義了類 Stack<>，並實現了泛型方法來對元素進行入棧出棧操作：

```cpp
#include <iostream>#include <vector>#include <cstdlib>#include <string>#include <stdexcept>using namespace std;template <class T>class Stack { 
  private: 
    vector<T> elems;     // 元素 

  public: 
    void push(T const&);  // 入棧
    void pop();               // 出棧
    T top() const;            // 返回棧頂元素
    bool empty() const{       // 如果為空則返回真。
        return elems.empty(); 
    } }; template <class T>void Stack<T>::push (T const& elem) { 
    // 追加傳入元素的副本
    elems.push_back(elem);    } template <class T>void Stack<T>::pop () { 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
	// 刪除最後一個元素
    elems.pop_back();         } template <class T>T Stack<T>::top () const { 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
	// 返回最後一個元素的副本 
    return elems.back();      } int main() { 
    try { 
        Stack<int>         intStack;  // int 型別的棧 
        Stack<string> stringStack;    // string 型別的棧 

        // 操作 int 型別的棧 
        intStack.push(7); 
        cout << intStack.top() <<endl; 

        // 操作 string 型別的棧 
        stringStack.push("hello"); 
        cout << stringStack.top() << std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    } 
    catch (exception const& ex) { 
        cerr << "Exception: " << ex.what() <<endl; 
        return -1;
    } }
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
7helloException: Stack<>::pop(): empty stack
```

# C++ 預處理器

預處理器是一些指令，指示編譯器在實際編譯之前所需完成的預處理。

所有的預處理器指令都是以井號（#）開頭，只有空格字符可以出現在預處理指令之前。預處理指令不是 C++ 語句，所以它們不會以分號（;）結尾。

我們已經看到，之前所有的實體中都有 **#include** 指令。這個巨集用於把頭檔案包含到原始檔中。

C++ 還支援很多預處理指令，比如 #include、#define、#if、#else、#line 等，讓我們一起看看這些重要指令。

## #define 預處理

\#define 預處理指令用於創建符號常數。該符號常數通常稱為**巨集**，指令的一般形式是：

```cpp
#define macro-name replacement-text
```

當這一行程式碼出現在一個檔案中時，在該檔案中後續出現的所有巨集都將會在程式編譯之前被替換為 replacement-text。例如：

```cpp
#include <iostream>using namespace std;#define PI 3.14159int main (){     cout << "Value of PI :" << PI << endl;     return 0;}
```

現在，讓我們測試這段程式碼，看看預處理的結果。假設原始碼檔案已經存在，接下來使用 -E 選項進行編譯，並把結果重定向到 test.p。現在，如果您查看 test.p 檔案，將會看到它已經包含大量的資訊，而且在檔案底部的值被改為如下：

```cpp
$gcc -E test.cpp > test.p...int main (){     cout << "Value of PI :" << 3.14159 << endl;     return 0;}
```

## 函式巨集

您可以使用 #define 來定義一個帶有參數的巨集，如下所示：

```cpp
#include <iostream>using namespace std;#define MIN(a,b) (a<b ? a : b)int main (){
   int i, j;
   i = 100;
   j = 30;
   cout <<"較小的值為：" << MIN(i, j) << endl;

    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
較小的值為：30
```

## 條件編譯

有幾個指令可以用來有選擇地對部分程式原始碼進行編譯。這個過程被稱為條件編譯。

條件預處理器的結構與 if 選擇結構很像。請看下面這段預處理器的程式碼：

```cpp
#ifndef NULL   #define NULL 0#endif
```

您可以只在除錯時進行編譯，除錯開關可以使用一個巨集來實現，如下所示：

```cpp
#ifdef DEBUG   cerr <<"Variable x = " << x << endl;#endif
```

如果在指令 #ifdef DEBUG 之前已經定義了符號常數 DEBUG，則會對程式中的 **cerr** 語句進行編譯。您可以使用 #if 0 語句註釋掉程式的一部分，如下所示：

```cpp
#if 0   不進行編譯的程式碼#endif
```

讓我們嘗試下面的實體：

```cpp
#include <iostream>using namespace std;#define DEBUG#define MIN(a,b) (((a)<(b)) ? a : b)int main (){
   int i, j;
   i = 100;
   j = 30;#ifdef DEBUG
   cerr <<"Trace: Inside main function" << endl;#endif#if 0
   /* 這是註釋部分 */
   cout << MKSTR(HELLO C++) << endl;#endif

   cout <<"The minimum is " << MIN(i, j) << endl;#ifdef DEBUG
   cerr <<"Trace: Coming out of main function" << endl;#endif
    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Trace: Inside main functionThe minimum is 30Trace: Coming out of main function
```

## # 和 ## 運算子

\# 和 ## 預處理運算子在 C++ 和 ANSI/ISO C 中都是可用的。# 運算子會把 replacement-text 令牌轉換為用引號引起來的字串。

請看下面的巨集定義：

```cpp
#include <iostream>using namespace std;#define MKSTR( x ) #xint main (){    cout << MKSTR(HELLO C++) << endl;    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
HELLO C++
```

讓我們來看看它是如何工作的。不難理解，C++ 預處理器把下面這行：

```cpp
cout << MKSTR(HELLO C++) << endl;
```

轉換成了：

```cpp
cout << "HELLO C++" << endl;
```

\## 運算子用於連接兩個令牌。下面是一個實體：

```cpp
#define CONCAT( x, y )  x ## y
```

當 CONCAT 出現在程式中時，它的參數會被連接起來，並用來取代巨集。例如，程式中 CONCAT(HELLO, C++) 會被替換為 "HELLO C++"，如下面實體所示。

```cpp
#include <iostream>using namespace std;#define concat(a, b) a ## bint main(){   int xy = 100;      cout << concat(x, y);   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
100
```

讓我們來看看它是如何工作的。不難理解，C++ 預處理器把下面這行：

```cpp
cout << concat(x, y);
```

轉換成了：

```cpp
cout << xy;
```

## C++ 中的預定義巨集

C++ 提供了下表所示的一些預定義巨集：

| 巨集       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| __LINE__ | 這會在程式編譯時包含當前行號。                               |
| __FILE__ | 這會在程式編譯時包含當前檔案名。                             |
| __DATE__ | 這會包含一個形式為 month/day/year 的字串，它表示把原始檔轉換為目標程式碼的日期。 |
| __TIME__ | 這會包含一個形式為 hour:minute:second 的字串，它表示程式被編譯的時間。 |

讓我們看看上述這些巨集的實體：

```cpp
#include <iostream>using namespace std;int main (){
    cout << "Value of __LINE__ : " << __LINE__ << endl;
    cout << "Value of __FILE__ : " << __FILE__ << endl;
    cout << "Value of __DATE__ : " << __DATE__ << endl;
    cout << "Value of __TIME__ : " << __TIME__ << endl;

    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Value of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48
```

# C++ 信號處理

信號是由作業系統傳給行程的中斷，會提早終止一個程式。在 UNIX、LINUX、Mac OS X 或 Windows 系統上，可以通過按 Ctrl+C 產生中斷。

有些信號不能被程式捕獲，但是下表所列信號可以在程式中捕獲，並可以基於信號採取適當的動作。這些信號是定義在 C++ 頭檔案 <csignal> 中。

| 信號    | 描述                                         |
| :------ | :------------------------------------------- |
| SIGABRT | 程式的異常終止，如調用 **abort**。           |
| SIGFPE  | 錯誤的算術運算，比如除以零或導致溢出的操作。 |
| SIGILL  | 檢測非法指令。                               |
| SIGINT  | 接收到交互注意信號。                         |
| SIGSEGV | 非法訪問記憶體。                               |
| SIGTERM | 發送到程式的終止請求。                       |

## signal() 函式

C++ 信號處理庫提供了 **signal** 函式，用來捕獲突發事件。以下是 signal() 函式的語法：

```cpp
void (*signal (int sig, void (*func)(int)))(int);
```

這個函式接收兩個參數：第一個參數是一個整數，代表了信號的編號；第二個參數是一個指向信號處理函式的指標。

讓我們編寫一個簡單的 C++ 程式，使用 signal() 函式捕獲 SIGINT 信號。不管您想在程式中捕獲什麼信號，您都必須使用 **signal** 函式來註冊信號，並將其與信號處理程式相關聯。看看下面的實體：

```cpp
#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){
    cout << "Interrupt signal (" << signum << ") received.\n";

    // 清理並關閉
    // 終止程式  

   exit(signum);  }int main (){
    // 註冊信號 SIGINT 和信號處理程式
    signal(SIGINT, signalHandler);  

    while(1){
       cout << "Going to sleep...." << endl;
       sleep(1);
    }

    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
Going to sleep....Going to sleep....Going to sleep....
```

現在，按 Ctrl+C 來中斷程式，您會看到程式捕獲信號，程式印出如下內容並退出：

```cpp
Going to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.
```

## raise() 函式

您可以使用函式 **raise()** 生成信號，該函式帶有一個整數信號編號作為參數，語法如下：

```cpp
int raise (signal sig);
```

在這裡，**sig** 是要發送的信號的編號，這些信號包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我們使用 raise() 函式內部生成信號的實體：

```cpp
#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){
    cout << "Interrupt signal (" << signum << ") received.\n";

    // 清理並關閉
    // 終止程式 

   exit(signum);  }int main (){
    int i = 0;
    // 註冊信號 SIGINT 和信號處理程式
    signal(SIGINT, signalHandler);  

    while(++i){
       cout << "Going to sleep...." << endl;
       if( i == 3 ){
          raise( SIGINT);
       }
       sleep(1);
    }

    return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果，並會自動退出：

```cpp
Going to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.
```

# C++ 多執行緒

多執行緒是多任務處理的一種特殊形式，多任務處理允許讓電腦同時運行兩個或兩個以上的程式。一般情況下，兩種型別的多任務處理：**基於行程和基於執行緒**。

- 基於行程的多任務處理是程式的併發執行。
- 基於執行緒的多任務處理是同一程式的片段的併發執行。

多執行緒程式包含可以同時運行的兩個或多個部分。這樣的程式中的每個部分稱為一個執行緒，每個執行緒定義了一個單獨的執行路徑。

本教程假設您使用的是 Linux 作業系統，我們要使用 POSIX 編寫多執行緒 C++ 程式。POSIX Threads 或 Pthreads 提供的 API 可在多種類 Unix POSIX 系統上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

## 創建執行緒

下面的程式，我們可以用它來創建一個 POSIX 執行緒：

```cpp
#include <pthread.h>pthread_create (thread, attr, start_routine, arg)
```

在這裡，**pthread_create** 創建一個新的執行緒，並讓它可執行。下面是關於參數的說明：

| 參數          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向執行緒標識符指標。                                         |
| attr          | 一個不透明的屬性物件，可以被用來設置執行緒屬性。您可以指定執行緒屬性物件，也可以使用預設值 NULL。 |
| start_routine | 執行緒運行函式起始地址，一旦執行緒被創建就會執行。               |
| arg           | 運行函式的參數。它必須通過把參照作為指標強制轉換為 void 型別進行傳遞。如果沒有傳遞參數，則使用 NULL。 |

創建執行緒成功時，函式返回 0，若回傳值不為 0 則說明創建執行緒失敗。

## 終止執行緒

使用下面的程式，我們可以用它來終止一個 POSIX 執行緒：

```cpp
#include <pthread.h>pthread_exit (status)
```

在這裡，**pthread_exit** 用於顯式地退出一個執行緒。通常情況下，pthread_exit() 函式是在執行緒完成工作後無需繼續存在時被調用。

如果 main() 是在它所創建的執行緒之前結束，並通過 pthread_exit() 退出，那麼其他執行緒將繼續執行。否則，它們將在 main() 結束時自動被終止。

## 實體

以下簡單的實體程式碼使用 pthread_create() 函式創建了 5 個執行緒，每個執行緒輸出"Hello Runoob！":

```cpp
#include <iostream>// 必須的頭檔案是#include <pthread.h>using namespace std;#define NUM_THREADS 5// 執行緒的運行函式void* say_hello(void* args){
    cout << "Hello Runoob！" << endl;}int main(){
    // 定義執行緒的 id 變數，多個變數使用陣列
    pthread_t tids[NUM_THREADS];
    for(int i = 0; i < NUM_THREADS; ++i)
    {
        //參數依次是：創建的執行緒id，執行緒參數，調用的函式，傳入的函式參數
        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);
        if (ret != 0)
        {
           cout << "pthread_create error: error_code=" << ret << endl;
        }
    }
    //等各個執行緒退出後，行程才結束，否則行程強制結束了，執行緒可能還沒反應過來；
    pthread_exit(NULL);}
```

使用 -lpthread 庫編譯下面的程式：

```cpp
$ g++ test.cpp -lpthread -o test.o
```

現在，執行程式，將產生下列結果：

```cpp
$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！
```

以下簡單的實體程式碼使用 pthread_create() 函式創建了 5 個執行緒，並接收傳入的參數。每個執行緒印出一個 "Hello Runoob!" 消息，並輸出接收的參數，然後調用 pthread_exit() 終止執行緒。

```cpp
//檔案名：test.cpp#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid){  
   // 對傳入的參數進行強制型別轉換，由無型別指標變為整形數指標，然後再讀取
   int tid = *((int*)threadid);
   cout << "Hello Runoob! 執行緒 ID, " << tid << endl;
   pthread_exit(NULL);}int main (){
   pthread_t threads[NUM_THREADS];
   int indexes[NUM_THREADS];// 用陣列來保存i的值
   int rc;
   int i;
   for( i=0; i < NUM_THREADS; i++ ){      
      cout << "main() : 創建執行緒, " << i << endl;
      indexes[i] = i; //先保存i的值
      // 傳入的時候必須強制轉換為void* 型別，即無型別指標        
      rc = pthread_create(&threads[i], NULL, 
                          PrintHello, (void *)&(indexes[i]));
      if (rc){
         cout << "Error:無法創建執行緒," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);}
```

現在編譯並執行程式，將產生下列結果：

```cpp
$ g++ test.cpp -lpthread -o test.o$ ./test.omain() : 創建執行緒, 0main() : 創建執行緒, 1main() : 創建執行緒, 2main() : 創建執行緒, 3main() : 創建執行緒, 4Hello Runoob! 執行緒 ID, 4Hello Runoob! 執行緒 ID, 3Hello Runoob! 執行緒 ID, 2Hello Runoob! 執行緒 ID, 1Hello Runoob! 執行緒 ID, 0
```

## 向執行緒傳遞參數

這個實體演示瞭如何通過結構傳遞多個參數。您可以在執行緒回呼中傳遞任意的數據型別，因為它指向 void，如下面的實體所示：

```cpp
#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5struct thread_data{   int  thread_id;   char *message;};void *PrintHello(void *threadarg){   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout << "Thread ID : " << my_data->thread_id ;   cout << " Message : " << my_data->message << endl;   pthread_exit(NULL);}int main (){   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i < NUM_THREADS; i++ ){      cout <<"main() : creating thread, " << i << endl;      td[i].thread_id = i;      td[i].message = "This is message";      rc = pthread_create(&threads[i], NULL,                          PrintHello, (void *)&td[i]);      if (rc){         cout << "Error:unable to create thread," << rc << endl;         exit(-1);      }   }   pthread_exit(NULL);}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
$ g++ test.cpp -lpthread -o test.o
$ ./test.o
main() : 創建執行緒, 0main() : 創建執行緒, 1main() : 創建執行緒, 2main() : 創建執行緒, 3main() : 創建執行緒, 4Hello Runoob! 執行緒 ID, 4Hello Runoob! 執行緒 ID, 3Hello Runoob! 執行緒 ID, 2Hello Runoob! 執行緒 ID, 1Hello Runoob! 執行緒 ID, 0
```

## 連接和分離執行緒

我們可以使用以下兩個函式來連接或分離執行緒：

```cpp
pthread_join (threadid, status) pthread_detach (threadid)
```

pthread_join() 子程式阻礙調用程式，直到指定的 threadid 執行緒終止為止。當創建一個執行緒時，它的某個屬性會定義它是否是可連接的（joinable）或可分離的（detached）。只有創建時定義為可連接的執行緒才可以被連接。如果執行緒創建時被定義為可分離的，則它永遠也不能被連接。

這個實體演示瞭如何使用 pthread_join() 函式來等待執行緒的完成。

```cpp
#include <iostream>#include <cstdlib>#include <pthread.h>#include <unistd.h>using namespace std;#define NUM_THREADS     5void *wait(void *t){
   int i;
   long tid;

   tid = (long)t;

   sleep(1);
   cout << "Sleeping in thread " << endl;
   cout << "Thread with id : " << tid << "  ...exiting " << endl;
   pthread_exit(NULL);}int main (){
   int rc;
   int i;
   pthread_t threads[NUM_THREADS];
   pthread_attr_t attr;
   void *status;

   // 初始化並設置執行緒為可連接的（joinable）
   pthread_attr_init(&attr);
   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

   for( i=0; i < NUM_THREADS; i++ ){
      cout << "main() : creating thread, " << i << endl;
      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }

   // 刪除屬性，並等待其他執行緒
   pthread_attr_destroy(&attr);
   for( i=0; i < NUM_THREADS; i++ ){
      rc = pthread_join(threads[i], &status);
      if (rc){
         cout << "Error:unable to join," << rc << endl;
         exit(-1);
      }
      cout << "Main: completed thread id :" << i ;
      cout << "  exiting with status :" << status << endl;
   }

   cout << "Main: program exiting." << endl;
   pthread_exit(NULL);}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
main() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread 
Thread with id : 4  ...exiting 
Sleeping in thread 
Thread with id : 3  ...exiting 
Sleeping in thread 
Thread with id : 2  ...exiting 
Sleeping in thread 
Thread with id : 1  ...exiting 
Sleeping in thread 
Thread with id : 0  ...exiting 
Main: completed thread id :0  exiting with status :0Main: completed thread id :1  exiting with status :0Main: completed thread id :2  exiting with status :0Main: completed thread id :3  exiting with status :0Main: completed thread id :4  exiting with status :0Main: program exiting.
```

# C++ Web 編程

## 什麼是 CGI？

- 公共網關介面（CGI），是一套標準，定義了資訊是如何在 Web 伺服器和用戶端腳本之間進行交換的。
- CGI 規範目前是由 NCSA 維護的，NCSA 定義 CGI 如下：
- 公共網關介面（CGI），是一種用於外部網關程式與資訊伺服器（如 HTTP 伺服器）對接的介面標準。
- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推進中。

## Web 瀏覽

為了更好地瞭解 CGI 的概念，讓我們點擊一個超連結，瀏覽一個特定的網頁或 URL，看看會發生什麼。

- 您的瀏覽器聯繫上 HTTP Web 伺服器，並請求 URL，即檔案名。
- Web 伺服器將解析 URL，並搜尋檔案名。如果找到請求的檔案，Web 伺服器會把檔案發送回瀏覽器，否則發送一條錯誤消息，表明您請求了一個錯誤的檔案。
- Web 瀏覽器從 Web 伺服器獲取響應，並根據接收到的響應來顯示檔案或錯誤消息。

然而，以這種方式搭建起來的 HTTP 伺服器，不管何時請求目錄中的某個檔案，HTTP 伺服器發送回來的不是該檔案，而是以程式形式執行，並把執行產生的輸出發送回瀏覽器顯示出來。

公共網關介面（CGI），是使得應用程式（稱為 CGI 程式或 CGI 腳本）能夠與 Web 伺服器以及用戶端進行交互的標準協議。這些 CGI 程式可以用 Python、PERL、Shell、C 或 C++ 等進行編寫。

## CGI 架構圖

下圖演示了 CGI 的架構：

![img](https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif)

## Web 伺服器配置

在您進行 CGI 編程之前，請確保您的 Web 伺服器支援 CGI，並已配置成可以處理 CGI 程式。所有由 HTTP 伺服器執行的 CGI 程式，都必須在預配置的目錄中。該目錄稱為 CGI 目錄，按照慣例命名為 /var/www/cgi-bin。雖然 CGI 檔案是 C++ 可執行檔案，但是按照慣例它的擴展名是 **.cgi**。

預設情況下，Apache Web 伺服器會配置在 /var/www/cgi-bin 中運行 CGI 程式。如果您想指定其他目錄來運行 CGI 腳本，您可以在 httpd.conf 檔案中修改以下部分：

```cpp
<Directory "/var/www/cgi-bin">   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all</Directory> <Directory "/var/www/cgi-bin">Options All</Directory>
```

在這裡，我們假設已經配置好 Web 伺服器並能成功運行，你可以運行任意的 CGI 程式，比如 Perl 或 Shell 等。

## 第一個 CGI 程式

請看下面的 C++ 程式：

```cpp
#include <iostream>using namespace std;
 int main (){
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - 第一個 CGI 程式</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! 這是我的第一個 CGI 程式</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

編譯上面的程式碼，把可執行檔案命名為 cplusplus.cgi，並把這個檔案保存在 /var/www/cgi-bin 目錄中。在運行 CGI 程式之前，請使用 **chmod 755 cplusplus.cgi** UNIX 命令來修改檔案模式，確保檔案可執行。訪問可執行檔案，您會看到下面的輸出：

## Hello World! 這是我的第一個 CGI 程式

上面的 C++ 程式是一個簡單的程式，把它的輸出寫在 STDOUT 檔案上，即顯示在螢幕上。在這裡，值得注意一點，第一行輸出 **Content-type:text/html\r\n\r\n**。這一行發送回瀏覽器，並指定要顯示在瀏覽器窗口上的內容型別。您必須理解 CGI 的基本概念，這樣才能進一步使用 Python 編寫更多複雜的 CGI 程式。C++ CGI 程式可以與任何其他外部的系統（如 RDBMS）進行交互。

## HTTP 頭資訊

行 **Content-type:text/html\r\n\r\n** 是 HTTP 頭資訊的組成部分，它被髮送到瀏覽器，以便更好地理解頁面內容。HTTP 頭資訊的形式如下：

```cpp
HTTP 字段名稱: 字段內容 例如Content-type: text/html\r\n\r\n
```

還有一些其他的重要的 HTTP 頭資訊，這些在您的 CGI 編程中都會經常被用到。

| 頭資訊              | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| Content-type:       | MIME 字串，定義返回的檔案格式。例如 Content-type:text/html。 |
| Expires: Date       | 資訊變成無效的日期。瀏覽器使用它來判斷一個頁面何時需要刷新。一個有效的日期字串的格式應為 01 Jan 1998 12:00:00 GMT。 |
| Location: URL       | 這個 URL 是指應該返回的 URL，而不是請求的 URL。你可以使用它來重定向一個請求到任意的檔案。 |
| Last-modified: Date | 資源的最後修改日期。                                         |
| Content-length: N   | 要返回的數據的長度，以位元元組為單位元元。瀏覽器使用這個值來表示一個檔案的預計下載時間。 |
| Set-Cookie: String  | 通過 *string* 設置 cookie。                                  |

## CGI 環境變數

所有的 CGI 程式都可以訪問下列的環境變數。這些變數在編寫 CGI 程式時扮演了非常重要的角色。

| 變數名          | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| CONTENT_TYPE    | 內容的數據型別。當用戶端向伺服器發送附加內容時使用。例如，檔案上傳等功能。 |
| CONTENT_LENGTH  | 查詢的資訊長度。只對 POST 請求可用。                         |
| HTTP_COOKIE     | 以鍵 & 值對的形式返回設置的 cookies。                        |
| HTTP_USER_AGENT | 用戶代理請求標頭字段，遞交用戶發起請求的有關資訊，包含了瀏覽器的名稱、版本和其他平臺性的附加資訊。 |
| PATH_INFO       | CGI 腳本的路徑。                                             |
| QUERY_STRING    | 通過 GET 方法發送請求時的 URL 編碼資訊，包含 URL 中問號後面的參數。 |
| REMOTE_ADDR     | 發出請求的遠程主機的 IP 地址。這在日誌記錄和認證時是非常有用的。 |
| REMOTE_HOST     | 發出請求的主機的完全限定名稱。如果此資訊不可用，則可以用 REMOTE_ADDR 來獲取 IP 地址。 |
| REQUEST_METHOD  | 用於發出請求的方法。最常見的方法是 GET 和 POST。             |
| SCRIPT_FILENAME | CGI 腳本的完整路徑。                                         |
| SCRIPT_NAME     | CGI 腳本的名稱。                                             |
| SERVER_NAME     | 伺服器的主機名或 IP 地址。                                   |
| SERVER_SOFTWARE | 伺服器上運行的軟體的名稱和版本。                             |

下面的 CGI 程式列出了所有的 CGI 變數。

```cpp
#include <iostream>#include <stdlib.h>using namespace std;const string ENV[ 24 ] = {                 
        "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",   
        "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",    &nbsnbsp;        
        "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",         
        "HTTP_HOST", "HTTP_USER_AGENT", "PATH",            
        "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",      
        "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
        "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",      
        "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",     
        "SERVER_SIGNATURE","SERVER_SOFTWARE" };   int main (){
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 環境變數</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";

   for ( int i = 0; i < 24; i++ )
   {
       cout << "<tr><td>" << ENV[ i ] << "</td><td>";
       // 嘗試檢索環境變數的值
       char *value = getenv( ENV[ i ].c_str() );  
       if ( value != 0 ){
         cout << value;                                 
       }else{
         cout << "環境變數不存在。";
       }
       cout << "</td></tr>\n";
   }
   cout << "</table><\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## C++ CGI 庫

在真實的實體中，您需要通過 CGI 程式執行許多操作。這裡有一個專為 C++ 程式而編寫的 CGI 庫，我們可以從 [ftp://ftp.gnu.org/gnu/cgicc/](ftp://ftp.gnu.org/gnu/cgicc/) 上下載這個 CGI 庫，並按照下面的步驟安裝庫：

```cpp
$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install
```

您可以點擊 C++ CGI Lib Documentation，查看相關的庫文件。

## GET 和 POST 方法

您可能有遇到過這樣的情況，當您需要從瀏覽器傳遞一些資訊到 Web 伺服器，最後再傳到 CGI 程式。通常瀏覽器會使用兩種方法把這個資訊傳到 Web 伺服器，分別是 GET 和 POST 方法。

## 使用 GET 方法傳遞資訊

GET 方法發送已編碼的用戶資訊追加到頁面請求中。頁面和已編碼資訊通過 ? 字符分隔開，如下所示：

```cpp
http://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2
```

GET 方法是預設的從瀏覽器向 Web 伺服器傳資訊的方法，它會在瀏覽器的地址欄中生成一串很長的字串。當您向伺服器傳密碼或其他一些敏感資訊時，不要使用 GET 方法。GET 方法有大小限制，在一個請求字串中最多可以傳 1024 個字符。

當使用 GET 方法時，是使用 QUERY_STRING http 頭來傳遞資訊，在 CGI 程式中可使用 QUERY_STRING 環境變數來訪問。

您可以通過在 URL 後跟上簡單連接的鍵值對，也可以通過使用 HTML <FORM> 標籤的 GET 方法來傳資訊。

## 簡單的 URL 實體：Get 方法

下面是一個簡單的 URL，使用 GET 方法傳遞兩個值給 hello_get.py 程式。

/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI

下面的實體生成 **cpp_get.cgi** CGI 程式，用於處理 Web 瀏覽器給出的輸入。通過使用 C++ CGI 庫，可以很容易地訪問傳遞的資訊：

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>  using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
   
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>使用 GET 和 POST 方法</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("first_name");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "名：" << **fi << endl;  
   }else{
      cout << "No text entered for first name" << endl;  
   }
   cout << "<br/>\n";
   fi = formData.getElement("last_name");  
   if( !fi->isEmpty() &&fi != (*formData).end()) {  
      cout << "姓：" << **fi << endl;  
   }else{
      cout << "No text entered for last name" << endl;  
   }
   cout << "<br/>\n";

   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

現在，編譯上面的程式，如下所示：

```cpp
$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc
```

生成 cpp_get.cgi，並把它放在 CGI 目錄中，並嘗試使用下面的連結進行訪問：

/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI

這會產生以下結果：

```cpp
名：ZARA 姓：ALI
```

## 簡單的表單實體：GET 方法

下面是一個簡單的實體，使用 HTML 表單和提交按鈕傳遞兩個值。我們將使用相同的 CGI 腳本 cpp_get.cgi 來處理輸入。

```cpp
<form action="/cgi-bin/cpp_get.cgi" method="get">名：<input type="text" name="first_name">  <br /> 姓：<input type="text" name="last_name" /><input type="submit" value="提交" /></form>
```

下面是上述表單的實際輸出，請輸入名和姓，然後點擊提交按鈕查看結果。

## 使用 POST 方法傳遞資訊

一個更可靠的向 CGI 程式傳遞資訊的方法是 POST 方法。這種方法打包資訊的方式與 GET 方法相同，不同的是，它不是把資訊以文本字串形式放在 URL 中的 ? 之後進行傳遞，而是把它以單獨的消息形式進行傳遞。該消息是以標準輸入的形式傳給 CGI 腳本的。

我們同樣使用 cpp_get.cgi 程式來處理 POST 方法。讓我們以同樣的例子，通過使用 HTML 表單和提交按鈕來傳遞兩個值，只不過這次我們使用的不是 GET 方法，而是 POST 方法，如下所示：

```cpp
<form action="/cgi-bin/cpp_get.cgi" method="post">名：<input type="text" name="first_name"><br />姓：<input type="text" name="last_name" /> <input type="submit" value="提交" /></form>
```

## 向 CGI 程式傳遞複選框數據

當需要選擇多個選項時，我們使用複選框。

下面的 HTML 程式碼實體是一個帶有兩個複選框的表單：

```html
<form action="/cgi-bin/cpp_checkbox.cgi" 
         method="POST" 
         target="_blank"><input type="checkbox" name="maths" value="on" /> 數學<input type="checkbox" name="physics" value="on" /> 物理<input type="submit" value="選擇學科" /></form>
```

下面的 C++ 程式會生成 cpp_checkbox.cgi 腳本，用於處理 Web 瀏覽器通過複選框給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
   bool maths_flag, physics_flag;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程式傳遞複選框數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   maths_flag = formData.queryCheckbox("maths");
   if( maths_flag ) {  
      cout << "Maths Flag: ON " << endl;  
   }else{
      cout << "Maths Flag: OFF " << endl;  
   }
   cout << "<br/>\n";

   physics_flag = formData.queryCheckbox("physics");
   if( physics_flag ) {  
      cout << "Physics Flag: ON " << endl;  
   }else{
      cout << "Physics Flag: OFF " << endl;  
   }
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程式傳遞單選按鈕數據

當只需要選擇一個選項時，我們使用單選按鈕。

下面的 HTML 程式碼實體是一個帶有兩個單選按鈕的表單：

```cpp
<form action="/cgi-bin/cpp_radiobutton.cgi" 
         method="post" 
         target="_blank"><input type="radio" name="subject" value="maths" 
                                    checked="checked"/> 數學 
<input type="radio" name="subject" value="physics" /> 物理<input type="submit" value="選擇學科" /></form>
```

下面的 C++ 程式會生成 cpp_radiobutton.cgi 腳本，用於處理 Web 瀏覽器通過單選按鈕給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程式傳遞單選按鈕數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("subject");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Radio box selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程式傳遞文本區域數據

當需要向 CGI 程式傳遞多行文本時，我們使用 TEXTAREA 元素。

下面的 HTML 程式碼實體是一個帶有 TEXTAREA 框的表單：

```
<form action="/cgi-bin/cpp_textarea.cgi" 
         method="post" 
         target="_blank"><textarea name="textcontent" cols="40" rows="4">請在這裡輸入文本...</textarea><input type="submit" value="提交" /></form>
```

下面的 C++ 程式會生成 cpp_textarea.cgi 腳本，用於處理 Web 瀏覽器通過文本區域給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程式傳遞文本區域數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("textcontent");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Text Content: " << **fi << endl;  
   }else{
      cout << "No text entered" << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程式傳遞下拉框數據

當有多個選項可用，但只能選擇一個或兩個選項時，我們使用下拉框。

下面的 HTML 程式碼實體是一個帶有下拉框的表單：

```cpp
<form action="/cgi-bin/cpp_dropdown.cgi" 
                       method="post" target="_blank"><select name="dropdown"><option value="Maths" selected>數學</option><option value="Physics">物理</option></select><input type="submit" value="提交"/></form>
```

下面的 C++ 程式會生成 cpp_dropdown.cgi 腳本，用於處理 Web 瀏覽器通過下拉框給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程式傳遞下拉框數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("dropdown");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Value Selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 在 CGI 中使用 Cookies

HTTP 協議是一種無狀態的協議。但對於一個商業網站，它需要在不同頁面間保持會話資訊。例如，一個用戶在完成多個頁面的步驟之後結束註冊。但是，如何在所有網頁中保持用戶的會話資訊。

在許多情況下，使用 cookies 是記憶和跟蹤有關用戶喜好、購買、佣金以及其他為追求更好的遊客體驗或網站統計所需資訊的最有效的方法。

### 它是如何工作的

伺服器以 cookie 的形式向訪客的瀏覽器發送一些數據。如果瀏覽器接受了 cookie，則 cookie 會以純文本記錄的形式存儲在訪客的硬碟上。現在，當訪客訪問網站上的另一個頁面時，會檢索 cookie。一旦找到 cookie，伺服器就知道存儲了什麼。

cookie 是一種純文本的數據記錄，帶有 5 個可變長度的字段：

- **Expires :** cookie 的過期日期。如果此字段留空，cookie 會在訪客退出瀏覽器時過期。
- **Domain :** 網站的域名。
- **Path :** 設置 cookie 的目錄或網頁的路徑。如果您想從任意的目錄或網頁檢索 cookie，此字段可以留空。
- **Secure :** 如果此字段包含單詞 "secure"，那麼 cookie 只能通過安全伺服器進行檢索。如果此字段留空，則不存在該限制。
- **Name=Value :** cookie 以鍵值對的形式被設置和獲取。

### 設置 Cookies

向瀏覽器發送 cookies 是非常簡單的。這些 cookies 會在 Content-type 字段之前，與 HTTP 頭一起被髮送。假設您想設置 UserID 和 Password 為 cookies，設置 cookies 的步驟如下所示：

```cpp
#include <iostream>using namespace std;int main (){
 
   cout << "Set-Cookie:UserID=XYZ;\r\n";
   cout << "Set-Cookie:Password=XYZ123;\r\n";
   cout << "Set-Cookie:Domain=www.w3cschool.cc;\r\n";
   cout << "Set-Cookie:Path=/perl;\n";
   cout << "Content-type:text/html\r\n\r\n";

   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   cout << "設置 cookies" << endl;  
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

從這個實體中，我們瞭解瞭如何設置 cookies。我們使用 **Set-Cookie** HTTP 頭來設置 cookies。

在這裡，有一些設置 cookies 的屬性是可選的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在發送行 **"Content-type:text/html\r\n\r\n** 之前被設置的。

編譯上面的程式，生成 setcookies.cgi，並嘗試使用下面的連結設置 cookies。它會在您的電腦上設置四個 cookies：

/cgi-bin/setcookies.cgi

### 獲取 Cookies

檢索所有設置的 cookies 是非常簡單的。cookies 被存儲在 CGI 環境變數 HTTP_COOKIE 中，且它們的形式如下：

```cpp
key1=value1;key2=value2;key3=value3....
```

下面的實體演示瞭如何獲取 cookies。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){
   Cgicc cgi;
   const_cookie_iterator cci;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";
   
   // 獲取環境變數
   const CgiEnvironment& env = cgi.getEnvironment();

   for( cci = env.getCookieList().begin();
        cci != env.getCookieList().end(); 
        ++cci )
   {
      cout << "<tr><td>" << cci->getName() << "</td><td>";
      cout << cci->getValue();                                 
      cout << "</td></tr>\n";
   }
   cout << "</table><\n";
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

現在，編譯上面的程式，生成 getcookies.cgi，並嘗試使用下面的連結獲取您的電腦上所有可用的 cookies：

/cgi-bin/getcookies.cgi

這會產生一個列表，顯示了上一節中設置的四個 cookies 以及您的電腦上所有其他的 cookies：

```cpp
UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl
```

## 檔案上傳實體

為了上傳一個檔案，HTML 表單必須把 enctype 屬性設置為 **multipart/form-data**。帶有檔案型別的 input 標籤會創建一個 "Browse" 按鈕。

```cpp
<html><body>
   <form enctype="multipart/form-data" 
            action="/cgi-bin/cpp_uploadfile.cgi" 
            method="post">
   <p>檔案：<input type="file" name="userfile" /></p>
   <p><input type="submit" value="上傳" /></p>
   </form></body></html>
```

這段程式碼的結果是下面的表單：

檔案：

 

**注意：**上面的實體已經故意禁用了保存上傳的檔案在我們的伺服器上。您可以在自己的伺服器上嘗試上面的程式碼。

下面是用於處理檔案上傳的腳本 **cpp_uploadfile.cpp**：

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){
   Cgicc cgi;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的檔案上傳</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   // 獲取要被上傳的檔案列表
   const_file_iterator file = cgi.getFile("userfile");
   if(file != cgi.getFiles().end()) {
      // 在 cout 中發送數據型別
      cout << HTTPContentHeader(file->getDataType());
      // 在 cout 中寫入內容
      file->writeToStream(cout);
   }
   cout << "<檔案上傳成功>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

上面的實體是在 **cout** 流中寫入內容，但您可以打開檔案流，並把上傳的檔案內容保存在目標位元元置的某個檔案中。

# C++ STL 教程

在前面的章節中，我們已經學習了 C++ 樣板的概念。C++ STL（標準樣板庫）是一套功能強大的 C++ 樣板類，提供了通用的樣板類和函式，這些樣板類和函式可以實現多種流行和常用的演演算法和數據結構，如向量、鏈結串列、佇列、棧。

C++ 標準樣板庫的核心包括以下三個組件：

| 組件                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| 容器（Containers）  | 容器是用來管理某一類物件的集合。C++ 提供了各種不同型別的容器，比如 deque、list、vector、map 等。 |
| 演演算法（Algorithms）  | 演演算法作用於容器。它們提供了執行各種操作的方式，包括對容器內容執行初始化、排序、搜尋和轉換等操作。 |
| 疊代器（iterators） | 疊代器用於走訪物件集合的元素。這些集合可能是容器，也可能是容器的子集。 |

這三個組件都帶有豐富的預定義函式，幫助我們通過簡單的方式處理複雜的任務。

下面的程式演示了向量容器（一個 C++ 標準的樣板），它與陣列十分相似，唯一不同的是，向量在需要擴展大小的時候，會自動處理它自己的存儲需求：

```cpp
#include <iostream>#include <vector>using namespace std;
 int main(){
   // 創建一個向量存儲 int
   vector<int> vec; 
   int i;

   // 顯示 vec 的原始大小
   cout << "vector size = " << vec.size() << endl;

   // 推入 5 個值到向量中
   for(i = 0; i < 5; i++){
      vec.push_back(i);
   }

   // 顯示 vec 擴展後的大小
   cout << "extended vector size = " << vec.size() << endl;

   // 訪問向量中的 5 個值
   for(i = 0; i < 5; i++){
      cout << "value of vec [" << i << "] = " << vec[i] << endl;
   }

   // 使用疊代器 iterator 訪問值
   vector<int>::iterator v = vec.begin();
   while( v != vec.end()) {
      cout << "value of v = " << *v << endl;
      v++;
   }

   return 0;}
```

當上面的程式碼被編譯和執行時，它會產生下列結果：

```cpp
vector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4
```

關於上面實體中所使用的各種函式，有幾點要注意：

- push_back( ) 成員函式在向量的末尾插入值，如果有必要會擴展向量的大小。
- size( ) 函式顯示向量的大小。
- begin( ) 函式返回一個指向向量開頭的疊代器。
- end( ) 函式返回一個指向向量末尾的疊代器。

# C++ 標準庫

C++ 標準庫可以分為兩部分：

- **標準函式庫：** 這個庫是由通用的、獨立的、不屬於任何類的函式組成的。函式庫繼承自 C 語言。
- **面向物件類庫：** 這個庫是類及其相關函式的集合。

C++ 標準庫包含了所有的 C 標準庫，為了支援型別安全，做了一定的添加和修改。

## 標準函式庫

標準函式庫分為以下幾類：

- 輸入/輸出 I/O
- 字串和字符處理
- 數學
- 時間、日期和本地化
- 動態分配
- 其他
- 寬字符函式

## 面向物件類庫

標準的 C++ 面向物件類庫定義了大量支援一些常見操作的類，比如輸入/輸出 I/O、字串處理、數值處理。面向物件類庫包含以下內容：

- 標準的 C++ I/O 類
- String 類
- 數值類
- STL 容器類
- STL 演演算法
- STL 函式物件
- STL 疊代器
- STL 分配器
- 本地化庫
- 異常處理類
- 雜項支援庫

