# C++ 教程

![img](https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png)

C++ 是一種中級語言，它是由 Bjarne Stroustrup 於 1979 年在貝爾實驗室開始設計開發的。C++ 進一步擴充和完善了 C 語言，是一種面向對象的程序設計語言。C++ 可運行於多種平臺上，如 Windows、MAC 操作系統以及 UNIX 的各種版本。

本教程通過通俗易懂的語言來講解 C++ 編程語言。

**現在開始學習 C++ 編程！**

 

## 誰適合閱讀本教程？

本教程是專門為初學者打造的，幫助他們理解與 C++ 編程語言相關的基礎到高級的概念。

## 閱讀本教程前，您需要了解的知識：

在您開始練習本教程中所給出的各種實例之前，您需要對計算機程序和計算機程序設計語言有基本的瞭解。

## 編譯/執行 C++ 程序

## 實例

```cpp
#include <iostream>using namespace std;int main(){
    cout << "Hello, world!" << endl;    return 0;
}
```

運行結果：

```cpp
Hello, world!
```

你可以用 "\n" 代替以上代碼裡的 "endl"。

# C++ 簡介

C++ 是一種靜態類型的、編譯式的、通用的、大小寫敏感的、不規則的編程語言，支持過程化編程、面向對象編程和泛型編程。

C++ 被認為是一種**中級**語言，它綜合了高級語言和低級語言的特點。

C++ 是由 Bjarne Stroustrup 於 1979 年在新澤西州美利山貝爾實驗室開始設計開發的。C++ 進一步擴充和完善了 C 語言，最初命名為帶類的C，後來在 1983 年更名為 C++。

C++ 是 C 的一個超集，事實上，任何合法的 C 程序都是合法的 C++ 程序。

**注意：**使用靜態類型的編程語言是在編譯時執行類型檢查，而不是在運行時執行類型檢查。

## 面向對象程序設計

C++ 完全支持面向對象的程序設計，包括面向對象開發的四大特性：

- 封裝
- 抽象
- 繼承
- 多態

## 標準庫

標準的 C++ 由三個重要部分組成：

- 核心語言，提供了所有構件塊，包括變量、數據類型和常量，等等。
- C++ 標準庫，提供了大量的函數，用於操作文件、字符串等。
- 標準模板庫（STL），提供了大量的方法，用於操作數據結構等。

## ANSI 標準

ANSI 標準是為了確保 C++ 的便攜性 —— 您所編寫的代碼在 Mac、UNIX、Windows、Alpha 計算機上都能通過編譯。

由於 ANSI 標準已穩定使用了很長的時間，所有主要的 C++ 編譯器的製造商都支持 ANSI 標準。

## 學習 C++

學習 C++，關鍵是要理解概念，而不應過於深究語言的技術細節。

學習程序設計語言的目的是為了成為一個更好的程序員，也就是說，是為了能更有效率地設計和實現新系統，以及維護舊系統。

C++ 支持多種編程風格。您可以使用 Fortran、C、Smalltalk 等任意一種語言的編程風格來編寫代碼。每種風格都能有效地保證運行時間效率和空間效率。

## C++ 的使用

基本上每個應用程序領域的程序員都有使用 C++。

C++ 通常用於編寫設備驅動程序和其他要求實時性的直接操作硬件的軟件。

C++ 廣泛用於教學和研究。

任何一個使用蘋果電腦或 Windows PC 機的用戶都在間接地使用 C++，因為這些系統的主要用戶接口是使用 C++ 編寫的。

------

## 標準化

| 發佈時間 | 文檔                  | 通稱   | 備註                |      |
| :------- | :-------------------- | :----- | :------------------ | :--- |
| 2015     | ISO/IEC TS 19570:2015 | -      | 用於並行計算的擴展  |      |
| 2015     | ISO/IEC TS 18822:2015 | -      | 文件系統            |      |
| 2014     | ISO/IEC 14882:2014    | C++14  | 第四個C++標準       |      |
| 2011     | ISO/IEC TR 24733:2011 | -      | 十進制浮點數擴展    |      |
| 2011     | ISO/IEC 14882:2011    | C++11  | 第三個C++標準       |      |
| 2010     | ISO/IEC TR 29124:2010 | -      | 數學函數擴展        |      |
| 2007     | ISO/IEC TR 19768:2007 | C++TR1 | C++技術報告：庫擴展 |      |
| 2006     | ISO/IEC TR 18015:2006 | -      | C++性能技術報告     |      |
| 2003     | ISO/IEC 14882:2003    | C++03  | 第二個C++標準       |      |
| 1998     | ISO/IEC 14882:1998    | C++98  | 第一個C++標準       |      |

# C++ 環境設置

## 本地環境設置

如果您想要設置 C++ 語言環境，您需要確保電腦上有以下兩款可用的軟件，文本編輯器和 C++ 編譯器。

## 文本編輯器

這將用於輸入您的程序。文本編輯器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。

文本編輯器的名稱和版本在不同的操作系統上可能會有所不同。例如，Notepad 通常用於 Windows 操作系統上，vim/vi 可用於 Windows 和 Linux/UNIX 操作系統上。

通過編輯器創建的文件通常稱為源文件，源文件包含程序源代碼。C++ 程序的源文件通常使用擴展名 .cpp、.cp 或 .c。

在開始編程之前，請確保您有一個文本編輯器，且有足夠的經驗來編寫一個計算機程序，然後把它保存在一個文件中，編譯並執行它。

## C++ 編譯器

寫在源文件中的源代碼是人類可讀的源。它需要"編譯"，轉為機器語言，這樣 CPU 可以按給定指令執行程序。

C++ 編譯器用於把源代碼編譯成最終的可執行程序。

大多數的 C++ 編譯器並不在乎源文件的擴展名，但是如果您未指定擴展名，則默認使用 .cpp。

最常用的免費可用的編譯器是 GNU 的 C/C++ 編譯器，如果您使用的是 HP 或 Solaris，則可以使用各自操作系統上的編譯器。

以下部分將指導您如何在不同的操作系統上安裝 GNU 的 C/C++ 編譯器。這裡同時提到 C/C++，主要是因為 GNU 的 gcc 編譯器適合於 C 和 C++ 編程語言。

## 安裝 GNU 的 C/C++ 編譯器

### UNIX/Linux 上的安裝

如果您使用的是 **Linux 或 UNIX**，請在命令行使用下面的命令來檢查您的系統上是否安裝了 GCC：

```cpp
$ g++ -v
```

如果您的計算機上已經安裝了 GNU 編譯器，則會顯示如下消息：

```cpp
Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
```

如果未安裝 GCC，那麼請按照 http://gcc.gnu.org/install/ 上的詳細說明安裝 GCC。

### Mac OS X 上的安裝

如果您使用的是 Mac OS X，最快捷的獲取 GCC 的方法是從蘋果的網站上下載 Xcode 開發環境，並按照安裝說明進行安裝。一旦安裝上 Xcode，您就能使用 GNU 編譯器。

Xcode 目前可從 developer.apple.com/technologies/tools/ 上下載。

### Windows 上的安裝

為了在 Windows 上安裝 GCC，您需要安裝 MinGW。為了安裝 MinGW，請訪問 MinGW 的主頁 www.mingw.org，進入 MinGW 下載頁面，下載最新版本的 MinGW 安裝程序，命名格式為 MinGW-<version>.exe。

當安裝 MinGW 時，您至少要安裝 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情況下都會安裝更多其他的項。

添加您安裝的 MinGW 的 bin 子目錄到您的 **PATH** 環境變量中，這樣您就可以在命令行中通過簡單的名稱來指定這些工具。

當完成安裝時，您可以從 Windows 命令行上運行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。

------

## 使用 Visual Studio (Graphical Interface) 編譯

1、下載及安裝 Visual Studio Community 2015。

2、打開 Visual Studio Community

3、點擊 File -> New -> Project

![img](https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png)

4、左側列表選擇 Templates -> Visual C++ -> Win32 Console Application，並設置項目名為 MyFirstProgram。

![img](https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png)

 

5、點擊 OK。

6、在以下窗口中點擊 Next

![img](https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png)

7、在彈出的窗口中選擇 Empty project 選項後，點擊 Finish 按鈕：

8、右擊文件夾 Source File 並點擊 Add --> New Item... :

![img](https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png)

9、選擇 C++ File 然後設置文件名為 main.cpp，然後點擊 Add：

![img](https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png)

 

10、拷貝以下代碼到 main.cpp 中：

```cpp
#include <iostream>int main(){
    std::cout << "Hello World!\n";
    return 0;}
```

界面如下所示：

![img](https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png)

11、點擊菜單上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :

![img](https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png)

12、完成以上操作後，你可以看到以下輸出：

![img](https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png)

------

## g++ 應用說明

程序 g++ 是將 gcc 默認語言設為 C++ 的一個特殊的版本，鏈接時它自動使用 C++ 標準庫而不用 C 標準庫。通過遵循源碼的命名規範並指定對應庫的名字，用 gcc 來編譯鏈接 C++ 程序是可行的，如下例所示：

```cpp
$ gcc main.cpp -lstdc++ -o main
```

下面是一個保存在文件 helloworld.cpp 中一個簡單的 C++ 程序的代碼：

```cpp
#include <iostream>using namespace std;int main(){
    cout << "Hello, world!" << endl;
    return 0;}
```

最簡單的編譯方式：

```cpp
$ g++ helloworld.cpp
```

由於命令行中未指定可執行程序的文件名，編譯器採用默認的 a.out。程序可以這樣來運行：

```cpp
$ ./a.outHello, world!
```

通常我們使用 **-o** 選項指定可執行程序的文件名，以下實例生成一個 helloworld 的可執行文件：

```cpp
$ g++ helloworld.cpp -o helloworld
```

執行 helloworld:

```cpp
$ ./helloworldHello, world!
```

如果是多個 C++ 代碼文件，如 runoob1.cpp、runoob2.cpp，編譯命令如下：

```cpp
$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob
```

生成一個 runoob 可執行文件。

g++ 有些系統默認是使用 C++98，我們可以指定使用 C++11 來編譯 main.cpp 文件：

```cpp
g++ -g -Wall -std=c++11 main.cpp
```

### g++ 常用命令選項

| 選項         | 解釋                                                         |
| :----------- | :----------------------------------------------------------- |
| -ansi        | 只支持 ANSI 標準的 C 語法。這一選項將禁止 GNU C 的某些特色， 例如 asm 或 typeof 關鍵詞。 |
| -c           | 只編譯並生成目標文件。                                       |
| -DMACRO      | 以字符串"1"定義 MACRO 宏。                                   |
| -DMACRO=DEFN | 以字符串"DEFN"定義 MACRO 宏。                                |
| -E           | 只運行 C 預編譯器。                                          |
| -g           | 生成調試信息。GNU 調試器可利用該信息。                       |
| -IDIRECTORY  | 指定額外的頭文件搜索路徑DIRECTORY。                          |
| -LDIRECTORY  | 指定額外的函數庫搜索路徑DIRECTORY。                          |
| -lLIBRARY    | 連接時搜索指定的函數庫LIBRARY。                              |
| -m486        | 針對 486 進行代碼優化。                                      |
| -o           | FILE 生成指定的輸出文件。用在生成可執行文件時。              |
| -O0          | 不進行優化處理。                                             |
| -O           | 或 -O1 優化生成代碼。                                        |
| -O2          | 進一步優化。                                                 |
| -O3          | 比 -O2 更進一步優化，包括 inline 函數。                      |
| -shared      | 生成共享目標文件。通常用在建立共享庫時。                     |
| -static      | 禁止使用共享連接。                                           |
| -UMACRO      | 取消對 MACRO 宏的定義。                                      |
| -w           | 不生成任何警告信息。                                         |
| -Wall        | 生成所有警告信息。                                           |

# C++ 基本語法

C++ 程序可以定義為對象的集合，這些對象通過調用彼此的方法進行交互。現在讓我們簡要地看一下什麼是類、對象，方法、即時變量。

- **對象 -** 對象具有狀態和行為。例如：一隻狗的狀態 - 顏色、名稱、品種，行為 - 搖動、叫喚、吃。對象是類的實例。
- **類 -** 類可以定義為描述對象行為/狀態的模板/藍圖。
- **方法 -** 從基本上說，一個方法表示一種行為。一個類可以包含多個方法。可以在方法中寫入邏輯、操作數據以及執行所有的動作。
- **即時變量 -** 每個對象都有其獨特的即時變量。對象的狀態是由這些即時變量的值創建的。

## C++ 程序結構

讓我們看一段簡單的代碼，可以輸出單詞 *Hello World*。

## 實例

```cpp
#include <iostream>using namespace std; // main() 是程序開始執行的地方 
	int main(){   
	cout << "Hello World"; // 輸出 Hello World   return 0;
	}
```

接下來我們講解一下上面這段程序：

- C++ 語言定義了一些頭文件，這些頭文件包含了程序中必需的或有用的信息。上面這段程序中，包含了頭文件 **<iostream>**。
- 行 **using namespace std;** 告訴編譯器使用 std 命名空間。命名空間是 C++ 中一個相對新的概念。
- 下一行 **// main() 是程序開始執行的地方** 是一個單行註釋。單行註釋以 // 開頭，在行末結束。
- 下一行 **int main()** 是主函數，程序從這裡開始執行。
- 下一行 **cout << "Hello World";** 會在屏幕上顯示消息 "Hello World"。
- 下一行 **return 0;** 終止 main( )函數，並向調用進程返回值 0。

## 編譯 & 執行 C++ 程序

接下來讓我們看看如何把源代碼保存在一個文件中，以及如何編譯並運行它。下面是簡單的步驟：

- 打開一個文本編輯器，添加上述代碼。
- 保存文件為 hello.cpp。
- 打開命令提示符，進入到保存文件所在的目錄。
- 鍵入 'g++ hello.cpp '，輸入回車，編譯代碼。如果代碼中沒有錯誤，命令提示符會跳到下一行，並生成 a.out 可執行文件。
- 現在，鍵入 ' a.out' 來運行程序。
- 您可以看到屏幕上顯示 ' Hello World '。

```cpp
$ g++ hello.cpp$ ./a.outHello World
```

請確保您的路徑中已包含 g++ 編譯器，並確保在包含源文件 hello.cpp 的目錄中運行它。

您也可以使用 makefile 來編譯 C/C++ 程序。

## C++ 中的分號 & 塊

在 C++ 中，分號是語句結束符。也就是說，每個語句必須以分號結束。它表明一個邏輯實體的結束。

例如，下面是三個不同的語句：

```cpp
x = y;y = y+1;add(x, y);
```

塊是一組使用大括號括起來的按邏輯連接的語句。例如：

```cpp
{   cout << "Hello World"; // 輸出 Hello World   return 0;}
```

C++ 不以行末作為結束符的標識，因此，您可以在一行上放置多個語句。例如：

```cpp
x = y;y = y+1;add(x, y);
```

等同於

```cpp
x = y; y = y+1; add(x, y);
```

## C++ 標識符

C++ 標識符是用來標識變量、函數、類、模塊，或任何其他用戶自定義項目的名稱。一個標識符以字母 A-Z 或 a-z 或下劃線 _ 開始，後跟零個或多個字母、下劃線和數字（0-9）。

C++ 標識符內不允許出現標點字符，比如 @、$ 和 %。C++ 是區分大小寫的編程語言。因此，在 C++ 中，**Manpower** 和 **manpower** 是兩個不同的標識符。

下面列出幾個有效的標識符：

```cpp
mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal
```

## C++ 關鍵字

下表列出了 C++ 中的保留字。這些保留字不能作為常量名、變量名或其他標識符名稱。

| asm          | else      | new              | this     |
| ------------ | --------- | ---------------- | -------- |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |

 

## 三字符組

三字符組就是用於表示另一個字符的三個字符序列，又稱為三字符序列。三字符序列總是以兩個問號開頭。

三字符序列不太常見，但 C++ 標準允許把某些字符指定為三字符序列。以前為了表示鍵盤上沒有的字符，這是必不可少的一種方法。

三字符序列可以出現在任何地方，包括字符串、字符序列、註釋和預處理指令。

下面列出了最常用的三字符序列：

| 三字符組 | 替換 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

如果希望在源程序中有兩個連續的問號，且不希望被預處理器替換，這種情況出現在字符常量、字符串字面值或者是程序註釋中，可選辦法是用字符串的自動連接："...?""?..."或者轉義序列："...?\?..."。

從Microsoft Visual C++ 2010版開始，該編譯器默認不再自動替換三字符組。如果需要使用三字符組替換（如為了兼容古老的軟件代碼），需要設置編譯器命令行選項/Zc:trigraphs

g++仍默認支持三字符組，但會給出編譯警告。

## C++ 中的空格

只包含空格的行，被稱為空白行，可能帶有註釋，C++ 編譯器會完全忽略它。

在 C++ 中，空格用於描述空白符、製表符、換行符和註釋。空格分隔語句的各個部分，讓編譯器能識別語句中的某個元素（比如 int）在哪裡結束，下一個元素在哪裡開始。因此，在下面的語句中：

```cpp
int age;
```

在這裡，int 和 age 之間必須至少有一個空格字符（通常是一個空白符），這樣編譯器才能夠區分它們。另一方面，在下面的語句中：

```cpp
fruit = apples + oranges;   // 獲取水果的總數
```

fruit 和 =，或者 = 和 apples 之間的空格字符不是必需的，但是為了增強可讀性，您可以根據需要適當增加一些空格。

# C++ 註釋

程序的註釋是解釋性語句，您可以在 C++ 代碼中包含註釋，這將提高源代碼的可讀性。所有的編程語言都允許某種形式的註釋。

C++ 支持單行註釋和多行註釋。註釋中的所有字符會被 C++ 編譯器忽略。

C++ 註釋以 /* 開始，以 */ 終止。例如：

```cpp
/* 這是註釋 *//* C++ 註釋也可以
 * 跨行
 */
```

註釋也能以 // 開始，直到行末為止。例如：

```cpp
#include <iostream>using namespace std;main(){
   cout << "Hello World"; // 輸出 Hello World

   return 0;}
```

當上面的代碼被編譯時，編譯器會忽略 **// 輸出 Hello World**，最後會產生以下結果：

```cpp
Hello World
```

在 /* 和 */ 註釋內部，// 字符沒有特殊的含義。在 // 註釋內，/* 和 */ 字符也沒有特殊的含義。因此，您可以在一種註釋內嵌套另一種註釋。例如：

```
 
/* 用於輸出 Hello World 的註釋

cout << "Hello World"; // 輸出 Hello World

*/
```

# C++ 數據類型

使用編程語言進行編程時，需要用到各種變量來存儲各種信息。變量保留的是它所存儲的值的內存位置。這意味著，當您創建一個變量時，就會在內存中保留一些空間。

您可能需要存儲各種數據類型（比如字符型、寬字符型、整型、浮點型、雙浮點型、布爾型等）的信息，操作系統會根據變量的數據類型，來分配內存和決定在保留內存中存儲什麼。

## 基本的內置類型

C++ 為程序員提供了種類豐富的內置數據類型和用戶自定義的數據類型。下表列出了七種基本的 C++ 數據類型：

| 類型     | 關鍵字  |
| :------- | :------ |
| 布爾型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮點型   | float   |
| 雙浮點型 | double  |
| 無類型   | void    |
| 寬字符型 | wchar_t |

一些基本類型可以使用一個或多個類型修飾符進行修飾：

- signed
- unsigned
- short
- long

下表顯示了各種變量類型在內存中存儲值時需要佔用的內存，以及該類型的變量所能存儲的最大值和最小值。

| 類型               | 位            | 範圍                                                    |
| :----------------- | :------------ | :------------------------------------------------------ |
| char               | 1 個字節      | -128 到 127 或者 0 到 255                               |
| unsigned char      | 1 個字節      | 0 到 255                                                |
| signed char        | 1 個字節      | -128 到 127                                             |
| int                | 4 個字節      | -2147483648 到 2147483647                               |
| unsigned int       | 4 個字節      | 0 到 4294967295                                         |
| signed int         | 4 個字節      | -2147483648 到 2147483647                               |
| short int          | 2 個字節      | -32768 到 32767                                         |
| unsigned short int | 2 個字節      | 0 到 65,535                                             |
| signed short int   | 2 個字節      | -32768 到 32767                                         |
| long int           | 8 個字節      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| signed long int    | 8 個字節      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| unsigned long int  | 8 個字節      | 0 to 18,446,744,073,709,551,615                         |
| float              | 4 個字節      | +/- 3.4e +/- 38 (~7 個數字)                             |
| double             | 8 個字節      | +/- 1.7e +/- 308 (~15 個數字)                           |
| long double        | 8 個字節      | +/- 1.7e +/- 308 (~15 個數字)                           |
| wchar_t            | 2 或 4 個字節 | 1 個寬字符                                              |

從上表可得知，變量的大小會根據編譯器和所使用的電腦而有所不同。

下面實例會輸出您電腦上各種數據類型的大小。

```cpp
#include <iostream>using namespace std;int main(){   
	cout << "Size of char : " << sizeof(char) << endl;   
	cout << "Size of int : " << sizeof(int) << endl;  
	cout << "Size of short int : " << sizeof(short int) << endl;  
	cout << "Size of long int : " << sizeof(long int) << endl;   
	cout << "Size of float : " << sizeof(float) << endl;   
	cout << "Size of double : " << sizeof(double) << endl;  
	cout << "Size of wchar_t : " << sizeof(wchar_t) << endl;   return 0;
}
```

本實例使用了 **endl**，這將在每一行後插入一個換行符，<< 運算符用於向屏幕傳多個值。我們也使用 **sizeof()** 函數來獲取各種數據類型的大小。

當上面的代碼被編譯和執行時，它會產生以下的結果，結果會根據所使用的計算機而有所不同：

```cpp
Size of char : 1Size of int : 4Size of short int : 2Size of long int : 8Size of float : 4Size of double : 8Size of wchar_t : 4
```

## typedef 聲明

您可以使用 **typedef** 為一個已有的類型取一個新的名字。下面是使用 typedef 定義一個新類型的語法：

```cpp
typedef type newname;
```

例如，下面的語句會告訴編譯器，feet 是 int 的另一個名稱：

```cpp
typedef int feet;
```

現在，下面的聲明是完全合法的，它創建了一個整型變量 distance：

```cpp
feet distance;
```

## 枚舉類型

枚舉類型(enumeration)是C++中的一種派生數據類型，它是由用戶定義的若干枚舉常量的集合。

如果一個變量只有幾種可能的值，可以定義為枚舉(enumeration)類型。所謂"枚舉"是指將變量的值一一列舉出來，變量的值只能在列舉出來的值的範圍內。

創建枚舉，需要使用關鍵字 **enum**。枚舉類型的一般形式為：

```cpp
enum enum-name { list of names } var-list;
```

在這裡，enum-name 是枚舉類型的名稱。名稱列表 { list of names } 是用逗號分隔的。

例如，下面的代碼定義了一個顏色枚舉，變量 c 的類型為 color。最後，c 被賦值為 "blue"。

```cpp
enum color { red, green, blue } c;c = blue;
```

默認情況下，第一個名稱的值為 0，第二個名稱的值為 1，第三個名稱的值為 2，以此類推。但是，您也可以給名稱賦予一個特殊的值，只需要添加一個初始值即可。例如，在下面的枚舉中，**green** 的值為 5。

```cpp
enum color { red, green=5, blue };
```

在這裡，**blue** 的值為 6，因為默認情況下，每個名稱都會比它前面一個名稱大 1。

# C++ 變量類型

變量其實只不過是程序可操作的存儲區的名稱。C++ 中每個變量都有指定的類型，類型決定了變量存儲的大小和佈局，該範圍內的值都可以存儲在內存中，運算符可應用於變量上。

變量的名稱可以由字母、數字和下劃線字符組成。它必須以字母或下劃線開頭。大寫字母和小寫字母是不同的，因為 C++ 是大小寫敏感的。

基於前一章講解的基本類型，有以下幾種基本的變量類型，將在下一章中進行講解：

| 類型    | 描述                                               |
| :------ | :------------------------------------------------- |
| bool    | 存儲值 true 或 false。                             |
| char    | 通常是一個八位字節（一個字節）。這是一個整數類型。 |
| int     | 對機器而言，整數的最自然的大小。                   |
| float   | 單精度浮點值。                                     |
| double  | 雙精度浮點值。                                     |
| void    | 表示類型的缺失。                                   |
| wchar_t | 寬字符類型。                                       |

C++ 也允許定義各種其他類型的變量，比如**枚舉、指針、數組、引用、數據結構、類**等等，這將會在後續的章節中進行講解。

下面我們將講解如何定義、聲明和使用各種類型的變量。

## C++ 中的變量定義

變量定義就是告訴編譯器在何處創建變量的存儲，以及如何創建變量的存儲。變量定義指定一個數據類型，幷包含了該類型的一個或多個變量的列表，如下所示：

```cpp
type variable_list;
```

在這裡，**type** 必須是一個有效的 C++ 數據類型，可以是 char、wchar_t、int、float、double、bool 或任何用戶自定義的對象，**variable_list** 可以由一個或多個標識符名稱組成，多個標識符之間用逗號分隔。下面列出幾個有效的聲明：

```cpp
int    i, j, k;char   c, ch;float  f, salary;double d;
```

行 **int i, j, k;** 聲明並定義了變量 i、j 和 k，這指示編譯器創建類型為 int 的名為 i、j、k 的變量。

變量可以在聲明的時候被初始化（指定一個初始值）。初始化器由一個等號，後跟一個常量表達式組成，如下所示：

```cpp
type variable_name = value;
```

下面列舉幾個實例：

```cpp
extern int d = 3, f = 5;   
	// d 和 f 的聲明 int d = 3, f = 5;          
	// 定義並初始化 d 和 fbyte z = 22;               
	// 定義並初始化 zchar x = 'x';              
	// 變量 x 的值為 'x'
```

不帶初始化的定義：帶有靜態存儲持續時間的變量會被隱式初始化為 NULL（所有字節的值都是 0），其他所有變量的初始值是未定義的。

## C++ 中的變量聲明

變量聲明向編譯器保證變量以給定的類型和名稱存在，這樣編譯器在不需要知道變量完整細節的情況下也能繼續進一步的編譯。變量聲明只在編譯時有它的意義，在程序連接時編譯器需要實際的變量聲明。

當您使用多個文件且只在其中一個文件中定義變量時（定義變量的文件在程序連接時是可用的），變量聲明就顯得非常有用。您可以使用 **extern** 關鍵字在任何地方聲明一個變量。雖然您可以在 C++ 程序中多次聲明一個變量，但變量只能在某個文件、函數或代碼塊中被定義一次。

## 實例

嘗試下面的實例，其中，變量在頭部就已經被聲明，但它們是在主函數內被定義和初始化的：

```cpp
#include <iostream>using namespace std;// 變量聲明extern int a, b;extern int c;extern float f;
  int main (){
  // 變量定義
  int a, b;
  int c;
  float f;
 
  // 實際初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;

  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
3023.3333
```

同樣的，在函數聲明時，提供一個函數名，而函數的實際定義則可以在任何地方進行。例如：

```cpp
// 函數聲明int func();int main(){
    // 函數調用
    int i = func();}// 函數定義int func(){
    return 0;}
```

## C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有兩種類型的表達式：

- **左值（lvalue）：**指向內存位置的表達式被稱為左值（lvalue）表達式。左值可以出現在賦值號的左邊或右邊。
- **右值（rvalue）：**術語右值（rvalue）指的是存儲在內存中某些地址的數值。右值是不能對其進行賦值的表達式，也就是說，右值可以出現在賦值號的右邊，但不能出現在賦值號的左邊。

變量是左值，因此可以出現在賦值號的左邊。數值型的字面值是右值，因此不能被賦值，不能出現在賦值號的左邊。下面是一個有效的語句：

```cpp
int g = 20;
```

但是下面這個就不是一個有效的語句，會生成編譯時錯誤：

```cpp
10 = 20;
```

# C++ 變量作用域

作用域是程序的一個區域，一般來說有三個地方可以聲明變量：

- 在函數或一個代碼塊內部聲明的變量，稱為局部變量。
- 在函數參數的定義中聲明的變量，稱為形式參數。
- 在所有函數外部聲明的變量，稱為全局變量。

我們將在後續的章節中學習什麼是函數和參數。本章我們先來講解聲明是局部變量和全局變量。

## 局部變量

在函數或一個代碼塊內部聲明的變量，稱為局部變量。它們只能被函數內部或者代碼塊內部的語句使用。下面的實例使用了局部變量：

```cpp
#include <iostream>using namespace std;
 int main (){
  // 局部變量聲明
  int a, b;
  int c;
 
  // 實際初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;}
```

## 全局變量

在所有函數外部定義的變量（通常是在程序的頭部），稱為全局變量。全局變量的值在程序的整個生命週期內都是有效的。

全局變量可以被任何函數訪問。也就是說，全局變量一旦聲明，在整個程序中都是可用的。下面的實例使用了全局變量和局部變量：

```cpp
#include <iostream>using namespace std;
 // 全局變量聲明int g;
 int main (){
  // 局部變量聲明
  int a, b;
 
  // 實際初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;}
```

在程序中，局部變量和全局變量的名稱可以相同，但是在函數內，局部變量的值會覆蓋全局變量的值。下面是一個實例：

```cpp
#include <iostream>using namespace std;
 // 全局變量聲明int g = 20;
 int main (){
  // 局部變量聲明
  int g = 10;
 
  cout << g;
 
  return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
10
```

## 初始化局部變量和全局變量

當局部變量被定義時，系統不會對其初始化，您必須自行對其初始化。定義全局變量時，系統會自動初始化為下列值：

| 數據類型 | 初始化默認值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正確地初始化變量是一個良好的編程習慣，否則有時候程序可能會產生意想不到的結果。

# C++ 常量

常量是固定值，在程序執行期間不會改變。這些固定的值，又叫做**字面量**。

常量可以是任何的基本數據類型，可分為整型數字、浮點數字、字符、字符串和布爾值。

常量就像是常規的變量，只不過常量的值在定義後不能進行修改。

## 整數常量

整數常量可以是十進制、八進制或十六進制的常量。前綴指定基數：0x 或 0X 表示十六進制，0 表示八進制，不帶前綴則默認表示十進制。

整數常量也可以帶一個後綴，後綴是 U 和 L 的組合，U 表示無符號整數（unsigned），L 表示長整數（long）。後綴可以是大寫，也可以是小寫，U 和 L 的順序任意。

下面列舉幾個整數常量的實例：

```cpp
212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八進制的數字032UU       // 非法的：不能重複後綴
```

以下是各種類型的整數常量的實例：

```cpp
85         // 十進制0213       // 八進制 0x4b       // 十六進制 30         // 整數 30u        // 無符號整數 30l        // 長整數 30ul       // 無符號長整數
```

## 浮點常量

浮點常量由整數部分、小數點、小數部分和指數部分組成。您可以使用小數形式或者指數形式來表示浮點常量。

當使用小數形式表示時，必須包含整數部分、小數部分，或同時包含兩者。當使用指數形式表示時， 必須包含小數點、指數，或同時包含兩者。帶符號的指數是用 e 或 E 引入的。

下面列舉幾個浮點常量的實例：

```cpp
3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指數210f          // 非法的：沒有小數或指數.e55          // 非法的：缺少整數或分數
```

## 布爾常量

布爾常量共有兩個，它們都是標準的 C++ 關鍵字：

- **true** 值代表真。
- **false** 值代表假。

我們不應把 true 的值看成 1，把 false 的值看成 0。

## 字符常量

字符常量是括在單引號中。如果常量以 L（僅當大寫時）開頭，則表示它是一個寬字符常量（例如 L'x'），此時它必須存儲在 **wchar_t** 類型的變量中。否則，它就是一個窄字符常量（例如 'x'），此時它可以存儲在 **char** 類型的簡單變量中。

字符常量可以是一個普通的字符（例如 'x'）、一個轉義序列（例如 '\t'），或一個通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，當它們前面有反斜槓時，它們就具有特殊的含義，被用來表示如換行符（\n）或製表符（\t）等。下表列出了一些這樣的轉義序列碼：

| 轉義序列   | 含義                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警報鈴聲                   |
| \b         | 退格鍵                     |
| \f         | 換頁符                     |
| \n         | 換行符                     |
| \r         | 回車                       |
| \t         | 水平製表符                 |
| \v         | 垂直製表符                 |
| \ooo       | 一到三位的八進制數         |
| \xhh . . . | 一個或多個數字的十六進制數 |

下面的實例顯示了一些轉義序列字符：

```cpp
#include <iostream>using namespace std;int main(){   cout << "Hello\tWorld\n\n";   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Hello   World
```

## 字符串常量

字符串字面值或常量是括在雙引號 "" 中的。一個字符串包含類似於字符常量的字符：普通的字符、轉義序列和通用的字符。

您可以使用空格做分隔符，把一個很長的字符串常量進行分行。

下面的實例顯示了一些字符串常量。下面這三種形式所顯示的字符串是相同的。

```cpp
"quot;hello, dear""hello, \dear""hello, " "d" "ear"
```

## 定義常量

在 C++ 中，有兩種簡單的定義常量的方式：

- 使用 **#define** 預處理器。
- 使用 **const** 關鍵字。

## #define 預處理器

下面是使用 #define 預處理器定義常量的形式：

```cpp
#define identifier value
```

具體請看下面的實例：

```cpp
#include <iostream>using namespace std;#define LENGTH 10   #define WIDTH  5#define NEWLINE '\n'int main(){

   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
50
```

## const 關鍵字

您可以使用 **const** 前綴聲明指定類型的常量，如下所示：

```cpp
const type variable = value;
```

具體請看下面的實例：

```cpp
#include <iostream>using namespace std;int main(){
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
50
```

請注意，把常量定義為大寫字母形式，是一個很好的編程實踐。

# C++ 修飾符類型

C++ 允許在 **char、int 和 double** 數據類型前放置修飾符。修飾符用於改變基本類型的含義，所以它更能滿足各種情境的需求。

下面列出了數據類型修飾符：

- signed
- unsigned
- long
- short

修飾符 **signed、unsigned、long 和 short** 可應用於整型，**signed** 和 **unsigned** 可應用於字符型，**long** 可應用於雙精度型。

修飾符 **signed** 和 **unsigned** 也可以作為 **long** 或 **short** 修飾符的前綴。例如：**unsigned long int**。

C++ 允許使用速記符號來聲明**無符號短整數**或**無符號長整數**。您可以不寫 int，只寫單詞 **unsigned、short** 或 **unsigned、long**，int 是隱含的。例如，下面的兩個語句都聲明瞭無符號整型變量。

```cpp
unsigned x;
unsigned int y;
```

為了理解 C++ 解釋有符號整數和無符號整數修飾符之間的差別，我們來運行一下下面這個短程序：

```cpp
#include <iostream>
using namespace std;
 
/* 
 * 這個程序演示了有符號整數和無符號整數之間的差別
*/
int main()
{
   short int i;           // 有符號短整數
   short unsigned int j;  // 無符號短整數

   j = 50000;

   i = j;
   cout << i << " " << j;

   return 0;
}
```

當上面的程序運行時，會輸出下列結果：

```cpp
-15536 50000
```

上述結果中，無符號短整數 50,000 的位模式被解釋為有符號短整數 -15,536。

## C++ 中的類型限定符

類型限定符提供了變量的額外信息。

| 限定符   | 含義                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 類型的對象在程序執行期間不能被修改改變。           |
| volatile | 修飾符 **volatile** 告訴編譯器，變量的值可能以程序未明確指定的方式被改變。 |
| restrict | 由 **restrict** 修飾的指針是唯一一種訪問它所指向的對象的方式。只有 C99 增加了新的類型限定符 restrict。 |

# C++ 存儲類

存儲類定義 C++ 程序中變量/函數的範圍（可見性）和生命週期。這些說明符放置在它們所修飾的類型之前。下面列出 C++ 程序中可用的存儲類：

- auto
- register
- static
- extern
- mutable
- thread_local (C++11)

從 C++ 11 開始，auto 關鍵字不再是 C++ 存儲類說明符，且 register 關鍵字被棄用。

## auto 存儲類

自 C++ 11 以來，**auto** 關鍵字用於兩種情況：聲明變量時根據初始化表達式自動推斷該變量的類型、聲明函數時函數返回值的佔位符。

C++98標準中auto關鍵字用於自動變量的聲明，但由於使用極少且多餘，在C++11中已刪除這一用法。

根據初始化表達式自動推斷被聲明的變量的類型，如：

auto f=3.14;    //doubleauto s("hello");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//錯誤，必須是初始化為同一類型

## register 存儲類

**register** 存儲類用於定義存儲在寄存器中而不是 RAM 中的局部變量。這意味著變量的最大尺寸等於寄存器的大小（通常是一個詞），且不能對它應用一元的 '&' 運算符（因為它沒有內存位置）。

{  register int miles;}

寄存器只用於需要快速訪問的變量，比如計數器。還應注意的是，定義 'register' 並不意味著變量將被存儲在寄存器中，它意味著變量可能存儲在寄存器中，這取決於硬件和實現的限制。

## static 存儲類

**static** 存儲類指示編譯器在程序的生命週期內保持局部變量的存在，而不需要在每次它進入和離開作用域時進行創建和銷燬。因此，使用 static 修飾局部變量可以在函數調用之間保持局部變量的值。

static 修飾符也可以應用於全局變量。當 static 修飾全局變量時，會使變量的作用域限制在聲明它的文件內。

在 C++ 中，當 static 用在類數據成員上時，會導致僅有一個該成員的副本被類的所有對象共享。

## 實例

```cpp
#include <iostream>
 // 函數聲明 void func(void); 
static int count = 10; /* 全局變量 */
 int main(){
    while(count--)
    {
       func();    }
    return 0;}// 函數定義void func( void ){
    static int i = 5; // 局部靜態變量
    i++;    std::cout << "變量 i 為 " << i ;    std::cout << " , 變量 count 為 " << count << std::endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
變量 i 為 6 , 變量 count 為 9變量 i 為 7 , 變量 count 為 8變量 i 為 8 , 變量 count 為 7變量 i 為 9 , 變量 count 為 6變量 i 為 10 , 變量 count 為 5變量 i 為 11 , 變量 count 為 4變量 i 為 12 , 變量 count 為 3變量 i 為 13 , 變量 count 為 2變量 i 為 14 , 變量 count 為 1變量 i 為 15 , 變量 count 為 0
```

## extern 存儲類

**extern** 存儲類用於提供一個全局變量的引用，全局變量對所有的程序文件都是可見的。當您使用 'extern' 時，對於無法初始化的變量，會把變量名指向一個之前定義過的存儲位置。

當您有多個文件且定義了一個可以在其他文件中使用的全局變量或函數時，可以在其他文件中使用 *extern* 來得到已定義的變量或函數的引用。可以這麼理解，*extern* 是用來在另一個文件中聲明一個全局變量或函數。

extern 修飾符通常用於當有兩個或多個文件共享相同的全局變量或函數的時候，如下所示：

第一個文件：main.cpp

## 實例

```cpp
#include <iostream>
 int count ;extern void write_extern(); 
int main(){
   count = 5;   write_extern();}
```

第二個文件：support.cpp

## 實例

```cpp
#include <iostream>
 extern int count; 
void write_extern(void){
   std::cout << "Count is " << count << std::endl;}
```

在這裡，第二個文件中的 *extern* 關鍵字用於聲明已經在第一個文件 main.cpp 中定義的 count。現在 ，編譯這兩個文件，如下所示：

```cpp
$ g++ main.cpp support.cpp -o write
```

這會產生 **write** 可執行程序，嘗試執行 **write**，它會產生下列結果：

```cpp
$ ./writeCount is 5
```

## mutable 存儲類

**mutable** 說明符僅適用於類的對象，這將在本教程的最後進行講解。它允許對象的成員替代常量。也就是說，mutable 成員可以通過 const 成員函數修改。

## thread_local 存儲類

使用 thread_local 說明符聲明的變量僅可在它在其上創建的線程上訪問。 變量在創建線程時創建，並在銷燬線程時銷燬。 每個線程都有其自己的變量副本。

thread_local 說明符可以與 static 或 extern 合併。

可以將 thread_local 僅應用於數據聲明和定義，thread_local 不能用於函數聲明或定義。

以下演示了可以被聲明為 thread_local 的變量：

```cpp
thread_local int x;  // 命名空間下的全局變量class X{
    static thread_local std::string s; // 類的static成員變量};static thread_local std::string X::s;  // X::s 是需要定義的
 void foo(){
    thread_local std::vector<int> v;  // 本地變量}
```

# C++ 運算符

運算符是一種告訴編譯器執行特定的數學或邏輯操作的符號。C++ 內置了豐富的運算符，並提供了以下類型的運算符：

- 算術運算符
- 關係運算符
- 邏輯運算符
- 位運算符
- 賦值運算符
- 雜項運算符

本章將逐一介紹算術運算符、關係運算符、邏輯運算符、位運算符、賦值運算符和其他運算符。

## 算術運算符

下表顯示了 C++ 支持的算術運算符。

假設變量 A 的值為 10，變量 B 的值為 20，則：

| 運算符 | 描述                                                         | 實例             |
| :----- | :----------------------------------------------------------- | :--------------- |
| +      | 把兩個操作數相加                                             | A + B 將得到 30  |
| -      | 從第一個操作數中減去第二個操作數                             | A - B 將得到 -10 |
| *      | 把兩個操作數相乘                                             | A * B 將得到 200 |
| /      | 分子除以分母                                                 | B / A 將得到 2   |
| %      | 取模運算符，整除後的餘數                                     | B % A 將得到 0   |
| ++     | [自增運算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整數值增加 1 | A++ 將得到 11    |
| --     | [自減運算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整數值減少 1 | A-- 將得到 9     |

### 實例

請看下面的實例，瞭解 C++ 中可用的算術運算符。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int b = 10;   int c ; 
   c = a + b;   cout << "Line 1 - c 的值是 " << c << endl ;   c = a - b;   cout << "Line 2 - c 的值是 " << c << endl ;   c = a * b;   cout << "Line 3 - c 的值是 " << c << endl ;   c = a / b;   cout << "Line 4 - c 的值是 " << c << endl ;   c = a % b;   cout << "Line 5 - c 的值是 " << c << endl ; 
   int d = 10;   //  測試自增、自減
   c = d++;   cout << "Line 6 - c 的值是 " << c << endl ; 
   d = 10;    // 重新賦值
   c = d--;   cout << "Line 7 - c 的值是 " << c << endl ;   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10Line 7 - c 的值是 10
```

## 關係運算符

下表顯示了 C++ 支持的關係運算符。

假設變量 A 的值為 10，變量 B 的值為 20，則：

| 運算符 | 描述                                                         | 實例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 檢查兩個操作數的值是否相等，如果相等則條件為真。             | (A == B) 不為真。 |
| !=     | 檢查兩個操作數的值是否相等，如果不相等則條件為真。           | (A != B) 為真。   |
| >      | 檢查左操作數的值是否大於右操作數的值，如果是則條件為真。     | (A > B) 不為真。  |
| <      | 檢查左操作數的值是否小於右操作數的值，如果是則條件為真。     | (A < B) 為真。    |
| >=     | 檢查左操作數的值是否大於或等於右操作數的值，如果是則條件為真。 | (A >= B) 不為真。 |
| <=     | 檢查左操作數的值是否小於或等於右操作數的值，如果是則條件為真。 | (A <= B) 為真。   |

### 實例

請看下面的實例，瞭解 C++ 中可用的關係運算符。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int b = 10;   int c ; 
   if( a == b )
   {
      cout << "Line 1 - a 等於 b" << endl ;   }
   else
   {
      cout << "Line 1 - a 不等於 b" << endl ;   }
   if ( a < b )
   {
      cout << "Line 2 - a 小於 b" << endl ;   }
   else
   {
      cout << "Line 2 - a 不小於 b" << endl ;   }
   if ( a > b )
   {
      cout << "Line 3 - a 大於 b" << endl ;   }
   else
   {
      cout << "Line 3 - a 不大於 b" << endl ;   }
   /* 改變 a 和 b 的值 */
   a = 5;   b = 20;   if ( a <= b )
   {
      cout << "Line 4 - a 小於或等於 b" << endl ;   }
   if ( b >= a )
   {
      cout << "Line 5 - b 大於或等於 a" << endl ;   }
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - a 不等於 bLine 2 - a 不小於 bLine 3 - a 大於 bLine 4 - a 小於或等於 bLine 5 - b 大於或等於 a
```

## 邏輯運算符

下表顯示了 C++ 支持的關係邏輯運算符。

假設變量 A 的值為 1，變量 B 的值為 0，則：

| 運算符 | 描述                                                         | 實例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| &&     | 稱為邏輯與運算符。如果兩個操作數都非零，則條件為真。         | (A && B) 為假。   |
| \|\|   | 稱為邏輯或運算符。如果兩個操作數中有任意一個非零，則條件為真。 | (A \|\| B) 為真。 |
| !      | 稱為邏輯非運算符。用來逆轉操作數的邏輯狀態。如果條件為真則邏輯非運算符將使其為假。 | !(A && B) 為真。  |

### 實例

請看下面的實例，瞭解 C++ 中可用的邏輯運算符。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 5;   int b = 20;   int c ; 
   if ( a && b )
   {
      cout << "Line 1 - 條件為真"<< endl ;   }
   if ( a || b )
   {
      cout << "Line 2 - 條件為真"<< endl ;   }
   /* 改變 a 和 b 的值 */
   a = 0;   b = 10;   if ( a && b )
   {
      cout << "Line 3 - 條件為真"<< endl ;   }
   else
   {
      cout << "Line 4 - 條件不為真"<< endl ;   }
   if ( !(a && b) )
   {
      cout << "Line 5 - 條件為真"<< endl ;   }
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - 條件為真Line 2 - 條件為真Line 4 - 條件不為真Line 5 - 條件為真
```

## 位運算符

位運算符作用於位，並逐位執行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假設如果 A = 60，且 B = 13，現在以二進制格式表示，它們如下所示：

A = 0011 1100

B = 0000 1101

\-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011

下表顯示了 C++ 支持的位運算符。假設變量 A 的值為 60，變量 B 的值為 13，則：

| 運算符 | 描述                                                         | 實例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 如果同時存在於兩個操作數中，二進制 AND 運算符複製一位到結果中。 | (A & B) 將得到 12，即為 0000 1100                            |
| \|     | 如果存在於任一操作數中，二進制 OR 運算符複製一位到結果中。   | (A \| B) 將得到 61，即為 0011 1101                           |
| ^      | 如果存在於其中一個操作數中但不同時存在於兩個操作數中，二進制異或運算符複製一位到結果中。 | (A ^ B) 將得到 49，即為 0011 0001                            |
| ~      | 二進制補碼運算符是一元運算符，具有"翻轉"位效果，即0變成1，1變成0。 | (~A ) 將得到 -61，即為 1100 0011，一個有符號二進制數的補碼形式。 |
| <<     | 二進制左移運算符。左操作數的值向左移動右操作數指定的位數。   | A << 2 將得到 240，即為 1111 0000                            |
| >>     | 二進制右移運算符。左操作數的值向右移動右操作數指定的位數。   | A >> 2 將得到 15，即為 0000 1111                             |

### 實例

請看下面的實例，瞭解 C++ 中可用的位運算符。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   unsigned int a = 60;      // 60 = 0011 1100  
   unsigned int b = 13;      // 13 = 0000 1101
   int c = 0;           
 
   c = a & b;             // 12 = 0000 1100
   cout << "Line 1 - c 的值是 " << c << endl ; 
   c = a | b;             // 61 = 0011 1101
   cout << "Line 2 - c 的值是 " << c << endl ; 
   c = a ^ b;             // 49 = 0011 0001
   cout << "Line 3 - c 的值是 " << c << endl ; 
   c = ~a;                // -61 = 1100 0011
   cout << "Line 4 - c 的值是 " << c << endl ; 
   c = a << 2;            // 240 = 1111 0000
   cout << "Line 5 - c 的值是 " << c << endl ; 
   c = a >> 2;            // 15 = 0000 1111
   cout << "Line 6 - c 的值是 " << c << endl ; 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```
 
Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15
```

## 賦值運算符

下表列出了 C++ 支持的賦值運算符：

| 運算符 | 描述                                                         | 實例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 簡單的賦值運算符，把右邊操作數的值賦給左邊操作數             | C = A + B 將把 A + B 的值賦給 C |
| +=     | 加且賦值運算符，把右邊操作數加上左邊操作數的結果賦值給左邊操作數 | C += A 相當於 C = C + A         |
| -=     | 減且賦值運算符，把左邊操作數減去右邊操作數的結果賦值給左邊操作數 | C -= A 相當於 C = C - A         |
| *=     | 乘且賦值運算符，把右邊操作數乘以左邊操作數的結果賦值給左邊操作數 | C *= A 相當於 C = C * A         |
| /=     | 除且賦值運算符，把左邊操作數除以右邊操作數的結果賦值給左邊操作數 | C /= A 相當於 C = C / A         |
| %=     | 求模且賦值運算符，求兩個操作數的模賦值給左邊操作數           | C %= A 相當於 C = C % A         |
| <<=    | 左移且賦值運算符                                             | C <<= 2 等同於 C = C << 2       |
| >>=    | 右移且賦值運算符                                             | C >>= 2 等同於 C = C >> 2       |
| &=     | 按位與且賦值運算符                                           | C &= 2 等同於 C = C & 2         |
| ^=     | 按位異或且賦值運算符                                         | C ^= 2 等同於 C = C ^ 2         |
| \|=    | 按位或且賦值運算符                                           | C \|= 2 等同於 C = C \| 2       |

### 實例

請看下面的實例，瞭解 C++ 中可用的賦值運算符。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 21;   int c ; 
   c =  a;   cout << "Line 1 - =  運算符實例，c 的值 = : " <<c<< endl ; 
   c +=  a;   cout << "Line 2 - += 運算符實例，c 的值 = : " <<c<< endl ; 
   c -=  a;   cout << "Line 3 - -= 運算符實例，c 的值 = : " <<c<< endl ; 
   c *=  a;   cout << "Line 4 - *= 運算符實例，c 的值 = : " <<c<< endl ; 
   c /=  a;   cout << "Line 5 - /= 運算符實例，c 的值 = : " <<c<< endl ; 
   c  = 200;   c %=  a;   cout << "Line 6 - %= 運算符實例，c 的值 = : " <<c<< endl ; 
   c <<=  2;   cout << "Line 7 - <<= 運算符實例，c 的值 = : " <<c<< endl ; 
   c >>=  2;   cout << "Line 8 - >>= 運算符實例，c 的值 = : " <<c<< endl ; 
   c &=  2;   cout << "Line 9 - &= 運算符實例，c 的值 = : " <<c<< endl ; 
   c ^=  2;   cout << "Line 10 - ^= 運算符實例，c 的值 = : " <<c<< endl ; 
   c |=  2;   cout << "Line 11 - |= 運算符實例，c 的值 = : " <<c<< endl ; 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```cpp
Line 1 - =  運算符實例，c 的值 = 21Line 2 - += 運算符實例，c 的值 = 42Line 3 - -= 運算符實例，c 的值 = 21Line 4 - *= 運算符實例，c 的值 = 441Line 5 - /= 運算符實例，c 的值 = 21Line 6 - %= 運算符實例，c 的值 = 11Line 7 - <<= 運算符實例，c 的值 = 44Line 8 - >>= 運算符實例，c 的值 = 11Line 9 - &= 運算符實例，c 的值 = 2Line 10 - ^= 運算符實例，c 的值 = 0Line 11 - |= 運算符實例，c 的值 = 2
```

## 雜項運算符

下表列出了 C++ 支持的其他一些重要的運算符。

| 運算符               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 運算符](https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html)返回變量的大小。例如，sizeof(a) 將返回 4，其中 a 是整數。 |
| Condition ? X : Y    | [條件運算符](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 為真 ? 則值為 X : 否則值為 Y。 |
| ,                    | [逗號運算符](https://edu.aliyun.com/cplusplus/cpp-comma-operator.html)會順序執行一系列運算。整個逗號表達式的值是以逗號分隔的列表中的最後一個表達式的值。 |
| .（點）和 ->（箭頭） | [成員運算符](https://edu.aliyun.com/cplusplus/cpp-member-operators.html)用於引用類、結構和共用體的成員。 |
| Cast                 | [強制轉換運算符](https://edu.aliyun.com/cplusplus/cpp-casting-operators.html)把一種數據類型轉換為另一種數據類型。例如，int(2.2000) 將返回 2。 |
| &                    | [指針運算符 &](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 返回變量的地址。例如 &a; 將給出變量的實際地址。 |
| *                    | [指針運算符 *](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 指向一個變量。例如，*var; 將指向變量 var。 |

## C++ 中的運算符優先級

運算符的優先級確定表達式中項的組合。這會影響到一個表達式如何計算。某些運算符比其他運算符有更高的優先級，例如，乘除運算符具有比加減運算符更高的優先級。

例如 x = 7 + 3 * 2，在這裡，x 被賦值為 13，而不是 20，因為運算符 * 具有比 + 更高的優先級，所以首先計算乘法 3*2，然後再加上 7。

下表將按運算符優先級從高到低列出各個運算符，具有較高優先級的運算符出現在表格的上面，具有較低優先級的運算符出現在表格的下面。在表達式中，較高優先級的運算符會優先被計算。

| 類別       | 運算符                            | 結合性   |
| :--------- | :-------------------------------- | :------- |
| 後綴       | () [] -> . ++ - -                 | 從左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 從右到左 |
| 乘除       | * / %                             | 從左到右 |
| 加減       | + -                               | 從左到右 |
| 移位       | << >>                             | 從左到右 |
| 關係       | < <= > >=                         | 從左到右 |
| 相等       | == !=                             | 從左到右 |
| 位與 AND   | &                                 | 從左到右 |
| 位異或 XOR | ^                                 | 從左到右 |
| 位或 OR    | \|                                | 從左到右 |
| 邏輯與 AND | &&                                | 從左到右 |
| 邏輯或 OR  | \|\|                              | 從左到右 |
| 條件       | ?:                                | 從右到左 |
| 賦值       | = += -= *= /= %=>>= <<= &= ^= \|= | 從右到左 |
| 逗號       | ,                                 | 從左到右 |

### 實例

請看下面的實例，瞭解 C++ 中運算符的優先級。

複製並黏貼下面的 C++ 程序到 test.cpp 文件中，編譯並運行程序。

對比有括號和沒有括號時的區別，這將產生不同的結果。因為 ()、 /、 * 和 + 有不同的優先級，高優先級的操作符將優先計算。

## 實例

```cpp
#include <iostream>using namespace std; 
int main(){
   int a = 20;   int b = 10;   int c = 15;   int d = 5;   int e; 
   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   cout << "(a + b) * c / d 的值是 " << e << endl ; 
   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   cout << "((a + b) * c) / d 的值是 " << e << endl ; 
   e = (a + b) * (c / d);   // (30) * (15/5)
   cout << "(a + b) * (c / d) 的值是 " << e << endl ; 
   e = a + (b * c) / d;     //  20 + (150/5)
   cout << "a + (b * c) / d 的值是 " << e << endl ;  
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生以下結果：

```cpp
(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50
```

# C++ 循環

有的時候，可能需要多次執行同一塊代碼。一般情況下，語句是順序執行的：函數中的第一個語句先執行，接著是第二個語句，依此類推。

編程語言提供了允許更為複雜的執行路徑的多種控制結構。

循環語句允許我們多次執行一個語句或語句組，下面是大多數編程語言中循環語句的一般形式：

![img](https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png)

## 循環類型

C++ 編程語言提供了以下幾種循環類型。點擊鏈接查看每個類型的細節。

| 循環類型        | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| while 循環      | 當給定條件為真時，重複語句或語句組。它會在執行循環主體之前測試條件。 |
| for 循環        | 多次執行一個語句序列，簡化管理循環變量的代碼。               |
| do...while 循環 | 除了它是在循環主體結尾測試條件外，其他與 while 語句類似。    |
| 嵌套循環        | 您可以在 while、for 或 do..while 循環內使用一個或多個循環。  |

 

## 循環控制語句

循環控制語句更改執行的正常序列。當執行離開一個範圍時，所有在該範圍中創建的自動對象都會被銷燬。

C++ 提供了下列的控制語句。點擊鏈接查看每個語句的細節。

| 控制語句      | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| break 語句    | 終止 **loop** 或 **switch** 語句，程序流將繼續執行緊接著 loop 或 switch 的下一條語句。 |
| continue 語句 | 引起循環跳過主體的剩餘部分，立即重新開始測試條件。           |
| goto 語句     | 將控制轉移到被標記的語句。但是不建議在程序中使用 goto 語句。 |

 

## 無限循環

如果條件永遠不為假，則循環將變成無限循環。**for** 循環在傳統意義上可用於實現無限循環。由於構成循環的三個表達式中任何一個都不是必需的，您可以將某些條件表達式留空來構成一個無限循環。

```cpp
#include <iostream>using namespace std;
 int main (){

   for( ; ; )
   {
      printf("This loop will run forever.\n");
   }

   return 0;}
```

當條件表達式不存在時，它被假設為真。您也可以設置一個初始值和增量表達式，但是一般情況下，C++ 程序員偏向於使用 for(;;) 結構來表示一個無限循環。

**注意：**您可以按 Ctrl + C 鍵終止一個無限循環。

# C++ 判斷

判斷結構要求程序員指定一個或多個要評估或測試的條件，以及條件為真時要執行的語句（必需的）和條件為假時要執行的語句（可選的）。

下面是大多數編程語言中典型的判斷結構的一般形式：

![img](https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png)

## 判斷語句

C++ 編程語言提供了以下類型的判斷語句。點擊鏈接查看每個語句的細節。

| 語句             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| if 語句          | 一個 **if 語句** 由一個布爾表達式後跟一個或多個語句組成。    |
| if...else 語句   | 一個 **if 語句** 後可跟一個可選的 **else 語句**，else 語句在布爾表達式為假時執行。 |
| 嵌套 if 語句     | 您可以在一個 **if** 或 **else if** 語句內使用另一個 **if** 或 **else if** 語句。 |
| switch 語句      | 一個 **switch** 語句允許測試一個變量等於多個值時的情況。     |
| 嵌套 switch 語句 | 您可以在一個 **switch** 語句內使用另一個 **switch** 語句。   |

 

## ? : 運算符

我們已經在前面的章節中講解了 [**條件運算符 ? :**](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)，可以用來替代 **if...else** 語句。它的一般形式如下：

```cpp
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表達式。請注意，冒號的使用和位置。

? 表達式的值是由 Exp1 決定的。如果 Exp1 為真，則計算 Exp2 的值，結果即為整個 ? 表達式的值。如果 Exp1 為假，則計算 Exp3 的值，結果即為整個 ? 表達式的值。

# C++ 函數

函數是一組一起執行一個任務的語句。每個 C++ 程序都至少有一個函數，即主函數 **main()** ，所有簡單的程序都可以定義其他額外的函數。

您可以把代碼劃分到不同的函數中。如何劃分代碼到不同的函數中是由您來決定的，但在邏輯上，劃分通常是根據每個函數執行一個特定的任務來進行的。

函數**聲明**告訴編譯器函數的名稱、返回類型和參數。函數**定義**提供了函數的實際主體。

C++ 標準庫提供了大量的程序可以調用的內置函數。例如，函數 **strcat()** 用來連接兩個字符串，函數 **memcpy()** 用來複制內存到另一個位置。

函數還有很多叫法，比如方法、子例程或程序，等等。

## 定義函數

C++ 中的函數定義的一般形式如下：

```cpp
return_type function_name( parameter list ){   body of the function}
```

在 C++ 中，函數由一個函數頭和一個函數主體組成。下面列出一個函數的所有組成部分：

- **返回類型：**一個函數可以返回一個值。**return_type** 是函數返回的值的數據類型。有些函數執行所需的操作而不返回值，在這種情況下，return_type 是關鍵字 **void**。
- **函數名稱：**這是函數的實際名稱。函數名和參數列表一起構成了函數簽名。
- **參數：**參數就像是佔位符。當函數被調用時，您向參數傳遞一個值，這個值被稱為實際參數。參數列表包括函數參數的類型、順序、數量。參數是可選的，也就是說，函數可能不包含參數。
- **函數主體：**函數主體包含一組定義函數執行任務的語句。

## 實例

以下是 **max()** 函數的源代碼。該函數有兩個參數 num1 和 num2，會返回這兩個數中較大的那個數：

```cpp
// 函數返回兩個數中較大的那個數 int max(int num1, int num2) {   // 局部變量聲明   int result;    if (num1 > num2)      result = num1;   else      result = num2;    return result; }
```

## 函數聲明

函數**聲明**會告訴編譯器函數名稱及如何調用函數。函數的實際主體可以單獨定義。

函數聲明包括以下幾個部分：

```cpp
return_type function_name( parameter list );
```

針對上面定義的函數 max()，以下是函數聲明：

```cpp
int max(int num1, int num2);
```

在函數聲明中，參數的名稱並不重要，只有參數的類型是必需的，因此下面也是有效的聲明：

```cpp
int max(int, int);
```

當您在一個源文件中定義函數且在另一個文件中調用函數時，函數聲明是必需的。在這種情況下，您應該在調用函數的文件頂部聲明函數。

## 調用函數

創建 C++ 函數時，會定義函數做什麼，然後通過調用函數來完成已定義的任務。

當程序調用函數時，程序控制權會轉移給被調用的函數。被調用的函數執行已定義的任務，當函數的返回語句被執行時，或到達函數的結束括號時，會把程序控制權交還給主程序。

調用函數時，傳遞所需參數，如果函數返回一個值，則可以存儲返回值。例如：

```cpp
#include <iostream>using namespace std;
 // 函數聲明int max(int num1, int num2);
 int main (){
   // 局部變量聲明
   int a = 100;
   int b = 200;
   int ret;
 
   // 調用函數來獲取最大值
   ret = max(a, b);
 
   cout << "Max value is : " << ret << endl;
 
   return 0;}
 // 函數返回兩個數中較大的那個數int max(int num1, int num2) {
   // 局部變量聲明
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; }
```

把 max() 函數和 main() 函數放一塊，編譯源代碼。當運行最後的可執行文件時，會產生下列結果：

```cpp
Max value is : 200
```

## 函數參數

如果函數要使用參數，則必須聲明接受參數值的變量。這些變量稱為函數的**形式參數**。

形式參數就像函數內的其他局部變量，在進入函數時被創建，退出函數時被銷燬。

當調用函數時，有兩種向函數傳遞參數的方式：

| 調用類型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [傳值調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html) | 該方法把參數的實際值複製給函數的形式參數。在這種情況下，修改函數內的形式參數對實際參數沒有影響。 |
| [指針調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html) | 該方法把參數的地址複製給形式參數。在函數內，該地址用於訪問調用中要用到的實際參數。這意味著，修改形式參數會影響實際參數。 |
| [引用調用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html) | 該方法把參數的引用複製給形式參數。在函數內，該引用用於訪問調用中要用到的實際參數。這意味著，修改形式參數會影響實際參數。 |

默認情況下，C++ 使用**傳值調用**來傳遞參數。一般來說，這意味著函數內的代碼不能改變用於調用函數的參數。之前提到的實例，調用 max() 函數時，使用了相同的方法。

## 參數的默認值

當您定義一個函數，您可以為參數列表中後邊的每一個參數指定默認值。當調用函數時，如果實際參數的值留空，則使用這個默認值。

這是通過在函數定義中使用賦值運算符來為參數賦值的。調用函數時，如果未傳遞參數的值，則會使用默認值，如果指定了值，則會忽略默認值，使用傳遞的值。請看下面的實例：

```cpp
#include <iostream>using namespace std;
 int sum(int a, int b=20){
  int result;

  result = a + b;
  
  return (result);}int main (){
   // 局部變量聲明
   int a = 100;
   int b = 200;
   int result;
 
   // 調用函數來添加值
   result = sum(a, b);
   cout << "Total value is :" << result << endl;

   // 再次調用函數
   result = sum(a);
   cout << "Total value is :" << result << endl;
 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Total value is :300Total value is :120
```

------

## Lambda 函數與表達式

C++11 提供了對匿名函數的支持,稱為 Lambda 函數(也叫 Lambda 表達式)。

Lambda 表達式把函數看作對象。Lambda 表達式可以像對象一樣使用，比如可以將它們賦給變量和作為參數傳遞，還可以像函數一樣對其求值。

Lambda 表達式本質上與函數聲明非常類似。Lambda 表達式具體形式如下:

```cpp
[capture](parameters)->return-type{body}
```

例如：

```
 
[](int x, int y){ return x < y ; }
```

如果沒有參數可以表示為：

```cpp
[capture](parameters){body}
```

例如：

```cpp
[]{ ++global_x; }
```

在一個更為複雜的例子中，返回類型可以被明確的指定如下：

```cpp
[](int x, int y) -> int { int z = x + y; return z + x; }
```

本例中，一個臨時的參數 z 被創建用來存儲中間結果。如同一般的函數，z 的值不會保留到下一次該不具名函數再次被調用時。

如果 lambda 函數沒有傳回值（例如 void），其回返類型可被完全忽略。

在Lambda表達式內可以訪問當前作用域的變量，這是Lambda表達式的閉包（Closure）行為。 與JavaScript閉包不同，C++變量傳遞有傳值和傳引用的區別。可以通過前面的[]來指定：

```cpp
[]      // 沒有定義任何變量。使用未定義變量會引發錯誤。[x, &y] // x以傳值方式傳入（默認），y以引用方式傳入。[&]     // 任何被使用到的外部變量都隱式地以引用方式加以引用。[=]     // 任何被使用到的外部變量都隱式地以傳值方式加以引用。[&, x]  // x顯式地以傳值方式加以引用。其餘變量以引用方式加以引用。[=, &z] // z顯式地以引用方式加以引用。其餘變量以傳值方式加以引用。
```

另外有一點需要注意。對於[=]或[&]的形式，lambda 表達式可以直接使用 this 指針。但是，對於[]的形式，如果要使用 this 指針，必須顯式傳入：

```cpp
[this]() { this->someFunc(); }();
```

# C++ 數字

通常，當我們需要用到數字時，我們會使用原始的數據類型，如 int、short、long、float 和 double 等等。這些用於數字的數據類型，其可能的值和數值範圍，我們已經在 C++ 數據類型一章中討論過。

## C++ 定義數字

我們已經在之前章節的各種實例中定義過數字。下面是一個 C++ 中定義各種類型數字的綜合實例：

```cpp
#include <iostream>using namespace std;
 int main (){
   // 數字定義
   short  s;
   int    i;
   long   l;
   float  f;
   double d;
   
   // 數字賦值
   s = 10;      
   i = 1000;    
   l = 1000000; 
   f = 230.47;  
   d = 30949.374;
   
   // 數字輸出
   cout << "short  s :" << s << endl;
   cout << "int    i :" << i << endl;
   cout << "long   l :" << l << endl;
   cout << "float  f :" << f << endl;
   cout << "double d :" << d << endl;
 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
short  s :10int    i :1000long   l :1000000float  f :230.47double d :30949.4
```

## C++ 數學運算

在 C++ 中，除了可以創建各種函數，還包含了各種有用的函數供您使用。這些函數寫在標準 C 和 C++ 庫中，叫做**內置**函數。您可以在程序中引用這些函數。

C++ 內置了豐富的數學函數，可對各種數字進行運算。下表列出了 C++ 中一些有用的內置的數學函數。

為了利用這些函數，您需要引用數學頭文件 **<cmath>**。

| 序號 | 函數 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **double cos(double);** 該函數返回弧度角（double 型）的餘弦。 |
| 2    | **double sin(double);** 該函數返回弧度角（double 型）的正弦。 |
| 3    | **double tan(double);** 該函數返回弧度角（double 型）的正切。 |
| 4    | **double log(double);** 該函數返回參數的自然對數。           |
| 5    | **double pow(double, double);** 假設第一個參數為 x，第二個參數為 y，則該函數返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 該函數返回兩個參數的平方總和的平方根，也就是說，參數為一個直角三角形的兩個直角邊，函數會返回斜邊的長度。 |
| 7    | **double sqrt(double);** 該函數返回參數的平方根。            |
| 8    | **int abs(int);** 該函數返回整數的絕對值。                   |
| 9    | **double fabs(double);** 該函數返回任意一個十進制數的絕對值。 |
| 10   | **double floor(double);** 該函數返回一個小於或等於傳入參數的最大整數。 |

下面是一個關於數學運算的簡單實例：

```cpp
#include <iostream>#include <cmath>using namespace std;
 int main (){
   // 數字定義
   short  s = 10;
   int    i = -1000;
   long   l = 100000;
   float  f = 230.47;
   double d = 200.374;

   // 數學運算
   cout << "sin(d) :" << sin(d) << endl;
   cout << "abs(i)  :" << abs(i) << endl;
   cout << "floor(d) :" << floor(d) << endl;
   cout << "sqrt(f) :" << sqrt(f) << endl;
   cout << "pow( d, 2) :" << pow(d, 2) << endl;
 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
sign(d) :-0.634939abs(i)  :1000floor(d) :200sqrt(f) :15.1812pow( d, 2 ) :40149.7
```

## C++ 隨機數

在許多情況下，需要生成隨機數。關於隨機數生成器，有兩個相關的函數。一個是 **rand()**，該函數只返回一個偽隨機數。生成隨機數之前必須先調用 **srand()** 函數。

下面是一個關於生成隨機數的簡單實例。實例中使用了 **time()** 函數來獲取系統時間的秒數，通過調用 rand() 函數來生成隨機數：

```cpp
#include <iostream>#include <ctime>#include <cstdlib>using namespace std;
 int main (){
   int i,j;
 
   // 設置種子
   srand( (unsigned)time( NULL ) );

   /* 生成 10 個隨機數 */
   for( i = 0; i < 10; i++ )
   {
      // 生成實際的隨機數
      j= rand();
      cout <<"隨機數： " << j << endl;
   }

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
隨機數： 1748144778隨機數： 630873888隨機數： 2134540646隨機數： 219404170隨機數： 902129458隨機數： 920445370隨機數： 1319072661隨機數： 257938873隨機數： 1256201101隨機數： 580322989
```

# C++ 數組

C++ 支持**數組**數據結構，它可以存儲一個固定大小的相同類型元素的順序集合。數組是用來存儲一系列數據，但它往往被認為是一系列相同類型的變量。

數組的聲明並不是聲明一個個單獨的變量，比如 number0、number1、...、number99，而是聲明一個數組變量，比如 numbers，然後使用 numbers[0]、numbers[1]、...、numbers[99] 來代表一個個單獨的變量。數組中的特定元素可以通過索引訪問。

所有的數組都是由連續的內存位置組成。最低的地址對應第一個元素，最高的地址對應最後一個元素。

## 聲明數組

在 C++ 中要聲明一個數組，需要指定元素的類型和元素的數量，如下所示：

```cpp
type arrayName [ arraySize ];
```

這叫做一維數組。**arraySize** 必須是一個大於零的整數常量，**type** 可以是任意有效的 C++ 數據類型。例如，要聲明一個類型為 double 的包含 10 個元素的數組 **balance**，聲明語句如下：

```cpp
double balance[10];
```

現在 *balance* 是一個可用的數組，可以容納 10 個類型為 double 的數字。

## 初始化數組

在 C++ 中，您可以逐個初始化數組，也可以使用一個初始化語句，如下所示：

```cpp
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

大括號 { } 之間的值的數目不能大於我們在數組聲明時在方括號 [ ] 中指定的元素數目。

如果您省略掉了數組的大小，數組的大小則為初始化時元素的個數。因此，如果：

```cpp
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

您將創建一個數組，它與前一個實例中所創建的數組是完全相同的。下面是一個為數組中某個元素賦值的實例：

```cpp
balance[4] = 50.0;
```

上述的語句把數組中第五個元素的值賦為 50.0。所有的數組都是以 0 作為它們第一個元素的索引，也被稱為基索引，數組的最後一個索引是數組的總大小減去 1。以下是上面所討論的數組的的圖形表示：

![數組表示](https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg)

## 訪問數組元素

數組元素可以通過數組名稱加索引進行訪問。元素的索引是放在方括號內，跟在數組名稱的後邊。例如：

```cpp
double salary = balance[9];
```

上面的語句將把數組中第 10 個元素的值賦給 salary 變量。下面的實例使用了上述的三個概念，即，聲明數組、數組賦值、訪問數組：

```cpp
#include <iostream>using namespace std;
 #include <iomanip>using std::setw;
 int main (){
   int n[ 10 ]; // n 是一個包含 10 個整數的數組
 
   // 初始化數組元素          
   for ( int i = 0; i < 10; i++ )
   {
      n[ i ] = i + 100; // 設置元素 i 為 i + 100
   }
   cout << "Element" << setw( 13 ) << "Value" << endl;
 
   // 輸出數組中每個元素的值                     
   for ( int j = 0; j < 10; j++ )
   {
      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;
   }
 
   return 0;}
```

上面的程序使用了 **setw()** 函數來格式化輸出。當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Element        Value
      0          100
      1          101
      2          102
      3          103
      4          104
      5          105
      6          106
      7          107
      8          108
      9          109
```

## C++ 中數組詳解

在 C++ 中，數組是非常重要的，我們需要了解更多有關數組的細節。下面列出了 C++ 程序員必須清楚的一些與數組相關的重要概念：

| 概念           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| 多維數組       | C++ 支持多維數組。多維數組最簡單的形式是二維數組。           |
| 指向數組的指針 | 您可以通過指定不帶索引的數組名稱來生成一個指向數組中第一個元素的指針。 |
| 傳遞數組給函數 | 您可以通過指定不帶索引的數組名稱來給函數傳遞一個指向數組的指針。 |
| 從函數返回數組 | C++ 允許從函數返回數組。                                     |

# C++ 字符串

C++ 提供了以下兩種類型的字符串表示形式：

- C 風格字符串
- C++ 引入的 string 類類型

## C 風格字符串

C 風格的字符串起源於 C 語言，並在 C++ 中繼續得到支持。字符串實際上是使用 **null** 字符 '\0' 終止的一維字符數組。因此，一個以 null 結尾的字符串，包含了組成字符串的字符。

下面的聲明和初始化創建了一個 "Hello" 字符串。由於在數組的末尾存儲了空字符，所以字符數組的大小比單詞 "Hello" 的字符數多一個。

```cpp
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

依據數組初始化規則，您可以把上面的語句寫成以下語句：

```cpp
char greeting[] = "Hello";
```

以下是 C/C++ 中定義的字符串的內存表示：

![img](https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg)

其實，您不需要把 *null* 字符放在字符串常量的末尾。C++ 編譯器會在初始化數組時，自動把 '\0' 放在字符串的末尾。讓我們嘗試輸出上面的字符串：

## 實例

```cpp
#include <iostream>
 using namespace std; 
int main (){
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; 
   cout << "Greeting message: ";   cout << greeting << endl; 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Greeting message: Hello
```

C++ 中有大量的函數用來操作以 null 結尾的字符串：supports a wide range of functions that manipulate null-terminated strings:

| 序號 | 函數 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 複製字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 連接字符串 s2 到字符串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字符串 s1 的長度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，則返回 0；如果 s1<s2 則返回小於 0；如果 s1>s2 則返回大於 0。 |
| 5    | **strchr(s1, ch);** 返回一個指針，指向字符串 s1 中字符 ch 的第一次出現的位置。 |
| 6    | **strstr(s1, s2);** 返回一個指針，指向字符串 s1 中字符串 s2 的第一次出現的位置。 |

下面的實例使用了上述的一些函數：

## 實例

```cpp
#include <iostream>#include <cstring>
 using namespace std; 
int main (){
   char str1[11] = "Hello";   char str2[11] = "World";   char str3[11];   int  len ; 
   // 複製 str1 到 str3
   strcpy( str3, str1);   cout << "strcpy( str3, str1) : " << str3 << endl; 
   // 連接 str1 和 str2
   strcat( str1, str2);   cout << "strcat( str1, str2): " << str1 << endl; 
   // 連接後，str1 的總長度
   len = strlen(str1);   cout << "strlen(str1) : " << len << endl; 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
strcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10
```

## C++ 中的 String 類

C++ 標準庫提供了 **string** 類類型，支持上述所有的操作，另外還增加了其他更多的功能。我們將學習 C++ 標準庫中的這個類，現在讓我們先來看看下面這個實例：

現在您可能還無法透徹地理解這個實例，因為到目前為止我們還沒有討論類和對象。所以現在您可以只是粗略地看下這個實例，等理解了面向對象的概念之後再回頭來理解這個實例。

## 實例

```cpp
#include <iostream>#include <string>
 using namespace std; 
int main (){
   string str1 = "Hello";   string str2 = "World";   string str3;   int  len ; 
   // 複製 str1 到 str3
   str3 = str1;   cout << "str3 : " << str3 << endl; 
   // 連接 str1 和 str2
   str3 = str1 + str2;   cout << "str1 + str2 : " << str3 << endl; 
   // 連接後，str3 的總長度
   len = str3.size();   cout << "str3.size() :  " << len << endl; 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
str3 : Hellostr1 + str2 : HelloWorldstr3.size() :  10
```

# C++ 指針

學習 C++ 的指針既簡單又有趣。通過指針，可以簡化一些 C++ 編程任務的執行，還有一些任務，如動態內存分配，沒有指針是無法執行的。所以，想要成為一名優秀的 C++ 程序員，學習指針是很有必要的。

正如您所知道的，每一個變量都有一個內存位置，每一個內存位置都定義了可使用連字號（&）運算符訪問的地址，它表示了在內存中的一個地址。請看下面的實例，它將輸出定義的變量地址：

```cpp
#include <iostream>using namespace std;int main (){
   int  var1;
   char var2[10];

   cout << "var1 變量的地址： ";
   cout << &var1 << endl;

   cout << "var2 變量的地址： ";
   cout << &var2 << endl;

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
var1 變量的地址： 0xbfebd5c0var2 變量的地址： 0xbfebd5b6
```

通過上面的實例，我們瞭解了什麼是內存地址以及如何訪問它。接下來讓我們看看什麼是指針。

## 什麼是指針？

**指針**是一個變量，其值為另一個變量的地址，即，內存位置的直接地址。就像其他變量或常量一樣，您必須在使用指針存儲其他變量地址之前，對其進行聲明。指針變量聲明的一般形式為：

```cpp
type *var-name;
```

在這裡，**type** 是指針的基類型，它必須是一個有效的 C++ 數據類型，**var-name** 是指針變量的名稱。用來聲明指針的星號 * 與乘法中使用的星號是相同的。但是，在這個語句中，星號是用來指定一個變量是指針。以下是有效的指針聲明：

```cpp
int    *ip;    /* 一個整型的指針 */double *dp;    /* 一個 double 型的指針 */float  *fp;    /* 一個浮點型的指針 */char   *ch;    /* 一個字符型的指針 */
```

所有指針的值的實際數據類型，不管是整型、浮點型、字符型，還是其他的數據類型，都是一樣的，都是一個代表內存地址的長的十六進制數。不同數據類型的指針之間唯一的不同是，指針所指向的變量或常量的數據類型不同。

## C++ 中使用指針

使用指針時會頻繁進行以下幾個操作：定義一個指針變量、把變量地址賦值給指針、訪問指針變量中可用地址的值。這些是通過使用一元運算符 ***** 來返回位於操作數所指定地址的變量的值。下面的實例涉及到了這些操作：

```cpp
#include <iostream>using namespace std;int main (){
   int  var = 20;   // 實際變量的聲明
   int  *ip;        // 指針變量的聲明

   ip = &var;       // 在指針變量中存儲 var 的地址

   cout << "Value of var variable: ";
   cout << var << endl;

   // 輸出在指針變量中存儲的地址
   cout << "Address stored in ip variable: ";
   cout << ip << endl;

   // 訪問指針中地址的值
   cout << "Value of *ip variable: ";
   cout << *ip << endl;

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Value of var variable: 20Address stored in ip variable: 0xbfc601acValue of *ip variable: 20
```

## C++ 指針詳解

在 C++ 中，有很多指針相關的概念，這些概念都很簡單，但是都很重要。下面列出了 C++ 程序員必須清楚的一些與指針相關的重要概念：

| 概念               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| C++ Null 指針      | C++ 支持空指針。NULL 指針是一個定義在標準庫中的值為零的常量。 |
| C++ 指針的算術運算 | 可以對指針進行四種算術運算：++、--、+、-                     |
| C++ 指針 vs 數組   | 指針和數組之間有著密切的關係。                               |
| C++ 指針數組       | 可以定義用來存儲指針的數組。                                 |
| C++ 指向指針的指針 | C++ 允許指向指針的指針。                                     |
| C++ 傳遞指針給函數 | 通過引用或地址傳遞參數，使傳遞的參數在調用函數中被改變。     |
| C++ 從函數返回指針 | C++ 允許函數返回指針到局部變量、靜態變量和動態內存分配。     |

# C++ 引用

引用變量是一個別名，也就是說，它是某個已存在變量的另一個名字。一旦把引用初始化為某個變量，就可以使用該引用名稱或變量名稱來指向變量。

## C++ 引用 vs 指針

引用很容易與指針混淆，它們之間有三個主要的不同：

- 不存在空引用。引用必須連接到一塊合法的內存。
- 一旦引用被初始化為一個對象，就不能被指向到另一個對象。指針可以在任何時候指向到另一個對象。
- 引用必須在創建時被初始化。指針可以在任何時間被初始化。

## C++ 中創建引用

試想變量名稱是變量附屬在內存位置中的標籤，您可以把引用當成是變量附屬在內存位置中的第二個標籤。因此，您可以通過原始變量名稱或引用來訪問變量的內容。例如：

```cpp
int i = 17;
```

我們可以為 i 聲明引用變量，如下所示：

```cpp
int&    r = i;
```

在這些聲明中，& 讀作**引用**。因此，第一個聲明可以讀作 "r 是一個初始化為 i 的整型引用"，第二個聲明可以讀作 "s 是一個初始化為 d 的 double 型引用"。下面的實例使用了 int 和 double 引用：

```cpp
#include <iostream>
 using namespace std;
 int main (){
   // 聲明簡單的變量
   int    i;
   double d;
 
   // 聲明引用變量
   int&    r = i;
   double& s = d;
   
   i = 5;
   cout << "Value of i : " << i << endl;
   cout << "Value of i reference : " << r  << endl;
 
   d = 11.7;
   cout << "Value of d : " << d << endl;
   cout << "Value of d reference : " << s  << endl;
   
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Value of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7
```

引用通常用於函數參數列表和函數返回值。下面列出了 C++ 程序員必須清楚的兩個與 C++ 引用相關的重要概念：

| 概念             | 描述                                                     |
| :--------------- | :------------------------------------------------------- |
| 把引用作為參數   | C++ 支持把引用作為參數傳給函數，這比傳一般的參數更安全。 |
| 把引用作為返回值 | 可以從 C++ 函數中返回引用，就像返回其他數據類型一樣。    |

# C++ 日期 & 時間

C++ 標準庫沒有提供所謂的日期類型。C++ 繼承了 C 語言用於日期和時間操作的結構和函數。為了使用日期和時間相關的函數和結構，需要在 C++ 程序中引用 <ctime> 頭文件。

有四個與時間相關的類型：**clock_t、time_t、size_t** 和 **tm**。類型 clock_t、size_t 和 time_t 能夠把系統時間和日期表示為某種整數。

結構類型 **tm** 把日期和時間以 C 結構的形式保存，tm 結構的定義如下：

```cpp
struct tm {
  int tm_sec;   // 秒，正常範圍從 0 到 59，但允許至 61
  int tm_min;   // 分，範圍從 0 到 59
  int tm_hour;  // 小時，範圍從 0 到 23
  int tm_mday;  // 一月中的第幾天，範圍從 1 到 31
  int tm_mon;   // 月，範圍從 0 到 11
  int tm_year;  // 自 1900 年起的年數
  int tm_wday;  // 一週中的第幾天，範圍從 0 到 6，從星期日算起
  int tm_yday;  // 一年中的第幾天，範圍從 0 到 365，從 1 月 1 日算起
  int tm_isdst; // 夏令時}
```

下面是 C/C++ 中關於日期和時間的重要函數。所有這些函數都是 C/C++ 標準庫的組成部分，您可以在 C++ 標準庫中查看一下各個函數的細節。

| 序號 | 函數 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **time_t time(time_t \*time);** 該函數返回系統的當前日曆時間，自 1970 年 1 月 1 日以來經過的秒數。如果系統沒有時間，則返回 .1。 |
| 2    | **char \*ctime(const time_t \*time);** 該返回一個表示當地時間的字符串指針，字符串形式 *day month year hours:minutes:seconds year\n\0*。 |
| 3    | **struct tm \*localtime(const time_t \*time);** 該函數返回一個指向表示本地時間的 **tm** 結構的指針。 |
| 4    | **clock_t clock(void);** 該函數返回程序執行起（一般為程序的開頭），處理器時鐘所使用的時間。如果時間不可用，則返回 .1。 |
| 5    | **char \* asctime ( const struct tm \* time );** 該函數返回一個指向字符串的指針，字符串包含了 time 所指向結構中存儲的信息，返回形式為：day month date hours:minutes:seconds year\n\0。 |
| 6    | **struct tm \*gmtime(const time_t \*time);** 該函數返回一個指向 time 的指針，time 為 tm 結構，用協調世界時（UTC）也被稱為格林尼治標準時間（GMT）表示。 |
| 7    | **time_t mktime(struct tm \*time);** 該函數返回日曆時間，相當於 time 所指向結構中存儲的時間。 |
| 8    | **double difftime ( time_t time2, time_t time1 );** 該函數返回 time1 和 time2 之間相差的秒數。 |
| 9    | **size_t strftime();** 該函數可用於格式化日期和時間為指定的格式。 |

## 當前日期和時間

下面的實例獲取當前系統的日期和時間，包括本地時間和協調世界時（UTC）。

```cpp
#include <iostream>#include <ctime>using namespace std;int main( ){
   // 基於當前系統的當前日期/時間
   time_t now = time(0);
   
   // 把 now 轉換為字符串形式
   char* dt = ctime(&now);

   cout << "本地日期和時間：" << dt << endl;

   // 把 now 轉換為 tm 結構
   tm *gmtm = gmtime(&now);
   dt = asctime(gmtm);
   cout << "UTC 日期和時間："<< dt << endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
本地日期和時間：Sat Jan  8 20:07:41 2011UTC 日期和時間：Sun Jan  9 03:07:41 2011
```

## 使用結構 tm 格式化時間

**tm** 結構在 C/C++ 中處理日期和時間相關的操作時，顯得尤為重要。tm 結構以 C 結構的形式保存日期和時間。大多數與時間相關的函數都使用了 tm 結構。下面的實例使用了 tm 結構和各種與日期和時間相關的函數。

在練習使用結構之前，需要對 C 結構有基本的瞭解，並懂得如何使用箭頭 -> 運算符來訪問結構成員。

```cpp
#include <iostream>#include <ctime>using namespace std;int main( ){
   // 基於當前系統的當前日期/時間
   time_t now = time(0);

   cout << "Number of sec since January 1,1970:" << now << endl;

   tm *ltm = localtime(&now);

   // 輸出 tm 結構的各個組成部分
   cout << "Year: "<< 1900 + ltm->tm_year << endl;
   cout << "Month: "<< 1 + ltm->tm_mon<< endl;
   cout << "Day: "<<  ltm->tm_mday << endl;
   cout << "Time: "<< 1 + ltm->tm_hour << ":";
   cout << 1 + ltm->tm_min << ":";
   cout << 1 + ltm->tm_sec << endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Number of sec since January 1, 1970:1294548238Year: 2011Month: 1Day: 8Time: 22: 44:59
```

# C++ 基本的輸入輸出

C++ 標準庫提供了一組豐富的輸入/輸出功能，我們將在後續的章節進行介紹。本章將討論 C++ 編程中最基本和最常見的 I/O 操作。

C++ 的 I/O 發生在流中，流是字節序列。如果字節流是從設備（如鍵盤、磁盤驅動器、網絡連接等）流向內存，這叫做**輸入操作**。如果字節流是從內存流向設備（如顯示屏、打印機、磁盤驅動器、網絡連接等），這叫做**輸出操作**。

## I/O 庫頭文件

下列的頭文件在 C++ 編程中很重要。

| 頭文件     | 函數和描述                                                   |
| :--------- | :----------------------------------------------------------- |
| <iostream> | 該文件定義了 **cin、cout、cerr** 和 **clog** 對象，分別對應於標準輸入流、標準輸出流、非緩衝標準錯誤流和緩衝標準錯誤流。 |
| <iomanip>  | 該文件通過所謂的參數化的流操縱器（比如 **setw** 和 **setprecision**），來聲明對執行標準化 I/O 有用的服務。 |
| <fstream>  | 該文件為用戶控制的文件處理聲明服務。我們將在文件和流的相關章節討論它的細節。 |

## 標準輸出流（cout）

預定義的對象 **cout** 是 **ostream** 類的一個實例。cout 對象"連接"到標準輸出設備，通常是顯示屏。**cout** 是與流插入運算符 << 結合使用的，如下所示：

```cpp
#include <iostream> using namespace std; int main( ){   char str[] = "Hello C++";    cout << "Value of str is : " << str << endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Value of str is : Hello C++
```

C++ 編譯器根據要輸出變量的數據類型，選擇合適的流插入運算符來顯示值。<< 運算符被重載來輸出內置類型（整型、浮點型、double 型、字符串和指針）的數據項。

流插入運算符 << 在一個語句中可以多次使用，如上面實例中所示，**endl** 用於在行末添加一個換行符。

## 標準輸入流（cin）

預定義的對象 **cin** 是 **istream** 類的一個實例。cin 對象附屬到標準輸入設備，通常是鍵盤。**cin** 是與流提取運算符 >> 結合使用的，如下所示：

```cpp
#include <iostream> using namespace std; int main( ){  
	char name[50];    cout << "請輸入您的名稱： ";   
	cin >> name;   cout << "您的名稱是： " << name << endl; }
```

當上面的代碼被編譯和執行時，它會提示用戶輸入名稱。當用戶輸入一個值，並按回車鍵，就會看到下列結果：

```cpp
請輸入您的名稱： cplusplus您的名稱是： cplusplus
```

C++ 編譯器根據要輸入值的數據類型，選擇合適的流提取運算符來提取值，並把它存儲在給定的變量中。

流提取運算符 >> 在一個語句中可以多次使用，如果要求輸入多個數據，可以使用如下語句：

```cpp
cin >> name >> age;
```

這相當於下面兩個語句：

```cpp
cin >> name;cin >> age;
```

## 標準錯誤流（cerr）

預定義的對象 **cerr** 是 **ostream** 類的一個實例。cerr 對象附屬到標準錯誤設備，通常也是顯示屏，但是 **cerr** 對象是非緩衝的，且每個流插入到 cerr 都會立即輸出。

**cerr** 也是與流插入運算符 << 結合使用的，如下所示：

```cpp
#include <iostream>
 using namespace std;
 int main( ){
   char str[] = "Unable to read....";
 
   cerr << "Error message : " << str << endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Error message : Unable to read....
```

## 標準日誌流（clog）

預定義的對象 **clog** 是 **ostream** 類的一個實例。clog 對象附屬到標準錯誤設備，通常也是顯示屏，但是 **clog** 對象是緩衝的。這意味著每個流插入到 clog 都會先存儲在緩衝在，直到緩衝填滿或者緩衝區刷新時才會輸出。

**clog** 也是與流插入運算符 << 結合使用的，如下所示：

```cpp
#include <iostream>
 using namespace std;
 int main( ){
   char str[] = "Unable to read....";
 
   clog << "Error message : " << str << endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Error message : Unable to read....
```

通過這些小實例，我們無法區分 cout、cerr 和 clog 的差異，但在編寫和執行大型程序時，它們之間的差異就變得非常明顯。所以良好的編程實踐告訴我們，使用 cerr 流來顯示錯誤消息，而其他的日誌消息則使用 clog 流來輸出。

# C++ 數據結構

C/C++ 數組允許定義可存儲相同類型數據項的變量，但是**結構**是 C++ 中另一種用戶自定義的可用的數據類型，它允許您存儲不同類型的數據項。

結構用於表示一條記錄，假設您想要跟蹤圖書館中書本的動態，您可能需要跟蹤每本書的下列屬性：

- Title ：標題
- Author ：作者
- Subject ：類目
- Book ID ：書的 ID

## 定義結構

為了定義結構，您必須使用 **struct** 語句。struct 語句定義了一個包含多個成員的新的數據類型，struct 語句的格式如下：

 

```cpp
struct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names;
```

**type_name** 是結構體類型的名稱，**member_type1 member_name1** 是標準的變量定義，比如 **int i;** 或者 **float f;** 或者其他有效的變量定義。在結構定義的末尾，最後一個分號之前，您可以指定一個或多個結構變量，這是可選的。下面是聲明一個結構體類型 **Books**，變量為 **book**：

```cpp
struct Books{   char  title[50];   char  author[50];   char  subject[100];      int   book_id;} book;
```

## 訪問結構成員

為了訪問結構的成員，我們使用**成員訪問運算符（.）**。成員訪問運算符是結構變量名稱和我們要訪問的結構成員之間的一個句號。

下面的實例演示了結構的用法：

## 實例

```cpp
#include <iostream>#include <cstring>
 using namespace std; 
// 聲明一個結構體類型 Books struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構體類型 Books 的變量 Book1
   Books Book2;        // 定義結構體類型 Books 的變量 Book2
 
   // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 輸出 Book1 信息
   cout << "第一本書標題 : " << Book1.title <<endl;   cout << "第一本書作者 : " << Book1.author <<endl;   cout << "第一本書類目 : " << Book1.subject <<endl;   cout << "第一本書 ID : " << Book1.book_id <<endl; 
   // 輸出 Book2 信息
   cout << "第二本書標題 : " << Book2.title <<endl;   cout << "第二本書作者 : " << Book2.author <<endl;   cout << "第二本書類目 : " << Book2.subject <<endl;   cout << "第二本書 ID : " << Book2.book_id <<endl; 
   return 0;}
```

實例中定義了結構體類似 Books 及其兩個變量 Book1 和 Book2。當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
第一本書標題 : C++ 教程第一本書作者 : Runoob第一本書類目 : 編程語言第一本書 ID : 12345第二本書標題 : CSS 教程第二本書作者 : Runoob第二本書類目 : 前端技術第二本書 ID : 12346
```

## 結構作為函數參數

您可以把結構作為函數參數，傳參方式與其他類型的變量或指針類似。您可以使用上面實例中的方式來訪問結構變量：

## 實例

```cpp
#include <iostream>#include <cstring>
 using namespace std;void printBook( struct Books book ); 
// 聲明一個結構體類型 Books struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構體類型 Books 的變量 Book1
   Books Book2;        // 定義結構體類型 Books 的變量 Book2
 
    // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   
   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 輸出 Book1 信息
   printBook( Book1 ); 
   // 輸出 Book2 信息
   printBook( Book2 ); 
   return 0;}void printBook( struct Books book ){
   cout << "書標題 : " << book.title <<endl;   cout << "書作者 : " 
   << book.author <<endl;   cout << "書類目 : " << book.subject <<endl;   
   cout << "書 ID : " << book.book_id <<endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
書標題 : C++ 教程書作者 : Runoob書類目 : 編程語言書 ID : 12345書標題 : CSS 教程書作者 : Runoob書類目 : 前端技術書 ID : 12346
```

## 指向結構的指針

您可以定義指向結構的指針，方式與定義指向其他類型變量的指針相似，如下所示：

```cpp
struct Books *struct_pointer;
```

現在，您可以在上述定義的指針變量中存儲結構變量的地址。為了查找結構變量的地址，請把 & 運算符放在結構名稱的前面，如下所示：

```cpp
struct_pointer = &Book1;
```

為了使用指向該結構的指針訪問結構的成員，您必須使用 -> 運算符，如下所示：

```cpp
struct_pointer->title;
```

讓我們使用結構指針來重寫上面的實例，這將有助於您理解結構指針的概念：

## 實例

```cpp
#include <iostream>#include <cstring>
 using namespace std;void printBook( struct Books *book ); 
struct Books{
   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; 
int main( ){
   Books Book1;        // 定義結構體類型 Books 的變量 Book1
   Books Book2;        // 定義結構體類型 Books 的變量 Book2
 
    // Book1 詳述
   strcpy( Book1.title, "C++ 教程");   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "編程語言");   Book1.book_id = 12345; 
   // Book2 詳述
   strcpy( Book2.title, "CSS 教程");   strcpy( Book2.author, "Runoob");   
   strcpy( Book2.subject, "前端技術");   Book2.book_id = 12346; 
   // 通過傳 Book1 的地址來輸出 Book1 信息
   printBook( &Book1 ); 
   // 通過傳 Book2 的地址來輸出 Book2 信息
   printBook( &Book2 ); 
   return 0;}// 該函數以結構指針作為參數void printBook( struct Books *book ){
   cout << "書標題  : " << book->title <<endl;   cout << "書作者 : " 
   << book->author <<endl;   cout << "書類目 : " << book->subject <<endl;   
   cout << "書 ID : " << book->book_id <<endl;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
書標題  : C++ 教程書作者 : Runoob書類目 : 編程語言書 ID : 12345書標題  : CSS 教程書作者 : Runoob書類目 : 前端技術書 ID : 12346
```

## typedef 關鍵字

下面是一種更簡單的定義結構的方式，您可以為創建的類型取一個"別名"。例如：

```cpp
typedef struct{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;}Books;
```

現在，您可以直接使用 *Books* 來定義 *Books* 類型的變量，而不需要使用 struct 關鍵字。下面是實例：

```cpp
Books Book1, Book2;
```

您可以使用 **typedef** 關鍵字來定義非結構類型，如下所示：

```cpp
typedef long int *pint32;
 pint32 x, y, z;
```

x, y 和 z 都是指向長整型 long int 的指針。

# C++ 類 & 對象

C++ 在 C 語言的基礎上增加了面向對象編程，C++ 支持面向對象程序設計。類是 C++ 的核心特性，通常被稱為用戶定義的類型。

類用於指定對象的形式，它包含了數據表示法和用於處理數據的方法。類中的數據和方法稱為類的成員。函數在一個類被稱為類的成員。

## C++ 類定義

定義一個類，本質上是定義一個數據類型的藍圖。這實際上並沒有定義任何數據，但它定義了類的名稱意味著什麼，也就是說，它定義了類的對象包括了什麼，以及可以在這個對象上執行哪些操作。

類定義是以關鍵字 **class** 開頭，後跟類的名稱。類的主體是包含在一對花括號中。類定義後必須跟著一個分號或一個聲明列表。例如，我們使用關鍵字 **class** 定義 Box 數據類型，如下所示：

```cpp
class Box{   public:      double length;   // Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box};
```

關鍵字 **public** 確定了類成員的訪問屬性。在類對象作用域內，公共成員在類的外部是可訪問的。您也可以指定類的成員為 **private** 或 **protected**，這個我們稍後會進行講解。

## 定義 C++ 對象

類提供了對象的藍圖，所以基本上，對象是根據類來創建的。聲明類的對象，就像聲明基本類型的變量一樣。下面的語句聲明瞭類 Box 的兩個對象：

```cpp
Box Box1;          // 聲明 Box1，類型為 BoxBox Box2;          // 聲明 Box2，類型為 Box
```

對象 Box1 和 Box2 都有它們各自的數據成員。

## 訪問數據成員

類的對象的公共數據成員可以使用直接成員訪問運算符 (.) 來訪問。為了更好地理解這些概念，讓我們嘗試一下下面的實例：

```cpp
#include <iostream>using namespace std;class Box{
   public:
      double length;   // 長度
      double breadth;  // 寬度
      double height;   // 高度};int main( ){
   Box Box1;        // 聲明 Box1，類型為 Box
   Box Box2;        // 聲明 Box2，類型為 Box
   double volume = 0.0;     // 用於存儲體積
 
   // box 1 詳述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;

   // box 2 詳述
   Box2.height = 10.0;
   Box2.length = 12.0;
   Box2.breadth = 13.0;

   // box 1 的體積
   volume = Box1.height * Box1.length * Box1.breadth;
   cout << "Box1 的體積：" << volume <<endl;

   // box 2 的體積
   volume = Box2.height * Box2.length * Box2.breadth;
   cout << "Box2 的體積：" << volume <<endl;
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Box1 的體積：210Box2 的體積：1560
```

需要注意的是，私有的成員和受保護的成員不能使用直接成員訪問運算符 (.) 來直接訪問。我們將在後續的教程中學習如何訪問私有成員和受保護的成員。

# 類 & 對象詳解

到目前為止，我們已經對 C++ 的類和對象有了基本的瞭解。下面的列表中還列出了其他一些 C++ 類和對象相關的概念，可以點擊相應的鏈接進行學習。

| 概念                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| 類成員函數          | 類的成員函數是指那些把定義和原型寫在類定義內部的函數，就像類定義中的其他變量一樣。 |
| 類訪問修飾符        | 類成員可以被定義為 public、private 或 protected。默認情況下是定義為 private。 |
| 構造函數 & 析構函數 | 類的構造函數是一種特殊的函數，在創建一個新的對象時調用。類的析構函數也是一種特殊的函數，在刪除所創建的對象時調用。 |
| C++ 拷貝構造函數    | 拷貝構造函數，是一種特殊的構造函數，它在創建對象時，是使用同一類中之前創建的對象來初始化新創建的對象。 |
| C++ 友元函數        | **友元函數**可以訪問類的 private 和 protected 成員。         |
| C++ 內聯函數        | 通過內聯函數，編譯器試圖在調用函數的地方擴展函數體中的代碼。 |
| C++ 中的 this 指針  | 每個對象都有一個特殊的指針 **this**，它指向對象本身。        |
| C++ 中指向類的指針  | 指向類的指針方式如同指向結構的指針。實際上，類可以看成是一個帶有函數的結構。 |
| C++ 類的靜態成員    | 類的數據成員和函數成員都可以被聲明為靜態的。                 |

# C++ 繼承

面向對象程序設計中最重要的一個概念是繼承。繼承允許我們依據另一個類來定義一個類，這使得創建和維護一個應用程序變得更容易。這樣做，也達到了重用代碼功能和提高執行時間的效果。

當創建一個類時，您不需要重新編寫新的數據成員和成員函數，只需指定新建的類繼承了一個已有的類的成員即可。這個已有的類稱為**基類**，新建的類稱為**派生類**。

繼承代表了 **is a** 關係。例如，哺乳動物是動物，狗是哺乳動物，因此，狗是動物，等等。

## 基類 & 派生類

一個類可以派生自多個類，這意味著，它可以從多個基類繼承數據和函數。定義一個派生類，我們使用一個類派生列表來指定基類。類派生列表以一個或多個基類命名，形式如下：

```cpp
class derived-class: access-specifier base-class
```

其中，訪問修飾符 access-specifier 是 **public、protected** 或 **private** 其中的一個，base-class 是之前定義過的某個類的名稱。如果未使用訪問修飾符 access-specifier，則默認為 private。

假設有一個基類 **Shape**，**Rectangle** 是它的派生類，如下所示：

```cpp
#include <iostream>
 using namespace std;// 基類class Shape {
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;};// 派生類class Rectangle: public Shape{
   public:
      int getArea()
      { 
         return (width * height); 
      }};int main(void){
   Rectangle Rect;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   // 輸出對象的面積
   cout << "Total area: " << Rect.getArea() << endl;

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```
 Total area: 35
```

## 訪問控制和繼承

派生類可以訪問基類中所有的非私有成員。因此基類成員如果不想被派生類的成員函數訪問，則應在基類中聲明為 private。

我們可以根據訪問權限總結出不同的訪問類型，如下所示：

| 訪問     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一個類 | yes    | yes       | yes     |
| 派生類   | yes    | yes       | no      |
| 外部的類 | yes    | no        | no      |

一個派生類繼承了所有的基類方法，但下列情況除外：

- 基類的構造函數、析構函數和拷貝構造函數。
- 基類的重載運算符。
- 基類的友元函數。

## 繼承類型

當一個類派生自基類，該基類可以被繼承為 **public、protected** 或 **private** 幾種類型。繼承類型是通過上面講解的訪問修飾符 access-specifier 來指定的。

我們幾乎不使用 **protected** 或 **private** 繼承，通常使用 **public** 繼承。當使用不同類型的繼承時，遵循以下幾個規則：

- **公有繼承（public）：**當一個類派生自**公有**基類時，基類的**公有**成員也是派生類的**公有**成員，基類的**保護**成員也是派生類的**保護**成員，基類的**私有**成員不能直接被派生類訪問，但是可以通過調用基類的**公有**和**保護**成員來訪問。
- **保護繼承（protected）：** 當一個類派生自**保護**基類時，基類的**公有**和**保護**成員將成為派生類的**保護**成員。
- **私有繼承（private）：**當一個類派生自**私有**基類時，基類的**公有**和**保護**成員將成為派生類的**私有**成員。

## 多繼承

多繼承即一個子類可以有多個父類，它繼承了多個父類的特性。

C++ 類可以從多個類繼承成員，語法如下：

```cpp
class <派生類名>:<繼承方式1><基類名1>,<繼承方式2><基類名2>,…{<派生類類體>};
```

其中，訪問修飾符繼承方式是 **public、protected** 或 **private** 其中的一個，用來修飾每個基類，各個基類之間用逗號分隔，如上所示。現在讓我們一起看看下面的實例：

```cpp
#include <iostream>
 using namespace std;// 基類 Shapeclass Shape {
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;};// 基類 PaintCostclass PaintCost {
   public:
      int getCost(int area)
      {
         return area * 70;
      }};// 派生類class Rectangle: public Shape, public PaintCost{
   public:
      int getArea()
      { 
         return (width * height); 
      }};int main(void){
   Rectangle Rect;
   int area;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   area = Rect.getArea();
   
   // 輸出對象的面積
   cout << "Total area: " << Rect.getArea() << endl;

   // 輸出總花費
   cout << "Total paint cost: $" << Rect.getCost(area) << endl;

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Total area: 35Total paint cost: $2450
```

# C++ 重載運算符和重載函數

C++ 允許在同一作用域中的某個**函數**和**運算符**指定多個定義，分別稱為**函數重載**和**運算符重載**。

重載聲明是指一個與之前已經在該作用域內聲明過的函數或方法具有相同名稱的聲明，但是它們的參數列表和定義（實現）不相同。

當您調用一個**重載函數**或**重載運算符**時，編譯器通過把您所使用的參數類型與定義中的參數類型進行比較，決定選用最合適的定義。選擇最合適的重載函數或重載運算符的過程，稱為**重載決策**。

## C++ 中的函數重載

在同一個作用域內，可以聲明幾個功能類似的同名函數，但是這些同名函數的形式參數（指參數的個數、類型或者順序）必須不同。您不能僅通過返回類型的不同來重載函數。

下面的實例中，同名函數 **print()** 被用於輸出不同的數據類型：

```cpp
#include <iostream>using namespace std;
 class printData 
{
   public:
      void print(int i) {
        cout << "Printing int: " << i << endl;
      }

      void print(double  f) {
        cout << "Printing float: " << f << endl;
      }

      void print(char* c) {
        cout << "Printing character: " << c << endl;
      }};int main(void){
   printData pd;
 
   // Call print to print integer
   pd.print(5);
   // Call print to print float
   pd.print(500.263);
   // Call print to print character
   pd.print("Hello C++");
 
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Printing int: 5Printing float: 500.263Printing character: Hello C++
```

## C++ 中的運算符重載

您可以重定義或重載大部分 C++ 內置的運算符。這樣，您就能使用自定義類型的運算符。

重載的運算符是帶有特殊名稱的函數，函數名是由關鍵字 operator 和其後要重載的運算符符號構成的。與其他函數一樣，重載運算符有一個返回類型和一個參數列表。

```cpp
Box operator+(const Box&);
```

聲明加法運算符用於把兩個 Box 對象相加，返回最終的 Box 對象。大多數的重載運算符可被定義為普通的非成員函數或者被定義為類成員函數。如果我們定義上面的函數為類的非成員函數，那麼我們需要為每次操作傳遞兩個參數，如下所示：

```cpp
Box operator+(const Box&, const Box&);
```

下面的實例使用成員函數演示了運算符重載的概念。在這裡，對象作為參數進行傳遞，對象的屬性使用 **this** 運算符進行訪問，如下所示：

```cpp
#include <iostream>using namespace std;class Box{
   public:

      double getVolume(void)
      {
         return length * breadth * height;
      }
      void setLength( double len )
      {
          length = len;
      }

      void setBreadth( double bre )
      {
          breadth = bre;
      }

      void setHeight( double hei )
      {
          height = hei;
      }
      // 重載 + 運算符，用於把兩個 Box 對象相加
      Box operator+(const Box& b)
      {
         Box box;
         box.length = this->length + b.length;
         box.breadth = this->breadth + b.breadth;
         box.height = this->height + b.height;
         return box;
      }
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度};// 程序的主函數int main( ){
   Box Box1;                // 聲明 Box1，類型為 Box
   Box Box2;                // 聲明 Box2，類型為 Box
   Box Box3;                // 聲明 Box3，類型為 Box
   double volume = 0.0;     // 把體積存儲在該變量中
 
   // Box1 詳述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 詳述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的體積
   volume = Box1.getVolume();
   cout << "Volume of Box1 : " << volume <<endl;
 
   // Box2 的體積
   volume = Box2.getVolume();
   cout << "Volume of Box2 : " << volume <<endl;

   // 把兩個對象相加，得到 Box3
   Box3 = Box1 + Box2;

   // Box3 的體積
   volume = Box3.getVolume();
   cout << "Volume of Box3 : " << volume <<endl;

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Volume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400
```

## 可重載運算符/不可重載運算符

下面是可重載的運算符列表：

| +    | -    | *    | /      | %      | ^         |
| ---- | ---- | ---- | ------ | ------ | --------- |
| &    | \|   | ~    | !      | ,      | =         |
| <    | >    | <=   | >=     | ++     | --        |
| <<   | >>   | ==   | !=     | &&     | \|\|      |
| +=   | -=   | /=   | %=     | ^=     | &=        |
| \|=  | *=   | <<=  | >>=    | []     | ()        |
| ->   | ->*  | new  | new [] | delete | delete [] |

下面是不可重載的運算符列表：

| ::   | .*   | .    | ?:   |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

## 運算符重載實例

下面提供了各種運算符重載的實例，幫助您更好地理解重載的概念。

| 序號 | 運算符和實例             |
| :--- | :----------------------- |
| 1    | 一元運算符重載           |
| 2    | 二元運算符重載           |
| 3    | 關係運算符重載           |
| 4    | 輸入/輸出運算符重載      |
| 5    | ++ 和 -- 運算符重載      |
| 6    | 賦值運算符重載           |
| 7    | 函數調用運算符 () 重載   |
| 8    | 下標運算符 [] 重載       |
| 9    | 類成員訪問運算符 -> 重載 |

# C++ 多態

**多態**按字面的意思就是多種形態。當類之間存在層次結構，並且類之間是通過繼承關聯時，就會用到多態。

C++ 多態意味著調用成員函數時，會根據調用函數的對象的類型來執行不同的函數。

下面的實例中，基類 Shape 被派生為兩個類，如下所示：

```cpp
#include <iostream> using namespace std;
 class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }};class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }};class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }};// 程序的主函數int main( ){
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // 存儲矩形的地址
   shape = &rec;
   // 調用矩形的求面積函數 area
   shape->area();

   // 存儲三角形的地址
   shape = &tri;
   // 調用三角形的求面積函數 area
   shape->area();
   
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Parent class areaParent class area
```

導致錯誤輸出的原因是，調用函數 area() 被編譯器設置為基類中的版本，這就是所謂的**靜態多態**，或**靜態鏈接** - 函數調用在程序執行前就準備好了。有時候這也被稱為**早綁定**，因為 area() 函數在程序編譯期間就已經設置好了。

但現在，讓我們對程序稍作修改，在 Shape 類中，area() 的聲明前放置關鍵字 **virtual**，如下所示：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }};
```

修改後，當編譯和執行前面的實例代碼時，它會產生以下結果：

```cpp
Rectangle class areaTriangle class area
```

此時，編譯器看的是指針的內容，而不是它的類型。因此，由於 tri 和 rec 類的對象的地址存儲在 *shape 中，所以會調用各自的 area() 函數。

正如您所看到的，每個子類都有一個函數 area() 的獨立實現。這就是**多態**的一般使用方式。有了多態，您可以有多個不同的類，都帶有同一個名稱但具有不同實現的函數，函數的參數甚至可以是相同的。

## 虛函數

**虛函數** 是在基類中使用關鍵字 **virtual** 聲明的函數。在派生類中重新定義基類中定義的虛函數時，會告訴編譯器不要靜態鏈接到該函數。

我們想要的是在程序中任意點可以根據所調用的對象類型來選擇調用的函數，這種操作被稱為**動態鏈接**，或**後期綁定**。

## 純虛函數

您可能想要在基類中定義虛函數，以便在派生類中重新定義該函數更好地適用於對象，但是您在基類中又不能對虛函數給出有意義的實現，這個時候就會用到純虛函數。

我們可以把基類中的虛函數 area() 改寫如下：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;};
```

= 0 告訴編譯器，函數沒有主體，上面的虛函數是**純虛函數**。

# C++ 數據抽象

數據抽象是指，只向外界提供關鍵信息，並隱藏其後臺的實現細節，即只表現必要的信息而不呈現細節。

數據抽象是一種依賴於接口和實現分離的編程（設計）技術。

讓我們舉一個現實生活中的真實例子，比如一臺電視機，您可以打開和關閉、切換頻道、調整音量、添加外部組件（如喇叭、錄像機、DVD 播放器），但是您不知道它的內部實現細節，也就是說，您並不知道它是如何通過纜線接收信號，如何轉換信號，並最終顯示在屏幕上。

因此，我們可以說電視把它的內部實現和外部接口分離開了，您無需知道它的內部實現原理，直接通過它的外部接口（比如電源按鈕、遙控器、聲量控制器）就可以操控電視。

現在，讓我們言歸正傳，就 C++ 編程而言，C++ 類為**數據抽象**提供了可能。它們向外界提供了大量用於操作對象數據的公共方法，也就是說，外界實際上並不清楚類的內部實現。

例如，您的程序可以調用 **sort()** 函數，而不需要知道函數中排序數據所用到的算法。實際上，函數排序的底層實現會因庫的版本不同而有所差異，只要接口不變，函數調用就可以照常工作。

在 C++ 中，我們使用**類**來定義我們自己的抽象數據類型（ADT）。您可以使用類 **ostream** 的 **cout** 對象來輸出數據到標準輸出，如下所示：

```cpp
#include <iostream>using namespace std;int main( ){   cout << "Hello C++" <<endl;   return 0;}
```

在這裡，您不需要理解 **cout** 是如何在用戶的屏幕上顯示文本。您只需要知道公共接口即可，cout 的底層實現可以自由改變。

## 訪問標籤強制抽象

在 C++ 中，我們使用訪問標籤來定義類的抽象接口。一個類可以包含零個或多個訪問標籤：

- 使用公共標籤定義的成員都可以訪問該程序的所有部分。一個類型的數據抽象視圖是由它的公共成員來定義的。
- 使用私有標籤定義的成員無法訪問到使用類的代碼。私有部分對使用類型的代碼隱藏了實現細節。

訪問標籤出現的頻率沒有限制。每個訪問標籤指定了緊隨其後的成員定義的訪問級別。指定的訪問級別會一直有效，直到遇到下一個訪問標籤或者遇到類主體的關閉右括號為止。

## 數據抽象的好處

數據抽象有兩個重要的優勢：

- 類的內部受到保護，不會因無意的用戶級錯誤導致對象狀態受損。
- 類實現可能隨著時間的推移而發生變化，以便應對不斷變化的需求，或者應對那些要求不改變用戶級代碼的錯誤報告。

如果只在類的私有部分定義數據成員，編寫該類的作者就可以隨意更改數據。如果實現發生改變，則只需要檢查類的代碼，看看這個改變會導致哪些影響。如果數據是公有的，則任何直接訪問舊錶示形式的數據成員的函數都可能受到影響。

## 數據抽象的實例

C++ 程序中，任何帶有公有和私有成員的類都可以作為數據抽象的實例。請看下面的實例：

```cpp
#include <iostream>using namespace std;class Adder{
   public:
      // 構造函數
      Adder(int i = 0)
      {
        total = i;
      }
      // 對外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 對外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 對外隱藏的數據
      int total;};int main( ){
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Total 60
```

上面的類把數字相加，並返回總和。公有成員 **addNum** 和 **getTotal** 是對外的接口，用戶需要知道它們以便使用類。私有成員 **total** 是用戶不需要了解的，但又是類能正常工作所必需的。

## 設計策略

抽象把代碼分離為接口和實現。所以在設計組件時，必須保持接口獨立於實現，這樣，如果改變底層實現，接口也將保持不變。

在這種情況下，不管任何程序使用接口，接口都不會受到影響，只需要將最新的實現重新編譯即可。

# C++ 數據封裝

所有的 C++ 程序都有以下兩個基本要素：

- **程序語句（代碼）：**這是程序中執行動作的部分，它們被稱為函數。
- **程序數據：**數據是程序的信息，會受到程序函數的影響。

封裝是面向對象編程中的把數據和操作數據的函數綁定在一起的一個概念，這樣能避免受到外界的干擾和誤用，從而確保了安全。數據封裝引申出了另一個重要的 OOP 概念，即**數據隱藏**。

**數據封裝**是一種把數據和操作數據的函數捆綁在一起的機制，**數據抽象**是一種僅向用戶暴露接口而把具體的實現細節隱藏起來的機制。

C++ 通過創建**類**來支持封裝和數據隱藏（public、protected、private）。我們已經知道，類包含私有成員（private）、保護成員（protected）和公有成員（public）成員。默認情況下，在類中定義的所有項目都是私有的。例如：

```cpp
class Box{
   public:
      double getVolume(void)
      {
         return length * breadth * height;
      }
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度
	};
```

變量 length、breadth 和 height 都是私有的（private）。這意味著它們只能被 Box 類中的其他成員訪問，而不能被程序中其他部分訪問。這是實現封裝的一種方式。

為了使類中的成員變成公有的（即，程序中的其他部分也能訪問），必須在這些成員前使用 **public** 關鍵字進行聲明。所有定義在 public 標識符後邊的變量或函數可以被程序中所有其他的函數訪問。

把一個類定義為另一個類的友元類，會暴露實現細節，從而降低了封裝性。理想的做法是儘可能地對外隱藏每個類的實現細節。

## 數據封裝的實例

C++ 程序中，任何帶有公有和私有成員的類都可以作為數據封裝和數據抽象的實例。請看下面的實例：

```cpp
#include <iostream>using namespace std;class Adder{
   public:
      // 構造函數
      Adder(int i = 0)
      {
        total = i;
      }
      // 對外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 對外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 對外隱藏的數據
      int total;};int main( ){
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Total 60
```

上面的類把數字相加，並返回總和。公有成員 **addNum** 和 **getTotal** 是對外的接口，用戶需要知道它們以便使用類。私有成員 **total** 是對外隱藏的，用戶不需要了解它，但它又是類能正常工作所必需的。

## 設計策略

通常情況下，我們都會設置類成員狀態為私有（private），除非我們真的需要將其暴露，這樣才能保證良好的**封裝性**。

這通常應用於數據成員，但它同樣適用於所有成員，包括虛函數。

# C++ 接口（抽象類）

接口描述了類的行為和功能，而不需要完成類的特定實現。

C++ 接口是使用**抽象類**來實現的，抽象類與數據抽象互不混淆，數據抽象是一個把實現細節與相關的數據分離開的概念。

如果類中至少有一個函數被聲明為純虛函數，則這個類就是抽象類。純虛函數是通過在聲明中使用 "= 0" 來指定的，如下所示：

```cpp
class Box{
   public:
      // 純虛函數
      virtual double getVolume() = 0;
   private:
      double length;      // 長度
      double breadth;     // 寬度
      double height;      // 高度};
```

設計**抽象類**（通常稱為 ABC）的目的，是為了給其他類提供一個可以繼承的適當的基類。抽象類不能被用於實例化對象，它只能作為**接口**使用。如果試圖實例化一個抽象類的對象，會導致編譯錯誤。

因此，如果一個 ABC 的子類需要被實例化，則必須實現每個虛函數，這也意味著 C++ 支持使用 ABC 聲明接口。如果沒有在派生類中重載純虛函數，就嘗試實例化該類的對象，會導致編譯錯誤。

可用於實例化對象的類被稱為**具體類**。

## 抽象類的實例

請看下面的實例，基類 Shape 提供了一個接口 **getArea()**，在兩個派生類 Rectangle 和 Triangle 中分別實現了 **getArea()**：

```cpp
#include <iostream>
 using namespace std;
 // 基類class Shape {public:
   // 提供接口框架的純虛函數
   virtual int getArea() = 0;
   void setWidth(int w)
   {
      width = w;
   }
   void setHeight(int h)
   {
      height = h;
   }protected:
   int width;
   int height;};
 // 派生類class Rectangle: public Shape{public:
   int getArea()
   { 
      return (width * height); 
   }};class Triangle: public Shape{public:
   int getArea()
   { 
      return (width * height)/2; 
   }};
 int main(void){
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   // 輸出對象的面積
   cout << "Total Rectangle area: " << Rect.getArea() << endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   // 輸出對象的面積
   cout << "Total Triangle area: " << Tri.getArea() << endl; 

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Total Rectangle area: 35Total Triangle area: 17
```

從上面的實例中，我們可以看到一個抽象類是如何定義一個接口 getArea()，兩個派生類是如何通過不同的計算面積的算法來實現這個相同的函數。

## 設計策略

面向對象的系統可能會使用一個抽象基類為所有的外部應用程序提供一個適當的、通用的、標準化的接口。然後，派生類通過繼承抽象基類，就把所有類似的操作都繼承下來。

外部應用程序提供的功能（即公有函數）在抽象基類中是以純虛函數的形式存在的。這些純虛函數在相應的派生類中被實現。

這個架構也使得新的應用程序可以很容易地被添加到系統中，即使是在系統被定義之後依然可以如此。

# C++ 文件和流

到目前為止，我們已經使用了 **iostream** 標準庫，它提供了 **cin** 和 **cout** 方法分別用於從標準輸入讀取流和向標準輸出寫入流。

本教程介紹如何從文件讀取流和向文件寫入流。這就需要用到 C++ 中另一個標準庫 **fstream**，它定義了三個新的數據類型：

| 數據類型 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| ofstream | 該數據類型表示輸出文件流，用於創建文件並向文件寫入信息。     |
| ifstream | 該數據類型表示輸入文件流，用於從文件讀取信息。               |
| fstream  | 該數據類型通常表示文件流，且同時具有 ofstream 和 ifstream 兩種功能，這意味著它可以創建文件，向文件寫入信息，從文件讀取信息。 |

要在 C++ 中進行文件處理，必須在 C++ 源代碼文件中包含頭文件 <iostream> 和 <fstream>。

## 打開文件

在從文件讀取信息或者向文件寫入信息之前，必須先打開文件。**ofstream** 和 **fstream** 對象都可以用來打開文件進行寫操作，如果只需要打開文件進行讀操作，則使用 **ifstream** 對象。

下面是 open() 函數的標準語法，open() 函數是 fstream、ifstream 和 ofstream 對象的一個成員。

```cpp
void open(const char *filename, ios::openmode mode);
```

在這裡，**open()** 成員函數的第一參數指定要打開的文件的名稱和位置，第二個參數定義文件被打開的模式。

| 模式標誌   | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| ios::app   | 追加模式。所有寫入都追加到文件末尾。                         |
| ios::ate   | 文件打開後定位到文件末尾。                                   |
| ios::in    | 打開文件用於讀取。                                           |
| ios::out   | 打開文件用於寫入。                                           |
| ios::trunc | 如果該文件已經存在，其內容將在打開文件之前被截斷，即把文件長度設為 0。 |

您可以把以上兩種或兩種以上的模式結合使用。例如，如果您想要以寫入模式打開文件，並希望截斷文件，以防文件已存在，那麼您可以使用下面的語法：

```cpp
ofstream outfile;outfile.open("file.dat", ios::out | ios::trunc );
```

類似地，您如果想要打開一個文件用於讀寫，可以使用下面的語法：

```cpp
fstream  afile;afile.open("file.dat", ios::out | ios::in );
```

## 關閉文件

當 C++ 程序終止時，它會自動關閉刷新所有流，釋放所有分配的內存，並關閉所有打開的文件。但程序員應該養成一個好習慣，在程序終止前關閉所有打開的文件。

下面是 close() 函數的標準語法，close() 函數是 fstream、ifstream 和 ofstream 對象的一個成員。

```cpp
void close();
```

## 寫入文件

在 C++ 編程中，我們使用流插入運算符（ << ）向文件寫入信息，就像使用該運算符輸出信息到屏幕上一樣。唯一不同的是，在這裡您使用的是 **ofstream** 或 **fstream** 對象，而不是 **cout** 對象。

## 讀取文件

在 C++ 編程中，我們使用流提取運算符（ >> ）從文件讀取信息，就像使用該運算符從鍵盤輸入信息一樣。唯一不同的是，在這裡您使用的是 **ifstream** 或 **fstream** 對象，而不是 **cin** 對象。

## 讀取 & 寫入實例

下面的 C++ 程序以讀寫模式打開一個文件。在向文件 afile.dat 寫入用戶輸入的信息之後，程序從文件讀取信息，並將其輸出到屏幕上：

```cpp
#include <fstream>#include <iostream>using namespace std;
 int main (){
    
   char data[100];

   // 以寫模式打開文件
   ofstream outfile;
   outfile.open("afile.dat");

   cout << "Writing to the file" << endl;
   cout << "Enter your name: "; 
   cin.getline(data, 100);

   // 向文件寫入用戶輸入的數據
   outfile << data << endl;

   cout << "Enter your age: "; 
   cin >> data;
   cin.ignore();
   
   // 再次向文件寫入用戶輸入的數據
   outfile << data << endl;

   // 關閉打開的文件
   outfile.close();

   // 以讀模式打開文件
   ifstream infile; 
   infile.open("afile.dat"); 
 
   cout << "Reading from the file" << endl; 
   infile >> data; 

   // 在屏幕上寫入數據
   cout << data << endl;
   
   // 再次從文件讀取數據，並顯示它
   infile >> data; 
   cout << data << endl; 

   // 關閉打開的文件
   infile.close();

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列輸入和輸出：

```cpp
$./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9
```

上面的實例中使用了 cin 對象的附加函數，比如 getline()函數從外部讀取一行，ignore() 函數會忽略掉之前讀語句留下的多餘字符。

## 文件位置指針

**istream** 和 **ostream** 都提供了用於重新定位文件位置指針的成員函數。這些成員函數包括關於 istream 的 **seekg**（"seek get"）和關於 ostream 的 **seekp**（"seek put"）。

seekg 和 seekp 的參數通常是一個長整型。第二個參數可以用於指定查找方向。查找方向可以是 **ios::beg**（默認的，從流的開頭開始定位），也可以是 **ios::cur**（從流的當前位置開始定位），也可以是 **ios::end**（從流的末尾開始定位）。

文件位置指針是一個整數值，指定了從文件的起始位置到指針所在位置的字節數。下面是關於定位 "get" 文件位置指針的實例：

```cpp
// 定位到 fileObject 的第 n 個字節（假設是 ios::beg）fileObject.seekg( n );// 把文件的讀指針從 fileObject 當前位置向後移 n 個字節fileObject.seekg( n, ios::cur );// 把文件的讀指針從 fileObject 末尾往回移 n 個字節fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );
```

# C++ 異常處理

異常是程序在執行期間產生的問題。C++ 異常是指在程序運行時發生的特殊情況，比如嘗試除以零的操作。

異常提供了一種轉移程序控制權的方式。C++ 異常處理涉及到三個關鍵字：**try、catch、throw**。

- **throw:** 當問題出現時，程序會拋出一個異常。這是通過使用 **throw** 關鍵字來完成的。
- **catch:** 在您想要處理問題的地方，通過異常處理程序捕獲異常。**catch** 關鍵字用於捕獲異常。
- **try:** **try** 塊中的代碼標識將被激活的特定異常。它後面通常跟著一個或多個 catch 塊。

如果有一個塊拋出一個異常，捕獲異常的方法會使用 **try** 和 **catch** 關鍵字。try 塊中放置可能拋出異常的代碼，try 塊中的代碼被稱為保護代碼。使用 try/catch 語句的語法如下所示：

```cpp
try{
   // 保護代碼}catch( ExceptionName e1 ){
   // catch 塊}catch( ExceptionName e2 ){
   // catch 塊}catch( ExceptionName eN ){
   // catch 塊}
```

如果 **try** 塊在不同的情境下會拋出不同的異常，這個時候可以嘗試羅列多個 **catch** 語句，用於捕獲不同類型的異常。

## 拋出異常

您可以使用 **throw** 語句在代碼塊中的任何地方拋出異常。throw 語句的操作數可以是任意的表達式，表達式的結果的類型決定了拋出的異常的類型。

以下是嘗試除以零時拋出異常的實例：

```cpp
double division(int a, int b){
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);}
```

## 捕獲異常

**catch** 塊跟在 **try** 塊後面，用於捕獲異常。您可以指定想要捕捉的異常類型，這是由 catch 關鍵字後的括號內的異常聲明決定的。

```cpp
try{
   // 保護代碼}catch( ExceptionName e ){
  // 處理 ExceptionName 異常的代碼}
```

上面的代碼會捕獲一個類型為 **ExceptionName** 的異常。如果您想讓 catch 塊能夠處理 try 塊拋出的任何類型的異常，則必須在異常聲明的括號內使用省略號 ...，如下所示：

```cpp
try{
   // 保護代碼}catch(...){
  // 能處理任何異常的代碼}
```

下面是一個實例，拋出一個除以零的異常，並在 catch 塊中捕獲該異常。

```cpp
#include <iostream>using namespace std;double division(int a, int b){
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);}int main (){
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }

   return 0;}
```

由於我們拋出了一個類型為 **const char\*** 的異常，因此，當捕獲該異常時，我們必須在 catch 塊中使用 const char*。當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Division by zero condition!
```

## C++ 標準的異常

C++ 提供了一系列標準的異常，定義在 **<exception>** 中，我們可以在程序中使用這些標準的異常。它們是以父子類層次結構組織起來的，如下所示：

![img](https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg)

下表是對上面層次結構中出現的每個異常的說明：

| 異常                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **std::exception**     | 該異常是所有標準 C++ 異常的父類。                            |
| std::bad_alloc         | 該異常可以通過 **new** 拋出。                                |
| std::bad_cast          | 該異常可以通過 **dynamic_cast** 拋出。                       |
| std::bad_exception     | 這在處理 C++ 程序中無法預期的異常時非常有用。                |
| std::bad_typeid        | 該異常可以通過 **typeid** 拋出。                             |
| **std::logic_error**   | 理論上可以通過讀取代碼來檢測到的異常。                       |
| std::domain_error      | 當使用了一個無效的數學域時，會拋出該異常。                   |
| std::invalid_argument  | 當使用了無效的參數時，會拋出該異常。                         |
| std::length_error      | 當創建了太長的 std::string 時，會拋出該異常。                |
| std::out_of_range      | 該異常可以通過方法拋出，例如 std::vector 和 std::bitset<>::operator[]()。 |
| **std::runtime_error** | 理論上不可以通過讀取代碼來檢測到的異常。                     |
| std::overflow_error    | 當發生數學上溢時，會拋出該異常。                             |
| std::range_error       | 當嘗試存儲超出範圍的值時，會拋出該異常。                     |
| std::underflow_error   | 當發生數學下溢時，會拋出該異常。                             |

## 定義新的異常

您可以通過繼承和重載 **exception** 類來定義新的異常。下面的實例演示瞭如何使用 std::exception 類來實現自己的異常：

```cpp
#include <iostream>#include <exception>using namespace std;struct MyException : public exception{
  const char * what () const throw ()
  {
    return "C++ Exception";
  }};
 int main(){
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的錯誤
  }}
```

這將產生以下結果：

```cpp
MyException caught
C++ Exception
```

在這裡，**what()** 是異常類提供的一個公共方法，它已被所有子異常類重載。這將返回異常產生的原因。

# C++ 動態內存

瞭解動態內存在 C++ 中是如何工作的是成為一名合格的 C++ 程序員必不可少的。C++ 程序中的內存分為兩個部分：

- **棧：**在函數內部聲明的所有變量都將佔用棧內存。
- **堆：**這是程序中未使用的內存，在程序運行時可用於動態分配內存。

很多時候，您無法提前預知需要多少內存來存儲某個定義變量中的特定信息，所需內存的大小需要在運行時才能確定。

在 C++ 中，您可以使用特殊的運算符為給定類型的變量在運行時分配堆內的內存，這會返回所分配的空間地址。這種運算符即 **new** 運算符。

如果您不需要動態分配內存，可以使用 **delete** 運算符，刪除之前由 new 運算符分配的內存。

## new 和 delete 運算符

下面是使用 new 運算符來為任意的數據類型動態分配內存的通用語法：

```cpp
new data-type;
```

在這裡，**data-type** 可以是包括數組在內的任意內置的數據類型，也可以是包括類或結構在內的用戶自定義的任何數據類型。讓我們先來看下內置的數據類型。例如，我們可以定義一個指向 double 類型的指針，然後請求內存，該內存在執行時被分配。我們可以按照下面的語句使用 **new** 運算符來完成這點：

```cpp
double* pvalue  = NULL; // 初始化為 null 的指針pvalue  = new double;   // 為變量請求內存
```

如果自由存儲區已被用完，可能無法成功分配內存。所以建議檢查 new 運算符是否返回 NULL 指針，並採取以下適當的操作：

```cpp
double* pvalue  = NULL;if( !(pvalue  = new double )){
   cout << "Error: out of memory." <<endl;
   exit(1);}
```

**malloc()** 函數在 C 語言中就出現了，在 C++ 中仍然存在，但建議儘量不要使用 malloc() 函數。new 與 malloc() 函數相比，其主要的優點是，new 不只是分配了內存，它還創建了對象。

在任何時候，當您覺得某個已經動態分配內存的變量不再需要使用時，您可以使用 delete 操作符釋放它所佔用的內存，如下所示：

```cpp
delete pvalue;        // 釋放 pvalue 所指向的內存
```

下面的實例中使用了上面的概念，演示瞭如何使用 new 和 delete 運算符：

```cpp
#include <iostream>using namespace std;int main (){
   double* pvalue  = NULL; // 初始化為 null 的指針
   pvalue  = new double;   // 為變量請求內存
 
   *pvalue = 29494.99;     // 在分配的地址存儲值
   cout << "Value of pvalue : " << *pvalue << endl;

   delete pvalue;         // 釋放內存

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Value of pvalue : 29495
```

## 數組的動態內存分配

假設我們要為一個字符數組（一個有 20 個字符的字符串）分配內存，我們可以使用上面實例中的語法來為數組動態地分配內存，如下所示：

```cpp
char* pvalue  = NULL;   // 初始化為 null 的指針pvalue  = new char[20]; // 為變量請求內存
```

要刪除我們剛才創建的數組，語句如下：

```cpp
delete [] pvalue;        // 刪除 pvalue 所指向的數組
```

下面是 new 操作符的通用語法，可以為多維數組分配內存，如下所示：

```cpp
int ROW = 2;int COL = 3;double **pvalue  = new double* [ROW]; // 為行分配內存// 為列分配內存for(int i = 0; i < COL; i++) {
    pvalue[i] = new double[COL];}
```

釋放多維數組內存：

```cpp
for(int i = 0; i < COL; i++) {
    delete[] pvalue[i];}delete [] pvalue;
```

## 對象的動態內存分配

對象與簡單的數據類型沒有什麼不同。例如，請看下面的代碼，我們將使用一個對象數組來理清這一概念：

```cpp
#include <iostream>using namespace std;class Box{
   public:
      Box() { 
         cout << "調用構造函數！" <<endl; 
      }
      ~Box() { 
         cout << "調用析構函數！" <<endl; 
      }};int main( ){
   Box* myBoxArray = new Box[4];

   delete [] myBoxArray; // Delete array

   return 0;}
```

如果要為一個包含四個 Box 對象的數組分配內存，構造函數將被調用 4 次，同樣地，當刪除這些對象時，析構函數也將被調用相同的次數（4次）。

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
調用構造函數！調用構造函數！調用構造函數！調用構造函數！調用析構函數！調用析構函數！調用析構函數！調用析構函數！
```

# C++ 命名空間

假設這樣一種情況，當一個班上有兩個名叫 Zara 的學生時，為了明確區分它們，我們在使用名字之外，不得不使用一些額外的信息，比如他們的家庭住址，或者他們父母的名字等等。

同樣的情況也出現在 C++ 應用程序中。例如，您可能會寫一個名為 xyz() 的函數，在另一個可用的庫中也存在一個相同的函數 xyz()。這樣，編譯器就無法判斷您所使用的是哪一個 xyz() 函數。

因此，引入了**命名空間**這個概念，專門用於解決上面的問題，它可作為附加信息來區分不同庫中相同名稱的函數、類、變量等。使用了命名空間即定義了上下文。本質上，命名空間就是定義了一個範圍。

## 定義命名空間

命名空間的定義使用關鍵字 **namespace**，後跟命名空間的名稱，如下所示：

```cpp
namespace namespace_name {   // 代碼聲明}
```

為了調用帶有命名空間的函數或變量，需要在前面加上命名空間的名稱，如下所示：

```cpp
name::code;  // code 可以是變量或函數
```

讓我們來看看命名空間如何為變量或函數等實體定義範圍：

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }}// 第二個命名空間namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }}int main (){
 
   // 調用第一個命名空間中的函數
   first_space::func();
   
   // 調用第二個命名空間中的函數
   second_space::func(); 

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Inside first_spaceInside second_space
```

## using 指令

您可以使用 **using namespace** 指令，這樣在使用命名空間時就可以不用在前面加上命名空間的名稱。這個指令會告訴編譯器，後續的代碼將使用指定的命名空間中的名稱。

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }}// 第二個命名空間namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }}using namespace first_space;int main (){
 
   // 調用第一個命名空間中的函數
   func();
   
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Inside first_space
```

using 指令也可以用來指定命名空間中的特定項目。例如，如果您只打算使用 std 命名空間中的 cout 部分，您可以使用如下的語句：

```cpp
using std::cout;
```

隨後的代碼中，在使用 cout 時就可以不用加上命名空間名稱作為前綴，但是 **std** 命名空間中的其他項目仍然需要加上命名空間名稱作為前綴，如下所示：

```cpp
#include <iostream>using std::cout;int main (){   
	cout << "std::endl is used with std!" << std::endl;      
	return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
std::endl is used with std!
```

**using** 指令引入的名稱遵循正常的範圍規則。名稱從使用 **using** 指令開始是可見的，直到該範圍結束。此時，在範圍以外定義的同名實體是隱藏的。

## 不連續的命名空間

命名空間可以定義在幾個不同的部分中，因此命名空間是由幾個單獨定義的部分組成的。一個命名空間的各個組成部分可以分散在多個文件中。

所以，如果命名空間中的某個組成部分需要請求定義在另一個文件中的名稱，則仍然需要聲明該名稱。下面的命名空間定義可以是定義一個新的命名空間，也可以是為已有的命名空間增加新的元素：

```cpp
namespace namespace_name {
   // 代碼聲明}
```

## 嵌套的命名空間

命名空間可以嵌套，您可以在一個命名空間中定義另一個命名空間，如下所示：

```cpp
namespace namespace_name1 {
   // 代碼聲明
   namespace namespace_name2 {
      // 代碼聲明
   }}
```

您可以通過使用 :: 運算符來訪問嵌套的命名空間中的成員：

```cpp
// 訪問 namespace_name2 中的成員using namespace namespace_name1::namespace_name2;// 訪問 namespace:name1 中的成員using namespace namespace_name1;
```

在上面的語句中，如果使用的是 namespace_name1，那麼在該範圍內 namespace_name2 中的元素也是可用的，如下所示：

```cpp
#include <iostream>using namespace std;// 第一個命名空間namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
   // 第二個命名空間
   namespace second_space{
      void func(){
         cout << "Inside second_space" << endl;
      }
   }}using namespace first_space::second_space;int main (){
 
   // 調用第二個命名空間中的函數
   func();
   
   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Inside second_space
```

# C++ 模板

模板是泛型編程的基礎，泛型編程即以一種獨立於任何特定類型的方式編寫代碼。

模板是創建泛型類或函數的藍圖或公式。庫容器，比如迭代器和算法，都是泛型編程的例子，它們都使用了模板的概念。

每個容器都有一個單一的定義，比如 **向量**，我們可以定義許多不同類型的向量，比如 **vector <int>** 或 **vector <string>**。

您可以使用模板來定義函數和類，接下來讓我們一起來看看如何使用。

## 函數模板

模板函數定義的一般形式如下所示：

```cpp
template <class type> ret-type func-name(parameter list){   // 函數的主體}
```

在這裡，type 是函數所使用的數據類型的佔位符名稱。這個名稱可以在函數定義中使用。

下面是函數模板的實例，返回兩個數種的最大值：

```cpp
#include <iostream>#include <string>using namespace std;template <typename T>inline T const& Max (T const& a, T const& b) { 
    return a < b ? b:a; } int main (){
 
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 

    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 

    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Max(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World
```

## 類模板

正如我們定義函數模板一樣，我們也可以定義類模板。泛型類聲明的一般形式如下所示：

```cpp
template <class type> class class-name {...}
```

在這裡，**type** 是佔位符類型名稱，可以在類被實例化的時候進行指定。您可以使用一個逗號分隔的列表來定義多個泛型數據類型。

下面的實例定義了類 Stack<>，並實現了泛型方法來對元素進行入棧出棧操作：

```cpp
#include <iostream>#include <vector>#include <cstdlib>#include <string>#include <stdexcept>using namespace std;template <class T>class Stack { 
  private: 
    vector<T> elems;     // 元素 

  public: 
    void push(T const&);  // 入棧
    void pop();               // 出棧
    T top() const;            // 返回棧頂元素
    bool empty() const{       // 如果為空則返回真。
        return elems.empty(); 
    } }; template <class T>void Stack<T>::push (T const& elem) { 
    // 追加傳入元素的副本
    elems.push_back(elem);    } template <class T>void Stack<T>::pop () { 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
	// 刪除最後一個元素
    elems.pop_back();         } template <class T>T Stack<T>::top () const { 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
	// 返回最後一個元素的副本 
    return elems.back();      } int main() { 
    try { 
        Stack<int>         intStack;  // int 類型的棧 
        Stack<string> stringStack;    // string 類型的棧 

        // 操作 int 類型的棧 
        intStack.push(7); 
        cout << intStack.top() <<endl; 

        // 操作 string 類型的棧 
        stringStack.push("hello"); 
        cout << stringStack.top() << std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    } 
    catch (exception const& ex) { 
        cerr << "Exception: " << ex.what() <<endl; 
        return -1;
    } }
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
7helloException: Stack<>::pop(): empty stack
```

# C++ 預處理器

預處理器是一些指令，指示編譯器在實際編譯之前所需完成的預處理。

所有的預處理器指令都是以井號（#）開頭，只有空格字符可以出現在預處理指令之前。預處理指令不是 C++ 語句，所以它們不會以分號（;）結尾。

我們已經看到，之前所有的實例中都有 **#include** 指令。這個宏用於把頭文件包含到源文件中。

C++ 還支持很多預處理指令，比如 #include、#define、#if、#else、#line 等，讓我們一起看看這些重要指令。

## #define 預處理

\#define 預處理指令用於創建符號常量。該符號常量通常稱為**宏**，指令的一般形式是：

```cpp
#define macro-name replacement-text
```

當這一行代碼出現在一個文件中時，在該文件中後續出現的所有宏都將會在程序編譯之前被替換為 replacement-text。例如：

```cpp
#include <iostream>using namespace std;#define PI 3.14159int main (){     cout << "Value of PI :" << PI << endl;     return 0;}
```

現在，讓我們測試這段代碼，看看預處理的結果。假設源代碼文件已經存在，接下來使用 -E 選項進行編譯，並把結果重定向到 test.p。現在，如果您查看 test.p 文件，將會看到它已經包含大量的信息，而且在文件底部的值被改為如下：

```cpp
$gcc -E test.cpp > test.p...int main (){     cout << "Value of PI :" << 3.14159 << endl;     return 0;}
```

## 函數宏

您可以使用 #define 來定義一個帶有參數的宏，如下所示：

```cpp
#include <iostream>using namespace std;#define MIN(a,b) (a<b ? a : b)int main (){
   int i, j;
   i = 100;
   j = 30;
   cout <<"較小的值為：" << MIN(i, j) << endl;

    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
較小的值為：30
```

## 條件編譯

有幾個指令可以用來有選擇地對部分程序源代碼進行編譯。這個過程被稱為條件編譯。

條件預處理器的結構與 if 選擇結構很像。請看下面這段預處理器的代碼：

```cpp
#ifndef NULL   #define NULL 0#endif
```

您可以只在調試時進行編譯，調試開關可以使用一個宏來實現，如下所示：

```cpp
#ifdef DEBUG   cerr <<"Variable x = " << x << endl;#endif
```

如果在指令 #ifdef DEBUG 之前已經定義了符號常量 DEBUG，則會對程序中的 **cerr** 語句進行編譯。您可以使用 #if 0 語句註釋掉程序的一部分，如下所示：

```cpp
#if 0   不進行編譯的代碼#endif
```

讓我們嘗試下面的實例：

```cpp
#include <iostream>using namespace std;#define DEBUG#define MIN(a,b) (((a)<(b)) ? a : b)int main (){
   int i, j;
   i = 100;
   j = 30;#ifdef DEBUG
   cerr <<"Trace: Inside main function" << endl;#endif#if 0
   /* 這是註釋部分 */
   cout << MKSTR(HELLO C++) << endl;#endif

   cout <<"The minimum is " << MIN(i, j) << endl;#ifdef DEBUG
   cerr <<"Trace: Coming out of main function" << endl;#endif
    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Trace: Inside main functionThe minimum is 30Trace: Coming out of main function
```

## # 和 ## 運算符

\# 和 ## 預處理運算符在 C++ 和 ANSI/ISO C 中都是可用的。# 運算符會把 replacement-text 令牌轉換為用引號引起來的字符串。

請看下面的宏定義：

```cpp
#include <iostream>using namespace std;#define MKSTR( x ) #xint main (){    cout << MKSTR(HELLO C++) << endl;    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
HELLO C++
```

讓我們來看看它是如何工作的。不難理解，C++ 預處理器把下面這行：

```cpp
cout << MKSTR(HELLO C++) << endl;
```

轉換成了：

```cpp
cout << "HELLO C++" << endl;
```

\## 運算符用於連接兩個令牌。下面是一個實例：

```cpp
#define CONCAT( x, y )  x ## y
```

當 CONCAT 出現在程序中時，它的參數會被連接起來，並用來取代宏。例如，程序中 CONCAT(HELLO, C++) 會被替換為 "HELLO C++"，如下面實例所示。

```cpp
#include <iostream>using namespace std;#define concat(a, b) a ## bint main(){   int xy = 100;      cout << concat(x, y);   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
100
```

讓我們來看看它是如何工作的。不難理解，C++ 預處理器把下面這行：

```cpp
cout << concat(x, y);
```

轉換成了：

```cpp
cout << xy;
```

## C++ 中的預定義宏

C++ 提供了下表所示的一些預定義宏：

| 宏       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| __LINE__ | 這會在程序編譯時包含當前行號。                               |
| __FILE__ | 這會在程序編譯時包含當前文件名。                             |
| __DATE__ | 這會包含一個形式為 month/day/year 的字符串，它表示把源文件轉換為目標代碼的日期。 |
| __TIME__ | 這會包含一個形式為 hour:minute:second 的字符串，它表示程序被編譯的時間。 |

讓我們看看上述這些宏的實例：

```cpp
#include <iostream>using namespace std;int main (){
    cout << "Value of __LINE__ : " << __LINE__ << endl;
    cout << "Value of __FILE__ : " << __FILE__ << endl;
    cout << "Value of __DATE__ : " << __DATE__ << endl;
    cout << "Value of __TIME__ : " << __TIME__ << endl;

    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Value of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48
```

# C++ 信號處理

信號是由操作系統傳給進程的中斷，會提早終止一個程序。在 UNIX、LINUX、Mac OS X 或 Windows 系統上，可以通過按 Ctrl+C 產生中斷。

有些信號不能被程序捕獲，但是下表所列信號可以在程序中捕獲，並可以基於信號採取適當的動作。這些信號是定義在 C++ 頭文件 <csignal> 中。

| 信號    | 描述                                         |
| :------ | :------------------------------------------- |
| SIGABRT | 程序的異常終止，如調用 **abort**。           |
| SIGFPE  | 錯誤的算術運算，比如除以零或導致溢出的操作。 |
| SIGILL  | 檢測非法指令。                               |
| SIGINT  | 接收到交互注意信號。                         |
| SIGSEGV | 非法訪問內存。                               |
| SIGTERM | 發送到程序的終止請求。                       |

## signal() 函數

C++ 信號處理庫提供了 **signal** 函數，用來捕獲突發事件。以下是 signal() 函數的語法：

```cpp
void (*signal (int sig, void (*func)(int)))(int);
```

這個函數接收兩個參數：第一個參數是一個整數，代表了信號的編號；第二個參數是一個指向信號處理函數的指針。

讓我們編寫一個簡單的 C++ 程序，使用 signal() 函數捕獲 SIGINT 信號。不管您想在程序中捕獲什麼信號，您都必須使用 **signal** 函數來註冊信號，並將其與信號處理程序相關聯。看看下面的實例：

```cpp
#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){
    cout << "Interrupt signal (" << signum << ") received.\n";

    // 清理並關閉
    // 終止程序  

   exit(signum);  }int main (){
    // 註冊信號 SIGINT 和信號處理程序
    signal(SIGINT, signalHandler);  

    while(1){
       cout << "Going to sleep...." << endl;
       sleep(1);
    }

    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
Going to sleep....Going to sleep....Going to sleep....
```

現在，按 Ctrl+C 來中斷程序，您會看到程序捕獲信號，程序打印如下內容並退出：

```cpp
Going to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.
```

## raise() 函數

您可以使用函數 **raise()** 生成信號，該函數帶有一個整數信號編號作為參數，語法如下：

```cpp
int raise (signal sig);
```

在這裡，**sig** 是要發送的信號的編號，這些信號包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我們使用 raise() 函數內部生成信號的實例：

```cpp
#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){
    cout << "Interrupt signal (" << signum << ") received.\n";

    // 清理並關閉
    // 終止程序 

   exit(signum);  }int main (){
    int i = 0;
    // 註冊信號 SIGINT 和信號處理程序
    signal(SIGINT, signalHandler);  

    while(++i){
       cout << "Going to sleep...." << endl;
       if( i == 3 ){
          raise( SIGINT);
       }
       sleep(1);
    }

    return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果，並會自動退出：

```cpp
Going to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.
```

# C++ 多線程

多線程是多任務處理的一種特殊形式，多任務處理允許讓電腦同時運行兩個或兩個以上的程序。一般情況下，兩種類型的多任務處理：**基於進程和基於線程**。

- 基於進程的多任務處理是程序的併發執行。
- 基於線程的多任務處理是同一程序的片段的併發執行。

多線程程序包含可以同時運行的兩個或多個部分。這樣的程序中的每個部分稱為一個線程，每個線程定義了一個單獨的執行路徑。

本教程假設您使用的是 Linux 操作系統，我們要使用 POSIX 編寫多線程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多種類 Unix POSIX 系統上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

## 創建線程

下面的程序，我們可以用它來創建一個 POSIX 線程：

```cpp
#include <pthread.h>pthread_create (thread, attr, start_routine, arg)
```

在這裡，**pthread_create** 創建一個新的線程，並讓它可執行。下面是關於參數的說明：

| 參數          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向線程標識符指針。                                         |
| attr          | 一個不透明的屬性對象，可以被用來設置線程屬性。您可以指定線程屬性對象，也可以使用默認值 NULL。 |
| start_routine | 線程運行函數起始地址，一旦線程被創建就會執行。               |
| arg           | 運行函數的參數。它必須通過把引用作為指針強制轉換為 void 類型進行傳遞。如果沒有傳遞參數，則使用 NULL。 |

創建線程成功時，函數返回 0，若返回值不為 0 則說明創建線程失敗。

## 終止線程

使用下面的程序，我們可以用它來終止一個 POSIX 線程：

```cpp
#include <pthread.h>pthread_exit (status)
```

在這裡，**pthread_exit** 用於顯式地退出一個線程。通常情況下，pthread_exit() 函數是在線程完成工作後無需繼續存在時被調用。

如果 main() 是在它所創建的線程之前結束，並通過 pthread_exit() 退出，那麼其他線程將繼續執行。否則，它們將在 main() 結束時自動被終止。

## 實例

以下簡單的實例代碼使用 pthread_create() 函數創建了 5 個線程，每個線程輸出"Hello Runoob！":

```cpp
#include <iostream>// 必須的頭文件是#include <pthread.h>using namespace std;#define NUM_THREADS 5// 線程的運行函數void* say_hello(void* args){
    cout << "Hello Runoob！" << endl;}int main(){
    // 定義線程的 id 變量，多個變量使用數組
    pthread_t tids[NUM_THREADS];
    for(int i = 0; i < NUM_THREADS; ++i)
    {
        //參數依次是：創建的線程id，線程參數，調用的函數，傳入的函數參數
        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);
        if (ret != 0)
        {
           cout << "pthread_create error: error_code=" << ret << endl;
        }
    }
    //等各個線程退出後，進程才結束，否則進程強制結束了，線程可能還沒反應過來；
    pthread_exit(NULL);}
```

使用 -lpthread 庫編譯下面的程序：

```cpp
$ g++ test.cpp -lpthread -o test.o
```

現在，執行程序，將產生下列結果：

```cpp
$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！
```

以下簡單的實例代碼使用 pthread_create() 函數創建了 5 個線程，並接收傳入的參數。每個線程打印一個 "Hello Runoob!" 消息，並輸出接收的參數，然後調用 pthread_exit() 終止線程。

```cpp
//文件名：test.cpp#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid){  
   // 對傳入的參數進行強制類型轉換，由無類型指針變為整形數指針，然後再讀取
   int tid = *((int*)threadid);
   cout << "Hello Runoob! 線程 ID, " << tid << endl;
   pthread_exit(NULL);}int main (){
   pthread_t threads[NUM_THREADS];
   int indexes[NUM_THREADS];// 用數組來保存i的值
   int rc;
   int i;
   for( i=0; i < NUM_THREADS; i++ ){      
      cout << "main() : 創建線程, " << i << endl;
      indexes[i] = i; //先保存i的值
      // 傳入的時候必須強制轉換為void* 類型，即無類型指針        
      rc = pthread_create(&threads[i], NULL, 
                          PrintHello, (void *)&(indexes[i]));
      if (rc){
         cout << "Error:無法創建線程," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);}
```

現在編譯並執行程序，將產生下列結果：

```cpp
$ g++ test.cpp -lpthread -o test.o$ ./test.omain() : 創建線程, 0main() : 創建線程, 1main() : 創建線程, 2main() : 創建線程, 3main() : 創建線程, 4Hello Runoob! 線程 ID, 4Hello Runoob! 線程 ID, 3Hello Runoob! 線程 ID, 2Hello Runoob! 線程 ID, 1Hello Runoob! 線程 ID, 0
```

## 向線程傳遞參數

這個實例演示瞭如何通過結構傳遞多個參數。您可以在線程回調中傳遞任意的數據類型，因為它指向 void，如下面的實例所示：

```cpp
#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5struct thread_data{   int  thread_id;   char *message;};void *PrintHello(void *threadarg){   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout << "Thread ID : " << my_data->thread_id ;   cout << " Message : " << my_data->message << endl;   pthread_exit(NULL);}int main (){   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i < NUM_THREADS; i++ ){      cout <<"main() : creating thread, " << i << endl;      td[i].thread_id = i;      td[i].message = "This is message";      rc = pthread_create(&threads[i], NULL,                          PrintHello, (void *)&td[i]);      if (rc){         cout << "Error:unable to create thread," << rc << endl;         exit(-1);      }   }   pthread_exit(NULL);}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
$ g++ test.cpp -lpthread -o test.o
$ ./test.o
main() : 創建線程, 0main() : 創建線程, 1main() : 創建線程, 2main() : 創建線程, 3main() : 創建線程, 4Hello Runoob! 線程 ID, 4Hello Runoob! 線程 ID, 3Hello Runoob! 線程 ID, 2Hello Runoob! 線程 ID, 1Hello Runoob! 線程 ID, 0
```

## 連接和分離線程

我們可以使用以下兩個函數來連接或分離線程：

```cpp
pthread_join (threadid, status) pthread_detach (threadid)
```

pthread_join() 子程序阻礙調用程序，直到指定的 threadid 線程終止為止。當創建一個線程時，它的某個屬性會定義它是否是可連接的（joinable）或可分離的（detached）。只有創建時定義為可連接的線程才可以被連接。如果線程創建時被定義為可分離的，則它永遠也不能被連接。

這個實例演示瞭如何使用 pthread_join() 函數來等待線程的完成。

```cpp
#include <iostream>#include <cstdlib>#include <pthread.h>#include <unistd.h>using namespace std;#define NUM_THREADS     5void *wait(void *t){
   int i;
   long tid;

   tid = (long)t;

   sleep(1);
   cout << "Sleeping in thread " << endl;
   cout << "Thread with id : " << tid << "  ...exiting " << endl;
   pthread_exit(NULL);}int main (){
   int rc;
   int i;
   pthread_t threads[NUM_THREADS];
   pthread_attr_t attr;
   void *status;

   // 初始化並設置線程為可連接的（joinable）
   pthread_attr_init(&attr);
   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

   for( i=0; i < NUM_THREADS; i++ ){
      cout << "main() : creating thread, " << i << endl;
      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }

   // 刪除屬性，並等待其他線程
   pthread_attr_destroy(&attr);
   for( i=0; i < NUM_THREADS; i++ ){
      rc = pthread_join(threads[i], &status);
      if (rc){
         cout << "Error:unable to join," << rc << endl;
         exit(-1);
      }
      cout << "Main: completed thread id :" << i ;
      cout << "  exiting with status :" << status << endl;
   }

   cout << "Main: program exiting." << endl;
   pthread_exit(NULL);}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
main() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread 
Thread with id : 4  ...exiting 
Sleeping in thread 
Thread with id : 3  ...exiting 
Sleeping in thread 
Thread with id : 2  ...exiting 
Sleeping in thread 
Thread with id : 1  ...exiting 
Sleeping in thread 
Thread with id : 0  ...exiting 
Main: completed thread id :0  exiting with status :0Main: completed thread id :1  exiting with status :0Main: completed thread id :2  exiting with status :0Main: completed thread id :3  exiting with status :0Main: completed thread id :4  exiting with status :0Main: program exiting.
```

# C++ Web 編程

## 什麼是 CGI？

- 公共網關接口（CGI），是一套標準，定義了信息是如何在 Web 服務器和客戶端腳本之間進行交換的。
- CGI 規範目前是由 NCSA 維護的，NCSA 定義 CGI 如下：
- 公共網關接口（CGI），是一種用於外部網關程序與信息服務器（如 HTTP 服務器）對接的接口標準。
- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推進中。

## Web 瀏覽

為了更好地瞭解 CGI 的概念，讓我們點擊一個超鏈接，瀏覽一個特定的網頁或 URL，看看會發生什麼。

- 您的瀏覽器聯繫上 HTTP Web 服務器，並請求 URL，即文件名。
- Web 服務器將解析 URL，並查找文件名。如果找到請求的文件，Web 服務器會把文件發送回瀏覽器，否則發送一條錯誤消息，表明您請求了一個錯誤的文件。
- Web 瀏覽器從 Web 服務器獲取響應，並根據接收到的響應來顯示文件或錯誤消息。

然而，以這種方式搭建起來的 HTTP 服務器，不管何時請求目錄中的某個文件，HTTP 服務器發送回來的不是該文件，而是以程序形式執行，並把執行產生的輸出發送回瀏覽器顯示出來。

公共網關接口（CGI），是使得應用程序（稱為 CGI 程序或 CGI 腳本）能夠與 Web 服務器以及客戶端進行交互的標準協議。這些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等進行編寫。

## CGI 架構圖

下圖演示了 CGI 的架構：

![img](https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif)

## Web 服務器配置

在您進行 CGI 編程之前，請確保您的 Web 服務器支持 CGI，並已配置成可以處理 CGI 程序。所有由 HTTP 服務器執行的 CGI 程序，都必須在預配置的目錄中。該目錄稱為 CGI 目錄，按照慣例命名為 /var/www/cgi-bin。雖然 CGI 文件是 C++ 可執行文件，但是按照慣例它的擴展名是 **.cgi**。

默認情況下，Apache Web 服務器會配置在 /var/www/cgi-bin 中運行 CGI 程序。如果您想指定其他目錄來運行 CGI 腳本，您可以在 httpd.conf 文件中修改以下部分：

```cpp
<Directory "/var/www/cgi-bin">   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all</Directory> <Directory "/var/www/cgi-bin">Options All</Directory>
```

在這裡，我們假設已經配置好 Web 服務器並能成功運行，你可以運行任意的 CGI 程序，比如 Perl 或 Shell 等。

## 第一個 CGI 程序

請看下面的 C++ 程序：

```cpp
#include <iostream>using namespace std;
 int main (){
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - 第一個 CGI 程序</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! 這是我的第一個 CGI 程序</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

編譯上面的代碼，把可執行文件命名為 cplusplus.cgi，並把這個文件保存在 /var/www/cgi-bin 目錄中。在運行 CGI 程序之前，請使用 **chmod 755 cplusplus.cgi** UNIX 命令來修改文件模式，確保文件可執行。訪問可執行文件，您會看到下面的輸出：

## Hello World! 這是我的第一個 CGI 程序

上面的 C++ 程序是一個簡單的程序，把它的輸出寫在 STDOUT 文件上，即顯示在屏幕上。在這裡，值得注意一點，第一行輸出 **Content-type:text/html\r\n\r\n**。這一行發送回瀏覽器，並指定要顯示在瀏覽器窗口上的內容類型。您必須理解 CGI 的基本概念，這樣才能進一步使用 Python 編寫更多複雜的 CGI 程序。C++ CGI 程序可以與任何其他外部的系統（如 RDBMS）進行交互。

## HTTP 頭信息

行 **Content-type:text/html\r\n\r\n** 是 HTTP 頭信息的組成部分，它被髮送到瀏覽器，以便更好地理解頁面內容。HTTP 頭信息的形式如下：

```cpp
HTTP 字段名稱: 字段內容 例如Content-type: text/html\r\n\r\n
```

還有一些其他的重要的 HTTP 頭信息，這些在您的 CGI 編程中都會經常被用到。

| 頭信息              | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| Content-type:       | MIME 字符串，定義返回的文件格式。例如 Content-type:text/html。 |
| Expires: Date       | 信息變成無效的日期。瀏覽器使用它來判斷一個頁面何時需要刷新。一個有效的日期字符串的格式應為 01 Jan 1998 12:00:00 GMT。 |
| Location: URL       | 這個 URL 是指應該返回的 URL，而不是請求的 URL。你可以使用它來重定向一個請求到任意的文件。 |
| Last-modified: Date | 資源的最後修改日期。                                         |
| Content-length: N   | 要返回的數據的長度，以字節為單位。瀏覽器使用這個值來表示一個文件的預計下載時間。 |
| Set-Cookie: String  | 通過 *string* 設置 cookie。                                  |

## CGI 環境變量

所有的 CGI 程序都可以訪問下列的環境變量。這些變量在編寫 CGI 程序時扮演了非常重要的角色。

| 變量名          | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| CONTENT_TYPE    | 內容的數據類型。當客戶端向服務器發送附加內容時使用。例如，文件上傳等功能。 |
| CONTENT_LENGTH  | 查詢的信息長度。只對 POST 請求可用。                         |
| HTTP_COOKIE     | 以鍵 & 值對的形式返回設置的 cookies。                        |
| HTTP_USER_AGENT | 用戶代理請求標頭字段，遞交用戶發起請求的有關信息，包含了瀏覽器的名稱、版本和其他平臺性的附加信息。 |
| PATH_INFO       | CGI 腳本的路徑。                                             |
| QUERY_STRING    | 通過 GET 方法發送請求時的 URL 編碼信息，包含 URL 中問號後面的參數。 |
| REMOTE_ADDR     | 發出請求的遠程主機的 IP 地址。這在日誌記錄和認證時是非常有用的。 |
| REMOTE_HOST     | 發出請求的主機的完全限定名稱。如果此信息不可用，則可以用 REMOTE_ADDR 來獲取 IP 地址。 |
| REQUEST_METHOD  | 用於發出請求的方法。最常見的方法是 GET 和 POST。             |
| SCRIPT_FILENAME | CGI 腳本的完整路徑。                                         |
| SCRIPT_NAME     | CGI 腳本的名稱。                                             |
| SERVER_NAME     | 服務器的主機名或 IP 地址。                                   |
| SERVER_SOFTWARE | 服務器上運行的軟件的名稱和版本。                             |

下面的 CGI 程序列出了所有的 CGI 變量。

```cpp
#include <iostream>#include <stdlib.h>using namespace std;const string ENV[ 24 ] = {                 
        "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",   
        "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",    &nbsnbsp;        
        "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",         
        "HTTP_HOST", "HTTP_USER_AGENT", "PATH",            
        "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",      
        "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
        "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",      
        "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",     
        "SERVER_SIGNATURE","SERVER_SOFTWARE" };   int main (){
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 環境變量</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";

   for ( int i = 0; i < 24; i++ )
   {
       cout << "<tr><td>" << ENV[ i ] << "</td><td>";
       // 嘗試檢索環境變量的值
       char *value = getenv( ENV[ i ].c_str() );  
       if ( value != 0 ){
         cout << value;                                 
       }else{
         cout << "環境變量不存在。";
       }
       cout << "</td></tr>\n";
   }
   cout << "</table><\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## C++ CGI 庫

在真實的實例中，您需要通過 CGI 程序執行許多操作。這裡有一個專為 C++ 程序而編寫的 CGI 庫，我們可以從 [ftp://ftp.gnu.org/gnu/cgicc/](ftp://ftp.gnu.org/gnu/cgicc/) 上下載這個 CGI 庫，並按照下面的步驟安裝庫：

```cpp
$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install
```

您可以點擊 C++ CGI Lib Documentation，查看相關的庫文檔。

## GET 和 POST 方法

您可能有遇到過這樣的情況，當您需要從瀏覽器傳遞一些信息到 Web 服務器，最後再傳到 CGI 程序。通常瀏覽器會使用兩種方法把這個信息傳到 Web 服務器，分別是 GET 和 POST 方法。

## 使用 GET 方法傳遞信息

GET 方法發送已編碼的用戶信息追加到頁面請求中。頁面和已編碼信息通過 ? 字符分隔開，如下所示：

```cpp
http://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2
```

GET 方法是默認的從瀏覽器向 Web 服務器傳信息的方法，它會在瀏覽器的地址欄中生成一串很長的字符串。當您向服務器傳密碼或其他一些敏感信息時，不要使用 GET 方法。GET 方法有大小限制，在一個請求字符串中最多可以傳 1024 個字符。

當使用 GET 方法時，是使用 QUERY_STRING http 頭來傳遞信息，在 CGI 程序中可使用 QUERY_STRING 環境變量來訪問。

您可以通過在 URL 後跟上簡單連接的鍵值對，也可以通過使用 HTML <FORM> 標籤的 GET 方法來傳信息。

## 簡單的 URL 實例：Get 方法

下面是一個簡單的 URL，使用 GET 方法傳遞兩個值給 hello_get.py 程序。

/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI

下面的實例生成 **cpp_get.cgi** CGI 程序，用於處理 Web 瀏覽器給出的輸入。通過使用 C++ CGI 庫，可以很容易地訪問傳遞的信息：

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>  using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
   
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>使用 GET 和 POST 方法</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("first_name");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "名：" << **fi << endl;  
   }else{
      cout << "No text entered for first name" << endl;  
   }
   cout << "<br/>\n";
   fi = formData.getElement("last_name");  
   if( !fi->isEmpty() &&fi != (*formData).end()) {  
      cout << "姓：" << **fi << endl;  
   }else{
      cout << "No text entered for last name" << endl;  
   }
   cout << "<br/>\n";

   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

現在，編譯上面的程序，如下所示：

```cpp
$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc
```

生成 cpp_get.cgi，並把它放在 CGI 目錄中，並嘗試使用下面的鏈接進行訪問：

/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI

這會產生以下結果：

```cpp
名：ZARA 姓：ALI
```

## 簡單的表單實例：GET 方法

下面是一個簡單的實例，使用 HTML 表單和提交按鈕傳遞兩個值。我們將使用相同的 CGI 腳本 cpp_get.cgi 來處理輸入。

```cpp
<form action="/cgi-bin/cpp_get.cgi" method="get">名：<input type="text" name="first_name">  <br /> 姓：<input type="text" name="last_name" /><input type="submit" value="提交" /></form>
```

下面是上述表單的實際輸出，請輸入名和姓，然後點擊提交按鈕查看結果。

## 使用 POST 方法傳遞信息

一個更可靠的向 CGI 程序傳遞信息的方法是 POST 方法。這種方法打包信息的方式與 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之後進行傳遞，而是把它以單獨的消息形式進行傳遞。該消息是以標準輸入的形式傳給 CGI 腳本的。

我們同樣使用 cpp_get.cgi 程序來處理 POST 方法。讓我們以同樣的例子，通過使用 HTML 表單和提交按鈕來傳遞兩個值，只不過這次我們使用的不是 GET 方法，而是 POST 方法，如下所示：

```cpp
<form action="/cgi-bin/cpp_get.cgi" method="post">名：<input type="text" name="first_name"><br />姓：<input type="text" name="last_name" /> <input type="submit" value="提交" /></form>
```

## 向 CGI 程序傳遞複選框數據

當需要選擇多個選項時，我們使用複選框。

下面的 HTML 代碼實例是一個帶有兩個複選框的表單：

```html
<form action="/cgi-bin/cpp_checkbox.cgi" 
         method="POST" 
         target="_blank"><input type="checkbox" name="maths" value="on" /> 數學<input type="checkbox" name="physics" value="on" /> 物理<input type="submit" value="選擇學科" /></form>
```

下面的 C++ 程序會生成 cpp_checkbox.cgi 腳本，用於處理 Web 瀏覽器通過複選框給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
   bool maths_flag, physics_flag;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序傳遞複選框數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   maths_flag = formData.queryCheckbox("maths");
   if( maths_flag ) {  
      cout << "Maths Flag: ON " << endl;  
   }else{
      cout << "Maths Flag: OFF " << endl;  
   }
   cout << "<br/>\n";

   physics_flag = formData.queryCheckbox("physics");
   if( physics_flag ) {  
      cout << "Physics Flag: ON " << endl;  
   }else{
      cout << "Physics Flag: OFF " << endl;  
   }
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程序傳遞單選按鈕數據

當只需要選擇一個選項時，我們使用單選按鈕。

下面的 HTML 代碼實例是一個帶有兩個單選按鈕的表單：

```cpp
<form action="/cgi-bin/cpp_radiobutton.cgi" 
         method="post" 
         target="_blank"><input type="radio" name="subject" value="maths" 
                                    checked="checked"/> 數學 
<input type="radio" name="subject" value="physics" /> 物理<input type="submit" value="選擇學科" /></form>
```

下面的 C++ 程序會生成 cpp_radiobutton.cgi 腳本，用於處理 Web 瀏覽器通過單選按鈕給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序傳遞單選按鈕數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("subject");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Radio box selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程序傳遞文本區域數據

當需要向 CGI 程序傳遞多行文本時，我們使用 TEXTAREA 元素。

下面的 HTML 代碼實例是一個帶有 TEXTAREA 框的表單：

```
<form action="/cgi-bin/cpp_textarea.cgi" 
         method="post" 
         target="_blank"><textarea name="textcontent" cols="40" rows="4">請在這裡輸入文本...</textarea><input type="submit" value="提交" /></form>
```

下面的 C++ 程序會生成 cpp_textarea.cgi 腳本，用於處理 Web 瀏覽器通過文本區域給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序傳遞文本區域數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("textcontent");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Text Content: " << **fi << endl;  
   }else{
      cout << "No text entered" << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 向 CGI 程序傳遞下拉框數據

當有多個選項可用，但只能選擇一個或兩個選項時，我們使用下拉框。

下面的 HTML 代碼實例是一個帶有下拉框的表單：

```cpp
<form action="/cgi-bin/cpp_dropdown.cgi" 
                       method="post" target="_blank"><select name="dropdown"><option value="Maths" selected>數學</option><option value="Physics">物理</option></select><input type="submit" value="提交"/></form>
```

下面的 C++ 程序會生成 cpp_dropdown.cgi 腳本，用於處理 Web 瀏覽器通過下拉框給出的輸入。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序傳遞下拉框數據</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   form_iterator fi = formData.getElement("dropdown");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Value Selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

## 在 CGI 中使用 Cookies

HTTP 協議是一種無狀態的協議。但對於一個商業網站，它需要在不同頁面間保持會話信息。例如，一個用戶在完成多個頁面的步驟之後結束註冊。但是，如何在所有網頁中保持用戶的會話信息。

在許多情況下，使用 cookies 是記憶和跟蹤有關用戶喜好、購買、佣金以及其他為追求更好的遊客體驗或網站統計所需信息的最有效的方法。

### 它是如何工作的

服務器以 cookie 的形式向訪客的瀏覽器發送一些數據。如果瀏覽器接受了 cookie，則 cookie 會以純文本記錄的形式存儲在訪客的硬盤上。現在，當訪客訪問網站上的另一個頁面時，會檢索 cookie。一旦找到 cookie，服務器就知道存儲了什麼。

cookie 是一種純文本的數據記錄，帶有 5 個可變長度的字段：

- **Expires :** cookie 的過期日期。如果此字段留空，cookie 會在訪客退出瀏覽器時過期。
- **Domain :** 網站的域名。
- **Path :** 設置 cookie 的目錄或網頁的路徑。如果您想從任意的目錄或網頁檢索 cookie，此字段可以留空。
- **Secure :** 如果此字段包含單詞 "secure"，那麼 cookie 只能通過安全服務器進行檢索。如果此字段留空，則不存在該限制。
- **Name=Value :** cookie 以鍵值對的形式被設置和獲取。

### 設置 Cookies

向瀏覽器發送 cookies 是非常簡單的。這些 cookies 會在 Content-type 字段之前，與 HTTP 頭一起被髮送。假設您想設置 UserID 和 Password 為 cookies，設置 cookies 的步驟如下所示：

```cpp
#include <iostream>using namespace std;int main (){
 
   cout << "Set-Cookie:UserID=XYZ;\r\n";
   cout << "Set-Cookie:Password=XYZ123;\r\n";
   cout << "Set-Cookie:Domain=www.w3cschool.cc;\r\n";
   cout << "Set-Cookie:Path=/perl;\n";
   cout << "Content-type:text/html\r\n\r\n";

   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   cout << "設置 cookies" << endl;  
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

從這個實例中，我們瞭解瞭如何設置 cookies。我們使用 **Set-Cookie** HTTP 頭來設置 cookies。

在這裡，有一些設置 cookies 的屬性是可選的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在發送行 **"Content-type:text/html\r\n\r\n** 之前被設置的。

編譯上面的程序，生成 setcookies.cgi，並嘗試使用下面的鏈接設置 cookies。它會在您的計算機上設置四個 cookies：

/cgi-bin/setcookies.cgi

### 獲取 Cookies

檢索所有設置的 cookies 是非常簡單的。cookies 被存儲在 CGI 環境變量 HTTP_COOKIE 中，且它們的形式如下：

```cpp
key1=value1;key2=value2;key3=value3....
```

下面的實例演示瞭如何獲取 cookies。

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){
   Cgicc cgi;
   const_cookie_iterator cci;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";
   
   // 獲取環境變量
   const CgiEnvironment& env = cgi.getEnvironment();

   for( cci = env.getCookieList().begin();
        cci != env.getCookieList().end(); 
        ++cci )
   {
      cout << "<tr><td>" << cci->getName() << "</td><td>";
      cout << cci->getValue();                                 
      cout << "</td></tr>\n";
   }
   cout << "</table><\n";
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

現在，編譯上面的程序，生成 getcookies.cgi，並嘗試使用下面的鏈接獲取您的計算機上所有可用的 cookies：

/cgi-bin/getcookies.cgi

這會產生一個列表，顯示了上一節中設置的四個 cookies 以及您的計算機上所有其他的 cookies：

```cpp
UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl
```

## 文件上傳實例

為了上傳一個文件，HTML 表單必須把 enctype 屬性設置為 **multipart/form-data**。帶有文件類型的 input 標籤會創建一個 "Browse" 按鈕。

```cpp
<html><body>
   <form enctype="multipart/form-data" 
            action="/cgi-bin/cpp_uploadfile.cgi" 
            method="post">
   <p>文件：<input type="file" name="userfile" /></p>
   <p><input type="submit" value="上傳" /></p>
   </form></body></html>
```

這段代碼的結果是下面的表單：

文件：

 

**注意：**上面的實例已經故意禁用了保存上傳的文件在我們的服務器上。您可以在自己的服務器上嘗試上面的代碼。

下面是用於處理文件上傳的腳本 **cpp_uploadfile.cpp**：

```cpp
#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){
   Cgicc cgi;

   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的文件上傳</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";

   // 獲取要被上傳的文件列表
   const_file_iterator file = cgi.getFile("userfile");
   if(file != cgi.getFiles().end()) {
      // 在 cout 中發送數據類型
      cout << HTTPContentHeader(file->getDataType());
      // 在 cout 中寫入內容
      file->writeToStream(cout);
   }
   cout << "<文件上傳成功>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;}
```

上面的實例是在 **cout** 流中寫入內容，但您可以打開文件流，並把上傳的文件內容保存在目標位置的某個文件中。

# C++ STL 教程

在前面的章節中，我們已經學習了 C++ 模板的概念。C++ STL（標準模板庫）是一套功能強大的 C++ 模板類，提供了通用的模板類和函數，這些模板類和函數可以實現多種流行和常用的算法和數據結構，如向量、鏈表、隊列、棧。

C++ 標準模板庫的核心包括以下三個組件：

| 組件                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| 容器（Containers）  | 容器是用來管理某一類對象的集合。C++ 提供了各種不同類型的容器，比如 deque、list、vector、map 等。 |
| 算法（Algorithms）  | 算法作用於容器。它們提供了執行各種操作的方式，包括對容器內容執行初始化、排序、搜索和轉換等操作。 |
| 迭代器（iterators） | 迭代器用於遍歷對象集合的元素。這些集合可能是容器，也可能是容器的子集。 |

這三個組件都帶有豐富的預定義函數，幫助我們通過簡單的方式處理複雜的任務。

下面的程序演示了向量容器（一個 C++ 標準的模板），它與數組十分相似，唯一不同的是，向量在需要擴展大小的時候，會自動處理它自己的存儲需求：

```cpp
#include <iostream>#include <vector>using namespace std;
 int main(){
   // 創建一個向量存儲 int
   vector<int> vec; 
   int i;

   // 顯示 vec 的原始大小
   cout << "vector size = " << vec.size() << endl;

   // 推入 5 個值到向量中
   for(i = 0; i < 5; i++){
      vec.push_back(i);
   }

   // 顯示 vec 擴展後的大小
   cout << "extended vector size = " << vec.size() << endl;

   // 訪問向量中的 5 個值
   for(i = 0; i < 5; i++){
      cout << "value of vec [" << i << "] = " << vec[i] << endl;
   }

   // 使用迭代器 iterator 訪問值
   vector<int>::iterator v = vec.begin();
   while( v != vec.end()) {
      cout << "value of v = " << *v << endl;
      v++;
   }

   return 0;}
```

當上面的代碼被編譯和執行時，它會產生下列結果：

```cpp
vector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4
```

關於上面實例中所使用的各種函數，有幾點要注意：

- push_back( ) 成員函數在向量的末尾插入值，如果有必要會擴展向量的大小。
- size( ) 函數顯示向量的大小。
- begin( ) 函數返回一個指向向量開頭的迭代器。
- end( ) 函數返回一個指向向量末尾的迭代器。

# C++ 標準庫

C++ 標準庫可以分為兩部分：

- **標準函數庫：** 這個庫是由通用的、獨立的、不屬於任何類的函數組成的。函數庫繼承自 C 語言。
- **面向對象類庫：** 這個庫是類及其相關函數的集合。

C++ 標準庫包含了所有的 C 標準庫，為了支持類型安全，做了一定的添加和修改。

## 標準函數庫

標準函數庫分為以下幾類：

- 輸入/輸出 I/O
- 字符串和字符處理
- 數學
- 時間、日期和本地化
- 動態分配
- 其他
- 寬字符函數

## 面向對象類庫

標準的 C++ 面向對象類庫定義了大量支持一些常見操作的類，比如輸入/輸出 I/O、字符串處理、數值處理。面向對象類庫包含以下內容：

- 標準的 C++ I/O 類
- String 類
- 數值類
- STL 容器類
- STL 算法
- STL 函數對象
- STL 迭代器
- STL 分配器
- 本地化庫
- 異常處理類
- 雜項支持庫

