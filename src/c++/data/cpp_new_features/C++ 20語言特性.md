> 本文為譯文，原文連結：https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/CPP20.md

### Coroutines（協程）

協程是一種特殊的函式，它的執行可以被暫停或恢復。要定義協程，關鍵字`co_return `，` co_await `，或`co_yield `必須出現在函式體中。c++ 20的協程是無棧的;除非編譯器進行了最佳化，否則它們的狀態是在堆上分配的。

協程的一個例子是**generator**函式，它在每次調用時生成一個值:

```cpp
generator<int> range(int start, int end) {
  while (start < end) {
    co_yield start;
    start++;
  }

  // Implicit co_return at the end of this function:
  // co_return;
}

for (int n : range(0, 10)) {
  std::cout << n << std::endl;
}
```

上面的` range `生成器函式生成的值從` start `開始直到` end `(互斥)，每個迭代步驟生成存儲在` start `中的當前值。生成器在每次調用` range `時都保持它的狀態(在本例中，調用是針對for迴圈中的每次迭代)。` co_yield `接受給定的表達式，生成(即返回)它的值，並在那一點暫停協程。在恢復時，在` co_yield `之後繼續執行。

協程的另一個例子是*task*，它是一個在等待任務時執行的非同步計算:

```cpp
task<void> echo(socket s) {
  for (;;) {
    auto data = co_await s.async_read();
    co_await async_write(s, data);
  }

  // Implicit co_return at the end of this function:
  // co_return;
}
```

在本例中，引入了` co_await `關鍵字。這個關鍵字接受一個表達式，如果您正在等待的東西(在本例中是讀或寫)沒有準備好，則掛起執行，否則繼續執行。(注意，在內部，` co_yield `使用` co_await `。)

使用任務惰性地評估一個值:

```cpp
task<int> calculate_meaning_of_life() {
  co_return 42;
}

auto meaning_of_life = calculate_meaning_of_life();
// ...
co_await meaning_of_life; // == 42
```

注意:雖然這些示例說明了如何在基本級別上使用協程，但在編譯程式碼時還有更多內容。這些例子並不意味著完全覆蓋c++ 20的協程。由於標準庫還沒有提供` generator `和` task `類，所以我使用cppcoro庫來編譯這些示例。

### Concepts（概念）

*概念*被命名為約束型別的編譯時謂詞。它們的形式如下:

```cpp
template < template-parameter-list >
concept concept-name = constraint-expression;
```

其中` constraint-expression `計算為constexpr布爾值。*約束*應該對語義需求進行建模，例如型別是數字型別還是可哈希型別。如果給定的型別不滿足它所綁定的概念(例如:“約束表達式”返回“false”)。因為約束是在編譯時計算的，所以它們可以提供更有意義的錯誤消息和運行時安全性。

```cpp
// `T` is not limited by any constraints.
template <typename T>
concept always_satisfied = true;
// Limit `T` to integrals.
template <typename T>
concept integral = std::is_integral_v<T>;
// Limit `T` to both the `integral` constraint and signedness.
template <typename T>
concept signed_integral = integral<T> && std::is_signed_v<T>;
// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.
template <typename T>
concept unsigned_integral = integral<T> && !signed_integral<T>;
```

有各種各樣的語法形式來加強概念:

```cpp
// Forms for function parameters:
// `T` is a constrained type template parameter.
template <my_concept T>
void f(T v);

// `T` is a constrained type template parameter.
template <typename T>
  requires my_concept<T>
void f(T v);

// `T` is a constrained type template parameter.
template <typename T>
void f(T v) requires my_concept<T>;

// `v` is a constrained deduced parameter.
void f(my_concept auto v);

// `v` is a constrained non-type template parameter.
template <my_concept auto v>
void g();

// Forms for auto-deduced variables:
// `foo` is a constrained auto-deduced value.
my_concept auto foo = ...;

// Forms for lambdas:
// `T` is a constrained type template parameter.
auto f = []<my_concept T> (T v) {
  // ...
};
// `T` is a constrained type template parameter.
auto f = []<typename T> requires my_concept<T> (T v) {
  // ...
};
// `T` is a constrained type template parameter.
auto f = []<typename T> (T v) requires my_concept<T> {
  // ...
};
// `v` is a constrained deduced parameter.
auto f = [](my_concept auto v) {
  // ...
};
// `v` is a constrained non-type template parameter.
auto g = []<my_concept auto v> () {
  // ...
};
```

` requires `關鍵字可以用來啟動一個require子句或一個require表達式:

```cpp
template <typename T>
  requires my_concept<T> // `requires` clause.
void f(T);

template <typename T>
concept callable = requires (T f) { f(); }; // `requires` expression.

template <typename T>
  requires requires (T x) { x + x; } // `requires` clause and expression on same line.
T add(T a, T b) {
  return a + b;
}
```

注意，requires表達式中的參數列表是可選的。require表達式中的每個需求都是下列要求之一:

- **Simple requirements** - 斷言給定表達式是否有效。

```cpp
template <typename T>
concept callable = requires (T f) { f(); };
```

- **Type requirements** - 關鍵字` typename `後跟一個型別名錶示，斷言給定的型別名是有效的。

```cpp
struct foo {
  int foo;
};

struct bar {
  using value = int;
  value data;
};

struct baz {
  using value = int;
  value data;
};

// Using SFINAE, enable if `T` is a `baz`.
template <typename T, typename = std::enable_if_t<std::is_same_v<T, baz>>>
struct S {};

template <typename T>
using Ref = T&;

template <typename T>
concept C = requires {
                     // Requirements on type `T`:
  typename T::value; // A) has an inner member named `value`
  typename S<T>;     // B) must have a valid class template specialization for `S`
  typename Ref<T>;   // C) must be a valid alias template substitution
};

template <C T>
void g(T a);

g(foo{}); // ERROR: Fails requirement A.
g(bar{}); // ERROR: Fails requirement B.
g(baz{}); // PASS.
```

- **Compound requirements** - 用大括號括起來的表達式，後面跟著返回型別或型別約束。

```cpp
template <typename T>
concept C = requires(T x) {
  {*x} -> typename T::inner; // the type of the expression `*x` is convertible to `T::inner`
  {x + 1} -> std::same_as<int>; // the expression `x + 1` satisfies `std::same_as<decltype((x + 1))>`
  {x * 1} -> T; // the type of the expression `x * 1` is convertible to `T`
};
```

- **Nested requirements** - 由` requires `關鍵字表示，指定額外的約束(例如本地參數參數)。

```cpp
template <typename T>
concept C = requires(T x) {
  requires std::same_as<sizeof(x), size_t>;
};
```

### Designated initializers(指定初始化式)

c風格指定初始化式語法。任何未顯式列出在指定初始化列表中的成員字段都是預設初始化的。

```cpp
struct A {
  int x;
  int y;
  int z = 123;
};

A a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2
```

### Template syntax for lambdas(lambda的樣板語法)

在lambda表達式中使用熟悉的樣板語法。

```cpp
auto f = []<typename T>(std::vector<T> v) {
  // ...
};
```

### Range-based for loop with initializer(帶初始化器的基於範圍的for迴圈)

該特性簡化了常見的程式碼模式，有助於保持範圍緊湊，併為常見的生存期問題提供了優雅的解決方案。

```cpp
for (std::vector v{1, 2, 3}; auto& e : v) {
  std::cout << e;
}
// prints "123"
```

### likely and unlikely attributes(可能和不可能的屬性)

向最佳化器提供提示，說明已標記語句執行的概率很高。

```cpp
switch (n) {
case 1:
  // ...
  break;

[[likely]] case 2:  // n == 2 is considered to be arbitrarily more
  // ...            // likely than any other value of n
  break;
}
```

如果一個可能/不太可能的屬性出現在If語句的右括號之後，則表明分支可能/不太可能執行其子語句(體)。

```cpp
int random = get_random_number_between_x_and_y(0, 3);
if (random > 0) [[likely]] {
  // body of if statement
  // ...
}
```

它也可以應用於迭代語句的子語句(體)。

```cpp
while (unlikely_truthy_condition) [[unlikely]] {
  // body of while statement
  // ...
}
```

### Deprecate implicit capture of this(不建議隱式捕獲)

在lamdba捕獲中使用`[=]`隱式捕獲` this `現在已棄用;更喜歡使用` [=，this] `或` [=，*this] `顯式捕獲。

```cpp
struct int_value {
  int n = 0;
  auto getter_fn() {
    // BAD:
    // return [=]() { return n; };

    // GOOD:
    return [=, *this]() { return n; };
  }
};
```

### Class types in non-type template parameters(非型別樣板形式參數中的型別)

類現在可以在非型別樣板參數中使用。作為樣板參數傳入的物件的型別為` const T `，其中` T `是物件的型別，並且具有靜態存儲時間。

```cpp
struct foo {
  foo() = default;
  constexpr foo(int) {}
};

template <foo f>
auto get_foo() {
  return f;
}

get_foo(); // uses implicit constructor
get_foo<foo{123}>();
```

### constexpr virtual functions(constexpr虛擬函式)

虛擬函式現在可以是` constexpr `並在編譯時計算。` constexpr `虛擬函式可以覆蓋非` constexpr `虛擬函式，反之亦然。

```cpp
struct X1 {
  virtual int f() const = 0;
};

struct X2: public X1 {
  constexpr virtual int f() const { return 2; }
};

struct X3: public X2 {
  virtual int f() const { return 3; }
};

struct X4: public X3 {
  constexpr virtual int f() const { return 4; }
};

constexpr X4 x4;
x4.f(); // == 4
```

### explicit(bool)(是否顯式)

在編譯時有條件地選擇建構函式是否顯式。` explicit(true) `與指定` explicit `相同。

```cpp
struct foo {
  // Specify non-integral types (strings, floats, etc.) require explicit construction.
  template <typename T>
  explicit(!std::is_integral_v<T>) foo(T) {}
};

foo a = 123; // OK
foo b = "123"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)
foo c {"123"}; // OK
```

### Immediate functions

類似於` constexpr `函式，但是帶有` consteval `說明符的函式必須產生一個常數。這些被稱為“直接函式”。

```cpp
consteval int sqr(int n) {
  return n * n;
}

constexpr int r = sqr(100); // OK
int x = 100;
int r2 = sqr(x); // ERROR: the value of `x` is not usable in a constant expression
                 // OK if `sqr` were a `constexpr` function
```

### using enum

將列舉成員引入作用域以提高可讀性。之前:

```cpp
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```

之後:

```cpp
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel my_channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```

### Lambda capture of parameter pack(參數包的Lambda捕獲)

捕獲參數按值包:

```cpp
template <typename... Args>
auto f(Args&&... args){
    // BY VALUE:
    return [...args = std::forward<Args>(args)] {
        // ...
    };
}
```

通過參照捕獲參數包:

```cpp
template <typename... Args>
auto f(Args&&... args){
    // BY REFERENCE:
    return [&...args = std::forward<Args>(args)] {
        // ...
    };
}
```

### char8_t

提供表示UTF-8字串的標準型別。

```cpp
char8_t utf8_str[] = u8"\u0123";
```

## c++ 20庫功能

### Concepts library

標準庫還提供了用於構建更復雜概念的概念。其中包括:

**核心語言概念:**

- `same_as` - 指定兩種相同的型別。
- `derived_from` - 指定一個型別派生自另一個型別。
- `convertible_to` - 指定一個型別可隱式轉換為另一個型別。
- `common_with` - 指定兩個型別共享一個公共型別。
- `integral` - 指定型別為整型。
- `default_constructible` - 指定可以預設建構型別的物件。

**Comparison concepts:**

- `boolean` - 指定可在布爾上下文中使用的型別。
- `equality_comparable` - 指定` operator== `是一個等價關係。

**Object concepts:**

- `movable` - 指定可移動和交換某一型別的物件。
- `copyable` - 指定可複製、移動和交換某一型別的物件。
- `semiregular` - 指定某個型別的物件可以被複制、移動、交換和預設建構。
- `regular` - 指定型別為*regular*，即既為` semiregular `又為` equality_comparable `。

**Callable concepts:**

- `invocable` - 指定可使用給定參數型別集調用可調用型別。
- `predicate` - 指定可調用型別是布爾謂詞。

### Synchronized buffered outputstream

緩衝包裝輸出流的輸出操作，以確保同步(即輸出沒有交錯)。

```cpp
std::osyncstream{std::cout} << "The value of x is:" << x << std::endl;
```

### std::span

span是容器的一個視圖(即非所有者視圖)，它提供了對連續元素組的邊界檢查訪問。由於視圖不擁有它們自己的元素，它們的建構和複製成本很低——考慮視圖的一種簡單方法是它們持有對其數據的參照。跨度可以是動態大小的，也可以是固定大小的。

```cpp
void f(std::span<int> ints) {
    std::for_each(ints.begin(), ints.end(), [](auto i) {
        // ...
    });
}

std::vector<int> v = {1, 2, 3};
f(v);
std::array<int, 3> a = {1, 2, 3};
f(a);
// etc.
```

示例:與維護指標和長度字段不同，span將這兩個字段打包在一個容器中。

```cpp
constexpr size_t LENGTH_ELEMENTS = 3;
int* arr = new int[LENGTH_ELEMENTS]; // arr = {0, 0, 0}

// Fixed-sized span which provides a view of `arr`.
std::span<int, LENGTH_ELEMENTS> span = arr;
span[1] = 1; // arr = {0, 1, 0}

// Dynamic-sized span which provides a view of `arr`.
std::span<int> d_span = arr;
span[0] = 1; // arr = {1, 1, 0}
constexpr size_t LENGTH_ELEMENTS = 3;
int* arr = new int[LENGTH_ELEMENTS];

std::span<int, LENGTH_ELEMENTS> span = arr; // OK
std::span<double, LENGTH_ELEMENTS> span2 = arr; // ERROR
std::span<int, 1> span3 = arr; // ERROR
```

### Bit operations

c++ 20提供了一個新的` <bit> `頭，它提供了一些位元元操作，包括popcount。

```cpp
std::popcount(0u); // 0
std::popcount(1u); // 1
std::popcount(0b1111`0000u); // 4
```

### Math constants

在` <numbers> ` header中定義的數學常數，包括PI、歐拉數等。

```cpp
std::numbers::pi; // 3.14159...
std::numbers::e; // 2.71828...
```

### std::is_constant_evaluated

謂詞函式，當它在編譯時上下文中被調用時為真

```cpp
constexpr bool is_compile_time() {
    return std::is_constant_evaluated();
}

constexpr bool a = is_compile_time(); // true
bool b = is_compile_time(); // false
```

### std::make_shared supports arrays

```cpp
auto p = std::make_shared<int[]>(5); // pointer to `int[5]`
// OR
auto p = std::make_shared<int[5]>(); // pointer to `int[5]`
```

### starts_with and ends_with on strings

字串(和字串視圖)現在有` starts_with `和` ends_with `成員函式來檢查一個字串是否以給定的字串開始或結束。

```cpp
std::string str = "foobar";
str.starts_with("foo"); // true
str.ends_with("baz"); // false
```

### Check if associative container has element

像集合和映射這樣的關聯容器有一個“contains”成員函式，它可以用來代替“搜尋和檢查疊代器的結束”習慣用法。

```cpp
std::map<int, char> map {{1, `a`}, {2, `b`}};
map.contains(2); // true
map.contains(123); // false

std::set<int> set {1, 2, 3};
set.contains(2); // true
```

### std::bit_cast

將物件從一種型別重新解釋為另一種型別的更安全的方法。

```cpp
float f = 123.0;
int i = std::bit_cast<int>(f);
```

### std::midpoint

安全地計算兩個整數的中點(不溢出)。

```cpp
std::midpoint(1, 3); // == 2
```

### std::to_array

將給定的陣列/"array-like"物件轉換為` std::array `。

```cpp
std::to_array("foo"); // returns `std::array<char, 4>`
std::to_array<int>({1, 2, 3}); // returns `std::array<int, 3>`

int a[] = {1, 2, 3};
std::to_array(a); // returns `std::array<int, 3>`
```
