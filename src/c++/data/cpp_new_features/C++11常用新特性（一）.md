# C++11常用新特性（一）

最近工作中，遇到一些問題，使用C11實現起來會更加方便，而線上的生產環境還不支援C11，於是決定新年開工後，在組內把C++11推廣開來，整理以下文件，方便自己查閱，也方便同事快速上手。（對於非同步編程十分實用的Future/Promise以及智慧指標等，將不做整理介紹，組內使用的框架已經支援並廣泛使用了，用的是自己公司參考boost實現的版本）



# nullptr

nullptr 出現的目的是為了替代 NULL。

在某種意義上來說，傳統 C++ 會把 NULL、0 視為同一種東西，這取決於編譯器如何定義 NULL，有些編譯器會將 NULL 定義為 ((void*)0)，有些則會直接將其定義為 0。

C++ 不允許直接將 void  *隱式轉換到其他型別，但如果 NULL 被定義為 ((void*)0)，那麼當編譯char *ch = NULL;時，NULL 只好被定義為 0。

而這依然會產生問題，將導致了 C++ 中多載特性會發生混亂，考慮：

```c
void foo(char *);
void foo(int);
```

對於這兩個函式來說，如果 NULL 又被定義為了 0 那麼 foo(NULL); 這個語句將會去調用 foo(int)，從而導致程式碼違反直觀。

為了解決這個問題，C++11 引入了 nullptr 關鍵字，專門用來區分空指標、0。

nullptr 的型別為 nullptr_t，能夠隱式的轉換為任何指標或成員指標的型別，也能和他們進行相等或者不等的比較。

當需要使用 NULL 時候，養成直接使用 nullptr的習慣。

# 型別推導

C++11 引入了 auto 和 decltype 這兩個關鍵字實現了型別推導，讓編譯器來操心變數的型別。

## auto

auto 在很早以前就已經進入了 C++，但是他始終作為一個存儲型別的指示符存在，與 register 並存。在傳統 C++ 中，如果一個變數沒有聲明為 register 變數，將自動被視為一個 auto 變數。而隨著 register 被棄用，對 auto 的語義變更也就非常自然了。

使用 auto 進行型別推導的一個最為常見而且顯著的例子就是疊代器。在以前我們需要這樣來書寫一個疊代器：

```c
for(vector<int>::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)
```

而有了 auto 之後可以：

```c
// 由於 cbegin() 將返回 vector<int>::const_iterator 
// 所以 itr 也應該是 vector<int>::const_iterator 型別
for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);
```

一些其他的常見用法：

```c
auto i = 5;             // i 被推導為 int
auto arr = new auto(10) // arr 被推導為 int *
```

注意：auto 不能用於函式傳參，因此下面的做法是無法通過編譯的（考慮多載的問題，我們應該使用樣板）：

```c
int add(auto x, auto y);
```

此外，auto 還不能用於推導陣列型別：

```c
#include <iostream>

int main() {
 auto i = 5;

 int arr[10] = {0};
 auto auto_arr = arr;
 auto auto_arr2[10] = arr;

 return 0;
}
```

## decltype

decltype 關鍵字是為了解決 auto 關鍵字只能對變數進行型別推導的缺陷而出現的。它的用法和 sizeof 很相似：

```c
decltype(表達式)
```

在此過程中，編譯器分析表達式並得到它的型別，卻不實際計算表達式的值。

有時候，我們可能需要計算某個表達式的型別，例如：

```c
auto x = 1;
auto y = 2;
decltype(x+y) z;
```

## 拖尾返回型別、auto 與 decltype 配合

你可能會思考，auto 能不能用於推導函式的返回型別。考慮這樣一個例子加法函式的例子，在傳統 C++ 中我們必須這麼寫：

```c
template<typename R, typename T, typename U>
R add(T x, U y) {
    return x+y
}
```

這樣的程式碼其實變得很醜陋，因為程式員在使用這個樣板函式的時候，必須明確指出返回型別。但事實上我們並不知道 add() 這個函式會做什麼樣的操作，獲得一個什麼樣的返回型別。

在 C++11 中這個問題得到解決。雖然你可能馬上回反應出來使用 decltype 推導 x+y 的型別，寫出這樣的程式碼：

```c
decltype(x+y) add(T x, U y);
```

但事實上這樣的寫法並不能通過編譯。這是因為在編譯器讀到 decltype(x+y) 時，x 和 y 尚未被定義。為了解決這個問題，C++11 還引入了一個叫做拖尾返回型別（trailing return type），利用 auto 關鍵字將返回型別後置：



```c
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```



從 C++14 開始是可以直接讓普通函式具備回傳值推導，因此下面的寫法變得合法：



```c
template<typename T, typename U>
auto add(T x, U y) {
    return x+y;
}
```



# 區間迭代



## 基於範圍的 for 迴圈



C++11 引入了基於範圍的迭代寫法，我們擁有了能夠寫出像 Python 一樣簡潔的迴圈語句。
最常用的 std::vector 走訪將從原來的樣子：



```c
std::vector<int> arr(5, 100);
for(std::vector<int>::iterator i = arr.begin(); i != arr.end(); ++i) {
    std::cout << *i << std::endl;
}
```



變得非常的簡單：



```c
// & 啟用了參照
for(auto &i : arr) {    
    std::cout << i << std::endl;
}
```



# 初始化列表



C++11 提供了統一的語法來初始化任意的物件，例如：



```c
struct A {
    int a;
    float b;
};
struct B {
  B(int _a, float _b): a(_a), b(_b) {}
  private:
    int a;
    float b;
};

A a {1, 1.1};    // 統一的初始化語法
B b {2, 2.2};
```



C++11 還把初始化列表的概念綁定到了型別上，並將其稱之為`std::initializer_list`，允許建構函式或其他函式像參數一樣使用初始化列表，這就為類物件的初始化與普通陣列和 POD 的初始化方法提供了統一的橋樑，例如：



```c
#include <initializer_list>

class Magic {
public:
    Magic(std::initializer_list<int> list) {}
};

Magic magic = {1,2,3,4,5};
std::vector<int> v = {1, 2, 3, 4};
```



# 樣板增強



## 外部樣板



傳統 C++ 中，樣板只有在使用時才會被編譯器實體化。只要在每個編譯單元（檔案）中編譯的程式碼中遇到了被完整定義的樣板，都會實體化。這就產生了重複實體化而導致的編譯時間的增加。並且，我們沒有辦法通知編譯器不要觸發樣板實體化。



C++11 引入了外部樣板，擴充了原來的強制編譯器在特定位元元置實體化樣板的語法，使得能夠顯式的告訴編譯器何時進行樣板的實體化：



```c
template class std::vector<bool>;            // 強行實體化
extern template class std::vector<double>;  // 不在該編譯檔案中實體化樣板
```



## 尖括號 “>”



在傳統 C++ 的編譯器中，`>>`一律被當做右移運算子來進行處理。但實際上我們很容易就寫出了嵌套樣板的程式碼：



```c
std::vector<std::vector<int>> wow;
```



這在傳統C編譯器下是不能夠被編譯的，而 C11 開始，連續的右尖括號將變得合法，並且能夠順利通過編譯。



## 型別別名樣板



在傳統 C++中，typedef 可以為型別定義一個新的名稱，但是卻沒有辦法為樣板定義一個新的名稱。因為，樣板不是型別。例如：



```c
template< typename T, typename U, int value>
class SuckType {
public:
    T a;
    U b;
    SuckType():a(value),b(value){}
};
template< typename U>
typedef SuckType<std::vector<int>, U, 1> NewType; // 不合法
```



C++11 使用 using 引入了下面這種形式的寫法，並且同時支援對傳統 typedef 相同的功效：



```c
template <typename T>
using NewType = SuckType<int, T, 1>;    // 合法
```



## 預設樣板參數



我們可能定義了一個加法函式：



```c
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y
}
```



但在使用時發現，要使用 add，就必須每次都指定其樣板參數的型別。



在 C++11 中提供了一種便利，可以指定樣板的預設參數：



```c
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```



# 建構函式



## 委託建構



C++11 引入了委託建構的概念，這使得建構函式可以在同一個類中一個建構函式調用另一個建構函式，從而達到簡化程式碼的目的：



```c
class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() {  // 委託 Base() 建構函式
        value2 = 2;
    }
};
```



## 繼承建構



在繼承體系中，如果派生類想要使用基類的建構函式，需要在建構函式中顯式聲明。



假若基類擁有為數眾多的不同版本的建構函式，這樣，在派生類中得寫很多對應的“透傳”建構函式。如下：



```c
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的建構函式版本
}；
struct B:A
{
  B(int i):A(i){}
  B(double d,int i):A(d,i){}
  B(folat f,int i,const char* c):A(f,i,e){}
  //......等等好多個和基類建構函式對應的建構函式
}；
```



C++11的繼承建構：



```c
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的建構函式版本
}；
struct B:A
{
  using A::A;
  //關於基類各建構函式的繼承一句話搞定
  //......
}；
```



如果一個繼承建構函式不被相關的程式碼使用，編譯器不會為之產生真正的函式程式碼，這樣比透傳基類各種建構函式更加節省目標程式碼空間。



# 

# 新增容器



## std::array



std::array 保存在棧記憶體中，相比堆記憶體中的 std::vector，我們能夠靈活的訪問這裡面的元素，從而獲得更高的性能。



std::array 會在編譯時創建一個固定大小的陣列，std::array 不能夠被隱式的轉換成指標，使用 std::array只需指定其型別和大小即可：



```c
std::array<int, 4> arr= {1,2,3,4};

int len = 4;
std::array<int, len> arr = {1,2,3,4}; // 非法, 陣列大小參數必須是常數表達式
```



當我們開始用上了 std::array 時，難免會遇到要將其兼容 C 風格的介面，這裡有三種做法：



```c
void foo(int *p, int len) {
    return;
}

std::array<int 4> arr = {1,2,3,4};

// C 風格介面傳參
// foo(arr, arr.size());           // 非法, 無法隱式轉換
foo(&arr[0], arr.size());
foo(arr.data(), arr.size());

// 使用 `std::sort`
std::sort(arr.begin(), arr.end());
```



## std::forward_list



std::forward_list 是一個列表容器，使用方法和 std::list 基本類似。



和 std::list 的雙向鏈結串列的實現不同，std::forward_list 使用單向鏈結串列進行實現，提供了 O(1) 複雜度的元素插入，不支援快速隨機訪問（這也是鏈結串列的特點），也是標準庫容器中唯一一個不提供 size() 方法的容器。當不需要雙向迭代時，具有比 std::list 更高的空間利用率。



## 無序容器



C++11 引入了兩組無序容器：
`std::unordered_map/std::unordered_multimap`和 `std::unordered_set/std::unordered_multiset`。



無序容器中的元素是不進行排序的，內部通過 Hash 表實現，插入和搜尋元素的平均複雜度為 O(constant)。



## 元組 std::tuple



元組的使用有三個核心的函式：



`std::make_tuple`: 建構元組
`std::get`: 獲得元組某個位元元置的值
`std::tie`: 元組拆包



```c
#include <tuple>
#include <iostream>

auto get_student(int id)
{
    // 返回型別被推斷為 std::tuple<double, char, std::string>
    if (id == 0)
        return std::make_tuple(3.8, 'A', "張三");
    if (id == 1)
        return std::make_tuple(2.9, 'C', "李四");
    if (id == 2)
        return std::make_tuple(1.7, 'D', "王五");
    return std::make_tuple(0.0, 'D', "null");   
    // 如果只寫 0 會出現推斷錯誤, 編譯失敗
}

int main()
{
    auto student = get_student(0);
    std::cout << "ID: 0, "
    << "GPA: " << std::get<0>(student) << ", "
    << "成績: " << std::get<1>(student) << ", "
    << "姓名: " << std::get<2>(student) << '\n';

    double gpa;
    char grade;
    std::string name;
    
    // 元組進行拆包
    std::tie(gpa, grade, name) = get_student(1);
    std::cout << "ID: 1, "
    << "GPA: " << gpa << ", "
    << "成績: " << grade << ", "
    << "姓名: " << name << '\n';

}
```



合併兩個元組，可以通過 std::tuple_cat 來實現。



```c
auto new_tuple = std::tuple_cat(get_student(1), std::move(t));
```



# 正則表達式



正則表達式描述了一種字串匹配的模式。一般使用正則表達式主要是實現下面三個需求：



1. 檢查一個串是否包含某種形式的子串；
2. 將匹配的子串替換；

1. 從某個串中取出符合條件的子串。



C++11 提供的正則表達式庫操作 std::string 物件，對模式 std::regex (本質是 std::basic_regex)進行初始化，通過 std::regex_match 進行匹配，從而產生 std::smatch （本質是 std::match_results 物件）。



我們通過一個簡單的例子來簡單介紹這個庫的使用。考慮下面的正則表達式：



[a-z]+.txt: 在這個正則表達式中, [a-z] 表示匹配一個小寫字母, + 可以使前面的表達式匹配多次，因此 [a-z]+ 能夠匹配一個及以上小寫字母組成的字串。在正則表達式中一個 . 表示匹配任意字符，而 . 轉義後則表示匹配字符 . ，最後的 txt 表示嚴格匹配 txt 這三個字母。因此這個正則表達式的所要匹配的內容就是檔案名為純小寫字母的文本檔案。
std::regex_match 用於匹配字串和正則表達式，有很多不同的多載形式。最簡單的一個形式就是傳入std::string 以及一個 std::regex 進行匹配，當匹配成功時，會返回 true，否則返回 false。例如：



```c
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string fnames[] = {"foo.txt", "bar.txt", "test", "a0.txt", "AAA.txt"};
    // 在 C++ 中 `\` 會被作為字串內的轉義符，為使 `\.` 作為正則表達式傳遞進去生效，需要對 `\` 進行二次轉義，從而有 `\\.`
    std::regex txt_regex("[a-z]+\\.txt");
    for (const auto &fname: fnames)
        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << std::endl;
}
```



另一種常用的形式就是依次傳入 std::string/std::smatch/std::regex 三個參數，其中 std::smatch 的本質其實是 std::match_results，在標準庫中， std::smatch 被定義為了 std::match_results，也就是一個子串疊代器型別的 match_results。使用 std::smatch 可以方便的對匹配的結果進行獲取，例如：



```c
std::regex base_regex("([a-z]+)\\.txt");
std::smatch base_match;
for(const auto &fname: fnames) {
    if (std::regex_match(fname, base_match, base_regex)) {
        // sub_match 的第一個元素匹配整個字串
        // sub_match 的第二個元素匹配了第一個括號表達式
        if (base_match.size() == 2) {
            std::string base = base_match[1].str();
            std::cout << "sub-match[0]: " << base_match[0].str() << std::endl;
            std::cout << fname << " sub-match[1]: " << base << std::endl;
        }
    }
}
```



以上兩個程式碼段的輸出結果為：



```bash
foo.txt: 1
bar.txt: 1
test: 0
a0.txt: 0
AAA.txt: 0
sub-match[0]: foo.txt
foo.txt sub-match[1]: foo
sub-match[0]: bar.txt
bar.txt sub-match[1]: bar
```



# 語言級執行緒支援



std::thread<br>
std::mutex/std::unique_lock<br>
std::future/std::packaged_task<br>
std::condition_variable<br>
