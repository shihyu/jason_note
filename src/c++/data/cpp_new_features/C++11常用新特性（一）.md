# C++11常用新特性（一）

最近工作中，遇到一些問題，使用C11實現起來會更加方便，而線上的生產環境還不支持C11，於是決定新年開工後，在組內把C++11推廣開來，整理以下文檔，方便自己查閱，也方便同事快速上手。（對於異步編程十分實用的Future/Promise以及智能指針等，將不做整理介紹，組內使用的框架已經支持並廣泛使用了，用的是自己公司參考boost實現的版本）



# nullptr

nullptr 出現的目的是為了替代 NULL。

在某種意義上來說，傳統 C++ 會把 NULL、0 視為同一種東西，這取決於編譯器如何定義 NULL，有些編譯器會將 NULL 定義為 ((void*)0)，有些則會直接將其定義為 0。

C++ 不允許直接將 void  *隱式轉換到其他類型，但如果 NULL 被定義為 ((void*)0)，那麼當編譯char *ch = NULL;時，NULL 只好被定義為 0。

而這依然會產生問題，將導致了 C++ 中重載特性會發生混亂，考慮：

```c
void foo(char *);
void foo(int);
```

對於這兩個函數來說，如果 NULL 又被定義為了 0 那麼 foo(NULL); 這個語句將會去調用 foo(int)，從而導致代碼違反直觀。

為了解決這個問題，C++11 引入了 nullptr 關鍵字，專門用來區分空指針、0。

nullptr 的類型為 nullptr_t，能夠隱式的轉換為任何指針或成員指針的類型，也能和他們進行相等或者不等的比較。

當需要使用 NULL 時候，養成直接使用 nullptr的習慣。

# 類型推導

C++11 引入了 auto 和 decltype 這兩個關鍵字實現了類型推導，讓編譯器來操心變量的類型。

## auto

auto 在很早以前就已經進入了 C++，但是他始終作為一個存儲類型的指示符存在，與 register 並存。在傳統 C++ 中，如果一個變量沒有聲明為 register 變量，將自動被視為一個 auto 變量。而隨著 register 被棄用，對 auto 的語義變更也就非常自然了。

使用 auto 進行類型推導的一個最為常見而且顯著的例子就是迭代器。在以前我們需要這樣來書寫一個迭代器：

```c
for(vector<int>::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)
```

而有了 auto 之後可以：

```c
// 由於 cbegin() 將返回 vector<int>::const_iterator 
// 所以 itr 也應該是 vector<int>::const_iterator 類型
for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);
```

一些其他的常見用法：

```c
auto i = 5;             // i 被推導為 int
auto arr = new auto(10) // arr 被推導為 int *
```

注意：auto 不能用於函數傳參，因此下面的做法是無法通過編譯的（考慮重載的問題，我們應該使用模板）：

```c
int add(auto x, auto y);
```

此外，auto 還不能用於推導數組類型：

```c
#include <iostream>

int main() {
 auto i = 5;

 int arr[10] = {0};
 auto auto_arr = arr;
 auto auto_arr2[10] = arr;

 return 0;
}
```

## decltype

decltype 關鍵字是為了解決 auto 關鍵字只能對變量進行類型推導的缺陷而出現的。它的用法和 sizeof 很相似：

```c
decltype(表達式)
```

在此過程中，編譯器分析表達式並得到它的類型，卻不實際計算表達式的值。

有時候，我們可能需要計算某個表達式的類型，例如：

```c
auto x = 1;
auto y = 2;
decltype(x+y) z;
```

## 拖尾返回類型、auto 與 decltype 配合

你可能會思考，auto 能不能用於推導函數的返回類型。考慮這樣一個例子加法函數的例子，在傳統 C++ 中我們必須這麼寫：

```c
template<typename R, typename T, typename U>
R add(T x, U y) {
    return x+y
}
```

這樣的代碼其實變得很醜陋，因為程序員在使用這個模板函數的時候，必須明確指出返回類型。但事實上我們並不知道 add() 這個函數會做什麼樣的操作，獲得一個什麼樣的返回類型。

在 C++11 中這個問題得到解決。雖然你可能馬上回反應出來使用 decltype 推導 x+y 的類型，寫出這樣的代碼：

```c
decltype(x+y) add(T x, U y);
```

但事實上這樣的寫法並不能通過編譯。這是因為在編譯器讀到 decltype(x+y) 時，x 和 y 尚未被定義。為了解決這個問題，C++11 還引入了一個叫做拖尾返回類型（trailing return type），利用 auto 關鍵字將返回類型後置：



```c
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```



從 C++14 開始是可以直接讓普通函數具備返回值推導，因此下面的寫法變得合法：



```c
template<typename T, typename U>
auto add(T x, U y) {
    return x+y;
}
```



# 區間迭代



## 基於範圍的 for 循環



C++11 引入了基於範圍的迭代寫法，我們擁有了能夠寫出像 Python 一樣簡潔的循環語句。
最常用的 std::vector 遍歷將從原來的樣子：



```c
std::vector<int> arr(5, 100);
for(std::vector<int>::iterator i = arr.begin(); i != arr.end(); ++i) {
    std::cout << *i << std::endl;
}
```



變得非常的簡單：



```c
// & 啟用了引用
for(auto &i : arr) {    
    std::cout << i << std::endl;
}
```



# 初始化列表



C++11 提供了統一的語法來初始化任意的對象，例如：



```c
struct A {
    int a;
    float b;
};
struct B {
  B(int _a, float _b): a(_a), b(_b) {}
  private:
    int a;
    float b;
};

A a {1, 1.1};    // 統一的初始化語法
B b {2, 2.2};
```



C++11 還把初始化列表的概念綁定到了類型上，並將其稱之為`std::initializer_list`，允許構造函數或其他函數像參數一樣使用初始化列表，這就為類對象的初始化與普通數組和 POD 的初始化方法提供了統一的橋樑，例如：



```c
#include <initializer_list>

class Magic {
public:
    Magic(std::initializer_list<int> list) {}
};

Magic magic = {1,2,3,4,5};
std::vector<int> v = {1, 2, 3, 4};
```



# 模板增強



## 外部模板



傳統 C++ 中，模板只有在使用時才會被編譯器實例化。只要在每個編譯單元（文件）中編譯的代碼中遇到了被完整定義的模板，都會實例化。這就產生了重複實例化而導致的編譯時間的增加。並且，我們沒有辦法通知編譯器不要觸發模板實例化。



C++11 引入了外部模板，擴充了原來的強制編譯器在特定位置實例化模板的語法，使得能夠顯式的告訴編譯器何時進行模板的實例化：



```c
template class std::vector<bool>;            // 強行實例化
extern template class std::vector<double>;  // 不在該編譯文件中實例化模板
```



## 尖括號 “>”



在傳統 C++ 的編譯器中，`>>`一律被當做右移運算符來進行處理。但實際上我們很容易就寫出了嵌套模板的代碼：



```c
std::vector<std::vector<int>> wow;
```



這在傳統C編譯器下是不能夠被編譯的，而 C11 開始，連續的右尖括號將變得合法，並且能夠順利通過編譯。



## 類型別名模板



在傳統 C++中，typedef 可以為類型定義一個新的名稱，但是卻沒有辦法為模板定義一個新的名稱。因為，模板不是類型。例如：



```c
template< typename T, typename U, int value>
class SuckType {
public:
    T a;
    U b;
    SuckType():a(value),b(value){}
};
template< typename U>
typedef SuckType<std::vector<int>, U, 1> NewType; // 不合法
```



C++11 使用 using 引入了下面這種形式的寫法，並且同時支持對傳統 typedef 相同的功效：



```c
template <typename T>
using NewType = SuckType<int, T, 1>;    // 合法
```



## 默認模板參數



我們可能定義了一個加法函數：



```c
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y
}
```



但在使用時發現，要使用 add，就必須每次都指定其模板參數的類型。



在 C++11 中提供了一種便利，可以指定模板的默認參數：



```c
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```



# 構造函數



## 委託構造



C++11 引入了委託構造的概念，這使得構造函數可以在同一個類中一個構造函數調用另一個構造函數，從而達到簡化代碼的目的：



```c
class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() {  // 委託 Base() 構造函數
        value2 = 2;
    }
};
```



## 繼承構造



在繼承體系中，如果派生類想要使用基類的構造函數，需要在構造函數中顯式聲明。



假若基類擁有為數眾多的不同版本的構造函數，這樣，在派生類中得寫很多對應的“透傳”構造函數。如下：



```c
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的構造函數版本
}；
struct B:A
{
  B(int i):A(i){}
  B(double d,int i):A(d,i){}
  B(folat f,int i,const char* c):A(f,i,e){}
  //......等等好多個和基類構造函數對應的構造函數
}；
```



C++11的繼承構造：



```c
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的構造函數版本
}；
struct B:A
{
  using A::A;
  //關於基類各構造函數的繼承一句話搞定
  //......
}；
```



如果一個繼承構造函數不被相關的代碼使用，編譯器不會為之產生真正的函數代碼，這樣比透傳基類各種構造函數更加節省目標代碼空間。



# 

# 新增容器



## std::array



std::array 保存在棧內存中，相比堆內存中的 std::vector，我們能夠靈活的訪問這裡面的元素，從而獲得更高的性能。



std::array 會在編譯時創建一個固定大小的數組，std::array 不能夠被隱式的轉換成指針，使用 std::array只需指定其類型和大小即可：



```c
std::array<int, 4> arr= {1,2,3,4};

int len = 4;
std::array<int, len> arr = {1,2,3,4}; // 非法, 數組大小參數必須是常量表達式
```



當我們開始用上了 std::array 時，難免會遇到要將其兼容 C 風格的接口，這裡有三種做法：



```c
void foo(int *p, int len) {
    return;
}

std::array<int 4> arr = {1,2,3,4};

// C 風格接口傳參
// foo(arr, arr.size());           // 非法, 無法隱式轉換
foo(&arr[0], arr.size());
foo(arr.data(), arr.size());

// 使用 `std::sort`
std::sort(arr.begin(), arr.end());
```



## std::forward_list



std::forward_list 是一個列表容器，使用方法和 std::list 基本類似。



和 std::list 的雙向鏈表的實現不同，std::forward_list 使用單向鏈表進行實現，提供了 O(1) 複雜度的元素插入，不支持快速隨機訪問（這也是鏈表的特點），也是標準庫容器中唯一一個不提供 size() 方法的容器。當不需要雙向迭代時，具有比 std::list 更高的空間利用率。



## 無序容器



C++11 引入了兩組無序容器：
`std::unordered_map/std::unordered_multimap`和 `std::unordered_set/std::unordered_multiset`。



無序容器中的元素是不進行排序的，內部通過 Hash 表實現，插入和搜索元素的平均複雜度為 O(constant)。



## 元組 std::tuple



元組的使用有三個核心的函數：



`std::make_tuple`: 構造元組
`std::get`: 獲得元組某個位置的值
`std::tie`: 元組拆包



```c
#include <tuple>
#include <iostream>

auto get_student(int id)
{
    // 返回類型被推斷為 std::tuple<double, char, std::string>
    if (id == 0)
        return std::make_tuple(3.8, 'A', "張三");
    if (id == 1)
        return std::make_tuple(2.9, 'C', "李四");
    if (id == 2)
        return std::make_tuple(1.7, 'D', "王五");
    return std::make_tuple(0.0, 'D', "null");   
    // 如果只寫 0 會出現推斷錯誤, 編譯失敗
}

int main()
{
    auto student = get_student(0);
    std::cout << "ID: 0, "
    << "GPA: " << std::get<0>(student) << ", "
    << "成績: " << std::get<1>(student) << ", "
    << "姓名: " << std::get<2>(student) << '\n';

    double gpa;
    char grade;
    std::string name;
    
    // 元組進行拆包
    std::tie(gpa, grade, name) = get_student(1);
    std::cout << "ID: 1, "
    << "GPA: " << gpa << ", "
    << "成績: " << grade << ", "
    << "姓名: " << name << '\n';

}
```



合併兩個元組，可以通過 std::tuple_cat 來實現。



```c
auto new_tuple = std::tuple_cat(get_student(1), std::move(t));
```



# 正則表達式



正則表達式描述了一種字符串匹配的模式。一般使用正則表達式主要是實現下面三個需求：



1. 檢查一個串是否包含某種形式的子串；
2. 將匹配的子串替換；

1. 從某個串中取出符合條件的子串。



C++11 提供的正則表達式庫操作 std::string 對象，對模式 std::regex (本質是 std::basic_regex)進行初始化，通過 std::regex_match 進行匹配，從而產生 std::smatch （本質是 std::match_results 對象）。



我們通過一個簡單的例子來簡單介紹這個庫的使用。考慮下面的正則表達式：



[a-z]+.txt: 在這個正則表達式中, [a-z] 表示匹配一個小寫字母, + 可以使前面的表達式匹配多次，因此 [a-z]+ 能夠匹配一個及以上小寫字母組成的字符串。在正則表達式中一個 . 表示匹配任意字符，而 . 轉義後則表示匹配字符 . ，最後的 txt 表示嚴格匹配 txt 這三個字母。因此這個正則表達式的所要匹配的內容就是文件名為純小寫字母的文本文件。
std::regex_match 用於匹配字符串和正則表達式，有很多不同的重載形式。最簡單的一個形式就是傳入std::string 以及一個 std::regex 進行匹配，當匹配成功時，會返回 true，否則返回 false。例如：



```c
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string fnames[] = {"foo.txt", "bar.txt", "test", "a0.txt", "AAA.txt"};
    // 在 C++ 中 `\` 會被作為字符串內的轉義符，為使 `\.` 作為正則表達式傳遞進去生效，需要對 `\` 進行二次轉義，從而有 `\\.`
    std::regex txt_regex("[a-z]+\\.txt");
    for (const auto &fname: fnames)
        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << std::endl;
}
```



另一種常用的形式就是依次傳入 std::string/std::smatch/std::regex 三個參數，其中 std::smatch 的本質其實是 std::match_results，在標準庫中， std::smatch 被定義為了 std::match_results，也就是一個子串迭代器類型的 match_results。使用 std::smatch 可以方便的對匹配的結果進行獲取，例如：



```c
std::regex base_regex("([a-z]+)\\.txt");
std::smatch base_match;
for(const auto &fname: fnames) {
    if (std::regex_match(fname, base_match, base_regex)) {
        // sub_match 的第一個元素匹配整個字符串
        // sub_match 的第二個元素匹配了第一個括號表達式
        if (base_match.size() == 2) {
            std::string base = base_match[1].str();
            std::cout << "sub-match[0]: " << base_match[0].str() << std::endl;
            std::cout << fname << " sub-match[1]: " << base << std::endl;
        }
    }
}
```



以上兩個代碼段的輸出結果為：



```bash
foo.txt: 1
bar.txt: 1
test: 0
a0.txt: 0
AAA.txt: 0
sub-match[0]: foo.txt
foo.txt sub-match[1]: foo
sub-match[0]: bar.txt
bar.txt sub-match[1]: bar
```



# 語言級線程支持



std::thread<br>
std::mutex/std::unique_lock<br>
std::future/std::packaged_task<br>
std::condition_variable<br>
