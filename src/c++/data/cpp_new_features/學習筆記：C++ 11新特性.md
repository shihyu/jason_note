# C++11新特性之auto和decltype知識點

C++11引入了auto和decltype關鍵字，使用它們可以在編譯期就推導出變量或者表達式的類型，方便開發者編碼的同時也簡化了代碼。

## auto

auto可以讓編譯器在編譯器就推導出變量的類型，看代碼：

```c++
auto a = 10; // 10是int型，可以自動推導出a是int
int i = 10;auto b = i; // b是int型
auto d = 2.0; // d是double型
```

這就是auto的基本用法，可以通過=右邊的類型推導出變量的類型。

### auto推導規則

直接看代碼

代碼1：

```c++
int i = 10;
auto a = i, &b = i, *c = &i; // a是int，b是i的引用，c是i的指針，auto就相當於int
auto d = 0, f = 1.0; // error，0和1.0類型不同，對於編譯器有二義性，沒法推導
auto e; // error，使用auto必須馬上初始化，否則無法推導類型
```

代碼2：

```c++
void func(auto value) {} // error，auto不能用作函數參數

class A {
    auto a = 1; // error，在類中auto不能用作非靜態成員變量
    static auto b = 1; // error，這裡與auto無關，正常static int b = 1也不可以
    static const auto int c = 1; // ok
};

void func2() {
    int a[10] = {0};
    auto b = a; // ok
    auto c[10] = a; // error，auto不能定義數組，可以定義指針
    vector<int> d;
    vector<auto> f = d; // error，auto無法推導出模板參數
}
```

auto的限制：

- auto的使用必須馬上初始化，否則無法推導出類型
- auto在一行定義多個變量時，各個變量的推導不能產生二義性，否則編譯失敗

- auto不能用作函數參數
- 在類中auto不能用作非靜態成員變量

- auto不能定義數組，可以定義指針
- auto無法推導出模板參數

再看這段代碼：

```c++
int i = 0;
auto *a = &i; // a是int*
auto &b = i; // b是int&
auto c = b; // c是int，忽略了引用

const auto d = i; // d是const int
auto e = d; // e是int

const auto& f = e; // f是const int&
auto &g = f; // g是const int&
```

首先，介紹下，這裡的cv是指const 和volatile

推導規則

- 在不聲明為引用或指針時，auto會忽略等號右邊的引用類型和cv限定
- 在聲明為引用或者指針時，auto會保留等號右邊的引用和cv屬性

### 什麼時候使用auto？

這裡沒有絕對答案，在不影響代碼代碼可讀性的前提下儘可能使用auto是蠻好的，複雜類型就使用auto，int、double這種就沒有必要使用auto了，看下面這段代碼：

```c++
auto func = [&] {
    cout << "xxx";
}; // 對於func難道不使用auto嗎，反正是不關心lambda表達式究竟是什麼類型。

auto asyncfunc = std::async(std::launch::async, func);
// 對於asyncfunc難道不使用auto嗎，懶得寫std::futurexxx等代碼，而且也記不住它返回的究竟是什麼...
```

## decltype

上面介紹auto用於推導變量類型，而decltype則用於推導表達式類型，這裡只用於編譯器分析表達式的類型，表達式實際不會進行運算，上代碼：

```c++
int func() { return 0; }
decltype(func()) i; // i為int類型

int x = 0;
decltype(x) y; // y是int類型
decltype(x + y) z; // z是int類型
```

注意：decltype不會像auto一樣忽略引用和cv屬性，decltype會保留表達式的引用和cv屬性

```c++
cont int &i = 1;
int a = 2;
decltype(i) b = 2; // b是const int&
```

### decltype推導規則

對於decltype(exp)有

- exp是表達式，decltype(exp)和exp類型相同
- exp是函數調用，decltype(exp)和函數返回值類型相同

- 其它情況，若exp是左值，decltype(exp)是exp類型的左值引用

```c++
int a = 0, b = 0;
decltype(a + b) c = 0; // c是int，因為(a+b)返回一個右值
decltype(a += b) d = c;// d是int&，因為(a+=b)返回一個左值

d = 20;
cout << "c " << c << endl; // 輸出c 20
```

## auto和decltype的配合使用

auto和decltype一般配合使用在推導函數返回值的類型問題上。

下面這段代碼

```c++
template<typename T, typename U>
return_value add(T t, U u) { // t和v類型不確定，無法推導出return_value類型
    return t + u;
}
```

上面代碼由於t和u類型不確定，那如何推導出返回值類型呢，可能會想到這種

```c++
template<typename T, typename U>
decltype(t + u) add(T t, U u) { // t和u尚未定義
    return t + u;
}
```

這段代碼在C++11上是編譯不過的，因為在decltype(t +u)推導時，t和u尚未定義，就會編譯出錯，所以有了下面的叫做返回類型後置的配合使用方法：

```c++
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

返回值後置類型語法就是為了解決函數返回值類型依賴於參數但卻難以確定返回值類型的問題。

# C++11新特性之左值引用、右值引用、移動語義、完美轉發

C++11新增了右值引用，談右值引用也可以擴展一些相關概念：

- 左值
- 右值

- 純右值
- 將亡值

- 左值引用
- 右值引用

- 移動語義
- 完美轉發

- 返回值優化

### 左值、右值

概念1：

左值：可以放到等號左邊的東西叫左值。

右值：不可以放到等號左邊的東西就叫右值。

概念2：

左值：可以取地址並且有名字的東西就是左值。

右值：不能取地址的沒有名字的東西就是右值。

舉例：

```c++
int a = b + c;
```

a是左值，有變量名，可以取地址，也可以放到等號左邊, 表達式b+c的返回值是右值，沒有名字且不能取地址，&(b+c)不能通過編譯，而且也不能放到等號左邊。

```c++
int a = 4; // a是左值，4作為普通字面量是右值
```

左值一般有：

- 函數名和變量名
- 返回左值引用的函數調用

- 前置自增自減表達式++i、--i
- 由賦值表達式或賦值運算符連接的表達式(a=b, a += b等)

- 解引用表達式*p
- 字符串字面值"abcd"

### 純右值、將亡值

純右值和將亡值都屬於右值。

#### 純右值

運算表達式產生的臨時變量、不和對象關聯的原始字面量、非引用返回的臨時變量、lambda表達式等都是純右值。

舉例：

- 除字符串字面值外的字面值
- 返回非引用類型的函數調用

- 後置自增自減表達式i++、i--
- 算術表達式(a+b, a*b, a&&b, a==b等)

- 取地址表達式等(&a)

#### 將亡值

將亡值是指C++11新增的和右值引用相關的表達式，通常指將要被移動的對象、T&&函數的返回值、std::move函數的返回值、轉換為T&&類型轉換函數的返回值，將亡值可以理解為即將要銷燬的值，通過“盜取”其它變量內存空間方式獲取的值，在確保其它變量不再被使用或者即將被銷燬時，可以避免內存空間的釋放和分配，延長變量值的生命週期，常用來完成移動構造或者移動賦值的特殊任務。

舉例：

```c++
class A {
    xxx;
};
A a;
auto c = std::move(a); // c是將亡值
auto d = static_cast<A&&>(a); // d是將亡值
```

#### 左值引用、右值引用

根據名字大概就可以猜到意思，左值引用就是對左值進行引用的類型，右值引用就是對右值進行引用的類型，他們都是引用，都是對象的一個別名，並不擁有所綁定對象的堆存，所以都必須立即初始化。

```c++
type &name = exp; // 左值引用
type &&name = exp; // 右值引用
```

左值引用

看代碼：

```c++
int a = 5;
int &b = a; // b是左值引用
b = 4;
int &c = 10; // error，10無法取地址，無法進行引用
const int &d = 10; // ok，因為是常引用，引用常量數字，這個常量數字會存儲在內存中，可以取地址
```

可以得出結論：對於左值引用，等號右邊的值必須可以取地址，如果不能取地址，則會編譯失敗，或者可以使用const引用形式，但這樣就只能通過引用來讀取輸出，不能修改數組，因為是常量引用。

右值引用

如果使用右值引用，那表達式等號右邊的值需要時右值，可以使用std::move函數強制把左值轉換為右值。

```c++
int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok
```

### 移動語義

談移動語義前，首先需要了解深拷貝與淺拷貝的概念

#### 深拷貝、淺拷貝

直接拿代碼舉例:

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = a.data_;
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

上面代碼中，兩個輸出的是相同的地址，a和b的data_指針指向了同一塊內存，這就是淺拷貝，只是數據的簡單賦值，那再析構時data_內存會被釋放兩次，導致程序出問題，這裡正常會出現double free導致程序崩潰的，這樣的程序肯定是有隱患的，如何消除這種隱患呢，可以使用如下深拷貝：

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

深拷貝就是再拷貝對象時，如果被拷貝對象內部還有指針引用指向其它資源，自己需要重新開闢一塊新內存存儲資源，而不是簡單的賦值。

移動語義可以理解為轉移所有權，之前的拷貝是對於別人的資源，自己重新分配一塊內存存儲複製過來的資源，而對於移動語義，類似於轉讓或者資源竊取的意思，對於那塊資源，轉為自己所擁有，別人不再擁有也不會再使用，通過C++11新增的移動語義可以省去很多拷貝負擔，怎麼利用移動語義呢，是通過移動構造函數。

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    A(A&& a) {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "move " << endl;
    }
    ~A() {
        if (data_ != nullptr) {
         delete[] data_;
        }
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    A c = std::move(a); // 調用移動構造函數
    return 0;
}
```

如果不使用std::move()，會有很大的拷貝代價，使用移動語義可以避免很多無用的拷貝，提供程序性能，C++所有的STL都實現了移動語義，方便使用。例如：

```c++
std::vector<string> vecs;
...
std::vector<string> vecm = std::move(vecs); // 免去很多拷貝
```

注意：移動語義僅針對於那些實現了移動構造函數的類的對象，對於那種基本類型int、float等沒有任何優化作用，還是會拷貝，因為它們實現沒有對應的移動構造函數。

### 完美轉發

完美轉發指可以寫一個接受任意實參的函數模板，並轉發到其它函數，目標函數會收到與轉發函數完全相同的實參，轉發函數實參是左值那目標函數實參也是左值，轉發函數實參是右值那目標函數實參也是右值。那如何實現完美轉發呢，答案是使用std::forward()。

```c++
void PrintV(int &t) {
    cout << "lvalue" << endl;
}

void PrintV(int &&t) {
    cout << "rvalue" << endl;
}

template<typename T>
void Test(T &&t) {
    PrintV(t);
    PrintV(std::forward<T>(t));

    PrintV(std::move(t));
}

int main() {
    Test(1); // lvalue rvalue rvalue
    int a = 1;
    Test(a); // lvalue lvalue rvalue
    Test(std::forward<int>(a)); // lvalue rvalue rvalue
    Test(std::forward<int&>(a)); // lvalue lvalue rvalue
    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    return 0;
}
```

分析

- Test(1)：1是右值，模板中T &&t這種為萬能引用，右值1傳到Test函數中變成了右值引用，但是調用PrintV()時候，t變成了左值，因為它變成了一個擁有名字的變量，所以打印lvalue，而PrintV(std::forward<T>(t))時候，會進行完美轉發，按照原來的類型轉發，所以打印rvalue，PrintV(std::move(t))毫無疑問會打印rvalue。
- Test(a)：a是左值，模板中T &&這種為萬能引用，左值a傳到Test函數中變成了左值引用，所以有代碼中打印。

- Test(std::forward<T>(a))：轉發為左值還是右值，依賴於T，T是左值那就轉發為左值，T是右值那就轉發為右值。

### 返回值優化

返回值優化(RVO)是一種C++編譯優化技術，當函數需要返回一個對象實例時候，就會創建一個臨時對象並通過複製構造函數將目標對象複製到臨時對象，這裡有複製構造函數和析構函數會被多餘的調用到，有代價，而通過返回值優化，C++標準允許省略調用這些複製構造函數。

那什麼時候編譯器會進行返回值優化呢?

- return的值類型與函數的返回值類型相同
- return的是一個局部對象

看幾個例子:

示例1：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}
std::vector<int> &&rval_ref = return_vector();
```

不會觸發RVO，拷貝構造了一個臨時的對象，臨時對象的生命週期和rval_ref綁定，等價於下面這段代碼：

```c++
const std::vector<int>& rval_ref = return_vector();
```

示例2：

```c++
std::vector<int>&& return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

這段代碼會造成運行時錯誤，因為rval_ref引用了被析構的tmp。講道理來說這段代碼是錯的，自己運行過程中卻成功了，繼續向下看什麼時候會觸發RVO。

示例3：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

和示例1類似，std::move一個臨時對象是沒有必要的，也會忽略掉返回值優化。

最好的代碼：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}

std::vector<int> rval_ref = return_vector();
```

這段代碼會觸發RVO，不拷貝也不移動，不生成臨時對象。

# C++11新特性之列表初始化

C++11新增了列表初始化的概念。

在C++11中可以直接在變量名後面加上初始化列表來進行對象的初始化。

```c++
struct A {
    public:
    A(int) {}
    private:
    A(const A&) {}
};
int main() {
    A a(123);
    A b = 123; // error
    A c = { 123 };
    A d{123}; // c++11

    int e = {123};
    int f{123}; // c++11

    return 0;
}
```

列表初始化也可以用在函數的返回值上

```c++
std::vector<int> func() {
    return {};
}
```

### 列表初始化的一些規則

首先說下聚合類型可以進行直接列表初始化，這裡需要了解什麼是聚合類型：

1. 類型是一個普通數組，如int[5]，char[]，double[]等
2. 類型是一個類，且滿足以下條件：

- - 沒有用戶聲明的構造函數
  - 沒有用戶提供的構造函數(允許顯示預置或棄置的構造函數)

- - 沒有私有或保護的非靜態數據成員
  - 沒有基類

- - 沒有虛函數
  - 沒有{}和=直接初始化的非靜態數據成員

- - 沒有默認成員初始化器

```c++
struct A {
    int a;
    int b;
    int c;
    A(int, int){}
};
int main() {
    A a{1, 2, 3};// error，A有自定義的構造函數，不能列表初始化
}
```

上述代碼類A不是聚合類型，無法進行列表初始化，必須以自定義的構造函數來構造對象。

```c++
struct A {
    int a;
    int b;
    virtual void func() {} // 含有虛函數，不是聚合類
};

struct Base {};
struct B : public Base { // 有基類，不是聚合類
    int a;
    int b;
};

struct C {
    int a;
    int b = 10; // 有等號初始化，不是聚合類
};

struct D {
    int a;
    int b;
    private:
    int c; // 含有私有的非靜態數據成員，不是聚合類
};

struct E {
    int a;
    int b;
    E() : a(0), b(0) {} // 含有默認成員初始化器，不是聚合類
};
```

上面列舉了一些不是聚合類的例子，對於一個聚合類型，使用列表初始化相當於對其中的每個元素分別賦值；對於非聚合類型，需要先自定義一個對應的構造函數，此時列表初始化將調用相應的構造函數。

### std::initializer_list

平時開發使用STL過程中可能發現它的初始化列表可以是任意長度，大家有沒有想過它是怎麼實現的呢，答案是std::initializer_list，看下面這段示例代碼：

```c++
struct CustomVec {
    std::vector<int> data;
    CustomVec(std::initializer_list<int> list) {
        for (auto iter = list.begin(); iter != list.end(); ++iter) {
            data.push_back(*iter);
        }
    }
};
```

這個std::initializer_list其實也可以作為函數參數。

注意：std::initializer_list<T>，它可以接收任意長度的初始化列表，但是裡面必須是相同類型T，或者都可以轉換為T。

### 列表初始化的好處

列表初始化的好處如下：

1. 方便，且基本上可以替代括號初始化
2. 可以使用初始化列表接受任意長度

1. 可以防止類型窄化，避免精度丟失的隱式類型轉換

什麼是類型窄化，列表初始化通過禁止下列轉換，對隱式轉化加以限制：

- 從浮點類型到整數類型的轉換
- 從 long double 到 double 或 float 的轉換，以及從 double 到 float 的轉換，除非源是常量表達式且不發生溢出

- 從整數類型到浮點類型的轉換，除非源是其值能完全存儲於目標類型的常量表達式
- 從整數或無作用域枚舉類型到不能表示原類型所有值的整數類型的轉換，除非源是其值能完全存儲於目標類型的常量表達式

示例：

```c++
int main() {
    int a = 1.2; // ok
    int b = {1.2}; // error

    float c = 1e70; // ok
    float d = {1e70}; // error

    float e = (unsigned long long)-1; // ok
    float f = {(unsigned long long)-1}; // error
    float g = (unsigned long long)1; // ok
    float h = {(unsigned long long)1}; // ok

    const int i = 1000;
    const int j = 2;
    char k = i; // ok
    char l = {i}; // error

    char m = j; // ok
    char m = {j}; // ok，因為是const類型，這裡如果去掉const屬性，也會報錯
}
```

打印如下：

```c++
test.cc:24:17: error: narrowing conversion of ‘1.2e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
    int b = {1.2};
                ^
test.cc:27:20: error: narrowing conversion of ‘1.0000000000000001e+70’ from ‘double’ to ‘float’ inside { } [-Wnarrowing]
     float d = {1e70};

test.cc:30:38: error: narrowing conversion of ‘18446744073709551615’ from ‘long long unsigned int’ to ‘float’ inside { } [-Wnarrowing]
    float f = {(unsigned long long)-1};
                                     ^
test.cc:36:14: warning: overflow in implicit constant conversion [-Woverflow]
    char k = i;
             ^
test.cc:37:16: error: narrowing conversion of ‘1000’ from ‘int’ to ‘char’ inside { } [-Wnarrowing]
    char l = {i};
```

# C++11新特性std::function和lambda表達式

c++11新增了`std::function`、`std::bind`、`lambda`表達式等封裝使函數調用更加方便。

## `std::function`

講`std::function`前首先需要了解下什麼是可調用對象

滿足以下條件之一就可稱為可調用對象：

- 是一個函數指針
- 是一個具有`operator()`成員函數的類對象(傳說中的仿函數)，lambda表達式

- 是一個可被轉換為函數指針的類對象
- 是一個類成員(函數)指針

- bind表達式或其它函數對象

而`std::function`就是上面這種可調用對象的封裝器，可以把`std::function`看做一個函數對象，用於表示函數這個抽象概念。`std::function`的實例可以存儲、複製和調用任何可調用對象，存儲的可調用對象稱為`std::function`的目標，若`std::function`不含目標，則稱它為空，調用空的`std::function`的目標會拋出`std::bad_function_call`異常。

使用參考如下實例代碼：

```c++
std::function<void(int)> f; // 這裡表示function的對象f的參數是int，返回值是void
#include <functional>
#include <iostream>

struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_ + i << '\n'; }
    int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
    void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
    // 存儲自由函數
    std::function<void(int)> f_display = print_num;
    f_display(-9);

    // 存儲 lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();

    // 存儲到 std::bind 調用的結果
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();

    // 存儲到成員函數的調用
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
    const Foo foo(314159);
    f_add_display(foo, 1);
    f_add_display(314159, 1);

    // 存儲到數據成員訪問器的調用
    std::function<int(Foo const&)> f_num = &Foo::num_;
    std::cout << "num_: " << f_num(foo) << '\n';

    // 存儲到成員函數及對象的調用
    using std::placeholders::_1;
    std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);
    f_add_display2(2);

    // 存儲到成員函數和對象指針的調用
    std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);
    f_add_display3(3);

    // 存儲到函數對象的調用
    std::function<void(int)> f_display_obj = PrintNum();
    f_display_obj(18);
}
```

從上面可以看到`std::function`的使用方法，當給`std::function`填入合適的參數表和返回值後，它就變成了可以容納所有這一類調用方式的函數封裝器。`std::function`還可以用作回調函數，或者在C++裡如果需要使用回調那就一定要使用`std::function`，特別方便。

## `std::bind`

使用`std::bind`可以將可調用對象和參數一起綁定，綁定後的結果使用`std::function`進行保存，並延遲調用到任何需要的時候。

`std::bind`通常有兩大作用：

- 將可調用對象與參數一起綁定為另一個`std::function`供調用
- 將n元可調用對象轉成m(m < n)元可調用對象，綁定一部分參數，這裡需要使用`std::placeholders`

具體示例：

```c++
#include <functional>
#include <iostream>
#include <memory>

void f(int n1, int n2, int n3, const int& n4, int n5) {
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << std::endl;
}

int g(int n1) { return n1; }

struct Foo {
    void print_sum(int n1, int n2) { std::cout << n1 + n2 << std::endl; }
    int data = 10;
};

int main() {
    using namespace std::placeholders;  // 針對 _1, _2, _3...

    // 演示參數重排序和按引用傳遞
    int n = 7;
    // （ _1 與 _2 來自 std::placeholders ，並表示將來會傳遞給 f1 的參數）
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001);  // 1 為 _1 所綁定， 2 為 _2 所綁定，不使用 1001
    // 進行到 f(2, 42, 1, n, 7) 的調用

    // 嵌套 bind 子表達式共享佔位符
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12);  // 進行到 f(12, g(12), 12, 4, 5); 的調用

    // 綁定指向成員函數指針
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);

    // 綁定指向數據成員指針
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << std::endl;

    // 智能指針亦能用於調用被引用對象的成員
    std::cout << f4(std::make_shared<Foo>(foo)) << std::endl;
}
```

## `lambda`表達式

lambda表達式可以說是c++11引用的最重要的特性之一，它定義了一個匿名函數，可以捕獲一定範圍的變量在函數內部使用，一般有如下語法形式：

```c++
auto func = [capture] (params) opt -> ret { func_body; };
```

其中`func`是可以當作`lambda`表達式的名字，作為一個函數使用，`capture`是捕獲列表，`params`是參數表，`opt`是函數選項(mutable之類)， ret是返回值類型，func_body是函數體。

一個完整的lambda表達式：

```c++
auto func1 = [](int a) -> int { return a + 1; };
auto func2 = [](int a) { return a + 2; };
cout << func1(1) << " " << func2(2) << endl;
```

如上代碼，很多時候lambda表達式返回值是很明顯的，c++11允許省略表達式的返回值定義。

`lambda`表達式允許捕獲一定範圍內的變量：

- `[]`不捕獲任何變量
- `[&]`引用捕獲，捕獲外部作用域所有變量，在函數體內當作引用使用

- `[=]`值捕獲，捕獲外部作用域所有變量，在函數內內有個副本使用
- `[=, &a]`值捕獲外部作用域所有變量，按引用捕獲a變量

- `[a]`只值捕獲a變量，不捕獲其它變量
- `[this]`捕獲當前類中的this指針

lambda表達式示例代碼：

```c++
int a = 0;
auto f1 = [=](){ return a; }; // 值捕獲a
cout << f1() << endl;

auto f2 = [=]() { return a++; }; // 修改按值捕獲的外部變量，error
auto f3 = [=]() mutable { return a++; };
```

代碼中的f2是編譯不過的，因為修改了按值捕獲的外部變量，其實lambda表達式就相當於是一個仿函數，仿函數是一個有`operator()`成員函數的類對象，這個`operator()`默認是`const`的，所以不能修改成員變量，而加了`mutable`，就是去掉`const`屬性。

還可以使用lambda表達式自定義stl的規則，例如自定義sort排序規則：

```c++
struct A {
    int a;
    int b;
};

int main() {
    vector<A> vec;
    std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });
}
```

## 總結

`std::function`和`std::bind`在平時編程過程中封裝函數更加的方便，而lambda表達式將這種方便發揮到了極致，可以在需要的時間就地定義匿名函數，不再需要定義類或者函數等，在自定義STL規則時候也非常方便，讓代碼更簡潔，更靈活，提高開發效率。

# C++11新特性之模板改進

C++11關於模板有一些細節的改進：

- 模板的右尖括號
- 模板的別名

- 函數模板的默認模板參數

### 模板的右尖括號

C++11之前是不允許兩個右尖括號出現的，會被認為是右移操作符，所以需要中間加個空格進行分割，避免發生編譯錯誤。

### 模板的別名

C++11引入了using，可以輕鬆的定義別名，而不是使用繁瑣的typedef。

```c++
int main() {
    std::vector<std::vector<int>> a; // error
    std::vector<std::vector<int> > b; // ok
}
```

使用using明顯簡潔並且易讀，大家可能之前也見過使用typedef定義函數指針之類的操作。

```c++
typedef void (*func)(int, int); 
using func = void (*)(int, int); // 起碼比typedef容易看的懂
```

上面的代碼使用using起碼比typedef容易看的懂一些，但是我還是看不懂，因為我從來不用這種來表示函數指針，用std::function()、std::bind()、std::placeholder()、lambda表達式它不香嗎。

### 函數模板的默認模板參數

C++11之前只有類模板支持默認模板參數，函數模板是不支持默認模板參數的，C++11後都支持。

```c++
template <typename T, typename U=int>
class A {
    T value;  
};

template <typename T=int, typename U> // error
class A {
    T value;  
};
```

類模板的默認模板參數必須從右往左定義，而函數模板則沒有這個限制。

```c++
template <typename R, typename U=int>
R func1(U val) {
   return val;
}

template <typename R=int, typename U>
R func2(U val) {
    return val;
}

int main() {
    cout << func1<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func1<double>(99.9) << endl; // 99.9
    cout << func1<int>(99.9) << endl; // 99
    cout << func2<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func2<double>(99.9) << endl; // 99.9
    cout << func2<int>(99.9) << endl; // 99
    return 0;
}
```

# C++11新特性之線程相關知識點

c++11關於併發引入了好多新東西，這裡按照如下順序介紹：

- std::thread相關
- std::mutex相關

- std::lock相關
- std::atomic相關

- std::call_once相關
- volatile相關

- std::condition_variable相關
- std::future相關

- async相關

## std::thread相關

c++11之前可能使用pthread_xxx來創建線程，繁瑣且不易讀，c++11引入了std::thread來創建線程，支持對線程join或者detach。直接看代碼：

```c++
#include <iostream>
#include <thread>

using namespace std;

int main() {
    auto func = []() {
        for (int i = 0; i < 10; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread t(func);
    if (t.joinable()) {
        t.detach();
    }
    auto func1 = [](int k) {
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread tt(func1, 20);
    if (tt.joinable()) { // 檢查線程可否被join
        tt.join();
    }
    return 0;
}
```

上述代碼中，函數func和func1運行在線程對象t和tt中，從剛創建對象開始就會新建一個線程用於執行函數，調用join函數將會阻塞主線程，直到線程函數執行結束，線程函數的返回值將會被忽略。如果不希望線程被阻塞執行，可以調用線程對象的detach函數，表示將線程和線程對象分離。

如果沒有調用join或者detach函數，假如線程函數執行時間較長，此時線程對象的生命週期結束調用析構函數清理資源，這時可能會發生錯誤，這裡有兩種解決辦法，一個是調用join()，保證線程函數的生命週期和線程對象的生命週期相同，另一個是調用detach()，將線程和線程對象分離，這裡需要注意，如果線程已經和對象分離，那就再也無法控制線程什麼時候結束了，不能再通過join來等待線程執行完。

這裡可以對thread進行封裝，避免沒有調用join或者detach可導致程序出錯的情況出現：

```c++
class ThreadGuard {
    public:
    enum class DesAction { join, detach };

    ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){};

    ~ThreadGuard() {
        if (t_.joinable()) {
            if (action_ == DesAction::join) {
                t_.join();
            } else {
                t_.detach();
            }
        }
    }

    ThreadGuard(ThreadGuard&&) = default;
    ThreadGuard& operator=(ThreadGuard&&) = default;

    std::thread& get() { return t_; }

    private:
    std::thread t_;
    DesAction action_;
};

int main() {
    ThreadGuard t(std::thread([]() {
        for (int i = 0; i < 10; ++i) {
            std::cout << "thread guard " << i << " ";
        }
        std::cout << std::endl;}), ThreadGuard::DesAction::join);
    return 0;
}
```

c++11還提供了獲取線程id，或者系統cpu個數，獲取thread native_handle，使得線程休眠等功能

```c++
std::thread t(func);
cout << "當前線程ID " << t.get_id() << endl;
cout << "當前cpu個數 " << std::thread::hardware_concurrency() << endl;
auto handle = t.native_handle();// handle可用於pthread相關操作
std::this_thread::sleep_for(std::chrono::seconds(1));
```

## std::mutex相關

std::mutex是一種線程同步的手段，用於保存多線程同時操作的共享數據。

mutex分為四種：

- std::mutex：獨佔的互斥量，不能遞歸使用，不帶超時功能
- std::recursive_mutex：遞歸互斥量，可重入，不帶超時功能

- std::timed_mutex：帶超時的互斥量，不能遞歸
- std::recursive_timed_mutex：帶超時的互斥量，可以遞歸使用

拿一個std::mutex和std::timed_mutex舉例，別的都是類似的使用方式：

std::mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>

using namespace std;
std::mutex mutex_;

int main() {
    auto func1 = [](int k) {
        mutex_.lock();
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
        mutex_.unlock();
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

std::timed_mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::timed_mutex timed_mutex_;

int main() {
    auto func1 = [](int k) {
        timed_mutex_.try_lock_for(std::chrono::milliseconds(200));
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
        timed_mutex_.unlock();
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

## std::lock相關

這裡主要介紹兩種RAII方式的鎖封裝，可以動態的釋放鎖資源，防止線程由於編碼失誤導致一直持有鎖。

c++11主要有std::lock_guard和std::unique_lock兩種方式，使用方式都類似，如下：

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::mutex mutex_;

int main() {
    auto func1 = [](int k) {
        // std::lock_guard<std::mutex> lock(mutex_);
        std::unique_lock<std::mutex> lock(mutex_);
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

std::lock_gurad相比於std::unique_lock更加輕量級，少了一些成員函數，std::unique_lock類有unlock函數，可以手動釋放鎖，所以條件變量都配合std::unique_lock使用，而不是std::lock_guard，因為條件變量在wait時需要有手動釋放鎖的能力，具體關於條件變量後面會講到。

## std::atomic相關

c++11提供了原子類型std::atomic<T>，理論上這個T可以是任意類型，但是平時只存放整形，別的還真的沒用過，整形有這種原子變量已經足夠方便，就不需要使用std::mutex來保護該變量啦。看一個計數器的代碼：

```c++
struct OriginCounter { // 普通的計數器
    int count;
    std::mutex mutex_;
    void add() {
        std::lock_guard<std::mutex> lock(mutex_);
        ++count;
    }

    void sub() {
        std::lock_guard<std::mutex> lock(mutex_);
        --count;
    }

    int get() {
        std::lock_guard<std::mutex> lock(mutex_);
        return count;
    }
};

struct NewCounter { // 使用原子變量的計數器
    std::atomic<int> count;
    void add() {
        ++count;
        // count.store(++count);這種方式也可以
    }

    void sub() {
        --count;
        // count.store(--count);
    }

    int get() {
        return count.load();
    }
};
```

是不是使用原子變量更加方便了呢？

## std::call_once相關

c++11提供了std::call_once來保證某一函數在多線程環境中只調用一次，它需要配合std::once_flag使用，直接看使用代碼：

```c++
std::once_flag onceflag;

void CallOnce() {
    std::call_once(onceflag, []() {
        cout << "call once" << endl;
    });
}

int main() {
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(CallOnce);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

## volatile相關

貌似把volatile放在併發裡介紹不太合適，但是貌似很多人都會把volatile和多線程聯繫在一起，一起介紹下。

volatile通常用來建立內存屏障，volatile修飾的變量，編譯器對訪問該變量的代碼通常不再進行優化，看下面代碼：

```c++
int *p = xxx;
int a = *p;
int b = *p;
```

a和b都等於p指向的值，一般編譯器會對此做優化，把*p的值放入寄存器，就是傳說中的工作內存(不是主內存)，之後a和b都等於寄存器的值，但是如果中間p地址的值改變，內存上的值改變啦，但a,b還是從寄存器中取的值(不一定，看編譯器優化結果)，這就不符合需求，所以在此對p加volatile修飾可以避免進行此類優化。

注意：volatile不能解決多線程安全問題，針對特種內存才需要使用volatile，它和atomic的特點如下：• std::atomic用於多線程訪問的數據，且不用互斥量，用於併發編程中• volatile用於讀寫操作不可以被優化掉的內存，用於特種內存中

## std::condition_variable相關

條件變量是c++11引入的一種同步機制，它可以阻塞一個線程或者個線程，直到有線程通知或者超時才會喚醒正在阻塞的線程，條件變量需要和鎖配合使用，這裡的鎖就是上面介紹的std::unique_lock。

這裡使用條件變量實現一個CountDownLatch：

```c++
class CountDownLatch {
    public:
    explicit CountDownLatch(uint32_t count) : count_(count);

    void CountDown() {
        std::unique_lock<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0) {
            cv_.notify_all();
        }
    }

    void Await(uint32_t time_ms = 0) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0) {
            if (time_ms > 0) {
                cv_.wait_for(lock, std::chrono::milliseconds(time_ms));
            } else {
                cv_.wait(lock);
            }
        }
    }

    uint32_t GetCount() const {
        std::unique_lock<std::mutex> lock(mutex_);
        return count_;
    }

    private:
    std::condition_variable cv_;
    mutable std::mutex mutex_;
    uint32_t count_ = 0;
};
```

關於條件變量其實還涉及到通知丟失和虛假喚醒問題，因為不是本文的主題，這裡暫不介紹，大家有需要可以留言。

## std::future相關

c++11關於異步操作提供了future相關的類，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高級些，std::future作為異步結果的傳輸通道，通過get()可以很方便的獲取線程函數的返回值，std::promise用來包裝一個值，將數據和future綁定起來，而std::packaged_task則用來包裝一個調用對象，將函數和future綁定起來，方便異步調用。而std::future是不可以複製的，如果需要複製放到容器中可以使用std::shared_future。

### std::promise與std::future配合使用

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

void func(std::future<int>& fut) {
    int x = fut.get();
    cout << "value: " << x << endl;
}

int main() {
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    std::thread t(func, std::ref(fut));
    prom.set_value(144);
    t.join();
    return 0;
}
```

### std::packaged_task與std::future配合使用

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) {
    return in + 1;
}

int main() {
    std::packaged_task<int(int)> task(func);
    std::future<int> fut = task.get_future();
    std::thread(std::move(task), 5).detach();
    cout << "result " << fut.get() << endl;
    return 0;
}
```

### 三者之間的關係

std::future用於訪問異步操作的結果，而std::promise和std::packaged_task在future高一層，它們內部都有一個future，promise包裝的是一個值，packaged_task包裝的是一個函數，當需要獲取線程中的某個值，可以使用std::promise，當需要獲取線程函數返回值，可以使用std::packaged_task。

## async相關

async是比future，packaged_task，promise更高級的東西，它是基於任務的異步操作，通過async可以直接創建異步的任務，返回的結果會保存在future中，不需要像packaged_task和promise那麼麻煩，關於線程操作應該優先使用async，看一段使用代碼：

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) { return in + 1; }

int main() {
    auto res = std::async(func, 5);
    // res.wait();
    cout << res.get() << endl; // 阻塞直到函數返回
    return 0;
}
```

使用async異步執行函數是不是方便多啦。

async具體語法如下：

```c++
async(std::launch::async | std::launch::deferred, func, args...);
```

第一個參數是創建策略：

- std::launch::async表示任務執行在另一線程
- std::launch::deferred表示延遲執行任務，調用get或者wait時才會執行，不會創建線程，惰性執行在當前線程。

如果不明確指定創建策略，以上兩個都不是async的默認策略，而是未定義，它是一個基於任務的程序設計，內部有一個調度器(線程池)，會根據實際情況決定採用哪種策略。

若從 std::async 獲得的 std::future 未被移動或綁定到引用，則在完整表達式結尾， std::future的析構函數將阻塞直至異步計算完成，實際上相當於同步操作：

```c++
std::async(std::launch::async, []{ f(); }); // 臨時量的析構函數等待 f()
std::async(std::launch::async, []{ g(); }); // f() 完成前不開始
```

注意：關於async啟動策略這裡以cppreference為主。

有時候如果想真正執行異步操作可以對async進行封裝，強制使用std::launch::async策略來調用async。

```c++
template <typename F, typename... Args>
inline auto ReallyAsync(F&& f, Args&&... params) {
    return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...);
}
```

## 總結

• std::thread使線程的創建變得非常簡單，還可以獲取線程id等信息。
• std::mutex通過多種方式保證了線程安全，互斥量可以獨佔，也可以重入，還可以設置互斥量的超時時間，避免一直阻塞等鎖。
• std::lock通過RAII技術方便了加鎖和解鎖調用，有std::lock_guard和std::unique_lock。
• std::atomic提供了原子變量，更方便實現實現保護，不需要使用互斥量
• std::call_once保證函數在多線程環境下只調用一次，可用於實現單例。
• volatile常用於讀寫操作不可以被優化掉的內存中。
• std::condition_variable提供等待的同步機制，可阻塞一個或多個線程，等待其它線程通知後喚醒。
• std::future用於異步調用的包裝和返回值。
• async更方便的實現了異步調用，異步調用優先使用async取代創建線程。

# C++11 的異步操作-async

C++11中增加了async，如它的名字一樣，這個關鍵字就是用來創建異步操作的，c++11中有個更常用的異步操作，叫做線程thread，那麼thread和async有什麼區別呢？以及async的優勢是什麼？應該怎麼使用？

### C++11 使用 std::async創建異步程序

C++11中增加了線程，可以非常方便的創建線程，它的基本用法是這樣的：

```c++
void f(int n);
std::thread t(f, n + 1);
t.join();
```

但是線程畢竟是屬於比較低層次的東西，有時候使用有些不便，比如希望獲取線程函數的返回結果的時候，就不能直接通過 `thread.join()`得到結果，這時就必須定義一個變量，在線程函數中去給這個變量賦值，然後join，最後得到結果，這個過程是比較繁瑣的。

c++11還提供了異步接口`std::async`，通過這個異步接口可以很方便的獲取線程函數的執行結果。`std::async`會自動創建一個線程去調用線程函數，它返回一個`std::future`，這個future中存儲了線程函數返回的結果，當需要線程函數的結果時，直接從future中獲取，非常方便。

其實std::async提供的便利可不僅僅是這一點，它首先解耦了線程的創建和執行，可以在需要的時候獲取異步操作的結果；其次它還提供了線程的創建策略（比如可以通過延遲加載的方式去創建線程），可以以多種方式去創建線程。在介紹`async`具體用法以及為什麼要用`std::async`代替線程的創建之前，先看看`std::future`、`std::promise`和 `std::packaged_task`。

### std::future

std::future是一個非常有用也很有意思的東西，簡單說std::future提供了一種訪問異步操作結果的機制。從字面意思來理解， 它表示未來，因為一個異步操作是不可能馬上就獲取操作結果的，只能在未來某個時候獲取，但是可以以同步等待的方式來獲取結果，可以通過查詢future的狀態（future_status）來獲取異步操作的結果。future_status有三種狀態：

- deferred：異步操作還沒開始
- ready：異步操作已經完成

- timeout：異步操作超時

```c++
//查詢future的狀態
std::future_status status;
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred\n";
    } else if (status == std::future_status::timeout) {
        std::cout << "timeout\n";
    } else if (status == std::future_status::ready) {
        std::cout << "ready!\n";
} while (status != std::future_status::ready);
```

獲取future結果有三種方式：get、wait、wait_for，其中get等待異步操作結束並返回結果，`wait`只是等待異步操作完成，沒有返回值，`wait_for`是超時等待返回結果。

### std::promise

std::promise為獲取線程函數中的某個值提供便利，在線程函數中給外面傳進來的promise賦值，當線程函數執行完成之後就可以通過promis獲取該值了，值得注意的是取值是間接的通過promise內部提供的future來獲取的。它的基本用法：

```c++
std::promise<int> pr;
std::thread t([](std::promise<int>& p){
    p.set_value_at_thread_exit(9);
},std::ref(pr));
std::future<int> f = pr.get_future();
auto r = f.get();
```

### std::packaged_task

std::packaged_task它包裝了一個可調用的目標（如function, lambda expression, bind expression, or another function object）,以便異步調用，它和promise在某種程度上有點像，promise保存了一個共享狀態的值，而`packaged_task`保存的是一 個函數。它的基本用法：

```c++
std::packaged_task<int()> task([](){ return 7; });
std::thread t1(std::ref(task)); 
std::future<int> f1 = task.get_future(); 
auto r1 = f1.get();
```

### std::promise、std::packaged_task和std::future的關係

看了`std::async`相關的幾個對象`std::future`、`std::promise`和`std::packaged_task`，其中 `std::promise`和`std::packaged_task`的結果最終都是通過其內部的future返回出來的，看看他們之間的關係到底是怎樣的，`std::future`提供了一個訪問異步操作結果的機制，它和線程是一個級別的屬於低層次的對象，在它之上高一層的是`std::packaged_task`和`std::promise`，他們內部都有future以便訪問異步操作結果，`std::packaged_task`包裝的是一個異步操作，而`std::promise`包裝的是一個值，都是為了方便異步操作的，因為有時需要獲取線程中的某個值，這時就用`std::promise`，而有時需要獲一個異步操作的返回值，這時就用`std::packaged_task`。

那 `std::promise`和`std::packaged_task`之間又是什麼關係呢？說他們沒關係也沒關係，說他們有關係也有關係，都取決於如何使用他們了，可以將一個異步操作的結果保存到`std::promise`中。

### 為什麼要用`std::async`代替線程的創建

`std::async`是為了讓開發者的少費點腦子的，它讓這三個對象默契的工作。大概的工作過程是這樣的：`std::async`先將異步操作用`std::packaged_task`包 裝起來，然後將異步操作的結果放到`std::promise`中，這個過程就是創造未來的過程。外面再通過`future.get/wait`來獲取這個未來的結果！

現在來看看`std::async`的原型

`async(std::launch::async | std::launch::deferred, f, args...)` 第一個參數是線程的創建策略，有兩種策略，默認的策略是立即創建線程：

`std::launch::async`：在調用async就開始創建線程。

`std::launch::deferred`：延遲加載方式創建線程。調用async時不創建線程，直到調用了`future`的`get`或者`wait`時才創建線程。

第二個參數是線程函數，第三個參數是線程函數的參數。

### `std::async`基本用法

```c++
std::future<int> f1 = std::async(std::launch::async, []() {
    return 8;
    });
cout << f1.get() << endl; //output: 8
std::future<void> f2 = std::async(std::launch::async, []() {
    cout << 8 << endl;
    //return 8;
    });
f2.wait(); //output: 8
std::future<int> future = std::async(std::launch::async, []() {
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 8;
    });
std::cout << "waiting...\n";
//Test12();
std::future_status status;
Sleep(3000);
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred\n";
    }
    else if (status == std::future_status::timeout) {
        std::cout << "timeout\n";
    }
    else if (status == std::future_status::ready) {
        std::cout << "ready!\n";
    }
} while (status != std::future_status::ready);
std::cout << "result is " << future.get() << '\n';
```

可能的結果：waiting... timeout timeout ready! result is 8

### 總結

`std::async`是更高層次上的異步操作，它的存在可以使開發者不用關注線程創建內部細節，就能方便的獲取異步執行狀態和結果，還可以指定線程創建策略，應該用`std::async`替代線程的創建，讓它成為做異步操作的首選。

# C++11新特性之智能指針

c++11引入了三種智能指針：

- std::shared_ptr
- std::weak_ptr

- std::unique_ptr

## shared_ptr

shared_ptr使用了引用計數，每一個shared_ptr的拷貝都指向相同的內存，每次拷貝都會觸發引用計數+1，每次生命週期結束析構的時候引用計數-1，在最後一個shared_ptr析構的時候，內存才會釋放。

使用方法如下：

```c++
struct ClassWrapper {
    ClassWrapper() {
        cout << "construct" << endl;
        data = new int[10];
    }
    ~ClassWrapper() {
        cout << "deconstruct" << endl;
        if (data != nullptr) {
            delete[] data;
        }
    }
    void Print() {
        cout << "print" << endl;
    }
    int* data;
};

void Func(std::shared_ptr<ClassWrapper> ptr) {
    ptr->Print();
}

int main() {
    auto smart_ptr = std::make_shared<ClassWrapper>();
    auto ptr2 = smart_ptr; // 引用計數+1
    ptr2->Print();
    Func(smart_ptr); // 引用計數+1
    smart_ptr->Print();
    ClassWrapper *p = smart_ptr.get(); // 可以通過get獲取裸指針
    p->Print();
    return 0;
}
```

智能指針還可以自定義刪除器，在引用計數為0的時候自動調用刪除器來釋放對象的內存，代碼如下：

```c++
std::shared_ptr<int> ptr(new int, [](int *p){ delete p; });
```

關於shared_ptr有幾點需要注意：

• 不要用一個裸指針初始化多個shared_ptr，會出現double_free導致程序崩潰

• 通過shared_from_this()返回this指針，不要把this指針作為shared_ptr返回出來，因為this指針本質就是裸指針，通過this返回可能 會導致重複析構，不能把this指針交給智能指針管理。

```c++
class A {
    shared_ptr<A> GetSelf() {
        return shared_from_this();
        // return shared_ptr<A>(this); 錯誤，會導致double free
    }  
};
```

- 儘量使用make_shared，少用new。
- 不要delete get()返回來的裸指針。

- 不是new出來的空間要自定義刪除器。
- 要避免循環引用，循環引用導致內存永遠不會被釋放，造成內存洩漏。

```c++
using namespace std;
struct A;
struct B;

struct A {
    std::shared_ptr<B> bptr;
    ~A() {
        cout << "A delete" << endl;
    }
};

struct B {
    std::shared_ptr<A> aptr;
    ~B() {
        cout << "B delete" << endl;
    }
};

int main() {
    auto aaptr = std::make_shared<A>();
    auto bbptr = std::make_shared<B>();
    aaptr->bptr = bbptr;
    bbptr->aptr = aaptr;
    return 0;
}
```

上面代碼，產生了循環引用，導致aptr和bptr的引用計數為2，離開作用域後aptr和bptr的引用計數-1，但是永遠不會為0，導致指針永遠不會析構，產生了內存洩漏，如何解決這種問題呢，答案是使用weak_ptr。

## weak_ptr

weak_ptr是用來監視shared_ptr的生命週期，它不管理shared_ptr內部的指針，它的拷貝的析構都不會影響引用計數，純粹是作為一個旁觀者監視shared_ptr中管理的資源是否存在，可以用來返回this指針和解決循環引用問題。

- 作用1：返回this指針，上面介紹的shared_from_this()其實就是通過weak_ptr返回的this指針。
- 作用2：解決循環引用問題。

```c++
struct A;
struct B;

struct A {
    std::shared_ptr<B> bptr;
    ~A() {
        cout << "A delete" << endl;
    }
    void Print() {
        cout << "A" << endl;
    }
};

struct B {
    std::weak_ptr<A> aptr; // 這裡改成weak_ptr
    ~B() {
        cout << "B delete" << endl;
    }
    void PrintA() {
        if (!aptr.expired()) { // 監視shared_ptr的生命週期
            auto ptr = aptr.lock();
            ptr->Print();
        }
    }
};

int main() {
    auto aaptr = std::make_shared<A>();
    auto bbptr = std::make_shared<B>();
    aaptr->bptr = bbptr;
    bbptr->aptr = aaptr;
    bbptr->PrintA();
    return 0;
}
```

輸出：

```c++
A
A delete
B delete
```

## unique_ptr

std::unique_ptr是一個獨佔型的智能指針，它不允許其它智能指針共享其內部指針，也不允許unique_ptr的拷貝和賦值。使用方法和shared_ptr類似，區別是不可以拷貝：

```c++
using namespace std;

struct A {
    ~A() {
        cout << "A delete" << endl;
    }
    void Print() {
        cout << "A" << endl;
    }
};


int main() {
    auto ptr = std::unique_ptr<A>(new A);
    auto tptr = std::make_unique<A>(); // error, c++11還不行，需要c++14
    std::unique_ptr<A> tem = ptr; // error, unique_ptr不允許移動
    ptr->Print();
    return 0;
}
```

