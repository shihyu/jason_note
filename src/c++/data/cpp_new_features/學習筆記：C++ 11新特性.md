# C++11新特性之auto和decltype知識點

C++11引入了auto和decltype關鍵字，使用它們可以在編譯期就推導出變數或者表達式的型別，方便開發者編碼的同時也簡化了程式碼。

## auto

auto可以讓編譯器在編譯器就推導出變數的型別，看程式碼：

```c++
auto a = 10; // 10是int型，可以自動推導出a是int
int i = 10;auto b = i; // b是int型
auto d = 2.0; // d是double型
```

這就是auto的基本用法，可以通過=右邊的型別推導出變數的型別。

### auto推導規則

直接看程式碼

程式碼1：

```c++
int i = 10;
auto a = i, &b = i, *c = &i; // a是int，b是i的參照，c是i的指標，auto就相當於int
auto d = 0, f = 1.0; // error，0和1.0型別不同，對於編譯器有二義性，沒法推導
auto e; // error，使用auto必須馬上初始化，否則無法推導型別
```

程式碼2：

```c++
void func(auto value) {} // error，auto不能用作函式參數

class A {
    auto a = 1; // error，在類中auto不能用作非靜態成員變數
    static auto b = 1; // error，這裡與auto無關，正常static int b = 1也不可以
    static const auto int c = 1; // ok
};

void func2() {
    int a[10] = {0};
    auto b = a; // ok
    auto c[10] = a; // error，auto不能定義陣列，可以定義指標
    vector<int> d;
    vector<auto> f = d; // error，auto無法推導出樣板參數
}
```

auto的限制：

- auto的使用必須馬上初始化，否則無法推導出型別
- auto在一行定義多個變數時，各個變數的推導不能產生二義性，否則編譯失敗

- auto不能用作函式參數
- 在類中auto不能用作非靜態成員變數

- auto不能定義陣列，可以定義指標
- auto無法推導出樣板參數

再看這段程式碼：

```c++
int i = 0;
auto *a = &i; // a是int*
auto &b = i; // b是int&
auto c = b; // c是int，忽略了參照

const auto d = i; // d是const int
auto e = d; // e是int

const auto& f = e; // f是const int&
auto &g = f; // g是const int&
```

首先，介紹下，這裡的cv是指const 和volatile

推導規則

- 在不聲明為參照或指標時，auto會忽略等號右邊的參照型別和cv限定
- 在聲明為參照或者指標時，auto會保留等號右邊的參照和cv屬性

### 什麼時候使用auto？

這裡沒有絕對答案，在不影響程式碼程式碼可讀性的前提下儘可能使用auto是蠻好的，複雜型別就使用auto，int、double這種就沒有必要使用auto了，看下面這段程式碼：

```c++
auto func = [&] {
    cout << "xxx";
}; // 對於func難道不使用auto嗎，反正是不關心lambda表達式究竟是什麼型別。

auto asyncfunc = std::async(std::launch::async, func);
// 對於asyncfunc難道不使用auto嗎，懶得寫std::futurexxx等程式碼，而且也記不住它返回的究竟是什麼...
```

## decltype

上面介紹auto用於推導變數型別，而decltype則用於推導表達式型別，這裡只用於編譯器分析表達式的型別，表達式實際不會進行運算，上程式碼：

```c++
int func() { return 0; }
decltype(func()) i; // i為int型別

int x = 0;
decltype(x) y; // y是int型別
decltype(x + y) z; // z是int型別
```

注意：decltype不會像auto一樣忽略參照和cv屬性，decltype會保留表達式的參照和cv屬性

```c++
cont int &i = 1;
int a = 2;
decltype(i) b = 2; // b是const int&
```

### decltype推導規則

對於decltype(exp)有

- exp是表達式，decltype(exp)和exp型別相同
- exp是函式調用，decltype(exp)和函式回傳值型別相同

- 其它情況，若exp是左值，decltype(exp)是exp型別的左值參照

```c++
int a = 0, b = 0;
decltype(a + b) c = 0; // c是int，因為(a+b)返回一個右值
decltype(a += b) d = c;// d是int&，因為(a+=b)返回一個左值

d = 20;
cout << "c " << c << endl; // 輸出c 20
```

## auto和decltype的配合使用

auto和decltype一般配合使用在推導函式回傳值的型別問題上。

下面這段程式碼

```c++
template<typename T, typename U>
return_value add(T t, U u) { // t和v型別不確定，無法推導出return_value型別
    return t + u;
}
```

上面程式碼由於t和u型別不確定，那如何推導出回傳值型別呢，可能會想到這種

```c++
template<typename T, typename U>
decltype(t + u) add(T t, U u) { // t和u尚未定義
    return t + u;
}
```

這段程式碼在C++11上是編譯不過的，因為在decltype(t +u)推導時，t和u尚未定義，就會編譯出錯，所以有了下面的叫做返回型別後置的配合使用方法：

```c++
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

回傳值後置型別語法就是為了解決函式回傳值型別依賴於參數但卻難以確定回傳值型別的問題。

# C++11新特性之左值參照、右值參照、移動語意、完美轉送

C++11新增了右值參照，談右值參照也可以擴展一些相關概念：

- 左值
- 右值

- 純右值
- 將亡值

- 左值參照
- 右值參照

- 移動語意
- 完美轉送

- 回傳值最佳化

### 左值、右值

概念1：

左值：可以放到等號左邊的東西叫左值。

右值：不可以放到等號左邊的東西就叫右值。

概念2：

左值：可以取地址並且有名字的東西就是左值。

右值：不能取地址的沒有名字的東西就是右值。

舉例：

```c++
int a = b + c;
```

a是左值，有變數名，可以取地址，也可以放到等號左邊, 表達式b+c的回傳值是右值，沒有名字且不能取地址，&(b+c)不能通過編譯，而且也不能放到等號左邊。

```c++
int a = 4; // a是左值，4作為普通字面量是右值
```

左值一般有：

- 函式名和變數名
- 返回左值參照的函式調用

- 前置自增自減表達式++i、--i
- 由賦值表達式或賦值運算子連接的表達式(a=b, a += b等)

- 解參照表達式*p
- 字串字面值"abcd"

### 純右值、將亡值

純右值和將亡值都屬於右值。

#### 純右值

運算表達式產生的臨時變數、不和物件關聯的原始字面量、非參照返回的臨時變數、lambda表達式等都是純右值。

舉例：

- 除字串字面值外的字面值
- 返回非參照型別的函式調用

- 後置自增自減表達式i++、i--
- 算術表達式(a+b, a*b, a&&b, a==b等)

- 取地址表達式等(&a)

#### 將亡值

將亡值是指C++11新增的和右值參照相關的表達式，通常指將要被移動的物件、T&&函式的回傳值、std::move函式的回傳值、轉換為T&&型別轉換函式的回傳值，將亡值可以理解為即將要銷燬的值，通過“盜取”其它變數記憶體空間方式獲取的值，在確保其它變數不再被使用或者即將被銷燬時，可以避免記憶體空間的釋放和分配，延長變數值的生命週期，常用來完成移動建構或者移動賦值的特殊任務。

舉例：

```c++
class A {
    xxx;
};
A a;
auto c = std::move(a); // c是將亡值
auto d = static_cast<A&&>(a); // d是將亡值
```

#### 左值參照、右值參照

根據名字大概就可以猜到意思，左值參照就是對左值進行參照的型別，右值參照就是對右值進行參照的型別，他們都是參照，都是物件的一個別名，並不擁有所綁定物件的堆存，所以都必須立即初始化。

```c++
type &name = exp; // 左值參照
type &&name = exp; // 右值參照
```

左值參照

看程式碼：

```c++
int a = 5;
int &b = a; // b是左值參照
b = 4;
int &c = 10; // error，10無法取地址，無法進行參照
const int &d = 10; // ok，因為是常參照，參照常數數字，這個常數數字會存儲在記憶體中，可以取地址
```

可以得出結論：對於左值參照，等號右邊的值必須可以取地址，如果不能取地址，則會編譯失敗，或者可以使用const參照形式，但這樣就只能通過參照來讀取輸出，不能修改陣列，因為是常數參照。

右值參照

如果使用右值參照，那表達式等號右邊的值需要時右值，可以使用std::move函式強制把左值轉換為右值。

```c++
int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok
```

### 移動語意

談移動語意前，首先需要了解深複製與淺複製的概念

#### 深複製、淺複製

直接拿程式碼舉例:

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = a.data_;
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

上面程式碼中，兩個輸出的是相同的地址，a和b的data_指標指向了同一塊記憶體，這就是淺複製，只是數據的簡單賦值，那再解構時data_記憶體會被釋放兩次，導致程式出問題，這裡正常會出現double free導致程式崩潰的，這樣的程式肯定是有隱患的，如何消除這種隱患呢，可以使用如下深複製：

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

深複製就是再複製物件時，如果被複製物件內部還有指標參照指向其它資源，自己需要重新開闢一塊新記憶體存儲資源，而不是簡單的賦值。

移動語意可以理解為轉移所有權，之前的複製是對於別人的資源，自己重新分配一塊記憶體存儲複製過來的資源，而對於移動語意，類似於轉讓或者資源竊取的意思，對於那塊資源，轉為自己所擁有，別人不再擁有也不會再使用，通過C++11新增的移動語意可以省去很多複製負擔，怎麼利用移動語意呢，是通過移動建構函式。

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    A(A&& a) {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "move " << endl;
    }
    ~A() {
        if (data_ != nullptr) {
         delete[] data_;
        }
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    A c = std::move(a); // 調用移動建構函式
    return 0;
}
```

如果不使用std::move()，會有很大的複製代價，使用移動語意可以避免很多無用的複製，提供程式性能，C++所有的STL都實現了移動語意，方便使用。例如：

```c++
std::vector<string> vecs;
...
std::vector<string> vecm = std::move(vecs); // 免去很多複製
```

注意：移動語意僅針對於那些實現了移動建構函式的類的物件，對於那種基本型別int、float等沒有任何最佳化作用，還是會複製，因為它們實現沒有對應的移動建構函式。

### 完美轉送

完美轉送指可以寫一個接受任意實際參數的函式樣板，並轉發到其它函式，目標函式會收到與轉發函式完全相同的實際參數，轉發函式實際參數是左值那目標函式實際參數也是左值，轉發函式實際參數是右值那目標函式實際參數也是右值。那如何實現完美轉送呢，答案是使用std::forward()。

```c++
void PrintV(int &t) {
    cout << "lvalue" << endl;
}

void PrintV(int &&t) {
    cout << "rvalue" << endl;
}

template<typename T>
void Test(T &&t) {
    PrintV(t);
    PrintV(std::forward<T>(t));

    PrintV(std::move(t));
}

int main() {
    Test(1); // lvalue rvalue rvalue
    int a = 1;
    Test(a); // lvalue lvalue rvalue
    Test(std::forward<int>(a)); // lvalue rvalue rvalue
    Test(std::forward<int&>(a)); // lvalue lvalue rvalue
    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    return 0;
}
```

分析

- Test(1)：1是右值，樣板中T &&t這種為萬能參照，右值1傳到Test函式中變成了右值參照，但是調用PrintV()時候，t變成了左值，因為它變成了一個擁有名字的變數，所以印出lvalue，而PrintV(std::forward<T>(t))時候，會進行完美轉送，按照原來的型別轉發，所以印出rvalue，PrintV(std::move(t))毫無疑問會印出rvalue。
- Test(a)：a是左值，樣板中T &&這種為萬能參照，左值a傳到Test函式中變成了左值參照，所以有程式碼中印出。

- Test(std::forward<T>(a))：轉發為左值還是右值，依賴於T，T是左值那就轉發為左值，T是右值那就轉發為右值。

### 回傳值最佳化

回傳值最佳化(RVO)是一種C++編譯最佳化技術，當函式需要返回一個物件實體時候，就會創建一個臨時物件並通過複製建構函式將目標物件複製到臨時物件，這裡有複製建構函式和解構函式會被多餘的調用到，有代價，而通過回傳值最佳化，C++標準允許省略調用這些複製建構函式。

那什麼時候編譯器會進行回傳值最佳化呢?

- return的值型別與函式的回傳值型別相同
- return的是一個局部物件

看幾個例子:

示例1：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}
std::vector<int> &&rval_ref = return_vector();
```

不會觸發RVO，複製建構了一個臨時的物件，臨時物件的生命週期和rval_ref綁定，等價於下面這段程式碼：

```c++
const std::vector<int>& rval_ref = return_vector();
```

示例2：

```c++
std::vector<int>&& return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

這段程式碼會造成運行時錯誤，因為rval_ref參照了被解構的tmp。講道理來說這段程式碼是錯的，自己運行過程中卻成功了，繼續向下看什麼時候會觸發RVO。

示例3：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

和示例1類似，std::move一個臨時物件是沒有必要的，也會忽略掉回傳值最佳化。

最好的程式碼：

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}

std::vector<int> rval_ref = return_vector();
```

這段程式碼會觸發RVO，不複製也不移動，不生成臨時物件。

# C++11新特性之列表初始化

C++11新增了列表初始化的概念。

在C++11中可以直接在變數名後面加上初始化列表來進行物件的初始化。

```c++
struct A {
    public:
    A(int) {}
    private:
    A(const A&) {}
};
int main() {
    A a(123);
    A b = 123; // error
    A c = { 123 };
    A d{123}; // c++11

    int e = {123};
    int f{123}; // c++11

    return 0;
}
```

列表初始化也可以用在函式的回傳值上

```c++
std::vector<int> func() {
    return {};
}
```

### 列表初始化的一些規則

首先說下聚合型別可以進行直接列表初始化，這裡需要了解什麼是聚合型別：

1. 型別是一個普通陣列，如int[5]，char[]，double[]等
2. 型別是一個類，且滿足以下條件：

- - 沒有用戶聲明的建構函式
  - 沒有用戶提供的建構函式(允許顯示預置或棄置的建構函式)

- - 沒有私有或保護的非靜態數據成員
  - 沒有基類

- - 沒有虛擬函式
  - 沒有{}和=直接初始化的非靜態數據成員

- - 沒有預設成員初始化器

```c++
struct A {
    int a;
    int b;
    int c;
    A(int, int){}
};
int main() {
    A a{1, 2, 3};// error，A有自定義的建構函式，不能列表初始化
}
```

上述程式碼類A不是聚合型別，無法進行列表初始化，必須以自定義的建構函式來建構物件。

```c++
struct A {
    int a;
    int b;
    virtual void func() {} // 含有虛擬函式，不是聚合類
};

struct Base {};
struct B : public Base { // 有基類，不是聚合類
    int a;
    int b;
};

struct C {
    int a;
    int b = 10; // 有等號初始化，不是聚合類
};

struct D {
    int a;
    int b;
    private:
    int c; // 含有私有的非靜態數據成員，不是聚合類
};

struct E {
    int a;
    int b;
    E() : a(0), b(0) {} // 含有預設成員初始化器，不是聚合類
};
```

上面列舉了一些不是聚合類的例子，對於一個聚合型別，使用列表初始化相當於對其中的每個元素分別賦值；對於非聚合型別，需要先自定義一個對應的建構函式，此時列表初始化將調用相應的建構函式。

### std::initializer_list

平時開發使用STL過程中可能發現它的初始化列表可以是任意長度，大家有沒有想過它是怎麼實現的呢，答案是std::initializer_list，看下面這段示例程式碼：

```c++
struct CustomVec {
    std::vector<int> data;
    CustomVec(std::initializer_list<int> list) {
        for (auto iter = list.begin(); iter != list.end(); ++iter) {
            data.push_back(*iter);
        }
    }
};
```

這個std::initializer_list其實也可以作為函式參數。

注意：std::initializer_list<T>，它可以接收任意長度的初始化列表，但是裡面必須是相同型別T，或者都可以轉換為T。

### 列表初始化的好處

列表初始化的好處如下：

1. 方便，且基本上可以替代括號初始化
2. 可以使用初始化列表接受任意長度

1. 可以防止型別窄化，避免精度丟失的隱式型別轉換

什麼是型別窄化，列表初始化通過禁止下列轉換，對隱式轉化加以限制：

- 從浮點型別到整數型別的轉換
- 從 long double 到 double 或 float 的轉換，以及從 double 到 float 的轉換，除非源是常數表達式且不發生溢出

- 從整數型別到浮點型別的轉換，除非源是其值能完全存儲於目標型別的常數表達式
- 從整數或無作用域列舉型別到不能表示原型別所有值的整數型別的轉換，除非源是其值能完全存儲於目標型別的常數表達式

示例：

```c++
int main() {
    int a = 1.2; // ok
    int b = {1.2}; // error

    float c = 1e70; // ok
    float d = {1e70}; // error

    float e = (unsigned long long)-1; // ok
    float f = {(unsigned long long)-1}; // error
    float g = (unsigned long long)1; // ok
    float h = {(unsigned long long)1}; // ok

    const int i = 1000;
    const int j = 2;
    char k = i; // ok
    char l = {i}; // error

    char m = j; // ok
    char m = {j}; // ok，因為是const型別，這裡如果去掉const屬性，也會報錯
}
```

印出如下：

```c++
test.cc:24:17: error: narrowing conversion of ‘1.2e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
    int b = {1.2};
                ^
test.cc:27:20: error: narrowing conversion of ‘1.0000000000000001e+70’ from ‘double’ to ‘float’ inside { } [-Wnarrowing]
     float d = {1e70};

test.cc:30:38: error: narrowing conversion of ‘18446744073709551615’ from ‘long long unsigned int’ to ‘float’ inside { } [-Wnarrowing]
    float f = {(unsigned long long)-1};
                                     ^
test.cc:36:14: warning: overflow in implicit constant conversion [-Woverflow]
    char k = i;
             ^
test.cc:37:16: error: narrowing conversion of ‘1000’ from ‘int’ to ‘char’ inside { } [-Wnarrowing]
    char l = {i};
```

# C++11新特性std::function和lambda表達式

c++11新增了`std::function`、`std::bind`、`lambda`表達式等封裝使函式調用更加方便。

## `std::function`

講`std::function`前首先需要了解下什麼是可調用物件

滿足以下條件之一就可稱為可調用物件：

- 是一個函式指標
- 是一個具有`operator()`成員函式的類物件(傳說中的仿函式)，lambda表達式

- 是一個可被轉換為函式指標的類物件
- 是一個類成員(函式)指標

- bind表達式或其它函式物件

而`std::function`就是上面這種可調用物件的封裝器，可以把`std::function`看做一個函式物件，用於表示函式這個抽象概念。`std::function`的實體可以存儲、複製和調用任何可調用物件，存儲的可調用物件稱為`std::function`的目標，若`std::function`不含目標，則稱它為空，調用空的`std::function`的目標會拋出`std::bad_function_call`異常。

使用參考如下實體程式碼：

```c++
std::function<void(int)> f; // 這裡表示function的物件f的參數是int，回傳值是void
#include <functional>
#include <iostream>

struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_ + i << '\n'; }
    int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
    void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
    // 存儲自由函式
    std::function<void(int)> f_display = print_num;
    f_display(-9);

    // 存儲 lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();

    // 存儲到 std::bind 調用的結果
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();

    // 存儲到成員函式的調用
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
    const Foo foo(314159);
    f_add_display(foo, 1);
    f_add_display(314159, 1);

    // 存儲到數據成員訪問器的調用
    std::function<int(Foo const&)> f_num = &Foo::num_;
    std::cout << "num_: " << f_num(foo) << '\n';

    // 存儲到成員函式及物件的調用
    using std::placeholders::_1;
    std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);
    f_add_display2(2);

    // 存儲到成員函式和物件指標的調用
    std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);
    f_add_display3(3);

    // 存儲到函式物件的調用
    std::function<void(int)> f_display_obj = PrintNum();
    f_display_obj(18);
}
```

從上面可以看到`std::function`的使用方法，當給`std::function`填入合適的參數表和回傳值後，它就變成了可以容納所有這一類調用方式的函式封裝器。`std::function`還可以用作回呼函式，或者在C++裡如果需要使用回呼那就一定要使用`std::function`，特別方便。

## `std::bind`

使用`std::bind`可以將可調用物件和參數一起綁定，綁定後的結果使用`std::function`進行保存，並延遲調用到任何需要的時候。

`std::bind`通常有兩大作用：

- 將可調用物件與參數一起綁定為另一個`std::function`供調用
- 將n元可調用物件轉成m(m < n)元可調用物件，綁定一部分參數，這裡需要使用`std::placeholders`

具體示例：

```c++
#include <functional>
#include <iostream>
#include <memory>

void f(int n1, int n2, int n3, const int& n4, int n5) {
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << std::endl;
}

int g(int n1) { return n1; }

struct Foo {
    void print_sum(int n1, int n2) { std::cout << n1 + n2 << std::endl; }
    int data = 10;
};

int main() {
    using namespace std::placeholders;  // 針對 _1, _2, _3...

    // 演示參數重排序和按參照傳遞
    int n = 7;
    // （ _1 與 _2 來自 std::placeholders ，並表示將來會傳遞給 f1 的參數）
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001);  // 1 為 _1 所綁定， 2 為 _2 所綁定，不使用 1001
    // 進行到 f(2, 42, 1, n, 7) 的調用

    // 嵌套 bind 子表達式共享佔位元元符
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12);  // 進行到 f(12, g(12), 12, 4, 5); 的調用

    // 綁定指向成員函式指標
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);

    // 綁定指向數據成員指標
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << std::endl;

    // 智慧指標亦能用於調用被參照物件的成員
    std::cout << f4(std::make_shared<Foo>(foo)) << std::endl;
}
```

## `lambda`表達式

lambda表達式可以說是c++11參照的最重要的特性之一，它定義了一個匿名函式，可以捕獲一定範圍的變數在函式內部使用，一般有如下語法形式：

```c++
auto func = [capture] (params) opt -> ret { func_body; };
```

其中`func`是可以當作`lambda`表達式的名字，作為一個函式使用，`capture`是捕獲列表，`params`是參數表，`opt`是函式選項(mutable之類)， ret是回傳值型別，func_body是函式體。

一個完整的lambda表達式：

```c++
auto func1 = [](int a) -> int { return a + 1; };
auto func2 = [](int a) { return a + 2; };
cout << func1(1) << " " << func2(2) << endl;
```

如上程式碼，很多時候lambda表達式回傳值是很明顯的，c++11允許省略表達式的回傳值定義。

`lambda`表達式允許捕獲一定範圍內的變數：

- `[]`不捕獲任何變數
- `[&]`參照捕獲，捕獲外部作用域所有變數，在函式體內當作參照使用

- `[=]`值捕獲，捕獲外部作用域所有變數，在函式內內有個副本使用
- `[=, &a]`值捕獲外部作用域所有變數，按參照捕獲a變數

- `[a]`只值捕獲a變數，不捕獲其它變數
- `[this]`捕獲當前類中的this指標

lambda表達式示例程式碼：

```c++
int a = 0;
auto f1 = [=](){ return a; }; // 值捕獲a
cout << f1() << endl;

auto f2 = [=]() { return a++; }; // 修改按值捕獲的外部變數，error
auto f3 = [=]() mutable { return a++; };
```

程式碼中的f2是編譯不過的，因為修改了按值捕獲的外部變數，其實lambda表達式就相當於是一個仿函式，仿函式是一個有`operator()`成員函式的類物件，這個`operator()`預設是`const`的，所以不能修改成員變數，而加了`mutable`，就是去掉`const`屬性。

還可以使用lambda表達式自定義stl的規則，例如自定義sort排序規則：

```c++
struct A {
    int a;
    int b;
};

int main() {
    vector<A> vec;
    std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });
}
```

## 總結

`std::function`和`std::bind`在平時編程過程中封裝函式更加的方便，而lambda表達式將這種方便發揮到了極致，可以在需要的時間就地定義匿名函式，不再需要定義類或者函式等，在自定義STL規則時候也非常方便，讓程式碼更簡潔，更靈活，提高開發效率。

# C++11新特性之樣板改進

C++11關於樣板有一些細節的改進：

- 樣板的右尖括號
- 樣板的別名

- 函式樣板的預設樣板參數

### 樣板的右尖括號

C++11之前是不允許兩個右尖括號出現的，會被認為是右移操作符，所以需要中間加個空格進行分割，避免發生編譯錯誤。

### 樣板的別名

C++11引入了using，可以輕鬆的定義別名，而不是使用繁瑣的typedef。

```c++
int main() {
    std::vector<std::vector<int>> a; // error
    std::vector<std::vector<int> > b; // ok
}
```

使用using明顯簡潔並且易讀，大家可能之前也見過使用typedef定義函式指標之類的操作。

```c++
typedef void (*func)(int, int); 
using func = void (*)(int, int); // 起碼比typedef容易看的懂
```

上面的程式碼使用using起碼比typedef容易看的懂一些，但是我還是看不懂，因為我從來不用這種來表示函式指標，用std::function()、std::bind()、std::placeholder()、lambda表達式它不香嗎。

### 函式樣板的預設樣板參數

C++11之前只有類樣板支援預設樣板參數，函式樣板是不支援預設樣板參數的，C++11後都支援。

```c++
template <typename T, typename U=int>
class A {
    T value;  
};

template <typename T=int, typename U> // error
class A {
    T value;  
};
```

類樣板的預設樣板參數必須從右往左定義，而函式樣板則沒有這個限制。

```c++
template <typename R, typename U=int>
R func1(U val) {
   return val;
}

template <typename R=int, typename U>
R func2(U val) {
    return val;
}

int main() {
    cout << func1<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func1<double>(99.9) << endl; // 99.9
    cout << func1<int>(99.9) << endl; // 99
    cout << func2<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func2<double>(99.9) << endl; // 99.9
    cout << func2<int>(99.9) << endl; // 99
    return 0;
}
```

# C++11新特性之執行緒相關知識點

c++11關於併發引入了好多新東西，這裡按照如下順序介紹：

- std::thread相關
- std::mutex相關

- std::lock相關
- std::atomic相關

- std::call_once相關
- volatile相關

- std::condition_variable相關
- std::future相關

- async相關

## std::thread相關

c++11之前可能使用pthread_xxx來創建執行緒，繁瑣且不易讀，c++11引入了std::thread來創建執行緒，支援對執行緒join或者detach。直接看程式碼：

```c++
#include <iostream>
#include <thread>

using namespace std;

int main() {
    auto func = []() {
        for (int i = 0; i < 10; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread t(func);
    if (t.joinable()) {
        t.detach();
    }
    auto func1 = [](int k) {
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread tt(func1, 20);
    if (tt.joinable()) { // 檢查執行緒可否被join
        tt.join();
    }
    return 0;
}
```

上述程式碼中，函式func和func1運行在執行緒物件t和tt中，從剛創建物件開始就會新建一個執行緒用於執行函式，調用join函式將會阻塞主執行緒，直到執行緒函式執行結束，執行緒函式的回傳值將會被忽略。如果不希望執行緒被阻塞執行，可以調用執行緒物件的detach函式，表示將執行緒和執行緒物件分離。

如果沒有調用join或者detach函式，假如執行緒函式執行時間較長，此時執行緒物件的生命週期結束調用解構函式清理資源，這時可能會發生錯誤，這裡有兩種解決辦法，一個是調用join()，保證執行緒函式的生命週期和執行緒物件的生命週期相同，另一個是調用detach()，將執行緒和執行緒物件分離，這裡需要注意，如果執行緒已經和物件分離，那就再也無法控制執行緒什麼時候結束了，不能再通過join來等待執行緒執行完。

這裡可以對thread進行封裝，避免沒有調用join或者detach可導致程式出錯的情況出現：

```c++
class ThreadGuard {
    public:
    enum class DesAction { join, detach };

    ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){};

    ~ThreadGuard() {
        if (t_.joinable()) {
            if (action_ == DesAction::join) {
                t_.join();
            } else {
                t_.detach();
            }
        }
    }

    ThreadGuard(ThreadGuard&&) = default;
    ThreadGuard& operator=(ThreadGuard&&) = default;

    std::thread& get() { return t_; }

    private:
    std::thread t_;
    DesAction action_;
};

int main() {
    ThreadGuard t(std::thread([]() {
        for (int i = 0; i < 10; ++i) {
            std::cout << "thread guard " << i << " ";
        }
        std::cout << std::endl;}), ThreadGuard::DesAction::join);
    return 0;
}
```

c++11還提供了獲取執行緒id，或者系統cpu個數，獲取thread native_handle，使得執行緒休眠等功能

```c++
std::thread t(func);
cout << "當前執行緒ID " << t.get_id() << endl;
cout << "當前cpu個數 " << std::thread::hardware_concurrency() << endl;
auto handle = t.native_handle();// handle可用於pthread相關操作
std::this_thread::sleep_for(std::chrono::seconds(1));
```

## std::mutex相關

std::mutex是一種執行緒同步的手段，用於保存多執行緒同時操作的共享數據。

mutex分為四種：

- std::mutex：獨佔的互斥量，不能遞歸使用，不帶超時功能
- std::recursive_mutex：遞歸互斥量，可重入，不帶超時功能

- std::timed_mutex：帶超時的互斥量，不能遞歸
- std::recursive_timed_mutex：帶超時的互斥量，可以遞歸使用

拿一個std::mutex和std::timed_mutex舉例，別的都是類似的使用方式：

std::mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>

using namespace std;
std::mutex mutex_;

int main() {
    auto func1 = [](int k) {
        mutex_.lock();
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
        mutex_.unlock();
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

std::timed_mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::timed_mutex timed_mutex_;

int main() {
    auto func1 = [](int k) {
        timed_mutex_.try_lock_for(std::chrono::milliseconds(200));
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
        timed_mutex_.unlock();
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

## std::lock相關

這裡主要介紹兩種RAII方式的鎖封裝，可以動態的釋放鎖資源，防止執行緒由於編碼失誤導致一直持有鎖。

c++11主要有std::lock_guard和std::unique_lock兩種方式，使用方式都類似，如下：

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::mutex mutex_;

int main() {
    auto func1 = [](int k) {
        // std::lock_guard<std::mutex> lock(mutex_);
        std::unique_lock<std::mutex> lock(mutex_);
        for (int i = 0; i < k; ++i) {
            cout << i << " ";
        }
        cout << endl;
    };
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(func1, 200);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

std::lock_gurad相比於std::unique_lock更加輕量級，少了一些成員函式，std::unique_lock類有unlock函式，可以手動釋放鎖，所以條件變數都配合std::unique_lock使用，而不是std::lock_guard，因為條件變數在wait時需要有手動釋放鎖的能力，具體關於條件變數後面會講到。

## std::atomic相關

c++11提供了原子型別std::atomic<T>，理論上這個T可以是任意型別，但是平時只存放整形，別的還真的沒用過，整形有這種原子變數已經足夠方便，就不需要使用std::mutex來保護該變數啦。看一個計數器的程式碼：

```c++
struct OriginCounter { // 普通的計數器
    int count;
    std::mutex mutex_;
    void add() {
        std::lock_guard<std::mutex> lock(mutex_);
        ++count;
    }

    void sub() {
        std::lock_guard<std::mutex> lock(mutex_);
        --count;
    }

    int get() {
        std::lock_guard<std::mutex> lock(mutex_);
        return count;
    }
};

struct NewCounter { // 使用原子變數的計數器
    std::atomic<int> count;
    void add() {
        ++count;
        // count.store(++count);這種方式也可以
    }

    void sub() {
        --count;
        // count.store(--count);
    }

    int get() {
        return count.load();
    }
};
```

是不是使用原子變數更加方便了呢？

## std::call_once相關

c++11提供了std::call_once來保證某一函式在多執行緒環境中只調用一次，它需要配合std::once_flag使用，直接看使用程式碼：

```c++
std::once_flag onceflag;

void CallOnce() {
    std::call_once(onceflag, []() {
        cout << "call once" << endl;
    });
}

int main() {
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(CallOnce);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

## volatile相關

貌似把volatile放在併發裡介紹不太合適，但是貌似很多人都會把volatile和多執行緒聯繫在一起，一起介紹下。

volatile通常用來建立記憶體屏障，volatile修飾的變數，編譯器對訪問該變數的程式碼通常不再進行最佳化，看下面程式碼：

```c++
int *p = xxx;
int a = *p;
int b = *p;
```

a和b都等於p指向的值，一般編譯器會對此做最佳化，把*p的值放入寄存器，就是傳說中的工作記憶體(不是主記憶體)，之後a和b都等於寄存器的值，但是如果中間p地址的值改變，記憶體上的值改變啦，但a,b還是從寄存器中取的值(不一定，看編譯器最佳化結果)，這就不符合需求，所以在此對p加volatile修飾可以避免進行此類最佳化。

注意：volatile不能解決多執行緒安全問題，針對特種記憶體才需要使用volatile，它和atomic的特點如下：• std::atomic用於多執行緒訪問的數據，且不用互斥量，用於併發編程中• volatile用於讀寫操作不可以被最佳化掉的記憶體，用於特種記憶體中

## std::condition_variable相關

條件變數是c++11引入的一種同步機制，它可以阻塞一個執行緒或者個執行緒，直到有執行緒通知或者超時才會喚醒正在阻塞的執行緒，條件變數需要和鎖配合使用，這裡的鎖就是上面介紹的std::unique_lock。

這裡使用條件變數實現一個CountDownLatch：

```c++
class CountDownLatch {
    public:
    explicit CountDownLatch(uint32_t count) : count_(count);

    void CountDown() {
        std::unique_lock<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0) {
            cv_.notify_all();
        }
    }

    void Await(uint32_t time_ms = 0) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0) {
            if (time_ms > 0) {
                cv_.wait_for(lock, std::chrono::milliseconds(time_ms));
            } else {
                cv_.wait(lock);
            }
        }
    }

    uint32_t GetCount() const {
        std::unique_lock<std::mutex> lock(mutex_);
        return count_;
    }

    private:
    std::condition_variable cv_;
    mutable std::mutex mutex_;
    uint32_t count_ = 0;
};
```

關於條件變數其實還涉及到通知丟失和虛假喚醒問題，因為不是本文的主題，這裡暫不介紹，大家有需要可以留言。

## std::future相關

c++11關於非同步操作提供了future相關的類，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高級些，std::future作為非同步結果的傳輸通道，通過get()可以很方便的獲取執行緒函式的回傳值，std::promise用來包裝一個值，將數據和future綁定起來，而std::packaged_task則用來包裝一個調用物件，將函式和future綁定起來，方便非同步調用。而std::future是不可以複製的，如果需要複製放到容器中可以使用std::shared_future。

### std::promise與std::future配合使用

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

void func(std::future<int>& fut) {
    int x = fut.get();
    cout << "value: " << x << endl;
}

int main() {
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    std::thread t(func, std::ref(fut));
    prom.set_value(144);
    t.join();
    return 0;
}
```

### std::packaged_task與std::future配合使用

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) {
    return in + 1;
}

int main() {
    std::packaged_task<int(int)> task(func);
    std::future<int> fut = task.get_future();
    std::thread(std::move(task), 5).detach();
    cout << "result " << fut.get() << endl;
    return 0;
}
```

### 三者之間的關係

std::future用於訪問非同步操作的結果，而std::promise和std::packaged_task在future高一層，它們內部都有一個future，promise包裝的是一個值，packaged_task包裝的是一個函式，當需要獲取執行緒中的某個值，可以使用std::promise，當需要獲取執行緒函式回傳值，可以使用std::packaged_task。

## async相關

async是比future，packaged_task，promise更高級的東西，它是基於任務的非同步操作，通過async可以直接創建非同步的任務，返回的結果會保存在future中，不需要像packaged_task和promise那麼麻煩，關於執行緒操作應該優先使用async，看一段使用程式碼：

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) { return in + 1; }

int main() {
    auto res = std::async(func, 5);
    // res.wait();
    cout << res.get() << endl; // 阻塞直到函式返回
    return 0;
}
```

使用async非同步執行函式是不是方便多啦。

async具體語法如下：

```c++
async(std::launch::async | std::launch::deferred, func, args...);
```

第一個參數是創建策略：

- std::launch::async表示任務執行在另一執行緒
- std::launch::deferred表示延遲執行任務，調用get或者wait時才會執行，不會創建執行緒，惰性執行在當前執行緒。

如果不明確指定創建策略，以上兩個都不是async的預設策略，而是未定義，它是一個基於任務的程式設計，內部有一個調度器(執行緒池)，會根據實際情況決定採用哪種策略。

若從 std::async 獲得的 std::future 未被移動或綁定到參照，則在完整表達式結尾， std::future的解構函式將阻塞直至非同步計算完成，實際上相當於同步操作：

```c++
std::async(std::launch::async, []{ f(); }); // 臨時量的解構函式等待 f()
std::async(std::launch::async, []{ g(); }); // f() 完成前不開始
```

注意：關於async啟動策略這裡以cppreference為主。

有時候如果想真正執行非同步操作可以對async進行封裝，強制使用std::launch::async策略來調用async。

```c++
template <typename F, typename... Args>
inline auto ReallyAsync(F&& f, Args&&... params) {
    return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...);
}
```

## 總結

• std::thread使執行緒的創建變得非常簡單，還可以獲取執行緒id等資訊。
• std::mutex通過多種方式保證了執行緒安全，互斥量可以獨佔，也可以重入，還可以設置互斥量的超時時間，避免一直阻塞等鎖。
• std::lock通過RAII技術方便了加鎖和解鎖調用，有std::lock_guard和std::unique_lock。
• std::atomic提供了原子變數，更方便實現實現保護，不需要使用互斥量
• std::call_once保證函式在多執行緒環境下只調用一次，可用於實現單例。
• volatile常用於讀寫操作不可以被最佳化掉的記憶體中。
• std::condition_variable提供等待的同步機制，可阻塞一個或多個執行緒，等待其它執行緒通知後喚醒。
• std::future用於非同步調用的包裝和回傳值。
• async更方便的實現了非同步調用，非同步調用優先使用async取代創建執行緒。

# C++11 的非同步操作-async

C++11中增加了async，如它的名字一樣，這個關鍵字就是用來創建非同步操作的，c++11中有個更常用的非同步操作，叫做執行緒thread，那麼thread和async有什麼區別呢？以及async的優勢是什麼？應該怎麼使用？

### C++11 使用 std::async創建非同步程式

C++11中增加了執行緒，可以非常方便的創建執行緒，它的基本用法是這樣的：

```c++
void f(int n);
std::thread t(f, n + 1);
t.join();
```

但是執行緒畢竟是屬於比較低層次的東西，有時候使用有些不便，比如希望獲取執行緒函式的返回結果的時候，就不能直接通過 `thread.join()`得到結果，這時就必須定義一個變數，在執行緒函式中去給這個變數賦值，然後join，最後得到結果，這個過程是比較繁瑣的。

c++11還提供了非同步介面`std::async`，通過這個非同步介面可以很方便的獲取執行緒函式的執行結果。`std::async`會自動創建一個執行緒去調用執行緒函式，它返回一個`std::future`，這個future中存儲了執行緒函式返回的結果，當需要執行緒函式的結果時，直接從future中獲取，非常方便。

其實std::async提供的便利可不僅僅是這一點，它首先解耦了執行緒的創建和執行，可以在需要的時候獲取非同步操作的結果；其次它還提供了執行緒的創建策略（比如可以通過延遲加載的方式去創建執行緒），可以以多種方式去創建執行緒。在介紹`async`具體用法以及為什麼要用`std::async`代替執行緒的創建之前，先看看`std::future`、`std::promise`和 `std::packaged_task`。

### std::future

std::future是一個非常有用也很有意思的東西，簡單說std::future提供了一種訪問非同步操作結果的機制。從字面意思來理解， 它表示未來，因為一個非同步操作是不可能馬上就獲取操作結果的，只能在未來某個時候獲取，但是可以以同步等待的方式來獲取結果，可以通過查詢future的狀態（future_status）來獲取非同步操作的結果。future_status有三種狀態：

- deferred：非同步操作還沒開始
- ready：非同步操作已經完成

- timeout：非同步操作超時

```c++
//查詢future的狀態
std::future_status status;
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred\n";
    } else if (status == std::future_status::timeout) {
        std::cout << "timeout\n";
    } else if (status == std::future_status::ready) {
        std::cout << "ready!\n";
} while (status != std::future_status::ready);
```

獲取future結果有三種方式：get、wait、wait_for，其中get等待非同步操作結束並返回結果，`wait`只是等待非同步操作完成，沒有回傳值，`wait_for`是超時等待返回結果。

### std::promise

std::promise為獲取執行緒函式中的某個值提供便利，在執行緒函式中給外面傳進來的promise賦值，當執行緒函式執行完成之後就可以通過promis獲取該值了，值得注意的是取值是間接的通過promise內部提供的future來獲取的。它的基本用法：

```c++
std::promise<int> pr;
std::thread t([](std::promise<int>& p){
    p.set_value_at_thread_exit(9);
},std::ref(pr));
std::future<int> f = pr.get_future();
auto r = f.get();
```

### std::packaged_task

std::packaged_task它包裝了一個可調用的目標（如function, lambda expression, bind expression, or another function object）,以便非同步調用，它和promise在某種程度上有點像，promise保存了一個共享狀態的值，而`packaged_task`保存的是一 個函式。它的基本用法：

```c++
std::packaged_task<int()> task([](){ return 7; });
std::thread t1(std::ref(task)); 
std::future<int> f1 = task.get_future(); 
auto r1 = f1.get();
```

### std::promise、std::packaged_task和std::future的關係

看了`std::async`相關的幾個物件`std::future`、`std::promise`和`std::packaged_task`，其中 `std::promise`和`std::packaged_task`的結果最終都是通過其內部的future返回出來的，看看他們之間的關係到底是怎樣的，`std::future`提供了一個訪問非同步操作結果的機制，它和執行緒是一個級別的屬於低層次的物件，在它之上高一層的是`std::packaged_task`和`std::promise`，他們內部都有future以便訪問非同步操作結果，`std::packaged_task`包裝的是一個非同步操作，而`std::promise`包裝的是一個值，都是為了方便非同步操作的，因為有時需要獲取執行緒中的某個值，這時就用`std::promise`，而有時需要獲一個非同步操作的回傳值，這時就用`std::packaged_task`。

那 `std::promise`和`std::packaged_task`之間又是什麼關係呢？說他們沒關係也沒關係，說他們有關係也有關係，都取決於如何使用他們了，可以將一個非同步操作的結果保存到`std::promise`中。

### 為什麼要用`std::async`代替執行緒的創建

`std::async`是為了讓開發者的少費點腦子的，它讓這三個物件默契的工作。大概的工作過程是這樣的：`std::async`先將非同步操作用`std::packaged_task`包 裝起來，然後將非同步操作的結果放到`std::promise`中，這個過程就是創造未來的過程。外面再通過`future.get/wait`來獲取這個未來的結果！

現在來看看`std::async`的原型

`async(std::launch::async | std::launch::deferred, f, args...)` 第一個參數是執行緒的創建策略，有兩種策略，預設的策略是立即創建執行緒：

`std::launch::async`：在調用async就開始創建執行緒。

`std::launch::deferred`：延遲加載方式創建執行緒。調用async時不創建執行緒，直到調用了`future`的`get`或者`wait`時才創建執行緒。

第二個參數是執行緒函式，第三個參數是執行緒函式的參數。

### `std::async`基本用法

```c++
std::future<int> f1 = std::async(std::launch::async, []() {
    return 8;
    });
cout << f1.get() << endl; //output: 8
std::future<void> f2 = std::async(std::launch::async, []() {
    cout << 8 << endl;
    //return 8;
    });
f2.wait(); //output: 8
std::future<int> future = std::async(std::launch::async, []() {
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 8;
    });
std::cout << "waiting...\n";
//Test12();
std::future_status status;
Sleep(3000);
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred\n";
    }
    else if (status == std::future_status::timeout) {
        std::cout << "timeout\n";
    }
    else if (status == std::future_status::ready) {
        std::cout << "ready!\n";
    }
} while (status != std::future_status::ready);
std::cout << "result is " << future.get() << '\n';
```

可能的結果：waiting... timeout timeout ready! result is 8

### 總結

`std::async`是更高層次上的非同步操作，它的存在可以使開發者不用關注執行緒創建內部細節，就能方便的獲取非同步執行狀態和結果，還可以指定執行緒創建策略，應該用`std::async`替代執行緒的創建，讓它成為做非同步操作的首選。

# C++11新特性之智慧指標

c++11引入了三種智慧指標：

- std::shared_ptr
- std::weak_ptr

- std::unique_ptr

## shared_ptr

shared_ptr使用了參照計數，每一個shared_ptr的複製都指向相同的記憶體，每次複製都會觸發參照計數+1，每次生命週期結束解構的時候參照計數-1，在最後一個shared_ptr解構的時候，記憶體才會釋放。

使用方法如下：

```c++
struct ClassWrapper {
    ClassWrapper() {
        cout << "construct" << endl;
        data = new int[10];
    }
    ~ClassWrapper() {
        cout << "deconstruct" << endl;
        if (data != nullptr) {
            delete[] data;
        }
    }
    void Print() {
        cout << "print" << endl;
    }
    int* data;
};

void Func(std::shared_ptr<ClassWrapper> ptr) {
    ptr->Print();
}

int main() {
    auto smart_ptr = std::make_shared<ClassWrapper>();
    auto ptr2 = smart_ptr; // 參照計數+1
    ptr2->Print();
    Func(smart_ptr); // 參照計數+1
    smart_ptr->Print();
    ClassWrapper *p = smart_ptr.get(); // 可以通過get獲取裸指標
    p->Print();
    return 0;
}
```

智慧指標還可以自定義刪除器，在參照計數為0的時候自動調用刪除器來釋放物件的記憶體，程式碼如下：

```c++
std::shared_ptr<int> ptr(new int, [](int *p){ delete p; });
```

關於shared_ptr有幾點需要注意：

• 不要用一個裸指標初始化多個shared_ptr，會出現double_free導致程式崩潰

• 通過shared_from_this()返回this指標，不要把this指標作為shared_ptr返回出來，因為this指標本質就是裸指標，通過this返回可能 會導致重複解構，不能把this指標交給智慧指標管理。

```c++
class A {
    shared_ptr<A> GetSelf() {
        return shared_from_this();
        // return shared_ptr<A>(this); 錯誤，會導致double free
    }  
};
```

- 儘量使用make_shared，少用new。
- 不要delete get()返回來的裸指標。

- 不是new出來的空間要自定義刪除器。
- 要避免迴圈參照，迴圈參照導致記憶體永遠不會被釋放，造成記憶體洩漏。

```c++
using namespace std;
struct A;
struct B;

struct A {
    std::shared_ptr<B> bptr;
    ~A() {
        cout << "A delete" << endl;
    }
};

struct B {
    std::shared_ptr<A> aptr;
    ~B() {
        cout << "B delete" << endl;
    }
};

int main() {
    auto aaptr = std::make_shared<A>();
    auto bbptr = std::make_shared<B>();
    aaptr->bptr = bbptr;
    bbptr->aptr = aaptr;
    return 0;
}
```

上面程式碼，產生了迴圈參照，導致aptr和bptr的參照計數為2，離開作用域後aptr和bptr的參照計數-1，但是永遠不會為0，導致指標永遠不會解構，產生了記憶體洩漏，如何解決這種問題呢，答案是使用weak_ptr。

## weak_ptr

weak_ptr是用來監視shared_ptr的生命週期，它不管理shared_ptr內部的指標，它的複製的解構都不會影響參照計數，純粹是作為一個旁觀者監視shared_ptr中管理的資源是否存在，可以用來返回this指標和解決迴圈參照問題。

- 作用1：返回this指標，上面介紹的shared_from_this()其實就是通過weak_ptr返回的this指標。
- 作用2：解決迴圈參照問題。

```c++
struct A;
struct B;

struct A {
    std::shared_ptr<B> bptr;
    ~A() {
        cout << "A delete" << endl;
    }
    void Print() {
        cout << "A" << endl;
    }
};

struct B {
    std::weak_ptr<A> aptr; // 這裡改成weak_ptr
    ~B() {
        cout << "B delete" << endl;
    }
    void PrintA() {
        if (!aptr.expired()) { // 監視shared_ptr的生命週期
            auto ptr = aptr.lock();
            ptr->Print();
        }
    }
};

int main() {
    auto aaptr = std::make_shared<A>();
    auto bbptr = std::make_shared<B>();
    aaptr->bptr = bbptr;
    bbptr->aptr = aaptr;
    bbptr->PrintA();
    return 0;
}
```

輸出：

```c++
A
A delete
B delete
```

## unique_ptr

std::unique_ptr是一個獨佔型的智慧指標，它不允許其它智慧指標共享其內部指標，也不允許unique_ptr的複製和賦值。使用方法和shared_ptr類似，區別是不可以複製：

```c++
using namespace std;

struct A {
    ~A() {
        cout << "A delete" << endl;
    }
    void Print() {
        cout << "A" << endl;
    }
};


int main() {
    auto ptr = std::unique_ptr<A>(new A);
    auto tptr = std::make_unique<A>(); // error, c++11還不行，需要c++14
    std::unique_ptr<A> tem = ptr; // error, unique_ptr不允許移動
    ptr->Print();
    return 0;
}
```

