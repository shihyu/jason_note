# C++11常用新特性(二）

# Lambda 表達式



Lambda 表達式，實際上就是提供了一個類似匿名函數的特性，而匿名函數則是在需要一個函數，但是又不想費力去命名一個函數的情況下去使用的。



## Lambda 表達式的基本語法如下：



```c
[ caputrue ] ( params ) opt -> ret { body; };
```



1. capture是捕獲列表；
2. params是參數表；(選填)

1. opt是函數選項；可以填`mutable`,`exception`,`attribute`（選填）



- mutable說明lambda表達式體內的代碼可以修改被捕獲的變量，並且可以訪問被捕獲的對象的non-const方法。
- exception說明lambda表達式是否拋出異常以及何種異常。

- attribute用來聲明屬性。



1. ret是返回值類型（拖尾返回類型）。(選填)
2. body是函數體。



捕獲列表：lambda表達式的捕獲列表精細控制了lambda表達式能夠訪問的外部變量，以及如何訪問這些變量。



1.  []不捕獲任何變量。 
2.  [&]捕獲外部作用域中所有變量，並作為引用在函數體中使用（按引用捕獲）。 

1.  [=]捕獲外部作用域中所有變量，並作為副本在函數體中使用(按值捕獲)。注意值捕獲的前提是變量可以拷貝，**且被捕獲的量在 lambda 表達式被創建時拷貝，而非調用時才拷貝**。如果希望lambda表達式在調用時能即時訪問外部變量，我們應當用引用方式捕獲。  

```c
int a = 0;
auto f = [=] { return a; };

a+=1;

cout << f() << endl;       //輸出0

int a = 0;
auto f = [&a] { return a; };

a+=1;

cout << f() <<endl;       //輸出1
```

1.  [=,&foo]按值捕獲外部作用域中所有變量，並按引用捕獲foo變量。 
2.  [bar]按值捕獲bar變量，同時不捕獲其他變量。 

1.  [this]捕獲當前類中的this指針，讓lambda表達式擁有和當前類成員函數同樣的訪問權限。**如果已經使用了&或者=，就默認添加此選項**。捕獲this的目的是可以在lamda中使用當前類的成員函數和成員變量。 



```c
class A
{
 public:
     int i_ = 0;

     void func(int x,int y){
         auto x1 = [] { return i_; };                   //error,沒有捕獲外部變量
         auto x2 = [=] { return i_ + x + y; };          //OK
         auto x3 = [&] { return i_ + x + y; };        //OK
         auto x4 = [this] { return i_; };               //OK
         auto x5 = [this] { return i_ + x + y; };       //error,沒有捕獲x,y
         auto x6 = [this, x, y] { return i_ + x + y; };     //OK
         auto x7 = [this] { return i_++; };             //OK

};

int a=0 , b=1;
auto f1 = [] { return a; };                         //error,沒有捕獲外部變量    
auto f2 = [&] { return a++ };                      //OK
auto f3 = [=] { return a; };                        //OK
auto f4 = [=] {return a++; };                       //error,a是以複製方式捕獲的，無法修改
auto f5 = [a] { return a+b; };                      //error,沒有捕獲變量b
auto f6 = [a, &b] { return a + (b++); };                //OK
auto f7 = [=, &b] { return a + (b++); };                //OK
```





注意f4，雖然**按值捕獲的變量**值均複製一份存儲在lambda表達式變量中，修改他們也並不會真正影響到外部，但**我們卻仍然無法修改它們**。如果希望去修改按值捕獲的外部變量，需要顯示指明lambda表達式為mutable。**被mutable修飾的lambda表達式就算沒有參數也要寫明參數列表。**



```cpp
int a = 0;
auto f1 = [=] { return a++; };                //error
auto f2 = [=] () mutable { return a++; };       //OK
```



原因：**lambda表達式可以說是就地定義仿函數閉包的“語法糖”**。它的捕獲列表捕獲住的任何外部變量，最終會變為閉包類型的成員變量。按照C++標準，**lambda表達式的operator()默認是const的**，一個const成員函數是無法修改成員變量的值的。**而mutable的作用，就在於取消operator()的const。**  



## lambda表達式的大致原理：



每當你定義一個lambda表達式後，**編譯器會自動生成一個匿名類（這個類重載了()運算符），我們稱為閉包類型（closure type）**。那麼在運行時，**這個lambda表達式就會返回一個匿名的閉包實例**，是一個右值。所以，我們上面的lambda表達式的結果就是一個個閉包。**對於複製傳值捕捉方式，類中會相應添加對應類型的非靜態數據成員**。在運行時，會用複製的值初始化這些成員變量，從而生成閉包。對於引用捕獲方式，無論是否標記mutable，都可以在lambda表達式中修改捕獲的值。至於閉包類中是否有對應成員，C++標準中給出的答案是：不清楚的，與具體實現有關。



## lambda表達式是不能被賦值的：



```c
auto a = [] { cout << "A" << endl; };
auto b = [] { cout << "B" << endl; };

a = b;   // 非法，lambda無法賦值
auto c = a;   // 合法，生成一個副本
```



閉包類型禁用了賦值操作符，但是沒有禁用複製構造函數，所以你仍然可以用一個lambda表達式去初始化另外一個lambda表達式而產生副本。



在多種捕獲方式中，**最好不要使用[=]和[&]默認捕獲所有變量**。



默認引用捕獲所有變量，你有很大可能會出現懸掛引用（Dangling references），因為引用捕獲不會延長引用的變量的生命週期：



```c
std::function<int(int)> add_x(int x)
{
    return [&](int a) { return x + a; };
}
```



上面函數返回了一個lambda表達式，參數x僅是一個臨時變量，函數add_x調用後就被銷燬了，但是返回的lambda表達式卻引用了該變量，當調用這個表達式時，引用的是一個垃圾值，會產生沒有意義的結果。上面這種情況，使用默認傳值方式可以避免懸掛引用問題。



但是採用默認值捕獲所有變量仍然有風險，看下面的例子：



```c
class Filter
{
public:
    Filter(int divisorVal):
        divisor{divisorVal}
    {}

    std::function<bool(int)> getFilter() 
    {
        return [=](int value) {return value % divisor == 0; };
    }

private:
    int divisor;
};
```



這個類中有一個成員方法，可以返回一個lambda表達式，這個表達式使用了類的數據成員divisor。而且採用默認值方式捕捉所有變量。你可能認為這個lambda表達式也捕捉了divisor的一份副本，但是實際上並沒有。因為數據成員divisor對lambda表達式並不可見，你可以用下面的代碼驗證：



```c
// 類的方法，下面無法編譯，因為divisor並不在lambda捕捉的範圍
std::function<bool(int)> getFilter() 
{
    return [divisor](int value) {return value % divisor == 0; };
}
```



原代碼中，lambda表達式實際上捕捉的是this指針的副本，所以原來的代碼等價於：



```c
std::function<bool(int)> getFilter() {    return [this](int value) {return value % this->divisor == 0; };}
```



儘管還是以值方式捕獲，但是捕獲的是指針，其實相當於以引用的方式捕獲了當前類對象，**所以lambda表達式的閉包與一個類對象綁定在一起了，這很危險，因為你仍然有可能在類對象析構後使用這個lambda表達式**，那麼類似“懸掛引用”的問題也會產生。所以，**採用默認值捕捉所有變量仍然是不安全的**，主要是由於指針變量的複製，實際上還是按引用傳值。



lambda表達式可以賦值給對應類型的函數指針。但是使用函數指針並不是那麼方便。所以STL定義在< functional >頭文件提供了一個多態的函數對象封裝std::function，其類似於函數指針。它可以綁定任何類函數對象，只要參數與返回類型相同。如下面的返回一個bool且接收兩個int的函數包裝器：



```c
std::function<bool(int, int)> wrapper = [](int x, int y) { return x < y; };
```



lambda表達式一個更重要的應用是其可以用於函數的參數，通過這種方式可以實現回調函數。



最常用的是在STL算法中，比如你要統計一個數組中滿足特定條件的元素數量，通過lambda表達式給出條件，傳遞給count_if函數：



```c
int value = 3;
vector<int> v {1, 3, 5, 2, 6, 10};
int count = std::count_if(v.beigin(), v.end(), [value](int x) { return x > value; });
```



再比如你想生成斐波那契數列，然後保存在數組中，此時你可以使用generate函數，並輔助lambda表達式：



```cpp
vector<int> v(10);
int a = 0;
int b = 1;
std::generate(v.begin(), v.end(), 
              [&a, &b] { int value = b; b = b + a; a = value; return value; });
// 此時v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}
```



當需要遍歷容器並對每個元素進行操作時：



```c
std::vector<int> v = { 1, 2, 3, 4, 5, 6 };
int even_count = 0;
for_each(v.begin(), v.end(), [&even_count](int val){
    if(!(val & 1)){
        ++ even_count;
    }
});
std::cout << "The number of even is " << even_count << std::endl;
```



大部分STL算法，可以非常靈活地搭配lambda表達式來實現想要的效果。



# C++ std::function



std::function是一個函數對象的包裝器，std::function的實例可以存儲，複製和調用任何可調用的目標，包括：



1.  函數。 
2.  lamada表達式。 

1.  綁定表達式或其他函數對象。 
2.  指向成員函數和指向數據成員的指針。 



當`std::function`對象沒有初始化任何實際的可調用元素，調用`std::function`對象將拋出`std::bad_function_call`異常。



## std::function簡介



類模版std::function是一種通用、多態的函數封裝。std::function的實例可以對任何可以調用的目標實體進行存儲、複製、和調用操作，這些目標實體包括普通函數、Lambda表達式、函數指針、以及其它函數對象等。std::function對象是對C++中現有的可調用實體的一種類型安全的包裹（我們知道像函數指針這類可調用實體，是類型不安全的）。



**通常std::function是一個函數對象類，它包裝其它任意的函數對象，被包裝的函數對象具有類型為T1, …,TN的N個參數，並且返回一個可轉換到R類型的值**。std::function使用 模板轉換構造函數接收被包裝的函數對象；特別是，閉包類型可以隱式地轉換為std::function。



C++標準庫詳細說明了這個的基本使用http://www.cplusplus.com/reference/functional/function/.



這裡我們大概總結一下。



### Member types

| 成員類型             | 說明                                                   |
| -------------------- | ------------------------------------------------------ |
| result_type          | 返回類型                                               |
| argument_type        | 如果函數對象只有一個參數，那麼這個代表參數類型。       |
| first_argument_type  | 如果函數對象有兩個個參數，那麼這個代表第一個參數類型。 |
| second_argument_type | 如果函數對象有兩個個參數，那麼這個代表第二個參數類型。 |



### Member functions

| 成員函數聲明  | 說明                                              |
| ------------- | ------------------------------------------------- |
| constructor   | 構造函數：constructs a new std::function instance |
| destructor    | 析構函數： destroys a std::function instance      |
| operator=     | 給定義的function對象賦值                          |
| operator bool | 檢查定義的function對象是否包含一個有效的對象      |
| operator()    | 調用一個對象                                      |



## std::function使用



封裝普通函數例子：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;int TestFunc(int a)  {      return a;  }int main(){    Functional obj = TestFunc;        int res = obj(1);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝lambda表達式 ：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;auto lambda = [](int a)->int{return a;};int main(){    Functional obj = lambda;        res = obj(2);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝仿函數：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;class Functor{public:    int operator()(int a)    {        return a;    }};int main(){    Functor func;    Functional obj = func;    res = obj(3);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝類的成員函數和static成員函數 ：



```c
#include <iostream>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <string>
#include <algorithm>
#include <functional>
#include <memory>

using namespace std;

typedef std::function<int(int)> Functional;

class CTest
{
public:
    int Func(int a)
    {
        return a;
    }
    static int SFunc(int a)
    {
        return a;
    }
};

int main()
{
    CTest t;  
    obj = std::bind(&CTest::Func, &t, std::placeholders::_1);  
    res = obj(3);  
    cout << "member function : " << res << endl;  
  
    obj = CTest::SFunc;  
    res = obj(4);  
    cout << "static member function : " << res << endl;  

    while(1);
    return 0;
}
```



關於可調用實體轉換為std::function對象需要遵守以下兩條原則：



1. 轉換後的std::function對象的參數能轉換為可調用實體的參數；
2. 可調用實體的返回值能轉換為std::function對象的返回值。



**std::function對象最大的用處就是在實現函數回調**，使用者需要注意，**它不能被用來檢查相等或者不相等，但是可以與NULL或者nullptr進行比較。**



**為什麼要用std::function？**



好用並實用的東西才會加入標準的。因為好用，實用，我們才在項目中使用它。std::function實現了一套類型消除機制，可以統一處理不同的函數對象類型。以前我們使用函數指針來完成這些；現在我們可以使用更安全的std::function來完成這些任務。



參考文檔：

 

[C++ std::function技術淺談](https://blog.csdn.net/xiangbaohui/article/details/106741654)

# 

# 右值引用和move語義



先看一個簡單的例子直觀感受下：



```c
string a(x);                                    // line 1
string b(x + y);                                    // line 2
string c(some_function_returning_a_string());       // line 3
```



如果使用以下拷貝構造函數：



```c
string(const string& that)
{
    size_t size = strlen(that.data) + 1;
    data = new char[size];
    memcpy(data, that.data, size);
}
```



以上3行中，只有第一行(line 1)的x深度拷貝是有必要的，因為我們可能會在後邊用到x，x是一個左值(lvalues)。



第二行和第三行的參數則是右值，因為表達式產生的string對象是匿名對象，之後沒有辦法再使用了。



C++ 11引入了一種新的機制叫做“右值引用”，以便我們通過重載直接使用右值參數。我們所要做的就是寫一個以右值引用為參數的構造函數：



```c
string(string&& that)   // string&& is an rvalue reference to a string
{
data = that.data;
that.data = 0;
}
```



我們沒有深度拷貝堆內存中的數據，而是僅僅複製了指針，並把源對象的指針置空。事實上，我們“偷取”了屬於源對象的內存數據。由於源對象是一個右值，不會再被使用，因此客戶並不會覺察到源對象被改變了。在這裡，我們並沒有真正的複製，所以我們把這個構造函數叫做“轉移構造函數”（move constructor），他的工作就是把資源從一個對象轉移到另一個對象，而不是複製他們。



有了右值引用，再來看看賦值操作符：



```c
string& operator=(string that)
{
std::swap(data, that.data);
return *this;
}
```



注意到我們是直接對參數that傳值，所以that會像其他任何對象一樣被初始化，那麼確切的說，that是怎樣被初始化的呢？對於C++ 98，答案是複製構造函數，**但是對於C++ 11，編譯器會依據參數是左值還是右值在複製構造函數和轉移構造函數間進行選擇。**



如果是a=b，這樣就會調用複製構造函數來初始化that（因為b是左值），賦值操作符會與新創建的對象交換數據，深度拷貝。這就是copy and swap 慣用法的定義：構造一個副本，與副本交換數據，並讓副本在作用域內自動銷燬。這裡也一樣。



如果是a = x + y，這樣就會調用轉移構造函數來初始化that（因為x+y是右值），所以這裡沒有深度拷貝，只有高效的數據轉移。相對於參數，that依然是一個獨立的對象，但是他的構造函數是無用的（trivial），因此堆中的數據沒有必要複製，而僅僅是轉移。沒有必要複製他，因為x+y是右值，再次，從右值指向的對象中轉移是沒有問題的。



總結一下：複製構造函數執行的是深度拷貝，因為源對象本身必須不能被改變。而轉移構造函數卻可以複製指針，把源對象的指針置空，這種形式下，這是安全的，因為用戶不可能再使用這個對象了。



下面我們進一步討論右值引用和move語義。



C98標準庫中提供了一種唯一擁有性的智能指針`std::auto_ptr`，**該類型在C11中已被廢棄**，因為其“複製”行為是危險的。



```c
auto_ptr<Shape> a(new Triangle);auto_ptr<Shape> b(a);
```



注意b是怎樣使用a進行初始化的，它不復制triangle，而是把triangle的所有權從a傳遞給了b，也可以說成“a 被轉移進了b”或者“triangle被從a轉移到了b”。



auto_ptr 的複製構造函數可能看起來像這樣（簡化）：



```c
auto_ptr(auto_ptr& source)   // note the missing const
{
p = source.p;
source.p = 0;   // now the source no longer owns the object
}
```



auto_ptr 的危險之處在於看上去應該是複製，但實際上確是轉移。調用被轉移過的auto_ptr 的成員函數將會導致不可預知的後果。所以你必須非常謹慎的使用auto_ptr ，如果他被轉移過。



```c
auto_ptr<Shape> make_triangle()
{
    return auto_ptr<Shape>(new Triangle);
}

auto_ptr<Shape> c(make_triangle());      // move temporary into c
double area = make_triangle()->area();   // perfectly safe

auto_ptr<Shape> a(new Triangle);    // create triangle
auto_ptr<Shape> b(a);               // move a into b
double area = a->area();                // undefined behavior
```



顯然，在持有auto_ptr 對象的a表達式和持有調用函數返回的auto_ptr值類型的make_triangle()表達式之間一定有一些潛在的區別，每調用一次後者就會創建一個新的auto_ptr對象。這裡a 其實就是一個左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。



轉移像a這樣的左值是非常危險的，因為我們可能調用a的成員函數，這會導致不可預知的行為。另一方面，轉移像make_triangle()這樣的右值卻是非常安全的，因為複製構造函數之後，我們不能再使用這個臨時對象了，因為這個轉移後的臨時對象會在下一行之前銷燬掉。



我們現在知道轉移左值是十分危險的，但是轉移右值卻是很安全的。如果C++能從語言級別支持區分左值和右值參數，我就可以完全杜絕對左值轉移，或者把轉移左值在調用的時候暴露出來，以使我們不會不經意的轉移左值。



C++ 11對這個問題的答案是右值引用。右值引用是針對右值的新的引用類型，語法是X&&。以前的老的引用類型X& 現在被稱作左值引用。



使用右值引用X&&作為參數的最有用的函數之一就是轉移構造函數X::X(X&& source)，它的主要作用是把源對象的本地資源轉移給當前對象。



C++ 11中，std::auto_ptr< T >已經被std::unique_ptr< T >所取代，後者就是利用的右值引用。



其轉移構造函數：



```c
unique_ptr(unique_ptr&& source)   // note the rvalue reference
{
    ptr = source.ptr;
    source.ptr = nullptr;
}
```



這個轉移構造函數跟auto_ptr中複製構造函數做的事情一樣，但是它卻只能接受右值作為參數。



```c
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);                 // error
unique_ptr<Shape> c(make_triangle());       // okay
```



第二行不能編譯通過，因為a是左值，但是參數unique_ptr&& source只能接受右值，這正是我們所需要的，杜絕危險的隱式轉移。第三行編譯沒有問題，因為make_triangle()是右值，轉移構造函數會將臨時對象的所有權轉移給對象c，這正是我們需要的。



## 轉移左值



有時候，我們可能想轉移左值，也就是說，有時候我們想讓編譯器把左值當作右值對待，以便能使用轉移構造函數，即便這有點不安全。出於這個目的，C++ 11在標準庫的頭文件< utility >中提供了一個模板函數std::move。實際上，std::move僅僅是簡單地將左值轉換為右值，它本身並沒有轉移任何東西。它僅僅是讓對象可以轉移。



以下是如何正確的轉移左值：



```c
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);              // still an error
unique_ptr<Shape> c(std::move(a));   // okay
```



請注意，第三行之後，a不再擁有Triangle對象。不過這沒有關係，因為通過明確的寫出std::move(a)，我們很清楚我們的意圖：親愛的轉移構造函數，你可以對a做任何想要做的事情來初始化c；我不再需要a了，對於a，您請自便。



當然，如果你在使用了mova(a)之後，還繼續使用a，那無疑是搬起石頭砸自己的腳，還是會導致嚴重的運行錯誤。



總之，std::move(some_lvalue)將左值轉換為右值（可以理解為一種類型轉換），使接下來的轉移成為可能。



一個例子：



```c
class Foo
{
    unique_ptr<Shape> member;

public:
    Foo(unique_ptr<Shape>&& parameter)
    : member(parameter)   // error
    {}

};
```



上面的parameter，其類型是一個右值引用，只能說明parameter是指向右值的引用，而parameter本身是個左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）



因此以上對parameter的轉移是不允許的，需要使用`std::move`來顯示轉換成右值。
