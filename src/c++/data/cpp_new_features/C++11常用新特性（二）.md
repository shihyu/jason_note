# C++11常用新特性(二）

# Lambda 表達式



Lambda 表達式，實際上就是提供了一個類似匿名函式的特性，而匿名函式則是在需要一個函式，但是又不想費力去命名一個函式的情況下去使用的。



## Lambda 表達式的基本語法如下：



```c
[ caputrue ] ( params ) opt -> ret { body; };
```



1. capture是捕獲列表；
2. params是參數表；(選填)

1. opt是函式選項；可以填`mutable`,`exception`,`attribute`（選填）



- mutable說明lambda表達式體內的程式碼可以修改被捕獲的變數，並且可以訪問被捕獲的物件的non-const方法。
- exception說明lambda表達式是否拋出異常以及何種異常。

- attribute用來聲明屬性。



1. ret是回傳值型別（拖尾返回型別）。(選填)
2. body是函式體。



捕獲列表：lambda表達式的捕獲列表精細控制了lambda表達式能夠訪問的外部變數，以及如何訪問這些變數。



1.  []不捕獲任何變數。 
2.  [&]捕獲外部作用域中所有變數，並作為參照在函式體中使用（按參照捕獲）。 

1.  [=]捕獲外部作用域中所有變數，並作為副本在函式體中使用(按值捕獲)。注意值捕獲的前提是變數可以複製，**且被捕獲的量在 lambda 表達式被創建時複製，而非調用時才複製**。如果希望lambda表達式在調用時能即時訪問外部變數，我們應當用參照方式捕獲。  

```c
int a = 0;
auto f = [=] { return a; };

a+=1;

cout << f() << endl;       //輸出0

int a = 0;
auto f = [&a] { return a; };

a+=1;

cout << f() <<endl;       //輸出1
```

1.  [=,&foo]按值捕獲外部作用域中所有變數，並按參照捕獲foo變數。 
2.  [bar]按值捕獲bar變數，同時不捕獲其他變數。 

1.  [this]捕獲當前類中的this指標，讓lambda表達式擁有和當前類成員函式同樣的訪問權限。**如果已經使用了&或者=，就預設添加此選項**。捕獲this的目的是可以在lamda中使用當前類的成員函式和成員變數。 



```c
class A
{
 public:
     int i_ = 0;

     void func(int x,int y){
         auto x1 = [] { return i_; };                   //error,沒有捕獲外部變數
         auto x2 = [=] { return i_ + x + y; };          //OK
         auto x3 = [&] { return i_ + x + y; };        //OK
         auto x4 = [this] { return i_; };               //OK
         auto x5 = [this] { return i_ + x + y; };       //error,沒有捕獲x,y
         auto x6 = [this, x, y] { return i_ + x + y; };     //OK
         auto x7 = [this] { return i_++; };             //OK

};

int a=0 , b=1;
auto f1 = [] { return a; };                         //error,沒有捕獲外部變數    
auto f2 = [&] { return a++ };                      //OK
auto f3 = [=] { return a; };                        //OK
auto f4 = [=] {return a++; };                       //error,a是以複製方式捕獲的，無法修改
auto f5 = [a] { return a+b; };                      //error,沒有捕獲變數b
auto f6 = [a, &b] { return a + (b++); };                //OK
auto f7 = [=, &b] { return a + (b++); };                //OK
```





注意f4，雖然**按值捕獲的變數**值均複製一份存儲在lambda表達式變數中，修改他們也並不會真正影響到外部，但**我們卻仍然無法修改它們**。如果希望去修改按值捕獲的外部變數，需要顯示指明lambda表達式為mutable。**被mutable修飾的lambda表達式就算沒有參數也要寫明參數列表。**



```cpp
int a = 0;
auto f1 = [=] { return a++; };                //error
auto f2 = [=] () mutable { return a++; };       //OK
```



原因：**lambda表達式可以說是就地定義仿函式閉包的“語法糖”**。它的捕獲列表捕獲住的任何外部變數，最終會變為閉包型別的成員變數。按照C++標準，**lambda表達式的operator()預設是const的**，一個const成員函式是無法修改成員變數的值的。**而mutable的作用，就在於取消operator()的const。**  



## lambda表達式的大致原理：



每當你定義一個lambda表達式後，**編譯器會自動生成一個匿名類（這個類多載了()運算子），我們稱為閉包型別（closure type）**。那麼在運行時，**這個lambda表達式就會返回一個匿名的閉包實體**，是一個右值。所以，我們上面的lambda表達式的結果就是一個個閉包。**對於複製傳值捕捉方式，類中會相應添加對應型別的非靜態數據成員**。在運行時，會用複製的值初始化這些成員變數，從而生成閉包。對於參照捕獲方式，無論是否標記mutable，都可以在lambda表達式中修改捕獲的值。至於閉包類中是否有對應成員，C++標準中給出的答案是：不清楚的，與具體實現有關。



## lambda表達式是不能被賦值的：



```c
auto a = [] { cout << "A" << endl; };
auto b = [] { cout << "B" << endl; };

a = b;   // 非法，lambda無法賦值
auto c = a;   // 合法，生成一個副本
```



閉包型別禁用了賦值操作符，但是沒有禁用複製建構函式，所以你仍然可以用一個lambda表達式去初始化另外一個lambda表達式而產生副本。



在多種捕獲方式中，**最好不要使用[=]和[&]預設捕獲所有變數**。



預設參照捕獲所有變數，你有很大可能會出現懸掛參照（Dangling references），因為參照捕獲不會延長參照的變數的生命週期：



```c
std::function<int(int)> add_x(int x)
{
    return [&](int a) { return x + a; };
}
```



上面函式返回了一個lambda表達式，參數x僅是一個臨時變數，函式add_x調用後就被銷燬了，但是返回的lambda表達式卻參照了該變數，當調用這個表達式時，參照的是一個垃圾值，會產生沒有意義的結果。上面這種情況，使用預設傳值方式可以避免懸掛參照問題。



但是採用預設值捕獲所有變數仍然有風險，看下面的例子：



```c
class Filter
{
public:
    Filter(int divisorVal):
        divisor{divisorVal}
    {}

    std::function<bool(int)> getFilter() 
    {
        return [=](int value) {return value % divisor == 0; };
    }

private:
    int divisor;
};
```



這個類中有一個成員方法，可以返回一個lambda表達式，這個表達式使用了類的數據成員divisor。而且採用預設值方式捕捉所有變數。你可能認為這個lambda表達式也捕捉了divisor的一份副本，但是實際上並沒有。因為數據成員divisor對lambda表達式並不可見，你可以用下面的程式碼驗證：



```c
// 類的方法，下面無法編譯，因為divisor並不在lambda捕捉的範圍
std::function<bool(int)> getFilter() 
{
    return [divisor](int value) {return value % divisor == 0; };
}
```



原程式碼中，lambda表達式實際上捕捉的是this指標的副本，所以原來的程式碼等價於：



```c
std::function<bool(int)> getFilter() {    return [this](int value) {return value % this->divisor == 0; };}
```



儘管還是以值方式捕獲，但是捕獲的是指標，其實相當於以參照的方式捕獲了當前類物件，**所以lambda表達式的閉包與一個類物件綁定在一起了，這很危險，因為你仍然有可能在類物件解構後使用這個lambda表達式**，那麼類似“懸掛參照”的問題也會產生。所以，**採用預設值捕捉所有變數仍然是不安全的**，主要是由於指標變數的複製，實際上還是按參照傳值。



lambda表達式可以賦值給對應型別的函式指標。但是使用函式指標並不是那麼方便。所以STL定義在< functional >頭檔案提供了一個多型的函式物件封裝std::function，其類似於函式指標。它可以綁定任何類函式物件，只要參數與返回型別相同。如下面的返回一個bool且接收兩個int的函式包裝器：



```c
std::function<bool(int, int)> wrapper = [](int x, int y) { return x < y; };
```



lambda表達式一個更重要的應用是其可以用於函式的參數，通過這種方式可以實現回呼函式。



最常用的是在STL演演算法中，比如你要統計一個陣列中滿足特定條件的元素數量，通過lambda表達式給出條件，傳遞給count_if函式：



```c
int value = 3;
vector<int> v {1, 3, 5, 2, 6, 10};
int count = std::count_if(v.beigin(), v.end(), [value](int x) { return x > value; });
```



再比如你想生成斐波那契數列，然後保存在陣列中，此時你可以使用generate函式，並輔助lambda表達式：



```cpp
vector<int> v(10);
int a = 0;
int b = 1;
std::generate(v.begin(), v.end(), 
              [&a, &b] { int value = b; b = b + a; a = value; return value; });
// 此時v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}
```



當需要走訪容器並對每個元素進行操作時：



```c
std::vector<int> v = { 1, 2, 3, 4, 5, 6 };
int even_count = 0;
for_each(v.begin(), v.end(), [&even_count](int val){
    if(!(val & 1)){
        ++ even_count;
    }
});
std::cout << "The number of even is " << even_count << std::endl;
```



大部分STL演演算法，可以非常靈活地搭配lambda表達式來實現想要的效果。



# C++ std::function



std::function是一個函式物件的包裝器，std::function的實體可以存儲，複製和調用任何可調用的目標，包括：



1.  函式。 
2.  lamada表達式。 

1.  綁定表達式或其他函式物件。 
2.  指向成員函式和指向數據成員的指標。 



當`std::function`物件沒有初始化任何實際的可調用元素，調用`std::function`物件將拋出`std::bad_function_call`異常。



## std::function簡介



類模版std::function是一種通用、多型的函式封裝。std::function的實體可以對任何可以調用的目標實體進行存儲、複製、和調用操作，這些目標實體包括普通函式、Lambda表達式、函式指標、以及其它函式物件等。std::function物件是對C++中現有的可調用實體的一種型別安全的包裹（我們知道像函式指標這類可調用實體，是型別不安全的）。



**通常std::function是一個函式物件類，它包裝其它任意的函式物件，被包裝的函式物件具有型別為T1, …,TN的N個參數，並且返回一個可轉換到R型別的值**。std::function使用 樣板轉換建構函式接收被包裝的函式物件；特別是，閉包型別可以隱式地轉換為std::function。



C++標準庫詳細說明了這個的基本使用http://www.cplusplus.com/reference/functional/function/.



這裡我們大概總結一下。



### Member types

| 成員型別             | 說明                                                   |
| -------------------- | ------------------------------------------------------ |
| result_type          | 返回型別                                               |
| argument_type        | 如果函式物件只有一個參數，那麼這個代表參數型別。       |
| first_argument_type  | 如果函式物件有兩個個參數，那麼這個代表第一個參數型別。 |
| second_argument_type | 如果函式物件有兩個個參數，那麼這個代表第二個參數型別。 |



### Member functions

| 成員函式聲明  | 說明                                              |
| ------------- | ------------------------------------------------- |
| constructor   | 建構函式：constructs a new std::function instance |
| destructor    | 解構函式： destroys a std::function instance      |
| operator=     | 給定義的function物件賦值                          |
| operator bool | 檢查定義的function物件是否包含一個有效的物件      |
| operator()    | 調用一個物件                                      |



## std::function使用



封裝普通函式例子：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;int TestFunc(int a)  {      return a;  }int main(){    Functional obj = TestFunc;        int res = obj(1);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝lambda表達式 ：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;auto lambda = [](int a)->int{return a;};int main(){    Functional obj = lambda;        res = obj(2);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝仿函式：



```c
#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;class Functor{public:    int operator()(int a)    {        return a;    }};int main(){    Functor func;    Functional obj = func;    res = obj(3);    std::cout << res << std::endl;    while(1);    return 0;}
```



封裝類的成員函式和static成員函式 ：



```c
#include <iostream>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <string>
#include <algorithm>
#include <functional>
#include <memory>

using namespace std;

typedef std::function<int(int)> Functional;

class CTest
{
public:
    int Func(int a)
    {
        return a;
    }
    static int SFunc(int a)
    {
        return a;
    }
};

int main()
{
    CTest t;  
    obj = std::bind(&CTest::Func, &t, std::placeholders::_1);  
    res = obj(3);  
    cout << "member function : " << res << endl;  
  
    obj = CTest::SFunc;  
    res = obj(4);  
    cout << "static member function : " << res << endl;  

    while(1);
    return 0;
}
```



關於可調用實體轉換為std::function物件需要遵守以下兩條原則：



1. 轉換後的std::function物件的參數能轉換為可調用實體的參數；
2. 可調用實體的回傳值能轉換為std::function物件的回傳值。



**std::function物件最大的用處就是在實現函式回呼**，使用者需要注意，**它不能被用來檢查相等或者不相等，但是可以與NULL或者nullptr進行比較。**



**為什麼要用std::function？**



好用並實用的東西才會加入標準的。因為好用，實用，我們才在專案中使用它。std::function實現了一套型別消除機制，可以統一處理不同的函式物件型別。以前我們使用函式指標來完成這些；現在我們可以使用更安全的std::function來完成這些任務。



參考文件：

 

[C++ std::function技術淺談](https://blog.csdn.net/xiangbaohui/article/details/106741654)

# 

# 右值參照和move語義



先看一個簡單的例子直觀感受下：



```c
string a(x);                                    // line 1
string b(x + y);                                    // line 2
string c(some_function_returning_a_string());       // line 3
```



如果使用以下複製建構函式：



```c
string(const string& that)
{
    size_t size = strlen(that.data) + 1;
    data = new char[size];
    memcpy(data, that.data, size);
}
```



以上3行中，只有第一行(line 1)的x深度複製是有必要的，因為我們可能會在後邊用到x，x是一個左值(lvalues)。



第二行和第三行的參數則是右值，因為表達式產生的string物件是匿名物件，之後沒有辦法再使用了。



C++ 11引入了一種新的機制叫做“右值參照”，以便我們通過多載直接使用右值參數。我們所要做的就是寫一個以右值參照為參數的建構函式：



```c
string(string&& that)   // string&& is an rvalue reference to a string
{
data = that.data;
that.data = 0;
}
```



我們沒有深度複製堆記憶體中的數據，而是僅僅複製了指標，並把源物件的指標置空。事實上，我們“偷取”了屬於源物件的記憶體數據。由於源物件是一個右值，不會再被使用，因此客戶並不會覺察到源物件被改變了。在這裡，我們並沒有真正的複製，所以我們把這個建構函式叫做“轉移建構函式”（move constructor），他的工作就是把資源從一個物件轉移到另一個物件，而不是複製他們。



有了右值參照，再來看看賦值操作符：



```c
string& operator=(string that)
{
std::swap(data, that.data);
return *this;
}
```



注意到我們是直接對參數that傳值，所以that會像其他任何物件一樣被初始化，那麼確切的說，that是怎樣被初始化的呢？對於C++ 98，答案是複製建構函式，**但是對於C++ 11，編譯器會依據參數是左值還是右值在複製建構函式和轉移建構函式間進行選擇。**



如果是a=b，這樣就會調用複製建構函式來初始化that（因為b是左值），賦值操作符會與新創建的物件交換數據，深度複製。這就是copy and swap 慣用法的定義：建構一個副本，與副本交換數據，並讓副本在作用域內自動銷燬。這裡也一樣。



如果是a = x + y，這樣就會調用轉移建構函式來初始化that（因為x+y是右值），所以這裡沒有深度複製，只有高效的數據轉移。相對於參數，that依然是一個獨立的物件，但是他的建構函式是無用的（trivial），因此堆中的數據沒有必要複製，而僅僅是轉移。沒有必要複製他，因為x+y是右值，再次，從右值指向的物件中轉移是沒有問題的。



總結一下：複製建構函式執行的是深度複製，因為源物件本身必須不能被改變。而轉移建構函式卻可以複製指標，把源物件的指標置空，這種形式下，這是安全的，因為用戶不可能再使用這個物件了。



下面我們進一步討論右值參照和move語義。



C98標準庫中提供了一種唯一擁有性的智慧指標`std::auto_ptr`，**該型別在C11中已被廢棄**，因為其“複製”行為是危險的。



```c
auto_ptr<Shape> a(new Triangle);auto_ptr<Shape> b(a);
```



注意b是怎樣使用a進行初始化的，它不復制triangle，而是把triangle的所有權從a傳遞給了b，也可以說成“a 被轉移進了b”或者“triangle被從a轉移到了b”。



auto_ptr 的複製建構函式可能看起來像這樣（簡化）：



```c
auto_ptr(auto_ptr& source)   // note the missing const
{
p = source.p;
source.p = 0;   // now the source no longer owns the object
}
```



auto_ptr 的危險之處在於看上去應該是複製，但實際上確是轉移。調用被轉移過的auto_ptr 的成員函式將會導致不可預知的後果。所以你必須非常謹慎的使用auto_ptr ，如果他被轉移過。



```c
auto_ptr<Shape> make_triangle()
{
    return auto_ptr<Shape>(new Triangle);
}

auto_ptr<Shape> c(make_triangle());      // move temporary into c
double area = make_triangle()->area();   // perfectly safe

auto_ptr<Shape> a(new Triangle);    // create triangle
auto_ptr<Shape> b(a);               // move a into b
double area = a->area();                // undefined behavior
```



顯然，在持有auto_ptr 物件的a表達式和持有調用函式返回的auto_ptr值型別的make_triangle()表達式之間一定有一些潛在的區別，每調用一次後者就會創建一個新的auto_ptr物件。這裡a 其實就是一個左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。



轉移像a這樣的左值是非常危險的，因為我們可能調用a的成員函式，這會導致不可預知的行為。另一方面，轉移像make_triangle()這樣的右值卻是非常安全的，因為複製建構函式之後，我們不能再使用這個臨時物件了，因為這個轉移後的臨時物件會在下一行之前銷燬掉。



我們現在知道轉移左值是十分危險的，但是轉移右值卻是很安全的。如果C++能從語言級別支援區分左值和右值參數，我就可以完全杜絕對左值轉移，或者把轉移左值在調用的時候暴露出來，以使我們不會不經意的轉移左值。



C++ 11對這個問題的答案是右值參照。右值參照是針對右值的新的參照型別，語法是X&&。以前的老的參照型別X& 現在被稱作左值參照。



使用右值參照X&&作為參數的最有用的函式之一就是轉移建構函式X::X(X&& source)，它的主要作用是把源物件的本地資源轉移給當前物件。



C++ 11中，std::auto_ptr< T >已經被std::unique_ptr< T >所取代，後者就是利用的右值參照。



其轉移建構函式：



```c
unique_ptr(unique_ptr&& source)   // note the rvalue reference
{
    ptr = source.ptr;
    source.ptr = nullptr;
}
```



這個轉移建構函式跟auto_ptr中複製建構函式做的事情一樣，但是它卻只能接受右值作為參數。



```c
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);                 // error
unique_ptr<Shape> c(make_triangle());       // okay
```



第二行不能編譯通過，因為a是左值，但是參數unique_ptr&& source只能接受右值，這正是我們所需要的，杜絕危險的隱式轉移。第三行編譯沒有問題，因為make_triangle()是右值，轉移建構函式會將臨時物件的所有權轉移給物件c，這正是我們需要的。



## 轉移左值



有時候，我們可能想轉移左值，也就是說，有時候我們想讓編譯器把左值當作右值對待，以便能使用轉移建構函式，即便這有點不安全。出於這個目的，C++ 11在標準庫的頭檔案< utility >中提供了一個樣板函式std::move。實際上，std::move僅僅是簡單地將左值轉換為右值，它本身並沒有轉移任何東西。它僅僅是讓物件可以轉移。



以下是如何正確的轉移左值：



```c
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);              // still an error
unique_ptr<Shape> c(std::move(a));   // okay
```



請注意，第三行之後，a不再擁有Triangle物件。不過這沒有關係，因為通過明確的寫出std::move(a)，我們很清楚我們的意圖：親愛的轉移建構函式，你可以對a做任何想要做的事情來初始化c；我不再需要a了，對於a，您請自便。



當然，如果你在使用了mova(a)之後，還繼續使用a，那無疑是搬起石頭砸自己的腳，還是會導致嚴重的運行錯誤。



總之，std::move(some_lvalue)將左值轉換為右值（可以理解為一種型別轉換），使接下來的轉移成為可能。



一個例子：



```c
class Foo
{
    unique_ptr<Shape> member;

public:
    Foo(unique_ptr<Shape>&& parameter)
    : member(parameter)   // error
    {}

};
```



上面的parameter，其型別是一個右值參照，只能說明parameter是指向右值的參照，而parameter本身是個左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）



因此以上對parameter的轉移是不允許的，需要使用`std::move`來顯示轉換成右值。
