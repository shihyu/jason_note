# ğŸ” å¤šåŸ·è¡Œç·’é–æ©Ÿåˆ¶å®Œå…¨æŒ‡å—

> ç”¨ç™½è©±å’Œç¤ºæ„åœ–ç†è§£æ‰€æœ‰å¸¸è¦‹çš„é–æ©Ÿåˆ¶

---

## ğŸ“š ç›®éŒ„

1. [ç„¡é–æ©Ÿåˆ¶ (Lock-Free)](#1-ç„¡é–æ©Ÿåˆ¶-lock-free)
2. [äº’æ–¥é– (Mutex)](#2-äº’æ–¥é–-mutex)
3. [è‡ªæ—‹é– (Spinlock)](#3-è‡ªæ—‹é–-spinlock)
4. [è®€å¯«é– (Read-Write Lock)](#4-è®€å¯«é–-read-write-lock)
5. [éè¿´é– (Recursive Lock)](#5-éè¿´é–-recursive-lock)
6. [æ¢ä»¶è®Šæ•¸ (Condition Variable)](#6-æ¢ä»¶è®Šæ•¸-condition-variable)
7. [ä¿¡è™Ÿé‡ (Semaphore)](#7-ä¿¡è™Ÿé‡-semaphore)
8. [æŸµæ¬„ (Barrier)](#8-æŸµæ¬„-barrier)
9. [é †åºé– (Seqlock)](#9-é †åºé–-seqlock)
10. [æ•ˆèƒ½æ¯”è¼ƒç¸½è¡¨](#10-æ•ˆèƒ½æ¯”è¼ƒç¸½è¡¨)

---

## 1. ç„¡é–æ©Ÿåˆ¶ (Lock-Free)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒä¸€å€‹ã€Œæ—‹è½‰å£½å¸å°ã€ï¼š
- **ç”Ÿç”¢è€…** = å»šå¸«æ”¾å£½å¸
- **æ¶ˆè²»è€…** = å®¢äººæ‹¿å£½å¸
- **ä¸éœ€è¦æœå‹™ç”Ÿå”èª¿**ï¼ˆä¸éœ€è¦é–ï¼‰

### ğŸ“Š ç¤ºæ„åœ–

```
ç’°ç‹€ç·©è¡å€ï¼ˆSPSC Queueï¼‰
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â†‘       â†‘
  è®€      å¯«

ç”Ÿç”¢è€…ï¼ˆå»šå¸«ï¼‰         æ¶ˆè²»è€…ï¼ˆå®¢äººï¼‰
åªæ”¹å¯«å…¥ä½ç½®   â†â†’     åªæ”¹è®€å–ä½ç½®
äº’ä¸å¹²æ“¾ï¼
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
template<typename T>
class LockFreeQueue {
    std::vector<T> buffer_;
    std::atomic<size_t> next_write_index_{0};  // åŸå­è®Šæ•¸
    std::atomic<size_t> next_read_index_{0};
    
public:
    void push(T data) {
        size_t write_pos = next_write_index_.load(std::memory_order_relaxed);
        buffer_[write_pos] = data;
        next_write_index_.store(write_pos + 1, std::memory_order_release);
    }
    
    bool pop(T& data) {
        size_t read_pos = next_read_index_.load(std::memory_order_relaxed);
        size_t write_pos = next_write_index_.load(std::memory_order_acquire);
        
        if (read_pos == write_pos) return false;  // ä½‡åˆ—ç©º
        
        data = buffer_[read_pos];
        next_read_index_.store(read_pos + 1, std::memory_order_release);
        return true;
    }
};
```

### âœ… å„ªé»
- **è¶…å¿«é€Ÿ**ï¼šæ²’æœ‰ Context Switch
- **ç„¡æ­»é–**ï¼šæ²’æœ‰é–å°±ä¸æœƒå¡ä½
- **ä½å»¶é²**ï¼šé©åˆå³æ™‚ç³»çµ±

### âŒ ç¼ºé»
- **é™åˆ¶å¤š**ï¼šé€šå¸¸åªæ”¯æ´ SPSCï¼ˆå–®ç”Ÿç”¢è€…å–®æ¶ˆè²»è€…ï¼‰
- **è¤‡é›œåº¦é«˜**ï¼šéœ€è¦ç†è§£è¨˜æ†¶é«”é †åºï¼ˆMemory Orderï¼‰
- **é™¤éŒ¯å›°é›£**ï¼šéŒ¯èª¤ä¸æ˜“é‡ç¾

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- éŸ³è¨Šè™•ç†ç®¡ç·š
- é«˜é »äº¤æ˜“ç³»çµ±
- ç¶²è·¯å°åŒ…è™•ç†

---

## 2. äº’æ–¥é– (Mutex)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒä¸€å€‹ã€Œå…¬å…±å»æ‰€ã€ï¼š
- **åªæœ‰ä¸€æŠŠé‘°åŒ™**ï¼ˆé–ï¼‰
- **èª°æ‹¿åˆ°é‘°åŒ™èª°é€²å»**
- **å…¶ä»–äººåœ¨å¤–é¢æ’éšŠç­‰**

### ğŸ“Š ç¤ºæ„åœ–

```
æ™‚é–“è»¸ï¼š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â†’

åŸ·è¡Œç·’ A:  [å–å¾—é–]â”€â”€â”€åŸ·è¡Œä¸­â”€â”€â”€[é‡‹æ”¾é–]
åŸ·è¡Œç·’ B:            [ç­‰å¾…......]  [å–å¾—é–]â”€â”€â”€åŸ·è¡Œä¸­â”€â”€â”€
åŸ·è¡Œç·’ C:                          [ç­‰å¾…..................]

ç‹€æ…‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«è³‡æº    â”‚
â”‚ (counter)   â”‚  â† åªæœ‰æ‹¿åˆ°é–çš„åŸ·è¡Œç·’èƒ½å­˜å–
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†‘
      ğŸ”’ Mutex
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <mutex>

class BankAccount {
    int balance_ = 0;
    std::mutex mutex_;  // ä¿è­· balance_
    
public:
    void deposit(int amount) {
        std::lock_guard<std::mutex> lock(mutex_);  // è‡ªå‹•åŠ é–
        balance_ += amount;
        // é›¢é–‹ä½œç”¨åŸŸè‡ªå‹•è§£é–
    }
    
    void withdraw(int amount) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (balance_ >= amount) {
            balance_ -= amount;
        }
    }
    
    int get_balance() {
        std::lock_guard<std::mutex> lock(mutex_);
        return balance_;
    }
};
```

### ğŸ”„ é‹ä½œæµç¨‹

```
åŸ·è¡Œç·’ A æƒ³è¦ä¿®æ”¹ balance_ï¼š

1. åŸ·è¡Œåˆ° lock_guard
   â†“
2. å˜—è©¦å–å¾— mutex_
   â”œâ”€ æˆåŠŸ â†’ ç¹¼çºŒåŸ·è¡Œ
   â””â”€ å¤±æ•— â†’ é€²å…¥ç¡çœ ï¼Œç­‰ä½œæ¥­ç³»çµ±å–šé†’
   
3. åŸ·è¡Œ balance_ += amount
   
4. é›¢é–‹ {} ä½œç”¨åŸŸ
   â†“
5. è‡ªå‹•é‡‹æ”¾ mutex_
   â†“
6. ä½œæ¥­ç³»çµ±å–šé†’ç­‰å¾…ä¸­çš„åŸ·è¡Œç·’
```

### âœ… å„ªé»
- **ç°¡å–®æ˜“ç”¨**ï¼šæœ€åŸºæœ¬çš„åŒæ­¥æ©Ÿåˆ¶
- **ä¿è­‰äº’æ–¥**ï¼šçµ•å°ä¸æœƒæœ‰å…©å€‹åŸ·è¡Œç·’åŒæ™‚åŸ·è¡Œ
- **è‡ªå‹•ç®¡ç†**ï¼šæ­é… RAIIï¼ˆlock_guardï¼‰ä¸æœƒå¿˜è¨˜è§£é–

### âŒ ç¼ºé»
- **Context Switch é–‹éŠ·**ï¼šç­‰å¾…æ™‚æœƒç¡çœ 
- **å¯èƒ½æ­»é–**ï¼šäº’ç›¸ç­‰å¾…å°æ–¹çš„é–
- **ä¸å…¬å¹³**ï¼šç„¡æ³•ä¿è­‰å…ˆç­‰å¾…çš„å…ˆå–å¾—

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- éŠ€è¡Œè½‰å¸³ç³»çµ±
- è³‡æ–™åº«é€£ç·šæ± 
- ä»»ä½•éœ€è¦ä¿è­·å…±äº«è³‡æºçš„æƒ…å¢ƒ

---

## 3. è‡ªæ—‹é– (Spinlock)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œæ’éšŠè²·æ¼”å”±æœƒç¥¨ã€ï¼š
- **ä¸é›¢é–‹éšŠä¼**ï¼ˆä¸ç¡çœ ï¼‰
- **ä¸€ç›´ç›¯è‘—å”®ç¥¨å£**ï¼ˆä¸€ç›´æª¢æŸ¥ï¼‰
- **ç¥¨ä¸€é–‹è³£é¦¬ä¸Šè¡**ï¼ˆç«‹å³å–å¾—ï¼‰

### ğŸ“Š ç¤ºæ„åœ–

```
Mutexï¼ˆç¡çœ ç­‰å¾…ï¼‰ï¼š
åŸ·è¡Œç·’ B: [å˜—è©¦é–]â†’ ğŸ˜´ ç¡è¦º... â†’ è¢«å–šé†’ â†’ [å–å¾—é–]
                    ï¼ˆContext Switchï¼‰

Spinlockï¼ˆå¿™ç¢Œç­‰å¾…ï¼‰ï¼š
åŸ·è¡Œç·’ B: [å˜—è©¦é–]â†’ ğŸ”„ğŸ”„ğŸ”„ ä¸€ç›´æª¢æŸ¥... â†’ [å–å¾—é–]
                    ï¼ˆæ¶ˆè€— CPU ä½†ç„¡ Context Switchï¼‰

CPU ä½¿ç”¨ç‡ï¼š
Mutex:     â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–“â–“ (ç¡çœ æ™‚ä¸ä½”ç”¨)
Spinlock:  â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ (ä¸€ç›´ä½”ç”¨ CPU)
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <atomic>

class Spinlock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
    
public:
    void lock() {
        // ä¸€ç›´å˜—è©¦ç›´åˆ°æˆåŠŸ
        while (flag_.test_and_set(std::memory_order_acquire)) {
            // ç©ºè½‰ç­‰å¾…ï¼ˆå¯åŠ å…¥ CPU pause æŒ‡ä»¤å„ªåŒ–ï¼‰
            #ifdef __x86_64__
                __builtin_ia32_pause();  // x86 çš„ PAUSE æŒ‡ä»¤
            #endif
        }
    }
    
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};

// ä½¿ç”¨ç¯„ä¾‹
class Counter {
    int value_ = 0;
    Spinlock lock_;
    
public:
    void increment() {
        lock_.lock();
        ++value_;
        lock_.unlock();
    }
};
```

### ğŸ”„ é‹ä½œå°æ¯”

```
é—œéµæ™‚åˆ»åœ–ï¼š

Mutexï¼ˆç­‰å¾… 100 å¾®ç§’ï¼‰ï¼š
[åŸ·è¡Œ] â†’ [ç¡çœ  100Î¼s] â†’ [å–šé†’] â†’ [åŸ·è¡Œ]
         â†‘              â†‘
    Context Switch   Context Switch
    (~1-10 å¾®ç§’)     (~1-10 å¾®ç§’)

ç¸½æˆæœ¬ï¼š100 + 1 + 1 = 102 å¾®ç§’

Spinlockï¼ˆç­‰å¾… 5 å¾®ç§’ï¼‰ï¼š
[åŸ·è¡Œ] â†’ [ç©ºè½‰ 5Î¼s] â†’ [åŸ·è¡Œ]
         â†‘
    æ²’æœ‰ Context Switchï¼

ç¸½æˆæœ¬ï¼š5 å¾®ç§’ï¼ˆä½† CPU ä¸€ç›´å¿™ç¢Œï¼‰
```

### âœ… å„ªé»
- **ä½å»¶é²**ï¼šç„¡ Context Switch
- **é©åˆçŸ­è‡¨ç•Œå€**ï¼šé–å®šæ™‚é–“ < 1 å¾®ç§’æ™‚å¾ˆå¿«
- **ç°¡å–®å¯¦ä½œ**ï¼šåªéœ€è¦åŸå­æ“ä½œ

### âŒ ç¼ºé»
- **æµªè²» CPU**ï¼šç­‰å¾…æ™‚ä¸€ç›´æ¶ˆè€— CPU
- **å¯èƒ½æ´»é–**ï¼šå„ªå…ˆæ¬Šåè½‰å•é¡Œ
- **ä¸é©åˆé•·æ™‚é–“é–å®š**ï¼šæœƒè®“å…¶ä»–åŸ·è¡Œç·’é¤“æ­»

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- ä½œæ¥­ç³»çµ±æ ¸å¿ƒï¼ˆKernelï¼‰
- ä¸­æ–·è™•ç†ç¨‹åº
- éå¸¸çŸ­çš„è‡¨ç•Œå€ï¼ˆ< 100 å¥ˆç§’ï¼‰

---

## 4. è®€å¯«é– (Read-Write Lock)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒä¸€å€‹ã€Œåœ–æ›¸é¤¨ã€ï¼š
- **è®€è€…**ï¼šå¾ˆå¤šäººå¯ä»¥åŒæ™‚çœ‹æ›¸ï¼ˆå…±äº«ï¼‰
- **ä½œè€…**ï¼šåªèƒ½ä¸€å€‹äººå¯«æ›¸ï¼Œå¯«çš„æ™‚å€™ä¸èƒ½è®€ï¼ˆç¨ä½”ï¼‰

### ğŸ“Š ç¤ºæ„åœ–

```
æ™‚é–“è»¸ï¼š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â†’

è®€è€… A:  [è®€å–â”€â”€â”€â”€â”€â”€â”€â”€]
è®€è€… B:    [è®€å–â”€â”€â”€â”€â”€â”€]     â† å¯ä»¥åŒæ™‚è®€
è®€è€… C:      [è®€å–â”€â”€â”€â”€]

å¯«è€… X:               [ç­‰å¾…] [å¯«å…¥] â† ç­‰æ‰€æœ‰è®€è€…çµæŸ
è®€è€… D:                      [ç­‰å¾…] [è®€å–] â† ç­‰å¯«è€…çµæŸ

ç‹€æ…‹è¡¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è®€æ¨¡å¼    â”‚   è®€æ¨¡å¼    â”‚   å¯«æ¨¡å¼    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¤šäººå¯è®€    â”‚ â† åˆ‡æ› â†’    â”‚ åªæœ‰ä¸€äºº    â”‚
â”‚ ç„¡äººå¯å¯«    â”‚             â”‚ ç„¡äººå¯è®€å¯«  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <shared_mutex>

class ThreadSafeCache {
    std::map<std::string, std::string> cache_;
    mutable std::shared_mutex mutex_;  // C++17
    
public:
    // è®€å–ï¼ˆå…±äº«é–ï¼‰
    std::string get(const std::string& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);  // å…±äº«é–
        auto it = cache_.find(key);
        return it != cache_.end() ? it->second : "";
    }
    
    // å¯«å…¥ï¼ˆç¨ä½”é–ï¼‰
    void set(const std::string& key, const std::string& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);  // ç¨ä½”é–
        cache_[key] = value;
    }
    
    // æª¢æŸ¥å­˜åœ¨ï¼ˆå…±äº«é–ï¼‰
    bool contains(const std::string& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return cache_.find(key) != cache_.end();
    }
};
```

### ğŸ”„ åŸ·è¡Œæµç¨‹

```
å ´æ™¯ï¼š5 å€‹è®€è€…ï¼Œ1 å€‹å¯«è€…

æ­¥é©Ÿ 1: è®€è€… A, B, C åŒæ™‚è®€å–
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«è³‡æº    â”‚
â”‚ (Data)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†‘   â†‘   â†‘
  A   B   C    â† å…±äº«é–ï¼Œå¯ä»¥åŒæ™‚è®€

æ­¥é©Ÿ 2: å¯«è€… X å˜—è©¦å¯«å…¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«è³‡æº    â”‚
â”‚ (Data)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†‘   â†‘   â†‘
  A   B   C    â† é‚„åœ¨è®€
      â° X     â† ç­‰å¾…ä¸­ï¼ˆç„¡æ³•å–å¾—ç¨ä½”é–ï¼‰

æ­¥é©Ÿ 3: æ‰€æœ‰è®€è€…çµæŸï¼Œå¯«è€…é–‹å§‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«è³‡æº    â”‚
â”‚ (Data)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†‘
      X        â† ç¨ä½”é–ï¼Œåªæœ‰å®ƒèƒ½å­˜å–

æ­¥é©Ÿ 4: å¯«è€…çµæŸï¼Œæ–°è®€è€…é€²å…¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«è³‡æº    â”‚
â”‚ (Data)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†‘   â†‘
  D   E        â† æ–°çš„è®€è€…å¯ä»¥åŒæ™‚è®€
```

### âœ… å„ªé»
- **è®€å–æ•ˆèƒ½é«˜**ï¼šå¤šå€‹è®€è€…ä¸äº’æ–¥
- **é©åˆè®€å¤šå¯«å°‘**ï¼šå¦‚å¿«å–ç³»çµ±
- **å…¬å¹³æ€§å¯èª¿**ï¼šå¯å„ªå…ˆè®€è€…æˆ–å¯«è€…

### âŒ ç¼ºé»
- **å¯«è€…å¯èƒ½é¤“æ­»**ï¼šè®€è€…ä¸æ–·é€²å…¥
- **å¯¦ä½œè¤‡é›œ**ï¼šéœ€è¦å…©ç¨®é–ç‹€æ…‹
- **é¡å¤–é–‹éŠ·**ï¼šæ¯”æ™®é€š Mutex æ…¢

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- å¿«å–ç³»çµ±ï¼ˆRedis, Memcachedï¼‰
- çµ„æ…‹æª”è®€å–
- è³‡æ–™åº«ç´¢å¼•

---

## 5. éè¿´é– (Recursive Lock)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œä¿„ç¾…æ–¯å¨ƒå¨ƒã€ï¼š
- **åŒä¸€å€‹äººå¯ä»¥å¤šæ¬¡é–‹é–€**ï¼ˆåŒä¸€åŸ·è¡Œç·’å¯å¤šæ¬¡åŠ é–ï¼‰
- **ä½†è¦è¨˜å¾—é–‹å¹¾æ¬¡å°±è¦é—œå¹¾æ¬¡**

### ğŸ“Š ç¤ºæ„åœ–

```
æ™®é€š Mutexï¼ˆæœƒæ­»é–ï¼‰ï¼š
void funcA() {
    mutex.lock();         // âœ… ç¬¬ä¸€æ¬¡åŠ é–æˆåŠŸ
    // ...
    funcB();              // å‘¼å« funcB
}

void funcB() {
    mutex.lock();         // âŒ æ­»é–ï¼åŒä¸€åŸ·è¡Œç·’å˜—è©¦å†æ¬¡åŠ é–
    // ...
    mutex.unlock();
}

éè¿´é–ï¼ˆå¯ä»¥é‡å…¥ï¼‰ï¼š
void funcA() {
    recursive_mutex.lock();  // âœ… è¨ˆæ•¸ = 1
    // ...
    funcB();
}

void funcB() {
    recursive_mutex.lock();  // âœ… è¨ˆæ•¸ = 2ï¼ˆåŒä¸€åŸ·è¡Œç·’ï¼‰
    // ...
    recursive_mutex.unlock(); // è¨ˆæ•¸ = 1
}
// funcA çµæŸæ™‚ unlock()     // è¨ˆæ•¸ = 0ï¼ˆçœŸæ­£é‡‹æ”¾ï¼‰

é–è¨ˆæ•¸å™¨ï¼š
åŸ·è¡Œä½ç½®         | lock() æ¬¡æ•¸ | unlock() æ¬¡æ•¸ | è¨ˆæ•¸å™¨
----------------|------------|--------------|-------
é€²å…¥ funcA       |     1      |      0       |   1
é€²å…¥ funcB       |     2      |      0       |   2
é›¢é–‹ funcB       |     2      |      1       |   1
é›¢é–‹ funcA       |     2      |      2       |   0  â† é‡‹æ”¾
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <mutex>

class FileSystem {
    std::recursive_mutex mutex_;
    std::string root_path_;
    
public:
    void createDirectory(const std::string& path) {
        std::lock_guard<std::recursive_mutex> lock(mutex_);
        
        // å»ºç«‹çˆ¶ç›®éŒ„ï¼ˆéè¿´å‘¼å«ï¼‰
        auto parent = getParentPath(path);
        if (!parent.empty()) {
            ensureDirectoryExists(parent);  // æœƒå†æ¬¡åŠ é–ï¼
        }
        
        // å»ºç«‹ç›®éŒ„
        mkdir(path.c_str(), 0755);
    }
    
    void ensureDirectoryExists(const std::string& path) {
        std::lock_guard<std::recursive_mutex> lock(mutex_);  // é‡å…¥é–
        
        if (!exists(path)) {
            createDirectory(path);  // åˆå‘¼å«å›å»äº†ï¼
        }
    }
};
```

### ğŸ”„ å‘¼å«å †ç–Šç¯„ä¾‹

```
å‘¼å«éç¨‹ï¼š
createDirectory("/a/b/c/d")
  â”œâ”€ lock()  [è¨ˆæ•¸=1]
  â”œâ”€ ensureDirectoryExists("/a/b/c")
  â”‚    â”œâ”€ lock()  [è¨ˆæ•¸=2]  â† åŒä¸€åŸ·è¡Œç·’ï¼Œå…è¨±ï¼
  â”‚    â”œâ”€ createDirectory("/a/b/c")
  â”‚    â”‚    â”œâ”€ lock()  [è¨ˆæ•¸=3]
  â”‚    â”‚    â”œâ”€ ensureDirectoryExists("/a/b")
  â”‚    â”‚    â”‚    â””â”€ lock()  [è¨ˆæ•¸=4]
  â”‚    â”‚    â”‚    â””â”€ unlock() [è¨ˆæ•¸=3]
  â”‚    â”‚    â””â”€ unlock() [è¨ˆæ•¸=2]
  â”‚    â””â”€ unlock() [è¨ˆæ•¸=1]
  â””â”€ unlock() [è¨ˆæ•¸=0]  â† çœŸæ­£é‡‹æ”¾
```

### âœ… å„ªé»
- **å…è¨±é‡å…¥**ï¼šéè¿´å‡½å¼ä¸æœƒæ­»é–
- **ç°¡åŒ–è¨­è¨ˆ**ï¼šä¸éœ€è¿½è¹¤æ˜¯å¦å·²åŠ é–
- **ç›¸å®¹ OOP**ï¼šç‰©ä»¶æ–¹æ³•äº’ç›¸å‘¼å«æ–¹ä¾¿

### âŒ ç¼ºé»
- **æ•ˆèƒ½è¼ƒå·®**ï¼šéœ€è¦è¨˜éŒ„æ“æœ‰è€…å’Œè¨ˆæ•¸
- **å®¹æ˜“èª¤ç”¨**ï¼šéš±è—è¨­è¨ˆå•é¡Œ
- **è¨˜æ†¶é«”é–‹éŠ·**ï¼šéœ€è¦é¡å¤–å„²å­˜è³‡è¨Š

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- æ¨¹ç‹€çµæ§‹éæ­·
- éè¿´æ¼”ç®—æ³•
- è¤‡é›œç‰©ä»¶æ–¹æ³•å‘¼å«

---

## 6. æ¢ä»¶è®Šæ•¸ (Condition Variable)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œé¤å»³å«è™Ÿç³»çµ±ã€ï¼š
- **å®¢äººæ‹¿è™Ÿç¢¼ç‰Œç­‰å¾…**ï¼ˆwaitï¼‰
- **å»šå¸«åšå¥½é¤é»é€šçŸ¥**ï¼ˆnotifyï¼‰
- **è¢«å«åˆ°è™Ÿç¢¼çš„å»å–é¤**ï¼ˆè¢«å–šé†’ï¼‰

### ğŸ“Š ç¤ºæ„åœ–

```
ç”Ÿç”¢è€…-æ¶ˆè²»è€…æ¨¡å‹ï¼š

ç”Ÿç”¢è€…åŸ·è¡Œç·’ï¼š                æ¶ˆè²»è€…åŸ·è¡Œç·’ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”Ÿç”¢è³‡æ–™     â”‚              â”‚ ç­‰å¾…è³‡æ–™     â”‚
â”‚   â†“         â”‚              â”‚   â†“         â”‚
â”‚ lock()      â”‚              â”‚ lock()      â”‚
â”‚   â†“         â”‚              â”‚   â†“         â”‚
â”‚ queue.push()â”‚              â”‚ while(empty)â”‚
â”‚   â†“         â”‚              â”‚   cv.wait() â”‚ â† é‡‹æ”¾é–ä¸¦ç¡çœ 
â”‚ cv.notify() â”‚ â”€â”€â”€â”€é€šçŸ¥â”€â”€â”€â†’ â”‚ (è¢«å–šé†’)    â”‚ â† é‡æ–°å–å¾—é–
â”‚   â†“         â”‚              â”‚   â†“         â”‚
â”‚ unlock()    â”‚              â”‚ queue.pop() â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â†“         â”‚
                             â”‚ unlock()    â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ™‚é–“åºåˆ—ï¼š
æ¶ˆè²»è€…: [lock]â†’[æª¢æŸ¥ç©º]â†’[wait ç¡çœ ......]â†’[è¢«å–šé†’]â†’[pop]â†’[unlock]
ç”Ÿç”¢è€…:                  [lock]â†’[push]â†’[notify]â†’[unlock]
                                        â†‘
                                    å–šé†’è¨Šè™Ÿ
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <condition_variable>
#include <mutex>
#include <queue>

template<typename T>
class BlockingQueue {
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
    
public:
    // ç”Ÿç”¢è€…ï¼šæ”¾å…¥è³‡æ–™
    void push(T value) {
        std::unique_lock<std::mutex> lock(mutex_);
        queue_.push(value);
        cv_.notify_one();  // é€šçŸ¥ä¸€å€‹ç­‰å¾…çš„æ¶ˆè²»è€…
    }
    
    // æ¶ˆè²»è€…ï¼šå–å‡ºè³‡æ–™ï¼ˆæœƒé˜»å¡ï¼‰
    T pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        
        // ç­‰å¾…ç›´åˆ°ä½‡åˆ—ä¸ç‚ºç©º
        cv_.wait(lock, [this] { return !queue_.empty(); });
        
        T value = queue_.front();
        queue_.pop();
        return value;
    }
    
    // å˜—è©¦å–å‡ºï¼ˆä¸é˜»å¡ï¼‰
    bool try_pop(T& value, std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        if (cv_.wait_for(lock, timeout, [this] { return !queue_.empty(); })) {
            value = queue_.front();
            queue_.pop();
            return true;
        }
        return false;  // é€¾æ™‚
    }
};
```

### ğŸ”„ è©³ç´°åŸ·è¡Œæµç¨‹

```
åˆå§‹ç‹€æ…‹ï¼šä½‡åˆ—ç©º

æ­¥é©Ÿ 1: æ¶ˆè²»è€… A å˜—è©¦ pop()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mutex_   â”‚ â† A å–å¾—
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ queue_   â”‚
â”‚ (ç©º)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ¶ˆè²»è€… A: "ä½‡åˆ—æ˜¯ç©ºçš„ï¼Œæˆ‘è¦ç­‰å¾…"
         cv_.wait() â†’ é‡‹æ”¾ mutex_ â†’ é€²å…¥ç¡çœ 

æ­¥é©Ÿ 2: ç”Ÿç”¢è€… B åŸ·è¡Œ push("è³‡æ–™")
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mutex_   â”‚ â† B å–å¾—ï¼ˆå› ç‚º A é‡‹æ”¾äº†ï¼‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ queue_   â”‚
â”‚ [è³‡æ–™]   â”‚ â† B æ”¾å…¥
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ç”Ÿç”¢è€… B: "é€šçŸ¥ç­‰å¾…çš„äºº"
         cv_.notify_one() â†’ å–šé†’ A
         é‡‹æ”¾ mutex_

æ­¥é©Ÿ 3: æ¶ˆè²»è€… A è¢«å–šé†’
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mutex_   â”‚ â† A é‡æ–°å–å¾—
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ queue_   â”‚
â”‚ [è³‡æ–™]   â”‚ â† A å–å‡º
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ¶ˆè²»è€… A: "æ‹¿åˆ°è³‡æ–™äº†ï¼"
         è¿”å› "è³‡æ–™"
         é‡‹æ”¾ mutex_
```

### âš ï¸ å¸¸è¦‹é™·é˜±ï¼šè™›å‡å–šé†’

```cpp
// âŒ éŒ¯èª¤å¯«æ³•ï¼ˆå¯èƒ½è™›å‡å–šé†’ï¼‰
cv_.wait(lock);
T value = queue_.front();  // å¯èƒ½ queue_ é‚„æ˜¯ç©ºçš„ï¼

// âœ… æ­£ç¢ºå¯«æ³•ï¼ˆç”¨ predicateï¼‰
cv_.wait(lock, [this] { return !queue_.empty(); });
T value = queue_.front();  // ä¿è­‰æœ‰è³‡æ–™

// ç­‰åƒ¹æ–¼ï¼š
while (queue_.empty()) {
    cv_.wait(lock);  // è¢«å–šé†’å¾Œé‡æ–°æª¢æŸ¥
}
```

### âœ… å„ªé»
- **é«˜æ•ˆç­‰å¾…**ï¼šä¸éœ€è¦å¿™ç¢Œè¼ªè©¢
- **è‡ªå‹•ç®¡ç†**ï¼šé…åˆ RAII ä¸æœƒå¿˜è¨˜è§£é–
- **æ”¯æ´é€¾æ™‚**ï¼šwait_for, wait_until

### âŒ ç¼ºé»
- **éœ€æ­é… Mutex**ï¼šä¸èƒ½å–®ç¨ä½¿ç”¨
- **è™›å‡å–šé†’**ï¼šéœ€è¦ç”¨ while è¿´åœˆ
- **æ•ˆèƒ½é–‹éŠ·**ï¼šç³»çµ±å‘¼å«

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- ç”Ÿç”¢è€…-æ¶ˆè²»è€…ä½‡åˆ—
- åŸ·è¡Œç·’æ± 
- äº‹ä»¶é€šçŸ¥ç³»çµ±

---

## 7. ä¿¡è™Ÿé‡ (Semaphore)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œåœè»Šå ´ã€ï¼š
- **æœ‰ N å€‹åœè»Šä½**ï¼ˆè³‡æºæ•¸é‡ï¼‰
- **è»Šé€²ä¾† â†’ å¯ç”¨è»Šä½ -1**ï¼ˆacquireï¼‰
- **è»Šå‡ºå» â†’ å¯ç”¨è»Šä½ +1**ï¼ˆreleaseï¼‰
- **è»Šä½æ»¿äº†å°±åœ¨å¤–é¢ç­‰**

### ğŸ“Š ç¤ºæ„åœ–

```
äºŒå…ƒä¿¡è™Ÿé‡ï¼ˆBinary Semaphoreï¼‰= Mutex
â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”‚ â† åˆå§‹å€¼
â””â”€â”€â”€â”€â”€â”˜

åŸ·è¡Œç·’ A:  acquire() â†’ 0 â†’ [åŸ·è¡Œ] â†’ release() â†’ 1
åŸ·è¡Œç·’ B:              â†‘ ç­‰å¾…ï¼ˆå€¼=0ï¼‰              â†‘ è¢«å–šé†’

è¨ˆæ•¸ä¿¡è™Ÿé‡ï¼ˆCounting Semaphoreï¼‰ï¼šè³‡æºæ± 
â”Œâ”€â”€â”€â”€â”€â”
â”‚  3  â”‚ â† æœ‰ 3 å€‹è³‡æº
â””â”€â”€â”€â”€â”€â”˜

åŸ·è¡Œç·’ A: acquire() â†’ 2
åŸ·è¡Œç·’ B: acquire() â†’ 1
åŸ·è¡Œç·’ C: acquire() â†’ 0
åŸ·è¡Œç·’ D: acquire() â†’ [é˜»å¡ï¼Œç­‰å¾…æœ‰äºº release()]

è¦–è¦ºåŒ–ï¼š
åœè»Šå ´ï¼ˆå®¹é‡ 3ï¼‰ï¼š
[ğŸš—] [ğŸš—] [ğŸš—]  â† æ»¿äº†ï¼ŒåŸ·è¡Œç·’ D åœ¨å¤–é¢ç­‰
 A    B    C

åŸ·è¡Œç·’ A é›¢é–‹ï¼š
[  ] [ğŸš—] [ğŸš—]  â† æœ‰ç©ºä½äº†ï¼åŸ·è¡Œç·’ D é€²ä¾†
     B    C
[ğŸš—]
 D
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <semaphore>  // C++20

// è³‡æ–™åº«é€£ç·šæ± ï¼ˆæœ€å¤š 5 å€‹é€£ç·šï¼‰
class ConnectionPool {
    std::counting_semaphore<5> semaphore_{5};  // åˆå§‹å€¼ 5
    std::vector<Connection*> connections_;
    std::mutex mutex_;
    
public:
    ConnectionPool() {
        // åˆå§‹åŒ– 5 å€‹é€£ç·š
        for (int i = 0; i < 5; ++i) {
            connections_.push_back(new Connection());
        }
    }
    
    // å–å¾—é€£ç·šï¼ˆæœƒé˜»å¡ç›´åˆ°æœ‰å¯ç”¨é€£ç·šï¼‰
    Connection* acquire() {
        semaphore_.acquire();  // å¯ç”¨æ•¸ -1ï¼ˆå¯èƒ½é˜»å¡ï¼‰
        
        std::lock_guard<std::mutex> lock(mutex_);
        Connection* conn = connections_.back();
        connections_.pop_back();
        return conn;
    }
    
    // æ­¸é‚„é€£ç·š
    void release(Connection* conn) {
        std::lock_guard<std::mutex> lock(mutex_);
        connections_.push_back(conn);
        
        semaphore_.release();  // å¯ç”¨æ•¸ +1ï¼ˆå–šé†’ç­‰å¾…è€…ï¼‰
    }
    
    // å˜—è©¦å–å¾—ï¼ˆä¸é˜»å¡ï¼‰
    Connection* try_acquire() {
        if (semaphore_.try_acquire()) {  // æˆåŠŸè¿”å› true
            std::lock_guard<std::mutex> lock(mutex_);
            Connection* conn = connections_.back();
            connections_.pop_back();
            return conn;
        }
        return nullptr;  // ç„¡å¯ç”¨é€£ç·š
    }
};

// ä½¿ç”¨ç¯„ä¾‹
void worker_thread(ConnectionPool& pool) {
    Connection* conn = pool.acquire();  // ç­‰å¾…å¯ç”¨é€£ç·š
    
    // ä½¿ç”¨é€£ç·šåŸ·è¡ŒæŸ¥è©¢
    conn->execute("SELECT * FROM users");
    
    pool.release(conn);  // æ­¸é‚„é€£ç·š
}
```

### ğŸ”„ åŸ·è¡Œæ™‚åº

```
å ´æ™¯ï¼š5 å€‹é€£ç·šçš„è³‡æ–™åº«æ± 

æ™‚åˆ» 0: ä¿¡è™Ÿé‡å€¼ = 5
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ 5 â”‚ æ‰€æœ‰é€£ç·šéƒ½å¯ç”¨
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

æ™‚åˆ» 1: åŸ·è¡Œç·’ A, B, C, D, E éƒ½ acquire()
ä¿¡è™Ÿé‡å€¼ = 0
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ é€£ç·šå…¨éƒ¨è¢«ä½”ç”¨
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

æ™‚åˆ» 2: åŸ·è¡Œç·’ F, G å˜—è©¦ acquire()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç­‰å¾…ä½‡åˆ—â”‚
â”‚   F     â”‚ â† é˜»å¡ä¸­
â”‚   G     â”‚ â† é˜»å¡ä¸­
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ™‚åˆ» 3: åŸ·è¡Œç·’ A release()
ä¿¡è™Ÿé‡å€¼ = 1 â†’ å–šé†’ F
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ F â”‚ B â”‚ C â”‚ D â”‚ E â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
ç­‰å¾…ä½‡åˆ—ï¼š[G]

æ™‚åˆ» 4: åŸ·è¡Œç·’ B release()
ä¿¡è™Ÿé‡å€¼ = 1 â†’ å–šé†’ G
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ F â”‚ G â”‚ C â”‚ D â”‚ E â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
```

### ğŸ†š Semaphore vs Mutex å°æ¯”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç‰¹æ€§      â”‚   Mutex      â”‚  Semaphore  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åˆå§‹å€¼      â”‚ 1 (unlocked) â”‚ N (å¯è¨­å®š)  â”‚
â”‚ èª°èƒ½é‡‹æ”¾    â”‚ åªæœ‰æ“æœ‰è€…   â”‚ ä»»ä½•åŸ·è¡Œç·’  â”‚
â”‚ ç”¨é€”        â”‚ äº’æ–¥å­˜å–     â”‚ è³‡æºè¨ˆæ•¸    â”‚
â”‚ å¯é‡å…¥      â”‚ éœ€ recursive â”‚ ä¸æ”¯æ´      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âœ… å„ªé»
- **é™åˆ¶ä¸¦è¡Œæ•¸**ï¼šæ§åˆ¶è³‡æºä½¿ç”¨
- **ç°¡å–®ç›´è§€**ï¼šæ¦‚å¿µå®¹æ˜“ç†è§£
- **å½ˆæ€§é«˜**ï¼šæ”¯æ´å¤šç¨®èªç¾©ï¼ˆäºŒå…ƒã€è¨ˆæ•¸ï¼‰

### âŒ ç¼ºé»
- **å®¹æ˜“èª¤ç”¨**ï¼šrelease ä¸ç•¶æœƒç ´å£è¨ˆæ•¸
- **ç„¡æ“æœ‰æ¬Šæ¦‚å¿µ**ï¼šä»»ä½•äººéƒ½èƒ½ release
- **é™¤éŒ¯å›°é›£**ï¼šä¿¡è™Ÿé‡æ´©æ¼é›£ä»¥è¿½è¹¤

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- é€£ç·šæ± ã€åŸ·è¡Œç·’æ± 
- é™æµå™¨ï¼ˆRate Limiterï¼‰
- è³‡æºæ± ç®¡ç†

---

## 8. æŸµæ¬„ (Barrier)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œåœ˜é«”æ—…éŠé›†åˆé»ã€ï¼š
- **æ‰€æœ‰äººéƒ½åˆ°äº†æ‰èƒ½ç¹¼çºŒ**
- **æ—©åˆ°çš„äººç­‰æ™šåˆ°çš„**
- **æœ€å¾Œä¸€äººåˆ°é” â†’ æ‰€æœ‰äººä¸€èµ·å‡ºç™¼**

### ğŸ“Š ç¤ºæ„åœ–

```
5 å€‹åŸ·è¡Œç·’ä½¿ç”¨ Barrier(5)ï¼š

åŸ·è¡Œç·’ 1:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â†’ [ç­‰å¾…....]
åŸ·è¡Œç·’ 2:  â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â†’ [ç­‰å¾…....]
åŸ·è¡Œç·’ 3:  â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç­‰å¾…....]
åŸ·è¡Œç·’ 4:  â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç­‰å¾…....]
åŸ·è¡Œç·’ 5:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â†’ [æœ€å¾Œåˆ°é”ï¼Œé‡‹æ”¾æ‰€æœ‰äººï¼]
                         â†“
åŸ·è¡Œç·’ 1:                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç¹¼çºŒåŸ·è¡Œ]
åŸ·è¡Œç·’ 2:                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç¹¼çºŒåŸ·è¡Œ]
åŸ·è¡Œç·’ 3:                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç¹¼çºŒåŸ·è¡Œ]
åŸ·è¡Œç·’ 4:                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç¹¼çºŒåŸ·è¡Œ]
åŸ·è¡Œç·’ 5:                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç¹¼çºŒåŸ·è¡Œ]

é›†åˆé»ç¤ºæ„ï¼š
åˆ°é”è¨ˆæ•¸å™¨ï¼š0/5 â†’ 1/5 â†’ 2/5 â†’ 3/5 â†’ 4/5 â†’ 5/5 âœ“
            â†‘     â†‘     â†‘     â†‘     â†‘     â†‘
           T4    T2    T3    T1    T5   (å…¨å“¡åˆ°é½Šï¼)
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <barrier>  // C++20

// å¤šéšæ®µå¹³è¡Œè¨ˆç®—
class ParallelProcessor {
    std::barrier<> sync_point_;  // åŒæ­¥é»
    std::vector<std::thread> workers_;
    
public:
    ParallelProcessor(int num_threads) 
        : sync_point_(num_threads) {  // åˆå§‹åŒ–æŸµæ¬„
        
        for (int i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this, i] {
                worker_task(i);
            });
        }
    }
    
    void worker_task(int id) {
        // éšæ®µ 1ï¼šè®€å–è³‡æ–™
        auto data = read_data(id);
        sync_point_.arrive_and_wait();  // ç­‰æ‰€æœ‰äººè®€å®Œ
        
        // éšæ®µ 2ï¼šè™•ç†è³‡æ–™
        auto result = process_data(data);
        sync_point_.arrive_and_wait();  // ç­‰æ‰€æœ‰äººè™•ç†å®Œ
        
        // éšæ®µ 3ï¼šå¯«å…¥çµæœ
        write_result(id, result);
        sync_point_.arrive_and_wait();  // ç­‰æ‰€æœ‰äººå¯«å®Œ
    }
};

// ä½¿ç”¨å›èª¿çš„ç‰ˆæœ¬ï¼ˆC++20ï¼‰
void parallel_map_reduce() {
    const int N = 4;
    std::vector<int> results(N);
    
    // Barrier å®Œæˆæ™‚åŸ·è¡Œçš„å›èª¿
    auto on_completion = [&]() noexcept {
        int sum = 0;
        for (int r : results) sum += r;
        std::cout << "ç¸½å’Œ: " << sum << std::endl;
    };
    
    std::barrier sync_point(N, on_completion);
    
    std::vector<std::thread> threads;
    for (int i = 0; i < N; ++i) {
        threads.emplace_back([&, i] {
            results[i] = compute(i);
            sync_point.arrive_and_wait();  // æœ€å¾Œä¸€äººè§¸ç™¼å›èª¿
        });
    }
    
    for (auto& t : threads) t.join();
}
```

### ğŸ”„ åŸ·è¡Œæ™‚åºç¯„ä¾‹

```
å ´æ™¯ï¼š4 å€‹åŸ·è¡Œç·’è¨ˆç®—çŸ©é™£

éšæ®µ 1ï¼šæ¯å€‹åŸ·è¡Œç·’è¨ˆç®—è‡ªå·±çš„åˆ—
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Thread 0: [è¨ˆç®—åˆ— 0] â†’ å®Œæˆ â—   â”‚
â”‚ Thread 1: [è¨ˆç®—åˆ— 1] â†’ å®Œæˆ â—   â”‚
â”‚ Thread 2: [è¨ˆç®—åˆ— 2........] â†’  â”‚ â† é‚„åœ¨ç®—
â”‚ Thread 3: [è¨ˆç®—åˆ— 3] â†’ å®Œæˆ â—   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
åˆ°é”è¨ˆæ•¸ï¼š3/4ï¼ˆç­‰å¾… Thread 2ï¼‰

Thread 2 å®Œæˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Thread 0: [ç­‰å¾…]                â”‚
â”‚ Thread 1: [ç­‰å¾…]                â”‚
â”‚ Thread 2: [è¨ˆç®—åˆ— 2] â†’ å®Œæˆ â— â†’ â”‚ å…¨å“¡åˆ°é½Šï¼
â”‚ Thread 3: [ç­‰å¾…]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
åˆ°é”è¨ˆæ•¸ï¼š4/4 âœ“ â†’ æ‰€æœ‰äººç¹¼çºŒ

éšæ®µ 2ï¼šåŒæ­¥å¾Œé–‹å§‹ä¸‹ä¸€éšæ®µ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Thread 0: â†’ [æ­£è¦åŒ–åˆ— 0]        â”‚
â”‚ Thread 1: â†’ [æ­£è¦åŒ–åˆ— 1]        â”‚
â”‚ Thread 2: â†’ [æ­£è¦åŒ–åˆ— 2]        â”‚
â”‚ Thread 3: â†’ [æ­£è¦åŒ–åˆ— 3]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ†š Barrier vs Condition Variable

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ¯”è¼ƒé …   â”‚    Barrier      â”‚ Condition Var    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å–šé†’æ–¹å¼   â”‚ æœ€å¾Œä¸€äººåˆ°é”    â”‚ æ˜ç¢º notify      â”‚
â”‚ ç­‰å¾…èªç¾©   â”‚ å…¨å“¡åˆ°é½Š        â”‚ æ¢ä»¶æ»¿è¶³         â”‚
â”‚ é‡è¤‡ä½¿ç”¨   â”‚ è‡ªå‹•é‡ç½®        â”‚ éœ€æ‰‹å‹•ç®¡ç†       â”‚
â”‚ é©ç”¨å ´æ™¯   â”‚ å¤šéšæ®µåŒæ­¥      â”‚ ç”Ÿç”¢è€…-æ¶ˆè²»è€…    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âœ… å„ªé»
- **ç°¡åŒ–å¤šéšæ®µåŒæ­¥**ï¼šä¸éœ€è¤‡é›œçš„è¨ˆæ•¸é‚è¼¯
- **è‡ªå‹•é‡ç½®**ï¼šå¯é‡è¤‡ä½¿ç”¨
- **æ”¯æ´å›èª¿**ï¼šå®Œæˆæ™‚è‡ªå‹•åŸ·è¡Œ

### âŒ ç¼ºé»
- **å›ºå®šåƒèˆ‡è€…æ•¸é‡**ï¼šç„¡æ³•å‹•æ…‹èª¿æ•´
- **å…¨å“¡é˜»å¡**ï¼šä¸€å€‹æ…¢æ‹–ç´¯å…¨éƒ¨
- **éœ€ C++20**ï¼šèˆŠç·¨è­¯å™¨ä¸æ”¯æ´

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- å¹³è¡Œæ¼”ç®—æ³•ï¼ˆMapReduceï¼‰
- GPU è¨ˆç®—åŒæ­¥
- éŠæˆ²å¼•æ“å¹€åŒæ­¥

---

## 9. é †åºé– (Seqlock)

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ
æƒ³åƒã€Œåšç‰©é¤¨å±•å“ã€ï¼š
- **åƒè§€è€…**ï¼šéš¨æ™‚å¯ä»¥çœ‹ï¼ˆè®€è€…ï¼‰
- **ç®¡ç†å“¡**ï¼šå¶çˆ¾æ›å±•å“ï¼ˆå¯«è€…ï¼‰
- **åƒè§€è€…è¦å‰‡**ï¼šå¦‚æœçœ‹åˆ°ç®¡ç†å“¡åœ¨æ›ï¼Œé‡æ–°çœ‹ä¸€æ¬¡

### ğŸ“Š ç¤ºæ„åœ–

```
è³‡æ–™çµæ§‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ sequence: 0 (å¶æ•¸)  â”‚ â† ç‰ˆæœ¬è™Ÿ
â”‚ data: {x:10, y:20}  â”‚ â† å¯¦éš›è³‡æ–™
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¯«å…¥éç¨‹ï¼š
æ­¥é©Ÿ 1: å¯«è€…é–‹å§‹
sequence = 1 (å¥‡æ•¸)  â† "æ­£åœ¨ä¿®æ”¹ä¸­"
å¯«è€…: å¯«å…¥ x = 15
å¯«è€…: å¯«å…¥ y = 25
sequence = 2 (å¶æ•¸)  â† "ä¿®æ”¹å®Œæˆ"

è®€å–éç¨‹ï¼ˆæ¨‚è§€è®€å–ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è®€è€…é–‹å§‹:                            â”‚
â”‚   seq1 = sequence.load()  // è¨˜éŒ„ç‰ˆæœ¬â”‚
â”‚   â†“                                  â”‚
â”‚   è®€å– data                          â”‚
â”‚   â†“                                  â”‚
â”‚   seq2 = sequence.load()  // å†æ¬¡æª¢æŸ¥â”‚
â”‚   â†“                                  â”‚
â”‚   if (seq1 == seq2 && seq1 % 2 == 0) â”‚
â”‚     â†’ è³‡æ–™ä¸€è‡´ï¼Œä½¿ç”¨å®ƒ               â”‚
â”‚   else                               â”‚
â”‚     â†’ é‡è©¦ï¼                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ™‚åºåœ–ï¼š
è®€è€… A:  [seq=0] â†’ è®€å– â†’ [seq=0] âœ“ æˆåŠŸ
å¯«è€…:                  [seq=1] å¯«å…¥ä¸­ [seq=2]
è®€è€… B:          [seq=0] â†’ è®€å– â†’ [seq=2] âœ— é‡è©¦
                         [seq=2] â†’ è®€å– â†’ [seq=2] âœ“ æˆåŠŸ
```

### ğŸ’» ç¨‹å¼ç¢¼ç¯„ä¾‹

```cpp
#include <atomic>

template<typename T>
class Seqlock {
    std::atomic<unsigned> sequence_{0};
    T data_;
    
public:
    // å¯«å…¥ï¼ˆç¨ä½”ï¼‰
    void write(const T& new_data) {
        // æ­¥é©Ÿ 1ï¼šå¢åŠ ç‰ˆæœ¬è™Ÿï¼ˆè®Šå¥‡æ•¸ï¼‰
        unsigned seq = sequence_.load(std::memory_order_relaxed);
        sequence_.store(seq + 1, std::memory_order_release);
        
        // æ­¥é©Ÿ 2ï¼šå¯«å…¥è³‡æ–™
        data_ = new_data;
        
        // æ­¥é©Ÿ 3ï¼šå†æ¬¡å¢åŠ ç‰ˆæœ¬è™Ÿï¼ˆè®Šå¶æ•¸ï¼‰
        sequence_.store(seq + 2, std::memory_order_release);
    }
    
    // è®€å–ï¼ˆæ¨‚è§€ï¼‰
    T read() const {
        T result;
        unsigned seq1, seq2;
        
        do {
            // è¨˜éŒ„ç‰ˆæœ¬è™Ÿ
            seq1 = sequence_.load(std::memory_order_acquire);
            
            // å¦‚æœæ˜¯å¥‡æ•¸ï¼Œè¡¨ç¤ºæ­£åœ¨å¯«å…¥ï¼Œç­‰ä¸€ä¸‹
            while (seq1 & 1) {
                seq1 = sequence_.load(std::memory_order_acquire);
            }
            
            // è®€å–è³‡æ–™
            result = data_;
            
            // æª¢æŸ¥ç‰ˆæœ¬è™Ÿæ˜¯å¦æ”¹è®Š
            seq2 = sequence_.load(std::memory_order_acquire);
            
        } while (seq1 != seq2);  // ä¸ä¸€è‡´å°±é‡è©¦
        
        return result;
    }
};

// å¯¦éš›æ‡‰ç”¨ï¼šåº§æ¨™è¿½è¹¤
struct Position {
    double x, y, z;
    uint64_t timestamp;
};

Seqlock<Position> player_position;

// éŠæˆ²åŸ·è¡Œç·’ï¼ˆå¯«è€…ï¼‰
void update_position(double x, double y, double z) {
    Position pos{x, y, z, get_timestamp()};
    player_position.write(pos);
}

// æ¸²æŸ“åŸ·è¡Œç·’ï¼ˆè®€è€…ï¼‰
void render_player() {
    Position pos = player_position.read();
    draw_at(pos.x, pos.y, pos.z);
}
```

### ğŸ”„ ç«¶çˆ­æ¢ä»¶è™•ç†

```
å ´æ™¯ï¼šè®€è€…åœ¨å¯«è€…ä¿®æ”¹æœŸé–“è®€å–

åˆå§‹ç‹€æ…‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ sequence = 100     â”‚
â”‚ x = 10, y = 20     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ™‚åˆ» T1ï¼šè®€è€…é–‹å§‹è®€å–
è®€è€…: seq1 = 100 (å¶æ•¸ï¼ŒOK)
è®€è€…: è®€å– x = 10

æ™‚åˆ» T2ï¼šå¯«è€…é–‹å§‹å¯«å…¥ï¼ˆåœ¨è®€è€…è®€å®Œä¹‹å‰ï¼‰
å¯«è€…: sequence = 101 (å¥‡æ•¸)  â† æ¨™è¨˜"æ­£åœ¨å¯«"
å¯«è€…: x = 15
å¯«è€…: y = 25
å¯«è€…: sequence = 102 (å¶æ•¸)

æ™‚åˆ» T3ï¼šè®€è€…è®€å®Œæª¢æŸ¥
è®€è€…: è®€å– y = 25  â† å¯èƒ½æ˜¯æ–°å€¼ï¼
è®€è€…: seq2 = 102
è®€è€…: seq1(100) != seq2(102) â†’ è³‡æ–™ä¸ä¸€è‡´ï¼
è®€è€…: é‡è©¦...

æ™‚åˆ» T4ï¼šè®€è€…é‡è©¦
è®€è€…: seq1 = 102
è®€è€…: è®€å– x = 15, y = 25
è®€è€…: seq2 = 102
è®€è€…: seq1 == seq2 â†’ æˆåŠŸï¼âœ“
```

### ğŸ†š Seqlock vs RWLock

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç‰¹æ€§      â”‚   Seqlock    â”‚   RWLock    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è®€å–æˆæœ¬    â”‚ ç„¡é–ï¼ˆå¿«ï¼‰   â”‚ éœ€åŠ é–ï¼ˆæ…¢ï¼‰â”‚
â”‚ å¯«å…¥æˆæœ¬    â”‚ ç„¡é–         â”‚ ç¨ä½”é–      â”‚
â”‚ è®€å¤±æ•—è™•ç†  â”‚ é‡è©¦         â”‚ é˜»å¡ç­‰å¾…    â”‚
â”‚ è³‡æ–™ä¸€è‡´æ€§  â”‚ æœ€çµ‚ä¸€è‡´     â”‚ å¼·ä¸€è‡´      â”‚
â”‚ é©ç”¨å ´æ™¯    â”‚ è®€å¤šå¯«å°‘     â”‚ è®€å¤šå¯«ä¸­    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âœ… å„ªé»
- **è®€å–è¶…å¿«**ï¼šå®Œå…¨ç„¡é–
- **å¯«è€…ä¸é˜»å¡è®€è€…**ï¼šè®€è€…è‡ªå·±é‡è©¦
- **ç„¡æ­»é–**ï¼šæ²’æœ‰é–å°±ä¸æœƒå¡

### âŒ ç¼ºé»
- **è®€è€…å¯èƒ½é¤“æ­»**ï¼šé »ç¹å¯«å…¥æ™‚ä¸€ç›´é‡è©¦
- **è³‡æ–™å¤§å°é™åˆ¶**ï¼šè¤‡è£½æˆæœ¬é«˜
- **å¯«è€…éœ€äº’æ–¥**ï¼šå¤šå¯«è€…éœ€é¡å¤–æ©Ÿåˆ¶

### ğŸ¯ ä½¿ç”¨å ´æ™¯
- å³æ™‚ç³»çµ±ï¼ˆè‚¡ç¥¨åƒ¹æ ¼ï¼‰
- éŠæˆ²å¼•æ“ï¼ˆä½ç½®æ›´æ–°ï¼‰
- ç³»çµ±ç›£æ§ï¼ˆçµ±è¨ˆè³‡æ–™ï¼‰

---

## 10. æ•ˆèƒ½æ¯”è¼ƒç¸½è¡¨

### ğŸ“Š å»¶é²å°æ¯”

```
æ“ä½œå»¶é²ï¼ˆå–®ä½ï¼šå¥ˆç§’ï¼Œä»¥ç¾ä»£ x86-64 ç‚ºæº–ï¼‰ï¼š

Lock-Free (CAS):      ~10-50 ns
Spinlock:             ~50-100 ns
Mutex (ç„¡ç«¶çˆ­):       ~50-100 ns
Mutex (æœ‰ç«¶çˆ­):       ~1,000-10,000 ns  â† Context Switch
RWLock (è®€):          ~100-200 ns
RWLock (å¯«):          ~1,000-10,000 ns
Semaphore:            ~1,000-5,000 ns
Condition Variable:   ~1,000-10,000 ns

åœ–ç¤ºï¼š
Lock-Free  â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (æ¥µå¿«)
Spinlock   â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (å¿«)
Mutex(ç„¡)  â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (å¿«)
Mutex(æœ‰)  â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (æ…¢)
Semaphore  â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (ä¸­æ…¢)
```

### ğŸ¯ ä½¿ç”¨å ´æ™¯é¸æ“‡è¡¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     å ´æ™¯           â”‚          æ¨è–¦é–æ©Ÿåˆ¶              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SPSC ä½‡åˆ—          â”‚ Lock-Free Queue                 â”‚
â”‚ å…±äº«è¨ˆæ•¸å™¨         â”‚ Atomic / Spinlock               â”‚
â”‚ éŠ€è¡Œè½‰å¸³           â”‚ Mutex                           â”‚
â”‚ å¿«å–ç³»çµ±           â”‚ RWLock / Seqlock                â”‚
â”‚ éè¿´å‡½å¼ä¿è­·       â”‚ Recursive Mutex                 â”‚
â”‚ ç”Ÿç”¢è€…-æ¶ˆè²»è€…      â”‚ Condition Variable              â”‚
â”‚ é€£ç·šæ±              â”‚ Semaphore                       â”‚
â”‚ å¹³è¡Œæ¼”ç®—æ³•åŒæ­¥     â”‚ Barrier                         â”‚
â”‚ å³æ™‚è‚¡åƒ¹æ›´æ–°       â”‚ Seqlock                         â”‚
â”‚ æ ¸å¿ƒ Interrupt     â”‚ Spinlock                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ” æ±ºç­–æ¨¹

```
é–‹å§‹
  â”‚
  â”œâ”€ æ˜¯å¦éœ€è¦å…±äº«è³‡æ–™ï¼Ÿ
  â”‚   â”œâ”€ å¦ â†’ ç„¡éœ€é–ï¼ˆThread-Local Storageï¼‰
  â”‚   â””â”€ æ˜¯ â†“
  â”‚
  â”œâ”€ æ˜¯å¦ç‚º SPSC æ¨¡å¼ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ Lock-Free Queue
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ è‡¨ç•Œå€æ˜¯å¦æ¥µçŸ­ï¼ˆ< 100nsï¼‰ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ Spinlock / Atomic
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ æ˜¯å¦è®€å¤šå¯«å°‘ï¼ˆè®€å¯«æ¯” > 10:1ï¼‰ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ RWLock / Seqlock
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ æ˜¯å¦éœ€è¦é™åˆ¶è³‡æºæ•¸é‡ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ Semaphore
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ æ˜¯å¦éœ€è¦æ¢ä»¶ç­‰å¾…ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ Condition Variable
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ æ˜¯å¦æœ‰éè¿´å‘¼å«ï¼Ÿ
  â”‚   â”œâ”€ æ˜¯ â†’ Recursive Mutex
  â”‚   â””â”€ å¦ â†“
  â”‚
  â””â”€ é è¨­é¸æ“‡ â†’ Mutex
```

### âš¡ å„ªåŒ–å»ºè­°

```
1. æ¸›å°‘é–ç²’åº¦
   âŒ æ•´å€‹ç‰©ä»¶ä¸€å€‹å¤§é–
   âœ… ä¸åŒæ¬„ä½ç”¨ä¸åŒé–

2. é¿å…é–é †åºæ­»é–
   âŒ åŸ·è¡Œç·’ A: lock(L1) â†’ lock(L2)
      åŸ·è¡Œç·’ B: lock(L2) â†’ lock(L1)
   âœ… çµ±ä¸€é–é †åºï¼šéƒ½å…ˆ L1 å† L2

3. ä½¿ç”¨ RAII ç®¡ç†é–
   âŒ mutex.lock();
      do_something();
      mutex.unlock();  // å¯èƒ½å¿˜è¨˜
   âœ… std::lock_guard<std::mutex> lock(mutex);

4. è€ƒæ…®ç„¡é–æ›¿ä»£
   âŒ mutex + counter++
   âœ… std::atomic<int> counter;
      counter.fetch_add(1);

5. æ‰¹æ¬¡æ“ä½œæ¸›å°‘é–æ¬¡æ•¸
   âŒ for (item : items) {
        lock();
        process(item);
        unlock();
      }
   âœ… lock();
      for (item : items) {
        process(item);
      }
      unlock();
```

---

## ğŸ“ ç¸½çµ

### å¿«é€Ÿè¨˜æ†¶å£è¨£

```
ğŸš€ é€Ÿåº¦è¦æ±‚é«˜ï¼Ÿ        â†’ Lock-Free / Spinlock
ğŸ” ç°¡å–®äº’æ–¥å°±å¥½ï¼Ÿ      â†’ Mutex
ğŸ“– è®€å¤šå¯«å°‘ï¼Ÿ          â†’ RWLock / Seqlock
ğŸ” æœƒéè¿´å‘¼å«ï¼Ÿ        â†’ Recursive Mutex
â° éœ€è¦æ¢ä»¶ç­‰å¾…ï¼Ÿ      â†’ Condition Variable
ğŸ« é™åˆ¶è³‡æºæ•¸é‡ï¼Ÿ      â†’ Semaphore
ğŸš§ å¤šéšæ®µåŒæ­¥ï¼Ÿ        â†’ Barrier
```

### å¸¸è¦‹éŒ¯èª¤

```
âŒ å¿˜è¨˜è§£é–               â†’ ä½¿ç”¨ RAII (lock_guard)
âŒ æ­»é–                   â†’ çµ±ä¸€é–é †åº
âŒ è™›å‡å–šé†’               â†’ Condition Variable ç”¨ while
âŒ éåº¦ä½¿ç”¨ Spinlock      â†’ é•·è‡¨ç•Œå€ç”¨ Mutex
âŒ å¿½ç•¥è¨˜æ†¶é«”é †åº         â†’ Atomic æ­£ç¢ºä½¿ç”¨ memory_order
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

- [C++ Concurrency in Action (2nd Edition)](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition)
- [The Art of Multiprocessor Programming](https://www.elsevier.com/books/the-art-of-multiprocessor-programming/herlihy/978-0-12-415950-1)
- [Linux Kernel Locking](https://www.kernel.org/doc/html/latest/locking/index.html)

---

**æ–‡ä»¶ç‰ˆæœ¬**: 1.0  
**æœ€å¾Œæ›´æ–°**: 2026-01-09  
**æˆæ¬Š**: CC BY-NC-SA 4.0

---

## é™„éŒ„ï¼šå¯¦ç”¨ç¨‹å¼ç¢¼ç‰‡æ®µ

### A1. ç°¡æ˜“æ•ˆèƒ½æ¸¬è©¦æ¡†æ¶

```cpp
#include <chrono>
#include <iostream>

template<typename Func>
double benchmark(Func f, int iterations = 1000000) {
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < iterations; ++i) {
        f();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    
    return duration.count() / (double)iterations;
}

// ä½¿ç”¨ç¯„ä¾‹
int main() {
    std::mutex mutex;
    int counter = 0;
    
    double avg_ns = benchmark([&] {
        std::lock_guard<std::mutex> lock(mutex);
        ++counter;
    });
    
    std::cout << "å¹³å‡æ¯æ¬¡æ“ä½œ: " << avg_ns << " ns\n";
}
```

### A2. æ­»é–æª¢æ¸¬å™¨

```cpp
#include <map>
#include <thread>
#include <mutex>

class DeadlockDetector {
    std::map<std::thread::id, std::vector<void*>> held_locks_;
    std::mutex detector_mutex_;
    
public:
    void acquire(void* lock) {
        std::lock_guard<std::mutex> guard(detector_mutex_);
        auto tid = std::this_thread::get_id();
        held_locks_[tid].push_back(lock);
        check_for_cycles(tid);
    }
    
    void release(void* lock) {
        std::lock_guard<std::mutex> guard(detector_mutex_);
        auto tid = std::this_thread::get_id();
        auto& locks = held_locks_[tid];
        locks.erase(std::remove(locks.begin(), locks.end(), lock), locks.end());
    }
    
private:
    void check_for_cycles(std::thread::id tid) {
        // ç°¡åŒ–ç‰ˆï¼šæª¢æŸ¥æ˜¯å¦æœ‰åŸ·è¡Œç·’æŒæœ‰å¤šå€‹é–
        if (held_locks_[tid].size() > 1) {
            std::cerr << "è­¦å‘Šï¼šåŸ·è¡Œç·’æŒæœ‰å¤šå€‹é–ï¼Œå¯èƒ½æ­»é–ï¼\n";
        }
    }
};
```

---

å¸Œæœ›é€™ä»½æŒ‡å—èƒ½å¹«åŠ©ä½ ç†è§£å„ç¨®é–æ©Ÿåˆ¶ï¼ğŸ“
