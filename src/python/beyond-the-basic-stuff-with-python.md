### 要真正落實 Clean Code，著實不易

雖然任何一種程式語言都能夠寫出堪稱簡潔的程式碼，但 Python 可能是最接近「自然語言」的那個，從這個角度看，Python 的 Clean Code 或許是最美的。

但因為 Python 的自由度，往往實際上的程式碼品質都不是那麼理想——你甚至希望它不要那麼自由。

### 我認為這本書被低估了

意思是它似乎不那麼有名。

當然，講 Clean Code Python 的書也不只這本，但我認為本書是**最適合起手**的一本。儘管它面向的是 Python 新鮮人，但不得不承認，即使已經寫了一、兩年 Python 的開發者，對於書中建議的落實，往往都還有所不足。

儘管 Python 是自由的，但 Clean Code 卻**沒有那麼自由**——我們需要這本書，而且要好好實踐它。



## 只講重點

雖然是偏筆記的形式，但我也不想重複那些基本知識，所以只講重點，視需要給予書中的細節。

重要的是，我們「知道」有這件事。這是一種「嗅覺」，你也可以說，是對於「程式碼壞味道」的嗅覺。

儘管在不久的將來，我們產出的程式碼，可能有相當部分是 AI 幫我們寫的，但那依舊不妨礙我們對於 Clean Code 的追求——畢竟你還是要審視 AI 的產出，並適時修正與完善。

------

本文整理書中第 3-5 章重點，前 2 章我覺得重要性普通就略過了。

## 第 3 章：使用 Black 進行程式碼格式化

Formatter——格式化器——想必大家都很熟悉了，我也有不少文章提過（雖然主要講 yapf），有興趣可以查看「[Code Formatting](https://blog.kyomind.tw/tags/Code-Formatting/)」這個 tag。與下列兩篇與 Black 有關的文章：

- [VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手](https://blog.kyomind.tw/flake8-and-black/)
- [pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學](https://blog.kyomind.tw/pyproject-toml/)

提 formatter 肯定要提 [PEP 8](https://peps.python.org/pep-0008/)，畢竟所有的 Python formatter 都是以 PEP 8 為基礎，再加上一些慣例或額外規則。

所以這章有一定的篇幅與範例都是在講 PEP 8，這裡只提一個我覺得比較容易被忽略（但我認為重要）的點——垂直間距（空行）。

至於要用哪個格式化器，本書推薦 Black。我認為 yapf 也不錯。

### 垂直間距

這名稱好學術，講白了就是程式碼之間的「空行」。

> 空行是一種藝術。

就跟文章的分段一樣，程式碼的空行太多會流於鬆散，而太少則過度緊迫。如何拿捏，需要你對**美感與程式可讀性**有幾分「**直覺**」才行。

所幸，PEP 8 有基本規則：

1. 函式之間：2 行空行。
2. 類別之間：2 行空行。
3. 類別的方法之間：1 行空行。

這 3 種空行，格式化器能幫你自動完成。另外，空 3 行或在上述情境「以外」的地方空 2 行，都是不允許的😷

格式化器會一併修正（linter 也會提醒），不會讓你自由發揮。

這麼說來，真正難的，還是**什麼時候要空 1 行**。我想這就是**空行藝術**的所在了。

## Why Black？

本書推薦 Black 的理由，就跟許多大型 Python 開源專案採用 Black 的理由一樣——因為它的**規則最硬**，大家只能乖乖遵守。書中是這麼說的：

> 如果您正在與其他人一起進行某個程式專案，只要使用 Black 工具就能立即解決所有關於格式化程式碼的許多爭論與協調。

真的，只要協作的人愈多，我們對程式碼「**一致性**」的需求就愈高，**優先權**甚至高過了典型的**慣例與規則**。比如 Google 要求內部 Python 專案中的程式碼縮排為 2 個空格而不是常見的 4 個。

2 空格的縮排既不符合 PEP 8，也並非常見慣例，是基於團隊與專案的**一致性要求**。

而一致性的本質就是——**這沒得商量**。

### 一致性的好處

沒得商量，就沒必要爭執，而且誰也不能怪誰，因為這是 Black 規定的！

不過，如同我之前的文章介紹，大多數時候我還是會變更下列兩個 Black 預設值：

1. 單行字元上限。
2. 停用強制雙引號。

「一致性」有在團隊協作中多重要？書上的這段話，無疑是很好的註解：

> Python 的語法在風格樣式上**更有彈性**。如果您編寫的程式別人看不到，那怎麼樣寫都可以，但是軟體開發工作大都是**共同協作**的，無論與其他人一起在專案上工作，或是請經驗豐富的開發專家來審查您完成的程式，**把程式碼格式化為大家公認的風格樣式是很重要的。**

可不是嗎？

------

## 第 4 章：選用易懂的命名

命名之難，是因為你總是要用很心才能命出好名字。而且情境千變萬化，**命名有原則，卻沒有太多捷徑。**

檢查風格樣式，機器可以代勞，但命名就不行了——那是以前！

現在有了 AI，只要你願意讓它看看你的程式碼，要求它「請幫我找出不恰當的命名」並接受它的建言，我相信肯定很有幫助。

雖然我們通常不想面對批評——哪怕是來自 AI 的批評。我懂，這是人之常情。包括我自己，也會覺得有點難受。

但你的 code 會因此變得更 [robust](https://zh.wikipedia.org/zh-tw/健壮性_(计算机科学))，這是值得的。

### 兩種不佳的命名模式

**一、prefix，命名的前綴**

為類別中的屬性命名，重複類別名稱作為前綴，比如在 Cat 類別中，屬性 weight 又命名為 cat_weight。這樣做是冗餘的。

先別說你不會XD，很多時候人都是健忘的。尤其當這個類別是 ORM 中的 Model 時，特別容易！

而且冗餘的前綴不一定只發生在類別，有時模組中的變數命名，也會再度重複模組名稱作為前綴。

**二、在名稱中以「循序數字」當作後綴**

比如`payment1`、`payment2`、`payment3`。

我真的很討厭！因為這樣的命名**缺乏表意性**。

有時候會在 pytest fixture 看到同事這樣寫，我會建議改成比較「**能表現個體特質**」的命名。

比如`payment1`改成`payment_with_credit_card`、`payment2`改成`invalid_payment`等等。除非它們之間真的沒有任何區別（通常都有區別，但懶得一一想名字），就只是需要複數個同類型的物件

### 第三種不佳的命名模式——型別後綴

除了書中的兩種，還有一種我個人也覺得不妥的命名模式——**型別後綴**。

也就是在變數的最後加上型別，比如`name_str`、`age_int`。

你未必很常看到這樣的命名，因為大部分時候並不需要。但是，在某些場合，當開發者**想要強調**某個變數的型別時，就會這麼做。

比如 code review 時，我最常見到的「型別後綴」命名就是：

```python
response_dict = response.json()
```

這樣寫似乎有其道理，**但我仍不推薦，理由有二：**

1. 型別後綴會**讓語意變得混亂**：比如本來很清楚的`is_valid`，加上後綴變成`is_valid_bool`，反而讓人不知所云。
2. 現在已經有了 [type hints](https://docs.python.org/3/library/typing.html)，可以用來強調型別。前述例子，你想強調它是一個布林值，就可以這樣寫：`is_valid: bool`。

所以，我們很難再找到充分理由，來使用型別後綴。

### 不要使用內建名稱

意即不要使用 Python 的[保留字](https://zh.wikipedia.org/zh-tw/保留字)。理由可想而知，因為它會覆蓋原來的內建物件，造成程式的錯誤與混亂。

那真的需要怎麼辦？一個常見的做法是加上`_`作為**後綴**。比如`type_`。

------

## 史上最糟的變數名稱——data

不瞞您說，**萬事萬物都是「data」。**

在實務中，把變數命名為 data 的情況還真不算罕見——但這是一種**極為糟糕的命名**，因為它**缺乏表意性**。

書中的這段話說得非常好（我稍重組了一下原句）：

> 將變數命名為 data，就像把你的狗命名為 Dog。

簡言之，執意將變數命名為 data，需要非常堅實的理由——通常不存在這樣的理由。

### 少數的例外

好啦，我能理解將變數命名為 data 的情境，就是當呼叫的**函式參數名稱為 data 時**，比如常見的：

```python
data = {
    'name': 'John',
    'age': 18,
}
# 使用requests套件發送POST請求
url = 'https://example.com/api'
response = requests.post(url, data=data)
```

總來的說，我覺得下面三種情境，使用 data 作為變數名稱都**尚可接受**：

1. 函式**參數**名稱就是 data。所以**引數**叫作 data，也算合理。
2. 該變數的**生命週期很短**——我絕對不會將任何長生命週期的變數命名為 data。上述例子中，data 的生命週期就只有寥寥幾行，所以我覺得還可以。
3. HTTP response 的**欄位名稱**就是 data。這種情況下，我也會考慮使用 data 作為變數名稱，因為這樣可以**保持一致性**。

但一般而言，**我還是會盡可能避免使用 data 命名變數，這是為了養成好習慣**。

------

## 史上「第二糟」的變數名稱？

這部分不是書中的內容，而是我自己的心得。

當我遵守了好習慣，盡可能避免在程式碼中使用 data 命名後，本以為能從此過上幸福快樂的生活，**但我錯了！**

因為沒多久後我就發現，還有一個比 data 更**駭人聽聞**的變數名稱——`result`。

和 data 相比，其**糟糕的程度**，簡直**有過之而無不及**。畢竟**萬事萬物都有「result」**，因果循環、生生不息，而且這個命名**更加抽象**，令人不禁想問：

> **到底是什麼結果？**

result 命名的濫用，在「儲存呼叫函式的**結果**」時最為常見，**難怪到處都是 result。**

## 3 個代表性案例

下面我們就舉 3 個代表性案例，來看看 result 到底有多糟糕。以及應該要用什麼名稱來取代它——基本上就是**更直接、具體、精確**的名稱。

### 一、從資料庫查詢訂單

```python
# 不好的寫法
result = query_orders_from_database(customer_id)
...

# 更好的寫法
orders = query_orders_from_database(customer_id)
...
```

第一種典型的情況是，**明明有更具體的名稱可以使用**，卻偏偏用了籠統的 result。

這樣的寫法，讓人看了一頭霧水，不確定 result 到底是指什麼。類似的例子還有求平均值、性別、數量等等，太多了，明顯都可以用更具體的名稱來取代。

事實上，無論是這 3 種情況中的哪一種，會叫 result，通常是因為**懶得想名字**。

### 二、檢查用戶是否有管理員權限

```python
# 不好的寫法
result = check_user_is_admin(user_id)
if result:
    ...

# 更好的寫法
is_admin = check_user_is_admin(user_id)
if is_admin:
    ...
```

我認為這是**最重要**的一種：當函式的**回傳是一個[布林值](https://zh.wikipedia.org/wiki/布林_(資料類型))\**，代表\**狀態**或**成功與否**。

這個時候，我們應該要使用充滿了「**布林味**」的變數名稱，比如`has_permission`、`is_valid`、`is_success`等等。而不是`result`。

### 三、使用 requests 發出 HTTP 請求

終於來你最常見到的情境了，使用`requests`（或`httpx`）發出 HTTP 請求，並將回傳的結果存入 result。

```python
import requests

# 不好的寫法
result = requests.get("https://api.example.com/data")
if result.status_code == 200:
    process_data(result.json())

# 更好的寫法
response = requests.get("https://api.example.com/data")
if response.status_code == 200:
    process_data(response.json())
```

在這個例子中，使用 response 作為變數名稱會比使用 result 更加清晰和具描述性。

當其他開發者（或是你自己）看到這段程式碼時，會立即明白這個變數存儲的是一個 HTTP response，而不是某個抽象的「結果」。

這個常見例子還有一個常見的「**變形**」：

```python
res = requests.get("https://api.example.com/data")
if res.status_code == 200:
    process_data(res.json())
```

這麼巧！response 和 result 兩者恰好都是以 res 為前綴，只要命名為`res`就天下太平了——才怪。

有什麼比 result 更讓人想握緊拳頭的變數名稱嗎？**恐怕就是 res 了。**

### 小結：no result

說真的，data 至少還有上述的例外情況，但關於 result，我真的想不到。

我非常確信，打算我工作的第二年起（第一年可能還懵懂無知），再就也沒有使用過 result 這個變數名稱。

> 一次也沒有。

所以，請原諒我，這一段的標題是「**騙人**」的，result 壓根不是什麼「史上第二糟」的變數名稱，**它就是「全銀河系最爛」的變數名稱。**

除了一口氣把它塞入[人馬座 A*](https://zh.wikipedia.org/wiki/人馬座A*) 的**超大質量黑洞**，我想不到更好的處理方式。

------

## 第 5 章：找出程式碼的異味

程式碼異味（[code smell](https://zh.wikipedia.org/zh-tw/代码异味)）指的就是程式中看起來「不對勁」，且有可能在後續引發問題的地方。

如果可以，我們當然要盡可能避免異味，至少要給予一定關注才行。

實務上，我會在覺得有明顯異味的地方留下`XXX`註解，闡述異味的理由，並留意後續發展。

```python
# XXX PATCH 做的事情太多了，很容易發生狀態殘留問題
if request.method == 'PATCH':
    ...
```

畢竟異味不一定都會造成問題，也不是所有的異味都要被修正（因為太多了），甚至隨著後續開發，原本看起來的異味可能隨之消散或減緩——但這屬於少見的情況。大部分都是愈來愈糟，不然怎麼會有「[技術債](https://zh.wikipedia.org/zh-tw/技术负债)」這個詞呢？

書中所舉的異味種類很多，也都很經典，值一一細讀。不過限於篇幅，只舉其中幾個我個人認為**比較有代表性**的異味。

### 一、重複的程式碼

重複程式碼肯定不是一個錯誤（error），卻很可能造成後續維護上的困擾。典型的困境就是改一個地方結果多處也要跟著一起改時，我稱之為程式碼的「**同步**」問題。

> 需要手動同步，就是壞味道。

通常我們會將這部分抽取出來，讓程式只需要改動一處，就能在所有引用處生效。

不過，書中也說了，重複一、兩次通常沒有關係；而重複三、四次時，就要好好考慮了是否重構或刪除。

而且有些時候，重複反而是比較簡潔的做法——無腦但直觀，可讀性最高。

確實，單憑形式上的「是否重複」來判斷要不要修改程式碼，往往是不足夠的。還要看**使用的場景**。比如前面說的那種會發生同步問題的重複，哪怕只有一次，我也會特地抽出來。

顯然，這需要一些經驗，與一次又一次的思考。

### 二、魔術數字

有些數字我們很容易知曉其含意，比如 3.14，而有些則否。

```
expiration = time.time() + 604800
```

這 604800 究竟代表什麼？我們肯定需要停下來思考，可能需要花一些時間才能想出來。這樣的寫法顯然太不直觀。

重點是，**你縱使猜得到，也無法 100% 確定**。

一種改進方式是**加上註解**：

```
expiration = time.time() + 604800  # 一星期後失效
```

原來 604800 代表的是一週的秒數！

這樣寫好很多，但書中建議我們採取更經典的做法——使用**常數**。

```python
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 60 * SECONDS_PER_MINUTE
SECONDS_PER_DAY = 24 * SECONDS_PER_HOUR
SECONDS_PER_WEEK = 7 * SECONDS_PER_DAY

expiration = time.time() + SECONDS_PER_WEEK  # 一星期後失效
```

常數是在程式中使用的**固定值**，原則上是**不能被改變**的。在使用常數時，我們應該採取**有描述性的命名**，這樣有助於提高程式的可讀性和可維護性。

常數 + 有描述性的命名，就是應對魔術數字的絕佳手段。

比如 [Django REST Framework](https://www.django-rest-framework.org/)（DRF）中的`status`：

```
return JsonResponse(context, status=status.HTTP_200_OK)
```

除了 200，常見的還有：

- `status.HTTP_400_BAD_REQUEST`
- `status.HTTP_404_NOT_FOUND`

我們當然可以直接寫`status=200`、`400`、`404`，看起來也很直觀，但對於那些我們**沒那麼熟悉**的 HTTP 狀態碼，比如 [509](https://http.cat/status/509)，則又需要陷入停頓與思考。

而使用常數的話，則所有成員都會**更加一視同仁**：

```
status.HTTP_509_BANDWIDTH_LIMIT_EXCEEDED
```

### 三、雙層生成式

書中的例子是，你想把一個二維 list「攤平」成一維，於是寫了**雙層串列生成式**（List [Comprehension](https://steam.oxxostudio.tw/category/python/basic/comprehension.html)）進行處理，像這樣：

```python
nested_list = [[0, 1, 2, 3], [4], [5, 6], [7, 8, 9]]
flat_list = [num for sub_list in nested_list for num in sub_list]
>>> flat_list
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

這樣的寫法雖然簡短，但**可讀性極差**。哪怕是 Python 老手，也很難一眼就看出來這個生成式到底在做什麼。

作者建議用雙層的 for 迴圈改寫，以增加可讀性：

```python
nested_list = [[0, 1, 2, 3], [4], [5, 6], [7, 8, 9]]
flat_list = []
for sub_list in nested_list:
    for num in sub_list:
        flat_list.append(num)

>>> flat_list
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

確實。但說真的，可以的話，我覺得盡量也不要使用雙層迴圈。

其中的原因，容我直接引用[臉書舊貼文](https://www.facebook.com/kyomind/posts/pfbid02KKKWxAjUxGWVep39bUDUyopBPrJcWj6Wv7tMU5wuZqF9AknA8cQT88zJQUNMS7sl)：

> 程式碼裡有：一層迴圈是壞味道，兩層迴圈是罪惡，三層迴圈是罪大惡極
> 　
> 因為這些都是程式中的「手工藝」，乏缺架構思維，除了當下用起來很「方便」，日後更可能是難以維護，畢竟正常人無法一眼就看出第二、三層迴圈到底在做什麼（仔細看也一樣啦！）
> 　
> 此乃典型的技術債，而且是很廉價的那種

雙重迴圈有時是不得已——總會有這樣的時候，但我們仍必須**視之為罪惡**。

## 程式碼異味的迷思

這是第 5 章的最後一節，但我覺得特別精彩，值得獨立拿出來講。

書中所謂「程式碼異味的迷思」，指的是**作者不認為那是異味**，但常常會被視為異味的情況。

書中列舉了 5 個迷思（作者**不認同**的命題），分別如下：

1. 迷思：函式末尾應該只有一個 return
2. 迷思：函式中最多應該只有一個 try 陳述句
3. 迷思：旗標（flag）引數是不好的
4. 迷思：全域變數是不好的
5. 迷思：注釋是不需要的

有些你可能也不覺得是迷思，沒關係，這裡我只打算討論第 5 個。

## 註解是不需要的？

我們可能聽過類似「好的程式碼應該透過優秀的命名與明確的意圖來自我表達、好的程式不需要註解」等等論述。

這堪稱是一種理想，乍聽也有幾分道理，但事實又如何呢？

在我看來，不寫任何註解或 [docstring](https://en.wikipedia.org/wiki/Docstring)，卻期待程式非常好讀，幾乎是不可能的！

註解或 docstring 使用自然語言，表達能力與彈性**遠遠超過**受限於「用詞精簡且著重於功能面」的程式碼。

我在「[Python docstring 之我見](https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-之我見)」也表述過類似的看法：

> 在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，**docstring 終究是不可少的**。因為文字的**詮釋能力**和程式碼相比，**絕不在同一個層次**，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。

> 不知道你怎麼看？我相信，寫好 docstring，是簡潔程式碼**不可或缺的一環**，更是優秀軟體工程師的必備條件——我對此深信不疑。

### 註解與 docstring 的價值

**有些事很重要**，開發者在維護與修改程式時**必須知道**，這些事往往難以直接藉由程式碼透露出來，**比如函式的「使用方式」與「注意事項」**，這時註解就派上用場了。

退萬步言，複雜的程式光要看懂就很不容易。而良好的註解與 docstring **可以大幅縮短閱讀理解的時間**，你的隊友一定會感謝你。

尤其在團隊開發時，**註解與 docstring 是溝通的重要媒介**，有時甚至是**唯一**的媒介。

當然我們也不得不承認，很多註解都寫得很爛！但這不是註解的錯，而是寫的人還不夠熟練或深思。而且寫好註解也真的很難，需要大量的練習。

顯然作者也是這麼認為的：

> 要寫出簡潔有效的注釋並不容易，注釋就像程式碼一樣，需要重寫和多次修調才會更好。

### 寫好註解是同理心的表現

就像我在〈[18，論軟體工程師常見的「路徑依賴」問題（上）](https://blog.kyomind.tw/weekly-review-18/)〉中所闡述的：

> 寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是**一個人的自言自語**（只要自己有完成任務就好）——**它並沒有在溝通**。

程式碼是溝通，而註解更是。它是同理心中「**換位思考**」的具體表現。

而且，把註解寫好，自己也會是受益者。因為我們不可能總是記得程式的所有細節，哪怕是自己寫的程式。

優秀的註解和 docstring，讓人讀程式時心曠神怡，維護的壓力也小得多。我相信任何開發者都希望自己接手的是這樣的程式碼。

在團隊協作中，這是一種任何人都會喜愛的溫柔。

## 第 6 章：寫出 Pythonic 風格的程式碼

我們常常聽到 Pythonic，但如果問起它究竟意味著什麼，一時之間可能也不容易回答，畢竟它沒有一個公認的標準或定義。

不過，**充利分用 Python 獨有的特性、寫作風格、語法，尤其是善用標準函式庫**（不重複造輪子——因為你自己造的輪子往往**不會**更好、更方便、更有效），顯然是大家都認同的部分。

至於遵守上篇提到的 [PEP 8](https://peps.python.org/pep-0008/)，自然不在話下。如果你的變數命名使用了小駝峰式命名法（lower camel case），那麼在「形式上」就已經不太 Pythonic 了。

話說回來，本書雖然是一本優秀的 Clean Code in Python 入門書，但不知為何，書中的函式命名皆是採用小駝峰，讓我不甚理解。

但我們要知道：好孩子不要學。至於為什麼，不用問，問就是 PEP 8。



## 使用`enumerate()`而不要用`range()`

這真的很重要！當我 review 到下面這類 code 時，我會**強烈要求**必須改用`enumerate`**重構**。

設想你有一個 Python list 如下：

```
animals = ['cat', 'dog', 'moose']
```

你想同時知道每一個元素是 list 中的**第幾個**與**內容為何**，直觀上可能會這樣寫：

```python
>>> animals = ['cat', 'dog', 'moose']
>>> for i in range(len(animals)):
...     print(i + 1, animals[i])
...
1 cat
2 dog
3 moose
```

這種「**手刻邏輯**式的寫作風格」——要什麼就寫什麼，寫完也不重構——你是否已經屢見不鮮？我們來評論一下，這段程式碼有兩個很醜（難讀）的地方。

1. `i + 1`。這寫法顯然是為了讓**計數**從 1 開始——而不是預設的 0。
2. `range(len(animals))`寫法非常不直觀，多層的**嵌套式呼叫**讓人看了昏昏欲睡。

這兩個地方充滿了「**手刻**」的**僵化感**，只是為了**最快速達到開發者「當下目的」而強行採用的一種粗糙手段**——但顯然不是最好的那個。

雖然兩者都不難理解與推測，但除了寫這段程式的人，**誰也無法 100% 確信作者的「意圖」**——這是[糙 code](https://ithelp.ithome.com.tw/users/20107637/ironman/1927) 的特色，它存在著**大量且不必要的誤解空間**。

這些**不明確的誤解空間**會造成別人閱讀本段程式碼時的「**思考停頓**」，更別說後續滋生 bug 的可能。所幸，它們是有可能被消除的。比如使用以下的`enumerate`。

一言以蔽之，你只要**在`for`迴圈內**，看到以下這樣的寫作模式，那就是典型的 Python [壞味道](https://blog.darkthread.net/blog/refactoring-notes-2-bad-smell/)：

> `iterable[index]`（`可迭代物件[物件元素的索引值]`）

迭代任何`iterable`同時，又需要知道每一個元素的索引值，這毋寧是很常見的需求。

因為太常見了，所以 Python 早就幫你準備好了——就是為了這種情況而存在的——`enumerate`。

同樣的需求，我們應該要這樣寫：

```python
>>> animals = ['cat', 'dog', 'moose']
>>> for i, animal in enumerate(animals, start=1):
...     print(i, animal)
...
1 cat
2 dog
3 moose
```

`start=1`讓你不用再`i+1`，也不再需要`range`和`len`的疊床架屋。

兩種寫法的結果是一樣的，但後者更加善用 Python 的內建特性，**且優雅**。

**善用 Python 的自身的特性寫出優雅而簡潔的程式碼——這就是 Pythonic。**

------

### 使用`with`陳述式而不要手動`close()`

因為你很可能會忘記 close！

`with`（**context manager，上下文管理器**）在資源管理上很有用，比如文件讀寫或資料庫連接等，可以確保即使有錯誤發生，也能正確地關閉、釋放資源。

但對於不熟悉或不常見的物件，**則要注意物件是否實作了所謂的「上下文管理協定」**。

這個協定要求物件必須實作以下兩個方法：`__enter__` 和 `__exit__`。這樣物件搭配`with`使用時，才能正常運作。

### 使用`is`比較是否為`None`，而不用`==`

細節請參考書中的詳盡說明，所幸現代 linter 都會提醒你：在比較`None`、`True`、`False`這 3 種值時，請使用`is`而非`==`。

### 以 Pythonic 風格來運用字典

1. 使用`get()`來處理沒有 key 值而出現`KeyError`的情況。（不過有時候缺少 key 是一個警訊，此時不宜透過 get 讓這個警訊被忽略）
2. 使用`setdefault()`來處理沒有 key 值就要**新增該 key 並給定一個預設值**的情況。
3. 使用`collections.defaultdict`來更細緻地處理預設值。

前兩者你可能已經熟悉，而第 3 種在特定情境真的很好用！以前當資料工程師，進行資料清洗時，我就很喜歡用`defaultdict`。

關於`defaultdict`的用法與介紹，可直接參考這篇〈[collections雜談之一 ——— dict的key值存不存在乾我屁事](https://ithelp.ithome.com.tw/articles/10193094)〉。

------

上面舉的種種例子，都是常見的 **Python 寫作慣例**，這些慣例是 Python 在設計功能時就已經詳細考慮到的常見情況。換句話說，它們也往往是**最佳實踐**。

這樣寫，我們不敢說是必要的。只是你真的這麼做的話，熟悉 Python 的人會知道，你就是一個「**內行人**」。

還是那句〈[Zen of Python](https://zh.wikipedia.org/zh-tw/Python之禅)〉中的名言：

> 任何問題應有一種，且**最好只有一種**顯而易見的解決方法。（There should be one– and preferably only one –obvious way to do it.）

說到內行人，下一章我們就來看看，內行人還需要知道哪些事情。

## 第 7 章：程式設計的行話

行話，在本章的情境中，指的是程式設計中的「術語」——包括不限於 Python。

本章應該算是這些重要基礎的再次強調，有一定經驗的人，可以直接跳過。但我還是介紹一些值得重新溫習的內容。

### 物件、值、型別、識別**碼**

物件（object）是**資料的表示形式**，例如數字、字串，或更複雜的資料結構，比如 list 或 set。

> 所有的物件都具有**值**、**識別碼**（id）和**資料型別**。

這句話很重要。因為我們很常把物件的「值」（比如數字 12、字串`"hello"`）視為物件「本身」，但實際上那只能說是物件的一個**重要屬性**。

而物件的其它兩個重要屬性，就是 id（代表物件在**當前的程式執行期間**在**記憶體中的地址**）和型別。

id 屬性的內容可以透過內建的`id`函式取得：

```python
>>> id(12345)
4603344144
```

而型別則是透過`type()`：

```python
>>> type(12345)
int
```

了解這些細節的重要理由是，每次執行程式時，物件的 id 與型別不會改變，但物件的值是可以變動的！這是可變與不可變物件的基石。

此外，如果兩個物件的 id 相同，那麼它們就是**同一個物件**。這將有助於你理解關於「物件的參照」與「[一、Python 中的變數：是水桶還是標籤？](https://blog.kyomind.tw/the-quick-python-book/#一、Python-中的變數：是水桶還是標籤？)」等議題。

> 相關文章：[最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀](https://blog.kyomind.tw/the-quick-python-book/)

### 可變與不可變

剛剛提到，物件中只有「值」是可以（有可能）改變的。所以依照物件的**值是否可以改變**，物件也分為兩大類：

1. 可變物件。
2. 不可變物件。

這無疑是一大經典議題，但這裡就不展開了。只要知道物件的可變與不可變，對於變數的「參照」有著巨大的影響。有興趣可以再看看「[二、使用可變物件作為引數時要小心](https://blog.kyomind.tw/the-quick-python-book/#二、使用可變物件作為引數時要小心)」部分。

本章還有很多術語的定義介紹，比如陳述式（statement）與表達式（expression）、iterable 與 iterator、參數與引數……等等，就請讀者自行參照書中介紹囉！

------

## 第 8 章：常見的 Python 誤解和陷阱

本章介紹基於 Python 特性的一些常見錯誤——我們一定都踩過。在此只提「為什麼這樣不好」以及如何避免這些不佳實作的**核心思路**。

### 不要在迴圈中新增或刪除「被迭代物件（比如 list）」中的元素

只要遇過一、兩次就會知道這個坑，但一段時間後，很可能會一錯再錯XD。

新增可能會造成無限迴圈（因為迭代不完），而且刪除則很可能會造成**索引值與你預期內容產生錯亂的問題**。

大原則就是「不要在迴圈中**編輯**（修改）當前被迭代的**可變物件**」，如果必須這麼麼做，就為它們建立一個「副本」吧！

### 一定要用`copy.copy()`和`copy.deepcopy()`來複製「可變值」

承上，既然要建立複本，就要採用穩妥的方式，而穩妥方式就是使用內建方法。

這又又又是一個「物件參照」的相關議題。下一個也是。

------

## 不要使用「可變物件」作為「參數預設值」

這點你可能已經很熟悉了，因為幾乎每一本書都會強調。

我們用下列兩段話（by ChatGPT）來回顧，**為什麼不能這麼做**：

> 在Python 中，不應該用可變物件做預設參數（引數），因為這個可變物件在函式第一次**被定義的時候**就已經「**固定**」了。（**只會建立一次**）

> 以後每次呼叫這個函式但**沒有提供這個引數**的話，都會**共用同一個物件**。如果你在函式裡改變了這個物件，那麼下次呼叫時，**這個改變就被保留下來了**。這會讓程式的行為變得很難預測和控制。

### 一個簡單的例子

參考程式碼，這個函式正常使用時，希望你帶入一個`fruit_list`作為引數——當然，從上面的「[二、使用可變物件作為引數時要小心](https://blog.kyomind.tw/the-quick-python-book/#二、使用可變物件作為引數時要小心)」我們知道，這也是一個不太健康的做法！

關於**使用可變物件為引數，我們先不論**。下面的呼叫我們都不給第二個引數，讓它**只使用參數預設值**。

我們預期的行為是：每次給定不同的水果，且不給`fruit_list`引數，則產出應該都要是「以該水果為單一元素的」的 list——**但事實完全不是如此**。

```python
def add_fruit_to_list(fruit, fruit_list=[]):
    fruit_list.append(fruit)
    return fruit_list

apple_list = add_fruit_to_list('apple')
print(apple_list)  # 輸出: ['apple']

banana_list = add_fruit_to_list('banana')
print(banana_list)  # 輸出: ['apple', 'banana']
print(apple_list)  # 輸出: ['apple', 'banana']
```

當「第二次」呼叫函式時，情況就**不是我們要的**了：

1. banana_list 竟然包含了 apple！
2. apple_list 竟然也被改變了！

### 替代方案

而替代方案想必你也知曉，**就是把預設值改設為**`None`，然後在函式中加上一個判斷，比如下面的`if fruit_list is None:`。

```python
def add_fruit_to_list(fruit, fruit_list=None):
    if fruit_list is None:
        fruit_list = []
    fruit_list.append(fruit)
    return fruit_list

apple_list = add_fruit_to_list('apple')
banana_list = add_fruit_to_list('banana')

print(apple_list)  # 輸出: ['apple']
print(banana_list)  # 輸出: ['banana']
```

當沒有提供`fruit_list`參數（引數）時，`if fruit_list is None:`判斷式會成立，判斷式內通常會**建立一個全新的可變物件**，讓每一次呼叫都會有不同的`fruit_list`可變物件，避免前述的「**狀態殘留**」與意料之外的錯誤。

------

### 不要以字串連接來製作字串

所謂的字串連接，就是使用`+`運算子來合併多個字串。比如：

```python
greeting = 'Hello' + 'World!'
```

連接兩個字串無傷大傷，但如果是這樣的話：

```python
greeting = 'Hello World!'
for i in range(10000):
    greeting += 'one more'
```

就會造成效能上的低落——和下列替代方案相比，慢了近 10 倍。

因為 Python 的**字串**是**不可變**的，所以這種拼接實際上是用舊的字串**建立新的字串**，for 迴圈中的每一次迭代，都會建立一個新字串。

替代方案當然就是經典的 list +`join`字串方法。

```python
greeting_parts = ['Hello World!']
for i in range(10000):
    greeting_parts.append('one more')

greeting = ''.join(greeting_parts)
```

------

## tuple 中即使只有一個元素，也不要忘記加逗號

這個例子非常經典！因為不少人可能寫了超過一年的 Python，都未必知道這個特性，而在某些「意料之外」的事發生後，才赫然發現這個事實。

好，我承認第一次知道時我也很吃驚，還好我是看書知道的。

照標題的意思，單元素 tuple 應該要長這樣：`("cat",)`，而不是這樣`("cat")`。

為什麼？

我們先看一下 ChatGPT 怎麼說：

> 這是因為在 Python 中，括號（這裡指的是「小」括號）被用於**多個目的**，例如分組表達式。當你寫`("cat")`時，括號會**被解釋為分組符號**，所以這個表達式的值**就是字串**`"cat"`，而**不是**包含一個元素的元組（tuple）。

> 如果你想要創建一個只有一個元素的元組，你需要在那個元素後面加上逗號。所以`("cat",)`**才是**包含一個元素的元組。逗號告訴Python你想要創建一個元組，而不僅僅是使用括號進行分組。

非常經典的講解！

就像《[流暢的 Python](https://www.tenlong.com.tw/products/9789863479116)》中說的，逗點才是 tuple 的本體XD。

這也是為什麼我們在函式中 return 複數值時，不需要為它們加上小括號，只要使用逗點分隔，return 自然就是一個 tuple。

```python
def multiple_values():
    return 'apple', 'banana', 42

result = multiple_values()
print(result)  # 輸出: ('apple', 'banana', 42)
```

足見，逗點確實是定義 tuple 的關鍵。

## 第 10 章：寫出有效率的函式

有效率的函式（或說「**好的**」函式）需要你在「**命名、規模大小（行數）、參數數量和複雜性**」之間，做出許多決定和**取捨**。

這無疑是極具挑戰的事——尤其是取捨。

人生之難，就難在取捨。

本章探討的正是這些取捨之間的利弊得失，以及編寫函式的重要原則。不用說，絕對是關鍵的一章。



> 相關文章：重構日誌：如何寫好一個 Python 函式——註解、docstring、解耦（待發表）

## 函式的規模：小就是好？

我們都聽過「函式應該盡可能簡單、一次只做一次件事」之類的建言，也表示認同。從這個精神出發，太大或太複雜的函式就應該要進行拆分。

但！事實是，有效拆分函式是一件耗神、講究細節，且沒有標準答案的事。以致於我們即使知道，也很難完全貫徹，包括我自己。

出於各種原因，我們常常對現實世界作出一定的妥協。

### 小函式的優點

有些人覺得任何函式都不應該超過 20 行，甚至 10、5 行😂。因為函式「短」往往有下面這些優點：

- 單一函式容易理解
- 較少的參數（這確實非常重要！）
- 易於測試與除錯

### 小函式的缺點

但小也有缺點：

- 一樣的邏輯，更小的函式也意味著「更多」的小函式
- 函式愈多，結構就愈複雜。即「函式間」的關係會變得更加複雜
- 愈多函式，函式間的精準命名將成為巨大的挑戰——這真的很困難！

這些「缺點」往往也解釋了為何我們不一定那麼積極拆分函式，讓每一個函式都符合「一次只做一件事」原則。

尤其是小函式造成的大量命名問題，對於命名很講究的我而言，有時確實感到棘手。

### 小結：小不等於短

函式原則上還是應該要盡可能單純一點，該拆就要拆，但不一定要很短。而且其中必然會有很多挑戰。

從「功能」上去劃分界限、拆分函式，會更有意義與指導性，與可行性。

作者認為，一味追求短函式，確實可以讓各別函式變得簡單，但卻很可能讓程式的「整體」變得複雜，適得其反。

他的經驗是，理想情況下，函式最好少於 30 行，最多不超過 200 行。**讓函式在合理情況下盡可能短少**，但不只是為了短少而縮減。

------

## 返回值（return）應該都要有相同的資料型別

對此，我想說：

> 這真的好重要啊！（吶喊）

卻常常沒有被好好遵守。

簡言之，為確保函式的「**可預測性**」，我們應該努力讓函式只回傳「**單一資料型別**」的值。比如**總是**回傳整數或字串，而不要有時回傳字串，有時則回傳布林值。

這不一定容易做到，但我更常遇到的情況是：**明明有替代方案讓回傳型別單一化，卻沒有善用。**

### 以`False`代替`raise`

最常見的例子就是：**該拋出錯誤時候，卻只用`return False` 替代**。

意即，當函式正常執行時，回傳一般正常的 output 值。但當執行失敗時，卻是回傳`False`——這簡直令人髮指，而且我相信你一定看過這樣的函式。

必須說明，發生錯誤時不拋出而選擇`return False`未必總是不好的，就像 Django REST framework 序列化器的`is_valid`方法，預設也是返回一個布林值（可以用`raise_exception=True`參數改為直接拋出錯誤），方便你進行更多後續操作。

不過，**如果你選擇在遇到錯誤時`return False`，則應該在函式正確執行時，`return True`**，以保持回傳型別的一致性。

而且**函式命名**也要跟著配合，讓人一看就知曉**該函式、方法會返回一個布林值**，比如上述的`is_valid`，或常見的`has_permission`、`is_authenticated`等。這些都是常見的最佳實踐。

### 錯誤示範

我們看一下這個錯誤示範：假設我們有一個函式，其目的是從一個`JSON`文件中讀取配置資訊。如果讀取成功，它會返回一個 Python 字典；如果讀取失敗，它會捕捉異常並返回`False`。

```python
import json

def get_config_from_file(file_path):
    try:
        with open(file_path, 'r') as f:
            config = json.load(f)
        return config
    except Exception as e:
        return False  # 這裡是問題所在
```

這個函式在`except`區塊裡面直接返回`False`，這會導致以下問題：

1. **資料型別不一致**：正常情況下返回一個字典，異常情況下返回`False`（布林值）。
2. **誤導函式使用者**：使用者可能會誤以為`False`是一個有效的配置，進而嘗試在其上進行操作，這會導致更多的錯誤。
3. **後續處理困難**：函式使用者必須額外檢查返回值是否為`False`，然後再決定是否進行後續的操作。

「return 型別不確定」肯定不只發生在例外處理，但它確實**很常發生在例外處理**，因為我看過**不止一次**類似的真實案例。

很多人本能地會這樣寫，這往往是因為不習慣、不擅長處理錯誤，所以想要用自己平常更熟悉的`False`。

除此之外，我還看過「函式正常執行回傳一個類別物件，失敗時回傳一個 Python tuple——包含錯誤代碼和錯誤訊息」這種非常**反直覺**的設計。彷彿是在告訴我們：

> 這個函式的回傳值，可能是一個物件，也可能是一個 tuple，你自己判斷吧！

會寫出這樣的函式，原因諸多——工作很忙、重構太麻煩了，要新增什麼功能我直接「加上去」就好！

**充滿了技術債味的寫法。**

### 技術債與認知負擔

這類「**雙型別 return**」的函式，對於**函式使用者**（有可能是你的同事）的認知，有著「**更高的要求**」——呼叫方必須很了解這個函式的**怪異行為**，才能正確使用與處理後續衍生的問題。

這在多行或有多個 return 值的複雜函式時，真是一場災難。

> 期望他人知道自己做了什麼「特別的事」，不是我所知曉的軟體開發之道。

當函式具有這種「雙型別 return」的特性時，會明顯增加呼叫方的「**認知負擔**」。

這使得程式**不僅難以閱讀和維護，也容易出錯**，因為未來的維護者或其他團隊成員**很可能不知道**這個函式的「獨特」行為。

無論何時，我們都不應該寫這樣的程式。

------

## 我對寫好函式的基本看法

寫好函式的重點實在太多了，而本文的篇幅有限，只能擇要為之。

我也講講我認為函式的撰寫中，最重要的兩點。

至少遵守這兩點，你的同事會很感激你。

## Docstring 真的很重要

其一是盡可能地寫 docstring，這不容易，畢竟維護 docstring 也需要心力。

> Docstring 就跟所有開發文件一樣——自己很懶得寫，但如果我想調用別人寫好的程式時，卻希望它們越詳細越好。

而且 docstring 也不是有寫就行，還需要從「**讀者**（也就是你的同事）」的角度去思考與表達。不然看起來會很像開發者的自言自語——沒人看得懂。

然而我也承認，為所有的模組、類別、函式寫 docstring，未免有點不切實際。在眾多函式中，下列兩種是我認為**一定要寫 docstring** 的：

1. **專案「自定義」成份濃厚**：除了開發者本人，沒人知道這段程式在幹什麼。這通常源於特殊的業務需求，而且往往行數超多、邏輯超手刻，各種 if/else、for 迴圈滿天飛，aka——**沒人想看的程式碼**。
2. **流程相對複雜**的函式：愈複雜就愈難理解，這時候 docstring 就是你的好朋友。用文字描述函式的**輸入、輸出、邏輯**，能大大提升我們理解程式碼的效率。

畢竟，看**有描述性的文字**，總比看一長串程式碼，要簡單且友善得多。

關於我對 docstring 的其它討論，可以參考這兩個部分：

- [註解是不需要的？](https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#註解是不需要的？)
- [Python docstring 之我見](https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-之我見)

我的觀點一向如此：**不寫好 docstring，就稱不上是一流的 Python 開發者。**

## 函式的行為與命名要一致

其二，好的函式要「言行一致」。

你可能會想：

> 這不是理所當然的嗎？

對，它**「本應該」是理所當然**的，畢竟這不就是函式命名的基本目的？——用來描述函式的行為。

但我們可以回想一下自己在工作中遇到的各式各樣函式，究竟有多少比例，是真正做到「言行一致」？我覺得可能只有一半。

或許你會認為「一半」也太誇張了！但我並不這麼想。

「言行不一致」通常有下面幾種症狀：

1. 函式名稱只表達了函式「**部分**」的行為。也就是函式做了超過它宣稱要做的事，比如「驗證欄位」函式，竟然還把驗證資料格式化了！
2. 函式名稱「**言過其實**」，說要驗證加格式化，結果只做了一半。
3. 名稱太模糊、缺乏業務邏輯描述、濫用技術詞彙等等，**根本看不懂它在說什麼**，更別說言行一致了。

如果你不能從一個函式的名稱中**有效理解並推測**它應有的行為，那麼這個函式基本上就是失敗（或不健康）的。

很多時候，函式**最初**可能是「言行一致」的，但隨著後來的修改、刪除、擴充，實際上做的事情變更了，但命名卻沒有跟著改變、重構。

這些言行不一的函式，充滿了**誤導性**，不斷地挑戰著你的認知、推理能力，還增加了維護成本。

這樣的例子還少嗎？恐怕每天都在發生。

------

## 第 11 章：注釋、docstring 和 type hints

這章我只摘錄書中的一段話——我特別欣賞與認同的部分：

> 好的注釋對程式設計師在未來閱讀並理解程式碼作用時提供了簡潔、有用和準確的資訊。這些注釋應該**用來解說程式設計師原本的意圖，並總結某程式碼的作用，而不是只對某行程式碼進行解說。**

> 注釋有時會詳細描述程式設計師在編寫程式碼時**所得到的經驗教訓，這些寶貴的資訊可以讓將來的維護者不必再次經歷這些苦難。**

說的太好了！

團隊寫程式，是關於溝通的藝術，畢竟《[人月神話](https://www.books.com.tw/products/0010254508)》已經告訴我們：人多不一定比較快。

溝通不止發生在會議、Jira、Slack 和規格文件上，程式之內也有著大量的溝通，註解是如此，docstring 亦是如此。

永遠不要低估「對這些細節的用心」所帶能來的巨大影響力。

優秀的工程師絕不可能輕忽它們。