# 3.1 HTTP 常見面試題

在面試過程中，HTTP 被提問的概率還是比較高的。

小林我搜集了 6 大類 HTTP 面試常問的題目，同時這 6 大類題跟 **HTTP 的發展和演變**關聯性是比較大的，通過**問答 + 圖解**的形式**由淺入深**的方式幫助大家進一步的學習和理解 HTTP。

1. HTTP 基本概念
2. Get 與 Post
3. HTTP 特性
4. HTTP 緩存技術
5. HTTPS 與 HTTP
6. HTTP/1.1、HTTP/2、HTTP/3 演變

![提綱](https://img-blog.csdnimg.cn/6b9bfd38d2684b3f9843ebabf8771212.png)


## HTTP 基本概念

### HTTP 是什麼？

HTTP 是超文本傳輸協議，也就是**H**yper**T**ext **T**ransfer **P**rotocol。

> 能否詳細解釋「超文本傳輸協議」？

HTTP 的名字「超文本協議傳輸」，它可以拆成三個部分：

- 超文本
- 傳輸
- 協議

![三個部分](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/3-HTTP三部分.png)

*1. 「協議」*

在生活中，我們也能隨處可見「協議」，例如：

- 剛畢業時會籤一個「三方協議」；
- 找房子時會籤一個「租房協議」；


![三方協議和租房協議](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/4-租房和三方協議.png)

生活中的協議，本質上與計算機中的協議是相同的，協議的特點:

- 「**協**」字，代表的意思是必須有**兩個以上的參與者**。例如三方協議裡的參與者有三個：你、公司、學校三個；租房協議裡的參與者有兩個：你和房東。
- 「**議**」字，代表的意思是對參與者的一種**行為約定和規範**。例如三方協議裡規定試用期期限、毀約金等；租房協議裡規定租期期限、每月租金金額、違約如何處理等。

針對 HTTP **協議**，我們可以這麼理解。

HTTP 是一個用在計算機世界裡的**協議**。它使用計算機能夠理解的語言確立了一種計算機之間交流通信的規範（**兩個以上的參與者**），以及相關的各種控制和錯誤處理方式（**行為約定和規範**）。

*2. 「傳輸」*

所謂的「傳輸」，很好理解，就是把一堆東西從 A 點搬到 B 點，或者從 B 點 搬到 A 點。

別輕視了這個簡單的動作，它至少包含兩項重要的信息。

HTTP 協議是一個**雙向協議**。

我們在上網衝浪時，瀏覽器是請求方 A，百度網站就是應答方 B。雙方約定用 HTTP 協議來通信，於是瀏覽器把請求數據發送給網站，網站再把一些數據返回給瀏覽器，最後由瀏覽器渲染在屏幕，就可以看到圖片、視頻了。

![請求 - 應答](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/5-請求應答.png)

數據雖然是在 A 和 B 之間傳輸，但允許中間有**中轉或接力**。

就好像第一排的同學想傳遞紙條給最後一排的同學，那麼傳遞的過程中就需要經過好多個同學（中間人），這樣的傳輸方式就從「A < --- > B」，變成了「A <-> N <-> M <-> B」。

而在 HTTP 裡，需要中間人遵從 HTTP 協議，只要不打擾基本的數據傳輸，就可以添加任意額外的東西。

針對**傳輸**，我們可以進一步理解了 HTTP。

HTTP 是一個在計算機世界裡專門用來在**兩點之間傳輸數據**的約定和規範。

*3. 「超文本」*

HTTP 傳輸的內容是「超文本」。

我們先來理解「文本」，在互聯網早期的時候只是簡單的字符文字，但現在「文本」的涵義已經可以擴展為圖片、視頻、壓縮包等，在 HTTP 眼裡這些都算作「文本」。

再來理解「超文本」，它就是**超越了普通文本的文本**，它是文字、圖片、視頻等的混合體，最關鍵有超鏈接，能從一個超文本跳轉到另外一個超文本。

HTML 就是最常見的超文本了，它本身只是純文字文件，但內部用很多標籤定義了圖片、視頻等的鏈接，再經過瀏覽器的解釋，呈現給我們的就是一個文字、有畫面的網頁了。

OK，經過了對 HTTP 裡這三個名詞的詳細解釋，就可以給出比「超文本傳輸協議」這七個字更準確更有技術含量的答案：

**HTTP 是一個在計算機世界裡專門在「兩點」之間「傳輸」文字、圖片、音頻、視頻等「超文本」數據的「約定和規範」。**

> 那「HTTP 是用於從互聯網服務器傳輸超文本到本地瀏覽器的協議」，這種說法正確嗎？

這種說法是**不正確**的。因為也可以是「服務器< -- >服務器」，所以採用**兩點之間**的描述會更準確。

### HTTP 常見的狀態碼有哪些？

![ 五大類 HTTP 狀態碼 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/6-五大類HTTP狀態碼.png)

`1xx` 類狀態碼屬於**提示信息**，是協議處理中的一種中間狀態，實際用到的比較少。

`2xx` 類狀態碼錶示服務器**成功**處理了客戶端的請求，也是我們最願意看到的狀態。

- 「**200 OK**」是最常見的成功狀態碼，表示一切正常。如果是非 `HEAD` 請求，服務器返回的響應頭都會有 body 數據。

- 「**204 No Content**」也是常見的成功狀態碼，與 200 OK 基本相同，但響應頭沒有 body 數據。

- 「**206 Partial Content**」是應用於 HTTP 分塊下載或斷點續傳，表示響應返回的 body 數據並不是資源的全部，而是其中的一部分，也是服務器處理成功的狀態。

`3xx` 類狀態碼錶示客戶端請求的資源發生了變動，需要客戶端用新的 URL 重新發送請求獲取資源，也就是**重定向**。 

- 「**301 Moved Permanently**」表示永久重定向，說明請求的資源已經不存在了，需改用新的 URL 再次訪問。

- 「**302 Found**」表示臨時重定向，說明請求的資源還在，但暫時需要用另一個 URL 來訪問。

301 和 302 都會在響應頭裡使用字段 `Location`，指明後續要跳轉的 URL，瀏覽器會自動重定向新的 URL。

- 「**304 Not Modified**」不具有跳轉的含義，表示資源未修改，重定向已存在的緩衝文件，也稱緩存重定向，也就是告訴客戶端可以繼續使用緩存資源，用於緩存控制。

`4xx` 類狀態碼錶示客戶端發送的**報文有誤**，服務器無法處理，也就是錯誤碼的含義。

- 「**400 Bad Request**」表示客戶端請求的報文有錯誤，但只是個籠統的錯誤。

- 「**403 Forbidden**」表示服務器禁止訪問資源，並不是客戶端的請求出錯。

- 「**404 Not Found**」表示請求的資源在服務器上不存在或未找到，所以無法提供給客戶端。

`5xx` 類狀態碼錶示客戶端請求報文正確，但是**服務器處理時內部發生了錯誤**，屬於服務器端的錯誤碼。

- 「**500 Internal Server Error**」與 400 類型，是個籠統通用的錯誤碼，服務器發生了什麼錯誤，我們並不知道。

- 「**501 Not Implemented**」表示客戶端請求的功能還不支持，類似“即將開業，敬請期待”的意思。

- 「**502 Bad Gateway**」通常是服務器作為網關或代理時返回的錯誤碼，表示服務器自身工作正常，訪問後端服務器發生了錯誤。

- 「**503 Service Unavailable**」表示服務器當前很忙，暫時無法響應客戶端，類似“網絡服務正忙，請稍後重試”的意思。

### HTTP 常見字段有哪些？

*Host* 字段

客戶端發送請求時，用來指定服務器的域名。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/7-HOST字段.png)

```
Host: www.A.com
```

有了 `Host` 字段，就可以將請求發往「同一臺」服務器上的不同網站。

*Content-Length 字段*

服務器在返回數據時，會有 `Content-Length` 字段，表明本次迴應的數據長度。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/8-content-length字段.png)

```
Content-Length: 1000
```

如上面則是告訴瀏覽器，本次服務器迴應的數據長度是 1000 個字節，後面的字節就屬於下一個迴應了。

大家應該都知道 HTTP 是基於 TCP 傳輸協議進行通信的，而使用了 TCP 傳輸協議，就會存在一個“粘包”的問題，**HTTP 協議通過設置回車符、換行符作為 HTTP header 的邊界，通過 Content-Length 字段作為 HTTP body 的邊界，這兩個方式都是為瞭解決“粘包”的問題**。具體什麼是 TCP 粘包，可以看這篇文章：[如何理解是 TCP 面向字節流協議？](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)

*Connection 字段*

`Connection` 字段最常用於客戶端要求服務器使用「HTTP 長連接」機制，以便其他請求複用。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/9-connection字段.png)

HTTP 長連接的特點是，只要任意一端沒有明確提出斷開連接，則保持 TCP 連接狀態。

![HTTP 長連接](https://img-blog.csdnimg.cn/img_convert/d2b20d1cc03936332adb2a68512eb167.png)

HTTP/1.1 版本的默認連接都是長連接，但為了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值為 `Keep-Alive`。

```
Connection: Keep-Alive
```

開啟了 HTTP Keep-Alive 機制後， 連接就不會中斷，而是保持連接。當客戶端發送另一個請求時，它會使用同一個連接，一直持續到客戶端或服務器端提出斷開連接。

PS：大家不要把 HTTP  Keep-Alive 和 TCP Keepalive 搞混了，這兩個雖然長的像，但是不是一個東西，具體可以看我這篇文章：[TCP Keepalive 和 HTTP Keep-Alive 是一個東西嗎？](https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html)

*Content-Type 字段*

`Content-Type` 字段用於服務器迴應時，告訴客戶端，本次數據是什麼格式。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/10-content-type字段.png)

```
Content-Type: text/html; Charset=utf-8
```

上面的類型表明，發送的是網頁，而且編碼是UTF-8。

客戶端請求的時候，可以使用 `Accept` 字段聲明自己可以接受哪些數據格式。

```
Accept: */*
```

上面代碼中，客戶端聲明自己可以接受任何格式的數據。

*Content-Encoding 字段*

`Content-Encoding` 字段說明數據的壓縮方法。表示服務器返回的數據使用了什麼壓縮格式

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/11-content-encoding字段.png)


```
Content-Encoding: gzip
```

上面表示服務器返回的數據採用了 gzip 方式壓縮，告知客戶端需要用此方式解壓。

客戶端在請求時，用 `Accept-Encoding` 字段說明自己可以接受哪些壓縮方法。

```
Accept-Encoding: gzip, deflate
```

---

## GET 與 POST

### GET 和 POST 有什麼區別？

根據 RFC 規範，**GET 的語義是從服務器獲取指定的資源**，這個資源可以是靜態的文本、頁面、圖片視頻等。GET 請求的參數位置一般是寫在 URL 中，URL 規定只能支持 ASCII，所以 GET 請求的參數只允許 ASCII 字符 ，而且瀏覽器會對 URL 的長度有限制（HTTP協議本身對 URL長度並沒有做任何規定）。

比如，你打開我的文章，瀏覽器就會發送 GET 請求給服務器，服務器就會返回文章的所有文字及資源。

![GET 請求](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/12-Get請求.png)

根據 RFC 規範，**POST 的語義是根據請求負荷（報文body）對指定的資源做出處理**，具體的處理方式視資源類型而不同。POST 請求攜帶數據的位置一般是寫在報文 body 中，body 中的數據可以是任意格式的數據，只要客戶端與服務端協商好即可，而且瀏覽器不會對 body 大小做限制。

比如，你在我文章底部，敲入了留言後點擊「提交」（**暗示你們留言**），瀏覽器就會執行一次 POST 請求，把你的留言文字放進了報文 body 裡，然後拼接好 POST 請求頭，通過 TCP 協議發送給服務器。

![POST 請求](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/13-Post請求.png)

### GET 和 POST 方法都是安全和冪等的嗎？

先說明下安全和冪等的概念：

- 在 HTTP 協議裡，所謂的「安全」是指請求方法不會「破壞」服務器上的資源。
- 所謂的「冪等」，意思是多次執行相同的操作，結果都是「相同」的。

如果從 RFC 規範定義的語義來看： 

- **GET 方法就是安全且冪等的**，因為它是「只讀」操作，無論操作多少次，服務器上的數據都是安全的，且每次的結果都是相同的。所以，**可以對 GET 請求的數據做緩存，這個緩存可以做到瀏覽器本身上（徹底避免瀏覽器發請求），也可以做到代理上（如nginx），而且在瀏覽器中 GET 請求可以保存為書籤**。
- **POST** 因為是「新增或提交數據」的操作，會修改服務器上的資源，所以是**不安全**的，且多次提交數據就會創建多個資源，所以**不是冪等**的。所以，**瀏覽器一般不會緩存 POST 請求，也不能把 POST 請求保存為書籤**。

做個簡要的小結。

GET 的語義是請求獲取指定的資源。GET 方法是安全、冪等、可被緩存的。

POST 的語義是根據請求負荷（報文主體）對指定的資源做出處理，具體的處理方式視資源類型而不同。POST 不安全，不冪等，（大部分實現）不可緩存。

注意， 上面是從 RFC 規範定義的語義來分析的。

但是實際過程中，開發者不一定會按照 RFC 規範定義的語義來實現 GET 和 POST 方法。比如：

- 可以用 GET 方法實現新增或刪除數據的請求，這樣實現的 GET 方法自然就不是安全和冪等。
- 可以用 POST 方法實現查詢數據的請求，這樣實現的  POST 方法自然就是安全和冪等。

曾經有個笑話，有人寫了個博客，刪除博客用的是 GET 請求，他覺得沒人訪問就連鑑權都沒做。然後 Google 服務器爬蟲爬了一遍，他所有博文就沒了。。。

如果「安全」放入概念是指信息是否會被洩漏的話，雖然 POST 用 body 傳輸數據，而 GET 用 URL 傳輸，這樣數據會在瀏覽器地址攔容易看到，但是並不能說 GET 不如 POST 安全的。

因為 HTTP 傳輸的內容都是明文的，雖然在瀏覽器地址攔看不到 POST 提交的 body 數據，但是隻要抓個包就都能看到了。

所以，要避免傳輸過程中數據被竊取，就要使用 HTTPS 協議，這樣所有 HTTP 的數據都會被加密傳輸。

> GET 請求可以帶 body 嗎？

RFC 規範並沒有規定 GET 請求不能帶 body 的。理論上，任何請求都可以帶 body 的。只是因為 RFC 規範定義的 GET 請求是獲取資源，所以根據這個語義不需要用到 body。

另外，URL 中的查詢參數也不是 GET 所獨有的，POST 請求的 URL 中也可以有參數的。

## HTTP 緩存技術

### HTTP 緩存有哪些實現方式？

對於一些具有重複性的 HTTP 請求，比如每次請求得到的數據都一樣的，我們可以把這對「請求-響應」的數據都**緩存在本地**，那麼下次就直接讀取本地的數據，不必在通過網絡獲取服務器的響應了，這樣的話 HTTP/1.1 的性能肯定肉眼可見的提升。

所以，避免發送 HTTP 請求的方法就是通過**緩存技術**，HTTP 設計者早在之前就考慮到了這點，因此 HTTP 協議的頭部有不少是針對緩存的字段。

HTTP 緩存有兩種實現方式，分別是**強制緩存和協商緩存**。

### 什麼是強制緩存？

強緩存指的是隻要瀏覽器判斷緩存沒有過期，則直接使用瀏覽器的本地緩存，決定是否使用緩存的主動性在於瀏覽器這邊。

如下圖中，返回的是 200 狀態碼，但在 size 項中標識的是 from disk cache，就是使用了強制緩存。

![](https://img-blog.csdnimg.cn/1cb6bc37597e4af8adfef412bfc57a42.png)

強緩存是利用下面這兩個 HTTP 響應頭部（Response Header）字段實現的，它們都用來表示資源在客戶端緩存的有效期：

- `Cache-Control`， 是一個相對時間；
- `Expires`，是一個絕對時間；

如果 HTTP 響應頭部同時有 Cache-Control 和 Expires 字段的話，**Cache-Control 的優先級高於 Expires** 。

Cache-control 選項更多一些，設置更加精細，所以建議使用 Cache-Control 來實現強緩存。具體的實現流程如下：

- 當瀏覽器第一次請求訪問服務器資源時，服務器會在返回這個資源的同時，在 Response 頭部加上 Cache-Control，Cache-Control 中設置了過期時間大小；
- 瀏覽器再次請求訪問服務器中的該資源時，會先**通過請求資源的時間與 Cache-Control 中設置的過期時間大小，來計算出該資源是否過期**，如果沒有，則使用該緩存，否則重新請求服務器；
- 服務器再次收到請求後，會再次更新 Response 頭部的 Cache-Control。

### 什麼是協商緩存？

當我們在瀏覽器使用開發者工具的時候，你可能會看到過某些請求的響應碼是 `304`，這個是告訴瀏覽器可以使用本地緩存的資源，通常這種通過服務端告知客戶端是否可以使用緩存的方式被稱為協商緩存。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png)

上圖就是一個協商緩存的過程，所以**協商緩存就是與服務端協商之後，通過協商結果來判斷是否使用本地緩存**。

協商緩存可以基於兩種頭部來實現。

第一種：請求頭部中的 `If-Modified-Since` 字段與響應頭部中的 `Last-Modified` 字段實現，這兩個字段的意思是：

- 響應頭部中的 `Last-Modified`：標示這個響應資源的最後修改時間；
- 請求頭部中的 `If-Modified-Since`：當資源過期了，發現響應頭中具有 Last-Modified 聲明，則再次發起請求的時候帶上 Last-Modified 的時間，服務器收到請求後發現有 If-Modified-Since 則與被請求資源的最後修改時間進行對比（Last-Modified），如果最後修改時間較新（大），說明資源又被改過，則返回最新資源，HTTP 200 OK；如果最後修改時間較舊（小），說明資源無新修改，響應 HTTP 304 走緩存。


第二種：請求頭部中的 `If-None-Match` 字段與響應頭部中的 `ETag` 字段，這兩個字段的意思是：
  - 響應頭部中 `Etag`：唯一標識響應資源；
  - 請求頭部中的 `If-None-Match`：當資源過期時，瀏覽器發現響應頭裡有 Etag，則再次向服務器發起請求時，會將請求頭 If-None-Match 值設置為 Etag 的值。服務器收到請求後進行比對，如果資源沒有變化返回 304，如果資源變化了返回 200。

第一種實現方式是基於時間實現的，第二種實現方式是基於一個唯一標識實現的，相對來說後者可以更加準確地判斷文件內容是否被修改，避免由於時間篡改導致的不可靠問題。

如果在第一次請求資源的時候，服務端返回的 HTTP 響應頭部同時有 Etag 和 Last-Modified 字段，那麼客戶端再下一次請求的時候，如果帶上了 ETag 和 Last-Modified 字段信息給服務端，**這時 Etag 的優先級更高**，也就是服務端先會判斷 Etag 是否變化了，如果 Etag 有變化就不用在判斷 Last-Modified 了，如果 Etag 沒有變化，然後再看  Last-Modified。

**為什麼 ETag 的優先級更高？** 這是因為 ETag 主要能解決 Last-Modified 幾個比較難以解決的問題：

1. 在沒有修改文件內容情況下文件的最後修改時間可能也會改變，這會導致客戶端認為這文件被改動了，從而重新請求；
2. 可能有些文件是在秒級以內修改的，`If-Modified-Since` 能檢查到的粒度是秒級的，使用 Etag就能夠保證這種需求下客戶端在 1 秒內能刷新多次；
3. 有些服務器不能精確獲取文件的最後修改時間。

注意，**協商緩存這兩個字段都需要配合強制緩存中 Cache-Control 字段來使用，只有在未能命中強制緩存的時候，才能發起帶有協商緩存字段的請求**。

下圖是強制緩存和協商緩存的工作流程：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http緩存.png)

當使用 ETag 字段實現的協商緩存的過程：

- 當瀏覽器第一次請求訪問服務器資源時，服務器會在返回這個資源的同時，在 Response 頭部加上 ETag 唯一標識，這個唯一標識的值是根據當前請求的資源生成的；
- 當瀏覽器再次請求訪問服務器中的該資源時，首先會先檢查強制緩存是否過期：
  - 如果沒有過期，則直接使用本地緩存；
  - 如果緩存過期了，會在 Request 頭部加上 If-None-Match 字段，該字段的值就是 ETag 唯一標識；
- 服務器再次收到請求後，**會根據請求中的 If-None-Match 值與當前請求的資源生成的唯一標識進行比較**：
  - **如果值相等，則返回 304 Not Modified，不會返回資源**；
  - 如果不相等，則返回 200 狀態碼和返回資源，並在 Response 頭部加上新的 ETag 唯一標識；
- 如果瀏覽器收到 304 的請求響應狀態碼，則會從本地緩存中加載資源，否則更新資源。

## HTTP 特性

到目前為止，HTTP 常見到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一樣的。

這裡先用  HTTP/1.1 版本給大家介紹，其他版本的後續也會介紹。

###  HTTP/1.1 的優點有哪些？

HTTP 最突出的優點是「簡單、靈活和易於擴展、應用廣泛和跨平臺」。

*1. 簡單*

HTTP 基本的報文格式就是 `header + body`，頭部信息也是 `key-value` 簡單文本的形式，**易於理解**，降低了學習和使用的門檻。

*2. 靈活和易於擴展*

HTTP 協議裡的各類請求方法、URI/URL、狀態碼、頭字段等每個組成要求都沒有被固定死，都允許開發人員**自定義和擴充**。

同時 HTTP 由於是工作在應用層（ `OSI` 第七層），則它**下層可以隨意變化**，比如：

- HTTPS 就是在 HTTP 與 TCP 層之間增加了 SSL/TLS 安全傳輸層；
- HTTP/1.1 和 HTTP/2.0 傳輸協議使用的是 TCP 協議，而到了 HTTP/3.0 傳輸協議改用了 UDP 協議。

*3. 應用廣泛和跨平臺*

互聯網發展至今，HTTP 的應用範圍非常的廣泛，從臺式機的瀏覽器到手機上的各種 APP，從看新聞、刷貼吧到購物、理財、吃雞，HTTP 的應用遍地開花，同時天然具有**跨平臺**的優越性。

### HTTP/1.1 的缺點有哪些？

HTTP 協議裡有優缺點一體的**雙刃劍**，分別是「無狀態、明文傳輸」，同時還有一大缺點「不安全」。

*1. 無狀態雙刃劍*

無狀態的**好處**，因為服務器不會去記憶 HTTP 的狀態，所以不需要額外的資源來記錄狀態信息，這能減輕服務器的負擔，能夠把更多的 CPU 和內存用來對外提供服務。

無狀態的**壞處**，既然服務器沒有記憶能力，它在完成有關聯性的操作時會非常麻煩。

例如登錄->添加購物車->下單->結算->支付，這系列操作都要知道用戶的身份才行。但服務器不知道這些請求是有關聯的，每次都要問一遍身份信息。

這樣每操作一次，都要驗證信息，這樣的購物體驗還能愉快嗎？別問，問就是**酸爽**！

對於無狀態的問題，解法方案有很多種，其中比較簡單的方式用 **Cookie** 技術。

`Cookie` 通過在請求和響應報文中寫入 Cookie 信息來控制客戶端的狀態。

相當於，**在客戶端第一次請求後，服務器會下發一個裝有客戶信息的「小貼紙」，後續客戶端請求服務器的時候，帶上「小貼紙」，服務器就能認得了了**，


![Cookie 技術](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/14-cookie技術.png)

*2. 明文傳輸雙刃劍*

明文意味著在傳輸過程中的信息，是可方便閱讀的，比如 Wireshark 抓包都可以直接肉眼查看，為我們調試工作帶了極大的便利性。

但是這正是這樣，HTTP 的所有信息都暴露在了光天化日下，相當於**信息裸奔**。在傳輸的漫長的過程中，信息的內容都毫無隱私可言，很容易就能被竊取，如果裡面有你的賬號密碼信息，那**你號沒了**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/15-你號沒了.png)

*3. 不安全*

HTTP 比較嚴重的缺點就是不安全：

- 通信使用明文（不加密），內容可能會被竊聽。比如，**賬號信息容易洩漏，那你號沒了。**
- 不驗證通信方的身份，因此有可能遭遇偽裝。比如，**訪問假的淘寶、拼多多，那你錢沒了。**
- 無法證明報文的完整性，所以有可能已遭篡改。比如，**網頁上植入垃圾廣告，視覺汙染，眼沒了。**

HTTP 的安全問題，可以用 HTTPS 的方式解決，也就是通過引入 SSL/TLS 層，使得在安全上達到了極致。

###  HTTP/1.1 的性能如何？

HTTP 協議是基於 **TCP/IP**，並且使用了「**請求 - 應答**」的通信模式，所以性能的關鍵就在這**兩點**裡。

*1. 長連接*

早期 HTTP/1.0 性能上的一個很大的問題，那就是每發起一個請求，都要新建一次 TCP 連接（三次握手），而且是串行請求，做了無謂的 TCP 連接建立和斷開，增加了通信開銷。

為瞭解決上述 TCP 連接問題，HTTP/1.1 提出了**長連接**的通信方式，也叫持久連接。這種方式的好處在於減少了 TCP 連接的重複建立和斷開所造成的額外開銷，減輕了服務器端的負載。

持久連接的特點是，只要任意一端沒有明確提出斷開連接，則保持 TCP 連接狀態。

![短連接與長連接](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/16-短連接與長連接.png)

當然，如果某個 HTTP 長連接超過一定時間沒有任何數據交互，服務端就會主動斷開這個連接。

*2. 管道網絡傳輸*

HTTP/1.1 採用了長連接的方式，這使得管道（pipeline）網絡傳輸成為了可能。

即可在同一個 TCP 連接裡面，客戶端可以發起多個請求，只要第一個請求發出去了，不必等其回來，就可以發第二個請求出去，可以**減少整體的響應時間。**

舉例來說，客戶端需要請求兩個資源。以前的做法是，在同一個 TCP 連接裡面，先發送 A 請求，然後等待服務器做出迴應，收到後再發出 B 請求。那麼，管道機制則是允許瀏覽器同時發出 A 請求和 B 請求，如下圖：

![管道網絡傳輸](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/17-管道網絡傳輸.png)

但是**服務器必須按照接收請求的順序發送對這些管道化請求的響應**。

如果服務端在處理 A 請求時耗時比較長，那麼後續的請求的處理都會被阻塞住，這稱為「隊頭堵塞」。

所以，**HTTP/1.1 管道解決了請求的隊頭阻塞，但是沒有解決響應的隊頭阻塞**。

::: tip

**注意!!!**

實際上 HTTP/1.1 管道化技術不是默認開啟，而且瀏覽器基本都沒有支持，所以**後面所有文章討論 HTTP/1.1 都是建立在沒有使用管道化的前提**。大家知道有這個功能，但是沒有被使用就行了。

:::

*3. 隊頭阻塞* 

「請求 - 應答」的模式加劇了 HTTP 的性能問題。

因為當順序發送的請求序列中的一個請求因為某種原因被阻塞時，在後面排隊的所有請求也一同被阻塞了，會招致客戶端一直請求不到數據，這也就是「**隊頭阻塞**」，好比上班的路上塞車。

![隊頭阻塞](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/18-隊頭阻塞.png)

總之 HTTP/1.1 的性能一般般，後續的 HTTP/2 和 HTTP/3 就是在優化 HTTP 的性能。

## HTTP 與 HTTPS

### HTTP 與 HTTPS 有哪些區別？

- HTTP 是超文本傳輸協議，信息是明文傳輸，存在安全風險的問題。HTTPS 則解決 HTTP 不安全的缺陷，在 TCP 和 HTTP 網絡層之間加入了 SSL/TLS 安全協議，使得報文能夠加密傳輸。

- HTTP 連接建立相對簡單， TCP 三次握手之後便可進行 HTTP 的報文傳輸。而 HTTPS 在 TCP 三次握手之後，還需進行 SSL/TLS 的握手過程，才可進入加密報文傳輸。

- 兩者的默認端口不一樣，HTTP 默認端口號是 80，HTTPS 默認端口號是 443。

- HTTPS 協議需要向 CA（證書權威機構）申請數字證書，來保證服務器的身份是可信的。

### HTTPS 解決了 HTTP 的哪些問題？

HTTP 由於是明文傳輸，所以安全上存在以下三個風險：

- **竊聽風險**，比如通信鏈路上可以獲取通信內容，用戶號容易沒。
- **篡改風險**，比如強制植入垃圾廣告，視覺汙染，用戶眼容易瞎。
- **冒充風險**，比如冒充淘寶網站，用戶錢容易沒。

![HTTP 與 HTTPS 網絡層](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/19-HTTPS與HTTP.png)

HTTP**S** 在 HTTP 與 TCP 層之間加入了 `SSL/TLS` 協議，可以很好的解決了上述的風險：

- **信息加密**：交互信息無法被竊取，但你的號會因為「自身忘記」賬號而沒。
- **校驗機制**：無法篡改通信內容，篡改了就不能正常顯示，但百度「競價排名」依然可以搜索垃圾廣告。
- **身份證書**：證明淘寶是真的淘寶網，但你的錢還是會因為「剁手」而沒。

可見，只要自身不做「惡」，SSL/TLS 協議是能保證通信是安全的。

> HTTPS 是如何解決上面的三個風險的？

- **混合加密**的方式實現信息的**機密性**，解決了竊聽的風險。
- **摘要算法**的方式來實現**完整性**，它能夠為數據生成獨一無二的「指紋」，指紋用於校驗數據的完整性，解決了篡改的風險。
- 將服務器公鑰放入到**數字證書**中，解決了冒充的風險。


*1. 混合加密*

通過**混合加密**的方式可以保證信息的**機密性**，解決了竊聽的風險。

![混合加密](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/20-混合加密.png)

HTTPS 採用的是**對稱加密**和**非對稱加密**結合的「混合加密」方式：

- 在通信建立前採用**非對稱加密**的方式交換「會話祕鑰」，後續就不再使用非對稱加密。
- 在通信過程中全部使用**對稱加密**的「會話祕鑰」的方式加密明文數據。

採用「混合加密」的方式的原因：

- **對稱加密**只使用一個密鑰，運算速度快，密鑰必須保密，無法做到安全的密鑰交換。
- **非對稱加密**使用兩個密鑰：公鑰和私鑰，公鑰可以任意分發而私鑰保密，解決了密鑰交換問題但速度慢。

*2. 摘要算法 + 數字簽名*

為了保證傳輸的內容不被篡改，我們需要對內容計算出一個「指紋」，然後同內容一起傳輸給對方。

對方收到後，先是對內容也計算出一個「指紋」，然後跟發送方發送的「指紋」做一個比較，如果「指紋」相同，說明內容沒有被篡改，否則就可以判斷出內容被篡改了。

那麼，在計算機裡會**用摘要算法（哈希函數）來計算出內容的哈希值**，也就是內容的「指紋」，這個**哈希值是唯一的，且無法通過哈希值推導出內容**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/摘要算法.png)

通過哈希算法可以確保內容不會被篡改，**但是並不能保證「內容 + 哈希值」不會被中間人替換，因為這裡缺少對客戶端收到的消息是否來源於服務端的證明**。

舉個例子，你想向老師請假，一般來說是要求由家長寫一份請假理由並簽名，老師才能允許你請假。

但是你有模仿你爸爸字跡的能力，你用你爸爸的字跡寫了一份請假理由然後簽上你爸爸的名字，老師一看到這個請假條，查看字跡和簽名，就誤以為是你爸爸寫的，就會允許你請假。

那作為老師，要如何避免這種情況發生呢？現實生活中的，可以通過電話或視頻來確認是否是由父母發出的請假，但是計算機裡可沒有這種操作。

那為了避免這種情況，計算機裡會用**非對稱加密算法**來解決，共有兩個密鑰：

- 一個是公鑰，這個是可以公開給所有人的；
- 一個是私鑰，這個必須由本人管理，不可洩露。

這兩個密鑰可以**雙向加解密**的，比如可以用公鑰加密內容，然後用私鑰解密，也可以用私鑰加密內容，公鑰解密內容。

流程的不同，意味著目的也不相同：

- **公鑰加密，私鑰解密**。這個目的是為了**保證內容傳輸的安全**，因為被公鑰加密的內容，其他人是無法解密的，只有持有私鑰的人，才能解密出實際的內容；
- **私鑰加密，公鑰解密**。這個目的是為了**保證消息不會被冒充**，因為私鑰是不可洩露的，如果公鑰能正常解密出私鑰加密的內容，就能證明這個消息是來源於持有私鑰身份的人發送的。

一般我們不會用非對稱加密來加密實際的傳輸內容，因為非對稱加密的計算比較耗費性能的。

所以非對稱加密的用途主要在於**通過「私鑰加密，公鑰解密」的方式，來確認消息的身份**，我們常說的**數字簽名算法**，就是用的是這種方式，不過私鑰加密內容不是內容本身，而是**對內容的哈希值加密**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/數字簽名.png)

私鑰是由服務端保管，然後服務端會向客戶端頒發對應的公鑰。如果客戶端收到的信息，能被公鑰解密，就說明該消息是由服務器發送的。

引入了數字簽名算法後，你就無法模仿你爸爸的字跡來請假了，你爸爸手上持有著私鑰，你老師持有著公鑰。

這樣只有用你爸爸手上的私鑰才對請假條進行「簽名」，老師通過公鑰看能不能解出這個「簽名」，如果能解出並且確認內容的完整性，就能證明是由你爸爸發起的請假條，這樣老師才允許你請假，否則老師就不認。

*3. 數字證書*

前面我們知道：

- 可以通過哈希算法來保證消息的完整性；
- 可以通過數字簽名來保證消息的來源可靠性（能確認消息是由持有私鑰的一方發送的）；

但是這還遠遠不夠，**還缺少身份驗證的環節**，萬一公鑰是被偽造的呢？

還是拿請假的例子，雖然你爸爸持有私鑰，老師通過是否能用公鑰解密來確認這個請假條是不是來源你父親的。

但是我們還可以自己偽造出一對公私鑰啊！

你找了個夜晚，偷偷把老師桌面上和你爸爸配對的公鑰，換成了你的公鑰，那麼下次你在請假的時候，你繼續模仿你爸爸的字跡寫了個請假條，然後用你的私鑰做個了「數字簽名」。

但是老師並不知道自己的公鑰被你替換過了，所以他還是按照往常一樣用公鑰解密，由於這個公鑰和你的私鑰是配對的，老師當然能用這個被替換的公鑰解密出來，並且確認了內容的完整性，於是老師就會以為是你父親寫的請假條，又允許你請假了。

好傢伙，為了一個請假，真的是鬥智鬥勇。

後面你的老師和父親發現了你偽造公私鑰的事情後，決定重新商量一個對策來應對你這個臭傢伙。

正所謂魔高一丈，道高一尺。

既然偽造公私鑰那麼隨意，所以你爸把他的公鑰註冊到**警察局**，警察局用他們自己的私鑰對你父親的公鑰做了個數字簽名，然後把你爸爸的「個人信息 + 公鑰 + 數字簽名」打包成一個**數字證書，也就是說這個數字證書包含你爸爸的公鑰。**

這樣，你爸爸如果因為家裡確實有事要向老師幫你請假的時候，不僅會用自己的私鑰對內容進行簽名，還會把數字證書給到老師。

老師拿到了數字證書後，**首先會去警察局驗證這個數字證書是否合法**，因為數字證書裡有警察局的數字簽名，警察局要驗證證書合法性的時候，用自己的公鑰解密，如果能解密成功，就說明這個數字證書是在警察局註冊過的，就認為該數字證書是合法的，然後就會把數字證書裡頭的公鑰（你爸爸的）給到老師。

**由於通過警察局驗證了數字證書是合法的，那麼就能證明這個公鑰就是你父親的**，於是老師就可以安心的用這個公鑰解密出清教條，如果能解密出，就證明是你爸爸寫的請假條。

正是通過了一個權威的機構來證明你爸爸的身份，所以你的偽造公私鑰這個小伎倆就沒用了。

在計算機裡，這個權威的機構就是 CA （數字證書認證機構），將服務器公鑰放在數字證書（由數字證書認證機構頒發）中，只要證書是可信的，公鑰就是可信的。

數字證書的工作流程，我也畫了一張圖，方便大家理解：

![數子證書工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/22-數字證書工作流程.png)

通過數字證書的方式保證服務器公鑰的身份，解決冒充的風險。

### HTTPS  是如何建立連接的？其間交互了什麼？

SSL/TLS 協議基本流程：

- 客戶端向服務器索要並驗證服務器的公鑰。
- 雙方協商生產「會話祕鑰」。
- 雙方採用「會話祕鑰」進行加密通信。

前兩步也就是 SSL/TLS 的建立過程，也就是 TLS 握手階段。

TLS 的「握手階段」涉及**四次**通信，使用不同的密鑰交換算法，TLS 握手流程也會不一樣的，現在常用的密鑰交換算法有兩種：[RSA 算法](https://xiaolincoding.com/network/2_http/https_rsa.html) 和 [ECDHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。

基於 RSA 算法的 TLS 握手過程比較容易理解，所以這裡先用這個給大家展示 TLS 握手過程，如下圖：

![HTTPS 連接建立過程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/23-HTTPS工作流程.png)


TLS 協議建立的詳細流程：

*1. ClientHello*

首先，由客戶端向服務器發起加密通信請求，也就是 `ClientHello` 請求。

在這一步，客戶端主要向服務器發送以下信息：

（1）客戶端支持的 TLS 協議版本，如 TLS 1.2 版本。

（2）客戶端生產的隨機數（`Client Random`），後面用於生成「會話祕鑰」條件之一。

（3）客戶端支持的密碼套件列表，如 RSA 加密算法。

*2. SeverHello*

服務器收到客戶端請求後，向客戶端發出響應，也就是 `ServerHello`。服務器迴應的內容有如下內容：

（1）確認 TLS 協議版本，如果瀏覽器不支持，則關閉加密通信。

（2）服務器生產的隨機數（`Server Random`），也是後面用於生產「會話祕鑰」條件之一。

（3）確認的密碼套件列表，如 RSA 加密算法。

（4）服務器的數字證書。

*3.客戶端迴應*

客戶端收到服務器的迴應之後，首先通過瀏覽器或者操作系統中的 CA 公鑰，確認服務器的數字證書的真實性。

如果證書沒有問題，客戶端會**從數字證書中取出服務器的公鑰**，然後使用它加密報文，向服務器發送如下信息：

（1）一個隨機數（`pre-master key`）。該隨機數會被服務器公鑰加密。

（2）加密通信算法改變通知，表示隨後的信息都將用「會話祕鑰」加密通信。

（3）客戶端握手結束通知，表示客戶端的握手階段已經結束。這一項同時把之前所有內容的發生的數據做個摘要，用來供服務端校驗。

上面第一項的隨機數是整個握手階段的第三個隨機數，會發給服務端，所以這個隨機數客戶端和服務端都是一樣的。

**服務器和客戶端有了這三個隨機數（Client Random、Server Random、pre-master key），接著就用雙方協商的加密算法，各自生成本次通信的「會話祕鑰」**。

*4. 服務器的最後迴應*

服務器收到客戶端的第三個隨機數（`pre-master key`）之後，通過協商的加密算法，計算出本次通信的「會話祕鑰」。

然後，向客戶端發送最後的信息：

（1）加密通信算法改變通知，表示隨後的信息都將用「會話祕鑰」加密通信。

（2）服務器握手結束通知，表示服務器的握手階段已經結束。這一項同時把之前所有內容的發生的數據做個摘要，用來供客戶端校驗。

至此，整個 TLS 的握手階段全部結束。接下來，客戶端與服務器進入加密通信，就完全是使用普通的 HTTP 協議，只不過用「會話祕鑰」加密內容。

::: tip

如果想深入學習基於 RSA 算法的 HTTPS 握手過程，可以看這篇，我通過抓包的方式，逐步分析每一個過程：[HTTPS RSA 握手解析](https://xiaolincoding.com/network/2_http/https_rsa.html)

不過，基於 RSA 算法的 HTTPS 存在「前向安全」的問題：如果服務端的私鑰洩漏了，過去被第三方截獲的所有 TLS 通訊密文都會被破解。

為瞭解決這個問題，後面就出現了 ECDHE 密鑰協商算法，我們現在大多數網站使用的正是 ECDHE 密鑰協商算法，關於 ECDHE 握手的過程可以看這篇文章：[HTTPS ECDHE 握手解析](https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0)

:::

> 客戶端校驗數字證書的流程是怎樣的？

接下來，詳細說一下實際中數字證書籤發和驗證流程。

如下圖圖所示，為數字證書籤發和驗證流程：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png)

CA 簽發證書的過程，如上圖左邊部分：

- 首先 CA 會把持有者的公鑰、用途、頒發者、有效時間等信息打成一個包，然後對這些信息進行 Hash 計算，得到一個 Hash 值；
- 然後 CA 會使用自己的私鑰將該 Hash 值加密，生成 Certificate Signature，也就是 CA 對證書做了簽名；
- 最後將 Certificate Signature 添加在文件證書上，形成數字證書；

客戶端校驗服務端的數字證書的過程，如上圖右邊部分：

- 首先客戶端會使用同樣的 Hash 算法獲取該證書的 Hash 值 H1；
- 通常瀏覽器和操作系統中集成了 CA 的公鑰信息，瀏覽器收到證書後可以使用 CA 的公鑰解密 Certificate Signature 內容，得到一個 Hash 值 H2 ；
- 最後比較 H1 和 H2，如果值相同，則為可信賴的證書，否則則認為證書不可信。

但事實上，證書的驗證過程中**還存在一個證書信任鏈的問題**，因為我們向 CA 申請的證書一般不是根證書籤發的，而是由中間證書籤發的，比如百度的證書，從下圖你可以看到，證書的層級有三級：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png)

對於這種三級層級關係的證書的驗證過程如下：

- 客戶端收到 baidu.com 的證書後，發現這個證書的簽發者不是根證書，就無法根據本地已有的根證書中的公鑰去驗證 baidu.com 證書是否可信。於是，客戶端根據 baidu.com 證書中的簽發者，找到該證書的頒發機構是 “GlobalSign Organization Validation CA - SHA256 - G2”，然後向 CA 請求該中間證書。
- 請求到證書後發現 “GlobalSign Organization Validation CA - SHA256 - G2” 證書是由 “GlobalSign Root CA” 簽發的，由於 “GlobalSign Root CA” 沒有再上級簽發機構，說明它是根證書，也就是自簽證書。應用軟件會檢查此證書有否已預載於根證書清單上，如果有，則可以利用根證書中的公鑰去驗證 “GlobalSign Organization Validation CA - SHA256 - G2” 證書，如果發現驗證通過，就認為該中間證書是可信的。
- “GlobalSign Organization Validation CA - SHA256 - G2” 證書被信任後，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 證書中的公鑰去驗證 baidu.com 證書的可信性，如果驗證通過，就可以信任 baidu.com 證書。

在這四個步驟中，最開始客戶端只信任根證書 GlobalSign Root CA 證書的，然後 “GlobalSign Root CA” 證書信任 “GlobalSign Organization Validation CA - SHA256 - G2” 證書，而 “GlobalSign Organization Validation CA - SHA256 - G2” 證書又信任 baidu.com 證書，於是客戶端也信任 baidu.com 證書。

總括來說，由於用戶信任 GlobalSign，所以由 GlobalSign 所擔保的 baidu.com 可以被信任，另外由於用戶信任操作系統或瀏覽器的軟件商，所以由軟件商預載了根證書的 GlobalSign 都可被信任。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.png)

操作系統裡一般都會內置一些根證書，比如我的 MAC 電腦裡內置的根證書有這麼多：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%B3%BB%E7%BB%9F%E6%A0%B9%E8%AF%81%E4%B9%A6.png)

這樣的一層層地驗證就構成了一條信任鏈路，整個證書信任鏈驗證流程如下圖所示：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png)

最後一個問題，為什麼需要證書鏈這麼麻煩的流程？Root CA 為什麼不直接頒發證書，而是要搞那麼多中間層級呢？

**這是為了確保根證書的絕對安全性，將根證書隔離地越嚴格越好，不然根證書如果失守了，那麼整個信任鏈都會有問題。**

### HTTPS 的應用數據是如何保證完整性的？

TLS 在實現上分為**握手協議**和**記錄協議**兩層：

- TLS 握手協議就是我們前面說的 TLS 四次握手的過程，負責協商加密算法和生成對稱密鑰，後續用此密鑰來保護應用程序數據（即 HTTP 數據）；
- TLS 記錄協議負責保護應用程序數據並驗證其完整性和來源，所以對 HTTP 數據加密是使用記錄協議；

TLS 記錄協議主要負責消息（HTTP 數據）的壓縮，加密及數據的認證，過程如下圖：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/記錄協議.png)

具體過程如下：

- 首先，消息被分割成多個較短的片段,然後分別對每個片段進行壓縮。

- 接下來，經過壓縮的片段會被**加上消息認證碼（MAC 值，這個是通過哈希算法生成的），這是為了保證完整性，並進行數據的認證**。通過附加消息認證碼的 MAC 值，可以識別出篡改。與此同時，為了防止重放攻擊，在計算消息認證碼時，還加上了片段的編碼。

- 再接下來，經過壓縮的片段再加上消息認證碼會一起通過對稱密碼進行加密。

- 最後，上述經過加密的數據再加上由數據類型、版本號、壓縮後的長度組成的報頭就是最終的報文數據。

記錄協議完成後，最終的報文數據將傳遞到傳輸控制協議 (TCP) 層進行傳輸。

如果你想詳細瞭解記錄協議是如何分片、壓縮、計算 MAC 值、分組加密，可以看這篇：[理解SSL/TLS系列 (四) 記錄協議](https://blog.csdn.net/zhanyiwp/article/details/105627799)

### HTTPS 一定安全可靠嗎？

之前有讀者在字節面試的時候，被問到：**HTTPS 一定安全可靠嗎？**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/提問.jpeg)

這個問題的場景是這樣的：客戶端通過瀏覽器向服務端發起 HTTPS 請求時，被「假基站」轉發到了一個「中間人服務器」，於是客戶端是和「中間人服務器」完成了 TLS 握手，然後這個「中間人服務器」再與真正的服務端完成 TLS 握手。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https中間人.drawio.png)

具體過程如下：

- 客戶端向服務端發起 HTTPS 建立連接請求時，然後被「假基站」轉發到了一個「中間人服務器」，接著中間人向服務端發起 HTTPS 建立連接請求，此時客戶端與中間人進行 TLS 握手，中間人與服務端進行 TLS 握手；
- 在客戶端與中間人進行 TLS 握手過程中，中間人會發送自己的公鑰證書給客戶端，**客戶端驗證證書的真偽**，然後從證書拿到公鑰，並生成一個隨機數，用公鑰加密隨機數發送給中間人，中間人使用私鑰解密，得到隨機數，此時雙方都有隨機數，然後通過算法生成對稱加密密鑰（A），後續客戶端與中間人通信就用這個對稱加密密鑰來加密數據了。
- 在中間人與服務端進行 TLS 握手過程中，服務端會發送從 CA 機構簽發的公鑰證書給中間人，從證書拿到公鑰，並生成一個隨機數，用公鑰加密隨機數發送給服務端，服務端使用私鑰解密，得到隨機數，此時雙方都有隨機數，然後通過算法生成對稱加密密鑰（B），後續中間人與服務端通信就用這個對稱加密密鑰來加密數據了。
- 後續的通信過程中，中間人用對稱加密密鑰（A）解密客戶端的 HTTPS 請求的數據，然後用對稱加密密鑰（B）加密 HTTPS 請求後，轉發給服務端，接著服務端發送 HTTPS 響應數據給中間人，中間人用對稱加密密鑰（B）解密 HTTPS 響應數據，然後再用對稱加密密鑰（A）加密後，轉發給客戶端。

從客戶端的角度看，其實並不知道網絡中存在中間人服務器這個角色。那麼中間人就可以解開瀏覽器發起的 HTTPS 請求裡的數據，也可以解開服務端響應給瀏覽器的 HTTPS 響應數據。相當於，中間人能夠 “偷看” 瀏覽器與服務端之間的 HTTPS 請求和響應的數據。

但是要發生這種場景是有前提的，前提是用戶點擊接受了中間人服務器的證書。

中間人服務器與客戶端在 TLS 握手過程中，實際上發送了自己偽造的證書給瀏覽器，而這個偽造的證書是能被瀏覽器（客戶端）識別出是非法的，於是就會提醒用戶該證書存在問題。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/證書安全提示.png)

如果用戶執意點擊「繼續瀏覽此網站」，相當於用戶接受了中間人偽造的證書，那麼後續整個 HTTPS 通信都能被中間人監聽了。

所以，這其實並不能說 HTTPS 不夠安全，畢竟瀏覽器都已經提示證書有問題了，如果用戶堅決要訪問，那不能怪 HTTPS ，得怪自己手賤。

另外，如果你的電腦中毒了，被惡意導入了中間人的根證書，那麼在驗證中間人的證書的時候，由於你操作系統信任了中間人的根證書，那麼等同於中間人的證書是合法的，這種情況下，瀏覽器是不會彈出證書存在問題的風險提醒的。

這其實也不關 HTTPS 的事情，是你電腦中毒了才導致 HTTPS 數據被中間人劫持的。

所以，**HTTPS 協議本身到目前為止還是沒有任何漏洞的，即使你成功進行中間人攻擊，本質上是利用了客戶端的漏洞（用戶點擊繼續訪問或者被惡意導入偽造的根證書），並不是 HTTPS 不夠安全**。

> 為什麼抓包工具能截取 HTTPS 數據？

很多抓包工具 之所以可以明文看到 HTTPS 數據，工作原理與中間人一致的。

對於 HTTPS 連接來說，中間人要滿足以下兩點，才能實現真正的明文代理:

1. 中間人，作為客戶端與真實服務端建立連接這一步不會有問題，因為服務端不會校驗客戶端的身份；
2. 中間人，作為服務端與真實客戶端建立連接，這裡會有客戶端信任服務端的問題，也就是服務端必須有對應域名的私鑰；

中間人要拿到私鑰只能通過如下方式：

1. 去網站服務端拿到私鑰；
2. 去CA處拿域名簽發私鑰；
3. 自己簽發受瀏覽器信任的證書；

不用解釋，抓包工具只能使用第三種方式取得中間人的身份。

因此使用抓包工具進行 HTTPS 抓包的時候，抓包工具會生成根證書，導入到客戶端系統的 受信任的根證書列表 中，這裡的根證書實際上起認證中心（CA）的作用。  

隨後抓包工具使用該根證書籤發域名的證書，因為根證書受信任，域名的證書同樣會被瀏覽器信任。也就是抓包工具給自己創建了一個認證中心 CA，客戶端拿著中間人（抓包工具）簽發的證書去中間人（抓包工具）自己的 CA 做認證，這個證書當然被認為是有效的。  

> 如何避免被中間人抓取數據？

我們要保證自己電腦的安全，不要被病毒乘虛而入，而且也不要點擊任何證書非法的網站，這樣 HTTPS 數據就不會被中間人截取到了。

當然，我們還可以通過 **HTTPS 雙向認證**來避免這種問題。

一般我們的 HTTPS 是單向認證，客戶端只會驗證了服務端的身份，但是服務端並不會驗證客戶端的身份。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/雙向認證.png)

如果用了雙向認證方式，不僅客戶端會驗證服務端的身份，而且服務端也會驗證客戶端的身份。服務端一旦驗證到請求自己的客戶端為不可信任的，服務端就拒絕繼續通信，客戶端如果發現服務端為不可信任的，那麼也中止通信。

## HTTP/1.1、HTTP/2、HTTP/3 演變

### HTTP/1.1 相比 HTTP/1.0 提高了什麼性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改進：

- 使用長連接的方式改善了 HTTP/1.0 短連接造成的性能開銷。
- 支持管道（pipeline）網絡傳輸，只要第一個請求發出去了，不必等其回來，就可以發第二個請求出去，可以減少整體的響應時間。


但 HTTP/1.1 還是有性能瓶頸：

- 請求 / 響應頭部（Header）未經壓縮就發送，首部信息越多延遲越大。只能壓縮 `Body` 的部分；
- 發送冗長的首部。每次互相發送相同的首部造成的浪費較多；
- 服務器是按請求的順序響應的，如果服務器響應慢，會招致客戶端一直請求不到數據，也就是隊頭阻塞；
- 沒有請求優先級控制；
- 請求只能從客戶端開始，服務器只能被動響應。

### HTTP/2 做了什麼優化？

HTTP/2 協議是基於 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

![HTT/1 ~ HTTP/2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/25-HTTP2.png)

那 HTTP/2 相比 HTTP/1.1 性能上的改進：

- 頭部壓縮
- 二進制格式
- 併發傳輸
- 服務器主動推送資源

*1. 頭部壓縮*

HTTP/2 會**壓縮頭**（Header）如果你同時發出多個請求，他們的頭是一樣的或是相似的，那麼，協議會幫你**消除重複的部分**。

這就是所謂的 `HPACK` 算法：在客戶端和服務器同時維護一張頭信息表，所有字段都會存入這個表，生成一個索引號，以後就不發送同樣字段了，只發送索引號，這樣就**提高速度**了。

*2. 二進制格式*

HTTP/2 不再像 HTTP/1.1 裡的純文本形式的報文，而是全面採用了**二進制格式**，頭信息和數據體都是二進制，並且統稱為幀（frame）：**頭信息幀（Headers Frame）和數據幀（Data Frame）**。

![HTTP/1 與 HTTP/2 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png)

這樣雖然對人不友好，但是對計算機非常友好，因為計算機只懂二進制，那麼收到報文後，無需再將明文的報文轉成二進制，而是直接解析二進制報文，這**增加了數據傳輸的效率**。

比如狀態碼 200 ，在 HTTP/1.1 是用 '2''0''0' 三個字符來表示（二進制：00110010 00110000 00110000），共用了 3 個字節，如下圖

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/http1.png)

在 HTTP/2 對於狀態碼 200 的二進制編碼是 10001000，只用了 1 字節就能表示，相比於 HTTP/1.1 節省了 2 個字節，如下圖：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/h2c.png)

Header: :status: 200 OK 的編碼內容為：1000 1000，那麼表達的含義是什麼呢？

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/index.png)

1. 最前面的 1 標識該 Header 是靜態表中已經存在的 KV。（至於什麼是靜態表，可以看這篇：[HTTP/2 牛逼在哪？](https://xiaolincoding.com/network/2_http/http2.html)）
2. 在靜態表理，“:status: 200 ok” 靜態表編碼是 8，二進制即是 1000。

因此，整體加起來就是 1000 1000。

*3. 併發傳輸*

我們都知道 HTTP/1.1 的實現是基於請求-響應模型的。同一個連接中，HTTP 完成一個事務（請求與響應），才能處理下一個事務，也就是說在發出請求等待響應的過程中，是沒辦法做其他事情的，如果響應遲遲不來，那麼後續的請求是無法發送的，也造成了**隊頭阻塞**的問題。

而 HTTP/2 就很牛逼了，引出了 Stream 概念，多個 Stream 複用在一條 TCP 連接。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/網絡/http2/stream.png)

從上圖可以看到，1 個 TCP 連接包含多個 Stream，Stream 裡可以包含 1 個或多個 Message，Message 對應 HTTP/1 中的請求或響應，由 HTTP 頭部和包體構成。Message 裡包含一條或者多個 Frame，Frame 是 HTTP/2 最小單位，以二進制壓縮格式存放 HTTP/1 中的內容（頭部和包體）。

**針對不同的 HTTP 請求用獨一無二的 Stream ID 來區分，接收端可以通過 Stream ID 有序組裝成 HTTP 消息，不同 Stream 的幀是可以亂序發送的，因此可以併發不同的 Stream ，也就是 HTTP/2 可以並行交錯地發送請求和響應**。

比如下圖，服務端**並行交錯地**發送了兩個響應： Stream 1 和 Stream 3，這兩個 Stream 都是跑在一個 TCP 連接上，客戶端收到後，會根據相同的 Stream ID 有序組裝成 HTTP 消息。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2多路複用.jpeg)

*4、服務器推送*

HTTP/2 還在一定程度上改善了傳統的「請求 - 應答」工作模式，服務端不再是被動地響應，可以**主動**向客戶端發送消息。

客戶端和服務器**雙方都可以建立 Stream**， Stream ID 也是有區別的，客戶端建立的 Stream 必須是奇數號，而服務器建立的 Stream 必須是偶數號。

比如下圖，Stream 1 是客戶端向服務端請求的資源，屬於客戶端建立的 Stream，所以該 Stream 的 ID 是奇數（數字 1）；Stream 2 和 4 都是服務端主動向客戶端推送的資源，屬於服務端建立的 Stream，所以這兩個 Stream 的 ID 是偶數（數字 2 和 4）。

![](https://img-blog.csdnimg.cn/83445581dafe409d8cfd2c573b2781ac.png)

再比如，客戶端通過 HTTP/1.1 請求從服務器那獲取到了 HTML 文件，而 HTML 可能還需要依賴 CSS 來渲染頁面，這時客戶端還要再發起獲取 CSS 文件的請求，需要兩次消息往返，如下圖左邊部分：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push.png)

如上圖右邊部分，在 HTTP/2 中，客戶端在訪問 HTML 時，服務器可以直接主動推送 CSS 文件，減少了消息傳遞的次數。

> HTTP/2 有什麼缺陷？

HTTP/2 通過 Stream 的併發能力，解決了 HTTP/1 隊頭阻塞的問題，看似很完美了，但是 HTTP/2 還是存在“隊頭阻塞”的問題，只不過問題不是在 HTTP 這一層面，而是在 TCP 這一層。

**HTTP/2 是基於 TCP 協議來傳輸數據的，TCP 是字節流協議，TCP 層必須保證收到的字節數據是完整且連續的，這樣內核才會將緩衝區裡的數據返回給 HTTP 應用，那麼當「前 1 個字節數據」沒有到達時，後收到的字節數據只能存放在內核緩衝區裡，只有等到這 1 個字節數據到達時，HTTP/2 應用層才能從內核中拿到數據，這就是 HTTP/2 隊頭阻塞問題。**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2阻塞.jpeg)

舉個例子，如下圖：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif)

圖中發送方發送了很多個 packet，每個 packet 都有自己的序號，你可以認為是 TCP 的序列號，其中 packet 3 在網絡中丟失了，即使 packet 4-6 被接收方收到後，由於內核中的 TCP 數據不是連續的，於是接收方的應用層就無法從內核中讀取到，只有等到 packet 3 重傳後，接收方的應用層才可以從內核中讀取到數據，這就是 HTTP/2 的隊頭阻塞問題，是在 TCP 層面發生的。

所以，一旦發生了丟包現象，就會觸發 TCP 的重傳機制，這樣在一個 TCP 連接中的**所有的 HTTP 請求都必須等待這個丟了的包被重傳回來**。

::: tip

如果想更進一步瞭解 HTTP/2 協議，可以看我這篇文章：[HTTP/2 牛逼在哪？](https://xiaolincoding.com/network/2_http/http2.html)

:::

### HTTP/3 做了哪些優化？

前面我們知道了 HTTP/1.1 和 HTTP/2 都有隊頭阻塞的問題：

- HTTP/1.1 中的管道（ pipeline）雖然解決了請求的隊頭阻塞，但是**沒有解決響應的隊頭阻塞**，因為服務端需要按順序響應收到的請求，如果服務端處理某個請求消耗的時間比較長，那麼只能等響應完這個請求後， 才能處理下一個請求，這屬於 HTTP 層隊頭阻塞。
- HTTP/2 雖然通過多個請求複用一個 TCP 連接解決了 HTTP 的隊頭阻塞 ，但是**一旦發生丟包，就會阻塞住所有的 HTTP 請求**，這屬於 TCP 層隊頭阻塞。

HTTP/2 隊頭阻塞的問題是因為 TCP，所以 **HTTP/3 把 HTTP 下層的 TCP 協議改成了 UDP！**

![HTTP/1 ~ HTTP/3](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/27-HTTP3.png)

UDP 發送是不管順序，也不管丟包的，所以不會出現像 HTTP/2 隊頭阻塞的問題。大家都知道 UDP 是不可靠傳輸的，但基於 UDP 的 **QUIC 協議** 可以實現類似 TCP 的可靠性傳輸。

QUIC 有以下 3 個特點。

- 無隊頭阻塞
- 更快的連接建立
- 連接遷移

*1、無隊頭阻塞*

QUIC 協議也有類似 HTTP/2 Stream 與多路複用的概念，也是可以在同一條連接上併發傳輸多個 Stream，Stream 可以認為就是一條 HTTP 請求。

QUIC 有自己的一套機制可以保證傳輸的可靠性的。**當某個流發生丟包時，只會阻塞這個流，其他流不會受到影響，因此不存在隊頭阻塞問題**。這與 HTTP/2 不同，HTTP/2 只要某個流中的數據包丟失了，其他流也會因此受影響。

所以，QUIC 連接上的多個 Stream 之間並沒有依賴，都是獨立的，某個流發生丟包了，只會影響該流，其他流不受影響。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic無阻塞.jpeg)

*2、更快的連接建立*

對於 HTTP/1 和 HTTP/2 協議，TCP 和 TLS 是分層的，分別屬於內核實現的傳輸層、openssl 庫實現的表示層，因此它們難以合併在一起，需要分批次來握手，先 TCP 握手，再 TLS 握手。

HTTP/3 在傳輸數據前雖然需要 QUIC 協議握手，但這個握手過程只需要 1 RTT，握手的目的是為確認雙方的「連接 ID」，連接遷移就是基於連接 ID 實現的。

但是 HTTP/3 的 QUIC 協議並不是與 TLS 分層，而是 QUIC 內部包含了 TLS，它在自己的幀會攜帶 TLS 裡的“記錄”，再加上 QUIC 使用的是 TLS/1.3，因此僅需 1 個 RTT 就可以「同時」完成建立連接與密鑰協商，如下圖：

![TCP HTTPS（TLS/1.3） 和 QUIC HTTPS ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/28-HTTP3交互次數.png)

甚至，在第二次連接的時候，應用數據包可以和 QUIC 握手信息（連接信息 + TLS 信息）一起發送，達到 0-RTT 的效果。

如下圖右邊部分，HTTP/3 當會話恢復時，有效負載數據與第一個數據包一起發送，可以做到 0-RTT（下圖的右下角）：

![](https://img-blog.csdnimg.cn/4cad213f5125432693e0e2a512c2d1a1.png)

*3、連接遷移*

基於 TCP 傳輸協議的 HTTP 協議，由於是通過四元組（源 IP、源端口、目的 IP、目的端口）確定一條 TCP 連接。

![TCP 四元組](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png)

那麼**當移動設備的網絡從 4G 切換到 WIFI 時，意味著 IP 地址變化了，那麼就必須要斷開連接，然後重新建立連接**。而建立連接的過程包含 TCP 三次握手和 TLS 四次握手的時延，以及 TCP 慢啟動的減速過程，給用戶的感覺就是網絡突然卡頓了一下，因此連接的遷移成本是很高的。

而 QUIC 協議沒有用四元組的方式來“綁定”連接，而是通過**連接 ID** 來標記通信的兩個端點，客戶端和服務器可以各自選擇一組 ID 來標記自己，因此即使移動設備的網絡變化後，導致 IP 地址變化了，只要仍保有上下文信息（比如連接 ID、TLS 密鑰等），就可以“無縫”地複用原連接，消除重連的成本，沒有絲毫卡頓感，達到了**連接遷移**的功能。

所以， QUIC 是一個在 UDP 之上的**偽** TCP + TLS + HTTP/2 的多路複用的協議。

QUIC 是新協議，對於很多網絡設備，根本不知道什麼是 QUIC，只會當做 UDP，這樣會出現新的問題，因為有的網絡設備是會丟掉 UDP 包的，而 QUIC 是基於 UDP 實現的，那麼如果網絡設備無法識別這個是 QUIC 包，那麼就會當作 UDP 包，然後被丟棄。

HTTP/3 現在普及的進度非常的緩慢，不知道未來 UDP 是否能夠逆襲 TCP。

::: tip

如果想更進一步瞭解 HTTP/3 和 QUIC 協議，可以看我這兩篇文章：

- [HTTP/3 強勢來襲](https://xiaolincoding.com/network/2_http/http3.html)
- [如何基於 UDP 協議實現可靠傳輸？](https://xiaolincoding.com/network/3_tcp/quic.html)

:::

----

參考資料：

[1] 上野 宣.圖解HTTP.人民郵電出版社.

[2] 羅劍鋒.透視HTTP協議.極客時間.

[3] 陳皓.HTTP的前世今.酷殼CoolShell.https://coolshell.cn/articles/19840.html

[4] 阮一峰.HTTP 協議入門.阮一峰的網絡日誌.http://www.ruanyifeng.com/blog/2016/08/http.html

----


## 讀者問答


> 讀者問：“https 和 http 相比，就是傳輸的內容多了對稱加密，可以這麼理解嗎？”

1. 建立連接時候：https 比 http 多了 TLS 的握手過程；

2. 傳輸內容的時候：https 會把數據進行加密，通常是對稱加密數據；

> 讀者問：“ 我看文中 TLS 和 SSL 沒有做區分，這兩個需要區分嗎？”

這倆實際上是一個東西。

SSL 是洋文 “*Secure Sockets Layer*” 的縮寫，中文叫做「安全套接層」。它是在上世紀 90 年代中期，由網景公司設計的。

到了1999年，SSL 因為應用廣泛，已經成為互聯網上的事實標準。IETF 就在那年把 SSL 標準化。標準化之後的名稱改為 TLS（是 “*Transport Layer Security*” 的縮寫），中文叫做 「傳輸層安全協議」。

很多相關的文章都把這兩者並列稱呼（SSL/TLS），因為這兩者可以視作同一個東西的不同階段。

> 讀者問：“為啥 SSL 的握手是 4 次？”

SSL/TLS 1.2 需要 4 握手，需要 2 個 RTT 的時延，我文中的圖是把每個交互分開畫了，實際上把他們合在一起發送，就是 4 次握手：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/29-TLS1.2-四次握手.png)


另外， SSL/TLS 1.3 優化了過程，只需要 1 個 RTT 往返時延，也就是隻需要 3 次握手：


![T](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/計算機網絡/HTTP/30-TLS1.3.png)

----


本文的 `30` 張圖片，都是從一條線兩條線畫出來，灰常的費勁，深切感受到畫圖也是個**體力活**啊！ 

愛偷懶的我其實不愛畫圖，但為了讓大家能更好的理解，在跟自己無數次鬥爭後，踏上了耗時耗體力的畫圖的不歸路，希望對你們有幫助！


**小林是專為大家圖解的工具人，Goodbye，我們下次見！**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)

