# 3.9 既然有 HTTP 協議，為什麼還要有 WebSocket？

> 來源：公眾號@小白debug
>
> 原文地址：[既然有 HTTP 協議，為什麼還要有 WebSocket？](https://mp.weixin.qq.com/s/jJNdXMNmXcE8wSE0gbtTAQ)

平時我們打開網頁，比如購物網站某寶。都是點一下「列表商品」，跳轉一下網頁就到了「商品詳情」。

從 HTTP 協議的角度來看，就是點一下網頁上的某個按鈕，**前端發一次 HTTP請 求，網站返回一次 HTTP 響應**。這種由客戶端主動請求，服務器響應的方式也滿足大部分網頁的功能場景。

但有沒有發現，這種情況下，服務器從來就「不會主動」給客戶端發一次消息。就像你喜歡的女生從來不會主動找你一樣。

但如果現在，你在刷網頁的時候「右下角」突然彈出一個小廣告，提示你【一個人在家偷偷才能玩哦】。

**求知，好學，勤奮**，這些刻在你 DNA 裡的東西都動起來了。

你點開後發現。

長相平平無奇的古某提示你"道士 9 條狗，全服橫著走"。

影帝某輝老師跟你說"系兄弟就來砍我"。

![圖片](https://img-blog.csdnimg.cn/img_convert/b8cca4b1291f25235bc8df3dddbb6da3.png)

來都來了，你就選了個角色進到了遊戲界面裡。

![圖片](https://img-blog.csdnimg.cn/img_convert/95e5b4cee384b182d0e604378c3ca00a.jpeg)

這時候，上來就是一個小怪，從遠處走來，然後瘋狂拿木棒子抽你。

**你全程沒點任何一次鼠標**。服務器就自動將怪物的移動數據和攻擊數據源源不斷髮給你了。

這….太暖心了。

感動之餘，問題就來了，

像這種**看起來服務器主動發消息給客戶端的場景**，是怎麼做到的？

在真正回答這個問題之前，我們先來聊下一些相關的知識背景。

## 使用 HTTP 不斷輪詢

其實問題的痛點在於，**怎麼樣才能在用戶不做任何操作的情況下，網頁能收到消息併發生變更。**

最常見的解決方案是，**網頁的前端代碼裡不斷定時發 HTTP 請求到服務器，服務器收到請求後給客戶端響應消息。**

這其實時一種「**偽**」服務器推的形式。

它其實並不是服務器主動發消息到客戶端，而是客戶端自己不斷偷偷請求服務器，只是用戶無感知而已。

用這種方式的場景也有很多，最常見的就是**掃碼登錄**。

比如，某信公眾號平臺，登錄頁面二維碼出現之後，**前端**網頁根本不知道用戶掃沒掃，於是不斷去向**後端**服務器詢問，看有沒有人掃過這個碼。而且是以大概 1 到 2 秒的間隔去不斷髮出請求，這樣可以保證用戶在掃碼後能在 1 到 2 秒內得到及時的反饋，不至於**等太久**。

使用HTTP定時輪詢

但這樣，會有兩個比較明顯的問題：

- 當你打開 F12 頁面時，你會發現滿屏的 HTTP 請求。雖然很小，但這其實也消耗帶寬，同時也會增加下游服務器的負擔。
- 最壞情況下，用戶在掃碼後，需要等個 1~2 秒，正好才觸發下一次 HTTP 請求，然後才跳轉頁面，用戶會感到**明顯的卡頓**。

使用起來的體驗就是，二維碼出現後，手機掃一掃，然後在手機上點個確認，這時候**卡頓等個 1~2 秒**，頁面才跳轉。

![圖片](https://img-blog.csdnimg.cn/img_convert/5e0e0e25e8aca80812c9a2892032111c.png)

那麼問題又來了，**有沒有更好的解決方案？**

有，而且實現起來成本還非常低。

## 長輪詢

我們知道，HTTP 請求發出後，一般會給服務器留一定的時間做響應，比如 3 秒，規定時間內沒返回，就認為是超時。

如果我們的 HTTP 請求**將超時設置的很大**，比如 30 秒，**在這 30 秒內只要服務器收到了掃碼請求，就立馬返回給客戶端網頁。如果超時，那就立馬發起下一次請求。**

這樣就減少了 HTTP 請求的個數，並且由於大部分情況下，用戶都會在某個 30 秒的區間內做掃碼操作，所以響應也是及時的。

![圖片](https://img-blog.csdnimg.cn/img_convert/1058a96ba35215c0f30accc3ff5bb824.png)

比如，某度雲網盤就是這麼幹的。所以你會發現一掃碼，手機上點個確認，電腦端網頁就**秒跳轉**，體驗很好。

![圖片](https://img-blog.csdnimg.cn/img_convert/a3a8c95b97d2bac26cfab123a4da68b2.png)

像這種發起一個請求，在較長時間內等待服務器響應的機制，就是所謂的**長輪詢機制**。我們常用的消息隊列 RocketMQ 中，消費者去取數據時，也用到了這種方式。

![圖片](https://img-blog.csdnimg.cn/img_convert/6173c1d25abc914ef17ee9e534ed6a5f.png)

像這種，在用戶不感知的情況下，服務器將數據推送給瀏覽器的技術，就是所謂的**服務器推送**技術，它還有個毫不沾邊的英文名，**comet** 技術，大家聽過就好。

上面提到的兩種解決方案（不斷輪詢和長輪詢），本質上，其實還是客戶端主動去取數據。

對於像掃碼登錄這樣的**簡單場景**還能用用。但如果是網頁遊戲呢，遊戲一般會有大量的數據需要從服務器主動推送到客戶端。

這就得說下 **WebSocket** 了。

## WebSocket是什麼

我們知道 TCP 連接的兩端，**同一時間裡**，**雙方**都可以**主動**向對方發送數據。這就是所謂的**全雙工**。

而現在使用最廣泛的`HTTP/1.1`，也是基於TCP協議的，**同一時間裡**，客戶端和服務器**只能有一方主動**發數據，這就是所謂的**半雙工**。

也就是說，好好的全雙工 TCP，被 HTTP/1.1 用成了半雙工。

為什麼？

這是由於 HTTP 協議設計之初，考慮的是看看網頁文本的場景，能做到**客戶端發起請求再由服務器響應**，就夠了，根本就沒考慮網頁遊戲這種，客戶端和服務器之間都要互相主動發大量數據的場景。

所以，為了更好的支持這樣的場景，我們需要另外一個**基於TCP的新協議**。

於是新的應用層協議**WebSocket**就被設計出來了。

大家別被這個名字給帶偏了。雖然名字帶了個socket，但其實 **socket 和 WebSocket 之間，就跟雷峰和雷峰塔一樣，二者接近毫無關係**。

![圖片](https://img-blog.csdnimg.cn/img_convert/3bbe4c5db972513f912d30ba8cbddd65.png)

### 怎麼建立WebSocket連接

我們平時刷網頁，一般都是在瀏覽器上刷的，一會刷刷圖文，這時候用的是 **HTTP 協議**，一會打開網頁遊戲，這時候就得切換成我們新介紹的 **WebSocket 協議**。

為了兼容這些使用場景。瀏覽器在 **TCP 三次握手**建立連接之後，都**統一使用 HTTP 協議**先進行一次通信。

- 如果此時是**普通的 HTTP 請求**，那後續雙方就還是老樣子繼續用普通 HTTP 協議進行交互，這點沒啥疑問。
- 如果這時候是**想建立 WebSocket 連接**，就會在 HTTP 請求裡帶上一些**特殊的header 頭**，如下：

```http
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
```

這些 header 頭的意思是，瀏覽器想**升級協議（Connection: Upgrade）**，並且**想升級成 WebSocket 協議（Upgrade: WebSocket）**。同時帶上一段**隨機生成的 base64 碼（Sec-WebSocket-Key）**，發給服務器。

如果服務器正好支持升級成 WebSocket 協議。就會走 WebSocket 握手流程，同時根據客戶端生成的 base64 碼，用某個**公開的**算法變成另一段字符串，放在 HTTP 響應的 `Sec-WebSocket-Accept` 頭裡，同時帶上`101狀態碼`，發回給瀏覽器。HTTP 的響應如下：

```http
HTTP/1.1 101 Switching Protocols\r\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
Upgrade: WebSocket\r\n
Connection: Upgrade\r\n
```

HTTP 狀態碼=200（正常響應）的情況，大家見得多了。101 確實不常見，它其實是指**協議切換**。

![圖片](https://img-blog.csdnimg.cn/img_convert/dea71991b336c876cae2e1ebdf03b62d.png)

之後，瀏覽器也用同樣的**公開算法**將`base64碼`轉成另一段字符串，如果這段字符串跟服務器傳回來的**字符串一致**，那驗證通過。

![圖片](https://img-blog.csdnimg.cn/img_convert/117eebe06cc6b35ded3216a95706f080.png)

就這樣經歷了一來一回兩次 HTTP 握手，WebSocket就建立完成了，後續雙方就可以使用 webscoket 的數據格式進行通信了。

![圖片](https://img-blog.csdnimg.cn/img_convert/f4edd3018914fe6eb38fad6aa3fd2d65.png)

### WebSocket抓包

我們可以用wireshark抓個包，實際看下數據包的情況。

![圖片](https://img-blog.csdnimg.cn/img_convert/f756ca625523f0f9d40a402465179bbe.png)

上面這張圖，注意畫了紅框的第`2445`行報文，是WebSocket的**第一次握手**，意思是發起了一次帶有`特殊Header`的HTTP請求。

![圖片](https://img-blog.csdnimg.cn/img_convert/82d65f08dad05e6b537ea06b94224a5f.png)

上面這個圖裡畫了紅框的`4714`行報文，就是服務器在得到第一次握手後，響應的**第二次握手**，可以看到這也是個 HTTP 類型的報文，返回的狀態碼是 101。同時可以看到返回的報文 header 中也帶有各種`WebSocket`相關的信息，比如`Sec-WebSocket-Accept`。

![圖片](https://img-blog.csdnimg.cn/img_convert/382c7699530ea7e7b22f60bb68af21bd.png)

上面這張圖就是全貌了，從截圖上的註釋可以看出，WebSocket和HTTP一樣都是基於TCP的協議。**經歷了三次TCP握手之後，利用 HTTP 協議升級為 WebSocket 協議**。

你在網上可能會看到一種說法："WebSocket 是基於HTTP的新協議"，**其實這並不對**，因為WebSocket只有在建立連接時才用到了HTTP，**升級完成之後就跟HTTP沒有任何關係了**。

這就好像你喜歡的女生通過你要到了你大學室友的微信，然後他們自己就聊起來了。你能說這個女生是通過你去跟你室友溝通的嗎？不能。你跟HTTP一樣，都只是個**工具人**。

![圖片](https://img-blog.csdnimg.cn/img_convert/2e9d4b1652bdfa1e3ae4bb24f70a1b5a.png)

這就有點"**借殼生蛋**"的那意思。

HTTP和WebSocket的關係

### WebSocket的消息格式

上面提到在完成協議升級之後，兩端就會用webscoket的數據格式進行通信。

數據包在WebSocket中被叫做**幀**，我們來看下它的數據格式長什麼樣子。

![圖片](https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png)

這裡面字段很多，但我們只需要關注下面這幾個。

**opcode字段**：這個是用來標誌這是個**什麼類型**的數據幀。比如。

- 等於 1 ，是指text類型（`string`）的數據包
- 等於 2 ，是二進制數據類型（`[]byte`）的數據包
- 等於 8 ，是關閉連接的信號

**payload字段**：存放的是我們**真正想要傳輸的數據的長度**，單位是**字節**。比如你要發送的數據是`字符串"111"`，那它的長度就是`3`。

![圖片](https://img-blog.csdnimg.cn/img_convert/437a076935f82be1d36960c9a4785fbd.png)

另外，可以看到，我們存放**payload 長度的字段有好幾個**，我們既可以用最前面的`7bit`, 也可以用後面的`7+16bit 或 7+64bit。`

那麼問題就來了。

我們知道，在數據層面，大家都是 01 二進制流。我怎麼知道**什麼情況下應該讀 7 bit，什麼情況下應該讀7+16bit呢？**

WebSocket會用最開始的7bit做標誌位。不管接下來的數據有多大，都**先讀最先的7個bit**，根據它的取值決定還要不要再讀個 16bit 或 64bit。

- 如果`最開始的7bit`的值是 0~125，那麼它就表示了 **payload 全部長度**，只讀最開始的`7個bit`就完事了。

![圖片](https://img-blog.csdnimg.cn/img_convert/690f5a4deda2de50f3a35eddf0be4d75.png)

- 如果是`126（0x7E）`。那它表示payload的長度範圍在 `126~65535` 之間，接下來還需要**再讀16bit**。這16bit會包含payload的真實長度。

![圖片](https://img-blog.csdnimg.cn/img_convert/c815c9dabc02fceb42a98c762705af33.png)

- 如果是`127（0x7F）`。那它表示payload的長度範圍`>=65536`，接下來還需要**再讀64bit**。這64bit會包含payload的長度。這能放2的64次方byte的數據，換算一下好多個TB，肯定夠用了。

![圖片](https://img-blog.csdnimg.cn/img_convert/192b22b4fe46e8dfb7b17549306d5998.png)

**payload data字段**：這裡存放的就是真正要傳輸的數據，在知道了上面的payload長度後，就可以根據這個值去截取對應的數據。

大家有沒有發現一個小細節，WebSocket的數據格式也是**數據頭（內含payload長度） + payload data** 的形式。

![圖片](https://img-blog.csdnimg.cn/img_convert/d449242f1bf41c6f95a5314ec8311d0d.jpeg)

這是因為 TCP 協議本身就是全雙工，但直接使用**純裸TCP**去傳輸數據，會有**粘包**的"問題"。為瞭解決這個問題，上層協議一般會用**消息頭+消息體**的格式去重新包裝要發的數據。

而**消息頭**裡一般含有**消息體的長度**，通過這個長度可以去截取真正的消息體。

HTTP 協議和大部分 RPC 協議，以及我們今天介紹的WebSocket協議，都是這樣設計的。

![圖片](https://img-blog.csdnimg.cn/img_convert/b91fedb1856897c231b8fb5932b7b2d2.png)

### WebSocket的使用場景

WebSocket完美繼承了 TCP 協議的**全雙工**能力，並且還貼心的提供瞭解決粘包的方案。

它適用於**需要服務器和客戶端（瀏覽器）頻繁交互**的大部分場景，比如網頁/小程序遊戲，網頁聊天室，以及一些類似飛書這樣的網頁協同辦公軟件。

回到文章開頭的問題，在使用 WebSocket 協議的網頁遊戲裡，怪物移動以及攻擊玩家的行為是**服務器邏輯**產生的，對玩家產生的傷害等數據，都需要由**服務器主動發送給客戶端**，客戶端獲得數據後展示對應的效果。

![圖片](https://img-blog.csdnimg.cn/img_convert/31410d2e885aab55c2c588aad754bb5c.png)

## 總結

- TCP 協議本身是**全雙工**的，但我們最常用的 HTTP/1.1，雖然是基於 TCP 的協議，但它是**半雙工**的，對於大部分需要服務器主動推送數據到客戶端的場景，都不太友好，因此我們需要使用支持全雙工的 WebSocket 協議。
- 在 HTTP/1.1 裡，只要客戶端不問，服務端就不答。基於這樣的特點，對於登錄頁面這樣的簡單場景，可以使用**定時輪詢或者長輪詢**的方式實現**服務器推送**(comet)的效果。
- 對於客戶端和服務端之間需要頻繁交互的複雜場景，比如網頁遊戲，都可以考慮使用 WebSocket 協議。
- WebSocket 和 socket 幾乎沒有任何關係，只是叫法相似。
- 正因為各個瀏覽器都支持 HTTP協 議，所以 WebSocket 會先利用HTTP協議加上一些特殊的 header 頭進行握手升級操作，升級成功後就跟 HTTP 沒有任何關係了，之後就用 WebSocket 的數據格式進行收發數據。

------

***哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，歡迎微信搜索「小林coding」關注我***

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)