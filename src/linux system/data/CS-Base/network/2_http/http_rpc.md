# 3.8 既然有 HTTP 協議，為什麼還要有 RPC？

>來源：公眾號@小白debug
>
>原文地址：[既然有 HTTP 協議，為什麼還要有 RPC？](https://mp.weixin.qq.com/s/qmnfmUCdekEt1xG0hp_4MQ)

我想起了我剛工作的時候，第一次接觸 RPC 協議，當時就很懵，**我 HTTP 協議用的好好的，為什麼還要用 RPC 協議？**

於是就到網上去搜。

不少解釋顯得非常官方，我相信大家在各種平臺上也都看到過，解釋了又好像沒解釋，都在**用一個我們不認識的概念去解釋另外一個我們不認識的概念**，懂的人不需要看，不懂的人看了還是不懂。

這種看了，又好像沒看的感覺，雲裡霧裡的很難受，**我懂**。

為了避免大家有強烈的**審醜疲勞**，今天我們來嘗試重新換個方式講一講。

## 從 TCP 聊起

作為一個程序員，假設我們需要在 A 電腦的進程發一段數據到 B 電腦的進程，我們一般會在代碼裡使用 Socket 進行編程。

這時候，我們可選項一般也就 TCP 和 UDP 二選一。TCP 可靠，UDP 不可靠。除非是馬總這種神級程序員（早期 QQ 大量使用 UDP），否則，只要稍微對可靠性有些要求，普通人一般無腦選 TCP 就對了。

類似下面這樣。

```c
fd = socket(AF_INET,SOCK_STREAM,0);
```

其中 `SOCK_STREAM`，是指使用**字節流**傳輸數據，說白了就是 **TCP 協議**。

在定義了 Socket 之後，我們就可以愉快的對這個 Socket 進行操作，比如用 `bind()` 綁定 IP 端口，用 `connect()` 發起建連。

![握手建立連接流程](https://img-blog.csdnimg.cn/img_convert/23cc66a7f4cb06afe13842b4b339e28b.gif)

在連接建立之後，我們就可以使用 `send()` 發送數據，`recv()` 接收數據。

光這樣一個純裸的 TCP 連接，就可以做到收發數據了，那是不是就夠了？

不行，這麼用會有問題。

## 使用純裸 TCP 會有什麼問題

八股文常背，TCP 是有三個特點，**面向連接**、**可靠**、基於**字節流**。

![TCP 是什麼](https://img-blog.csdnimg.cn/img_convert/3fcad07ba7ae92299b32224da8583363.png)

這三個特點真的概括的**非常精闢**，這個八股文我們沒白背。

每個特點展開都能聊一篇文章，而今天我們需要關注的是**基於字節流**這一點。

字節流可以理解為一個雙向的通道里流淌的數據，這個**數據**其實就是我們常說的二進制數據，簡單來說就是一大堆 **01 串**。純裸 TCP 收發的這些 01 串之間是**沒有任何邊界**的，你根本不知道到哪個地方才算一條完整消息。

![01 二進制字節流](https://img-blog.csdnimg.cn/img_convert/254d845f9de05c19536d8343d268595a.png)

正因為這個沒有**任何邊界**的特點，所以當我們選擇使用 TCP 發送"夏洛"和"特煩惱"的時候，接收端收到的就是"夏洛特煩惱"，這時候接收端沒發區分你是想要表達"夏洛"+"特煩惱"還是"夏洛特"+"煩惱"。

![消息對比](https://img-blog.csdnimg.cn/img_convert/cd7c006cb4180bf751c4afd268ed44f0.png)

這就是所謂的**粘包問題**，之前也寫過一篇專門的[文章](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)聊過這個問題。

說這個的目的是為了告訴大家，純裸 TCP 是不能直接拿來用的，你需要在這個基礎上加入一些**自定義的規則**，用於區分**消息邊界**。

於是我們會把每條要發送的數據都包裝一下，比如加入**消息頭**，**消息頭裡寫清楚一個完整的包長度是多少**，根據這個長度可以繼續接收數據，截取出來後它們就是我們真正要傳輸的**消息體**。

![消息邊界長度標誌](https://img-blog.csdnimg.cn/img_convert/9428feed1ff22156fc136d17a129527b.png)

而這裡頭提到的**消息頭**，還可以放各種東西，比如消息體是否被壓縮過和消息體格式之類的，只要上下游都約定好了，互相都認就可以了，這就是所謂的**協議。**

每個使用 TCP 的項目都可能會定義一套類似這樣的協議解析標準，他們可能**有區別，但原理都類似**。

**於是基於 TCP，就衍生了非常多的協議，比如 HTTP 和 RPC。**

## HTTP 和 RPC

我們回過頭來看網絡的分層圖。

![四層網絡協議](https://img-blog.csdnimg.cn/img_convert/da970d16a205fb48d6a8bea14498814d.png)

**TCP 是傳輸層的協議**，而基於 TCP 造出來的 HTTP 和**各類** RPC 協議，它們都只是定義了不同消息格式的**應用層協議**而已。

**HTTP** 協議（**H**yper **T**ext **T**ransfer **P**rotocol），又叫做**超文本傳輸協議**。我們用的比較多，平時上網在瀏覽器上敲個網址就能訪問網頁，這裡用到的就是 HTTP 協議。

![HTTP調用](https://img-blog.csdnimg.cn/img_convert/809c33f7090c08b78d494445e39ae1b4.png)

而 **RPC**（**R**emote **P**rocedure **C**all），又叫做**遠程過程調用**。它本身並不是一個具體的協議，而是一種**調用方式**。

舉個例子，我們平時調用一個**本地方法**就像下面這樣。

```
 res = localFunc(req)
```

如果現在這不是個本地方法，而是個**遠端服務器**暴露出來的一個方法 `remoteFunc`，如果我們還能像調用本地方法那樣去調用它，這樣就可以**屏蔽掉一些網絡細節**，用起來更方便，豈不美哉？

```
 res = remoteFunc(req)
```

![RPC可以像調用本地方法那樣調用遠端方法](https://img-blog.csdnimg.cn/img_convert/2b2ea6d26af9ded517043e528b032307.png)

基於這個思路，大佬們造出了非常多款式的 RPC 協議，比如比較有名的`gRPC`，`thrift`。

值得注意的是，雖然大部分 RPC 協議底層使用 TCP，但實際上**它們不一定非得使用 TCP，改用 UDP 或者 HTTP，其實也可以做到類似的功能。**

![基於TCP協議的HTTP和RPC協議](https://img-blog.csdnimg.cn/img_convert/054e9738bc492a6fb6e9a71737d95fc0.png)

到這裡，我們回到文章標題的問題。

> 既然有 HTTP 協議，為什麼還要有 RPC？

其實，`TCP` 是**70年**代出來的協議，而 `HTTP` 是 **90 年代**才開始流行的。而直接使用裸 TCP 會有問題，可想而知，這中間這麼多年有多少自定義的協議，而這裡面就有**80年代**出來的 `RPC`。

所以我們該問的不是**既然有 HTTP 協議為什麼要有 RPC**，而是**為什麼有 RPC 還要有 HTTP 協議**。

> 那既然有 RPC 了，為什麼還要有 HTTP 呢？

現在電腦上裝的各種**聯網**軟件，比如 xx管家，xx衛士，它們都作為**客戶端（Client）需要跟服務端（Server）建立連接收發消息**，此時都會用到應用層協議，在這種 Client/Server (C/S) 架構下，它們可以使用自家造的 RPC 協議，因為它只管連自己公司的服務器就 ok 了。

但有個軟件不同，**瀏覽器（Browser）**，不管是 Chrome 還是 IE，它們不僅要能訪問自家公司的**服務器（Server）**，還需要訪問其他公司的網站服務器，因此它們需要有個統一的標準，不然大家沒法交流。於是，HTTP 就是那個時代用於統一 **Browser/Server (B/S)** 的協議。

也就是說在多年以前，**HTTP 主要用於 B/S 架構，而 RPC 更多用於 C/S 架構。但現在其實已經沒分那麼清了，B/S 和 C/S 在慢慢融合。**很多軟件同時支持多端，比如某度雲盤，既要支持**網頁版**，還要支持**手機端和 PC 端**，如果通信協議都用 HTTP 的話，那服務器只用同一套就夠了。而 RPC 就開始退居幕後，一般用於公司內部集群裡，各個微服務之間的通訊。

那這麼說的話，**都用 HTTP 得了，還用什麼 RPC？**

彷彿又回到了文章開頭的樣子，那這就要從它們之間的區別開始說起。

## HTTP 和 RPC 有什麼區別

我們來看看 RPC 和 HTTP 區別比較明顯的幾個點。

### 服務發現

首先要向某個服務器發起請求，你得先建立連接，而建立連接的前提是，你得知道 **IP 地址和端口**。這個找到服務對應的 IP 端口的過程，其實就是**服務發現**。

在 **HTTP** 中，你知道服務的域名，就可以通過 **DNS 服務**去解析得到它背後的 IP 地址，默認 80 端口。

而 **RPC** 的話，就有些區別，一般會有專門的**中間服務**去保存服務名和IP信息，比如 **Consul 或者 Etcd，甚至是 Redis**。想要訪問某個服務，就去這些中間服務去獲得 IP 和端口信息。由於 DNS 也是服務發現的一種，所以也有基於 DNS 去做服務發現的組件，比如**CoreDNS**。

可以看出服務發現這一塊，兩者是有些區別，但不太能分高低。

### 底層連接形式

以主流的 **HTTP/1.1** 協議為例，其默認在建立底層 TCP 連接之後會一直保持這個連接（**Keep Alive**），之後的請求和響應都會複用這條連接。

而 **RPC** 協議，也跟 HTTP 類似，也是通過建立 TCP 長鏈接進行數據交互，但不同的地方在於，RPC 協議一般還會再建個**連接池**，在請求量大的時候，建立多條連接放在池內，要發數據的時候就從池裡取一條連接出來，**用完放回去，下次再複用**，可以說非常環保。

![connection_pool](https://img-blog.csdnimg.cn/img_convert/ec5c8e28d3ea308c6db2ac991a12ea80.png)

**由於連接池有利於提升網絡請求性能，所以不少編程語言的網絡庫裡都會給 HTTP 加個連接池**，比如 **Go** 就是這麼幹的。

可以看出這一塊兩者也沒太大區別，所以也不是關鍵。

### 傳輸的內容

基於 TCP 傳輸的消息，說到底，無非都是**消息頭 Header 和消息體 Body。**

**Header** 是用於標記一些特殊信息，其中最重要的是**消息體長度**。

**Body** 則是放我們真正需要傳輸的內容，而這些內容只能是二進制 01 串，畢竟計算機只認識這玩意。所以 TCP 傳字符串和數字都問題不大，因為字符串可以轉成編碼再變成 01 串，而數字本身也能直接轉為二進制。但結構體呢，我們得想個辦法將它也轉為二進制 01 串，這樣的方案現在也有很多現成的，比如 **Json，Protobuf。**

這個將結構體轉為二進制數組的過程就叫**序列化**，反過來將二進制數組復原成結構體的過程叫**反序列化**。

![序列化和反序列化](https://img-blog.csdnimg.cn/img_convert/dba2bc3af0938d2c087f85acc191fd3f.png)

對於主流的 HTTP/1.1，雖然它現在叫**超文本**協議，支持音頻視頻，但 HTTP 設計初是用於做網頁**文本**展示的，所以它傳的內容以字符串為主。Header 和 Body 都是如此。在 Body 這塊，它使用 **Json** 來**序列化**結構體數據。

我們可以隨便截個圖直觀看下。

![HTTP 報文](https://img-blog.csdnimg.cn/img_convert/324cbe84c303a3b975e50329f5cdbf8b.png)

可以看到這裡面的內容非常多的**冗餘**，顯得**非常囉嗦**。最明顯的，像 `Header` 裡的那些信息，其實如果我們約定好頭部的第幾位是 Content-Type，就**不需要每次都真的把"Content-Type"這個字段都傳過來**，類似的情況其實在 `body` 的 Json 結構裡也特別明顯。

而 RPC，因為它定製化程度更高，可以採用體積更小的 Protobuf 或其他序列化協議去保存結構體數據，同時也不需要像 HTTP 那樣考慮各種瀏覽器行為，比如 302 重定向跳轉啥的。**因此性能也會更好一些，這也是在公司內部微服務中拋棄 HTTP，選擇使用 RPC 的最主要原因。**

![HTTP 原理](https://img-blog.csdnimg.cn/img_convert/f4cef7331cabcfe56d9d6434f7ef907f.png)

![RPC 原理](https://img-blog.csdnimg.cn/img_convert/12244fb0b19b2e61755fcab799198f68.png)

當然上面說的 HTTP，其實**特指的是現在主流使用的 HTTP/1.1**，`HTTP/2` 在前者的基礎上做了很多改進，所以**性能可能比很多 RPC 協議還要好**，甚至連 `gRPC` 底層都直接用的 `HTTP/2`。

> 那麼問題又來了，為什麼既然有了 HTTP/2，還要有 RPC 協議？

這個是由於 HTTP/2 是 2015 年出來的。那時候很多公司內部的 RPC 協議都已經跑了好些年了，基於歷史原因，一般也沒必要去換了。

## 總結

- 純裸 TCP 是能收發數據，但它是個**無邊界**的數據流，上層需要定義**消息格式**用於定義**消息邊界**。於是就有了各種協議，HTTP 和各類 RPC 協議就是在 TCP 之上定義的應用層協議。
- **RPC 本質上不算是協議，而是一種調用方式**，而像 gRPC 和 Thrift 這樣的具體實現，才是協議，它們是實現了 RPC 調用的協議。目的是希望程序員能像調用本地方法那樣去調用遠端的服務方法。同時 RPC 有很多種實現方式，**不一定非得基於 TCP 協議**。
- 從發展歷史來說，**HTTP 主要用於 B/S 架構，而 RPC 更多用於 C/S 架構。但現在其實已經沒分那麼清了，B/S 和 C/S 在慢慢融合**。很多軟件同時支持多端，所以對外一般用 HTTP 協議，而內部集群的微服務之間則採用 RPC 協議進行通訊。
- RPC 其實比 HTTP 出現的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司內部都還在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基礎上做了優化，性能可能比很多 RPC 協議都要好，但由於是這幾年才出來的，所以也不太可能取代掉 RPC。

---

***哈嘍，我是小林，就愛圖解計算機基礎，如果覺得文章對你有幫助，歡迎微信搜索「小林coding」***

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)