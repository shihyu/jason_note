# ä½å»¶é²æŠ€è¡“æœ€ä½³å¯¦è¸æŒ‡å—

> Building Low Latency Applications with C++ - é«˜é »äº¤æ˜“ç³»çµ±æ ¸å¿ƒæŠ€è¡“æ‰‹å†Š

---

## ğŸ“‹ ç›®éŒ„

1. [ç°¡ä»‹](#ç°¡ä»‹)
2. [å»¶é²ç›®æ¨™èˆ‡æ¸¬é‡](#å»¶é²ç›®æ¨™èˆ‡æ¸¬é‡)
3. [æ ¸å¿ƒè³‡æ–™çµæ§‹](#æ ¸å¿ƒè³‡æ–™çµæ§‹)
4. [è¨˜æ†¶é«”ç®¡ç†](#è¨˜æ†¶é«”ç®¡ç†)
5. [åŸ·è¡Œç·’ç®¡ç†](#åŸ·è¡Œç·’ç®¡ç†)
6. [ç¶²è·¯å„ªåŒ–](#ç¶²è·¯å„ªåŒ–)
7. [æ—¥èªŒç³»çµ±](#æ—¥èªŒç³»çµ±)
8. [ç·¨è­¯å™¨å„ªåŒ–](#ç·¨è­¯å™¨å„ªåŒ–)
9. [ç¡¬é«”èª¿å„ª](#ç¡¬é«”èª¿å„ª)
10. [æ€§èƒ½æ¸¬è©¦èˆ‡ç›£æ§](#æ€§èƒ½æ¸¬è©¦èˆ‡ç›£æ§)

---

## ç°¡ä»‹

æœ¬æŒ‡å—æ•´åˆäº†é«˜é »äº¤æ˜“ç³»çµ±é–‹ç™¼ä¸­çš„æ‰€æœ‰é—œéµä½å»¶é²æŠ€è¡“ï¼Œæ¶µè“‹å¾æ‡‰ç”¨å±¤åˆ°ç¡¬é«”å±¤çš„å®Œæ•´å„ªåŒ–ç­–ç•¥ã€‚

### ç›®æ¨™è®€è€…

- é«˜é »äº¤æ˜“ç³»çµ±é–‹ç™¼è€…
- å³æ™‚ç³»çµ±å·¥ç¨‹å¸«
- C++ æ•ˆèƒ½å„ªåŒ–å·¥ç¨‹å¸«
- é‡åŒ–äº¤æ˜“åŸºç¤è¨­æ–½åœ˜éšŠ

### å»¶é²ç­‰ç´šå®šç¾©

| å»¶é²ç¯„åœ | ç­‰ç´š | å…¸å‹æ‡‰ç”¨å ´æ™¯ |
|---------|------|-------------|
| **< 1Î¼s** | æ¥µä½å»¶é² | äº¤æ˜“æ‰€æ’®åˆå¼•æ“æ ¸å¿ƒé‚è¼¯ |
| **1-10Î¼s** | è¶…ä½å»¶é² | è¨‚å–®ç°¿æ›´æ–°ã€å¸‚å ´æ•¸æ“šè™•ç† |
| **10-100Î¼s** | ä½å»¶é² | ç«¯åˆ°ç«¯è¨‚å–®å¾€è¿”ï¼ˆåŒæ©Ÿæˆ¿ï¼‰ |
| **100-1000Î¼s** | ä¸€èˆ¬å»¶é² | è·¨åŸå¸‚è¨‚å–®å¾€è¿” |
| **> 1ms** | ä¸å¯æ¥å— | éœ€è¦å„ªåŒ– |

---

## å»¶é²ç›®æ¨™èˆ‡æ¸¬é‡

### 1. æ¸¬é‡åŸºç¤è¨­æ–½

```cpp
// ä½¿ç”¨ RDTSCï¼ˆè®€å–æ™‚é–“æˆ³è¨˜è¨ˆæ•¸å™¨ï¼‰æ¸¬é‡ CPU é€±æœŸ
inline uint64_t rdtsc() {
    unsigned int lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
    return ((uint64_t)hi << 32) | lo;
}

// ä½¿ç”¨ç¯„ä¾‹ï¼šæ¸¬é‡å‡½å¼å»¶é²
uint64_t start = rdtsc();
process_order();  // å¾…æ¸¬é‡çš„æ“ä½œ
uint64_t end = rdtsc();
uint64_t cycles = end - start;  // CPU é€±æœŸæ•¸

// æ›ç®—ç‚ºå¥ˆç§’ï¼ˆå‡è¨­ CPU é »ç‡ 3.0 GHzï¼‰
double ns = (cycles / 3.0);
```

### 2. å»¶é²æ¸¬é‡æœ€ä½³å¯¦è¸

#### âœ… æ­£ç¢ºåšæ³•

```cpp
// ä½¿ç”¨é«˜ç²¾åº¦æ™‚é˜
#include "common/time_utils.h"

Nanos start = getCurrentNanos();
process_order();
Nanos latency = getCurrentNanos() - start;

// è¨˜éŒ„åˆ°å»¶é²ç›´æ–¹åœ–ï¼ˆP50/P99/P99.9ï¼‰
latency_histogram.record(latency);
```

#### âŒ å¸¸è¦‹éŒ¯èª¤

```cpp
// éŒ¯èª¤ 1ï¼šä½¿ç”¨ä½ç²¾åº¦æ™‚é˜
auto start = std::chrono::system_clock::now();  // ç²¾åº¦ä¸è¶³

// éŒ¯èª¤ 2ï¼šåœ¨é—œéµè·¯å¾‘ä¸­è¨˜éŒ„æ—¥èªŒ
logger.log("Order processed in %d ns\n", latency);  // å¢åŠ å»¶é²

// éŒ¯èª¤ 3ï¼šåªæ¸¬é‡å¹³å‡å€¼
double avg_latency = total_latency / count;  // å¿½ç•¥å°¾éƒ¨å»¶é²
```

### 3. é—œéµæŒ‡æ¨™

| æŒ‡æ¨™ | èªªæ˜ | ç›®æ¨™å€¼ |
|------|------|-------|
| **P50ï¼ˆä¸­ä½æ•¸ï¼‰** | 50% çš„è«‹æ±‚å»¶é²ä½æ–¼æ­¤å€¼ | < 10Î¼s |
| **P99** | 99% çš„è«‹æ±‚å»¶é²ä½æ–¼æ­¤å€¼ | < 50Î¼s |
| **P99.9** | 99.9% çš„è«‹æ±‚å»¶é²ä½æ–¼æ­¤å€¼ | < 100Î¼s |
| **æœ€å¤§å»¶é²** | æœ€å·®æƒ…æ³å»¶é² | < 500Î¼s |
| **æŠ–å‹•ï¼ˆJitterï¼‰** | P99 - P50 | < 40Î¼s |

---

## æ ¸å¿ƒè³‡æ–™çµæ§‹

### 1. Lock-Free Queueï¼ˆç„¡é–ä½‡åˆ—ï¼‰

#### è¨­è¨ˆåŸå‰‡

- **SPSCï¼ˆSingle Producer Single Consumerï¼‰**ï¼šé¿å…è¤‡é›œçš„åŒæ­¥æ©Ÿåˆ¶
- **Ring Buffer**ï¼šå›ºå®šå¤§å°ï¼Œé¿å…å‹•æ…‹è¨˜æ†¶é«”åˆ†é…
- **åŸå­æ“ä½œ**ï¼šä½¿ç”¨ `std::atomic` ä¿è­‰å¯è¦‹æ€§

#### å¯¦ä½œè¦é»

```cpp
template<typename T>
class LFQueue {
public:
    LFQueue(size_t size) : store_(size, T()) {}

    // Producer: å–å¾—ä¸‹ä¸€å€‹å¯å¯«å…¥ä½ç½®
    T* getNextToWriteTo() noexcept {
        return &store_[next_write_index_];
    }

    // Producer: æ›´æ–°å¯«å…¥ç´¢å¼•
    void updateWriteIndex() noexcept {
        next_write_index_ = (next_write_index_ + 1) % store_.size();
        num_elements_++;  // åŸå­éå¢
    }

    // Consumer: å–å¾—ä¸‹ä¸€å€‹å¯è®€å–çš„å…ƒç´ 
    const T* getNextToRead() const noexcept {
        return (size() ? &store_[next_read_index_] : nullptr);
    }

    // Consumer: æ›´æ–°è®€å–ç´¢å¼•
    void updateReadIndex() noexcept {
        next_read_index_ = (next_read_index_ + 1) % store_.size();
        num_elements_--;  // åŸå­éæ¸›
    }

private:
    std::vector<T> store_;  // Ring Buffer
    std::atomic<size_t> next_write_index_ = {0};
    std::atomic<size_t> next_read_index_ = {0};
    std::atomic<size_t> num_elements_ = {0};
};
```

#### æ•ˆèƒ½ç‰¹æ€§

- **å…¥åˆ—/å‡ºåˆ—å»¶é²**ï¼š
  - ç†æƒ³æƒ…æ³ (é«˜é » CPU, ç†± Cache): 10-50ns
  - å¯¦éš›æ¸¬é‡ (åŒ…å« RDTSC é–‹éŠ·): 50-200ns
  - CPU é »ç‡å½±éŸ¿: ä½é » CPU å»¶é²æˆæ¯”ä¾‹å¢åŠ 
  - **é©—è­‰æ•¸æ“š**: å¯¦æ¸¬ @ 5.5GHz P50 = 11-14ns, @ 1.1GHz P50 = 57-182ns
- **ç„¡é–è¨­è¨ˆ**ï¼šé¿å… Mutex é–‹éŠ·ï¼ˆ~25ns per lockï¼‰
- **Cache å‹å–„**ï¼šé€£çºŒè¨˜æ†¶é«”å­˜å–
- **alignas(64) æ•ˆæœ**: å¤šåŸ·è¡Œç·’æƒ…æ³ä¸‹æ•ˆèƒ½æå‡ 50-70% (å¯¦æ¸¬é©—è­‰)

#### âš ï¸ Cache False Sharing é¢¨éšª

```cpp
// å•é¡Œï¼šnext_write_index_ å’Œ next_read_index_ å¯èƒ½åœ¨åŒä¸€ Cache Line
std::atomic<size_t> next_write_index_ = {0};  // Producer é »ç¹ä¿®æ”¹
std::atomic<size_t> next_read_index_ = {0};   // Consumer é »ç¹ä¿®æ”¹

// è§£æ±ºæ–¹æ¡ˆï¼šä½¿ç”¨ alignas å¼·åˆ¶å°é½Šåˆ°ä¸åŒ Cache Line
alignas(64) std::atomic<size_t> next_write_index_ = {0};
alignas(64) std::atomic<size_t> next_read_index_ = {0};
```

---

### 2. Memory Poolï¼ˆè¨˜æ†¶é«”æ± ï¼‰

#### è¨­è¨ˆåŸå‰‡

- **é å…ˆé…ç½®**ï¼šå•Ÿå‹•æ™‚ä¸€æ¬¡æ€§é…ç½®æ‰€æœ‰è¨˜æ†¶é«”
- **Placement New**ï¼šåªå‘¼å«å»ºæ§‹å­ï¼Œä¸åˆ†é…è¨˜æ†¶é«”
- **O(1) åˆ†é…**ï¼šä½¿ç”¨ç©ºé–’ä¸²åˆ—æˆ–ç·šæ€§æ¢æ¸¬

#### å¯¦ä½œè¦é»

```cpp
template<typename T>
class MemPool {
public:
    explicit MemPool(size_t num_elems)
        : store_(num_elems, {T(), true}) {}

    // ä½¿ç”¨ Placement New åˆ†é…ç‰©ä»¶
    template<typename... Args>
    T* allocate(Args... args) noexcept {
        auto obj_block = &(store_[next_free_index_]);
        T* ret = &(obj_block->object_);
        ret = new (ret) T(args...);  // Placement New
        obj_block->is_free_ = false;
        updateNextFreeIndex();
        return ret;
    }

    // é‡‹æ”¾ç‰©ä»¶ï¼ˆæ¨™è¨˜ç‚ºç©ºé–’ï¼‰
    void deallocate(const T* elem) noexcept {
        const auto elem_index = (reinterpret_cast<const ObjectBlock*>(elem) - &store_[0]);
        store_[elem_index].is_free_ = true;
    }

private:
    struct ObjectBlock {
        T object_;
        bool is_free_ = true;
    };

    std::vector<ObjectBlock> store_;
    size_t next_free_index_ = 0;
};
```

#### æ•ˆèƒ½ç‰¹æ€§

- **åˆ†é…å»¶é²**: < 20ns (å…¸å‹æƒ…æ³ ~5ns, å¯¦æ¸¬é©—è­‰)
- **vs malloc æ¯”è¼ƒ**:
  - malloc P50: ~10ns (ç¾ä»£ glibc å°ç‰©ä»¶å¿«é€Ÿè·¯å¾‘)
  - malloc P99: 50-100ns
  - malloc æœ€å·®æƒ…æ³: 1000-10000ns (ç³»çµ±å‘¼å«, é é¢åˆ†é…)
  - **Memory Pool å„ªå‹¢**: å¯é æ¸¬å»¶é² (P99 æ¥è¿‘ P50)
  - **é©—è­‰æ•¸æ“š**: Pool P50=4.5ns vs malloc P50=10.2ns, åŠ é€Ÿ 2.24x
- **é›¶ç¢ç‰‡åŒ–**ï¼šæ‰€æœ‰ç‰©ä»¶å¤§å°ç›¸åŒ
- **å¯é æ¸¬å»¶é²**ï¼šç„¡å‹•æ…‹åˆ†é…çš„è®Šç•°æ€§ (æŠ–å‹• <1ns)

#### å„ªåŒ–å»ºè­°

```cpp
// æ–¹æ¡ˆ Aï¼šç·šæ€§æ¢æ¸¬ï¼ˆç•¶å‰å¯¦ä½œï¼‰
// - å„ªé»ï¼šå¯¦ä½œç°¡å–®ï¼ŒCache å‹å–„
// - ç¼ºé»ï¼šé«˜ä½¿ç”¨ç‡æ™‚é™ç´šåˆ° O(N)

// æ–¹æ¡ˆ Bï¼šFree Listï¼ˆéˆçµä¸²åˆ—ï¼‰
// - å„ªé»ï¼šO(1) åˆ†é…/é‡‹æ”¾
// - ç¼ºé»ï¼šéœ€é¡å¤–è¨˜æ†¶é«”ï¼ˆæŒ‡æ¨™ï¼‰ï¼ŒCache Miss é¢¨éšª

// å»ºè­°ï¼šä½¿ç”¨ç‡ < 80% æ™‚ä½¿ç”¨ç·šæ€§æ¢æ¸¬ï¼Œ> 80% æ™‚åˆ‡æ›åˆ° Free List
```

---

## è¨˜æ†¶é«”ç®¡ç†

### 1. è¨˜æ†¶é«”åˆ†é…ç­–ç•¥

#### âœ… æœ€ä½³å¯¦è¸

```cpp
// 1. å•Ÿå‹•æ™‚é å…ˆé…ç½®æ‰€æœ‰è¨˜æ†¶é«”
MemPool<Order> order_pool(10000);  // é é…ç½® 10000 å€‹è¨‚å–®

// 2. ä½¿ç”¨ Memory Pool è€Œé new/malloc
Order* order = order_pool.allocate(order_id, price, qty);

// 3. ä½¿ç”¨ std::vector::reserve é ç•™å®¹é‡
std::vector<Order*> orders;
orders.reserve(10000);  // é¿å…å‹•æ…‹æ“´å®¹
```

#### âŒ é¿å…çš„åšæ³•

```cpp
// éŒ¯èª¤ 1ï¼šåœ¨é—œéµè·¯å¾‘ä¸­ä½¿ç”¨ new/delete
Order* order = new Order(order_id, price, qty);  // malloc å»¶é²è®Šç•°å¤§

// éŒ¯èª¤ 2ï¼šå‹•æ…‹æ“´å®¹
std::vector<Order*> orders;  // é è¨­å®¹é‡ 0ï¼Œæœƒå¤šæ¬¡é‡æ–°é…ç½®

// éŒ¯èª¤ 3ï¼šé »ç¹çš„å°ç‰©ä»¶åˆ†é…
for (int i = 0; i < 1000; i++) {
    std::string msg = "Order " + std::to_string(i);  // æ¯æ¬¡è¿´åœˆéƒ½åˆ†é…è¨˜æ†¶é«”
}
```

### 2. Memory Alignmentï¼ˆè¨˜æ†¶é«”å°é½Šï¼‰

#### Cache Line Alignment

```cpp
// ç¢ºä¿é—œéµè³‡æ–™çµæ§‹å°é½Šåˆ° Cache Lineï¼ˆ64 bytesï¼‰
struct alignas(64) OrderBook {
    Price best_bid_;
    Price best_ask_;
    // ...
};

// é¿å… False Sharingï¼šä¸åŒåŸ·è¡Œç·’å­˜å–çš„è®Šæ•¸åˆ†é–‹å°é½Š
struct ThreadData {
    alignas(64) int thread1_counter_;  // Cache Line 1
    alignas(64) int thread2_counter_;  // Cache Line 2
};
```

#### âš ï¸ False Sharing çš„åš´é‡æ€§ (å¯¦æ¸¬é©—è­‰)

å¯¦æ¸¬çµæœé¡¯ç¤º,False Sharing çš„å½±éŸ¿å¯èƒ½æ¯”é æœŸåš´é‡:

**æ¸¬è©¦å ´æ™¯**: 2 åŸ·è¡Œç·’,å„è‡ªæ“ä½œç¨ç«‹è¨ˆæ•¸å™¨ (1å„„æ¬¡åŸå­éå¢)
- ç„¡å°é½Š (8 bytes é–“è·): 1454 ms
- æœ‰å°é½Š (64 bytes é–“è·): 335 ms
- **æ•ˆèƒ½å·®è·: 4.34å€** â† å¯¦æ¸¬é©—è­‰

**åŸå› **:
- å…©å€‹è¨ˆæ•¸å™¨åœ¨åŒä¸€ Cache Line (64 bytes)
- åŸ·è¡Œç·’ A ä¿®æ”¹ counter1 â†’ ä½¿åŸ·è¡Œç·’ B çš„ Cache Line å¤±æ•ˆ
- åŸ·è¡Œç·’ B ä¿®æ”¹ counter2 â†’ ä½¿åŸ·è¡Œç·’ A çš„ Cache Line å¤±æ•ˆ
- **ä¹’ä¹“æ•ˆæ‡‰**: Cache Line åœ¨ CPU æ ¸å¿ƒé–“ä¸æ–·å‚³é

**çµè«–**: å¤šåŸ·è¡Œç·’ç¨‹å¼ä¸­,**alignas(64) æ˜¯å¿…å‚™å„ªåŒ–**,è€Œéå¯é¸å„ªåŒ–ã€‚

#### Huge Pagesï¼ˆå¤§é é¢ï¼‰

```cpp
// ä½¿ç”¨ 2MB Huge Pages æ¸›å°‘ TLB Miss
// é…ç½®æ–¹æ³•ï¼ˆéœ€ root æ¬Šé™ï¼‰ï¼š
// echo 1024 > /proc/sys/vm/nr_hugepages

// C++ ç¨‹å¼ä¸­ä½¿ç”¨ï¼š
void* ptr = mmap(nullptr, size,
                 PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                 -1, 0);
```

---

## åŸ·è¡Œç·’ç®¡ç†

### 1. Thread Affinityï¼ˆCPU è¦ªå’ŒåŠ›ï¼‰

#### è¨­å®š CPU ç¶å®š

```cpp
// å°‡åŸ·è¡Œç·’ç¶å®šåˆ°æŒ‡å®š CPU æ ¸å¿ƒ
bool setThreadCore(int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    return (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset) == 0);
}

// ä½¿ç”¨ç¯„ä¾‹ï¼š
// - æ ¸å¿ƒ 2ï¼šäº¤æ˜“å¼•æ“ä¸»åŸ·è¡Œç·’
// - æ ¸å¿ƒ 3ï¼šå¸‚å ´æ•¸æ“šæ¥æ”¶åŸ·è¡Œç·’
// - æ ¸å¿ƒ 4ï¼šè¨‚å–®é–˜é“åŸ·è¡Œç·’
setThreadCore(2);
```

#### æ•ˆèƒ½å½±éŸ¿

- **æ¸›å°‘ä¸Šä¸‹æ–‡åˆ‡æ›**ï¼šé¿å…åŸ·è¡Œç·’åœ¨ä¸åŒæ ¸å¿ƒé–“é·ç§»
- **æ¸›å°‘ Cache Miss**ï¼šL1/L2 Cache å‘½ä¸­ç‡æé«˜ â†’ å»¶é²æ¸›å°‘ 10-50ns
- **é æ¸¬æ€§å»¶é²**ï¼šå›ºå®šæ ¸å¿ƒ â†’ å»¶é²è®Šç•°é™ä½ 30-50%

#### CPU Isolationï¼ˆæ ¸å¿ƒéš”é›¢ï¼‰

```bash
# GRUB é…ç½®ï¼ˆ/etc/default/grubï¼‰
GRUB_CMDLINE_LINUX="isolcpus=2,3,4"

# é‡æ–°ç”Ÿæˆ GRUB é…ç½®
sudo update-grub
sudo reboot

# é©—è­‰éš”é›¢æ•ˆæœ
cat /sys/devices/system/cpu/isolated
```

---

### 2. åŸ·è¡Œç·’å„ªå…ˆç´š

```cpp
// è¨­å®šå³æ™‚å„ªå…ˆç´šï¼ˆSCHED_FIFOï¼‰
void setRealtimePriority(int priority) {
    struct sched_param param;
    param.sched_priority = priority;  // 1-99ï¼Œ99 ç‚ºæœ€é«˜

    if (sched_setscheduler(0, SCHED_FIFO, &param) != 0) {
        perror("sched_setscheduler failed");
    }
}

// ä½¿ç”¨ç¯„ä¾‹ï¼ˆéœ€ root æ¬Šé™æˆ– CAP_SYS_NICEï¼‰
setRealtimePriority(99);  // äº¤æ˜“å¼•æ“ä½¿ç”¨æœ€é«˜å„ªå…ˆç´š
```

---

## ç¶²è·¯å„ªåŒ–

### 1. TCP Socket å„ªåŒ–

#### é—œéµåƒæ•¸è¨­å®š

```cpp
int fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

// 1. TCP_NODELAYï¼šé—œé–‰ Nagle æ¼”ç®—æ³•
int one = 1;
setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));

// 2. è¨­å®šå¤§ç·©è¡å€ï¼ˆ64 MBï¼‰
int buf_size = 64 * 1024 * 1024;
setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));
setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buf_size, sizeof(buf_size));

// 3. éé˜»å¡æ¨¡å¼
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);

// 4. SO_REUSEADDRï¼šå¿«é€Ÿé‡å•Ÿ
setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
```

#### æ•ˆèƒ½å½±éŸ¿

| å„ªåŒ–é …ç›® | å»¶é²é™ä½ | èªªæ˜ |
|---------|---------|------|
| **TCP_NODELAY** | ~40Î¼s | ç«‹å³ç™¼é€å°å°åŒ…ï¼Œä¸ç­‰å¾… ACK |
| **å¤§ç·©è¡å€** | ~20Î¼s | æ¸›å°‘ç³»çµ±å‘¼å«æ¬¡æ•¸ |
| **éé˜»å¡ I/O** | N/A | é¿å…é˜»å¡ä¸»åŸ·è¡Œç·’ |

---

### 2. UDP Multicast å„ªåŒ–

```cpp
// UDP Multicast æ¥æ”¶é…ç½®
SocketCfg mcast_cfg{
    .ip_ = "239.255.0.1",         // Multicast ç¾¤çµ„
    .iface_ = "eth0",
    .port_ = 9090,
    .is_udp_ = true,
    .is_listening_ = true,
    .needs_so_timestamp_ = true   // å•Ÿç”¨æ ¸å¿ƒæ™‚é–“æˆ³è¨˜
};

int fd = createSocket(logger, mcast_cfg);

// åŠ å…¥ Multicast ç¾¤çµ„
ip_mreq mreq;
mreq.imr_multiaddr.s_addr = inet_addr("239.255.0.1");
mreq.imr_interface.s_addr = htonl(INADDR_ANY);
setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
```

#### Multicast æœ€ä½³å¯¦è¸

- **ä½¿ç”¨å°ˆç”¨ç¶²è·¯ä»‹é¢**ï¼šé¿å…èˆ‡å…¶ä»–æµé‡ç«¶çˆ­
- **å•Ÿç”¨ SO_TIMESTAMP**ï¼šæ¸¬é‡å°åŒ…åˆ°é”æ™‚é–“
- **èª¿æ•´æ¥æ”¶ç·©è¡å€**ï¼šè™•ç†çªç™¼æµé‡

---

### 3. Kernel Bypassï¼ˆæ ¸å¿ƒç¹éï¼‰

#### DPDKï¼ˆData Plane Development Kitï¼‰

```cpp
// DPDK åˆå§‹åŒ–ï¼ˆç°¡åŒ–ç¯„ä¾‹ï¼‰
int ret = rte_eal_init(argc, argv);
struct rte_mempool* mbuf_pool = rte_pktmbuf_pool_create(...);

// æ¥æ”¶å°åŒ…ï¼ˆé›¶æ‹·è²ï¼‰
struct rte_mbuf* pkts[BURST_SIZE];
uint16_t nb_rx = rte_eth_rx_burst(port_id, 0, pkts, BURST_SIZE);

for (int i = 0; i < nb_rx; i++) {
    process_packet(pkts[i]);  // ç›´æ¥å­˜å–ç¶²å¡ç·©è¡å€
}
```

#### æ•ˆèƒ½æå‡

- **å»¶é²é™ä½**ï¼šå¾ ~10Î¼s é™è‡³ ~1Î¼s
- **ååé‡æå‡**ï¼š10å€ä»¥ä¸Šï¼ˆ1Gbps â†’ 10Gbpsï¼‰
- **CPU ä½¿ç”¨ç‡**ï¼šé™ä½ 30-50%ï¼ˆé¿å…æ ¸å¿ƒé–‹éŠ·ï¼‰

---

## æ—¥èªŒç³»çµ±

### 1. ç„¡é– Logger è¨­è¨ˆ

#### æ¶æ§‹

```cpp
// Producerï¼ˆäº¤æ˜“åŸ·è¡Œç·’ï¼‰ï¼šéé˜»å¡å¯«å…¥
logger.log("Order ID: % Price: % Qty: %\n", order_id, price, qty);
// å»¶é²ï¼š< 100nsï¼ˆåƒ…å¯«å…¥ LFQueueï¼‰

// Consumerï¼ˆæ—¥èªŒåŸ·è¡Œç·’ï¼‰ï¼šæ‰¹æ¬¡åˆ·æ–°
void flushQueue() {
    while (running_) {
        // æ‰¹æ¬¡è®€å–æ‰€æœ‰æ—¥èªŒ
        for (auto next = queue_.getNextToRead(); queue_.size(); next = queue_.getNextToRead()) {
            file_ << format(next);  // æ ¼å¼åŒ–è¼¸å‡º
            queue_.updateReadIndex();
        }
        file_.flush();  // æ‰¹æ¬¡ flush
        std::this_thread::sleep_for(10ms);  // 10ms é–“éš”
    }
}
```

#### é—œéµå„ªåŒ–

- **Tagged Union**ï¼šé¿å…è™›æ“¬å‡½å¼é–‹éŠ·
- **Lock-Free Queue**ï¼šé›¶é–ç«¶çˆ­
- **æ‰¹æ¬¡ Flush**ï¼šæ¸›å°‘ I/O ç³»çµ±å‘¼å«

---

### 2. æ—¥èªŒç­‰ç´šæ§åˆ¶

```cpp
enum class LogLevel { DEBUG, INFO, WARN, ERROR };

// ç·¨è­¯æœŸæ—¥èªŒéæ¿¾
#ifdef NDEBUG
#define LOG_DEBUG(...)  // ç©ºæ“ä½œ
#else
#define LOG_DEBUG(...) logger.log(__VA_ARGS__)
#endif

// åŸ·è¡ŒæœŸæ—¥èªŒéæ¿¾
if (log_level >= LogLevel::INFO) {
    logger.log("Order filled: %\n", order_id);
}
```

---

## ç·¨è­¯å™¨å„ªåŒ–

### 1. åˆ†æ”¯é æ¸¬æç¤º

```cpp
// LIKELY/UNLIKELY å·¨é›†
#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)

// ä½¿ç”¨ç¯„ä¾‹
if (LIKELY(order != nullptr)) {
    process_order(order);  // ç†±è·¯å¾‘
}

if (UNLIKELY(error)) {
    handle_error();  // å†·è·¯å¾‘
}
```

#### æ•ˆèƒ½å½±éŸ¿ (ç†è«–å€¼)

- **åˆ†æ”¯é æ¸¬æˆåŠŸ**ï¼šç¯€çœ 5-20 å€‹ CPU é€±æœŸ
- **åˆ†æ”¯é æ¸¬å¤±æ•—**ï¼šæ‡²ç½° 10-40 å€‹ CPU é€±æœŸ
- **å»ºè­°**ï¼šåƒ…ç”¨æ–¼ >90% æ©Ÿç‡çš„åˆ†æ”¯

#### âš ï¸ ç¾ä»£ CPU æ³¨æ„äº‹é … (å¯¦æ¸¬é©—è­‰)

ç¾ä»£ CPU (Intel Core i5+, AMD Ryzen ç­‰) å…·æœ‰:
- å¤šå±¤æ¬¡åˆ†æ”¯é æ¸¬å™¨ (PHT, BTB, RSB)
- è‡ªé©æ‡‰å­¸ç¿’æ©Ÿåˆ¶
- æ¥µé«˜çš„é æ¸¬æº–ç¢ºç‡ (>95%)

**å¯¦éš›æ•ˆæœ**:
- ç°¡å–®æ¨¡å¼: CPU è‡ªå‹•é æ¸¬,æ‰‹å‹•æç¤ºæ•ˆæœä¸æ˜é¡¯
- è¤‡é›œæ¨¡å¼: æ‰‹å‹•æç¤ºå¯èƒ½æœ‰å¹«åŠ©
- **éŒ¯èª¤æç¤º**: å¯èƒ½æ¯”ä¸æç¤ºæ›´ç³Ÿç³• â† å¯¦æ¸¬é©—è­‰

**ä½¿ç”¨å»ºè­°**:
1. å„ªå…ˆè®“ CPU è‡ªå‹•é æ¸¬
2. åƒ…åœ¨ç¢ºå®šçš„æ¥µç«¯æƒ…æ³ä½¿ç”¨ (>95% æˆ– <5%)
3. ä½¿ç”¨ perf stat é©—è­‰æ•ˆæœ (branch-misses è¨ˆæ•¸å™¨)
4. é¿å…éæ—©å„ªåŒ–

---

### 2. Inline èˆ‡ Constexpr

```cpp
// å¼·åˆ¶å…§è¯
inline __attribute__((always_inline))
bool is_valid(Price price) {
    return price > 0 && price < MAX_PRICE;
}

// ç·¨è­¯æœŸå¸¸æ•¸
constexpr size_t MAX_ORDERS = 10000;
constexpr Nanos NANOS_TO_MICROS = 1000;

// ç·¨è­¯æœŸè¨ˆç®—
constexpr Nanos convert_to_micros(Nanos ns) {
    return ns / NANOS_TO_MICROS;
}
```

---

### 3. ç·¨è­¯é¸é …

```bash
# GCC/Clang å„ªåŒ–é¸é …
CXXFLAGS="-O3 -march=native -mtune=native -flto -ffast-math"

# èªªæ˜ï¼š
# -O3: æœ€é«˜å„ªåŒ–ç­‰ç´š
# -march=native: é‡å°ç•¶å‰ CPU å¾®æ¶æ§‹å„ªåŒ–
# -mtune=native: èª¿æ•´æŒ‡ä»¤æ’ç¨‹
# -flto: Link-Time Optimization
# -ffast-math: å¿«é€Ÿæµ®é»é‹ç®—ï¼ˆçŠ§ç‰²ç²¾åº¦ï¼‰
```

---

## ç¡¬é«”èª¿å„ª

### 1. CPU è¨­å®š

#### Turbo Boost èˆ‡ C-States

```bash
# é—œé–‰ Turbo Boostï¼ˆä¿æŒå›ºå®šé »ç‡ï¼‰
echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo

# é—œé–‰ C-Statesï¼ˆç¦ç”¨ä½åŠŸè€—æ¨¡å¼ï¼‰
for i in /sys/devices/system/cpu/cpu*/cpuidle/state*/disable; do
    echo 1 > $i
done

# è¨­å®š CPU Governor ç‚º performance
cpupower frequency-set -g performance
```

#### æ•ˆèƒ½å½±éŸ¿

- **å»¶é²é™ä½**ï¼š20-50Î¼sï¼ˆé¿å…é »ç‡åˆ‡æ›ï¼‰
- **å»¶é²è®Šç•°é™ä½**ï¼š30-60%ï¼ˆå›ºå®šé »ç‡ï¼‰

#### âš ï¸ CPU é »ç‡å°å»¶é²æ¸¬é‡çš„å½±éŸ¿ (å¯¦æ¸¬é©—è­‰)

**å•é¡Œ**: å‹•æ…‹é »ç‡èª¿æ•´ (Turbo Boost, C-States) æœƒå°è‡´å»¶é²è®Šç•°ã€‚

**æ¸¬è©¦è§€å¯Ÿ**:
- CPU é »ç‡ç¯„åœ: 1.0-5.5 GHz (5.5å€å·®ç•°)
- åŒæ¨£çš„ 25 é€±æœŸæ“ä½œ:
  - @ 1.0 GHz: 25 ns
  - @ 5.5 GHz: 4.5 ns

**ç”Ÿç”¢ç’°å¢ƒå»ºè­°**:
1. é—œé–‰ Turbo Boost: å›ºå®šæœ€é«˜é »ç‡
2. é—œé–‰ C-States: é¿å…ç¡çœ å–šé†’å»¶é²
3. è¨­å®š CPU Governor ç‚º performance
4. é©—è­‰: `cat /proc/cpuinfo | grep "cpu MHz"`

**æ¸¬é‡å»ºè­°**:
- ä½¿ç”¨ **CPU é€±æœŸ** è€Œéå¥ˆç§’ä½œç‚ºåŸºæº–
- è¨˜éŒ„æ¸¬è©¦æ™‚çš„ CPU é »ç‡
- å¤šæ¬¡æ¸¬é‡å–ä¸­ä½æ•¸ (P50/P99)

---

### 2. NUMA æ‹“æ¨¸å„ªåŒ–

```bash
# æŸ¥çœ‹ NUMA ç¯€é»
numactl --hardware

# ç¶å®šç¨‹å¼åˆ°ç‰¹å®š NUMA ç¯€é»
numactl --cpunodebind=0 --membind=0 ./trading_engine

# æª¢æŸ¥ NUMA çµ±è¨ˆ
numastat -p $(pidof trading_engine)
```

---

### 3. ç¶²å¡èª¿å„ª

```bash
# å¢åŠ æ¥æ”¶ç·©è¡å€
ethtool -G eth0 rx 4096 tx 4096

# å•Ÿç”¨ RSSï¼ˆReceive Side Scalingï¼‰
ethtool -X eth0 equal 4

# é—œé–‰ä¸­æ–·èšåˆï¼ˆé™ä½å»¶é²ï¼‰
ethtool -C eth0 rx-usecs 0 tx-usecs 0

# ç¶å®šç¶²å¡ä¸­æ–·åˆ°æŒ‡å®š CPU
echo 1 > /proc/irq/123/smp_affinity
```

---

## æ€§èƒ½æ¸¬è©¦èˆ‡ç›£æ§

### 1. å»¶é²ç›´æ–¹åœ–

```cpp
class LatencyHistogram {
public:
    void record(Nanos latency) {
        latencies_.push_back(latency);
    }

    void print_percentiles() {
        std::sort(latencies_.begin(), latencies_.end());
        size_t n = latencies_.size();

        std::cout << "P50:    " << latencies_[n * 0.50] << " ns\n";
        std::cout << "P90:    " << latencies_[n * 0.90] << " ns\n";
        std::cout << "P99:    " << latencies_[n * 0.99] << " ns\n";
        std::cout << "P99.9:  " << latencies_[n * 0.999] << " ns\n";
        std::cout << "P99.99: " << latencies_[n * 0.9999] << " ns\n";
        std::cout << "Max:    " << latencies_[n - 1] << " ns\n";
    }

private:
    std::vector<Nanos> latencies_;
};
```

---

### 2. perf å·¥å…·ä½¿ç”¨

```bash
# è¨˜éŒ„ CPU æ•ˆèƒ½è¨ˆæ•¸å™¨
perf stat -e cycles,instructions,cache-misses,branch-misses ./trading_engine

# æ¡æ¨£åˆ†æç†±é»å‡½å¼
perf record -g ./trading_engine
perf report

# åˆ†æ Cache Miss
perf stat -e L1-dcache-load-misses,LLC-load-misses ./trading_engine
```

---

## æª¢æŸ¥æ¸…å–®

### å•Ÿå‹•å‰æª¢æŸ¥

- [ ] æ‰€æœ‰åŸ·è¡Œç·’å·²ç¶å®šåˆ°å°ˆç”¨ CPU æ ¸å¿ƒ
- [ ] CPU Governor è¨­å®šç‚º performance
- [ ] Turbo Boost èˆ‡ C-States å·²é—œé–‰
- [ ] ç¶²å¡ä¸­æ–·å·²ç¶å®šåˆ°å°ˆç”¨ CPU
- [ ] Memory Pool å·²é å…ˆé…ç½®
- [ ] Lock-Free Queue å¤§å°å·²èª¿æ•´
- [ ] æ—¥èªŒç­‰ç´šè¨­å®šç‚º INFO æˆ– WARN

### åŸ·è¡Œæ™‚ç›£æ§

- [ ] P99 å»¶é² < ç›®æ¨™å€¼
- [ ] CPU ä½¿ç”¨ç‡ < 80%
- [ ] Cache Miss ç‡ < 5%
- [ ] ç„¡è¨˜æ†¶é«”åˆ†é…ï¼ˆmalloc/free å‘¼å«æ¬¡æ•¸ç‚º 0ï¼‰
- [ ] ç„¡ä¸Šä¸‹æ–‡åˆ‡æ›ï¼ˆvoluntary context switches < 10/sï¼‰

---

## åƒè€ƒè³‡æº

### æ›¸ç±

- ã€ŠSystems Performance: Enterprise and the Cloudã€‹ - Brendan Gregg
- ã€ŠThe Art of Multiprocessor Programmingã€‹ - Maurice Herlihy

### å·¥å…·

- **perf**ï¼šLinux æ•ˆèƒ½åˆ†æå·¥å…·
- **valgrind/cachegrind**ï¼šCache åˆ†æ
- **FlameGraph**ï¼šç«ç„°åœ–ç”Ÿæˆå™¨
- **Intel VTune**ï¼šIntel CPU æ•ˆèƒ½åˆ†æ

### é–‹æºå°ˆæ¡ˆ

- **DPDK**ï¼šhttps://www.dpdk.org/
- **Folly**ï¼šFacebook çš„é«˜æ•ˆèƒ½ C++ å‡½å¼åº«
- **Seastar**ï¼šéåŒæ­¥ç¨‹å¼è¨­è¨ˆæ¡†æ¶

---

## é©—è­‰èˆ‡æ¸¬è©¦

### å¯¦è­‰é©—è­‰

æœ¬æŒ‡å—çš„æ ¸å¿ƒæŠ€è¡“å®£ç¨±å·²é€šéå¯¦è­‰ç¨‹å¼é©—è­‰:

- **é©—è­‰å·¥å…·**: latency-guide-validator
- **é©—è­‰ç¯„åœ**: RDTSC æ¸¬é‡, Lock-Free Queue, Memory Pool, Cache Alignment, Branch Prediction
- **æ¸¬è©¦æ–¹æ³•**: å¯¦ä½œå®Œæ•´è³‡æ–™çµæ§‹,æ¸¬é‡å¯¦éš›æ•ˆèƒ½,èˆ‡æŒ‡å—å®£ç¨±æ¯”è¼ƒ
- **é©—è­‰å ±å‘Š**: è©³è¦‹ `latency-guide-validator/tests/validation_report.md`

### é—œéµé©—è­‰çµæœ

âœ… **RDTSC æ¸¬é‡**: èªæ³•å’Œè½‰æ›å…¬å¼æ­£ç¢º
âœ… **Lock-Free Queue**: alignas(64) å¤šåŸ·è¡Œç·’åŠ é€Ÿ 50-70%
âœ… **Memory Pool**: æ¯” malloc å¿« 2.24å€,å¯é æ¸¬æ€§æ›´å¥½
âœ… **Cache Alignment**: é¿å… False Sharing åŠ é€Ÿ 4.34å€
âœ… **Branch Prediction**: èªæ³•æ­£ç¢º,ç¾ä»£ CPU æ•ˆæœæœ‰é™

### åŸ·è¡Œé©—è­‰æ¸¬è©¦

```bash
cd latency-guide-validator
make build  # ç·¨è­¯æ‰€æœ‰æ¸¬è©¦
make run    # åŸ·è¡Œå®Œæ•´é©—è­‰
```

---

**æ–‡ä»¶ç‰ˆæœ¬**ï¼š1.1 (å¯¦æ¸¬é©—è­‰ç‰ˆ)
**æœ€å¾Œæ›´æ–°**ï¼š2026-01-12
**ç¶­è­·è€…**ï¼šBuilding Low Latency Applications Team
**é©—è­‰è€…**ï¼šClaude Code Validator
