# é«˜é »/ä½å»¶é² Linux C/C++ å®Œæ•´é…ç½®æŒ‡å—

> **ç›®æ¨™**ï¼šç¡¬é«” + ç³»çµ± + ç¨‹å¼ç¢¼ = æ¥µè‡´ä½å»¶é²  
> **é©ç”¨**ï¼šHFTã€DPDKã€è¶…ä½å»¶é²äº¤æ˜“ç³»çµ±

---

## ğŸ¯ ä¸‰å±¤æ¶æ§‹ç¸½è¦½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ç¡¬é«”å±¤ï¼ˆHardwareï¼‰               â”‚
â”‚  - é«˜éšç¶²å¡ + BIOS è¨­å®š              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. ç³»çµ±å±¤ï¼ˆOS/Kernelï¼‰              â”‚
â”‚  - GRUB åƒæ•¸ + Runtime è¨­å®š          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. æ‡‰ç”¨å±¤ï¼ˆC/C++ Codeï¼‰             â”‚
â”‚  - DPDK + Lock-free + è¨˜æ†¶é«”ç®¡ç†     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1ï¸âƒ£ ç¡¬é«”å±¤é…ç½®

### BIOS è¨­å®šï¼ˆé–‹æ©Ÿå‰ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¿…é ˆé—œé–‰                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ Hyper-Threading (SMT)     â”‚
â”‚ âœ“ C-States (çœé›»æ¨¡å¼)        â”‚
â”‚ âœ“ P-States (å‹•æ…‹é »ç‡)        â”‚
â”‚ âœ“ Turbo Boost               â”‚
â”‚ âœ“ NUMA Node Interleaving    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¿…é ˆé–‹å•Ÿ                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ VT-d / IOMMU              â”‚
â”‚ âœ“ Performance Mode          â”‚
â”‚ âœ“ ACS (Access Control)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç¶²å¡è¦æ±‚

```
æ¨è–¦å‹è™Ÿï¼š
- Intel X710 / XL710
- Mellanox ConnectX-5/6

å¿…å‚™åŠŸèƒ½ï¼š
âœ“ SR-IOV
âœ“ Flow Director / Flow Steering
âœ“ RSS (Receive Side Scaling)
âœ“ 32+ RX/TX queues
âœ“ DPDK PMD æ”¯æ´
```

---

## 2ï¸âƒ£ ç³»çµ±å±¤é…ç½®

### A. GRUB å•Ÿå‹•åƒæ•¸

ç·¨è¼¯ `/etc/default/grub`ï¼š

```bash
GRUB_CMDLINE_LINUX="
  isolcpus=1-7
  nohz_full=1-7
  rcu_nocbs=1-7
  rcu_nocb_poll
  intel_pstate=disable
  intel_idle.max_cstate=0
  processor.max_cstate=0
  idle=poll
  nosoftlockup
  nmi_watchdog=0
  mce=off
  intel_iommu=on
  iommu=pt
  default_hugepagesz=1G
  hugepagesz=1G
  hugepages=8
  transparent_hugepage=never
"
```

æ›´æ–°ä¸¦é‡å•Ÿï¼š

```bash
sudo update-grub
sudo reboot
```

### B. ç³»çµ±æœå‹™ç®¡ç†

```bash
# é—œé–‰ä¸å¿…è¦æœå‹™
systemctl stop irqbalance
systemctl disable irqbalance
systemctl stop cpupower
systemctl mask systemd-journald.service

# é–å®š CPU é »ç‡
cpupower frequency-set -g performance
for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    echo performance > $cpu
done
```

### C. IRQ è¦ªå’Œæ€§è¨­å®šï¼ˆç¾ä»£æ›´æ–°ï¼‰

**é‡è¦è§€å¿µè½‰è®Š**ï¼šåœ¨ Kernel Bypass æ¨¡å¼ä¸‹ï¼Œä¸å†å¼·èª¿ã€ŒæŠŠ IRQ ç¶åˆ°å“ªå€‹ CPUã€ï¼Œè€Œæ˜¯å¼·èª¿ã€Œé¿é–‹ Polling CPUã€ã€‚

#### ç‚ºä»€éº¼ IRQ ç¶å®šè§€å¿µæ”¹è®Šäº†ï¼Ÿ

1. **è‡ªå‹•åŒ–**ï¼šé«˜éšç¶²å¡ï¼ˆå¦‚ Mellanox ConnectX-7+ï¼‰åœ¨ Bypass æ¨¡å¼ä¸‹æœƒè‡ªå‹•é—œé–‰ç¡¬é«”ä¸­æ–·
2. **é¿é–‹ç­–ç•¥**ï¼šé‡é»æ˜¯ã€Œç¢ºä¿ä¸­æ–·ä¸è¦å‡ºç¾åœ¨ Polling æ ¸å¿ƒä¸Šã€
3. **ç³»çµ±ä¸­æ–·è™•ç†**ï¼šå°‡æ‰€æœ‰ç³»çµ±ä¸­æ–·ï¼ˆç£ç¢Ÿã€è¨ˆæ™‚å™¨ï¼‰ç¶å®šåˆ°éäº¤æ˜“æ ¸å¿ƒï¼ˆé€šå¸¸æ˜¯ CPU 0ï¼‰

```bash
#!/bin/bash
# irq_binding.sh - å°‡æ‰€æœ‰ç³»çµ±ä¸­æ–·ç¶å®šåˆ° CPU 0

# ç­–ç•¥ï¼šè®“æ‰€æœ‰ä¸­æ–·éƒ½åœ¨ CPU 0 è™•ç†ï¼Œä¿è­· 1-7 è™Ÿæ ¸å¿ƒ
for irq in /proc/irq/*/smp_affinity; do
    # è·³é default_smp_affinity
    if [[ $irq == *"default"* ]]; then
        continue
    fi

    # 0x01 = äºŒé€²ä½ 0001 = CPU 0
    echo 1 > $irq 2>/dev/null
done

# é©—è­‰ï¼šæ‰€æœ‰ä¸­æ–·æ‡‰è©²åªåœ¨ CPU 0 ä¸Šå¢é•·
watch -n 1 'cat /proc/interrupts | head -20'
```

#### NUMA æ‹“æ’²å°é½Šï¼ˆé—œéµï¼ï¼‰

```bash
# 1. æª¢æŸ¥ç¶²å¡åœ¨å“ªå€‹ NUMA Node
lspci -vvv -s 0000:03:00.0 | grep "NUMA node"
# è¼¸å‡ºç¯„ä¾‹ï¼šNUMA node: 0

# 2. æª¢æŸ¥ CPU æ‹“æ’²
lstopo-no-graphics --of txt
# æˆ–
numactl --hardware

# 3. ç¢ºä¿ä½ çš„ Polling ç¨‹å¼é‹è¡Œåœ¨åŒä¸€å€‹ NUMA Node
# ä¾‹å¦‚ç¶²å¡åœ¨ NUMA 0ï¼Œå‰‡ä½¿ç”¨ CPU 0-11 (å‡è¨­ 12 æ ¸/socket)
```

**é—œéµ**ï¼šè·¨ NUMA å­˜å–çš„å»¶é²æœƒæ¯€æ‰æ‰€æœ‰å„ªåŒ–æ•ˆæœï¼

### E. Kernel Bypass é—œéµæ¦‚å¿µ

#### ç‚ºä»€éº¼ IRQ ç¶å®šè®Šå°‘äº†ï¼Ÿ

```
å‚³çµ±è§€å¿µ (èˆŠ)           ç¾ä»£ Bypass æ¨¡å¼ (æ–°)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æŠŠ IRQ ç¶åˆ°ç‰¹å®š CPU    â†’ é¿é–‹ Polling CPUï¼Œé—œé–‰ä¸å¿…è¦çš„ä¸­æ–·
éœ€è¦æ‰‹å‹•èª¿æ•´ affinity  â†’ é«˜éšç¶²å¡è‡ªå‹•é—œé–‰ç¡¬é«”ä¸­æ–·
```

**æ ¸å¿ƒåŸå‰‡**ï¼šåœ¨ Kernel Bypass æ¨¡å¼ä¸‹ï¼Œé‡é»ä¸æ˜¯ã€ŒæŠŠä¸­æ–·ç¶åˆ°å“ªã€ï¼Œè€Œæ˜¯ã€Œç¢ºä¿ä¸­æ–·ä¸è¦å‡ºç¾åœ¨ Polling æ ¸å¿ƒä¸Šã€ã€‚

**ã€Œéœé»˜/é—œé–‰ä¸­æ–·ã€çš„æ„æ€**ï¼šç¶²å¡åœ¨ Bypass æ¨¡å¼ä¸‹ä¸æœƒç”¢ç”Ÿç¡¬é«”ä¸­æ–·é€šçŸ¥ CPUï¼Œå› ç‚ºæˆ‘å€‘ä½¿ç”¨ Busy Pollingï¼ˆä¸æ–·ä¸»å‹•è¼ªè©¢ï¼‰å–ä»£è¢«å‹•ç­‰å¾…ä¸­æ–·ã€‚

#### ç³»çµ±é…ç½®å››è¦ç´ 

**1. è»Ÿé«”å±¤ç´šï¼šæ¨æ£„ poll()**

```cpp
// âŒ ä¸è¦ä½¿ç”¨
struct pollfd fds[1];
poll(fds, 1, timeout);

// âœ… æ”¹ç”¨ DPDK
rte_eth_rx_burst(port, queue_id, bufs, BURST_SIZE);
```

**2. ä½œæ¥­ç³»çµ±å±¤ç´šï¼šæ ¸å¿ƒéš”é›¢**

```bash
# å¿…è¦æ“ä½œï¼šåœ¨ GRUB è¨­å®šä¸­åŠ å…¥
isolcpus=X,Y        # é˜²æ­¢æ’ç¨‹å™¨ä½¿ç”¨é€™äº›æ ¸å¿ƒ
nohz_full=X,Y       # é—œé–‰è©²æ ¸å¿ƒçš„ tick
```

**3. IRQ ç®¡ç†ï¼šç¶å®šåˆ°éäº¤æ˜“æ ¸å¿ƒ**

```bash
# å°‡æ‰€æœ‰ç³»çµ±ä¸­æ–·ç¶å®šåˆ° CPU 0ï¼ˆé Polling æ ¸å¿ƒï¼‰
for irq in /proc/irq/*/smp_affinity; do
    echo 1 > $irq 2>/dev/null
done
```

**4. ç¡¬é«”å°é½Šï¼šNUMA æ‹“æ’²**

```bash
# æª¢æŸ¥ç¶²å¡åœ¨å“ªå€‹ NUMA Node
lstopo-no-graphics --of txt

# æˆ–ä½¿ç”¨
lspci -vvv -s <PCI_ADDR> | grep "NUMA node"

# é—œéµï¼šPolling ç¨‹å¼å¿…é ˆé‹è¡Œåœ¨åŒä¸€å€‹ NUMA Node çš„ CPU ä¸Š
```

### D. DPDK ç’°å¢ƒæº–å‚™

```bash
#!/bin/bash
# dpdk_setup.sh

# 1. è¼‰å…¥ VFIO æ¨¡çµ„
modprobe vfio-pci
echo 1 > /sys/module/vfio/parameters/enable_unsafe_noiommu_mode

# 2. æŸ¥çœ‹ç¶²å¡ PCI ä½å€
lspci | grep Ethernet
# å‡è¨­è¼¸å‡ºï¼š0000:03:00.0 Ethernet controller: Intel Corporation

# 3. è§£ç¶åŸé©…å‹•
echo "0000:03:00.0" > /sys/bus/pci/drivers/i40e/unbind

# 4. ç¶å®šåˆ° vfio-pciï¼ˆIntel X710 çš„ vendor:device IDï¼‰
echo "8086 1572" > /sys/bus/pci/drivers/vfio-pci/new_id
echo "0000:03:00.0" > /sys/bus/pci/drivers/vfio-pci/bind

# 5. æ›è¼‰ Hugepages
mkdir -p /mnt/huge
mount -t hugetlbfs nodev /mnt/huge
echo 8 > /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages

# 6. é©—è­‰
cat /proc/meminfo | grep Huge
```

---

## 2.5 DPDK vs å‚³çµ±ç¶²è·¯ç·¨ç¨‹

### poll() vs recvfrom() - å‚³çµ± Socket çš„å…©éšæ®µæµç¨‹

åœ¨å‚³çµ± Linux ç¶²è·¯ç·¨ç¨‹ä¸­ï¼Œ`poll()` å’Œ `recvfrom()` æ˜¯**å…©å€‹ä¸åŒçš„ç³»çµ±å‘¼å«**ï¼Œå„å¸å…¶è·ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å‚³çµ± Socket å…©éšæ®µæµç¨‹                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  1. poll() / select() / epoll()            â”‚
â”‚     â””â”€ ç›£æ§ socket ç‹€æ…‹                     â”‚
â”‚     â””â”€ ç­‰å¾…ã€Œæœ‰è³‡æ–™å¯è®€ã€äº‹ä»¶                â”‚
â”‚     â””â”€ å¯åŒæ™‚ç›£æ§å¤šå€‹ socket                â”‚
â”‚     â””â”€ é˜»å¡æˆ–éé˜»å¡æ¨¡å¼                     â”‚
â”‚                                             â”‚
â”‚  2. recvfrom() / recv() / read()           â”‚
â”‚     â””â”€ å¯¦éš›æ¥æ”¶è³‡æ–™                         â”‚
â”‚     â””â”€ å¾ kernel buffer æ‹·è²åˆ° user buffer  â”‚
â”‚     â””â”€ ä¸€æ¬¡è™•ç†ä¸€å€‹ socket                  â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å‚³çµ±æ–¹å¼çš„å…¸å‹ç¨‹å¼ç¢¼

```c
#include <sys/socket.h>
#include <poll.h>

int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
bind(sockfd, ...);

struct pollfd fds[1];
fds[0].fd = sockfd;
fds[0].events = POLLIN;  // ç›£æ§ã€Œå¯è®€ã€äº‹ä»¶

while (1) {
    // éšæ®µ 1ï¼šç­‰å¾… socket æœ‰è³‡æ–™ï¼ˆå¯èƒ½é˜»å¡ï¼‰
    int ret = poll(fds, 1, 1000);  // timeout 1000ms

    if (ret > 0 && (fds[0].revents & POLLIN)) {
        // éšæ®µ 2ï¼šå¯¦éš›æ¥æ”¶è³‡æ–™
        char buffer[1500];
        struct sockaddr_in src_addr;
        socklen_t addrlen = sizeof(src_addr);

        ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                             (struct sockaddr*)&src_addr, &addrlen);

        if (n > 0) {
            process_data(buffer, n);
        }
    }
}
```

#### recvfrom() å¯ä»¥ä¸éœ€è¦ poll() å—ï¼Ÿ

**ç­”æ¡ˆï¼šå¯ä»¥ï¼** `poll()` ä¸æ˜¯å¿…é ˆçš„ï¼Œæœ‰å¤šç¨®ä½¿ç”¨æ–¹å¼ï¼š

**æ–¹å¼ 1ï¼šç´”é˜»å¡æ¨¡å¼ï¼ˆæœ€ç°¡å–®ï¼‰**

```c
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
bind(sockfd, ...);

while (1) {
    char buffer[1500];
    // ç›´æ¥å‘¼å« recvfromï¼Œæœƒä¸€ç›´ç­‰å¾…ç›´åˆ°æœ‰è³‡æ–™
    ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);

    if (n > 0) {
        process_data(buffer, n);
    }
}
```

- âœ… æœ€ç°¡å–®ï¼Œä¸éœ€è¦ poll
- âŒ æœƒä¸€ç›´é˜»å¡ï¼Œç„¡æ³•è¨­å®š timeout
- âŒ ç„¡æ³•è™•ç†å¤šå€‹ socket

**æ–¹å¼ 2ï¼šéé˜»å¡ + Busy Pollingï¼ˆæ¨¡ä»¿ DPDKï¼Œä½†æ•ˆç‡å·®ï¼‰**

```c
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
bind(sockfd, ...);

// è¨­å®šç‚ºéé˜»å¡æ¨¡å¼
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

while (1) {
    char buffer[1500];
    // âš ï¸ æ¯æ¬¡éƒ½æ˜¯ç³»çµ±å‘¼å«ï¼Œç«‹å³å›å‚³
    ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);

    if (n > 0) {
        // æœ‰å°åŒ…ï¼Œè™•ç†è³‡æ–™
        process_data(buffer, n);
    } else if (n < 0 && errno == EAGAIN) {
        // æ²’å°åŒ…ï¼Œä½†é¦¬ä¸Šåˆé€²å…¥ä¸‹ä¸€æ¬¡è¿´åœˆ
        // âš ï¸ æ¯æ¬¡è¿´åœˆéƒ½è¦é€² kernel æª¢æŸ¥æ˜¯å¦æœ‰å°åŒ…
        continue;
    }
}
```

**é‡é»ï¼šrecvfrom åœ¨éé˜»å¡æ¨¡å¼ä¸‹çš„è¡Œç‚º**

```
æ¯æ¬¡å‘¼å« recvfrom() éƒ½æœƒï¼š
  1. é€²å…¥ kernel space            (ç³»çµ±å‘¼å«é–‹éŠ·)
  2. æª¢æŸ¥ socket buffer æ˜¯å¦æœ‰è³‡æ–™
  3. å¦‚æœæœ‰è³‡æ–™ â†’ æ‹·è²åˆ° user bufferï¼Œè¿”å›è³‡æ–™é•·åº¦
  4. å¦‚æœæ²’è³‡æ–™ â†’ è¿”å› -1ï¼Œè¨­å®š errno = EAGAIN
  5. å›åˆ° user space              (ç³»çµ±å‘¼å«é–‹éŠ·)

å•é¡Œï¼šæ¯æ¬¡è¿´åœˆéƒ½è¦é€™æ¨£åšï¼Œå³ä½¿ 99% çš„æ™‚é–“æ²’è³‡æ–™ï¼
```

- âœ… ä¸æœƒé˜»å¡ï¼Œæœ‰è³‡æ–™ç«‹å³è™•ç†
- âŒ **ç˜‹ç‹‚ç³»çµ±å‘¼å«**ï¼Œæ¯æ¬¡è¿´åœˆéƒ½è¦é€² kernel æª¢æŸ¥
- âŒ CPU 100%ï¼Œä½†å¤§éƒ¨åˆ†æ™‚é–“æµªè²»åœ¨é€²å‡º kernel

**æ–¹å¼ 3ï¼špoll() + recvfrom()ï¼ˆæ¨è–¦ï¼‰**

```c
struct pollfd fds[1];
fds[0].fd = sockfd;
fds[0].events = POLLIN;

while (1) {
    // åªå‘¼å«ä¸€æ¬¡ poll ç­‰å¾…
    int ret = poll(fds, 1, 1000);

    if (ret > 0) {
        // ç¢ºå®šæœ‰è³‡æ–™æ‰å‘¼å« recvfrom
        ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
        process_data(buffer, n);
    }
}
```

- âœ… æœ‰è³‡æ–™æ™‚æ‰è®€å–ï¼Œæ¸›å°‘ç„¡æ•ˆç³»çµ±å‘¼å«
- âœ… å¯è¨­å®š timeout
- âœ… å¯åŒæ™‚ç›£æ§å¤šå€‹ socket

#### ç‚ºä»€éº¼éœ€è¦ poll()ï¼Ÿ

| å ´æ™¯ | ä¸ç”¨ poll çš„å•é¡Œ | ç”¨ poll çš„å¥½è™• |
|------|-----------------|---------------|
| å–®ä¸€ socket | `recvfrom()` æœƒä¸€ç›´é˜»å¡ | å¯è¨­å®š timeout |
| å¤šå€‹ socket | ä¸çŸ¥é“è©²è®€å“ªå€‹ï¼Œéœ€è¦é€ä¸€è¼ªè©¢ | ä¸€æ¬¡ç›£æ§å¤šå€‹ï¼ŒçŸ¥é“å“ªå€‹æœ‰è³‡æ–™ |
| éé˜»å¡æ¨¡å¼ | ç˜‹ç‹‚ç³»çµ±å‘¼å«æµªè²» CPU | åªåœ¨æœ‰è³‡æ–™æ™‚æ‰å‘¼å« recvfrom |

#### recvfrom() ç³»çµ±å‘¼å«è¡Œç‚ºè©³è§£

**é—œéµå•é¡Œï¼šrecvfrom è¦æ¯æ¬¡ç³»çµ±å‘¼å«çœ‹æ˜¯å¦æœ‰å°åŒ…å—ï¼Ÿ**

**ç­”æ¡ˆï¼šå–æ±ºæ–¼æ¨¡å¼ï¼**

| æ¨¡å¼ | è¡Œç‚º | ç³»çµ±å‘¼å«é »ç‡ | é©ç”¨å ´æ™¯ |
|------|------|-------------|---------|
| **é˜»å¡æ¨¡å¼** | å‘¼å«ä¸€æ¬¡ï¼Œç­‰åˆ°æœ‰è³‡æ–™æ‰è¿”å› | æœ‰è³‡æ–™æ™‚æ‰è¿”å› | ç°¡å–®æ‡‰ç”¨ |
| **éé˜»å¡æ¨¡å¼** | æ¯æ¬¡å‘¼å«ç«‹å³è¿”å› | **æ¯æ¬¡è¿´åœˆéƒ½è¦ç³»çµ±å‘¼å«** | Busy polling (æ•ˆç‡å·®) |
| **poll + recvfrom** | poll ç­‰å¾…ï¼Œç¢ºå®šæœ‰è³‡æ–™æ‰ recvfrom | æœ‰è³‡æ–™æ™‚æ‰ recvfrom | æ¨è–¦ |

**è©³ç´°è¡Œç‚ºå°æ¯”ï¼š**

```
é˜»å¡æ¨¡å¼ï¼š
  recvfrom(sockfd, ...);  â† å‘¼å«ä¸€æ¬¡
  â†“
  â¸ï¸ åœ¨ kernel å…§ç­‰å¾…ï¼ˆç¨‹å¼æš«åœï¼‰
  â†“
  ğŸ“¦ æœ‰å°åŒ…åˆ°é”
  â†“
  âœ… æ‹·è²è³‡æ–™ï¼Œè¿”å›
  â†“
  è™•ç†è³‡æ–™
  â†“
  recvfrom(sockfd, ...);  â† å†æ¬¡å‘¼å«ï¼Œåˆæœƒç­‰å¾…

  ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼šç­‰æ–¼å°åŒ…æ•¸é‡ï¼ˆæœ€å°‘ï¼‰

éé˜»å¡æ¨¡å¼ï¼ˆBusy Pollingï¼‰ï¼š
  while (1) {
    recvfrom(sockfd, ...);  â† æ¯æ¬¡è¿´åœˆéƒ½ç³»çµ±å‘¼å«
    â†“
    ç«‹å³æª¢æŸ¥ socket buffer
    â†“
    æ²’è³‡æ–™ï¼Ÿè¿”å› EAGAIN
    â†“
    recvfrom(sockfd, ...);  â† åˆæ˜¯ç³»çµ±å‘¼å«
    â†“
    æ²’è³‡æ–™ï¼Ÿè¿”å› EAGAIN
    â†“
    recvfrom(sockfd, ...);  â† åˆæ˜¯ç³»çµ±å‘¼å«
    ...ï¼ˆå¯èƒ½é‡è¤‡æ•¸ç™¾è¬æ¬¡ï¼‰
    â†“
    ğŸ“¦ æœ‰å°åŒ…åˆ°é”
    â†“
    æ‹·è²è³‡æ–™ï¼Œè¿”å›
  }

  ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼šå¯èƒ½æ•¸ç™¾è¬æ¬¡/ç§’ï¼ˆæ¥µå¤šï¼ï¼‰

poll + recvfromï¼š
  while (1) {
    poll(fds, ...);         â† ç³»çµ±å‘¼å«ï¼Œç­‰å¾…äº‹ä»¶
    â†“
    â¸ï¸ åœ¨ kernel å…§ç­‰å¾…
    â†“
    ğŸ“¦ æœ‰å°åŒ…åˆ°é”
    â†“
    âœ… è¿”å›ã€Œæœ‰è³‡æ–™å¯è®€ã€
    â†“
    recvfrom(sockfd, ...);  â† ç¢ºå®šæœ‰è³‡æ–™æ‰ç³»çµ±å‘¼å«
    â†“
    æ‹·è²è³‡æ–™ï¼Œè¿”å›
  }

  ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼šç´„ 2 Ã— å°åŒ…æ•¸é‡ï¼ˆé©ä¸­ï¼‰
```

**é—œéµå·®ç•°ç¸½çµï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éé˜»å¡ recvfrom busy polling ç‚ºä»€éº¼é€™éº¼å·®ï¼Ÿ         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  while (1) {                                        â”‚
â”‚    recvfrom(...)  â† ç³»çµ±å‘¼å« 1                      â”‚
â”‚    recvfrom(...)  â† ç³»çµ±å‘¼å« 2                      â”‚
â”‚    recvfrom(...)  â† ç³»çµ±å‘¼å« 3                      â”‚
â”‚    ...                                              â”‚
â”‚    recvfrom(...)  â† ç³»çµ±å‘¼å« 1000000                â”‚
â”‚  }                                                  â”‚
â”‚                                                     â”‚
â”‚  æ¯æ¬¡éƒ½è¦ï¼š                                         â”‚
â”‚  1. user â†’ kernel åˆ‡æ›     (50-100 cycles)          â”‚
â”‚  2. æª¢æŸ¥ socket buffer     (20-50 cycles)           â”‚
â”‚  3. kernel â†’ user åˆ‡æ›     (50-100 cycles)          â”‚
â”‚                                                     â”‚
â”‚  å³ä½¿æ²’å°åŒ…ï¼Œä¹Ÿè¦é€™æ¨£åšï¼                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### å°æ¯”ï¼šä¸‰ç¨®æ–¹å¼ vs DPDK

```
æ–¹å¼ 1ï¼ˆé˜»å¡ recvfromï¼‰:
  while (1) {
    recvfrom(...);  // é˜»å¡ç­‰å¾…ï¼Œç°¡å–®ä½†ä¸éˆæ´»
  }

æ–¹å¼ 2ï¼ˆéé˜»å¡ recvfrom busy pollingï¼‰:
  while (1) {
    recvfrom(...);  // ç˜‹ç‹‚ç³»çµ±å‘¼å«ï¼ŒCPU 100%
  }
  âŒ æƒ³æ¨¡ä»¿ DPDK ä½†æ•ˆç‡æ¥µå·®

æ–¹å¼ 3ï¼ˆpoll + recvfromï¼‰:
  while (1) {
    poll(...);      // ç­‰å¾…äº‹ä»¶
    recvfrom(...);  // æœ‰è³‡æ–™æ‰è®€
  }
  âœ… æ¨è–¦çš„å‚³çµ±æ–¹å¼

DPDKï¼ˆçœŸæ­£çš„ busy pollingï¼‰:
  while (1) {
    rte_eth_rx_burst(...);  // ç›´æ¥è®€è¨˜æ†¶é«”ï¼Œé›¶ç³»çµ±å‘¼å«
  }
  âœ… CPU 100% ä½†å…¨åœ¨ user space
```

---

#### ğŸ’¡ æ·±å…¥åˆ†æï¼šç‚ºä»€éº¼æ–¹å¼ 2 æ•ˆç‡é€™éº¼å·®ï¼Ÿ

é›–ç„¶æ–¹å¼ 2ï¼ˆéé˜»å¡ recvfrom busy pollingï¼‰å’Œ DPDK éƒ½æ˜¯ busy pollingï¼Œä½†**æ•ˆç‡å·®ç•°é«˜é” 1000 å€ï¼**

**éé˜»å¡ recvfrom busy polling çš„é–‹éŠ·ï¼š**

```
æ¯æ¬¡è¿´åœˆéƒ½è¦ï¼š
  1. åˆ‡æ›åˆ° kernel mode      (50-100 cycles)
  2. æª¢æŸ¥ socket buffer       (20-50 cycles)
  3. æ‹·è²è³‡æ–™ï¼ˆå¦‚æœæœ‰ï¼‰       (ä¾è³‡æ–™å¤§å°ï¼Œ1500 bytes â‰ˆ 300 cycles)
  4. åˆ‡æ›å› user mode         (50-100 cycles)

æ²’è³‡æ–™æ™‚ï¼šæµªè²» 100-200 cycles
æœ‰è³‡æ–™æ™‚ï¼šé‚„è¦åŠ ä¸Šæ‹·è²é–‹éŠ· 300+ cycles
ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼šæ¯æ¬¡è¿´åœˆéƒ½å‘¼å«ï¼ˆå¯èƒ½æ•¸ç™¾è¬æ¬¡/ç§’ï¼‰
```

**DPDK busy polling çš„é–‹éŠ·ï¼š**

```
æ¯æ¬¡è¿´åœˆï¼š
  1. ç›´æ¥è®€è¨˜æ†¶é«”              (10-20 cycles)
  2. è³‡æ–™å·²ç¶“åœ¨é‚£è£¡ï¼ˆé›¶æ‹·è²ï¼‰  (0 cycles)

æ²’è³‡æ–™æ™‚ï¼šåªæµªè²» 10-20 cycles
æœ‰è³‡æ–™æ™‚ï¼šè³‡æ–™å·²ç¶“åœ¨ user spaceï¼Œä¸éœ€æ‹·è²
ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼š0
```

**æ•ˆç‡å°æ¯”ç¸½çµï¼š**

| é …ç›® | æ–¹å¼ 2 (éé˜»å¡ recvfrom) | DPDK (rx_burst) | å·®ç•° |
|------|------------------------|----------------|------|
| **æ¯æ¬¡è¿´åœˆé–‹éŠ·** | 100-200 cycles | 10-20 cycles | **10-20å€** |
| **ç³»çµ±å‘¼å«** | æ¯æ¬¡éƒ½è¦ | é›¶æ¬¡ | **âˆ** |
| **è³‡æ–™æ‹·è²** | éœ€è¦ï¼ˆ300+ cyclesï¼‰ | ä¸éœ€è¦ï¼ˆ0 cyclesï¼‰ | **âˆ** |
| **Context Switch** | æ¯æ¬¡ 2 æ¬¡ | é›¶æ¬¡ | **âˆ** |
| **ç¸½é«”æ•ˆç‡** | æ¥µå·® | æ¥µä½³ | **1000-3000å€** |

**é—œéµçµè«–ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åŒæ¨£æ˜¯ CPU 100% çš„ Busy Polling                      â”‚
â”‚                                                      â”‚
â”‚  æ–¹å¼ 2ï¼šCPU æ™‚é–“æµªè²»åœ¨é€²å‡º kernel                    â”‚
â”‚          âŒ æ¯æ¬¡è¿´åœˆï¼škernel â†” user åˆ‡æ›é–‹éŠ·          â”‚
â”‚          âŒ å¤§é‡ç„¡æ•ˆç³»çµ±å‘¼å«                          â”‚
â”‚                                                      â”‚
â”‚  DPDKï¼š  CPU æ™‚é–“ç”¨åœ¨è™•ç†å°åŒ…                         â”‚
â”‚          âœ… å®Œå…¨åœ¨ user space                        â”‚
â”‚          âœ… é›¶ç³»çµ±å‘¼å«ï¼Œé›¶æ‹·è²                        â”‚
â”‚                                                      â”‚
â”‚  çµè«–ï¼šå³ä½¿éƒ½æ˜¯ busy pollingï¼ŒDPDK å¿« 1000 å€ï¼       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å¯¦æ¸¬æ•¸æ“šç¤ºä¾‹ï¼š**

```
æ¸¬è©¦ç’°å¢ƒï¼šIntel Xeon E5-2680 v4 @ 2.4GHz
å°åŒ…å¤§å°ï¼š64 bytes (æœ€å° UDP å°åŒ…)
æ¸¬è©¦æ™‚é–“ï¼š10 ç§’

æ–¹å¼ 2 (éé˜»å¡ recvfrom busy polling):
  - å°åŒ…è™•ç†é€Ÿåº¦ï¼š~100,000 pps
  - CPU ä½¿ç”¨ç‡ï¼š100%
  - ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼š~10,000,000 æ¬¡/ç§’
  - å¹³å‡å»¶é²ï¼š~10 Î¼s

DPDK (rx_burst):
  - å°åŒ…è™•ç†é€Ÿåº¦ï¼š~14,000,000 pps (ç·šé€Ÿ)
  - CPU ä½¿ç”¨ç‡ï¼š100%
  - ç³»çµ±å‘¼å«æ¬¡æ•¸ï¼š0
  - å¹³å‡å»¶é²ï¼š~0.5 Î¼s

æ•ˆç‡æå‡ï¼š140x (å°åŒ…è™•ç†é€Ÿåº¦)
å»¶é²é™ä½ï¼š20x
```

> **é‡é»**ï¼šé€™å°±æ˜¯ç‚ºä»€éº¼**å³ä½¿éƒ½æ˜¯ busy pollingï¼ŒDPDK é‚„æ˜¯å¿«å¾—å¤š**ï¼ä¸æ˜¯æ¦‚å¿µçš„å·®ç•°ï¼Œè€Œæ˜¯å¯¦ä½œå±¤ç´šçš„æ ¹æœ¬å·®ç•°ã€‚

---

#### æ ¸å¿ƒå·®ç•°ä¸€è¦½

**æ˜¯çš„ï¼Œpoll() å’Œ recvfrom() å®Œå…¨ä¸ä¸€æ¨£ï¼**

```
poll()              recvfrom()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç›£æ§éšæ®µ             å¯¦éš›è®€å–éšæ®µ
ç­‰å¾…äº‹ä»¶é€šçŸ¥         æ‹·è²è³‡æ–™
å¯ç›£æ§å¤šå€‹ socket    ä¸€æ¬¡è™•ç†ä¸€å€‹
è¿”å›ã€Œå°±ç·’ç‹€æ…‹ã€     è¿”å›ã€Œå¯¦éš›è³‡æ–™ã€
```

**å‚³çµ±æµç¨‹ï¼ˆå…©éšæ®µï¼‰**

```c
// ç¬¬ 1 æ­¥ï¼šå• kernelã€Œæœ‰è³‡æ–™å—?ã€
poll(fds, 1, timeout);

// ç¬¬ 2 æ­¥ï¼šã€Œæœ‰ï¼é‚£æˆ‘ä¾†æ‹¿ã€
recvfrom(sockfd, buffer, ...);
```

**DPDK æµç¨‹ï¼ˆå–®ä¸€æ­¥é©Ÿï¼‰**

```cpp
// ä¸€æ­¥åˆ°ä½ï¼šç›´æ¥å¾ç¶²å¡è¨˜æ†¶é«”æ‹¿è³‡æ–™
rte_eth_rx_burst(port_id, 0, bufs, BURST_SIZE);
```

**ç‚ºä»€éº¼ DPDK åªéœ€è¦ä¸€æ­¥ï¼Ÿ**

1. **ä¸éœ€è¦ poll()** - å› ç‚ºæˆ‘å€‘ä¸ä¾è³´ kernel é€šçŸ¥ï¼Œç›´æ¥è‡ªå·±å»ç¶²å¡è¨˜æ†¶é«”çœ‹æœ‰æ²’æœ‰è³‡æ–™
2. **ä¸éœ€è¦ recvfrom()** - å› ç‚ºè³‡æ–™å·²ç¶“åœ¨æˆ‘å€‘çš„è¨˜æ†¶é«”è£¡ï¼ˆDMA ç›´æ¥å¯«å…¥ï¼‰ï¼Œä¸éœ€è¦å¾ kernel buffer æ‹·è²

**æ•ˆèƒ½å·®ç•°**

```
å‚³çµ±æ–¹å¼ï¼ˆæ¯å€‹å°åŒ…ï¼‰:
poll() ç³»çµ±å‘¼å« (1ms)
  â†’ kernel æª¢æŸ¥ socket
  â†’ ç­‰å¾…ä¸­æ–·
  â†’ å›å‚³ã€Œæœ‰è³‡æ–™ã€
recvfrom() ç³»çµ±å‘¼å« (0.5ms)
  â†’ kernel æ‹·è²è³‡æ–™
  â†’ å›å‚³è³‡æ–™
ç¸½è¨ˆï¼š~1.5ms

DPDK æ–¹å¼ï¼ˆæ‰¹æ¬¡ 32 å€‹å°åŒ…ï¼‰:
rte_eth_rx_burst() (0.5Î¼s)
  â†’ ç›´æ¥è®€è¨˜æ†¶é«”
  â†’ æ‹¿åˆ° 32 å€‹å°åŒ…
ç¸½è¨ˆï¼š~0.5Î¼s (å¿« 3000 å€!)
```

> **é‡é»**ï¼šé€™å°±æ˜¯ç‚ºä»€éº¼åœ¨ã€ŒE. Kernel Bypass é—œéµæ¦‚å¿µã€ç« ç¯€ä¸­ï¼Œç¬¬ä¸€æ¢å°±æ˜¯ã€Œ**æ¨æ£„ poll()**ã€- å› ç‚ºåœ¨ Bypass æ¨¡å¼ä¸‹ï¼Œæˆ‘å€‘å®Œå…¨è·³éäº† kernel çš„äº‹ä»¶é€šçŸ¥æ©Ÿåˆ¶ï¼

---

#### DPDK çš„å·®ç•°ï¼šå–®ä¸€æ­¥é©Ÿ

```cpp
// DPDK æ–¹å¼ï¼šæ²’æœ‰å…©éšæ®µï¼Œç›´æ¥å–è³‡æ–™
while (1) {
    struct rte_mbuf *bufs[BURST_SIZE];

    // ä¸€æ­¥åˆ°ä½ï¼šæª¢æŸ¥ + å–è³‡æ–™
    uint16_t nb_rx = rte_eth_rx_burst(port_id, 0, bufs, BURST_SIZE);

    // nb_rx å¯èƒ½æ˜¯ 0ï¼ˆæ²’è³‡æ–™ï¼‰æˆ– 1-32ï¼ˆæœ‰è³‡æ–™ï¼‰
    for (uint16_t i = 0; i < nb_rx; i++) {
        process_packet(bufs[i]);
        rte_pktmbuf_free(bufs[i]);
    }

    // æ²’è³‡æ–™ä¹Ÿä¸ç¡çœ ï¼ˆbusy pollingï¼‰
    if (nb_rx == 0) {
        rte_pause();  // åªæ˜¯ CPU pause æŒ‡ä»¤
    }
}
```

#### é—œéµå·®ç•°ç¸½çµ

| å±¤é¢ | å‚³çµ± Socket | DPDK |
|------|------------|------|
| **æ­¥é©Ÿ** | å…©éšæ®µï¼ˆpoll â†’ recvfromï¼‰ | å–®ä¸€æ­¥é©Ÿï¼ˆrx_burstï¼‰ |
| **ç³»çµ±å‘¼å«** | æ¯è¼ªè‡³å°‘ 1 æ¬¡ï¼ˆpollï¼‰+ æœ‰è³‡æ–™æ™‚å¤š 1 æ¬¡ï¼ˆrecvfromï¼‰ | 0 æ¬¡ï¼ˆå®Œå…¨åœ¨ user spaceï¼‰ |
| **ç­‰å¾…æ©Ÿåˆ¶** | poll é˜»å¡ç­‰å¾… kernel é€šçŸ¥ | busy polling ä¸»å‹•è¼ªè©¢ |
| **è³‡æ–™æ‹·è²** | kernel buffer â†’ user buffer | é›¶æ‹·è²ï¼ˆDMA ç›´é”ï¼‰ |
| **æ‰¹æ¬¡è™•ç†** | æ¯æ¬¡ 1 å€‹å°åŒ… | æ¯æ¬¡æœ€å¤š 32 å€‹å°åŒ… |

---

### æ ¸å¿ƒå·®ç•°å°ç…§è¡¨

| ç‰¹æ€§ | å‚³çµ± recvfrom | DPDK rte_eth_rx_burst |
|------|---------------|----------------------|
| **è³‡æ–™è·¯å¾‘** | ç¶²å¡ â†’ æ ¸å¿ƒç·©è¡å€ â†’ æ‹·è² â†’ ç”¨æˆ¶ç©ºé–“ | ç¶²å¡ â†’ ç›´æ¥å¯«å…¥ç”¨æˆ¶ç©ºé–“è¨˜æ†¶é«” (Zero-copy) |
| **è™•ç†å–®ä½** | å–®å€‹å°åŒ… (Single Packet) | ä¸€æ‰¹å°åŒ… (Batch/Burst) |
| **é˜»å¡ç‰¹æ€§** | å¯é˜»å¡ (Blocking) æˆ–éé˜»å¡ | æ°¸é ä¸é˜»å¡ï¼ˆç«‹å³å›å‚³ç›®å‰æŠ“åˆ°çš„å°åŒ…æ•¸ï¼‰ |
| **å”è­°æ£§** | è‡ªå‹•è™•ç† TCP/IPï¼ˆç”± Linux Kernel è™•ç†ï¼‰ | è£¸å°åŒ… (Raw Packet)ï¼Œéœ€è‡ªå·±è§£æ Ethernet/IP/UDP æ¨™é ­ |
| **ç³»çµ±å‘¼å«** | æ¯æ¬¡éƒ½é€²å…¥ kernel space | å®Œå…¨åœ¨ user spaceï¼ˆé›¶ç³»çµ±å‘¼å«ï¼‰ |
| **ä¸­æ–·è™•ç†** | ä¾è³´ç¡¬é«”ä¸­æ–·å–šé†’ç¨‹å¼ | Busy Pollingï¼Œä¸ä¾è³´ä¸­æ–· |

### ç¨‹å¼ç¢¼å°æ¯”

#### å‚³çµ± Socket æ–¹å¼

```cpp
// å‚³çµ±æ–¹å¼ï¼šæ¯æ¬¡è™•ç†ä¸€å€‹å°åŒ…ï¼Œæœ‰ç³»çµ±å‘¼å«é–‹éŠ·
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
bind(sockfd, ...);

while (1) {
    char buffer[1500];
    struct sockaddr_in src_addr;
    socklen_t addrlen = sizeof(src_addr);

    // é˜»å¡ç­‰å¾…æˆ–è¼ªè©¢ï¼ˆæœ‰ kernel overheadï¼‰
    ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                         (struct sockaddr*)&src_addr, &addrlen);

    if (n > 0) {
        // è³‡æ–™å·²ç¶“è¢« kernel è§£æéï¼ˆTCP/IP stackï¼‰
        process_data(buffer, n);
    }
}
```

#### DPDK æ–¹å¼

```cpp
// DPDK æ–¹å¼ï¼šæ‰¹æ¬¡è™•ç†ï¼Œé›¶ç³»çµ±å‘¼å«ï¼Œé›¶æ‹·è²
uint16_t port_id = 0;
uint16_t queue_id = 0;

while (1) {
    struct rte_mbuf *bufs[BURST_SIZE];

    // éé˜»å¡ï¼šç«‹å³å›å‚³ï¼ˆç›®å‰æŠ“åˆ°å¹¾å€‹å°±å›å‚³å¹¾å€‹ï¼‰
    uint16_t nb_rx = rte_eth_rx_burst(port_id, queue_id,
                                       bufs, BURST_SIZE);

    // æ‰¹æ¬¡è™•ç†
    for (uint16_t i = 0; i < nb_rx; i++) {
        // è£¸å°åŒ…ï¼šéœ€è¦è‡ªå·±è§£æ Ethernet/IP/UDP header
        uint8_t *pkt = rte_pktmbuf_mtod(bufs[i], uint8_t*);

        struct rte_ether_hdr *eth = (struct rte_ether_hdr *)pkt;
        struct rte_ipv4_hdr *ip = (struct rte_ipv4_hdr *)(eth + 1);
        struct rte_udp_hdr *udp = (struct rte_udp_hdr *)(ip + 1);

        uint8_t *payload = (uint8_t *)(udp + 1);

        // è™•ç†æ¥­å‹™é‚è¼¯
        process_packet(payload);

        // é‡‹æ”¾æˆ–è½‰ç™¼
        rte_pktmbuf_free(bufs[i]);
    }

    // å³ä½¿ nb_rx == 0 ä¹Ÿä¸ç¡çœ ï¼ˆbusy pollingï¼‰
    if (unlikely(nb_rx == 0)) {
        rte_pause();  // CPU pause æŒ‡ä»¤
    }
}
```

### é‡è¦è§€å¿µ

#### 1. Batch è™•ç†å„ªå‹¢

```
å‚³çµ± Socket (N æ¬¡ç³»çµ±å‘¼å«)
recvfrom() â†’ è™•ç† â†’ recvfrom() â†’ è™•ç† â†’ ...
æ¯æ¬¡éƒ½é€² kernel

DPDK Burst (1 æ¬¡ DMA æ“ä½œå–å¾—å¤šå€‹å°åŒ…)
rte_eth_rx_burst() â†’ å–å¾— 32 å€‹å°åŒ… â†’ å…¨éƒ¨è™•ç†
å®Œå…¨åœ¨ user space
```

#### 2. é›¶æ‹·è²åŸç†

```
å‚³çµ±ï¼š
ç¶²å¡ DMA â†’ Kernel Buffer â†’ memcpy â†’ User Buffer
          â†‘ æ‹·è²é–‹éŠ·

DPDKï¼š
ç¶²å¡ DMA â†’ User Space Mbuf Pool (é€é IOMMU)
          â†‘ ç›´æ¥å¯«å…¥
```

#### 3. ç‚ºä»€éº¼éœ€è¦è‡ªå·±è§£æå”è­°ï¼Ÿ

```cpp
// Kernel å¹«ä½ åšçš„äº‹ï¼ˆå‚³çµ± Socketï¼‰
- Ethernet è§£å°è£
- IP checksum é©—è­‰
- UDP/TCP è§£æ
- Socket buffer ç®¡ç†

// DPDK ä½ è¦è‡ªå·±åš
uint8_t *pkt = rte_pktmbuf_mtod(mbuf, uint8_t*);

// æ‰‹å‹•è§£ææ¯ä¸€å±¤
struct rte_ether_hdr *eth = (struct rte_ether_hdr *)pkt;
struct rte_ipv4_hdr *ip = (struct rte_ipv4_hdr *)(eth + 1);
struct rte_udp_hdr *udp = (struct rte_udp_hdr *)(ip + 1);
void *payload = (void *)(udp + 1);
```

**ä»£åƒ¹**ï¼šè¤‡é›œåº¦ â†‘
**å¥½è™•**ï¼šå»¶é² â†“ (é€šå¸¸é™ä½ 10-100x)

---

## 2.5.1 æ²’æœ‰ DPDK çš„é«˜é »ä½å»¶é²æœ€ä½³æ–¹æ¡ˆ

### å¯¦éš›å ´æ™¯ï¼šç„¡æ³•ä½¿ç”¨ Kernel Bypass æ™‚æ€éº¼è¾¦ï¼Ÿ

åœ¨å¾ˆå¤šæƒ…æ³ä¸‹ç„¡æ³•ä½¿ç”¨ DPDKï¼š
- å…±äº«ä¼ºæœå™¨ç’°å¢ƒï¼ˆä¸èƒ½ç¨ä½”ç¶²å¡ï¼‰
- éœ€è¦ä½¿ç”¨æ¨™æº– TCP/IP å”è­°æ£§
- å®‰å…¨æ€§è€ƒé‡ï¼ˆä¸æƒ³ bypass kernelï¼‰
- é ç®—é™åˆ¶ï¼ˆç„¡æ³•è³¼è²·é«˜éšç¶²å¡ï¼‰

**é€™æ™‚å€™ï¼Œå‚³çµ± Socket ç·¨ç¨‹çš„æœ€ä½³æ–¹æ¡ˆæ˜¯ä»€éº¼ï¼Ÿ**

### â­ æ¨è–¦æ–¹æ¡ˆï¼šepoll (Edge-Triggered) + å„ªåŒ–æŠ€å·§

#### æ–¹æ¡ˆæ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æœ€ä½³å‚³çµ±æ–¹æ¡ˆï¼ˆç„¡ DPDKï¼‰                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  1. epoll (edge-triggered mode)            â”‚
â”‚     âœ“ æ¯” poll/select å¿«å¾ˆå¤š                 â”‚
â”‚     âœ“ O(1) è¤‡é›œåº¦                           â”‚
â”‚     âœ“ åªé€šçŸ¥æœ‰è®ŠåŒ–çš„ socket                 â”‚
â”‚                                             â”‚
â”‚  2. SO_BUSY_POLL socket é¸é …                â”‚
â”‚     âœ“ Kernel å…§çš„ busy poll                 â”‚
â”‚     âœ“ æ¸›å°‘ä¸­æ–·å»¶é²                          â”‚
â”‚                                             â”‚
â”‚  3. CPU Affinity + IRQ ç¶å®š                 â”‚
â”‚     âœ“ æ¸›å°‘ cache miss                       â”‚
â”‚     âœ“ é™ä½ context switch                   â”‚
â”‚                                             â”‚
â”‚  4. Batch è™•ç†                              â”‚
â”‚     âœ“ epoll_wait ä¸€æ¬¡å–å¤šå€‹äº‹ä»¶             â”‚
â”‚     âœ“ recvmmsg ä¸€æ¬¡è®€å¤šå€‹å°åŒ…               â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œç¯„ä¾‹ï¼šæœ€ä½³åŒ–çš„å‚³çµ±æ–¹æ¡ˆ

```c
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <sys/socket.h>
#include <sched.h>
#include <pthread.h>

#define MAX_EVENTS 32
#define BATCH_SIZE 32

// 1. è¨­å®š socket é¸é …
int setup_optimized_socket(int sockfd) {
    // è¨­å®šç‚ºéé˜»å¡
    int flags = fcntl(sockfd, F_GETFL, 0);
    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

    // å•Ÿç”¨ SO_BUSY_POLLï¼ˆkernel å…§çš„ busy pollï¼‰
    int busy_poll_us = 50;  // 50 å¾®ç§’
    setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL,
               &busy_poll_us, sizeof(busy_poll_us));

    // è¨­å®šæ¥æ”¶ç·©è¡å€å¤§å°
    int rcvbuf = 4 * 1024 * 1024;  // 4MB
    setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF,
               &rcvbuf, sizeof(rcvbuf));

    // å•Ÿç”¨ SO_REUSEPORTï¼ˆå¤šåŸ·è¡Œç·’è² è¼‰å‡è¡¡ï¼‰
    int reuse = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT,
               &reuse, sizeof(reuse));

    return 0;
}

// 2. ç¶å®šåˆ°ç‰¹å®š CPU
void bind_to_cpu(int cpu_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu_id, &cpuset);
    pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
}

// 3. ä½¿ç”¨ epoll edge-triggered æ¨¡å¼
int main() {
    // ç¶å®šåˆ°ç‰¹å®š CPU
    bind_to_cpu(2);

    // å»ºç«‹ socket
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    bind(sockfd, ...);
    setup_optimized_socket(sockfd);

    // å»ºç«‹ epoll
    int epfd = epoll_create1(0);

    // åŠ å…¥ socketï¼ˆEdge-Triggered æ¨¡å¼ï¼‰
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET;  // â† Edge-Triggered
    ev.data.fd = sockfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);

    // æº–å‚™æ¥æ”¶ç·©è¡å€
    struct mmsghdr msgs[BATCH_SIZE];
    struct iovec iovecs[BATCH_SIZE];
    char buffers[BATCH_SIZE][2048];

    for (int i = 0; i < BATCH_SIZE; i++) {
        iovecs[i].iov_base = buffers[i];
        iovecs[i].iov_len = sizeof(buffers[i]);
        msgs[i].msg_hdr.msg_iov = &iovecs[i];
        msgs[i].msg_hdr.msg_iovlen = 1;
        msgs[i].msg_hdr.msg_name = NULL;
        msgs[i].msg_hdr.msg_namelen = 0;
    }

    // ä¸»è¿´åœˆ
    struct epoll_event events[MAX_EVENTS];

    while (1) {
        // ç­‰å¾…äº‹ä»¶ï¼ˆå¯è¨­ timeout = 0 åš busy pollï¼‰
        int nfds = epoll_wait(epfd, events, MAX_EVENTS, 0);  // 0 = éé˜»å¡

        for (int i = 0; i < nfds; i++) {
            if (events[i].events & EPOLLIN) {
                // Edge-triggeredï¼šéœ€è¦è®€å–æ‰€æœ‰å¯ç”¨è³‡æ–™
                while (1) {
                    // ä½¿ç”¨ recvmmsg æ‰¹æ¬¡æ¥æ”¶
                    int nr = recvmmsg(sockfd, msgs, BATCH_SIZE,
                                     MSG_DONTWAIT, NULL);

                    if (nr <= 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            break;  // æ²’è³‡æ–™äº†
                        }
                        // è™•ç†éŒ¯èª¤
                        break;
                    }

                    // æ‰¹æ¬¡è™•ç†å°åŒ…
                    for (int j = 0; j < nr; j++) {
                        process_packet(buffers[j], msgs[j].msg_len);
                    }
                }
            }
        }

        // å³ä½¿æ²’äº‹ä»¶ä¹Ÿæœƒç«‹å³å›åˆ°è¿´åœˆï¼ˆbusy pollï¼‰
    }

    return 0;
}
```

### é—œéµå„ªåŒ–æŠ€å·§

#### 1. ä½¿ç”¨ epoll è€Œé poll/select

| æ–¹æ¡ˆ | æ™‚é–“è¤‡é›œåº¦ | æœ€å¤§ fd æ•¸ | æ¨è–¦åº¦ |
|------|-----------|-----------|--------|
| select() | O(n) | 1024 | âŒ ä¸æ¨è–¦ |
| poll() | O(n) | ç„¡é™åˆ¶ | â–³ æ™®é€š |
| epoll() | O(1) | ç„¡é™åˆ¶ | âœ… æ¨è–¦ |

**epoll å„ªå‹¢ï¼š**
- ä¸éœ€è¦æ¯æ¬¡å‚³éæ•´å€‹ fd åˆ—è¡¨
- åªè¿”å›æœ‰äº‹ä»¶çš„ fd
- Edge-triggered æ¨¡å¼æ›´é«˜æ•ˆ

#### 2. SO_BUSY_POLL - Kernel å…§çš„ Busy Poll

```c
// Kernel æœƒåœ¨æŒ‡å®šæ™‚é–“å…§ busy pollï¼Œæ¸›å°‘ä¸­æ–·å»¶é²
int busy_poll_us = 50;  // å¾®ç§’
setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL,
           &busy_poll_us, sizeof(busy_poll_us));
```

**æ•ˆæœï¼š**
- å»¶é²å¾ ~50Î¼s é™åˆ° ~10Î¼s
- ä»£åƒ¹ï¼šå¢åŠ  CPU ä½¿ç”¨ç‡

#### 3. ä½¿ç”¨ recvmmsg æ‰¹æ¬¡æ¥æ”¶

```c
// ä¸€æ¬¡æ¥æ”¶å¤šå€‹å°åŒ…ï¼Œæ¸›å°‘ç³»çµ±å‘¼å«
struct mmsghdr msgs[32];
int nr = recvmmsg(sockfd, msgs, 32, MSG_DONTWAIT, NULL);

// æ¯”èµ· 32 æ¬¡ recvfromï¼Œåªéœ€è¦ 1 æ¬¡ç³»çµ±å‘¼å«ï¼
```

#### 4. SO_REUSEPORT å¤šåŸ·è¡Œç·’è² è¼‰å‡è¡¡

```c
int reuse = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &reuse, sizeof(reuse));

// å¤šå€‹åŸ·è¡Œç·’å¯ä»¥ bind åŒä¸€å€‹ port
// Kernel æœƒè‡ªå‹•åšè² è¼‰å‡è¡¡
```

#### 5. CPU Affinity å’Œ IRQ ç¶å®š

```bash
# å°‡æ¥æ”¶åŸ·è¡Œç·’ç¶åˆ° CPU 2
taskset -c 2 ./my_app

# å°‡ç¶²å¡ IRQ ç¶åˆ°åŒä¸€å€‹ CPU
echo 4 > /proc/irq/<IRQ_NUM>/smp_affinity  # 0x4 = CPU 2
```

### æ•ˆèƒ½å°æ¯”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å‚³çµ±æ–¹æ¡ˆæ•ˆèƒ½å°æ¯”ï¼ˆç„¡ DPDKï¼‰                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  æ–¹æ¡ˆ                      å»¶é²        ååé‡           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  é˜»å¡ recvfrom            100-500Î¼s   ~50,000 pps       â”‚
â”‚  poll + recvfrom          50-200Î¼s    ~100,000 pps      â”‚
â”‚  epoll + recvfrom         20-100Î¼s    ~500,000 pps      â”‚
â”‚  epoll + recvmmsg         10-50Î¼s     ~1,000,000 pps    â”‚
â”‚  epoll + recvmmsg +       5-30Î¼s      ~2,000,000 pps    â”‚
â”‚    SO_BUSY_POLL                                         â”‚
â”‚                                                         â”‚
â”‚  DPDK (åƒè€ƒ)              0.5-2Î¼s     ~14,000,000 pps   â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æœ€ä½³å¯¦è¸ Checklist

```
ç³»çµ±å±¤ç´šï¼š
[âœ“] IRQ ç¶å®šåˆ°ç‰¹å®š CPU
[âœ“] é—œé–‰ irqbalance
[âœ“] CPU governor = performance
[âœ“] ç¶²å¡ RSS/RPS è¨­å®š

Socket é¸é …ï¼š
[âœ“] SO_BUSY_POLLï¼ˆ50Î¼sï¼‰
[âœ“] SO_REUSEPORTï¼ˆå¤šåŸ·è¡Œç·’ï¼‰
[âœ“] SO_RCVBUFï¼ˆå¢å¤§ç·©è¡å€ï¼‰
[âœ“] O_NONBLOCKï¼ˆéé˜»å¡ï¼‰

ç¨‹å¼è¨­è¨ˆï¼š
[âœ“] ä½¿ç”¨ epoll edge-triggered
[âœ“] ä½¿ç”¨ recvmmsg æ‰¹æ¬¡æ¥æ”¶
[âœ“] CPU affinity ç¶å®š
[âœ“] é¿å…è¨˜æ†¶é«”åˆ†é…
[âœ“] Batch è™•ç†
```

### ä½•æ™‚å‡ç´šåˆ° DPDKï¼Ÿ

```
å‚³çµ±æ–¹æ¡ˆèƒ½æ»¿è¶³ï¼š
  âœ“ å»¶é²è¦æ±‚ > 10Î¼s
  âœ“ ååé‡ < 2M pps
  âœ“ éœ€è¦æ¨™æº– TCP/IP å”è­°æ£§
  âœ“ å…±äº«ä¼ºæœå™¨ç’°å¢ƒ

è€ƒæ…® DPDKï¼š
  âœ— å»¶é²è¦æ±‚ < 5Î¼s
  âœ— ååé‡ > 5M pps
  âœ— éœ€è¦æ¥µè‡´æ•ˆèƒ½
  âœ— å¯ä»¥ç¨ä½”ç¶²å¡
```

> **çµè«–**ï¼šåœ¨æ²’æœ‰ DPDK çš„æƒ…æ³ä¸‹ï¼Œ**epoll (edge-triggered) + recvmmsg + SO_BUSY_POLL** æ˜¯æœ€ä½³æ–¹æ¡ˆï¼Œå¯ä»¥é”åˆ° ~10Î¼s å»¶é²å’Œ 1-2M pps ååé‡ã€‚

---

## 2.6 ä¸»æµ Kernel Bypass æŠ€è¡“å°æ¯”

### ç‚ºä»€éº¼ä¸èƒ½ç”¨ recvfromï¼Ÿ

ç•¶ä½ å•Ÿå‹• DPDK æˆ–ç›¸é—œæŠ€è¡“æ™‚ï¼ŒæœƒåŸ·è¡Œã€Œç¶å®šé©…å‹•ã€(Binding Driver) å‹•ä½œï¼š

```
å‚³çµ± Linux ç¶²è·¯æ£§                Kernel Bypass æ¨¡å¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ifconfig å¯çœ‹åˆ°ç¶²å¡ eth0        ifconfig çœ‹ä¸åˆ°ç¶²å¡ï¼ˆè¢«æ¥ç®¡ï¼‰
æ ¸å¿ƒè™•ç†æ‰€æœ‰å°åŒ…                  æ ¸å¿ƒå¤±å»æ§åˆ¶æ¬Š
recvfrom() å¯ç”¨                  recvfrom() æ‹¿ä¸åˆ°è³‡æ–™
å°åŒ…ç¶“éå®Œæ•´å”è­°æ£§                å°åŒ…ç›´æ¥åˆ° User Space
```

**é—œéµå·®ç•°**ï¼šå°åŒ…è·¯å¾‘è®Šæˆ `ç¶²å¡ç¡¬é«” â†’ DMA â†’ User-space Memory`

### ä¸»æµæŠ€è¡“å°æ¯”è¡¨

| æŠ€è¡“ | å–åŒ…å‡½æ•¸ | é©ç”¨å ´æ™¯ | å»¶é²ç‰¹æ€§ | å­¸ç¿’æ›²ç·š |
|------|---------|---------|---------|---------|
| **DPDK** | `rte_eth_rx_burst()` | é€šç”¨é«˜æ•ˆèƒ½ç¶²è·¯æ‡‰ç”¨ | 500ns - 1Î¼s | ä¸­ç­‰ |
| **RDMA/RoCE** | `ibv_poll_cq()` | é‡‘èäº¤æ˜“ã€è¶…ç®— | < 500ns | è¼ƒé«˜ |
| **Solarflare EF_VI** | `ef_eventq_poll()` | é‡‘èæ¥­æ¨™æº– | < 300ns | é«˜ |
| **XDP (AF_XDP)** | `xsk_ring_cons__peek()` | å…¼é¡§å®‰å…¨èˆ‡æ•ˆèƒ½ | 1-2Î¼s | ä½ |

### 1. DPDK (æœ€ä¸»æµé–‹ç™¼æ¡†æ¶)

**ç‰¹é»**ï¼šé€éç’°å¢ƒæŠ½è±¡å±¤ (EAL) æ¥ç®¡ç¶²å¡ï¼Œå®Œå…¨ä¸ç¶“éæ ¸å¿ƒ

#### å–åŒ…å‡½æ•¸

```cpp
uint16_t rte_eth_rx_burst(
    uint16_t port_id,      // ç¶²å¡ port
    uint16_t queue_id,     // æ¥æ”¶ä½‡åˆ—ç·¨è™Ÿ
    struct rte_mbuf **rx_pkts,  // å°åŒ…ç·©è¡å€é™£åˆ—
    const uint16_t nb_pkts      // æœ€å¤šå–å¹¾å€‹å°åŒ…
);
```

#### ç‰¹æ€§

- **æ‰¹é‡è™•ç†**ï¼šä¸€æ¬¡å¯å–å› 1-32 å€‹ï¼ˆæˆ–æ›´å¤šï¼‰å°åŒ…
- **é›¶æ‹·è²**ï¼šå°åŒ…ç›´æ¥ç”±ç¶²å¡é€é DMA å¯«å…¥é å…ˆåˆ†é…çš„ Hugepages è¨˜æ†¶é«”
- **ç¤¾ç¾¤æ”¯æ´**ï¼šæœ€æ´»èºçš„é–‹æºå°ˆæ¡ˆï¼Œæ–‡ä»¶å®Œæ•´

#### ç¨‹å¼æµç¨‹

```cpp
// 1. åˆå§‹åŒ–
rte_eal_init(argc, argv);
mbuf_pool = rte_pktmbuf_pool_create(...);
rte_eth_dev_configure(port_id, ...);

// 2. è¼ªè©¢ (Busy Polling)
while (1) {
    struct rte_mbuf *bufs[BURST_SIZE];
    uint16_t nb_rx = rte_eth_rx_burst(port_id, 0, bufs, BURST_SIZE);

    for (uint16_t i = 0; i < nb_rx; i++) {
        // 3. æ‰‹å‹•è§£ææ¨™é ­
        uint8_t *pkt = rte_pktmbuf_mtod(bufs[i], uint8_t*);
        parse_packet(pkt);
        rte_pktmbuf_free(bufs[i]);
    }
}
```

### 2. RDMA / RoCE (æ¥µä½å»¶é²ã€ç¡¬é«”å¸è¼‰)

**ç‰¹é»**ï¼šè®“å…©å°ä¸»æ©Ÿçš„è¨˜æ†¶é«”ç›´æ¥é€šè¨Šï¼Œå¸¸ç”¨æ–¼é‡‘èé«˜é »äº¤æ˜“æˆ–è¶…ç®—ä¸­å¿ƒ

#### å–åŒ…å‡½æ•¸

```c
int ibv_poll_cq(
    struct ibv_cq *cq,        // Completion Queue
    int num_entries,          // æœ€å¤šè¼ªè©¢å¹¾ç­†
    struct ibv_wc *wc         // Work Completion çµæœ
);
```

#### ç‰¹æ€§

- **ä¸æ˜¯ã€Œæ¥æ”¶å°åŒ…ã€**ï¼šè€Œæ˜¯æª¢æŸ¥ã€Œå®Œæˆä½‡åˆ—ã€(Completion Queue)
- **ç¡¬é«”å¸è¼‰**ï¼šç¶²å¡ç›´æ¥å°‡è³‡æ–™æ”¾é€²ä½ çš„è¨˜æ†¶é«”ï¼Œç•™ä¸‹å®Œæˆç´€éŒ„
- **RDMA Read/Write**ï¼šå¯ç›´æ¥è®€å¯«é ç«¯ä¸»æ©Ÿè¨˜æ†¶é«”

#### ç¨‹å¼æµç¨‹

```c
// 1. åˆå§‹åŒ– RDMA è³‡æº
struct ibv_context *ctx = ibv_open_device(...);
struct ibv_cq *cq = ibv_create_cq(ctx, ...);
struct ibv_qp *qp = ibv_create_qp(pd, ...);

// 2. è¼ªè©¢å®Œæˆä½‡åˆ—
while (1) {
    struct ibv_wc wc;
    int n = ibv_poll_cq(cq, 1, &wc);

    if (n > 0 && wc.status == IBV_WC_SUCCESS) {
        // è³‡æ–™å·²ç¶“åœ¨ä½ çš„è¨˜æ†¶é«”ä¸­
        void *data = (void *)wc.wr_id;
        process_data(data);
    }
}
```

### 3. Solarflare EF_VI (é‡‘èæ¥­æ¨™æº–)

**ç‰¹é»**ï¼šSolarflare ç¶²å¡å°ˆæœ‰çš„åº•å±¤ APIï¼Œä»¥æ¥µè‡´ä½å»¶é²è‘—ç¨±

#### å–åŒ…å‡½æ•¸

```c
int ef_eventq_poll(
    struct ef_vi* vi,         // Virtual Interface
    ef_event* evs,            // Event é™£åˆ—
    int evs_len               // æœ€å¤šå–å¹¾å€‹ event
);

int ef_vi_receive_post(
    struct ef_vi* vi,         // Virtual Interface
    ef_addr buf_addr,         // ç·©è¡å€ä½å€
    ef_request_id id          // Request ID
);
```

#### ç‰¹æ€§

- **æ¯” DPDK æ›´è¼•é‡**ï¼šç›´æ¥æ“ä½œç¶²å¡çš„ Event Queue
- **è¶…ä½å»¶é²**ï¼šå°ˆç‚ºé‡‘èå¸‚å ´è¨­è¨ˆ
- **å» å•†é–å®š**ï¼šåƒ…æ”¯æ´ Solarflare (ç¾ AMD) ç¶²å¡

### 4. XDP (eXpress Data Path)

**ç‰¹é»**ï¼šLinux ç¤¾ç¾¤æ¨å´‡çš„æŠ€è¡“ï¼Œåœ¨å°åŒ…é€²å…¥å”è­°æ£§å‰æ””æˆªï¼Œçµåˆå®‰å…¨æ€§èˆ‡æ•ˆèƒ½

#### å–åŒ…å‡½æ•¸

```c
// AF_XDP User Space ä»‹é¢
__u32 xsk_ring_cons__peek(
    struct xsk_ring_cons *ring,  // æ¥æ”¶ ring
    __u32 nb,                    // æœ€å¤šå–å¹¾å€‹
    __u32 *idx                   // èµ·å§‹ç´¢å¼•
);
```

#### ç‰¹æ€§

- **eBPF æ•´åˆ**ï¼šå¯åœ¨ kernel å…§é€²è¡Œåˆæ­¥éæ¿¾
- **å…¼é¡§å®‰å…¨**ï¼šä¸éœ€è¦å®Œå…¨æ¥ç®¡ç¶²å¡
- **æ•ˆèƒ½æ¥è¿‘ DPDK**ï¼šä½†ä¿ç•™ Linux ç”Ÿæ…‹ç³»çµ±

#### ç¨‹å¼æµç¨‹

```c
// 1. å»ºç«‹ AF_XDP socket
int xsk_fd = socket(AF_XDP, SOCK_RAW, 0);
struct xsk_socket *xsk;
xsk_socket__create(&xsk, ifname, queue_id, ...);

// 2. è¼ªè©¢
while (1) {
    __u32 idx_rx = 0;
    __u32 nb_rx = xsk_ring_cons__peek(&xsk->rx, BATCH_SIZE, &idx_rx);

    for (__u32 i = 0; i < nb_rx; i++) {
        const struct xdp_desc *desc = xsk_ring_cons__rx_desc(&xsk->rx, idx_rx++);
        void *pkt = xsk_umem__get_data(xsk->umem_area, desc->addr);
        process_packet(pkt, desc->len);
    }

    xsk_ring_cons__release(&xsk->rx, nb_rx);
}
```

### æŠ€è¡“é¸æ“‡å»ºè­°

```
é€šç”¨å ´æ™¯          â†’ DPDK
  âœ“ ç¤¾ç¾¤æ”¯æ´ä½³
  âœ“ æ–‡ä»¶å®Œæ•´
  âœ“ è·¨å¹³å°

æ¥µè‡´å»¶é²          â†’ RDMA / Solarflare EF_VI
  âœ“ ç¡¬é«”å¸è¼‰
  âœ“ < 500ns å»¶é²
  âœ— ç¡¬é«”æˆæœ¬é«˜

å…¼é¡§å®‰å…¨èˆ‡æ•ˆèƒ½     â†’ XDP
  âœ“ ä¸ç ´å£ Linux ç¶²è·¯æ£§
  âœ“ eBPF æ•´åˆ
  âœ“ å­¸ç¿’æ›²ç·šä½
```

### å…±é€šé–‹ç™¼æµç¨‹

ç„¡è«–é¸æ“‡å“ªç¨®æŠ€è¡“ï¼Œæ ¸å¿ƒæµç¨‹éƒ½é¡ä¼¼ï¼š

```
1. åˆå§‹åŒ–
   â””â”€ æ¥ç®¡ç¶²å¡ / å»ºç«‹è³‡æº

2. è¨˜æ†¶é«”ç®¡ç†
   â””â”€ é å…ˆåˆ†é… Hugepages / UMEM

3. Busy Polling
   â””â”€ while(1) ä¸æ–·è¼ªè©¢

4. æ‰‹å‹•è§£æ
   â””â”€ è§£æ Ethernet/IP/UDP Header

5. è™•ç†æ¥­å‹™é‚è¼¯
   â””â”€ é¿å…ç³»çµ±å‘¼å«ã€é¿å…é–
```

---

## 3ï¸âƒ£ æ‡‰ç”¨å±¤ C/C++ ç¨‹å¼è¨­è¨ˆ

### å°ˆæ¡ˆæ¶æ§‹

```
hft_project/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ dpdk_init.cpp
â”‚   â””â”€â”€ packet_handler.cpp
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ config.h
â”‚   â””â”€â”€ lockfree_queue.hpp
â””â”€â”€ scripts/
    â”œâ”€â”€ setup.sh
    â””â”€â”€ run.sh
```

### ä¸»ç¨‹å¼ (src/main.cpp)

```cpp
#include <rte_eal.h>
#include <rte_ethdev.h>
#include <rte_mbuf.h>
#include <rte_cycles.h>
#include <pthread.h>
#include <sched.h>

#define RX_RING_SIZE 1024
#define TX_RING_SIZE 1024
#define NUM_MBUFS 8191
#define MBUF_CACHE_SIZE 250
#define BURST_SIZE 32

// NUMA-aware memory pool
static struct rte_mempool *mbuf_pool = NULL;

// æ ¸å¿ƒé…ç½®
#define POLLING_CORE 2    // éš”é›¢çš„ core
#define NUMA_NODE 0       // NIC æ‰€åœ¨çš„ NUMA node

// å°‡åŸ·è¡Œç·’ç¶å®šåˆ°ç‰¹å®š CPU
static inline void bind_to_cpu(int cpu) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
    
    // è¨­å®šæœ€é«˜å„ªå…ˆæ¬Š
    struct sched_param param;
    param.sched_priority = 99;
    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
}

// Port åˆå§‹åŒ–
static int port_init(uint16_t port) {
    struct rte_eth_conf port_conf = {};
    const uint16_t rx_rings = 1, tx_rings = 1;
    uint16_t nb_rxd = RX_RING_SIZE;
    uint16_t nb_txd = TX_RING_SIZE;
    int retval;
    
    // RSS é…ç½®ï¼ˆå¤š queue æ™‚ä½¿ç”¨ï¼‰
    port_conf.rxmode.mq_mode = RTE_ETH_MQ_RX_RSS;
    port_conf.rx_adv_conf.rss_conf.rss_key = NULL;
    port_conf.rx_adv_conf.rss_conf.rss_hf = 
        RTE_ETH_RSS_TCP | RTE_ETH_RSS_UDP;
    
    // é…ç½® port
    retval = rte_eth_dev_configure(port, rx_rings, tx_rings, &port_conf);
    if (retval != 0) return retval;
    
    // èª¿æ•´ ring size
    retval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &nb_rxd, &nb_txd);
    if (retval != 0) return retval;
    
    // é…ç½® RX queueï¼ˆç¶å®šåˆ° NUMA nodeï¼‰
    retval = rte_eth_rx_queue_setup(port, 0, nb_rxd,
        rte_eth_dev_socket_id(port), NULL, mbuf_pool);
    if (retval < 0) return retval;
    
    // é…ç½® TX queue
    retval = rte_eth_tx_queue_setup(port, 0, nb_txd,
        rte_eth_dev_socket_id(port), NULL);
    if (retval < 0) return retval;
    
    // å•Ÿå‹• port
    retval = rte_eth_dev_start(port);
    if (retval < 0) return retval;
    
    // é–‹å•Ÿ promiscuous modeï¼ˆä¾éœ€æ±‚ï¼‰
    rte_eth_promiscuous_enable(port);
    
    return 0;
}

// å¿«é€Ÿå°åŒ…è™•ç†ï¼ˆinline æ¸›å°‘å‡½æ•¸å‘¼å«é–‹éŠ·ï¼‰
static inline void process_packet(struct rte_mbuf *mbuf) {
    // é›¶æ‹·è²ï¼šç›´æ¥æ“ä½œ mbuf çš„è³‡æ–™æŒ‡æ¨™
    uint8_t *pkt_data = rte_pktmbuf_mtod(mbuf, uint8_t*);
    
    // å‡è¨­è™•ç† Ethernet header
    // struct rte_ether_hdr *eth_hdr = (struct rte_ether_hdr *)pkt_data;
    
    // *** ä½ çš„æ¥­å‹™é‚è¼¯ ***
    // ä¾‹å¦‚ï¼šè§£æã€è¨ˆç®—ã€æ±ºç­–
    
    // é‡é»ï¼šé¿å…è¨˜æ†¶é«”è¤‡è£½ã€é¿å…ç³»çµ±å‘¼å«ã€é¿å…é–
}

// ä¸»è¿´åœˆï¼šBusy Polling
static int lcore_main(__rte_unused void *arg) {
    uint16_t port = 0;
    
    // ç¶å®šåˆ°éš”é›¢çš„ CPU
    bind_to_cpu(POLLING_CORE);
    
    printf("Core %u doing packet processing.\n", rte_lcore_id());
    
    // é ç†± cache
    struct rte_mbuf *bufs[BURST_SIZE];
    for (int i = 0; i < 1000; i++) {
        uint16_t nb_rx = rte_eth_rx_burst(port, 0, bufs, BURST_SIZE);
        for (uint16_t i = 0; i < nb_rx; i++) {
            rte_pktmbuf_free(bufs[i]);
        }
    }
    
    // ä¸»è¿´åœˆï¼šæ°¸é ä¸ç¡çœ 
    while (1) {
        // Burst æ¥æ”¶ï¼ˆæ¸›å°‘ overheadï¼‰
        uint16_t nb_rx = rte_eth_rx_burst(port, 0, bufs, BURST_SIZE);
        
        if (unlikely(nb_rx == 0)) {
            // å³ä½¿æ²’å°åŒ…ä¹Ÿä¸ç¡çœ 
            rte_pause(); // CPU pause æŒ‡ä»¤ï¼Œæ¸›å°‘åŠŸè€—
            continue;
        }
        
        // è™•ç†å°åŒ…
        for (uint16_t i = 0; i < nb_rx; i++) {
            process_packet(bufs[i]);
            
            // é‡‹æ”¾ mbufï¼ˆæˆ–ç™¼é€å‡ºå»ï¼‰
            rte_pktmbuf_free(bufs[i]);
        }
    }
    
    return 0;
}

int main(int argc, char *argv[]) {
    // 1. åˆå§‹åŒ– DPDK EAL
    int ret = rte_eal_init(argc, argv);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Error with EAL initialization\n");
    }
    argc -= ret;
    argv += ret;
    
    // 2. å»ºç«‹ Memory Poolï¼ˆNUMA-awareï¼‰
    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", NUM_MBUFS,
        MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, NUMA_NODE);
    if (mbuf_pool == NULL) {
        rte_exit(EXIT_FAILURE, "Cannot create mbuf pool\n");
    }
    
    // 3. åˆå§‹åŒ– port 0
    if (port_init(0) != 0) {
        rte_exit(EXIT_FAILURE, "Cannot init port 0\n");
    }
    
    // 4. å•Ÿå‹•è™•ç†è¿´åœˆ
    lcore_main(NULL);
    
    // æ¸…ç†ï¼ˆé€šå¸¸ä¸æœƒåŸ·è¡Œåˆ°ï¼‰
    rte_eal_cleanup();
    return 0;
}
```

### Lock-free Queue (include/lockfree_queue.hpp)

```cpp
#pragma once
#include <atomic>
#include <array>

// Single Producer Single Consumer Lock-free Queue
template<typename T, size_t SIZE>
class SPSCQueue {
private:
    struct alignas(64) Node {  // Cache line alignment
        T data;
        std::atomic<bool> ready{false};
    };
    
    std::array<Node, SIZE> buffer_;
    alignas(64) std::atomic<size_t> write_idx_{0};
    alignas(64) std::atomic<size_t> read_idx_{0};
    
public:
    // ç”Ÿç”¢è€…ï¼šå¯«å…¥
    bool try_push(const T& item) {
        size_t current_write = write_idx_.load(std::memory_order_relaxed);
        size_t next_write = (current_write + 1) % SIZE;
        
        // æª¢æŸ¥æ˜¯å¦å·²æ»¿
        if (next_write == read_idx_.load(std::memory_order_acquire)) {
            return false;
        }
        
        buffer_[current_write].data = item;
        buffer_[current_write].ready.store(true, std::memory_order_release);
        write_idx_.store(next_write, std::memory_order_release);
        return true;
    }
    
    // æ¶ˆè²»è€…ï¼šè®€å–
    bool try_pop(T& item) {
        size_t current_read = read_idx_.load(std::memory_order_relaxed);
        
        if (!buffer_[current_read].ready.load(std::memory_order_acquire)) {
            return false;
        }
        
        item = buffer_[current_read].data;
        buffer_[current_read].ready.store(false, std::memory_order_release);
        read_idx_.store((current_read + 1) % SIZE, std::memory_order_release);
        return true;
    }
};
```

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(hft_app)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -march=native -mtune=native")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra")

# DPDK
find_package(PkgConfig REQUIRED)
pkg_check_modules(DPDK REQUIRED libdpdk)

include_directories(
    ${DPDK_INCLUDE_DIRS}
    ${CMAKE_SOURCE_DIR}/include
)

add_executable(hft_app
    src/main.cpp
)

target_link_libraries(hft_app
    ${DPDK_LIBRARIES}
    pthread
    numa
)
```

### å•Ÿå‹•è…³æœ¬ (scripts/run.sh)

```bash
#!/bin/bash

# æª¢æŸ¥ root
if [ "$EUID" -ne 0 ]; then 
    echo "Please run as root"
    exit 1
fi

# è¨­å®š CPU affinity maskï¼ˆä½¿ç”¨éš”é›¢çš„ core 2ï¼‰
# -l 2: ä½¿ç”¨ lcore 2
# -n 4: 4 å€‹ memory channels
# --socket-mem: æ¯å€‹ NUMA node çš„è¨˜æ†¶é«” (MB)
./hft_app -l 2 -n 4 --socket-mem=1024 \
    --file-prefix=hft \
    -- \
    --portmask=0x1
```

---

## 4ï¸âƒ£ é€²éšå„ªåŒ–æŠ€å·§

### A. è¨˜æ†¶é«”å°é½Šèˆ‡ Prefetch

```cpp
// 1. Cache line å°é½Šï¼ˆé¿å… false sharingï¼‰
struct alignas(64) Order {
    uint64_t timestamp;
    uint32_t price;
    uint32_t quantity;
    // ... å…¶ä»–æ¬„ä½
};

// 2. Prefetchï¼ˆæå‰è¼‰å…¥åˆ° cacheï¼‰
static inline void process_batch(Order* orders, int count) {
    for (int i = 0; i < count; i++) {
        // æå‰è¼‰å…¥ä¸‹ä¸€ç­†
        if (i + 1 < count) {
            __builtin_prefetch(&orders[i + 1], 0, 3);
        }
        
        // è™•ç†ç•¶å‰é€™ç­†
        process_order(&orders[i]);
    }
}
```

### B. Branch Prediction å„ªåŒ–

```cpp
// ä½¿ç”¨ likely/unlikely æç¤ºç·¨è­¯å™¨
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

if (unlikely(error_occurred)) {
    handle_error();
}

if (likely(packet_valid)) {
    process_packet();
}
```

### C. é¿å… False Sharing

```cpp
// éŒ¯èª¤ï¼šå…©å€‹è®Šæ•¸åœ¨åŒä¸€ cache lineï¼Œå¤šæ ¸å¿ƒå¯«å…¥æœƒäº’ç›¸å½±éŸ¿
struct Bad {
    std::atomic<uint64_t> counter1;  // 8 bytes
    std::atomic<uint64_t> counter2;  // 8 bytes (same cache line!)
};

// æ­£ç¢ºï¼špadding åˆ†é›¢åˆ°ä¸åŒ cache line
struct Good {
    alignas(64) std::atomic<uint64_t> counter1;
    alignas(64) std::atomic<uint64_t> counter2;
};
```

### D. æ™‚é–“æˆ³è¨˜å–å¾—

```cpp
// ä½¿ç”¨ RDTSCï¼ˆæœ€å¿«çš„æ™‚é–“æˆ³ï¼‰
static inline uint64_t rdtsc() {
    uint32_t lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
    return ((uint64_t)hi << 32) | lo;
}

// æˆ–ä½¿ç”¨ DPDK çš„å°è£
uint64_t now = rte_rdtsc();

// è½‰æ› cycles åˆ° nanoseconds
uint64_t hz = rte_get_tsc_hz();
uint64_t ns = (cycles * 1000000000ULL) / hz;
```

---

## 5ï¸âƒ£ æ¸¬è©¦èˆ‡é©—è­‰

### Latency æ¸¬è©¦ç¨‹å¼

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void measure_latency() {
    const int SAMPLES = 100000;
    std::vector<uint64_t> latencies;
    latencies.reserve(SAMPLES);
    
    for (int i = 0; i < SAMPLES; i++) {
        uint64_t start = rte_rdtsc();
        
        // *** ä½ çš„è™•ç†é‚è¼¯ ***
        process_packet();
        
        uint64_t end = rte_rdtsc();
        latencies.push_back(end - start);
    }
    
    // æ’åºè¨ˆç®—ç™¾åˆ†ä½
    std::sort(latencies.begin(), latencies.end());
    
    uint64_t hz = rte_get_tsc_hz();
    auto cycles_to_ns = [hz](uint64_t cycles) {
        return (cycles * 1000000000ULL) / hz;
    };
    
    std::cout << "P50:    " << cycles_to_ns(latencies[SAMPLES * 50 / 100]) << " ns\n";
    std::cout << "P99:    " << cycles_to_ns(latencies[SAMPLES * 99 / 100]) << " ns\n";
    std::cout << "P99.9:  " << cycles_to_ns(latencies[SAMPLES * 999 / 1000]) << " ns\n";
    std::cout << "Max:    " << cycles_to_ns(latencies.back()) << " ns\n";
}
```

### ç³»çµ±é…ç½®æª¢æŸ¥è…³æœ¬ (scripts/check.sh)

```bash
#!/bin/bash

echo "=== CPU Isolation Check ==="
cat /sys/devices/system/cpu/isolated

echo -e "\n=== CPU Governor ==="
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor | sort -u

echo -e "\n=== C-States ==="
cat /sys/module/intel_idle/parameters/max_cstate

echo -e "\n=== IRQ Affinity ==="
grep eth0 /proc/interrupts

echo -e "\n=== Hugepages ==="
cat /proc/meminfo | grep Huge

echo -e "\n=== NUMA Topology ==="
numactl --hardware

echo -e "\n=== NIC Driver ==="
ethtool -i eth0

echo -e "\n=== NIC Queues ==="
ethtool -l eth0

echo -e "\n=== DPDK Binding ==="
dpdk-devbind.py --status
```

---

## 6ï¸âƒ£ å®Œæ•´éƒ¨ç½² Checklist

### ç¡¬é«”å±¤

```
[âœ“] BIOSï¼šé—œé–‰ Hyper-Threading
[âœ“] BIOSï¼šé—œé–‰ C-States (C1E, C3, C6)
[âœ“] BIOSï¼šé—œé–‰ P-States / Turbo Boost
[âœ“] BIOSï¼šé–‹å•Ÿ VT-d / IOMMU
[âœ“] BIOSï¼šPerformance Mode
[âœ“] ç¶²å¡ï¼šIntel X710 æˆ– Mellanox ConnectX
[âœ“] ç¢ºèª NUMA æ‹“æ’²ï¼ˆNIC åœ¨å“ªå€‹ nodeï¼‰
```

### ç³»çµ±å±¤

```
[âœ“] GRUBï¼šisolcpus=1-7
[âœ“] GRUBï¼šnohz_full=1-7
[âœ“] GRUBï¼šrcu_nocbs=1-7
[âœ“] GRUBï¼šintel_pstate=disable
[âœ“] GRUBï¼šintel_idle.max_cstate=0
[âœ“] GRUBï¼šHugepages 1GB
[âœ“] é—œé–‰ irqbalance
[âœ“] IRQ ç¶å®šåˆ° CPU 0
[âœ“] CPU governor = performance
[âœ“] DPDK ç¶²å¡ç¶å®š (vfio-pci)
[âœ“] æ›è¼‰ Hugepages
```

### æ‡‰ç”¨å±¤

```
[âœ“] ä½¿ç”¨ DPDK PMD
[âœ“] Busy polling (while(1) loop)
[âœ“] ç¶å®šåˆ°éš”é›¢çš„ core (pthread_setaffinity_np)
[âœ“] SCHED_FIFO priority 99
[âœ“] Lock-free è³‡æ–™çµæ§‹
[âœ“] Cache line å°é½Š (alignas(64))
[âœ“] é¿å…å‹•æ…‹è¨˜æ†¶é«”åˆ†é… (malloc/free)
[âœ“] é›¶æ‹·è²è¨­è¨ˆ (ç›´æ¥æ“ä½œ mbuf)
[âœ“] Prefetch + Branch hints
[âœ“] NUMA-aware memory allocation
```

---

## 7ï¸âƒ£ ç·¨è­¯èˆ‡åŸ·è¡Œ

### å®‰è£ä¾è³´

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install -y dpdk dpdk-dev libnuma-dev \
    build-essential cmake pkg-config

# é©—è­‰ DPDK ç‰ˆæœ¬
dpdk-devbind.py --version
```

### ç·¨è­¯å°ˆæ¡ˆ

```bash
mkdir build && cd build
cmake ..
make -j$(nproc)
```

### é…ç½®ç³»çµ±ï¼ˆéœ€ rootï¼‰

```bash
# åŸ·è¡Œ DPDK è¨­å®šè…³æœ¬
sudo ../scripts/setup.sh

# æª¢æŸ¥é…ç½®
sudo ../scripts/check.sh
```

### åŸ·è¡Œæ‡‰ç”¨ç¨‹å¼

```bash
# æ–¹å¼ 1ï¼šç›´æ¥åŸ·è¡Œ
sudo ./hft_app -l 2 -n 4 --socket-mem=1024

# æ–¹å¼ 2ï¼šä½¿ç”¨è…³æœ¬
sudo ../scripts/run.sh
```

---

## 8ï¸âƒ£ é æœŸæ•ˆæœ

### æ•ˆèƒ½æŒ‡æ¨™

```
æ­£ç¢ºé…ç½®å¾Œçš„é æœŸæ•ˆæœï¼š

P50 Latency:  < 500 ns
P99 Latency:  < 1 Î¼s (å¾®ç§’)
P99.9:        < 5 Î¼s
Jitter:       < 10 Î¼s

ååé‡:       æ•¸ç™¾è¬ pps (packets per second)
CPU ä½¿ç”¨ç‡:    100% (busy polling)
```

### é©—è­‰æ–¹æ³•

```bash
# 1. æª¢æŸ¥ CPU æ˜¯å¦çœŸçš„éš”é›¢
taskset -cp $(pgrep hft_app)
# æ‡‰è©²é¡¯ç¤ºï¼špid XXX's current affinity list: 2

# 2. æª¢æŸ¥æ˜¯å¦çœŸçš„åœ¨ busy polling
top -H -p $(pgrep hft_app)
# CPU æ‡‰è©²æ¥è¿‘ 100%

# 3. æª¢æŸ¥ IRQ æ˜¯å¦æ­£ç¢ºåˆ†é…
watch -n 1 'cat /proc/interrupts | grep eth0'
# IRQ æ‡‰è©²åªåœ¨ CPU 0 ä¸Šå¢é•·

# 4. æª¢æŸ¥è¨˜æ†¶é«”æ˜¯å¦åœ¨æ­£ç¢ºçš„ NUMA node
numastat -p $(pgrep hft_app)
```

---

## 9ï¸âƒ£ å¸¸è¦‹å•é¡Œæ’é™¤

### Q1: DPDK åˆå§‹åŒ–å¤±æ•—

```bash
# æª¢æŸ¥ hugepages
cat /proc/meminfo | grep Huge

# é‡æ–°é…ç½®
echo 8 > /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages
```

### Q2: ç¶²å¡ç¶å®šå¤±æ•—

```bash
# ç¢ºèªç¶²å¡æ”¯æ´ DPDK
dpdk-devbind.py --status

# ç¢ºèª VFIO æ¨¡çµ„å·²è¼‰å…¥
lsmod | grep vfio

# æ‰‹å‹•è¼‰å…¥
modprobe vfio-pci
```

### Q3: Latency ä»ç„¶å¾ˆé«˜

```bash
# æª¢æŸ¥ CPU isolation
cat /sys/devices/system/cpu/isolated

# æª¢æŸ¥ C-States
cat /sys/module/intel_idle/parameters/max_cstate
# æ‡‰è©²æ˜¯ 0

# æª¢æŸ¥ CPU governor
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
# æ‡‰è©²å…¨éƒ¨æ˜¯ performance
```

### Q4: IRQ ä»æ‰“åˆ° polling core

```bash
# æª¢æŸ¥ irqbalance æ˜¯å¦çœŸçš„é—œé–‰
systemctl status irqbalance
# æ‡‰è©²æ˜¯ inactive (dead)

# æ‰‹å‹•è¨­å®š IRQ affinity
echo 1 > /proc/irq/XXX/smp_affinity
```

---

## ğŸ”Ÿ æ ¸å¿ƒåŸå‰‡ç¸½çµ

### äº”å¤§æ”¯æŸ±

```
1. CPU éš”é›¢
   isolcpus + nohz_full + rcu_nocbs
   â†’ è®“ CPU è®Šæˆå°ˆå±¬è£¸æ©Ÿ

2. Busy Polling
   while(1) + æ°¸é ä¸ç¡çœ 
   â†’ æ› CPU è³‡æºå–å¾—ç©©å®š latency

3. é›¶æ‹·è²
   ç›´æ¥æ“ä½œ DPDK mbuf
   â†’ é¿å…è¨˜æ†¶é«”è¤‡è£½

4. Lock-free
   atomic + memory_order
   â†’ é¿å…é–ç«¶çˆ­

5. NUMA å°é½Š
   NIC/core/memory åŒ node
   â†’ é¿å…è·¨ NUMA å­˜å–
```

### å„ªåŒ–å„ªå…ˆç´š

```
é«˜å„ªå…ˆç´šï¼ˆå¿…åšï¼‰
â”œâ”€â”€ CPU isolation é…ç½®
â”œâ”€â”€ IRQ ç¶å®š
â”œâ”€â”€ Hugepages
â”œâ”€â”€ DPDK kernel bypass
â””â”€â”€ NUMA å°é½Š

ä¸­å„ªå…ˆç´šï¼ˆé‡è¦ï¼‰
â”œâ”€â”€ Lock-free è³‡æ–™çµæ§‹
â”œâ”€â”€ Cache line å°é½Š
â”œâ”€â”€ é¿å…å‹•æ…‹è¨˜æ†¶é«”åˆ†é…
â””â”€â”€ Prefetch

ä½å„ªå…ˆç´šï¼ˆåŠ åˆ†ï¼‰
â”œâ”€â”€ Branch hints
â”œâ”€â”€ ç·¨è­¯å™¨å„ªåŒ– flags
â””â”€â”€ å¾®èª¿ DPDK åƒæ•¸
```

---

## ğŸ“š åƒè€ƒè³‡æº

### å®˜æ–¹æ–‡ä»¶

- [DPDK Documentation](https://doc.dpdk.org/)
- [Intel X710 Datasheet](https://www.intel.com/content/www/us/en/products/docs/network-io/ethernet/700-series-controllers.html)
- [Linux Kernel Real-Time](https://wiki.linuxfoundation.org/realtime/start)

### é€²éšé–±è®€

- [DPDK Performance Tuning](https://doc.dpdk.org/guides/linux_gsg/nic_perf_intel_platform.html)
- [Linux Low Latency Tuning](https://rigtorp.se/low-latency-guide/)
- [Lock-free Programming](https://preshing.com/20120612/an-introduction-to-lock-free-programming/)

---

## ğŸ“„ æˆæ¬Šèˆ‡è²¢ç»

æœ¬æ–‡ä»¶æä¾›åƒè€ƒä½¿ç”¨ï¼Œå¯¦éš›éƒ¨ç½²è«‹æ ¹æ“šå…·é«”ç¡¬é«”èˆ‡éœ€æ±‚èª¿æ•´ã€‚

---

**è¨˜ä½**ï¼šé«˜é »ç³»çµ±å„ªåŒ–ä¸æ˜¯è¿½æ±‚ã€Œå¿«ã€ï¼Œè€Œæ˜¯è¿½æ±‚ã€Œç©©å®šçš„å¿«ã€ã€‚

> **"It's not about being fast, it's about being consistently fast."**
