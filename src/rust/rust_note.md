## å­¸ç¿’é †åº

Rust æ˜¯ä¸€å€‹å­¸ç¿’æ›²ç·šæ¯”è¼ƒé™¡å³­çš„èªè¨€ï¼Œå³ä½¿æœ‰å…¶ä»–èªè¨€åŸºç¤ï¼Œå¦‚æœæ²’æœ‰å…ˆè®€æ›¸ï¼Œè€Œæ˜¯ç›´æ¥ä¸Šï¼Œé‚£åœ¨ compile éšæ®µå°±æœƒæœ‰å¾ˆå¤šæŒ«æŠ˜ä¸¦ä¸”ç„¡æ³•ç†è§£ã€‚ä»¥ä¸‹æ˜¯æˆ‘è¦ºå¾—å°å·²ç¶“æœ‰å…¶ä»–èªè¨€åŸºç¤çš„äººï¼Œç”¨é€™æ¨£çš„å­¸ç¿’é †åºæ˜¯ä¸éŒ¯çš„

1. [Rust èªè¨€ä¹‹æ—…](https://tourofrust.com/TOC_zh-tw.html)ï¼š1 - 3 å¤©å°±å¯ä»¥èµ°å®Œï¼Œä¸¦ä¸”å› ç‚ºæ˜¯ä½¿ç”¨ playgroundï¼Œå¯ä»¥åŒæ™‚æ”¹æ”¹ä»–çš„ç¯„ä¾‹é¡å¤–è§€å¯Ÿä¸€äº›è‡ªå·±æœ‰èˆˆè¶£çš„è¡Œç‚ºã€‚èµ°å®Œä¹‹å¾Œå¤§æ¦‚æœƒå°æ–¼ Rust èˆ‡å…¶ä»–èªè¨€çš„å·®åˆ¥æœ‰äº›æ„Ÿè¦º
2. [Rust book](https://doc.rust-lang.org/book/)ï¼šOffical çš„æ•™å­¸æ–‡ï¼Œé›–ç„¶å¯«çš„ä¸ç®—ç‘£ç¢ï¼Œä½†è‹¥ä¸€é–‹å§‹å°±çœ‹é€™å€‹å¯èƒ½é‚„æ˜¯æœƒè®“äººå¤±å»è€å¿ƒï¼Œç•¢ç«Ÿä¸€æ¬¡æœƒç´¯ç¸¾æ¥æ”¶å¤ªå¤šæ–°æ±è¥¿ã€‚å¦‚æœå·²ç¶“æœ‰äº†æ­¥é©Ÿ 1ï¼Œå°æ–¼ Rust è·Ÿå…¶ä»–èªè¨€çš„ç•°åŒæœ‰æ„Ÿè¦ºï¼Œé‚£å¾ˆå¤šéƒ¨åˆ†å°±å¯ä»¥åƒç…§å…¶ä»–æœ¬ä¾†å°±æœƒçš„èªè¨€ï¼Œå› æ­¤æœ‰ä¸€å€‹ç«‹è¶³é»ï¼Œæ¯”è¼ƒä¸æœƒå¤ªæŒ«æŠ˜ä¸¦å¤±å»è€å¿ƒã€‚ä¸ä¸€å®šè¦ä¸€è¡Œä¸€è¡Œçœ‹çš„å¾ˆä»”ç´°ï¼Œå› ç‚ºå…¶å¯¦ç•¢ç«Ÿå…‰çœ‹ä¹ŸæœƒçœŸçš„æ‡‚ï¼Œæ‰€ä»¥å°±åªæ˜¯å¤§æ¦‚çŸ¥é“æœ‰å“ªäº›æ±è¥¿æœ‰å€‹å°è±¡å°±è¡Œã€‚å¯èƒ½æœƒèŠ±åˆ°ä¸€é€±ä»¥ä¸Šçš„æ™‚é–“ï¼Œå–æ±ºæ–¼çœ‹å¾—å¤šä»”ç´°ä»¥åŠå¤šä¹…å¤±å»è€å¿ƒâ€¦ å’Œä¸‹ä¸€æ­¥çš„ [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html) é †åºå¯èƒ½å¯ä»¥èª¿æ›ï¼Œçœ‹ä½ çš„ç¿’æ…£æ˜¯æ¯”è¼ƒå–œæ­¡è®€æ›¸é‚„æ˜¯çœ‹ codeâ€¦ï¼Œå¦‚æœå¾ˆä¸æ„›è®€æ–‡å­—çš„è©±ç”šè‡³ä¹Ÿå¯ä»¥è·³é Rust bookï¼Œç›´æ¥å¾ [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html) é–‹å§‹ä¹Ÿå¯ä»¥ï¼Œå¦‚æœæœ‰ Example çœ‹ä¸æ‡‚çš„åœ°æ–¹å†ä¾†ç¿»ç¿»çœ‹ Rust book
3. [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)ï¼šä¸€äº›åŸºç¤ pattern çš„ç¯„ä¾‹ï¼Œå¯ä»¥ç†Ÿæ‚‰ Rust èªæ³•å’Œä»–çš„ä¸€äº›ç‰¹åˆ¥è¨­è¨ˆï¼Œå°¤å…¶å¦‚ [Enum](https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum/testcase_linked_list.html)ã€`match`ã€[Closure](https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html)â€¦ ç­‰ç­‰å…¶ä»–èªè¨€å¯èƒ½ä¹Ÿæœ‰ï¼Œä½† Rust å»åœ¨å…¶ä¸ŠèŠ±æ›´å¤šåŠŸå¤«çš„éƒ¨åˆ†ã€‚å…¨éƒ¨å¤§æ¦‚ 3 å¤©ä»¥å…§å¯ä»¥çœ‹å®Œã€‚å¦‚æœæœ‰ç„¡æ³•ç†è§£çš„åœ°æ–¹ï¼Œå¯èƒ½é‚„æ˜¯è¦å›å»ç¿» [Rust book](https://doc.rust-lang.org/book/)

åˆ°é€™è£¡å°±çµæŸäº†è®€æ›¸éšæ®µï¼Œç¸½å…±èŠ±äº† 1~2 é€±çš„æ™‚é–“ï¼Œå¾€ä¸‹å°±æ˜¯ç·´ç¿’äº†

1. [Chest sheet](https://cheats.rs/)ï¼šå¯ä»¥é–‹å§‹ä¸Šå·¥äº†ï¼Œå­¸ç¿’èªè¨€é€™ç¨®æ±è¥¿æ˜¯æ²’è¾¦æ³•åªç”¨çœ‹çš„ï¼Œé–‹å§‹è‘—æ‰‹å¯« project æ‰èƒ½çœŸçš„å­¸æœƒï¼Œå¯«çš„éç¨‹å°±å¯ä»¥å¿«é€Ÿç”¨é€™å€‹ Chest sheet æŸ¥çœ‹èªæ³•ï¼Œå¤§éƒ¨åˆ†åœ¨ [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html) ä»‹ç´¹åˆ°çš„ pattern éƒ½æœ‰è¢«ä»¥ä¸€è¡Œç°¡æ½”çš„æ”¶éŒ„åœ¨ Chest sheetï¼Œåéä¾†èªªï¼Œè‹¥çœ‹äº† Chest sheet é‚„æ˜¯æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å›å»ç¿» [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)
2. [rustlings](https://github.com/rust-lang/rustlings/)ï¼šRust å®˜æ–¹æä¾›çš„ç·´ç¿’ï¼Œå¯ä»¥é–‹å§‹ç·´ç¿’å°ç¨‹å¼ï¼Œç¯„åœæœ‰å¯èƒ½æ˜¯å–®ä¸€ [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯è¤‡åˆã€‚å…¶å¯¦ rustlings åŸºæœ¬ä¸Šå°±æ˜¯ [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)ï¼Œåªæ˜¯ä¹‹å‰ Rust by Example ä½ å¯èƒ½å°±åªæ˜¯å…‰çœ‹ï¼Œé€é rustlings ä½ å¯ä»¥çœŸçš„å‹•æ‰‹å¯«ä¸€æ¬¡ï¼Œéç¨‹ä¸­ [Chest sheet](https://cheats.rs/) å°±æ˜¯å¥½å¹«æ‰‹
3. [Rust Algorithm Club](https://rust-algo.club/index.html)ï¼šåŸºç¤æ¼”è¡£æ–™çµæ§‹å’Œç®—æ³•çš„å¯¦ä½œ
4. [Rust cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)ï¼šå®Œæˆä¹‹å‰çš„æ­¥é©Ÿä¹‹å¾Œï¼Œä½ åŸºæœ¬ä¸Šå·²ç¶“å¯ä»¥ç”¨ Rust å®Œæˆå¤§éƒ¨åˆ†çš„éœ€æ±‚ï¼Œä½†å¯ä»¥é€²ä¸€æ­¥å†è®€é€™å€‹ Rust cookbookã€‚ä»–æ˜¯å®˜æ–¹æ”¶é›†äº†å¸¸ç”¨çš„æƒ…å¢ƒï¼Œç¤ºç¯„æœ€å°ˆæ¥­çš„å¯«æ³•ã€‚åœ¨å¾€å¾Œä½ çš„å¯¦éš›å°ˆæ¡ˆä¸­ï¼Œä½ çš„ç¨‹å¼çš„éœ€æ±‚ä¸€å®šéƒ½ç”¨å¾—åˆ°é€™äº›æ±è¥¿ï¼Œä¹Ÿå°±æ˜¯èªªç•¶æˆç‚ºä¸€å€‹è·æ¥­ Rust developerï¼Œ[Chest sheet](https://cheats.rs/)ã€[Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)ã€[Rust cookbook](https://rust-lang-nursery.github.io/rust-cookbook/) å°±æ˜¯ä¸‰å€‹é–‹åœ¨æ—é‚Šéš¨æ™‚åƒè€ƒçš„æ±è¥¿ã€‚å…¶å¯¦ï¼Œå¦‚æœæ˜¯å…¶ä»–èªè¨€ï¼Œç•¶æƒ³æ‰¾ä»€éº¼èªæ³•æˆ‘å€‘å¯èƒ½éƒ½æœƒé¸æ“‡ç›´æ¥ Googleï¼Œç„¶å¾Œå°±æœƒçœ‹åˆ°åå‡º Stack Overflow çš„çµæœå¯ä»¥ç›´æ¥åƒè€ƒï¼Œä¸éå¯èƒ½ Rust æ˜¯ä¸€å€‹ç›¸å°æ–°çš„èªè¨€ï¼ŒåŠ ä¸Šä»–çš„å­¸ç¿’æ›²ç·šæ¯”è¼ƒé™¡å³­ï¼Œæ‰€ä»¥ Stack Overflow çš„å›ç­”å¯èƒ½æœƒå‡ºç¾ä¸å¤ªæ­£ç¢ºæˆ–è€…éæ–¼æ¨¡ç³Šçš„ç‹€æ³ï¼Œæ‰€ä»¥æ‰å»ºè­°å¾å®˜æ–¹è³‡æºå‡ºç™¼ï¼Œæ‰å¯¦ä¸€é»çš„å­¸ï¼Œå¾€å¾Œå°±å¯ä»¥æ›´æœ‰èƒ½åŠ›åˆ¤æ–·åˆ¥äººçš„å›ç­”æ˜¯å°æ˜¯éŒ¯ã€‚ä¹Ÿä¸ç”¨å…¨çœ‹å•¦ï¼Œç€è¦½ä¸€ä¸‹ä»–æœ‰å“ªäº›ç¯„ä¾‹ï¼Œç„¶å¾ŒæŒ‘å¹¾å€‹æœ‰èˆˆè¶£çœ‹ä¸€ä¸‹å°±å¯ä»¥ï¼Œä¹‹å¾ŒçœŸçš„é–‹å§‹å¯«å°ˆæ¡ˆï¼Œè¦ä¾†è¤‡è£½è²¼ä¸Šçš„æ™‚å€™ï¼Œå†ä¾†æŠŠä»–çœ‹æ‡‚å°±å¯ä»¥
5. å¦å¤–ä¹Ÿæœ‰éå®˜æ–¹çš„ç·´ç¿’å¦‚ [Exercism](https://exercism.io/my/tracks/rust) æä¾›æ›´é€²éšçš„é¡Œç›®ã€‚LeetCode ä¹Ÿæœ‰ Rust å•¦ï¼Œä¸éä»–ç•¢ç«Ÿä¸»è¦æ˜¯ for é¢è©¦æƒ…å¢ƒï¼Œæ‰€ä»¥æ˜¯ä»¥æ€è€ƒæ¼”ç®—æ³•ç‚ºä¸»è¦å°å‘çš„ï¼Œå› æ­¤ç”¨é«˜éšä¸€é»çš„èªè¨€å»åˆ·æ¯”å¦‚ Python, Java é‚„æ˜¯æ¯”è¼ƒé©åˆçš„ã€‚Rust ä½œç‚ºä¸€å€‹ system programming languageï¼Œç›´æ¥ç”¨å®ƒä¾†é–‹å§‹å¯« system application å°±å¾ˆå¥½
6. å¯ä»¥é–‹å§‹å¯«å®Œæ•´çš„ project äº†ï¼Œå¦‚æœæ²’æœ‰ä¸»é¡Œçš„è©±ï¼Œå¯ä»¥å¾ [Rust book å»ºè­°çš„](https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html) é–‹å§‹

------

## Chest sheet

[Chest sheet](https://cheats.rs/)

### Reference

- [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)
- [Rust cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)
- [Rust Algorithm Club](https://rust-algo.club/index.html)
- [Official std](https://doc.rust-lang.org/std/)

### Data Type

#### Basic

- integer

  > Length Signed Unsigned
  > 8-bit `i8` `u8`
  > 16-bit `i16` `u16`
  > 32-bit `i32`(default) `u32`
  > 64-bit `i64` `u64`
  > 128-bit `i128` `u128`
  > arch `isize` `usize`

- float: `f32`, `f64`(default)

- `bool`

- `char`: Fixed 4 bytes in size and represents a Unicode Scalar Value

#### Advanced

- **Tuple**: `()` Fixed length. Group different types.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```



```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup; // it's copying, not moving because it's on stack
```



```rust
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
```

- **Array**: `[]` Same type. Fixed length

```rust
let a = [1, 2, 3, 4, 5];

let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; //[3 ,3 ,3, 3, ,3]

let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
```

- [Vector](https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-18)
- [string](https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-12)
- [HashMap](https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-19)

------

> å¾€ä¸‹æ˜¯æˆ‘è‡ªå·±è£œå…… Chest sheet ä¸­æ²’æœ‰çš„ï¼Œæˆ–è€…ä¸€äº›æ¯”è¼ƒé›£æ‡‚çš„æ¦‚å¿µ

## Borrowing

Rust çš„ `*` å’Œ `&` åœ¨ä¸€é–‹å§‹ä¸å»ºè­°ç›´æ¥ç”¨ C çš„æ–¹å¼ä¾†ç†è§£ï¼Œè€Œå»ºè­°ç†è§£ç‚º `&` è¡¨é”çš„æ˜¯ `å€Ÿç”¨`ï¼Œè€Œä¸æ˜¯ `å–å€`ã€‚
é›–ç„¶å…¶å¯¦åŸºç¤ä¸Šå°±éƒ½æ˜¯ referenceï¼Œæ‰€ä»¥ä»¥åº•å±¤ä¾†èªªå¯¦éš›ä¸Šè·Ÿ C å·®ç•°ä¸å¤§ï¼Œåªæ˜¯èªæ³•ä¸Šå¦‚æœç›´æ¥æƒ³æˆè·Ÿ C ä¸€æ¨£ï¼Œé‚£æœƒæœ‰å¥½äº› compile error ç„¡æ³•é †åˆ©ç†è§£ã€‚



```rust
struct Foo {
    x: i32,
}

fn do_something(f: Foo) {
    println!("{}", f.x);
    // f is dropped here
}

fn main() {
    let mut foo = Foo { x: 42 };
    let f = &mut foo;

    // FAILURE: do_something(foo) would fail because
    // foo cannot be moved while mutably borrowed

    // FAILURE: foo.x = 13; would fail here because
    // foo is not modifiable while mutably borrowed

    f.x = 13;
    // f is dropped here because it's no longer used after this point
    
    println!("{}", foo.x);
    
    // this works now because all mutable references were dropped
    foo.x = 7;
    
    // move foo's ownership to a function
    do_something(foo);
}
```

- Rust åªå…è¨± ä¸€å€‹ mut reference æˆ–è€… å¤šå€‹ unmut referenceï¼Œä½†ä¸æœƒåŒæ™‚ç™¼ç”Ÿ
- ä¸€å€‹ reference çµ•å°ä¸èƒ½æ´»å¾—æ¯”å®ƒçš„æ“æœ‰è€…é‚„é•·

å°æ–¼å€Ÿç”¨è€Œä¾†çš„è®Šæ•¸ï¼Œæ“ä½œæ™‚æœƒä½¿ç”¨åˆ° `*`ï¼Œé›–ç„¶ä¹Ÿå«åš `dereferencing`ï¼Œä½†åœ¨ rust ä¾†èªªä¸€æ¨£æ˜¯è¦ç”¨ ownership çš„æ¦‚å¿µä¾†æº–ç¢ºç†è§£ã€‚

```rust
fn main() {
    let mut foo = 42;
    let f = &mut foo;
    let bar = *f; // get a copy of the owner's value
    *f = 13;      // set the reference's owner's value
    println!("{}", bar);
    println!("{}", foo);
}
```

æ³¨æ„ `let bar = *f` æ˜¯è®“ bar å¾—åˆ° f çš„å€¼çš„è¤‡è£½å“ï¼Œå‰ææ˜¯ f çš„å‹åˆ¥æœ‰ Copy å±¬æ€§ã€‚

### Example

Borrow checker å…¶å¯¦æ˜¯å€‹å¤§é­”ç‹ï¼Œä»–éå¸¸åš´æ ¼ï¼Œå¯ä»¥å¯«å¯«é€™ä¸€é¡Œä¾‹å­å°±æœƒæ›´æœ‰æ„Ÿè¦º
[[LeeCode\] #19 Remove Nth Node From End of List](https://chungchris.github.io/2021/07/09/software/leecode/Remove-Nth-Node-From-End-of-List/#toc-heading-5)

------

## Lifetime

Lifetime å°±æ˜¯ç‚ºäº† borrow checker è€Œå­˜åœ¨ï¼Œç¢ºä¿ä¸€å€‹ reference ä¸€å®šä¸æœƒ refer åˆ°ä¸€å¡Šå·²ç¶“æ­»æ‰çš„å¯¦é«”ã€‚å¤§éƒ¨åˆ†çš„ç‹€æ³éƒ½ Elisionï¼Œç·¨è­¯å™¨æœƒå¹«å¿™è£œä¸Šï¼Œä½†ç·¨è­¯å™¨ç„¡æ³•åˆ¤æ–·çš„ç‹€æ³è‡ªç„¶å°±è¦è‡ªå·±å¯«

```rust
// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow<'a>() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    let y: &'a i32 = &_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&`) of both variables are passed into the function.
    print_refs(&four, &nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
```

`fn failed_borrow<'a>()` ä»£è¡¨ `'a` é€™å€‹ lifetime è¦ >= `failed_borrow()` é€™å€‹ funtcion çš„ lifetime
ä½† `main()` è£¡é¢å‘¼å«åˆ° `failed_borrow()` çš„æ™‚å€™ï¼Œæ²’æœ‰æŒ‡å®š `'a` æ˜¯ä»€éº¼ï¼Œé‚£å°±é è¨­ `'a` å°±æ˜¯ `'static`ï¼Œè€Œ `'static` é€™å€‹ lifetime ä¸€å®š >= `failed_borrow()` çš„ lifetime

`fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32)` è¦ç¯„ `print_refs()` é€™å€‹ function çš„ lifetimeï¼Œä¸€å®šè¦ <= `'a`,`'b` é€™å…©å€‹ lifetimeï¼Œä¹Ÿå°±æ˜¯ä»–çš„å…©å€‹åƒæ•¸çš„ lifetime

### Coercion

```rust
// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply<'a>(first: &'a i32, second: &'a i32) -> i32 {
    first * second
}
```

`first` `second` å…©å€‹åƒæ•¸çš„ lifetime ä¸è¦‹å¾—ç›¸åŒï¼Œä½†æœƒå–å…¶å°è€…ï¼Œæœ‰å°±æ˜¯ `multiply()` é€™å€‹ function çš„ lifetime ä¸€å®šè¦å°æ–¼ç­‰æ–¼å…¶å…©å€‹åƒæ•¸ä¹‹ä¸­ lifetime æ›´å°çš„é‚£å€‹

### static

- ä¸€å€‹éœæ…‹è®Šé‡æ˜¯åœ¨ç·¨è­¯æ™‚é–“å°±è¢«ç”¢ç”Ÿçš„è¨˜æ†¶é«”è³‡æºï¼Œå®ƒå¾ç¨‹å¼ä¸€é–‹å§‹å°±å­˜åœ¨ï¼Œç›´åˆ°çµæŸ
- ä¸€å®šè¦æ˜ç¢ºçš„è¡¨ç¤ºå‹åˆ¥
- æ°¸é ä¸æœƒè¢« `drop`
- å¦‚æœéœæ…‹ç”Ÿå‘½é€±æœŸè³‡æºåŒ…å«äº† referenceï¼Œé‚£å®ƒå€‘å¿…é ˆéƒ½å¾—æ˜¯ `static`



- ä¿®æ”¹éœæ…‹è®Šé‡æœ¬è³ªä¸Šå°±æ˜¯å±éšªçš„ï¼Œå› ç‚ºä»»ä½•äººåœ¨ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥å­˜å–å®ƒå€‘ï¼Œè€Œé€™æœ‰å¯èƒ½æœƒé€ æˆ data racing
- Rust å…è¨±ä½¿ç”¨ `unsafe { ... }` æ“ä½œä¸€äº›ç·¨è­¯å™¨ç„¡æ³•ç¢ºä¿çš„è¨˜æ†¶é«”è¡Œç‚º

------

## Collections- string

`utf-8`ï¼Œæœ‰ 1-4 å€‹ bytes çš„*å¯è®Šé•·åº¦*

```rust
fn main() {
    let a = "hi ğŸ¦€";
    println!("{}", a.len());
    let first_word = &a[0..2]; // 2 bytes => 2 Eng chars
    let second_word = &a[3..7]; // 4 bytes => 1 emoji
    // let half_crab = &a[3..5]; FAILS
    // Rust does not accept slices of invalid unicode characters
    println!("{} {}", first_word, second_word);
}
```

```bash
7
hi ğŸ¦€
```

å› ç‚ºå¯è®Šé•·åº¦çš„é—œä¿‚ï¼ŒæŸ¥æ‰¾å­—å…ƒæ™‚ç„¡æ³•å¿«é€Ÿåœ°ä»¥ `O(1)` å¸¸æ•¸æ™‚é–“ç”¨ç´¢å¼•å®Œæˆï¼Œä¾‹å¦‚ä»¥ `my_text[3]` å–å¾—ç¬¬ 4 å€‹å…ƒ)ã€‚å–è€Œä»£ä¹‹çš„æ˜¯å¿…å®šå¾—è¿­ä»£æ•´å€‹ `utf-8` ä½å…ƒåºåˆ—ï¼Œæ‰æœ‰è¾¦æ³•çŸ¥é“å„å€‹ char çš„é–‹å§‹é»ï¼Œæ‰€ä»¥æ˜¯ `O(n)` ç·šæ€§æ™‚é–“

### push_str, +, to_uppercase, to_lowercase, trim, replace, concat, join

```rust
fn main() {
    let mut helloworld = String::from("hello");
    helloworld.push_str(" world");
    helloworld = helloworld + "!";
    println!("{}", helloworld);
    println!("{}", helloworld.to_uppercase());
    println!("{}", helloworld.trim()); // åˆ‡é™¤ç©ºç™½
    println!("{}", helloworld.replace("world", "taiwan"));

    let helloworld = ["hello", " ", "world", "!"].concat();
    let abc = ["a", "b", "c"].join(",");
    println!("{}", helloworld);
    println!("{}",abc);
}
```

```bash
hello world!
HELLO WORLD!
hello world!
hello taiwan!
hello world!
a,b,c
```

### to_string, parse

```rust
fn main() -> Result<(), std::num::ParseIntError> {
    let a = 42;
    let a_string = a.to_string();
    let b = a_string.parse::<i32>()?;
    println!("{} {}", a, b);
    Ok(())
}
```

### format!

```rust
format!("Hello");                 // => "Hello"
format!("Hello, {}!", "world");   // => "Hello, world!"
format!("The number is {}", 1);   // => "The number is 1"
format!("{:?}", (3, 4));          // => "(3, 4)"
format!("{value}", value=4);      // => "4"
format!("{} {}", 1, 2);           // => "1 2"
format!("{:04}", 42);             // => "0042" with leading zeros
format!("{:#?}", (100, 200));     // => "(
                                  //       100,
                                  //       200,
                                  //     )"
```

[moreâ€¦](https://doc.rust-lang.org/std/fmt/)

### include_str

å¦‚æœä½ æœ‰ä¸€äº›éå¸¸é•·çš„æ–‡å­—ï¼Œå¯ä»¥è€ƒæ…®ä½¿ç”¨ marco `include_str!` å°‡ string å¾ file è®€åˆ°ç¨‹å¼è£¡

```rust
let hello_html = include_str!("hello.html");
```

### chars

Rust æä¾›äº†ä¸€å€‹æ–¹æ³•å¯ä»¥å–å¾—ä¸€å€‹ `utf-8` ä½å…ƒçµ„çš„å­—å…ƒå‘é‡ï¼Œå®ƒçš„å‹åˆ¥æ˜¯ `char`ã€‚ä¸€å€‹ `char` çš„å¤§å°æ°¸é æ˜¯ 4 bytes

```rust
fn main() {
    // collect the characters as a vector of char
    let chars = "hi ğŸ¦€".chars().collect::<Vec<char>>();
    println!("{}", chars.len()); // should be 4
    // since chars are 4 bytes we can convert to u32
    println!("{}", chars[3] as u32);
}
```

`string` çš„ `chars()` æ–¹æ³•å°‡ string åˆ†é›¢ç‚ºå„å€‹æœ‰æ„ç¾©çš„ characterï¼Œä¸¦æ”¾å…¥ç©ºé–“ä¸€å¾‹ç‚º 4 bytes çš„ `char` å‹åˆ¥ä¸­ï¼Œä¸²æˆä¸€å€‹ `Vec` å›å‚³ã€‚

```rust
for c in my_str.chars() { 
    // do something with `c`
}

for (i, c) in my_str.chars().enumerate() {
    // do something with character `c` and index `i`
}
```

------

## Collections- Vector

- can only store values of the same type
- puts all the values next to each other in memory

```rust
fn main() {
    // Iterators can be collected into vectors
    let collected_iterator: Vec<i32> = (0..10).collect();
    println!("Collected (0..10) into: {:?}", collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1 i32, 2, 3];
    println!("Initial vector: {:?}", xs);

    // Insert new element at the end of the vector
    println!("Push 4 into the vector");
    xs.push(4);
    println!("Vector: {:?}", xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the number of elements currently stored in a vector
    println!("Vector length: {}", xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!("Second element: {}", xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!("Pop last element: {:?}", xs.pop());

    // Out of bounds indexing yields a panic
    println!("Fourth element: {}", xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!("Contents of xs:");
    for x in xs.iter() {
        println!("> {}", x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!("Updated vector: {:?}", xs);
}
```

------

## Collections- HashMap

All of the keys must have the same type, and all of the values must have the same type. Any type that implements the `Eq` and `Hash` traits can be a key in HashMap. This includes:

- `bool` (though not very useful since there is only two possible keys)
- `int`, `uint`, and all variations thereof
- `String` and `&str`
- You can easily implement Eq and Hash for a custom type with just one line: `#[derive(PartialEq, Eq, Hash)]`

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
// `HashMap::insert()` returns `None`
// if the inserted value is new, `Some(value)` otherwise
scores.insert(String::from("Blue"), 10);
let team_name = String::from("Blue");
let score = scores.get(&team_name);

scores.entry(String::from("Yellow")).or_insert(50); // Only Inserting a Value If the Key Has No Value

for (key, value) in &scores {
    println!("{}: {}", key, value);
}

contacts.remove(&"Yellow"); 

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
let mut scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();

// `HashMap::iter()` returns an iterator that yields 
// (&'a key, &'a value) pairs in arbitrary order.
for (name, &number) in teams.iter() {
    println!("Calling {}: {}", name, call(number)); 
}
```

### HashSet

Consider a HashSet as a HashMap where we just care about the keys ( `HashSet<T>` is, in actuality, just a wrapper around `HashMap<T, ()>`).
A HashSetâ€™s unique feature is that it is guaranteed to not have duplicate elements. Thatâ€™s the contract that any set collection fulfills. HashSet is just one implementation.

------

## Trait

- å¯ç†è§£ç‚ºå…¶ä»–èªè¨€ï¼ˆå¦‚ pythonï¼‰çš„ `Interface`
- Trait è£¡é¢çš„ method å¯ä»¥æœ‰ default å¯¦ä½œï¼Œä½†ä»–ç„¡æ³•æ“ä½œ struct çš„ inner fieldsï¼Œä¹Ÿå°±æ˜¯èªªä¸€å€‹ trait åªèƒ½å®šç¾©éœ€è¦æœ‰å“ªäº› methodï¼Œç„¡æ³•å®šç¾©éœ€è¦æœ‰å“ªäº›æˆå“¡
- trait å¯ä»¥ç¹¼æ‰¿å¦ä¸€å€‹ trait (`Supertraits`)ï¼š`trait LoudNoiseMaker: NoiseMaker`ã€‚ä»£è¡¨ `LoudNoiseMaker` ä¹Ÿè¦æœ‰ `NoiseMaker` è¦ç¯„çš„æ‰€æœ‰ method

### Handling Unsized Data

When we want to store them within another struct, traits obfuscate the original struct thus it also obfuscates the original size. Unsized values being stored in structs are handled in two ways in Rust:

- generics - Using parameterized types effectively create struct/functions known types and thus known sizes. å³ä½¿ç”¨ `impl Trait`
- indirection - Putting instances on the heap gives us a level of indirection that allow us to not have to worry about the size of the actual type and just store a pointer to it. å³ä½¿ç”¨ `Box<dyn Trait>`

### Trait bound (a.k.a. impl Trait)

```rust
fn animal_talk(a: impl Animal) {
  a.talk();
}
/* same as
fn animal_talk<T>(a: T)
where
    T: Animal
{
  a.talk();
}
*/

fn main() {
  let c = Cat{};
  let d = Dog{};
 
  animal_talk(c);
  animal_talk(d);
}
```

`impl Animal` There is no `&` there. `impl` here makes the compiler determine the type at the compile time. One that takes Dog and another that takes Cat. This is called monomorphization and will not have any runtime overhead.

For example,

```rust
fn animal () -> impl Animal {
  if (is_dog_available()) {
    return Dog {};
  }
  Cat {}
}
```

It fails! because, the types here are determined at the compile time (static dispatch) .

```rust
fn animal() -> Box<dyn Animal> {
  if (is_dog_available()) {
    return Box::new(Dog {});
  } 
    
  Box::new(Cat {})
}
```

This works!

### Static vs Dynamic Dispatch (a.k.a. dyn Trait)

`&dyn NoiseMaker` is a `trait object`. It represents a pointer to the concrete type and a pointer to a vtable of function pointers. (`Box<dyn Animal>`, `Rc<dyn Animal>` are also trait Objects.) A `trait object` is what allows us to indirectly call the correct methods of an instance. A `trait object` is a struct that holds the pointer of our instance with a `list` of function pointers to our instanceâ€™s methods. This `list` of functions is known in `C++` as a `vtable`.

```rust
struct SeaCreature {
    pub name: String,
    noise: String,
}

impl SeaCreature {
    pub fn get_sound(&self) -> &str {
        &self.noise
    }
}

trait NoiseMaker {
    fn make_noise(&self);
}

impl NoiseMaker for SeaCreature {
    fn make_noise(&self) {
        println!("{}", &self.get_sound());
    }
}

fn static_make_noise(creature: &SeaCreature) {
    // we know the real type
    creature.make_noise();
}

fn dynamic_make_noise(noise_maker: &dyn NoiseMaker) {
    // we don't know the real type
    noise_maker.make_noise();
}

fn main() {
    let creature = SeaCreature {
        name: String::from("Ferris"),
        noise: String::from("blub"),
    };
    static_make_noise(&creature);
    dynamic_make_noise(&creature);
}
```

Dynamic dispatch is slightly slower because of the pointer chasing to find the real function call.

### Derive

```rust
#[derive(PartialEq, PartialOrd)]
```

è®“ç·¨è­¯å™¨è‡ªå‹•å¹«å¿™è£œä¸Šä¸€äº›åŸºæœ¬çš„ traitï¼Œå¦‚ä¸‹

- Comparison traits: `Eq`, `PartialEq`, `Ord`, `PartialOrd`.
- `Clone`, to create `T` from `&T` via a copy. Introduce `.clone().`
- `Copy`, to give a type â€˜copy semanticsâ€™ instead of â€˜move semanticsâ€™. Introct `.copy()`.
- `Hash`, to compute a hash from `&T`.
- `Default`, to create an empty instance of a data type.
- `Debug`, to format a value using the `{:?}` formatter.
- `Add`, `Sub`, inctoduce `+`, `-` operators.
- `Drop`, you can override `.drop()`
- `Iterator`

------

## Rc, Arc, Refcell, Mutex

`Rc`. Reference Count. ç”¨ä¾†è£ä¸€å€‹ (smart) pointerï¼Œå¦‚æ­¤ä¾¿æä¾›äº† `clone()` çš„èƒ½åŠ›ï¼Œä¹Ÿå°±æ˜¯å…©å€‹ä¸åŒçš„ pointer æŒ‡å‘åŒä¸€å¡Šè³‡æ–™ã€‚
([ç‚ºä»€éº¼å« smart pointer å¯ä»¥åƒè€ƒé€™è£¡](https://tourofrust.com/95_zh-tw.html))
ç‚ºä»€éº¼éœ€è¦é€™å€‹ï¼Ÿè¨˜å¾— Rust çš„ç†å¿µï¼Œownership åŸºæœ¬ä¸Šåªæœ‰ä¸€å€‹ï¼Œæ‰€ä»¥ä¸æ˜¯ move å°±æ˜¯ borrowï¼Œå¦‚æœä¸æ˜¯ move ä¹Ÿä¸æ˜¯ borrowï¼Œé‚£éš»èƒ½ copyï¼Œé‚£å¯¦éš›ä¸Šå°±æ˜¯å…©å¡Šç¨ç«‹çš„è³‡æ–™è‡ªç„¶å¯ä»¥å„æœ‰å„çš„ ownershipã€‚è—‰ç”±å–®ä¸€æ“æœ‰è€…ï¼Œå°±å¯ä»¥é€éè©²æ“æœ‰è€…çš„ä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼Œåœ¨æ­£ç¢ºçš„æ™‚é–“åš drop å›æ”¶è¨˜æ†¶é«”ã€‚
ä½†è‹¥ç‰½æ‰¯åˆ°æŒ‡æ¨™ï¼Œå°±è®Šæˆè¦ç¢ºä¿å·²ç¶“æ²’æœ‰ä»»ä½•æŒ‡æ¨™æŒ‡åˆ°æŸä¸€å¡Šè³‡æ–™ï¼Œæ‰å¯ä»¥ dropï¼Œæ‰€ä»¥éœ€è¦å°å…¥ `Rc`ï¼Œåªè¦æ˜¯é€é Rc clone çš„æŒ‡æ¨™éƒ½æœƒè¢«è¨˜éŒ„ï¼Œç¢ºä¿åœ¨ count æ­¸é›¶æ™‚æ‰æŠŠè¨˜æ†¶é«”é‡‹æ”¾ã€‚

```rust
use std::rc::Rc;

struct Pie;

impl Pie {
    fn eat(&self) {
        println!("tastes better on the heap!")
    }
}

fn main() {
    let heap_pie = Rc::new(Pie);
    let heap_pie2 = heap_pie.clone();
    let heap_pie3 = heap_pie2.clone();

    heap_pie3.eat();
    heap_pie2.eat();
    heap_pie.eat();

    // all reference count smart pointers are dropped now
    // the heap data Pie finally deallocates
}
```

`Refcell` ç”¨ä¾†è£ä¸€å€‹ (smart) pointerï¼Œæä¾› borrow mutable/immutable references çš„èƒ½åŠ›ï¼Œå¥½è™•æ˜¯ `Refcell` è² è²¬ç¢ºä¿ *Only one mutable reference OR multiple immutable references, but not both!*
ç‚ºä»€éº¼éœ€è¦é€™å€‹ï¼Ÿå› ç‚º `Rc` åªæä¾›äº†è¤‡è£½æŒ‡æ¨™çš„èƒ½åŠ›ï¼Œè®“æˆ‘å€‘å¯ä»¥æœ‰è¤‡æ•¸å€‹æŒ‡æ¨™æŒ‡å‘åŒä¸€å¡Šè³‡æ–™ï¼Œå› æ­¤ä¹Ÿè² è²¬ç¢ºä¿äº† drop è©²è³‡æ–™è¨˜æ†¶é«”çš„æ™‚æ©Ÿã€‚ä½†ä»–æ²’æœ‰ç¢ºä¿ mutablility çš„éƒ¨åˆ†ï¼ŒåŒæ™‚æœ‰å…©å€‹æ´»è‘—çš„ mutable references æŒ‡å‘åŒä¸€å¡Šè³‡æ–™æ˜¯å±éšªçš„ã€‚

å¦‚ä¸‹é¢é€™ä¾‹å­ï¼Œ`ferris` å’Œ `sarah` çš„ pie å…¶å¯¦æ˜¯æŒ‡å‘åŒä¸€å¡Šè³‡æ–™ï¼Œä¸¦éæ“æœ‰å„è‡ªçš„ pie

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Pie {
    slices: u8,
}

impl Pie {
    fn eat_slice(&mut self, name: &str) {
        println!("{} took a slice!", name);
        self.slices -= 1;
    }
}

struct SeaCreature {
    name: String,
    pie: Rc<RefCell<Pie>>,
}

impl SeaCreature {
    fn eat(&self) {
        // use smart pointer to pie for a mutable borrow
        let mut p = self.pie.borrow_mut();
        // take a bite!
        p.eat_slice(&self.name);
    }
}

fn main() {
    let pie = Rc::new(RefCell::new(Pie { slices: 8 }));
    // ferris and sarah are given clones of smart pointer to pie
    let ferris = SeaCreature {
        name: String::from("ferris"),
        pie: pie.clone(),
    };
    let sarah = SeaCreature {
        name: String::from("sarah"),
        pie: pie.clone(),
    };
    ferris.eat();
    sarah.eat();

    let p = pie.borrow();
    println!("{} slices left", p.slices);
}
```

å¦‚æœèªªå…©å€‹ pointer æœƒç”±ä¸åŒçš„ thread æ“æœ‰ï¼Œ`Rc` å°±è¦æ›æˆä½¿ç”¨ `Arc`

ä¸”å¦‚æœèªªæœƒè·¨ threadï¼Œ`Refcell` å°±è®Šæˆè¦ä½¿ç”¨ `Mutex`ã€‚æ‰€ä»¥ç¶“å¸¸çœ‹åˆ°çš„çµ„åˆå°±æ˜¯

- within thread: `Rc<RefCell<...>>`
- across thread: `Arc<Mutex<...>>`

æ­¤æ™‚å¯èƒ½æœƒç”¢ç”Ÿä¸€å€‹ç–‘å•ï¼Œåœ¨è·¨ thread ç‹€æ³ä¸‹æœ‰ data racing çš„é¢¨éšªé€™æˆ‘å€‘çŸ¥é“ï¼Œå› æ­¤éœ€è¦å°å…¥ Arc å’Œ Mutex åˆç†ï¼›ä½†è‹¥ç‚º single thread çš„ç‹€æ³ï¼Œéœ€è¦ Rc ä¾†çŸ¥é“ drop æ™‚æ©Ÿå¯ä»¥ç†è§£ï¼Œä¸éç‚ºä½•éœ€è¦ Refcellï¼Ÿæ—¢ç„¶åªæœ‰ single threadï¼Œæ€éº¼å¯èƒ½æœƒæœ‰åŒä¸€æ™‚é–“å­˜åœ¨å…©å€‹ mutable reference çš„ç‹€æ³ï¼Ÿ
æœƒæœ‰é€™å€‹ç–‘å•å¯èƒ½æ˜¯å¿½ç•¥äº† Rust ç•¢ç«Ÿé‚„æ˜¯ä¸€å€‹èˆ‡ C ç›¸åŒå±¤ç´šçš„èªè¨€ï¼Œä»–æ˜¯å¯ä»¥æä¾›è¨˜æ†¶é«”ä½å€ç­‰ç´šçš„æ“ä½œçš„ã€‚ä¹Ÿå°±æ˜¯èªªä½ å¯ä»¥æ‹¿åˆ°ä¸€å€‹ instance çš„ addressï¼Œä¸¦é€éè©² address å°è©² instance æ“ä½œã€‚å•é¡Œæ˜¯ï¼Œè‹¥é€éé€™æ¨£çš„æ–¹å¼ï¼Œé€™äº›æ“ä½œå°±æ˜¯ä¸æ˜¯ compiler å¯ä»¥è¿½è¹¤åˆ°ä¸¦ä¸”ä»‹å…¥è¦ç¯„çš„ï¼Œè‡ªç”±ç•¶ç„¶æ˜¯è‡ªç”±ï¼Œä½†é¢¨éšªå°±è¦è‡ªè² ã€‚é€™ç¨®æ“ä½œåœ¨ Rust å«åš `Unsafe`ï¼Œæ¯”å¦‚ dereferencing a raw pointer æ“ä½œï¼Œåªè¦ç”¨ `Unsafe` block åŒ…èµ·ä¾†ï¼ŒRust compiler å°±æœƒä¸ç®¡ä½ è£¡é¢çš„æ“ä½œã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘å€‘å°æ–¼ pointer é€™ç¨®é€éæŒ‡æ¨™å»æ“ä½œä¸€å¡Šè³‡æ–™çš„è¡Œç‚ºï¼Œéƒ½é€é `Rc`, `RefCell` é€™ç¨® wrapperï¼Œé‚£å°±å¯ä»¥è®“ compiler ä»‹å…¥å¹«æˆ‘å€‘ç¢ºä¿æˆ‘å€‘å°æ–¼æŒ‡æ¨™çš„ä½¿ç”¨å®‰å…¨ï¼Œé †å¸¶ä¸€æï¼Œå¯ä»¥æƒ³è¦‹é€™å€‹ wrapper çš„å…§éƒ¨å¯¦ä½œçµ‚ç©¶é‚„æ˜¯æœƒæœ‰ Unsafe blockï¼Œåªæ˜¯èªªä»–åœ¨å¤–åŒ…äº†ä¸€å±¤ï¼ŒåŠ å…¥äº†ä¸€äº› metadataï¼Œè®“ç·¨è­¯å™¨å¯ä»¥è—‰ç”±é€™äº› metadata æ­¤ä¾†å¹«åŠ©æˆ‘å€‘è¿½è¹¤å’Œç¢ºä¿ã€‚

## Conversion

é€é impl `From` æˆ– `Into` é€™å…©å€‹ traitsï¼Œå¯ä»¥è®“ä½ çš„ type æ“æœ‰ `::from()` æˆ– `::into()` çš„æ–¹æ³•ä¾†åšå‹åˆ¥è½‰æ›

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}
```

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into();
    println!("My number is {:?}", num);
}
```

`TryFrom`/`TryInto` traits are used for fallible conversions, and as such, return Results.

```rust
use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
```

------

## Debug

### print Display

```rust
use std::fmt; // Import the `fmt` module.

// Define a structure named `List` containing a `Vec`.
struct List(Vec<i32>);

impl fmt::Display for List {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Extract the value using tuple indexing,
        // and create a reference to `vec`.
        let vec = &self.0;

        write!(f, "[")?;

        // Iterate over `v` in `vec` while enumerating the iteration
        // count in `count`.
        for (count, v) in vec.iter().enumerate() {
            // For every element except the first, add a comma.
            // Use the ? operator to return on errors.
            if count != 0 { write!(f, ", ")?; }
            write!(f, "{}", v)?;
        }

        // Close the opened bracket and return a fmt::Result value.
        write!(f, "]")
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!("{}", v);
}
```

------

## Module

- ä¸€å€‹ *Program* æœ‰ä¸€å€‹ `main.rs`ï¼Œè£¡é¢å¯¦ä½œ `main()` æ–¹æ³•

- ä¸€å€‹ *Lib* æœ‰ä¸€å€‹ root module `lib.rs`ï¼Œå¯ä»¥å†åŒ…å«æ•¸å€‹ module ä½œç‚º submodule

- *Program* æˆ–è€… *Lib* éƒ½ç¨±ç‚ºä¸€å€‹ *crate*ï¼Œæ˜¯ä¸€å€‹ compilation unitï¼Œä¹Ÿå¯ä»¥å°æ‡‰åˆ°å…¶ä»–èªè¨€ package çš„æ¦‚å¿µï¼Œæ˜¯ä¸€å€‹å°å…¥ç¬¬ä¸‰æ–¹å‡½å¼åº«çš„å–®ä½ï¼Œé€é `use` ä¾†å°å…¥ namespace

- ä¸€å€‹

   

  (Sub)Module

   

  æœ‰å…©å€‹æ–¹å¼ï¼Œå–æ±ºæ–¼ code å¤§å°ï¼Œæ¯”å¦‚å‰µä¸€å€‹ submodule foo

  - `./foo.rs`ï¼šæ‰€æœ‰è©² foo module çš„ code éƒ½åœ¨é€™å€‹ rs file è£¡
  - `./foo/mod.rs`ï¼šfoo é€™å€‹è³‡æ–™å¤¾åº•ä¸‹é‚„å¯ä»¥æœ‰å…¶ä»– rs fileï¼Œä»–å€‘åˆèµ·ä¾†å®Œæ•´ foo é€™å€‹ module

- access ä¸€å€‹ (sub)module èˆ‡ file path å¼·ç›¸é—œï¼Œä¸¦ä¸”æœ‰ä¸‰å€‹é—œéµå­—å¯ä½œç‚ºèµ·é»

  - `crate` - the root module of your crate
  - `super` - the parent module of your current module
  - `self` - the current module

æ‰€ä»¥ä¸€å€‹ crate å¯èƒ½å°±é•·é€™æ¨£

```bash
â”œâ”€â”€ lib.rs
â”œâ”€â”€ main.rs
â”œâ”€â”€ submod1.rs
â””â”€â”€ submod2
    â”œâ”€â”€ file1.rs
    â”œâ”€â”€ file2.rs
    â”œâ”€â”€ mod.rs
    â””â”€â”€ submod3
        â”œâ”€â”€ file3.rs
        â””â”€â”€ mod.rs
```

é™¤äº† file å±¤ç´šçš„ module åŠƒåˆ†ï¼Œå–®ä¸€ rs è£¡é¢ä¹Ÿå¯ä»¥ç”¨ `mod` å®šç¾©è‡ªå·±çš„ submodule

### share lib

```bash
$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
```

`rary` is actuaylly refer to the whole acssociated `crate`. It does not imply only build single `rary.rs` file.

To using a Library

```rust
// extern crate rary; // May be required for Rust 2015 edition or earlier
fn main() {
    rary::public_function();
}
```

------

## Error Handling

```
Option` å’Œ `Result` éƒ½æœ‰ `unwrap()` å’Œ `?` å¯ä»¥ä½¿ç”¨ï¼ŒåŸºæœ¬ä¸Šä¸€å€‹ function çš„ return å€¼å»ºè­°å°±æ˜¯å¾é€™å…©è€…é¸å…¶ä¸€ï¼Œä¸¦ä¸”ä¸å»ºè­° caller ç›´æ¥ä½¿ç”¨ `unwarp()` è™•ç†ï¼Œå› ç‚ºé€™æœƒé€ æˆ `panic
```

### Option

`map()` æ˜¯ `Option` æä¾›çš„æ–¹æ³•ï¼Œåƒæ•¸æ˜¯ä¸€å€‹ `closure`ï¼Œä»–å…¶å¯¦å°±æ˜¯åœ¨é€™ç¨®æƒ…å¢ƒä¸­ match èªæ³•çš„ç°¡åŒ–ï¼Œå¦‚ä¸‹ç¯„ä¾‹

```rust
// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option<Peeled>) -> Option<Chopped> {
    match peeled {
        Some(Peeled(food)) => Some(Chopped(food)),
        None               => None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option<Chopped>) -> Option<Cooked> {
    chopped.map(|Chopped(food)| Cooked(food))
}
/* instead of
fn cook(chopped: Option<Chopped>) -> Option<Cooked> {
    match chopped {
        Some(Chopped(food)) => Some(Cooked(food)),
        None => None
    }
}
*/
```

åœ¨ä¸²å…©çš„éƒ½æ˜¯ return Option çš„ function çš„æ™‚å€™ï¼Œå¦‚æœå…©å€‹ function çš„ return Option<Type> ç›¸åŒï¼Œé‚£å¯ä»¥ç›´æ¥ä½¿ç”¨ `?`ï¼›è‹¥ä¸åŒï¼Œå‰‡è¦åšè½‰æ›ï¼Œä½†æ‡‰æ›æˆä½¿ç”¨ `Option` çš„ `and_then()` æ–¹æ³•ï¼Œå› ç‚ºè‹¥ä½¿ç”¨ `map()`ï¼Œæœƒå¤šä¸€å±¤ Optionï¼Œå› ç‚º `map()` åŒ…å«ä¸€å€‹ç°¡åŒ–æ˜¯æœƒå¹«ä½ åŠ ä¸Š `Some()` è£èµ·ä¾†

ä¸‹é¢é€™å€‹ç¯„ä¾‹å°±æ˜¯ä¸² `have_recipe()` å’Œ `have_ingredients()` å…©å€‹ function

```rust
#[derive(Debug, Clone)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

fn have_ingredients(food: Food) -> Option<Food> {
    match food {
        Food::Sushi => None,
        _           => Some(food),
    }
}

fn have_recipe(food: Food) -> Option<Food> {
    match food {
        Food::CordonBleu => None,
        _                => Some(food),
    }
}

fn cookable_v2(food: Food) -> Option<Food> {
    have_recipe(food).and_then(have_ingredients)
    // instead of have_recipe(food).map(|f| have_ingredients(f))
    //   becauset his will return Option<Option<Food>>
}
```

#### as_ref(), as_mut()

```rust
pub const fn as_ref(&self) -> Option<&T>
```

Converts from `&Option<T>` to `Option<&T>`.

é€™æ±è¥¿çš„é‡è¦æ€§åœ¨æ–¼å¯ä»¥ç”¢ç”Ÿä¸€å€‹è¢«åŒ…åœ¨ Option è£¡é¢çš„æ±è¥¿çš„ reference è€Œä¸ç”¨ take ownership

```rust
pub fn as_mut(&mut self) -> Option<&mut T>
```

Converts from `&mut Option<T>` to `Option<&mut T>`.

```rust
let mut x = Some(2);
match x.as_mut() {
    Some(v) => *v = 42,
    None => {},
}
assert_eq!(x, Some(42));
```

æ³¨æ„è½‰æ›éä¹‹å¾Œéƒ½é‚„æ˜¯åŒ…åœ¨ `Option` è£¡é¢

> `Option`, `Box`, `Result` ä¸‰ç¨®é¡å‹æ‰æœ‰æ”¯æŒé è¨­ï¼Œå…¶ä»–è¦å¯¦ä½œ `AsRef` trait

```rust
fn main() {
    let mut a = Some(Box::new(5));
    let p1 = a.as_ref(); // p æ²’æœ‰ take ownership å–”. 5 çš„ ownership é‚„æ˜¯åœ¨ a

    println!("{:?}", a);
    println!("{:?}", p1);
    
    let p11 = p1.unwrap();
    println!("p11:{:?}", p11); // å¯ä»¥é€é p11 æ‹¿åˆ° 5
    println!("a:{:?}", a);
    
    // ä»¥ä¸‹æ˜¯çŠ¯ä¸€äº›å¦‚æœä¸ä½¿ç”¨ as_ref()ï¼Œæœƒé‡åˆ°çš„ ownership å•é¡Œ
    
    let p2 = &mut a;
    //let p22 = p2.unwrap(); // cannot move out of `*p2` which is behind a shared reference

    /*let p22 = match *p2 { // cannot move out of `p2.0` which is behind a mutable reference
        Some(v) => *v, // v: data moved here
        None => 0
    };*/
    
    let p22 = match *p2 {
        Some(ref v) => **v, // è™•ç†ä¸Šé¢éŒ¯èª¤çš„æ–¹æ³•å°±æ˜¯ç”¨ ref ä¾†æ¥
        None => 0
    };
    println!("p22:{:?} {:p}", p22, &p22);
    //println!("a:{:?}", a); // cannot borrow `a` as immutable because it is also borrowed as mutable
    // é€™å€‹æ™‚å€™ 5 çš„ ownership éƒ½é‚„æ˜¯åœ¨ aï¼Œæ‰€ä»¥ç•¶é€™è£¡è¦ç”¨ a å°±æœƒæœ‰é€™å€‹è¡çª

    let p23 = match p2.take() { // æˆ–è€…è¦æŠŠåŸæœ¬ a çš„ ownership take éä¾†åˆ° p2ï¼Œp2 æ‰æœ‰æ¬ŠæŠŠè£¡é¢çš„æ±è¥¿ç§»å» v
        Some(v) => *v,
        None => 0
    };
    println!("p23:{:?} {:p}", p23, &p23);
    println!("a:{:?}", a); // å› ç‚ºåŸæœ¬ a çš„ ownership å·²ç¶“è¢«è½‰ç§»å» p2ï¼Œæ‰€ä»¥ a å·²ç¶“è®Š None è‡ªç„¶ä¹Ÿä¸å†æœ‰è¡çª
}
```

### Result

å°æ–¼ä¸€å€‹ module è€Œè¨€ï¼Œæœ€å®Œæ•´çš„ erro propagation åšæ³•ç‚º

1. å®šç¾©è‡ªå·±çš„ error å‹åˆ¥ï¼Œæ¯”å¦‚ `enum MyError {}`ï¼Œåˆ—èˆ‰å„ç¨®å¯èƒ½ç”¢ç”Ÿçš„ errorï¼ŒåŒæ™‚ä¹ŸåŒ…å«ç•¶ä½¿ç”¨åˆ°å…¶ä»– module æ™‚ï¼Œå„å€‹å…¶ä»– moduel çš„ error æ­¸é¡åˆ° MyError ä¸­çš„å…¶ä¸­ä¸€å€‹å¯èƒ½å€¼
2. `impl fmt::Display for MyError`
3. `impl error::Error for MyError` å¯¦ä½œ `source()` æ–¹æ³•ï¼Œ`source()` æ–¹æ³•ä½¿è·¨æŠ½è±¡å±¤çš„ç‹€æ³è®“ä¸Šå±¤ module ä¹Ÿèƒ½å–å¾—æ›´å¤šå…¶*ä¸‹ä¸‹å±¤* module çš„ error ç´°ç¯€çš„å¯èƒ½æ€§ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œé€™ä¸€æ­¥å¯ä»¥ä¸åšï¼Œä½†ä¸åšçš„çµæœå°±æ˜¯ï¼Œå‡è¨­ æŸA ä½¿ç”¨ä½ çš„ moduleï¼Œç•¶ä½ çš„ module ç™¼ç”Ÿäº† call å¦ä¸€å€‹ moduleB æ™‚ç”¢ç”Ÿçš„è©² moduleB çš„ error å› æ­¤å°è‡´ä½ çš„ moduel ä¹Ÿ report error çµ¦ æŸAï¼ŒæŸA æ‰€èƒ½å¾—åˆ°çš„å”¯ä¸€è³‡è¨Šå°±æ˜¯ä½ ç¿»è­¯éçš„ errorï¼Œç„¡æ³•é€²ä¸€æ­¥é€é source() é€²åˆ° moduleB è£¡å»æå–æ›´å¤šè³‡è¨Š
4. `impl From<OtherModuleErrorType> for MyError` è®“ `?` å¯ç”¨ã€‚ä¹Ÿå¯ä»¥ä¸åšï¼Œè‹¥ä¸åšå°±è®Šæˆç•¶è¦ call å…¶ä»– module æ™‚ï¼Œè¦ç”¨ `method_provided_by_another_module().ok_or(MyError::SomeTranslatedError)?` ä¾†åšè½‰æ›ã€‚ç›¸ç•¶æ–¼ `?` å…¶å¯¦å°±æ˜¯æœƒå»æ‰¾ `From` æ–¹æ³•å­˜ä¸å­˜åœ¨ï¼Œè‹¥å­˜åœ¨å°±æœƒä¾æ“š From çš„å…§å®¹åšè½‰æ›

ä¸‹é¢ç¯„ä¾‹

```rust
fn double_first(vec: Vec<&str>) -> i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::<i32>().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {}", double_first(numbers));

    println!("The first doubled is {}", double_first(empty));
    // Error 1: the input vector is empty

    println!("The first doubled is {}", double_first(strings));
    // Error 2: the element doesn't parse to a number
}
```

å‡è¨­é€™å°±æ˜¯æˆ‘å€‘çš„ moduleï¼Œè£¡é¢ç”¨äº†å…¶ä»–å…©å€‹ moduel çš„æ–¹æ³• `first()` å’Œ `parse()`ï¼Œä»–å€‘éƒ½æœƒç”¢ç”Ÿå„è‡ªå®šç¾©çš„ error typeã€‚ä¸‹é¢å°±æ˜¯ä¾æ“šä¸Šè¿°çš„æ­¥é©Ÿæ”¹å¯«çš„çµæœï¼Œæˆ‘å€‘å®šç¾©äº†è‡ªå·±çš„ error type `DoubleError` æŠŠä»–å€‘åŒ…èµ·ä¾†ä¸¦å€‹åˆ¥ç¿»è­¯

```rust
use std::error;
use std::error::Error as _;
use std::num::ParseIntError;
use std::fmt;

type Result<T> = std::result::Result<T, DoubleError>;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            DoubleError::EmptyVec =>
                write!(f, "please use a vector with at least one element"),
            // The wrapped error contains additional information and is available
            // via the source() method.
            DoubleError::Parse(..) =>
                write!(f, "the provided string could not be parsed as int"),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        match *self {
            DoubleError::EmptyVec => None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) => Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From<ParseIntError> for DoubleError {
    fn from(err: ParseIntError) -> DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec<&str>) -> Result<i32> {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // Here we implicitly use the `ParseIntError` implementation of `From` (which
    // we defined above) in order to create a `DoubleError`.
    let parsed = first.parse::<i32>()?;

    Ok(2 * parsed)
}

fn print(result: Result<i32>) {
    match result {
        Ok(n)  => println!("The first doubled is {}", n),
        Err(e) => {
            println!("Error: {}", e);
            if let Some(source) = e.source() {
                println!("  Caused by: {}", source);
            }
        },
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
```

------

## Multithreading

```rust
use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender<T>` and the `Receiver<T>`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!("thread {} finished", id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect("oops! the child thread panicked");
    }

    // Show the order in which the messages were sent
    println!("{:?}", ids);
}
```

------

## exec

```rust
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &'static str =
"the quick brown fox jumped over the lazy dog\n";

fn main() {
    // Spawn the `wc` command
    let process = match Command::new("wc")
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) => panic!("couldn't spawn wc: {}", why),
        Ok(process) => process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option<ChildStdin>`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) => panic!("couldn't write to wc stdin: {}", why),
        Ok(_) => println!("sent pangram to wc"),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option<ChildStdout>` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Err(why) => panic!("couldn't read wc stdout: {}", why),
        Ok(_) => print!("wc responded with:\n{}", s),
    }
}
```

If youâ€™d like to wait for a process::Child to finish, you must call Child::wait, which will return a `process::ExitStatus`.

```rust
use std::process::Command;

fn main() {
    let mut child = Command::new("sleep").arg("5").spawn().unwrap();
    let _result = child.wait().unwrap();

    println!("reached end of main");
}
```

------

## Argument parsing

```rust
use std::env;

fn increase(number: i32) {
    println!("{}", number + 1);
}

fn decrease(number: i32) {
    println!("{}", number - 1);
}

fn help() {
    println!("usage:
match_args <string>
    Check whether given string is the answer.
match_args {{increase|decrease}} <integer>
    Increase or decrease given integer by one.");
}

fn main() {
    let args: Vec<String> = env::args().collect();

    match args.len() {
        // no arguments passed
        1 => {
            println!("My name is 'match_args'. Try passing some arguments!");
        },
        // one argument passed
        2 => {
            match args[1].parse() {
                Ok(42) => println!("This is the answer!"),
                _ => println!("This is not the answer."),
            }
        },
        // one command and one argument passed
        3 => {
            let cmd = &args[1];
            let num = &args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) => {
                    n
                },
                Err(_) => {
                    eprintln!("error: second argument not an integer");
                    help();
                    return;
                },
            };
            // parse the command
            match &cmd[..] {
                "increase" => increase(number),
                "decrease" => decrease(number),
                _ => {
                    eprintln!("error: invalid command");
                    help();
                },
            }
        },
        // all the other cases
        _ => {
            // show a help message
            help();
        }
    }
}
```

------

## References

- [Rust èªè¨€ä¹‹æ—…](https://tourofrust.com/TOC_zh-tw.html)
- [Rust book](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/index.html)
- [dyn , impl and Trait Objects â€” Rust](https://cotigao.medium.com/dyn-impl-and-trait-objects-rust-fd7280521bea)


From: A Po
Author: Chris Chung
Link: https://chungchris.github.io/2021/06/30/software/language/rust-note/
æœ¬æ–‡ç« æˆåŠŸæ¬Šæ­¸ä½œè€…æ‰€æœ‰ï¼Œå½¢å¼çš„è½‰è¼‰éƒ½è«‹è¨»æ˜å‡ºè™•ã€‚