# Atomic 原子操作範例

這個資料夾包含了 Rust 原子操作的範例，展示如何使用無鎖的高效能並行操作。

## 📁 範例檔案

### 1. `basic_atomic_counter.rs` - 基本原子計數器
- **目的**: 演示原子操作的基本用法和效能優勢
- **概念**: AtomicI32 的基本操作和效能比較
- **學習重點**:
  - 原子操作的無鎖特性
  - 與 Mutex 的效能比較
  - fetch_add 等基本原子操作

**執行指令**:
```bash
cargo run --example basic_atomic_counter
```

### 2. `atomic_flags.rs` - 原子旗標控制
- **目的**: 展示如何使用原子布林值控制執行緒
- **概念**: AtomicBool 在執行緒協調中的應用
- **學習重點**:
  - 執行緒啟動/停止控制
  - 生產者-消費者協調
  - 事件驅動的執行緒通訊

**執行指令**:
```bash
cargo run --example atomic_flags
```

### 3. `compare_and_swap.rs` - Compare-and-Swap 操作
- **目的**: 展示 CAS 操作的強大功能
- **概念**: 無鎖演算法的核心操作
- **學習重點**:
  - CAS 操作的原理和使用
  - 無鎖資料結構的基礎
  - 重試機制和錯誤處理

**執行指令**:
```bash
cargo run --example compare_and_swap
```

## 🎯 核心概念

### 原子操作 (Atomic Operations)
- **無鎖**: 不需要 Mutex 等鎖定機制
- **線性化**: 操作看起來是瞬間完成的
- **硬體支援**: 直接對應 CPU 指令

### 常用原子類型
- `AtomicBool` - 原子布林值，適合旗標控制
- `AtomicI32/AtomicI64` - 原子整數，適合計數器
- `AtomicUsize` - 原子無符號整數，適合索引/大小
- `AtomicPtr<T>` - 原子指標，適合無鎖資料結構

### 記憶體順序 (Memory Ordering)
- `Relaxed` - 最寬鬆，只保證原子性
- `Acquire` - 讀取時的獲取語意
- `Release` - 寫入時的釋放語意
- `SeqCst` - 順序一致性，最強但可能較慢

### Compare-and-Swap (CAS)
- 原子地比較並可能更新值
- 無鎖演算法的基石
- 提供 `compare_exchange` 和 `compare_exchange_weak`

## ⚡ 效能特點

### 優勢
- **高效能**: 通常比 Mutex 更快
- **無死鎖**: 不會造成死鎖問題
- **可擴展性**: 在多核心系統上表現更好

### 適用場景
- 簡單的數值操作（計數器、旗標）
- 高頻率的短操作
- 無鎖資料結構實現
- 效能關鍵的系統元件

### 限制
- 只適用於簡單資料類型
- 複雜操作需要 CAS 迴圈
- 記憶體順序需要仔細考慮

## 🚀 下一步

完成這些範例後，可以繼續學習：
- 無鎖資料結構設計
- 記憶體順序的深入理解
- 高效能並行演算法
- 系統程式設計模式

## 💡 實戰建議

1. **從簡單開始**: 先掌握基本的 fetch_add、load、store
2. **理解記憶體順序**: 大多數情況下 `SeqCst` 是安全選擇
3. **效能測試**: 在實際應用中測量原子操作 vs Mutex 的效能
4. **避免過度優化**: 只在確實需要時才使用原子操作