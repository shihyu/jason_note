# PART I 基礎部分 - 量化語境下的Rust編程基礎 (Fundamentals of Rust Programming with the context of Quantitative Trading)

----------------------------------------

# Chapter 1 -  Rust 語言入門101

開始之前我們不妨做一些簡單的準備工作。

## 1.1 在類Unix操作系統(Linux,MacOS)上安裝 rustup

打開終端並輸入下面命令：

```shell
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

只要出現下面這行：

```bash
Rust is installed now. Great! 
```

就完成 Rust 安裝了。



> **[建議]** 量化金融從業人員為什麼應該嘗試接觸使用Linux？
>
> 1. 穩定性：Linux系統被認為是非常穩定的。在金融領域，系統的穩定性和可靠性至關重要，因為任何技術故障都可能對業務產生重大影響。因此，Linux成為了一個被廣泛接受的選擇。
> 2. 靈活性：Linux的靈活性允許用戶根據需求定製系統。在量化金融領域，可能需要使用各種不同的軟件和工具來處理數據、進行模型開發和測試等。Linux允許用戶更靈活地使用這些工具，並通過修改源代碼來提高性能。
> 3. 安全性：Linux的開源開發方式意味著錯誤可以更快地被暴露出來，這讓技術人員可以更早地發現並解決潛在的安全隱患。此外，Linux對可能對系統產生安全隱患的遠程程序調用進行了限制，進一步提高了系統的安全性。
> 4. 可維護性：Linux系統的維護要求相對較高，需要一定的技術水平。但是，對於長期運行的功能需求，如備份歷史行情數據和實時行情數據的入庫和維護，Linux系統提供了高效的命令行方式，可以更快速地進行恢復和維護。



## 1.2 安裝 C 語言編譯器 [ 可選 ] 

Rust 有的時候會依賴 libc 和鏈接器 linker， 比如PyTorch的C bindings的Rust版本tch.rs 就自然依賴C。因此如果遇到了提示鏈接器無法執行的錯誤，你需要再手動安裝一個 C 語言編譯器：

**MacOS **：

```bash
$ xcode-select --install
```

**Linux **：
如果你使用 Ubuntu，則可安裝 build-essential。
其他 Linux 用戶一般應按照相應發行版的文檔來安裝 gcc 或 clang。

## 1.3 維護 Rust 工具鏈

**更新Rust**

```bash
$ rustup update
```

**卸載Rust**

```bash
$ rustup self uninstall
```

**檢查Rust安裝是否成功**

檢查rustc版本

```bash
$ rustc -V 
rustc 1.72.0 (5680fa18f 2023-08-23)
```

檢查cargo版本

```bash
$ cargo -V 
cargo 1.72.0 (103a7ff2e 2023-08-15)
```

## 1.4 Nightly 版本

作為一門編程語言，Rust非常注重代碼的穩定性。為了達到"穩定而不停滯",Rust的開發遵循一個列車時刻表。也就是說，所有的開發工作都在Rust存儲庫的主分支上進行。Rust有三個發佈通道：

1. **夜間(Nightly)**
2. **測試(Beta)**
3. **穩定(Stable)**

以下是開發和發佈流程的示例：假設Rust團隊正在開發Rust 1.5的版本。該版本在2015年12月發佈，但我們可以用這個版本號來說明。Rust添加了一個新功能：新的提交被合併到主分支。每天晚上，都會生成一個新的Rust夜間版本。

對於Rust Nightly來說, 幾乎每天都是發佈日, 這些發佈是由Rust社區的發佈基建(release infrastructure)自動創建的。

```text
nightly: * - - * - - *
```

每六個禮拜， `beta` 分支都會從被夜間版本使用的 `master` 分支中分叉出來, 單獨發佈一次。

```
nightly: * - - * - - *
                     |
beta:                *
```

大多數Rust開發者主要使用 **Stable** 通道，但那些想嘗試實驗性新功能的人可以使用 **Nightly** 或 **Beta**。

Rust 編程語言的 Nightly 版本是不斷更新的。有的時候為了用到 Rust 的最新的語言特性，或者安裝一些依賴 Rust Nightly的軟件包，我們會需要切換到 Nightly。

但是請注意，Nightly版本包含最新的功能和改進，所以也可能不夠穩定，在生產環境中使用時要小心。

**安裝Nightly版本**：

```shell
$ rustup install nightly
```

**切換到Nightly版本**：

```shell
$ rustup default nightly
```

**更新Nightly版本**：

```shell
$ rustup update nightly
```

**切換回Stable版本：**

```shell
$ rustup default stable
```

## 1.5 cargo的使用

`cargo` 是 Rust 編程語言的官方構建工具和包管理器。它是一個非常強大的工具，用於幫助開發者創建、構建、測試和發佈 Rust 項目。以下是一些 `cargo` 的主要功能：

1. **項目創建**：
   `cargo new`  可以創建新的 Rust 項目，包括創建項目的基本結構、生成默認的源代碼文件和配置文件。

2. **依賴管理**：
   `cargo` 管理項目的依賴項。你可以在項目的 `Cargo.toml` 文件中指定依賴項，然後運行 `cargo build` 命令來下載和構建這些依賴項。這使得添加、更新和刪除依賴項變得非常容易。

3. **構建項目**：
   通過運行 `cargo build` 命令，你可以構建你的 Rust 項目。`cargo` 會自動處理編譯、鏈接和生成可執行文件或庫的過程。

4. **添加依賴**：
   使用 cargo add 或編輯項目的 Cargo.toml 文件來添加依賴項。cargo add 命令會自動更新 Cargo.toml 並下載依賴項。
   例如，要添加一個名為 "rand" 的依賴，可以運行：cargo add rand

5. **執行預先編纂的測試**：

   `cargo` 允許你編寫和運行測試，以確保代碼的正確性。你可以使用 `cargo test` 命令來運行測試套件。

6. **文檔生成**：

   `cargo` 可以自動生成項目文檔。通過運行 `cargo doc` 命令，如果我們的 **文檔註釋** (以///或者//！起始的註釋) 符合Markdown規範，你可以生成包括庫文檔和文檔註釋的 HTML 文檔，以便其他開發者查閱。

7. **發佈和分發**：

   執行`cargo login` 登陸 crate.io 後，再在項目文件夾執行`cargo publish` 可以幫助你將你的 Rust 庫發佈到 [crates.io](https://crates.io/)，Rust 生態系統的官方包倉庫。這使得分享你的代碼和庫變得非常容易。

8. **列出依賴項**：

  使用 cargo tree 命令可以查看項目的依賴項樹，以瞭解你的項目使用了哪些庫以及它們之間的依賴關係。例如，要查看依賴項樹，只需在項目目錄中運行：`cargo tree`



## 1.6 cargo 和 rustup的區別

`rustup` 和`cargo` 是 Rust 生態系統中兩個不同的工具，各自承擔著不同的任務：

`rustup` 和 `cargo` 是 Rust 生態系統中兩個不同的工具，各自承擔著不同的任務：

 **`rustup`**：

   - `rustup` 是 Rust 工具鏈管理器。它用於安裝、升級和管理不同版本的 Rust 編程語言。
   - 通過 `rustup`，你可以輕鬆地在你的計算機上安裝多個 Rust 版本，以便在項目之間切換。
   - 它還管理 Rust 工具鏈的組件，例如 Rust 標準庫、Rustfmt(用於格式化代碼的工具)等。
   - `rustup` 還提供了一些其他功能，如設置默認工具鏈、卸載 Rust 等。

**`cargo`**：

   - `cargo` 是 Rust 的構建工具和包管理器。它用於創建、構建和管理 Rust 項目。
   - `cargo` 可以創建新的 Rust 項目，添加依賴項，構建項目，運行測試，生成文檔，發佈庫等等。
   - 它提供了一種簡便的方式來管理項目的依賴和構建過程，使得創建和維護 Rust 項目變得容易。
   - 與構建相關的任務，如編譯、運行測試、打包應用程序等，都可以通過 `cargo` 來完成。

總之，`rustup` 主要用於管理 Rust 的版本和工具鏈，而 `cargo` 用於管理和構建具體的 Rust 項目。這兩個工具一起使得在 Rust 中開發和維護項目變得非常方便。



## 1.7 用cargo創立並搭建第一個項目

### 1. 用 `cargo new `新建項目

```shell
$ cargo new_strategy # new_strategy 是我們的新crate 
$ cd new_strategy
```

第一行命令新建了名為 *new_strategy* 的文件夾。我們將項目命名為 *new_strategy*，同時 cargo 在一個同名文件夾中創建樹狀分佈的項目文件。

進入 *new_strategy* 文件夾, 然後鍵入`ls`列出文件。將會看到 cargo 生成了兩個文件和一個目錄：一個 *Cargo.toml* 文件，一個 *src* 目錄，以及位於 *src* 目錄中的 *main.rs* 文件。

此時cargo在 *new_strategy* 文件夾初始化了一個 Git 倉庫，並帶有一個 *.gitignore* 文件。

> 注意: cargo是默認使用git作為版本控制系統的(version control system， VCS)。可以通過 `--vcs` 參數使 `cargo new` 切換到其它版本控制系統，或者不使用 VCS。運行 `cargo new --help` 查看可用的選項。

### 2. 編輯 `cargo.toml`

現在可以找到項目文件夾中的 *cargo.toml* 文件。這應該是一個cargo 最小化工作樣本(MWE, Minimal Working Example)的樣子了。它看起來應該是如下這樣：

```toml
[package]
name = "new_strategy"
version = "0.1.0" # 此軟件包的版本
edition = "2021" # rust的規範版本，成書時最近一次更新是2021年。
[dependencies]

```

第一行 `[package]`，是一個 section 的標題，表明下面的語句用來配置一個包(package)。隨著我們在這個文件增加更多的信息，還將增加其他 sections。

第二個 section 即`[dependencies]` ，一般我們在這裡填項目所依賴的任何包。

在 Rust 中，代碼包被稱為 *crate*。我們把crate的信息填寫在這裡以後，再運行cargo build, cargo就會自動下載並構建這個項目。雖然這個項目目前並不需要其他的 crate。

現在打開 new_strategy/**src**/main.rs* 看看：

```rust
fn main() {
    println!("Hello, world!");
}
```

cargo已經在 `src` 文件夾為我們自動生成了一個 Hello, world! 程序。雖然看上去有點越俎代庖，但是這也是為了提醒我們，cargo 期望源代碼文件(以rs後綴結尾的Rust語言文件)位於 `src` 目錄中。項目根目錄只存放**說明文件**(README)、**許可協議**(license)信息、**配置文件** (cargo.toml)和其他跟代碼無關的文件。使用 Cargo 可幫助你保持項目乾淨整潔。這裡為一切事物所準備，一切都位於正確的位置。

###  3. 構建並運行 Cargo 項目

現在在 `new_strategy` 目錄下，輸入下面的命令來構建項目：

```shell
$ cargo build
   Compiling new_strategy v0.1.0 (file:///projects/new_strategy)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

這個命令會在 *target/debug/new_strategy* 下創建一個可執行文件(在 Windows 上是 *target\debug\new_strategy.exe*)，而不是放在目前目錄下。你可以使用下面的命令來運行它：

```shell
$ ./target/debug/new_strategy 
Hello, world!
```

cargo 還提供了一te x t個名為 `cargo check` 的命令。該命令快速檢查代碼確保其可以編譯：

```shell
$ cargo check
   Checking new_strategy v0.1.0 (file:///projects/new_strategy)
    Finished dev [unoptimized + debuginfo] target(s) in 0.14 secs
```

因為編譯的耗時有時可以非常長，所以此時我們更改或修正代碼後，並不會頻繁執行`cargo build`來重構項目，而是使用 `cargo check`。



### 4. 發佈構建

當我們最終準備好交付代碼時，可以使用 `cargo build --release` 來優化編譯項目。

這會在   而不是 *target/debug* 下生成可執行文件。這些優化可以讓 Rust 代碼運行的更快，不過啟用這些優化也需要消耗顯著更長的編譯時間。

如果你要對代碼運行時間進行基準測試，請確保運行 `cargo build --release` 並使用 *target/release* 下的可執行文件進行測試。

##  1.8  需要了解的幾個Rust概念

好的，讓我為每個概念再提供一個更詳細的案例，以幫助你更好地理解。

### 作用域 (Scope)

作用域是指在代碼中變量或值的可見性和有效性範圍。在作用域內聲明的變量或值可以在該作用域內使用，而在作用域外無法訪問。簡單來說，作用域決定了你在哪裡可以使用一個變量或值。

在大多數編程語言中，作用域通常由大括號 `{}` 來界定，例如在函數、循環、條件語句或代碼塊中。變量或值在進入作用域時創建，在離開作用域時銷燬。這有助於確保程序的局部性和變量不會干擾其他部分的代碼。

例如，在下面的Rust代碼中，`x` 變量的作用域在函數 `main` 中，因此只能在函數內部使用：

```rust
fn main() {
    let x = 10; // 變量x的作用域從這裡開始

    // 在這裡可以使用變量x

} // 變量x的作用域在這裡結束，x被銷燬
```

總之，作用域是編程語言中用來控制變量和值可見性的概念，它確保了變量只在適當的地方可用，從而提高了代碼的可維護性和安全性。在第6章我們還會詳細講解作用域 (Scope)。

### 所有權 (Ownership)

想象一下你有一個獨特的玩具火車，只有你能夠玩。這個火車是你的所有物。當你不再想玩這個火車時，你可以把它扔掉，它就不再存在了。在 Rust 中，每個值就像是這個玩具火車，有一個唯一的所有者。一旦所有者不再需要這個值，它會被銷燬，這樣就不會佔用內存空間。

```rust
fn main() {
    let toy_train = "Awesome train".to_string(); // 創建一個玩具火車
    // toy_train 是它的所有者

    let train_name = get_name(&toy_train); // 傳遞火車的引用
    println!("Train's name: {}", train_name);
    // 接下來 toy_train 離開了main函數的作用域， 在main函數外面誰也不能再玩 toy_train了。
}

fn get_name(train: &String) -> String {
    // 接受 String 的引用，不獲取所有權
    train.clone() // 返回火車的名字的拷貝
}
```

在這個例子中，我們創建了一個 `toy_train` 的值，然後將它的引用傳遞給 `get_name` 函數，而不是移動它的所有權。這樣，函數可以讀取 `toy_train` 的數據，但 `toy_train` 的所有權仍然在 `main` 函數中。當 `toy_train` 離開 `main` 函數的作用域時，它的所有權被移動到函數內部，所以在函數外部不能再使用 `toy_train`。

### 可變性 (mutability)

可變性(mutability)是指在編程中一個變量或數據是否可以被修改或改變的特性。在許多編程語言中，變量通常有二元對立的狀態：可變(mutable)和不可變(immutable)。

- **可變 (Mutable)**：如果一個變量是可變的，意味著你可以在創建後更改它的值。你可以對可變變量進行賦值操作，修改其中的數據。這在編程中非常常見，因為它允許程序在運行時動態地改變數據。

- **不可變 (Immutable)**：如果一個變量是不可變的，意味著一旦賦值後，就無法再更改其值。不可變變量在多線程編程和併發環境中非常有用，因為它們可以避免競爭條件和數據不一致性。

在很多編程語言中，變量默認是可變的，但有些語言(如Rust)選擇默認為不可變，需要顯式地聲明變量為可變才能進行修改。

在Rust中，可變性是一項強制性的特性，這意味著默認情況下變量是不可變的。如果你想要一個可變的變量，需要使用 `mut` 關鍵字顯式聲明它。例如：

```rust
fn main() {
    let x = 10; // 不可變變量x
    let mut y = 20; // 可變變量y，可以修改其值
    y = 30; // 可以修改y的值
}
```

這種默認的不可變性有助於提高代碼的安全性，因為它防止了意外的數據修改。但也允許你選擇在需要時顯式地聲明變量為可變，以便進行修改。

### 借用(Borrowing)

想象一下你有一本漫畫書，你的朋友可以看，但不能把它帶走或畫在上面。你允許你的朋友借用這本書，但不能改變它。在 Rust 中，你可以創建共享引用，就像是讓朋友看你的書，但不能修改它。

```rust
fn main() {
    let mut comic_book = "Spider-Man".to_string(); // 創建一本漫畫書
    // comic_book 是它的所有者

    let book_title = get_title(&comic_book); // 傳遞書的引用
    println!("Book title: {}", book_title); // 返回 "Book title: Spider-Man"

    add_subtitle(&mut comic_book); // 嘗試修改書，需要可變引用

    // comic_book 離開了作用域，它的所有權被移動到 get_title 函數
    // 這裡不能再閱讀或修改 comic_book
}

fn get_title(book: &String) -> String {
    // 接受 String 的引用，不獲取所有權
    book.clone() // 返回書的標題的拷貝
}

fn add_subtitle(book: &mut String) {
    // 接受可變 String 的引用，可以修改書
    book.push_str(": The Amazing Adventures");
}
```

在這個例子中，我們首先創建了一本漫畫書 `comic_book`，然後將它的引用傳遞給 `get_title` 函數，而不是移動它的所有權。這樣，函數可以讀取 `comic_book` 的數據，但不能修改它。然後，我們嘗試調用 `add_subtitle` 函數，該函數需要一個可變引用，因為它要修改書的內容。在rust中，對變量的寫的權限，可以通過可變引用來控制。

### 生命週期(Lifetime)

生命週期就像是你和朋友一起觀看電影，但你必須確保電影結束前，你的朋友仍然在場。如果你的朋友提前離開，你不能再和他一起看電影。在 Rust 中，生命週期告訴編譯器你的引用可以用多久，以確保引用不會指向已經消失的東西。這樣可以防止出現問題。

```rust
fn main() {
    let result;
    {
        let number = 42;
        result = get_value(&number);
    } // number 離開了作用域，但 result 的引用仍然有效

    println!("Result: {}", result);
}

fn get_value<'a>(val: &'a i32) -> &'a i32 {
    // 接受 i32 的引用，返回相同生命週期的引用
    val // 返回 val 的引用，其生命週期與 val 相同
}
```

在這個示例中，我們創建了一個整數 `number`，然後將它的引用傳遞給 `get_value` 函數，並使用生命週期 `'a` 來標註引用的有效性。函數返回的引用的生命週期與傳入的引用 `val` 相同，因此它仍然有效，即使 `number` 離開了作用域。

這些案例希望幫助你更容易理解 Rust 中的所有權、借用和生命週期這三個概念。這些概念是 Rust 的核心，有助於確保你的代碼既安全又高效。

# Chapter 2 - 格式化輸出

##  2.1 諸種格式宏(format macros)

Rust的打印操作由 `std::fmt` 裡面所定義的一系列宏 Macro 來處理，包括：

`format!`：將格式化文本寫到字符串。

`print!`：與 format! 類似，但將文本輸出到控制檯(io::stdout)。

`println!`: 與 print! 類似，但輸出結果追加一個換行符。

`eprint!`：與 print! 類似，但將文本輸出到標準錯誤(io::stderr)。

`eprintln!`：與 eprint! 類似，但輸出結果追加一個換行符。

### 案例：折現計算器

以下這個案例是一個簡單的折現計算器，用於計算未來現金流的現值。用戶需要提供本金金額、折現率和時間期限，然後程序將根據這些輸入計算現值並將結果顯示給用戶。這個示例同時用到了一些基本的 Rust 編程概念，以及標準庫中的一些功能。

```rust
use std::io;
use std::io::Write; // 導入 Write trait，以便使用 flush 方法

fn main() {
    // 讀取用戶輸入的本金、折現率和時間期限
    let mut input = String::new();

    println!("折現計算器");

    // 提示用戶輸入本金金額
    print!("請輸入本金金額：");
    io::stdout().flush().expect("刷新失敗"); // 刷新標準輸出流，確保立即顯示
    io::stdin().read_line(&mut input).expect("讀取失敗");
    let principal: f64 = input.trim().parse().expect("無效輸入");

    input.clear(); // 清空輸入緩衝區，以便下一次使用

    // 提示用戶輸入折現率
    println!("請輸入折現率(以小數形式)：");
    io::stdin().read_line(&mut input).expect("讀取失敗");
    let discount_rate: f64 = input.trim().parse().expect("無效輸入");

    input.clear(); // 清空輸入緩衝區，以便下一次使用

    // 提示用戶輸入時間期限
    print!("請輸入時間期限(以年為單位)：");
    io::stdout().flush().expect("刷新失敗"); // 刷新標準輸出流，確保立即顯示
    io::stdin().read_line(&mut input).expect("讀取失敗");
    let time_period: u32 = input.trim().parse().expect("無效輸入");

    // 計算並顯示結果
    let result = calculate_present_value(principal, discount_rate, time_period);
    println!("現值為：{:.2}", result);
}

fn calculate_present_value(principal: f64, discount_rate: f64, time_period: u32) -> f64 {
    if discount_rate < 0.0 {
        eprint!("\n錯誤：折現率不能為負數！ ");    // '\n'為換行轉義符號
        eprintln!("\n請提供有效的折現率。");
        std::process::exit(1);
    }

    if time_period == 0 {
        eprint!("\n錯誤：時間期限不能為零！ ");
        eprintln!("\n請提供有效的時間期限。");
        std::process::exit(1);
    }

    principal / (1.0 + discount_rate).powi(time_period as i32)
}

```

現在我們來使用一下這個折現計算器

```shell
折現計算器
請輸入本金金額：2000
請輸入折現率(以小數形式)：0.2
請輸入時間期限(以年為單位)：2

現值為：1388.89
```

當我們輸入一個負的折現率後, 我們用eprint!和eprintln!預先編輯好的錯誤信息就出現了:

```shell
折現計算器
請輸入本金金額：3000
請輸入折現率(以小數形式)：-0.2
請輸入時間期限(以年為單位)：5

錯誤：折現率不能為負數！ 請提供有效的折現率。
```

## 2.2 Debug 和 Display 特性

> `fmt::Debug`：使用 {:?} 標記。格式化文本以供**調試使用**。
> `fmt::Display`：使用 {} 標記。以**更優雅和友好的風格**來格式化文本。

在 Rust 中，你可以為自定義類型(包括結構體 `struct`)實現 `Display` 和 `Debug` 特性來控制如何以可讀和調試友好的方式打印(格式化)該類型的實例。這兩個特性是 Rust 標準庫中的 trait，它們提供了不同的打印輸出方式，適用於不同的用途。

**Display 特性：**

- `Display` 特性用於定義類型的人類可讀字符串表示形式，通常用於用戶友好的輸出。例如，你可以實現 `Display` 特性來打印結構體的信息，以便用戶能夠輕鬆理解它。

- 要實現 `Display` 特性，必須定義一個名為 `fmt` 的方法，它接受一個格式化器對象(`fmt::Formatter`)作為參數，並將要打印的信息寫入該對象。

- 使用 `{}` 佔位符可以在 `println!` 宏或 `format!` 宏中使用 `Display` 特性。

- 通常，實現 `Display` 特性需要手動編寫代碼來指定打印的格式，以確保輸出滿足你的需求。

**Debug 特性：**

- `Debug` 特性用於定義類型的調試輸出形式，通常用於開發和調試過程中，以便查看內部數據結構和狀態。

- 與 `Display` 不同，`Debug` 特性不需要手動指定格式，而是使用默認的格式化方式。你可以通過在 `println!` 宏或 `format!` 宏中使用 `{:?}` 佔位符來打印實現了 `Debug` 特性的類型。

- 標準庫提供了一個 `#[derive(Debug)]` 註解，你可以將其添加到結構體定義之前，以自動生成 `Debug` 實現。這使得調試更加方便，因為不需要手動編寫調試輸出的代碼。



### 案例： 打印股票價格信息和金融報告

**股票價格信息**：(由**Display Trait**推導)

```rust
// 導入 fmt 模塊中的 fmt trait，用於實現自定義格式化
use std::fmt;

// 定義一個結構體 StockPrice，表示股票價格
struct StockPrice {
    symbol: String, // 股票符號
    price: f64,     // 價格
}

// 實現 fmt::Display trait，允許我們自定義格式化輸出
impl fmt::Display for StockPrice {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // 使用 write! 宏將格式化後的字符串寫入 f 參數
        write!(f, "股票: {} - 價格: {:.2}", self.symbol, self.price)
    }
}

fn main() {
    // 創建一個 StockPrice 結構體實例
    let price = StockPrice {
        symbol: "AAPL".to_string(), // 使用 to_string() 方法將字符串字面量轉換為 String 類型
        price: 150.25,
    };

    // 使用 println! 宏打印格式化後的字符串，這裡會自動調用 Display 實現的 fmt 方法
    println!("[INFO]: {}", price);
}
```

**執行結果:** 

```shell
[INFO]: Stock: AAPL - Price: 150.25
```



**金融報告**：(由**Debug Trait**推導)

```rust
// 導入 fmt 模塊中的 fmt trait，用於實現自定義格式化
use std::fmt;

// 定義一個結構體 FinancialReport，表示財務報告
// 使用 #[derive(Debug)] 屬性來自動實現 Debug trait，以便能夠使用 {:?} 打印調試信息
struct FinancialReport {
    income: f64,    // 收入
    expenses: f64,  // 支出
}

fn main() {
    // 創建一個 FinancialReport 結構體實例
    let report = FinancialReport {
        income: 10000.0,  // 設置收入
        expenses: 7500.0, // 設置支出
    };

    // 使用 income 和 expenses 字段的值，打印財務報告的收入和支出
    println!("金融報告:\nIncome: {:.2}\nExpenses: {:.2}", report.income, report.expenses);

    // 打印整個財務報告的調試信息，利用 #[derive(Debug)] 自動生成的 Debug trait
    println!("{:?}", report);
}
```

**執行結果:** 

```
金融報告:
Income: 10000.00 //手動格式化的語句
Expenses: 7500.00 //手動格式化的語句
FinancialReport { income: 10000.0, expenses: 7500.0 } //Debug Trait幫我們推導的原始語句
```

## 2.3  write! , print! 和 format!的區別

`write!`、`print!` 和 `format!` 都是 Rust 中的宏，用於生成文本輸出，但它們在使用和輸出方面略有不同：

1. `write!`：

   - `write!` 宏用於將格式化的文本寫入到一個實現了 `std::io::Write` trait 的對象中，通常是文件、標準輸出(`std::io::stdout()`)或標準錯誤(`std::io::stderr()`)。

   - 使用 `write!` 時，你需要指定目標輸出流，將生成的文本寫入該流中，而不是直接在控制檯打印。

   - `write!` 生成的文本不會立即顯示在屏幕上，而是需要進一步將其刷新(flush)到輸出流中。

   - 示例用法：

     ```rust
     use std::io::{self, Write};
      
     fn main() -> io::Result<()> {
         let mut output = io::stdout();
         write!(output, "Hello, {}!", "world")?;
         output.flush()?;
         Ok(())
     }
     ```

2. `print!`：

   - `print!` 宏用於直接將格式化的文本打印到標準輸出(控制檯)，而不需要指定輸出流。

   - `print!` 生成的文本會立即顯示在屏幕上。

   - 示例用法：

     ```rust
     fn main() {
         print!("Hello, {}!", "world");
     }
     ```

3. `format!`：

   - `format!` 宏用於生成一個格式化的字符串，而不是直接將其寫入輸出流或打印到控制檯。

   - 它返回一個 `String` 類型的字符串，你可以隨後使用它進行進一步處理、打印或寫入到文件中。

   - 示例用法：

     ```rust
     fn main() {
         let formatted_str = format!("Hello, {}!", "world");
         println!("{}", formatted_str);
     }
     ```

總結：

- 如果你想將格式化的文本輸出到標準輸出，通常使用 `print!`。
- 如果你想將格式化的文本輸出到文件或其他實現了 `Write` trait 的對象，使用 `write!`。
- 如果你只想生成一個格式化的字符串而不需要立即輸出，使用 `format!`。

# Chapter 3 - 原生類型

"原生類型"(Primitive Types)是計算機科學中的一個通用術語，通常用於描述編程語言中的基本數據類型。Rust中的原生類型被稱為原生，因為它們是語言的基礎構建塊，通常由編譯器和底層硬件直接支持。以下是為什麼這些類型被稱為原生類型的幾個原因：

1. **硬件支持**：原生類型通常能夠直接映射到底層硬件的數據表示方式。例如，`i32` 和 `f64` 類型通常直接對應於CPU中整數和浮點數寄存器的存儲格式，因此在運行時效率較高。
2. **編譯器優化**：由於原生類型的表示方式是直接的，編譯器可以進行有效的優化，以在代碼執行時獲得更好的性能。這意味著原生類型的操作通常比自定義類型更快速。
3. **標準化**：原生類型是語言標準的一部分，因此在不同的Rust編譯器和環境中具有相同的語義。這意味著你可以跨平臺使用這些類型，而無需擔心不同系統上的行為不一致。
4. **內存佈局可控**：原生類型的內存佈局是明確的，因此你可以精確地控制數據在內存中的存儲方式。這對於與外部系統進行交互、編寫系統級代碼或進行底層內存操作非常重要。

Rust 中有一些原生數據類型，用於表示基本的數據值。以下是一些常見的原生數據類型：

1. **整數類型**：

   - `i8`：有符號8位整數
   - `i16`：有符號16位整數
   - `i32`：有符號32位整數
   - `i64`：有符號64位整數
   - `i128`：有符號128位整數
   - `u8`：無符號8位整數
   - `u16`：無符號16位整數
   - `u32`：無符號32位整數
   - `u64`：無符號64位整數
   - `u128`：無符號128位整數
   - `isize`：有符號機器字大小的整數
   - `usize`：無符號機器字大小的整數

   以下是一個使用各種整數類型的 案例，演示了不同整數類型的用法：

   ```rust
   fn main() {
       // 有符號整數類型
       let i8_num: i8 = -42;   // 8位有符號整數，範圍：-128 到 127
       let i16_num: i16 = -1000; // 16位有符號整數，範圍：-32,768 到 32,767
       let i32_num: i32 = 200000; // 32位有符號整數，範圍：-2,147,483,648 到 2,147,483,647
       let i64_num: i64 = -9000000000; // 64位有符號整數，範圍：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
       let i128_num: i128 = 10000000000000000000000000000000; // 128位有符號整數
   
       // 無符號整數類型
       let u8_num: u8 = 255; // 8位無符號整數，範圍：0 到 255
       let u16_num: u16 = 60000; // 16位無符號整數，範圍：0 到 65,535
       let u32_num: u32 = 4000000000; // 32位無符號整數，範圍：0 到 4,294,967,295
       let u64_num: u64 = 18000000000000000000; // 64位無符號整數，範圍：0 到 18,446,744,073,709,551,615
       let u128_num: u128 = 340282366920938463463374607431768211455; // 128位無符號整數
   
       // 打印各個整數類型的值
       println!("i8: {}", i8_num);
       println!("i16: {}", i16_num);
       println!("i32: {}", i32_num);
       println!("i64: {}", i64_num);
       println!("i128: {}", i128_num);
       println!("u8: {}", u8_num);
       println!("u16: {}", u16_num);
       println!("u32: {}", u32_num);
       println!("u64: {}", u64_num);
       println!("u128: {}", u128_num);
   }
   ```

   **執行結果:**

   ```text
   i8: -42
   i16: -1000
   i32: 200000
   i64: -9000000000
   i128: 10000000000000000000000000000000
   u8: 255
   u16: 60000
   u32: 4000000000
   u64: 18000000000000000000
   u128: 340282366920938463463374607431768211455
   ```

   

2. **浮點數類型**：

   - `f32`：32位浮點數
   - `f64`：64位浮點數(雙精度浮點數)

   以下是一個 演示各種浮點數類型及其範圍的案例：

   ```rust
   fn main() {
       let f32_num: f32 = 3.14; // 32位浮點數，範圍：約 -3.4e38 到 3.4e38，精度約為7位小數
       let f64_num: f64 = 3.141592653589793238; // 64位浮點數，範圍：約 -1.7e308 到 1.7e308，精度約為15位小數
   
       // 打印各個浮點數類型的值
       println!("f32: {}", f32_num);
       println!("f64: {}", f64_num);
   }
   
   ```

   **執行結果:**

   ```text
   f32: 3.14
   f64: 3.141592653589793
   ```

   

3. **布爾類型**：

   `bool`：表示布爾值，可以是 `true` 或 `false`。

   在rust中, 布爾值 bool 可以直接拿來當if語句的判斷條件。

   ```rust
   fn main() {
       // 模擬股票價格數據
       let stock_price = 150.0;
       
       // 定義交易策略條件
       let buy_condition = stock_price < 160.0; // 如果股價低於160，滿足購買條件
       let sell_condition = stock_price > 170.0; // 如果股價高於170，滿足賣出條件
       
       // 執行交易策略
       if buy_condition {  //buy_condition此時已經是一個布爾值, 可以直接拿來當if語句的判斷條件
           println!("購買股票：股價為 {}，滿足購買條件。", stock_price);
       } else if sell_condition { //sell_condition 同理也已是一個布爾值, 可以當if語句的判斷條件
           println!("賣出股票：股價為 {}，滿足賣出條件。", stock_price);
       } else {
           println!("不執行交易：股價為 {}，沒有滿足的交易條件。", stock_price);
       }
   }
   ```

   **執行結果:**

   ```text
   購買股票：股價為 150，滿足購買條件。
   ```

   

4. **字符類型**：

   `char`：表示**單個** Unicode 字符。

   Rust的字符類型char具有以下特徵:

   1. **Unicode 支持**：幾乎所有現代編程語言都提供了對Unicode字符的支持，因為Unicode已成為全球標準字符集。Rust 的 `char` 類型當然也是 Unicode 兼容的，這意味著它可以表示任何有效的 Unicode 字符，包括 ASCII 字符和其他語言中的特殊字符。
   2. **32 位寬度**：`char`類型使用UTF-32編碼來表示Unicode字符，一個`char`實際上是一個長度為 1 的 UCS-4 / UTF-32 字符串。。這確保了`char`類型可以容納任何Unicode字符，因為UTF-32編碼的碼點範圍覆蓋了Unicode字符集的所有字符。`char` 類型的值是 Unicode 標量值(即不是代理項的代碼點)，表示為 0x0000 到 0xD7FF 或 0xE000 到 0x10FFFF 範圍內的 32 位無符號字。創建一個超出此範圍的 `char` 會立即被編譯器認為是未定義行為。 
   3. **字符字面量**：`char` 類型的字符字面量使用單引號括起來，例如 `'A'` 或 `'❤'`。這些字符字面量可以直接賦值給 `char` 變量。
   4. **字符轉義序列**：與字符串一樣，`char` 字面量也支持轉義序列，例如 `'\n'` 表示換行字符。
   5. **UTF-8 字符串**：Rust 中的字符串類型 `String` 是 UTF-8 編碼的，這與 `char` 類型兼容，因為 UTF-8 是一種可變長度編碼，可以表示各種字符。
   6. **字符迭代**：你可以使用迭代器來處理字符串中的每個字符，例如使用 `chars()` 方法。這使得遍歷和操作字符串中的字符非常方便。

   

    `char` 類型的特性可以用於處理和表示與金融數據和分析相關的各種字符和符號。以下是一些展示如何在量化金融環境中利用 `char` 特性的示例：

   1. **表示貨幣符號**：`char` 可以用於表示貨幣符號，例如美元符號 `$` 或歐元符號 `€`。這對於在金融數據中標識貨幣類型非常有用。

      ```rust
      fn main() {
          let usd_symbol = '$';
          let eur_symbol = '€';
      
          println!("美元符號: {}", usd_symbol);
          println!("歐元符號: {}", eur_symbol);
      }
      ```

      **執行結果:**

      ```text
      美元符號: $
      歐元符號: €
      ```

   2. **表示期權合約種類**：在這個示例中，我們使用 `char` 類型來表示期權合約類型，'P' 代表put期權合約，'C' 代表call期權合約。根據不同的合約類型，我們執行不同的操作。這種方式可以用於在金融交易中確定期權合約的類型，從而執行相應的交易策略。

      ```rust
      fn main() {
          let contract_type = 'P'; // 代表put期權合約
          
          match contract_type {
              'P' => println!("執行put期權合約。"),
              'C' => println!("執行call期權合約。"),
              _ => println!("未知的期權合約類型。"),
          }
      }
      ```

      **執行結果:**

      ```text
      執行put期權合約。
      ```

   3. **處理特殊字符**：金融數據中可能包含特殊字符，例如百分比符號 `%` 或乘號 `*`。`char` 類型允許你在處理這些字符時更容易地執行各種操作。

      ```rust
      fn main() {
          let percentage = 5.0; // 百分比 5%
          let multi_sign = '*';
      
          // 在計算中使用百分比
          let value = 10.0;
          let result = value * (percentage / 100.0); // 將百分比轉換為小數進行計算
      
          println!("{}% {} {} = {}", percentage, multi_sign, value, result);
      }
      ```

      **執行結果:**

      ```text
      5% * 10 = 0.5
      ```

      

   `char` 類型的特性使得你能夠更方便地處理和識別與金融數據和符號相關的字符，從而更好地支持金融數據分析和展示。	

   

## 3.1 字面量, 運算符 和字符串

Rust語言中，你可以使用不同類型的字面量來表示不同的數據類型，包括整數、浮點數、字符、字符串、布爾值以及單元類型。以下是關於Rust字面量和運算符的簡要總結：

### 3.1.1 字面量(Literals)：

當你編寫 Rust 代碼時，你會遇到各種不同類型的字面量，它們用於表示不同類型的值。以下是一些常見的字面量類型和示例：

1. **整數字面量(Integer Literals)**：用於表示整數值，例如：
   - 十進制整數：`10`
   - 十六進制整數：`0x1F`
   - 八進制整數：`0o77`
   - 二進制整數：`0b1010`

2. **浮點數字面量(Floating-Point Literals)**：用於表示帶小數點的數值，例如：
   - 浮點數：`3.14`
   - 科學計數法：`2.0e5`

3. **字符字面量(Character Literals)**：用於表示單個字符，使用單引號括起來，例如：
   - 字符 ：`'A'`
   - 轉義字符 ：`'\n'`

4. **字符串字面量(String Literals)**：用於表示文本字符串，使用雙引號括起來，例如：
   - 字符串 ：`"Hello, World!"`

5. **布爾字面量(Boolean Literals)**：用於表示真(`true`)或假(`false`)的值，例如：
   - 布爾值 ：`true`
   - 布爾值：`false`

6. **單元類型(Unit Type)**：表示沒有有意義的返回值的情況，通常表示為 `()`，例如：
   - 函數返回值：`fn do_something() -> () { }`

你還可以在數字字面量中插入下劃線 `_` 以提高可讀性，例如 `1_000` 和 `0.000_001`，它們分別等同於1000和0.000001。這些字面量類型用於初始化變量、傳遞參數和表示數據的各種值。



### 3.1.2 運算符(Operators)：

在 Rust 中，常見的運算符包括：

1. **算術運算符(Arithmetic Operators)**：
   - `+`(加法)：將兩個數相加，例如 `a + b`。
   - `-`(減法)：將右邊的數從左邊的數中減去，例如 `a - b`。
   - `*`(乘法)：將兩個數相乘，例如 `a * b`。
   - `/`(除法)：將左邊的數除以右邊的數，例如 `a / b`。
   - `%`(取餘)：返回左邊的數除以右邊的數的餘數，例如 `a % b`。
2. **比較運算符(Comparison Operators)**：
   - `==`(等於)：檢查左右兩邊的值是否相等，例如 `a == b`。
   - `!=`(不等於)：檢查左右兩邊的值是否不相等，例如 `a != b`。
   - `<`(小於)：檢查左邊的值是否小於右邊的值，例如 `a < b`。
   - `>`(大於)：檢查左邊的值是否大於右邊的值，例如 `a > b`。
   - `<=`(小於等於)：檢查左邊的值是否小於或等於右邊的值，例如 `a <= b`。
   - `>=`(大於等於)：檢查左邊的值是否大於或等於右邊的值，例如 `a >= b`。
3. **邏輯運算符(Logical Operators)**：
   - `&&`(邏輯與)：用於組合兩個條件，只有當兩個條件都為真時才為真，例如 `condition1 && condition2`。
   - `||`(邏輯或)：用於組合兩個條件，只要其中一個條件為真就為真，例如 `condition1 || condition2`。
   - `!`(邏輯非)：用於取反一個條件，將真變為假，假變為真，例如 `!condition`。
4. **賦值運算符(Assignment Operators)**：
   - `=`(賦值)：將右邊的值賦給左邊的變量，例如 `a = b`。
   - `+=`(加法賦值)：將左邊的變量與右邊的值相加，並將結果賦給左邊的變量，例如 `a += b` 相當於 `a = a + b`。
   - `-=`(減法賦值)：將左邊的變量與右邊的值相減，並將結果賦給左邊的變量，例如 `a -= b` 相當於 `a = a - b`。
5. **位運算符(Bitwise Operators)**：
   - `&`(按位與)：對兩個數的每一位執行與操作，例如 `a & b`。
   - `|`(按位或)：對兩個數的每一位執行或操作，例如 `a | b`。
   - `^`(按位異或)：對兩個數的每一位執行異或操作，例如 `a ^ b`。

這些運算符在 Rust 中用於執行各種數學、邏輯和位操作，使你能夠編寫靈活和高效的代碼。

現在把這些運算符帶到實際場景來看一下：

```rust
fn main() {
    // 加法運算：整數相加
    println!("3 + 7 = {}", 3u32 + 7);
    // 減法運算：整數相減
    println!("10 減去 4 = {}", 10i32 - 4);

    // 邏輯運算：布爾值的組合
    println!("true 與 false 的與運算結果是：{}", true && false);
    println!("true 或 false 的或運算結果是：{}", true || false);
    println!("true 的非運算結果是：{}", !true);

    // 賦值運算：變量值的更新
    let mut x = 8;
    x += 5; // 等同於 x = x + 5
    println!("x 現在的值是：{}", x);

    // 位運算：二進制位的操作
    println!("0101 和 0010 的與運算結果是：{:04b}", 0b0101u32 & 0b0010);
    println!("0101 和 0010 的或運算結果是：{:04b}", 0b0101u32 | 0b0010);
    println!("0101 和 0010 的異或運算結果是：{:04b}", 0b0101u32 ^ 0b0010);
    println!("2 左移 3 位的結果是：{}", 2u32 << 3);
    println!("0xC0 右移 4 位的結果是：0x{:x}", 0xC0u32 >> 4);

    // 使用下劃線增加數字的可讀性
    println!("一千可以表示為：{}", 1_000u32);
}


```

**執行結果:**

```text
3 + 7 = 10
10 減去 4 = 6
true 與 false 的與運算結果是：false
true 或 false 的或運算結果是：true
true 的非運算結果是：false
x 現在的值是：13
0101 和 0010 的與運算結果是：0000
0101 和 0010 的或運算結果是：0111
0101 和 0010 的異或運算結果是：0111
2 左移 3 位的結果是：16
0xC0 右移 4 位的結果是：0xc
一千可以表示為：1000
```

### 補充學習: 邏輯運算符

邏輯運算中有三種基本操作：與(AND)、或(OR)、異或(XOR)，用來操作二進制位。

1. 0011 與 0101 為 0001(AND運算)：
   這個運算符表示兩個二進制數的對應位都為1時，結果位為1，否則為0。在這個例子中，我們對每一對位進行AND運算：
   - 第一個位：0 AND 0 = 0
   - 第二個位：0 AND 1 = 0
   - 第三個位：1 AND 0 = 0
   - 第四個位：1 AND 1 = 1
     因此，結果為 0001。

2. 0011 或 0101 為 0111(OR運算)：
   這個運算符表示兩個二進制數的對應位中只要有一個為1，結果位就為1。在這個例子中，我們對每一對位進行OR運算：
   - 第一個位：0 OR 0 = 0
   - 第二個位：0 OR 1 = 1
   - 第三個位：1 OR 0 = 1
   - 第四個位：1 OR 1 = 1
     因此，結果為 0111。

3. 0011 異或 0101 為 0110(XOR運算)：
   這個運算符表示兩個二進制數的對應位相同則結果位為0，不同則結果位為1。在這個例子中，我們對每一對位進行XOR運算：
   - 第一個位：0 XOR 0 = 0
   - 第二個位：0 XOR 1 = 1
   - 第三個位：1 XOR 0 = 1
   - 第四個位：1 XOR 1 = 0
     因此，結果為 0110。

這些邏輯運算在計算機中廣泛應用於位操作和布爾代數中，它們用於創建複雜的邏輯電路、控制程序和數據處理。

### 補充學習: 移動運算符

這涉及到位運算符的工作方式，特別是左移運算符(`<<`)和右移運算符(`>>`)。讓我為你解釋一下：

1. `為什麼1 左移 5 位為 32`：
   - `1` 表示二進制數字 `0001`。
   - 左移運算符 `<<` 將二進制數字向左移動指定的位數。
   - 在這裡，`1u32 << 5` 表示將二進制數字 `0001` 向左移動5位。
   - 移動5位後，變成了 `100000`，這是二進制中的32。
   - 因此，`1 左移 5 位` 等於 `32`。

2. 為什麼`0x80 右移 2 位為 0x20`：
   - `0x80` 表示十六進制數字，其二進製表示為 `10000000`。
   - 右移運算符 `>>` 將二進制數字向右移動指定的位數。
   - 在這裡，`0x80u32 >> 2` 表示將二進制數字 `10000000` 向右移動2位。
   - 移動2位後，變成了 `00100000`，這是二進制中的32。
   - 以十六進製表示，`0x20` 表示32。
   - 因此，`0x80 右移 2 位` 等於 `0x20`。

這些運算是基於二進制和十六進制的移動，因此結果不同於我們平常的十進製表示方式。左移操作會使數值變大，而右移操作會使數值變小。

### 3.1.3 字符串切片 (&str)

`&str` 是 Rust 中的字符串切片類型，表示對一個已有字符串的引用或視圖。它是一個非擁有所有權的、不可變的字符串類型，具有以下特性和用途：

1. **不擁有所有權**：`&str` 不擁有底層字符串的內存，它只是一個對字符串的引用。這意味著當 `&str` 超出其作用域時，不會釋放底層字符串的內存，因為它不擁有該內存。這有助於避免內存洩漏。

2. **不可變性**：`&str` 是不可變的，一旦創建，就不能更改其內容。這意味著你不能像 `String` 那樣在 `&str` 上進行修改操作，例如添加字符。

3. **UTF-8 字符串**：Rust 確保 `&str` 指向有效的 UTF-8 字符序列，因此它是一種安全的字符串類型，不會包含無效的字符。

4. **切片操作**：你可以使用切片操作來創建 `&str`，從現有字符串中獲取子字符串。

   ```rust
   let my_string = "Hello, world!";
   let my_slice: &str = &my_string[0..5]; // 創建一個字符串切片
   ```

5. **函數參數和返回值**：`&str` 常用於函數參數和返回值，因為它允許你傳遞字符串的引用而不是整個字符串，從而避免不必要的所有權轉移。

**示例：**

```rust
fn main() {
    let greeting = "Hello, world!";
    let slice: &str = &greeting[0..5]; // 創建字符串切片
    println!("{}", slice); // 輸出 "Hello"
}
```

總之，`&str` 是一種輕量級、安全且靈活的字符串類型，常用於讀取字符串內容、函數參數、以及字符串切片操作。通過使用 `&str`，Rust 提供了一種有效管理字符串的方式，同時保持內存安全性。

在Rust中，字符串是一個重要的數據類型，用於存儲文本和字符數據。字符串在量化金融領域以及其他編程領域中廣泛使用，用於表示和處理金融數據、交易記錄、報告生成等任務。

此處要注意的是，在Rust中，有**兩種主要的字符串類型**：

- `String`：動態字符串，可變且在堆上分配內存。`String` 類型通常用於需要修改字符串內容的情況，比如拼接、替換等操作。在第五章我們還會詳細介紹這個類型。
- `&str`:字符串切片, 不可變的字符串引用，通常在棧上分配。`&str` 通常用於只需訪問字符串而不需要修改它的情況，也是函數參數中常見的類型。

在Rust中，`String` 和 `&str` 字符串類型的區別可以用金融實例來解釋。假設我們正在編寫一個金融應用程序，需要處理股票數據。

1. **使用 `String`：**

如果我們需要在應用程序中動態構建、修改和處理字符串，例如拼接多個股票代碼或構建複雜的查詢語句，我們可能會選擇使用 `String` 類型。這是因為 `String` 是可變的，允許我們在運行時修改其內容。

```rust
fn main() {
    let mut stock_symbol = String::from("AAPL");
    
    // 在運行時追加字符串
    stock_symbol.push_str("(NASDAQ)");
    
    println!("Stock Symbol: {}", stock_symbol);
}
```

**執行結果:**

```text
Stock Symbol: AAPL(NASDAQ)
```

在這個示例中，我們創建了一個可變的 `String` 變量 `stock_symbol`，然後在運行時追加了"(NASDAQ)"字符串。這種靈活性對於金融應用程序中的動態字符串操作非常有用。

2. **使用 `&str`：**

如果我們只需要引用或讀取字符串而不需要修改它，並且希望避免額外的內存分配，我們可以使用 `&str`。在金融應用程序中，`&str` 可以用於傳遞字符串參數，訪問股票代碼等。

```rust
fn main() {
    let stock_symbol = "AAPL"; // 字符串切片，不可變
    let stock_name = get_stock_name(stock_symbol);
    
    println!("Stock Name: {}", stock_name);
}

fn get_stock_name(symbol: &str) -> &str {
    match symbol {
        "AAPL" => "Apple Inc.",
        "GOOGL" => "Alphabet Inc.",
        _ => "Unknown",
    }
}
```

在這個示例中，我們定義了一個函數 `get_stock_name`，它接受一個 `&str` 參數來查找股票名稱。這允許我們在不進行額外內存分配的情況下訪問字符串。

3. **小結**

`String` 和 `&str` 在金融應用程序中的使用取決於我們的需求。如果需要修改字符串內容或者在運行時構建字符串，`String` 是一個更好的選擇。如果只需要訪問字符串而不需要修改它，或者希望避免額外的內存分配，`&str` 是更合適的選擇。



## 3.2 元組 (Tuple)

元組(Tuple)是Rust中的一種數據結構，它可以存儲多個不同或相同類型的值，並且一旦創建，它們的長度就是不可變的。元組通常用於將多個值組合在一起以進行傳遞或返回，它們在量化金融中也有各種應用場景。

以下是一個元組的使用案例:

```rust
fn main() {
    // 創建一個元組，表示股票的價格和數量
    let stock = ("AAPL", 150.50, 1000);

    // 訪問元組中的元素, 賦值給一併放在左邊的變量們,
    // 這種賦值方式稱為元組解構(Tuple Destructuring)
    let (symbol, price, quantity) = stock;

    // 打印變量的值
    println!("股票代碼: {}", symbol);
    println!("股票價格: ${:.2}", price);
    println!("股票數量: {}", quantity);

    // 計算總價值
    let total_value = price * (quantity as f64); // 注意將數量轉換為浮點數以進行計算

    println!("總價值: ${:.2}", total_value);
}
```

**執行結果:**

```text
股票代碼: AAPL
股票價格: $150.50
股票數量: 1000
總價值: $150500.00
```

在上述Rust代碼示例中，我們演示瞭如何使用元組來表示和存儲股票的相關信息。讓我們詳細解釋代碼中的各個部分：

1. **創建元組：**

   ```rust
   let stock = ("AAPL", 150.50, 1000);
   ```

   這一行代碼創建了一個元組 `stock`，其中包含了三個元素：股票代碼(字符串)、股票價格(浮點數)和股票數量(整數)。注意，元組的長度在創建後是不可變的，所以我們無法添加或刪除元素。

2. **元組解構(Tuple Destructuring)：**

   ```rust
   let (symbol, price, quantity) = stock;
   ```

   在這一行中，我們使用模式匹配的方式從元組中解構出各個元素，並將它們分別賦值給 `symbol`、`price` 和 `quantity` 變量。這使得我們能夠方便地訪問元組的各個部分。

3. **打印變量的值：**

   ```rust
   println!("股票代碼: {}", symbol);
   println!("股票價格: ${:.2}", price);
   println!("股票數量: {}", quantity);
   ```

   這些代碼行使用 `println!` 宏打印了元組中的不同變量的值。在第二個 `println!` 中，我們使用 `:.2` 來控制浮點數輸出的小數點位數。

4. **計算總價值：**

   ```rust
   let total_value = price * (quantity as f64);
   ```

   這一行代碼計算了股票的總價值。由於 `quantity` 是整數，我們需要將其轉換為浮點數 (`f64`) 來進行計算，以避免整數除法的問題。

最後，我們打印出了計算得到的總價值，得到了完整的股票信息。

總之，元組是一種方便的數據結構，可用於組合不同類型的值，並且能夠進行模式匹配以輕鬆訪問其中的元素。在量化金融或其他領域中，元組可用於組織和傳遞多個相關的數據項。

## 3.3 數組

在Rust中，數組是一種固定大小的數據結構，它存儲相同類型的元素，並且一旦聲明瞭大小，就不能再改變。Rust中的數組有以下特點：

1. **固定大小**：：數組和元組都是靜態大小的數據結構。數組的大小在聲明時必須明確指定，而且不能在運行時改變。這意味著一旦數組創建，它的長度就是不可變的。
2. **相同類型**：和元組不同，數組中的所有元素必須具有相同的數據類型。這意味著一個數組中的元素類型必須是一致的，例如，所有的整數或所有的浮點數。
3. **棧上分配**：Rust的數組是在棧上分配內存的，這使得它們在訪問和迭代時非常高效。但是，由於它們是棧上的，所以大小必須在編譯時確定。

下面是一個示例，演示瞭如何聲明、初始化和訪問Rust數組：

```rust
fn main() {
    // 聲明一個包含5個整數的數組，使用[類型; 大小]語法
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];

    // 訪問數組元素，索引從0開始
    println!("第一個元素: {}", numbers[0]); // 輸出 "第一個元素: 1"
    println!("第三個元素: {}", numbers[2]); // 輸出 "第三個元素: 3"

    // 數組長度必須在編譯時確定，但可以使用.len()方法獲取長度
    let length = numbers.len();
    println!("數組長度: {}", length); // 輸出 "數組長度: 5"
}

```

**執行結果：**

```text
第一個元素: 1
第三個元素: 3
數組長度: 5
```



### 案例1：簡單移動平均線計算器 (SMA Calculator)

簡單移動平均線(Simple Moving Average，SMA)是一種常用的技術分析指標，用於平滑時間序列數據以識別趨勢。SMA的計算公式非常簡單，它是過去一段時間內數據點的平均值。以下是SMA的計算公式：

$$
SMA = (X1 + X2 + X3 + ... + Xn) / n
$$

當在Rust中進行量化金融建模時，我們通常會使用數組(Array)和其他數據結構來管理和處理金融數據。以下是一個簡單的Rust量化金融案例，展示如何使用數組來計算股票的簡單移動平均線(Simple Moving Average，SMA)。



```rust
fn main() {
    // 假設這是一個包含股票價格的數組
    let stock_prices = [50.0, 52.0, 55.0, 60.0, 58.0, 62.0, 65.0, 70.0, 75.0, 80.0];
    
    // 計算簡單移動平均線(SMA)
    let window_size = 5; // 移動平均窗口大小
    let mut sma_values: Vec<f64> = Vec::new();
    
    for i in 0..stock_prices.len() - window_size + 1 {
        let window = &stock_prices[i..i + window_size];
        let sum: f64 = window.iter().sum();
        let sma = sum / window_size as f64;
        sma_values.push(sma);
    }
    
    // 打印SMA值
    println!("簡單移動平均線(SMA):");
    for (i, sma) in sma_values.iter().enumerate() {
        println!("Day {}: {:.2}", i + window_size, sma);
    }
}
```

**執行結果:**

```text
簡單移動平均線(SMA):
Day 5: 55.00
Day 6: 57.40
Day 7: 60.00
Day 8: 63.00
Day 9: 66.00
Day 10: 70.40
```

在這個示例中，我們計算的是簡單移動平均線(SMA)，窗口大小為5天。因此，SMA值是從第5天開始的，直到最後一天。在輸出中，"Day 5" 對應著第5天的SMA值，"Day 6" 對應第6天的SMA值，以此類推。這是因為SMA需要一定數量的歷史數據才能計算出第一個移動平均值，所以前幾天的結果會是空的或不可用的。

### 補充學習: 範圍設置

`for i in 0..stock_prices.len() - window_size + 1` 這樣寫是為了創建一個迭代器，該迭代器將在股票價格數組上滑動一個大小為 `window_size` 的窗口，以便計算簡單移動平均線(SMA)。

讓我們解釋一下這個表達式的各個部分：

- `0..stock_prices.len()`：這部分創建了一個範圍(range)，從0到 `stock_prices` 數組的長度。範圍的右邊界是不包含的，所以它包含了從0到 `stock_prices.len() - 1` 的所有索引。
- `- window_size + 1`：這部分將範圍的右邊界減去 `window_size`，然後再加1。這是為了確保窗口在數組上滑動，以便計算SMA。考慮到窗口的大小，我們需要確保它在數組內完全滑動，因此右邊界需要向左移動 `window_size - 1` 個位置。

因此，整個表達式 `0..stock_prices.len() - window_size + 1` 創建了一個範圍，該範圍從0到 `stock_prices.len() - window_size`，覆蓋了數組中所有可能的窗口的起始索引。在每次迭代中，這個範圍將產生一個新的索引，用於創建一個新的窗口，以計算SMA。這是一種有效的方法來遍歷數組並執行滑動窗口操作。

### 案例2： 指數移動平均線計算器 (EMA Calculator)

指數移動平均線(Exponential Moving Average，EMA)是另一種常用的技術分析指標，與SMA不同，EMA賦予了更多的權重最近的價格數據，因此它更加敏感於價格的近期變化。EMA的計算公式如下：
$$
EMA(t) = (P(t) * α) + (EMA(y) * (1 - α))
$$
其中：

- `EMA(t)`：當前時刻的EMA值。
- `P(t)`：當前時刻的價格。
- `EMA(y)`：前一時刻的EMA值。
- `α`：平滑因子，通常通過指定一個時間窗口長度來計算，`α = 2 / (n + 1)`，其中 `n` 是時間窗口長度。

在技術分析中，EMA(指數移動平均線)和SMA(簡單移動平均線)的計算有不同的起始點。

- EMA的計算通常可以從第一個數據點(Day 1)開始，因為它使用了指數加權平均的方法，使得前面的數據點的權重較小，從而考慮了所有的歷史數據。
- 而SMA的計算需要使用一個固定大小的窗口，因此必須從窗口大小之後的數據點(在我們的例子中是從第五天開始)才能得到第一個SMA值。這是因為SMA是對一段時間內的數據進行簡單平均，需要足夠的數據點來計算平均值。

現在讓我們在Rust中編寫一個EMA計算器，類似於之前的SMA計算器：

```rust
fn main() {
    // 假設這是一個包含股票價格的數組
    let stock_prices = [50.0, 52.0, 55.0, 60.0, 58.0, 62.0, 65.0, 70.0, 75.0, 80.0];
    
    // 計算指數移動平均線(EMA)
    let window_size = 5; // 時間窗口大小
    let mut ema_values: Vec<f64> = Vec::new();
    
    let alpha = 2.0 / (window_size as f64 + 1.0);
    let mut ema = stock_prices[0]; // 初始EMA值等於第一個價格
    
    for price in &stock_prices {
        ema = (price - ema) * alpha + ema;
        ema_values.push(ema);
    }
    
    // 打印EMA值
    println!("指數移動平均線(EMA):");
    for (i, ema) in ema_values.iter().enumerate() {
        println!("Day {}: {:.2}", i + 1, ema);
    }
}
```

**執行結果:**

```text
指數移動平均線(EMA):
Day 1: 50.00
Day 2: 51.00
Day 3: 52.75
Day 4: 55.88
Day 5: 56.59
Day 6: 58.39
Day 7: 59.92
Day 8: 62.02
Day 9: 63.95
Day 10: 66.30
```

### 補充學習: 平滑因子alpha

當計算指數移動平均線(EMA)時，需要使用一個平滑因子 `alpha`，這個因子決定了最近價格數據和前一EMA值的權重分配，它的計算方法是 `alpha = 2.0 / (window_size as f64 + 1.0)`。讓我詳細解釋這句代碼的含義：

1. `window_size` 表示時間窗口大小，通常用來確定計算EMA時要考慮多少個數據點。較大的 `window_size` 會導致EMA更加平滑，對價格波動的反應更慢，而較小的 `window_size` 則使EMA更加敏感，更快地反應價格變化。

2. `window_size as f64` 將 `window_size` 轉換為浮點數類型 (`f64`)，因為我們需要在計算中使用浮點數來確保精度。

3. `window_size as f64 + 1.0` 將窗口大小加1，這是EMA計算中的一部分，用於調整平滑因子。添加1是因為通常我們從第一個數據點開始計算EMA，所以需要考慮一個額外的數據點。

4. 最終，`2.0 / (window_size as f64 + 1.0)` 計算出平滑因子 `alpha`。這個平滑因子決定了EMA對最新數據的權重，通常情況下，`alpha` 的值會接近於1，以便更多地考慮最新的價格數據。較小的 `alpha` 值會使EMA對歷史數據更加平滑，而較大的 `alpha` 值會更強調最新的價格變動。

總之，這一行代碼計算了用於指數移動平均線計算的平滑因子 `alpha`，該因子在EMA計算中決定了最新數據和歷史數據的權重分配，以便在分析中更好地反映價格趨勢。

### 案例3 相對強度指數(Relative Strength Index，RSI)

RSI是一種用於衡量價格趨勢的技術指標，通常用於股票和其他金融市場的技術分析。相對強弱指數(RSI)的計算公式如下：

RSI = 100 - [100 / (1 + RS)]

其中，RS表示14天內收市價上漲數之和的平均值除以14天內收市價下跌數之和的平均值。

讓我們通過一個示例來說明：

假設最近14天的漲跌情況如下：

- 第一天上漲2元
- 第二天下跌2元
- 第三至第五天每天上漲3元
- 第六天下跌4元
- 第七天上漲2元
- 第八天下跌5元
- 第九天下跌6元
- 第十至十二天每天上漲1元
- 第十三至十四天每天下跌3元

現在，我們來計算RSI的步驟：

1. 首先，將14天內上漲的總額相加，然後除以14。在這個示例中，總共上漲16元，所以計算結果是16 / 14 = 1.14285714286
2. 接下來，將14天內下跌的總額相加，然後除以14。在這個示例中，總共下跌23元，所以計算結果是23 / 14 = 1.64285714286
3. 然後，計算相對強度RS，即RS = 1.14285714286 / 1.64285714286 = 0.69565217391
4. 接著，計算1 + RS，即1 + 0.69565217391 = 1.69565217391。
5. 最後，將100除以1 + RS，即100 / 1.69565217391 = 58.9743589745
6. 最終的RSI值為100 - 58.9743589745 = 41.0256410255  ≈ 41.026

這樣，我們就得到了相對強弱指數(RSI)的值，它可以幫助分析市場的超買和超賣情況。以下是一個計算RSI的示例代碼：

```rust
fn calculate_rsi(up_days: Vec<f64>, down_days: Vec<f64>) -> f64 {  
    let up_sum = up_days.iter().sum::<f64>();  
    let down_sum = down_days.iter().sum::<f64>();  
    let rs = up_sum / down_sum;  
    let rsi = 100.0 - (100.0 / (1.0 + rs));  
    rsi  
}  
  
fn main() {  
    let up_days = vec![2.0, 3.0, 3.0, 3.0, 2.0, 1.0, 1.0];  
    let down_days = vec![2.0, 4.0, 5.0, 6.0, 4.0, 3.0, 3.0];  
    let rsi = calculate_rsi(up_days, down_days);  
    println!("RSI: {}", rsi);  
}

```

**執行結果:**

```text
RSI: 41.026
```



## 3.4 切片

在Rust中，切片(Slice)是一種引用數組或向量中一部分連續元素的方法，而不需要複製數據。切片有時非常有用，特別是在量化金融中，因為我們經常需要處理時間序列數據或其他大型數據集。

下面我將提供一個簡單的案例，展示如何在Rust中使用切片進行量化金融分析。

假設有一個包含股票價格的數組，我們想計算某段時間內的最高和最低價格。以下是一個示例：

```rust
fn main() {
    // 假設這是一個包含股票價格的數組
    let stock_prices = [50.0, 52.0, 55.0, 60.0, 58.0, 62.0, 65.0, 70.0, 75.0, 80.0];

    // 定義時間窗口範圍
    let start_index = 2; // 開始日期的索引(從0開始)
    let end_index = 6;   // 結束日期的索引(包含)

    // 使用切片獲取時間窗口內的價格數據
    let price_window = &stock_prices[start_index..=end_index]; // 注意使用..=來包含結束索引

    // 計算最高和最低價格
    let max_price = price_window.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
    let min_price = price_window.iter().cloned().fold(f64::INFINITY, f64::min);

    // 打印結果
    println!("時間窗口內的最高價格: {:.2}", max_price);
    println!("時間窗口內的最低價格: {:.2}", min_price);
}

```

**執行結果:**

```text
時間窗口內的最高價格: 65.00
時間窗口內的最低價格: 55.00
```

下面我會詳細解釋以下兩行代碼：

```
let max_price = price_window.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
let min_price = price_window.iter().cloned().fold(f64::INFINITY, f64::min);
```

這兩行代碼的目標是計算時間窗口內的最高價格(`max_price`)和最低價格(`min_price`)。讓我們一一解釋它們的每一部分：

1. `price_window.iter()`：`price_window` 是一個切片，使用 `.iter()` 方法可以獲得一個迭代器，用於遍歷切片中的元素。
2. `.cloned()`：`cloned()` 方法用於將切片中的元素進行克隆，因為 `fold` 函數需要元素的拷貝(`Clone` trait)。這是因為 `f64` 類型是不可變類型，無法通過引用進行直接比較。所以我們將元素克隆，以便在 `fold` 函數中進行比較。
3. `.fold(f64::NEG_INFINITY, f64::max)`：`fold` 函數是一個迭代器適配器，它將迭代器中的元素按照給定的操作進行摺疊(歸約)。在這裡，我們使用 `fold` 來找到最高價格。
   - `f64::NEG_INFINITY` 是一個負無窮大的初始值，用於確保任何實際的價格都會大於它。這是為了確保在計算最高價格時，如果時間窗口為空，結果將是負無窮大。
   - `f64::max` 是一個函數，用於計算兩個 `f64` 類型的數值中的較大值。在 `fold` 過程中，它會比較當前最高價格和迭代器中的下一個元素，然後返回較大的那個。

### 補充學習: fold函數

`fold` 是一個常見的函數式編程概念，用於在集合(如數組、迭代器等)的元素上進行摺疊(或歸約)操作。它允許你在集合上進行迭代，並且在每次迭代中將一個累積值與集合中的元素進行某種操作，最終得到一個最終的累積結果。

在 Rust 中，`fold` 函數的簽名如下：

```rust
fn fold<B, F>(self, init: B, f: F) -> B
```

這個函數接受三個參數：

- `init`：初始值，表示摺疊操作的起始值。
- `f`：一個閉包(函數)，它定義了在每次迭代中如何將當前的累積值與集合中的元素進行操作。
- 返回值：最終的累積結果。

`fold` 的工作方式如下：

1. 它從初始值 `init` 開始。
2. 對於集合中的每個元素，它調用閉包 `f`，將當前累積值和元素作為參數傳遞給閉包。
3. 閉包 `f` 執行某種操作，生成一個新的累積值。
4. 新的累積值成為下一次迭代的輸入。
5. 此過程重複，直到遍歷完集合中的所有元素。
6. 最終的累積值成為 `fold` 函數的返回值。

這個概念的好處在於，我們可以使用 `fold` 函數來進行各種集合的累積操作，例如求和、求積、查找最大值、查找最小值等。在之前的示例中，我們使用了 `fold` 函數來計算最高價格和最低價格，將當前的最高/最低價格與集合中的元素進行比較，並更新累積值，最終得到了最高和最低價格。



# Chapter 4 - 自定義類型 Struct & Enum 

## 4.1 結構體(`struct`)

結構體(Struct)是 Rust 中一種自定義的複合數據類型，它允許你組合多個不同類型的值併為它們定義一個新的數據結構。結構體用於表示和組織具有相關屬性的數據。

以下是結構體的一些基本特點和概念：

1. **自定義類型**：結構體允許你創建自己的用戶定義類型，以適應特定問題領域的需求。

2. **屬性**：結構體包含屬性(fields)，每個屬性都有自己的數據類型，這些屬性用於存儲相關的數據。

3. **命名**：每個屬性都有一個名稱，用於標識和訪問它們。這使得代碼更加可讀和可維護。

4. **實例化**：可以創建結構體的實例，用於存儲具體的數據。實例化一個結構體時，需要提供每個屬性的值。

5. **方法**：結構體可以擁有自己的方法，允許你在結構體上執行操作。

6. **可變性**：你可以聲明結構體實例為可變(mutable)，允許在實例上修改屬性的值。

7. **生命週期**：結構體可以包含引用，從而引入了生命週期的概念，用於確保引用的有效性。

結構體是 Rust 中組織和抽象數據的重要工具，它們常常用於建模真實世界的實體、配置選項、狀態等。結構體的定義通常包括了屬性的名稱和數據類型，以及可選的方法，以便在實際應用中對結構體執行操作。

#### 案例： 創建一個代表簡單金融工具的結構體

在 Rust 中進行量化金融建模時，通常需要自定義類型來表示金融工具、交易策略或其他相關概念。自定義類型可以是結構體(`struct`)或枚舉(`enum`)，具體取決於我們的需求。下面是一個簡單的示例，演示如何在 Rust 中創建自定義結構體來表示一個簡單的金融工具(例如股票)：

```rust
// 定義一個股票的結構體
struct Stock {
    symbol: String,  // 股票代碼
    price: f64,      // 當前價格
    quantity: u32,   // 持有數量
}

fn main() {
    // 創建一個股票實例
    let apple_stock = Stock {
        symbol: String::from("AAPL"),
        price: 150.50,
        quantity: 1000,
    };

    // 打印股票信息
    println!("股票代碼: {}", apple_stock.symbol);
    println!("股票價格: ${:.2}", apple_stock.price);
    println!("股票數量: {}", apple_stock.quantity);

    // 計算總價值
    let total_value = apple_stock.price * apple_stock.quantity as f64;
    println!("總價值: ${:.2}", total_value);
}

```

**執行結果:**

```text
股票代碼: AAPL
股票價格: $150.50
股票數量: 1000
總價值: $150500.00
```

##  4.2 枚舉(`enum`)

在 Rust 中，`enum` 是一種自定義數據類型，用於表示具有一組離散可能值的類型。它允許你定義一組相關的值，併為每個值指定一個名稱。`enum` 通常用於表示枚舉類型，它可以包含不同的變體(也稱為成員或枚舉項)，每個變體可以存儲不同類型的數據。

以下是一個簡單的示例，展示瞭如何定義和使用 `enum`：

```rust
// 定義一個名為 Color 的枚舉
enum Color {
    Red,
    Green,
    Blue,
}

fn main() {
    // 創建枚舉變量
    let favorite_color = Color::Blue;

    // 使用模式匹配匹配枚舉值
    match favorite_color {
        Color::Red => println!("紅色是我的最愛！"),
        Color::Green => println!("綠色也不錯。"),
        Color::Blue => println!("藍色是我的最愛！"),
    }
}
```

在這個示例中，我們定義了一個名為 `Color` 的枚舉，它有三個變體：`Red`、`Green` 和 `Blue`。每個變體代表了一種顏色。然後，在 `main` 函數中，我們創建了一個 `favorite_color` 變量，並將其設置為 `Color::Blue`，然後使用 `match` 表達式對枚舉值進行模式匹配，根據顏色輸出不同的消息。

枚舉的主要優點包括：

1. **類型安全**：枚舉確保變體的值是類型安全的，不會出現無效的值。

2. **可讀性**：枚舉可以為每個值提供描述性的名稱，使代碼更具可讀性。

3. **模式匹配**：枚舉與模式匹配結合使用，可用於處理不同的情況，使代碼更具表達力。

4. **可擴展性**：你可以隨時添加新的變體來擴展枚舉類型，而不會破壞現有代碼。

枚舉在 Rust 中被廣泛用於表示各種不同的情況和狀態，包括錯誤處理、選項類型等等。它是 Rust 強大的工具之一，有助於編寫類型安全且清晰的代碼。

### 案例1： 投資組合管理系統

以下是一個示例，演示瞭如何在 Rust 中使用枚舉和結構體來處理量化金融中的複雜案例。在這個示例中，我們將創建一個簡化的投資組合管理系統，用於跟蹤不同類型的資產(股票、債券等)和它們的價格。我們將使用枚舉來表示不同類型的資產，並使用結構體來表示資產的詳細信息。

```rust
// 定義一個枚舉，表示不同類型的資產
enum AssetType {
    Stock,
    Bond,
    RealEstate,
}

// 定義一個結構體，表示資產
struct Asset {
    name: String,
    asset_type: AssetType,
    price: f64,
}

// 定義一個投資組合結構體，包含多個資產
struct Portfolio {
    assets: Vec<Asset>,
}

impl Portfolio {
    // 計算投資組合的總價值
    fn calculate_total_value(&self) -> f64 {
        let mut total_value = 0.0;
        for asset in &self.assets {
            total_value += asset.price;
        }
        total_value
    }
}

fn main() {
    // 創建不同類型的資產
    let stock1 = Asset {
        name: String::from("AAPL"),
        asset_type: AssetType::Stock,
        price: 150.0,
    };

    let bond1 = Asset {
        name: String::from("Government Bond"),
        asset_type: AssetType::Bond,
        price: 1000.0,
    };

    let real_estate1 = Asset {
        name: String::from("Commercial Property"),
        asset_type: AssetType::RealEstate,
        price: 500000.0,
    };

    // 創建投資組合並添加資產
    let mut portfolio = Portfolio {
        assets: Vec::new(),
    };

    portfolio.assets.push(stock1);
    portfolio.assets.push(bond1);
    portfolio.assets.push(real_estate1);

    // 計算投資組合的總價值
    let total_value = portfolio.calculate_total_value();

    // 打印結果
    println!("投資組合總價值: ${}", total_value);
}
```

**執行結果:**

```text
投資組合總價值: $501150
```

在這個示例中，我們定義了一個名為 `AssetType` 的枚舉，它代表不同類型的資產(股票、債券、房地產)。然後，我們定義了一個名為 `Asset` 的結構體，用於表示單個資產的詳細信息，包括名稱、資產類型和價格。接下來，我們定義了一個名為 `Portfolio` 的結構體，它包含一個 `Vec<Asset>`，表示投資組閤中的多個資產。

在 `Portfolio` 結構體上，我們實現了一個方法 `calculate_total_value`，用於計算投資組合的總價值。該方法遍歷投資組閤中的所有資產，並將它們的價格相加，得到總價值。

在 `main` 函數中，我們創建了不同類型的資產，然後創建了一個投資組合並向其中添加資產。最後，我們調用 `calculate_total_value` 方法計算投資組合的總價值，並將結果打印出來。

這個示例展示瞭如何使用枚舉和結構體來建模複雜的量化金融問題，以及如何在 Rust 中實現相應的功能。在實際應用中，你可以根據需要擴展這個示例，包括更多的資產類型、交易規則等等。



### 案例2： 訂單執行模擬

當在量化金融中使用 Rust 時，枚舉(`enum`)常常用於表示不同的金融工具或訂單類型。以下是一個示例，演示如何在 Rust 中使用枚舉來表示不同類型的金融工具和訂單，並模擬執行這些訂單：

```rust
// 定義一個枚舉，表示不同類型的金融工具
enum FinancialInstrument {
    Stock,
    Bond,
    Option,
    Future,
}

// 定義一個枚舉，表示不同類型的訂單
enum OrderType {
    Market,
    Limit(f64), // 限價訂單，包括價格限制
    Stop(f64),  // 止損訂單，包括觸發價格
}

// 定義一個結構體，表示訂單
struct Order {
    instrument: FinancialInstrument,
    order_type: OrderType,
    quantity: i32,
}

impl Order {
    // 模擬執行訂單
    fn execute(&self) {
        match &self.order_type {
            OrderType::Market => println!("執行市價訂單: {:?} x {}", self.instrument, self.quantity),
            OrderType::Limit(price) => {
                println!("執行限價訂單: {:?} x {} (價格限制: ${})", self.instrument, self.quantity, price)
            }
            OrderType::Stop(trigger_price) => {
                println!("執行止損訂單: {:?} x {} (觸發價格: ${})", self.instrument, self.quantity, trigger_price)
            }
        }
    }
}

fn main() {
    // 創建不同類型的訂單
    let market_order = Order {
        instrument: FinancialInstrument::Stock,
        order_type: OrderType::Market,
        quantity: 100,
    };

    let limit_order = Order {
        instrument: FinancialInstrument::Option,
        order_type: OrderType::Limit(50.0),
        quantity: 50,
    };

    let stop_order = Order {
        instrument: FinancialInstrument::Future,
        order_type: OrderType::Stop(4900.0),
        quantity: 10,
    };

    // 執行訂單
    market_order.execute();
    limit_order.execute();
    stop_order.execute();
}
```

在這個示例中，我們定義了兩個枚舉：`FinancialInstrument` 用於表示不同類型的金融工具(股票、債券、期權、期貨等)，`OrderType` 用於表示不同類型的訂單(市價訂單、限價訂單、止損訂單)。`OrderType::Limit` 和 `OrderType::Stop` 變體包括了價格限制和觸發價格的信息。

然後，我們定義了一個 `Order` 結構體，它包含了金融工具類型、訂單類型和訂單數量。在 `Order` 結構體上，我們實現了一個方法 `execute`，用於模擬執行訂單，並根據訂單類型打印相應的信息。

在 `main` 函數中，我們創建了不同類型的訂單，並使用 `execute` 方法模擬執行它們。這個示例展示瞭如何使用枚舉和結構體來表示量化金融中的不同概念，並模擬執行相關操作。你可以根據實際需求擴展這個示例，包括更多的金融工具類型和訂單類型。



# Chapter 5 - 標準庫類型 

當提到 Rust 的標準庫時，確實包含了許多自定義類型，它們在原生數據類型的基礎上進行了擴展和增強，為 Rust 程序提供了更多的功能和靈活性。以下是一些常見的自定義類型和類型包裝器：

1. **可增長的字符串(`String`)**：

   - `String` 是一個可變的、堆分配的字符串類型，與原生的字符串切片(`str`)不同。它允許**動態地**增加和修改字符串內容。

   ```rust
   let greeting = String::from("Hello, ");
   let name = "Alice";
   let message = greeting + name;
   ```

2. **可增長的向量(`Vec`)**：

   - `Vec` 是一個可變的、堆分配的**動態數組**，可以根據需要動態增加或刪除元素。

   ```rust
   let mut numbers = Vec::new();
   numbers.push(1);
   numbers.push(2);
   ```

3. **選項類型(`Option`)**：

   - `Option` 表示一個可能存在也可能**不存在的值**，它用於處理缺失值的情況。它有兩個變體：`Some(value)` 表示存在一個值，`None` 表示缺失值。

   ```rust
   fn divide(x: f64, y: f64) -> Option<f64> {
       if y == 0.0 {
           None
       } else {
           Some(x / y)
       }
   }
   ```

4. **錯誤處理類型(`Result`)**：

   - `Result` 用於表示操作的結果，可能成功**也可能失敗**。它有兩個變體：`Ok(value)` 表示操作成功並返回一個值，`Err(error)` 表示操作失敗並返回一個錯誤。

   ```rust
   fn parse_input(input: &str) -> Result<i32, &str> {
       if let Ok(value) = input.parse::<i32>() {
           Ok(value)
       } else {
           Err("Invalid input")
       }
   }
   ```

5. **堆分配的指針(`Box`)**：

   -  `Box` 是 Rust 的類型包裝器，它允許將數據在堆上分配，並提供了堆數據的所有權。它通常用於管理內存和解決所有權問題。

   ```rust
   fn create_boxed_integer() -> Box<i32> {
       Box::new(42)
   }
   ```

這些標準類型和類型包裝器擴展了 Rust 的基本數據類型，使其更適用於各種編程任務。

## 5.1 字符串 (String)

`String` 是 Rust 中的一種字符串類型，它是一個可變的、堆分配的字符串。下面詳細解釋和介紹 `String`，包括其內存特徵：

1. **可變性**：
   - `String` 是可變的，這意味著你可以動態地向其添加、修改或刪除字符，而不需要創建一個新的字符串對象。
2. **堆分配**：
   - `String` 的內存是在堆上分配的。這意味著它的大小是動態的，可以根據需要動態增長或減小，而不受棧內存的限制。
   - 堆分配的內存由 Rust 的所有權系統管理，當不再需要 `String` 時，它會自動釋放其內存，防止內存洩漏。
3. **UTF-8 編碼**：
   - `String` 內部存儲的數據是一個有效的 UTF-8 字符序列。UTF-8 是一種可變長度的字符編碼，允許表示各種語言的字符，並且在全球範圍內廣泛使用。
   - 由於 `String` 內部是有效的 UTF-8 編碼，因此它是一個合法的 Unicode 字符串。
4. **字節向量(`Vec<u8>`)**：
   - `String` 的底層數據結構是一個由字節(`u8`)組成的向量，即 `Vec<u8>`。
   - 這個字節向量存儲了字符串的每個字符的 UTF-8 編碼字節序列。
5. **擁有所有權**：
   - `String` 擁有其內部數據的所有權。這意味著當你將一個 `String` 分配給另一個 `String` 或在函數之間傳遞時，所有權會轉移，而不是複製數據。這有助於避免不必要的內存複製。
6. **克隆和複製**：
   - `String` 類型實現了 `Clone` trait，因此你可以使用 `.clone()` 方法克隆一個 `String`，這將創建一個新的 `String`，擁有相同的內容。
   - 與 `&str` 不同，`String` 是可以複製的(`Copy` trait)，這意味著它在某些情況下可以自動複製，而不會移動所有權。

**示例：**

```rust
fn main() {
    // 創建一個新的空字符串
    let mut my_string = String::new();

    // 向字符串添加內容
    my_string.push_str("Hello, ");
    my_string.push_str("world!");

    println!("{}", my_string); // 輸出 "Hello, world!"
}
```

**總結：**

`String` 是 Rust 中的字符串類型，具有可變性、堆分配的特性，內部存儲有效的 UTF-8 編碼數據，並擁有所有權。它是一種非常有用的字符串類型，適合處理需要動態增長和修改內容的字符串操作。同時，Rust 的所有權系統確保了內存安全性和有效的內存管理。

之前我們在第三章詳細講過&str , 以下是一個表格，對比了 `String` 和 `&str` 這兩種 Rust 字符串類型的主要特性：

| 特性             |            `String`            |            `&str`             |
| :--------------- | :----------------------------: | :---------------------------: |
| 可變性           |              可變              |            不可變             |
| 內存分配         |             堆分配             | 不擁有內存，通常是棧上的視圖  |
| UTF-8 編碼       |     有效的 UTF-8 字符序列      |     有效的 UTF-8 字符序列     |
| 底層數據結構     |      `Vec<u8>`(字節向量)       |      無(只是切片的引用)       |
| 所有權           |      擁有內部數據的所有權      |    不擁有內部數據的所有權     |
| 可克隆(Clone)    |  可克隆(實現了 `Clone` trait)  |           不可克隆            |
| 移動和複製       |  移動或複製數據，具體情況而定  |  複製切片的引用，無內存移動   |
| 增加、修改和刪除 |  可以動態進行，不需要重新分配  |     不可變，不能直接修改      |
| 適用場景         | 動態字符串，需要增加和修改內容 |  讀取、傳遞現有字符串的引用   |
| 內存管理         |     Rust 的所有權系統管理      | Rust 的借用和生命週期系統管理 |

在生產環境中，根據你的具體需求來選擇使用哪種類型，通常情況下，`String` 適用於動態字符串內容的構建和修改，而 `&str` 適用於只需要讀取字符串內容的情況，或者作為函數參數和返回值。

## 5.2 向量 (vector)

向量(Vector)是 Rust 中的一種動態數組數據結構，它允許你存儲多個相同類型的元素，並且可以在運行時動態增長或縮小。向量是 Rust 標準庫(`std::vec::Vec`)提供的一種非常有用的數據結構，以下是關於向量的詳細解釋：

**特性和用途**：

1. **動態大小**：向量的大小可以在運行時**動態增長或縮小**，而不需要事先指定大小。這使得向量適用於需要動態管理元素的情況，避免了固定數組大小的限制。

2. **堆分配**：向量的元素是在堆上分配的，這意味著它們不受棧內存的限制，**可以容納大量元素**。向量的內存由 Rust 的所有權系統管理，確保在不再需要時釋放內存。

3. **類型安全**：向量只能**存儲相同類型的元素**，這提供了類型安全性和編譯時檢查。如果嘗試將不同類型的元素插入到向量中，Rust 編譯器會報錯。

4. **索引訪問**：可以使用索引來訪問向量中的元素。Rust 的索引從 0 開始，因此第一個元素的索引為 0。

   ```rust
   let my_vec = vec![1, 2, 3];
   let first_element = my_vec[0]; // 訪問第一個元素
   ```

5. **迭代**：可以使用迭代器來遍歷向量中的元素。Rust 提供了多種方法來迭代向量，包括 `for` 循環、`iter()` 方法等。

   ```rust
   let my_vec = vec![1, 2, 3];
   for item in &my_vec {
       println!("Element: {}", item);
   }
   ```

6. **增加和刪除元素**：向量提供了多種方法來增加和刪除元素，如 `push()`、`pop()`、`insert()`、`remove()` 等。

   以下是關於 `push()`、`pop()`、`insert()` 和 `remove()` 方法的詳細解釋，以及它們之間的異同點：

   | 方法                  | 功能                           | 異同點                                                       |
   | --------------------- | ------------------------------ | ------------------------------------------------------------ |
   | `push(item)`          | 向向量的末尾添加一個元素。     | - `push()` 方法是向向量的末尾添加元素。<br />- 可以傳遞單個元素，也可以傳遞多個元素。 |
   | `pop()`               | 移除並返回向量的最後一個元素。 | - `pop()` 方法會移除並返回向量的最後一個元素。<br />- 如果向量為空，它會返回 `None`(`Option` 類型)。 |
   | `insert(index, item)` | 在指定索引位置插入一個元素。   | - `insert()` 方法可以在向量的任意位置插入元素。<br />- 需要傳遞要插入的索引和元素。<br />- 插入操作可能導致元素的移動，因此具有 O(n) 的時間複雜度。 |
   | `remove(index)`       | 移除並返回指定索引位置的元素。 | - `remove()` 方法可以移除向量中指定索引位置的元素。<br />- 移除操作可能導致元素的移動，因此具有 O(n) 的時間複雜度。 |

   這些方法允許你在向量中添加、刪除和修改元素，以及按照需要進行動態調整。需要注意的是，`push()` 和 `pop()` 通常用於向向量的末尾添加和移除元素，而 `insert()` 和 `remove()` 允許你在任意位置插入和移除元素。由於插入和移除操作可能涉及元素的移動，因此它們的時間複雜度是 O(n)，其中 n 是向量中的元素數量。

   **示例：**

   ```rust
   fn main() {
       let mut my_vec = vec![1, 2, 3];
   
       my_vec.push(4); // 向末尾添加元素，my_vec 現在為 [1, 2, 3, 4]
   
       let popped = my_vec.pop(); // 移除並返回最後一個元素，popped 是 Some(4)，my_vec 現在為 [1, 2, 3]
   
       my_vec.insert(1, 5); // 在索引 1 處插入元素 5，my_vec 現在為 [1, 5, 2, 3]
   
       let removed = my_vec.remove(2); // 移除並返回索引 2 的元素，removed 是 2，my_vec 現在為 [1, 5, 3]
   
       println!("my_vec after operations: {:?}", my_vec);
       println!("Popped value: {:?}", popped);
       println!("Removed value: {:?}", removed);
   }
   ```

   執行結果：

   ```bash
   my_vec after operations: [1, 5, 3]
   Popped value: Some(4) #注意，pop()是有可能可以無法返回數值的方法，所以4會被some包裹。 具體我們會在本章第4節詳敘。
   Removed value: 2
   ```

   **總結：**這些方法是用於向向量中添加、移除和修改元素的常見操作，根據具體需求選擇使用合適的方法。 `push()` 和 `pop()` 適用於末尾操作，而 `insert()` 和 `remove()` 可以在任何位置執行操作。但要注意，有時候插入和移除操作可能導致元素的移動，因此在性能敏感的情況下需要謹慎使用。

7. **切片操作**：可以使用切片操作來獲取向量的一部分，返回的是一個切片類型 `&[T]`。

   ```rust
   let my_vec = vec![1, 2, 3, 4, 5];
   let slice = &my_vec[1..4]; // 獲取索引 1 到 3 的元素的切片
   ```

### 案例：處理期貨合約列表

以下是一個示例，演示瞭如何使用 `push()`、`pop()`、`insert()` 和 `remove()` 方法對存儲中國期貨合約列表的向量進行操作

```rust
fn main() {
    // 創建一個向量來存儲中國期貨合約列表
    let mut futures_contracts: Vec<String> = vec![
        "AU2012".to_string(),
        "IF2110".to_string(),
        "C2109".to_string(),
    ];

    // 使用 push() 方法添加新的期貨合約
    futures_contracts.push("IH2110".to_string());

    // 打印當前期貨合約列表
    println!("當前期貨合約列表: {:?}", futures_contracts);

    // 使用 pop() 方法移除最後一個期貨合約
    let popped_contract = futures_contracts.pop();
    println!("移除的最後一個期貨合約: {:?}", popped_contract);

    // 使用 insert() 方法在指定位置插入新的期貨合約
    futures_contracts.insert(1, "IC2110".to_string());
    println!("插入新期貨合約後的列表: {:?}", futures_contracts);

    // 使用 remove() 方法移除指定位置的期貨合約
    let removed_contract = futures_contracts.remove(2);
    println!("移除的第三個期貨合約: {:?}", removed_contract);

    // 打印最終的期貨合約列表
    println!("最終期貨合約列表: {:?}", futures_contracts);
}


```

**執行結果：**

```text
當前期貨合約列表: ["AU2012", "IF2110", "C2109", "IH2110"]
移除的最後一個期貨合約: Some("IH2110")
插入新期貨合約後的列表: ["AU2012", "IC2110", "IF2110", "C2109"]
移除的第三個期貨合約: Some("IF2110")
最終期貨合約列表: ["AU2012", "IC2110", "C2109"]
```

這些輸出顯示了不同方法對中國期貨合約列表的操作結果。我們使用 `push()` 添加了一個期貨合約，`pop()` 移除了最後一個期貨合約，`insert()` 在指定位置插入了一個期貨合約，而 `remove()` 移除了指定位置的期貨合約。最後，我們打印了最終的期貨合約列表。

## **5.3** 哈希映射(Hashmap)

`HashMap` 是 Rust 標準庫中的一種數據結構，用於存儲鍵值對(key-value pairs)。它是一種哈希表(hash table)的實現，允許你通過鍵來快速檢索值。

`HashMap` 在 Rust 中的功能類似於 Python 中的字典(`dict`)。它們都是用於存儲鍵值對的數據結構，允許你通過鍵來查找對應的值。以下是一些類比：

- Rust 的 `HashMap` <=> Python 的 `dict`
- Rust 的 鍵(key) <=> Python 的 鍵(key)
- Rust 的 值(value) <=> Python 的 值(value)

與 Python 字典類似，Rust 的 `HashMap` 具有快速的查找性能，允許你通過鍵快速檢索對應的值。此外，它們都是動態大小的，可以根據需要添加或刪除鍵值對。然而，Rust 和 Python 在語法和語義上有一些不同之處，因為它們是不同的編程語言，具有不同的特性和約束。

總之，如果你熟悉 Python 中的字典操作，那麼在 Rust 中使用 `HashMap` 應該會感到非常自然，因為它們提供了類似的鍵值對存儲和檢索功能。以下是關於 `HashMap` 的詳細解釋：

1. **鍵值對存儲**：`HashMap` 存儲的數據以鍵值對的形式存在，每個鍵都有一個對應的值。鍵是唯一的，而值可以重複。

2. **動態大小**：與數組不同，`HashMap` 是動態大小的，這意味著它可以根據需要增長或縮小以容納鍵值對。

3. **快速檢索**：`HashMap` 的實現基於哈希表，這使得在其中查找值的速度非常快，通常是常數時間複雜度(O(1))。

4. **無序集合**：`HashMap` 不維護元素的順序，因此它不會保留插入元素的順序。如果需要有序集合，可以考慮使用 `BTreeMap`。

5. **泛型支持**：`HashMap` 是泛型的，這意味著你可以在其中存儲不同類型的鍵和值，只要它們滿足 `Eq` 和 `Hash` trait 的要求。

6. **自動擴容**：當 `HashMap` 的負載因子(load factor)超過一定閾值時，它會自動擴容，以保持檢索性能。

7. **安全性**：Rust 的 `HashMap` 提供了安全性保證，防止懸垂引用和數據競爭。它使用所有權系統來管理內存。

8. **示例用途**：`HashMap` 在許多情況下都非常有用，例如用於緩存、配置管理、數據索引等。它提供了一種高效的方式來存儲和檢索鍵值對。

以下是一個簡單的示例，展示如何創建、插入、檢索和刪除 `HashMap` 中的鍵值對：

```rust
use std::collections::HashMap;

fn main() {
    // 創建一個空的 HashMap，鍵是字符串，值是整數
    let mut scores = HashMap::new();

    // 插入鍵值對
    scores.insert(String::from("Alice"), 100);
    scores.insert(String::from("Bob"), 90);

    // 檢索鍵對應的值
    let _alice_score = scores.get("Alice"); // 返回 Some(100)

    // 刪除鍵值對
    scores.remove("Bob");

    // 遍歷 HashMap 中的鍵值對
    for (name, score) in &scores {
        println!("{} 的分數是 {}", name, score);
    }
}
```

**執行結果**：

```text
Alice 的分數是 100
```

這是一個簡單的 `HashMap` 示例，展示瞭如何使用 `HashMap` 進行基本操作。你可以根據自己的需求插入、刪除、檢索鍵值對，以及遍歷 `HashMap` 中的元素。

###  案例1：管理股票價格數據

HashMap 當然也適合用於管理金融數據和執行各種金融計算。以下是一個簡單的 Rust 量化金融案例，展示瞭如何使用 HashMap 來管理股票價格數據：

```rust
use std::collections::HashMap;

// 定義一個股票價格數據結構
#[derive(Debug)]
struct StockPrice {
    symbol: String,
    price: f64,
}

fn main() {
    // 創建一個空的 HashMap 來存儲股票價格數據
    let mut stock_prices: HashMap<String, StockPrice> = HashMap::new();

    // 添加股票價格數據
    let stock1 = StockPrice {
        symbol: String::from("AAPL"),
        price: 150.0,
    };
    stock_prices.insert(String::from("AAPL"), stock1);

    let stock2 = StockPrice {
        symbol: String::from("GOOGL"),
        price: 2800.0,
    };
    stock_prices.insert(String::from("GOOGL"), stock2);

    let stock3 = StockPrice {
        symbol: String::from("MSFT"),
        price: 300.0,
    };
    stock_prices.insert(String::from("MSFT"), stock3);

    // 查詢股票價格
    if let Some(price) = stock_prices.get("AAPL") {
        println!("The price of AAPL is ${}", price.price);
    } else {
        println!("AAPL not found in the stock prices.");
    }

    // 遍歷並打印所有股票價格
    for (symbol, price) in &stock_prices {
        println!("{}: ${}", symbol, price.price);
    }
}

```

**執行結果:**

```text
The price of AAPL is $150
GOOGL: $2800
MSFT: $300
AAPL: $150
```



##### **思考:Rust 的 hashmap 是不是和 python 的字典或者 C++ 的map有相似性?**

是的，Rust 中的 HashMap 與 Python 中的字典(Dictionary)和 C++ 中的 std::unordered_map(無序映射)有相似性。它們都是用於存儲鍵值對的數據結構，允許你通過鍵快速查找值。

以下是一些共同點：

1. **鍵值對存儲**：HashMap、字典和無序映射都以鍵值對的形式存儲數據，每個鍵都映射到一個值。

2. **快速查找**：它們都提供了快速的查找操作，你可以根據鍵來獲取相應的值，時間複雜度通常為 O(1)。

3. **插入和刪除**：你可以在這些數據結構中插入新的鍵值對，也可以刪除已有的鍵值對。

4. **可變性**：它們都支持在已創建的數據結構中修改值。

5. **遍歷**：你可以遍歷這些數據結構中的所有鍵值對。

儘管它們在概念上相似，但在不同編程語言中的實現和用法可能會有一些差異。例如，Rust 的 HashMap 是類型安全的，要求鍵和值都具有相同的類型，而 Python 的字典可以容納不同類型的鍵和值。此外，性能和內存管理方面也會有差異。

總之，這些數據結構在不同的編程語言中都用於相似的用途，但具體的實現和用法可能因語言而異。在選擇使用時，應考慮語言的要求和性能特性。



### 案例2： 數據類型異質但是仍然安全的Hashmap



在 Rust 中，標準庫提供的 `HashMap` 是類型安全的，這意味著在編譯時，編譯器會強制要求鍵和值都具有相同的類型。這是為了確保代碼的類型安全性，防止在運行時發生類型不匹配的錯誤。

如果你需要在 Rust 中創建一個 HashMap，其中鍵和值具有不同的類型，你可以使用 Rust 的枚舉(Enum)來實現這一目標。具體來說，你可以創建一個枚舉，枚舉的變體代表不同的類型，然後將枚舉用作 HashMap 的值。這樣，你可以在 HashMap 中存儲不同類型的數據，而仍然保持類型安全。

以下是一個示例，演示瞭如何在 Rust 中創建一個 HashMap，其中鍵的類型是字符串，而值的類型是枚舉，枚舉的變體可以表示不同的數據類型：

```rust
use std::collections::HashMap;

// 定義一個枚舉，表示不同的數據類型
enum Value {
    Integer(i32),
    Float(f64),
    String(String),
}

fn main() {
    // 創建一個 HashMap，鍵是字符串，值是枚舉
    let mut data: HashMap<String, Value> = HashMap::new();

    // 向 HashMap 中添加不同類型的數據
    data.insert(String::from("age"), Value::Integer(30));
    data.insert(String::from("height"), Value::Float(175.5));
    data.insert(String::from("name"), Value::String(String::from("John")));

    // 訪問和打印數據
    if let Some(value) = data.get("age") {
        match value {
            Value::Integer(age) => println!("Age: {}", age),
            _ => println!("Invalid data type for age."),
        }
    }

    if let Some(value) = data.get("height") {
        match value {
            Value::Float(height) => println!("Height: {}", height),
            _ => println!("Invalid data type for height."),
        }
    }

    if let Some(value) = data.get("name") {
        match value {
            Value::String(name) => println!("Name: {}", name),
            _ => println!("Invalid data type for name."),
        }
    }
}
```

**執行結果:**

```text
Age: 30
Height: 175.5
Name: John
```



在這個示例中，我們定義了一個名為 `Value` 的枚舉，它有三個變體，分別代表整數、浮點數和字符串類型的數據。然後，我們創建了一個 HashMap，其中鍵是字符串，值是 `Value` 枚舉。這使得我們可以在 HashMap 中存儲不同類型的數據，而仍然保持類型安全。

## 5.4 選項類型(optional types)

選項類型(Option types)是 Rust 中一種非常重要的枚舉類型，**用於表示一個值要麼存在，要麼不存在的情況**。這種概念在實現了圖靈完備的編程語言中非常常見，尤其是在處理可能出現錯誤或缺失數據的情況下非常有用。下面詳細論述 Rust 中的選項類型：

1. **枚舉定義**：

   在 Rust 中，選項類型由標準庫的 `Option` 枚舉來表示。它有兩個變體：

   - `Some(T)`: 表示一個值存在，並將這個值封裝在 `Some` 內。
   - `None`: 表示值不存在，通常用於表示缺失數據或錯誤。

   `Option` 的定義如下：

   ```rust
   enum Option<T> {
       Some(T),
       None,
   }
   ```

2. **用途**：

   - **處理可能的空值**：選項類型常用於處理可能為空(`null` 或 `nil`)的情況。它允許你明確地處理值的存在和缺失，而不會出現空指針異常。

   - **錯誤處理**：選項類型也用於函數返回值，特別是那些可能會出現錯誤的情況。例如，`Result` 類型就是基於 `Option` 構建的，其中 `Ok(T)` 表示成功幷包含一個值，而 `Err(E)` 表示錯誤幷包含一個錯誤信息。

3. **示例**：

   使用選項類型來處理可能為空的情況非常常見。以下是一個示例，演示瞭如何使用選項類型來查找向量中的最大值：

   ```rust
   fn find_max(numbers: Vec<i32>) -> Option<i32> {
       if numbers.is_empty() {
           return None; // 空向量，返回 None 表示值不存在
       }
   
       let mut max = numbers[0];
       for &num in &numbers {
           if num > max {
               max = num;
           }
       }
   
       Some(max) // 返回最大值封裝在 Some 內
   }
   
   fn main() {
       let numbers = vec![10, 5, 20, 8, 15];
       match find_max(numbers) {
           Some(max) => println!("最大值是: {}", max),
           None => println!("向量為空或沒有最大值。"),
       }
   }
   ```

   在這個示例中，`find_max` 函數接受一個整數向量，並返回一個 `Option<i32>` 類型的結果。如果向量為空，它返回 `None`；否則，返回最大值封裝在 `Some` 中。在 `main` 函數中，我們使用 `match` 表達式來處理 `find_max` 的結果，分別處理存在值和不存在值的情況。

4. **unwrap 和 expect 方法**：

   為了從 `Option` 中獲取封裝的值，你可以使用 `unwrap()` 方法。但要小心，如果 `Option` 是 `None`，調用 `unwrap()` 將導致程序 panic。

   ```rust
   let result: Option<i32> = Some(42);
   let value = result.unwrap(); // 如果是 Some，獲取封裝的值，否則 panic
   ```

   為了更加安全地處理 `None`，你可以使用 `expect()` 方法，它允許你提供一個自定義的錯誤消息。

   ```rust
   let result: Option<i32> = None;
   let value = result.expect("值不存在"); // 提供自定義的錯誤消息
   ```

5. **if let 表達式**：

   你可以使用 `if let` 表達式來簡化匹配 `Option` 的過程，特別是在只關心其中一種情況的情況下。

   ```rust
   let result: Option<i32> = Some(42);
   
   if let Some(value) = result {
       println!("存在值: {}", value);
   } else {
       println!("值不存在");
   }
   ```

   這可以減少代碼的嵌套，並使代碼更加清晰。

總之，選項類型(Option types)是 Rust 中用於表示值的存在和缺失的強大工具，可用於處理可能為空的情況以及錯誤處理。它是 Rust 語言的核心特性之一，有助於編寫更安全和可靠的代碼。

### 案例:  處理銀行賬戶餘額查詢

以下是一個簡單的金融領域案例，演示瞭如何在 Rust 中使用選項類型來處理銀行賬戶餘額查詢的情況：

```rust
struct BankAccount {
    account_holder: String,
    balance: Option<f64>, // 使用選項類型表示餘額，可能為空
}

impl BankAccount {
    fn new(account_holder: &str) -> BankAccount {
        BankAccount {
            account_holder: account_holder.to_string(),
            balance: None, // 初始時沒有餘額
        }
    }

    fn deposit(&mut self, amount: f64) {
        // 存款操作，更新餘額
        if let Some(existing_balance) = self.balance {
            self.balance = Some(existing_balance + amount);
        } else {
            self.balance = Some(amount);
        }
    }

    fn withdraw(&mut self, amount: f64) -> Option<f64> {
        // 取款操作，更新餘額並返回取款金額
        if let Some(existing_balance) = self.balance {
            if existing_balance >= amount {
                self.balance = Some(existing_balance - amount);
                Some(amount)
            } else {
                None // 餘額不足，返回 None 表示取款失敗
            }
        } else {
            None // 沒有餘額可取，返回 None
        }
    }

    fn check_balance(&self) -> Option<f64> {
        // 查詢餘額操作
        self.balance
    }
}

fn main() {
    let mut account = BankAccount::new("Alice"); // 建立新賬戶，裡面沒有餘額。

    account.deposit(1000.0); // 存入1000
    println!("存款後的餘額: {:?}", account.check_balance());

    if let Some(withdrawn_amount) = account.withdraw(500.0) {  // 在Some方法的包裹下安全取走500
        println!("成功取款: {:?}", withdrawn_amount);
    } else {
        println!("取款失敗，餘額不足或沒有餘額。");
    }

    println!("最終餘額: {:?}", account.check_balance());
}
```

**執行結果：**

```text
存款後的餘額: Some(1000.0)
成功取款: 500.0
最終餘額: Some(500.0)
```

在這個示例中，我們定義了一個 `BankAccount` 結構體，其中 `balance` 使用了選項類型 `Option<f64>` 表示餘額。我們實現了存款 (`deposit`)、取款 (`withdraw`) 和查詢餘額 (`check_balance`) 的方法來操作賬戶餘額。這些方法都使用了選項類型來處理可能的空值情況。

在 `main` 函數中，我們創建了一個銀行賬戶，進行了存款和取款操作，並查詢了最終的餘額。使用選項類型使我們能夠更好地處理可能的錯誤或空值情況，以確保銀行賬戶操作的安全性和可靠性。

## 5.5 錯誤處理類型(error handling types)

### 5.5.1 Result枚舉類型

`Result` 是 Rust 中用於處理可能產生錯誤的值的枚舉類型。它被廣泛用於 Rust 程序中，用於返回函數執行的結果，並允許明確地處理潛在的錯誤情況。`Result` 枚舉有兩個變體：

1. `Ok(T)`：表示操作成功，包含一個類型為 `T` 的值，其中 `T` 是成功結果的類型。

2. `Err(E)`：表示操作失敗，包含一個類型為 `E` 的錯誤值，其中 `E` 是錯誤的類型。錯誤值通常用於攜帶有關失敗原因的信息。

`Result` 的主要目標是提供一種安全、可靠的方式來處理錯誤，而不需要在函數中使用異常。它強製程序員顯式地處理錯誤，以確保錯誤情況不會被忽略。

以下是使用 `Result` 的一些示例：

```rust
use std::fs::File;           // 導入文件操作相關的模塊
use std::io::Read;           // 導入輸入輸出相關的模塊

// 定義一個函數，該函數用於讀取文件的內容
fn read_file_contents(file_path: &str) -> Result<String, std::io::Error> {
    // 打開指定路徑的文件並返回結果(Result類型)
    let mut file = File::open(file_path)?;  // ? 用於將可能的錯誤傳播到調用者

    // 創建一個可變字符串來存儲文件的內容
    let mut contents = String::new();

    // 讀取文件的內容到字符串中，並將結果存儲在 contents 變量中
    file.read_to_string(&mut contents)?;

    // 如果成功讀取文件內容，返回包含內容的 Result::Ok(contents)
    Ok(contents)
}

// 主函數
fn main() {
    // 調用 read_file_contents 函數來嘗試讀取文件
    match read_file_contents("example.txt") {  // 使用 match 來處理函數的返回值
        // 如果操作成功，執行以下代碼塊
        Ok(contents) => {
            // 打印文件的內容
            println!("File contents: {}", contents);
        }
        // 如果操作失敗，執行以下代碼塊
        Err(error) => {
            // 打印錯誤信息
            eprintln!("Error reading file: {}", error);
        }
    }
}
```

**可能的結果：**

假設 "example.txt" 文件存在且包含文本 "Hello, Rust!"，那麼程序的輸出將是：

```bash
File contents: Hello, Rust!
```

如果文件不存在或出現其他IO錯誤，程序將打印類似以下內容的錯誤信息：

```bash
Error reading file: No such file or directory (os error 2)
```

這個錯誤消息的具體內容取決於發生的錯誤類型和上下文。

在上述示例中，`read_file_contents` 函數嘗試打開指定文件並讀取其內容，如果操作成功，它會返回包含文件內容的 `Result::Ok(contents)`，否則返回一個 `Result::Err(error)`，其中 `error` 包含了出現的錯誤。在 `main` 函數中，我們使用 `match` 來檢查並處理結果。

總之，`Result` 是 Rust 中用於處理錯誤的重要工具，它使程序員能夠以一種明確和安全的方式處理可能出現的錯誤情況，並避免了異常處理的複雜性。這有助於編寫可靠和健壯的 Rust 代碼。現在讓我們和上一節的option做個對比。下面是一個表格，列出了`Result`和`Option`之間的主要區別：

下面是一個表格，列出了`Result`和`Option`之間的主要區別：

| 特徵                      | Result                                      | Option                                         |
| ------------------------- | ------------------------------------------- | ---------------------------------------------- |
| 用途                      | 用於表示可能發生錯誤的結果                  | 用於表示可能存在或不存在的值                   |
| 枚舉變體                  | `Result<T, E>` 和 `Result<(), E>`           | `Some(T)` 和 `None`                            |
| 成功情況(存在值)          | `Ok(T)` 包含成功的結果值 `T`                | `Some(T)` 包含值 `T`                           |
| 失敗情況(錯誤信息)        | `Err(E)` 包含錯誤的信息 `E`                 | N/A(`Option` 不提供錯誤信息)                   |
| 錯誤處理                  | 通常使用 `match` 或 `?` 運算符              | 通常使用 `if let` 或 `match`                   |
| 主要用途                  | 用於處理可恢復的錯誤                        | 用於處理可選值，如可能為`None`的情況           |
| 引發程序終止(panic)的情況 | 不會引發程序終止                            | 不會引發程序終止                               |
| 適用於何種情況            | I/O操作、文件操作、網絡請求等可能失敗的操作 | 從集合中查找元素、配置選項等可能為`None`的情況 |

這個表格總結了`Result`和`Option`的主要區別，它們在Rust中分別用於處理錯誤和處理可選值。`Result`用於表示可能發生錯誤的操作結果，而`Option`用於表示可能存在或不存在的值。

### 5.5.2 panic! 宏

`panic!` 是Rust編程語言中的一個宏(macro)，用於引發恐慌(panic)。當程序在運行時遇到無法處理的錯誤或不一致性時，`panic!` 宏會導致程序立即終止，並在終止前打印錯誤信息。這種行為是Rust中的一種不可恢復錯誤處理機制。

下面是有關 `panic!` 宏的詳細說明：

1. **引發恐慌**：
   - `panic!` 宏的主要目的是立即終止程序的執行。它會在終止之前打印一條錯誤消息，並可選地附帶錯誤信息。
   - 恐慌通常用於表示不應該發生的錯誤情況，例如除以零或數組越界。這些錯誤通常表明程序的狀態已經不一致，無法安全地繼續執行。

2. **用法**：
   - `panic!` 宏的語法非常簡單，可以像函數調用一樣使用。例如：`panic!("Something went wrong");`。
   - 你也可以使用`panic!` 宏的帶格式的版本，類似於 `println!` 宏：`panic!("Error: {}", error_message);`。

3. **錯誤信息**：
   - 你可以提供一個字符串作為 `panic!` 宏的參數，用於描述發生的錯誤。這個字符串會被打印到標準錯誤輸出(stderr)。
   - 錯誤信息通常應該清晰地描述問題，以便開發人員能夠理解錯誤的原因。

4. **恢復恐慌**：
   - 默認情況下，當程序遇到恐慌時，它會終止執行。這是為了確保不一致狀態不會傳播到程序的其他部分。
   - 但是，你可以使用 `std::panic::catch_unwind` 函數來捕獲恐慌並嘗試在某種程度上恢復程序的執行。這通常需要使用 `std::panic::UnwindSafe` trait 來標記可安全恢復的代碼。

```rust
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        // 可能引發恐慌的代碼塊
        panic!("Something went wrong");
    });

    match result {
        Ok(_) => println!("Panic handled successfully"),
        Err(_) => println!("Panic occurred and was caught"),
    }
}
```

**總結：** `panic!` 宏是Rust中一種不可恢復錯誤處理機制，用於處理不應該發生的錯誤情況。在正常的程序執行中，應該儘量避免使用 `panic!`，而是使用 `Result` 或 `Option` 來處理錯誤和可選值。

### 5.5.3 常見錯誤處理方式的比較

現在讓我們在錯誤處理的矩陣中加入panic！宏，再來比較一下：

| 特徵                      |                          panic!                          |                            Result                            |                       Option                       |
| ------------------------- | :------------------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------------: |
| 用途                      |      用於表示不可恢復的錯誤，通常是不應該發生的情況      |    用於表示可恢復的錯誤或失敗情況，如文件操作、網絡請求等    | 用於表示可能存在或不存在的值，如從集合中查找元素等 |
| 枚舉變體                  |                      N/A(不是枚舉)                       |   `Result<T, E>` 和 `Result<(), E>`(或其他自定義錯誤類型)    |                `Some(T)` 和 `None`                 |
| 程序終止(Termination)     |                引發恐慌，**立即終止程序**                |               不引發程序終止，**允許繼續執行**               |          不引發程序終止，**允許繼續執行**          |
| 錯誤處理方式              |         不提供清晰的錯誤信息，通常只打印錯誤消息         |      提供明確的錯誤類型(如IO錯誤、自定義錯誤)和錯誤信息      |                N/A(不提供錯誤信息)                 |
| 引發程序終止(panic)的情況 |              遇到不可恢復的錯誤或不一致情況              |              通常用於可預見的、可恢復的錯誤情況              |                N/A(不用於錯誤處理)                 |
| 恢復機制                  | 可以使用 `std::panic::catch_unwind` 來捕獲恐慌並嘗試恢復 | 通常通過 `match`、`if let`、`?` 運算符等來處理錯誤，不需要恢復機制 |                N/A(不用於錯誤處理)                 |
| 適用性                    |                 適用於不可恢復的錯誤情況                 |                    適用於可恢復的錯誤情況                    |      適用於可選值的情況，如可能為`None`的情況      |
| 主要示例                  |            ```panic!("Division by zero");```             |   ```File::open("file.txt")?;``` 或其他 `Result` 使用方式    |            ```Some(42)``` 或 ```None```            |

這個表格總結了`panic!`、`Result` 和 `Option` 之間的主要區別。`panic!` 用於處理不可恢復的錯誤情況，`Result` 用於處理可恢復的錯誤或失敗情況，並提供明確的錯誤信息，而 `Option` 用於表示可能存在或不存在的值，例如在從集合中查找元素時使用。在實際編程中，通常應該根據具體情況選擇適當的錯誤處理方式。

##  5.6 棧(Stack)、堆(Heap)和箱子(Box)

內存中的棧(stack)和堆(heap)是計算機內存管理的兩個關鍵方面。在Rust中，與其他編程語言一樣，棧和堆起著不同的角色，用於存儲不同類型的數據。下面詳細解釋這兩者，包括示例和圖表。

### 5.6.1 內存棧(Stack)

- 內存棧是一種線性數據結構，用於存儲程序運行時的函數調用、局部變量和函數參數。
- 棧是一種高效的數據結構，因為它支持常量時間的入棧(push)和出棧(pop)操作。
- 棧上的數據的生命週期是確定的，當變量超出作用域時，相關的數據會自動銷燬。
- 在Rust中，基本數據類型(如整數、浮點數、布爾值)和固定大小的數據結構(如元組)通常存儲在棧上。

下面是一個示例，說明瞭內存棧的工作原理：

```rust
fn main() {
    let x = 42;  // 整數x被存儲在棧上
    let y = 17;  // 整數y被存儲在棧上
    let sum = x + y; // 棧上的x和y的值被相加，結果存儲在棧上的sum中
}  // 所有變量超出作用域，棧上的數據現在全部自動銷燬
```

### 5.6.2 內存堆(Heap)

- 內存堆是一塊較大的、動態分配的內存區域，用於存儲不確定大小或可變大小的數據，例如字符串、向量、結構體等。
- 堆上的數據的生命週期不是固定的，需要手動管理內存的分配和釋放。
- 在Rust中，堆上的數據通常由智能指針(例如`Box`、`Rc`、`Arc`)管理，這些智能指針提供了安全的堆內存訪問方式，避免了內存洩漏和使用-after-free等問題。

**示例**：

如何在堆上分配一個字符串：

```rust
fn main() {
    let s = String::from("Hello, Rust!"); // 字符串s在堆上分配
    // ...
} // 當s超出作用域時，堆上的字符串會被自動釋放
```

下面是一個簡單的圖表，展示了內存棧和內存堆的區別：

![Memory in C – the stack, the heap, and static – The Craft of Coding](https://craftofcoding.files.wordpress.com/2015/12/stackmemory4.jpg)

棧上的數據具有固定的生命週期，是直接管理的。堆上的數據可以是動態分配的，需要**智能指針**來管理其生命週期。

### 5.6.3 箱子(Box)

在 Rust 中，默認情況下，所有值都是棧上分配的。但是，通過創建 `Box<T>`，可以將值進行**裝箱**(boxed)，使其**在堆上分配內存**。一個箱子(box，即 `Box<T>` 類型的實例)實際上是一個智能指針，指向堆上分配的 `T` 類型的值。當箱子超出其作用域時，內部的對象就會被銷燬，並且堆上分配的內存也會被釋放。

以下是一個示例，其中演示了在Rust中使用Box的重要性。在這個示例中，我們試圖創建一個包含非常大數據的結構，但由於沒有使用Box，編譯器會報錯，因為數據無法在棧上存儲：

```rust
struct LargeData {
    // 假設這是一個非常大的數據結構
    data: [u8; 1024 * 1024 * 1024], // 1 GB的數據
}

fn main() {
    let large_data = LargeData {
        data: [0; 1024 * 1024 * 1024], // 初始化數據
    };
    
    println!("Large data created.");
}

```

**執行結果：**

```text
thread 'main' has overflowed its stack
fatal runtime error: stack overflow
fish: Job 1, 'cargo run $argv' terminated by signal SIGABRT (Abort)
```

在這個示例中，我們嘗試創建一個`LargeData`結構，其中包含一個1GB大小的數據數組。由於Rust默認情況下將數據存儲在棧上，這將導致編譯錯誤，因為棧上無法容納如此大的數據。要解決這個問題，可以使用Box來將數據存儲在堆上，如下所示：

```rust
struct LargeData {
    data: Box<[u8]>,
}

fn main() {
    let large_data = LargeData {
        data: vec![0; 1024 * 1024 * 1024].into_boxed_slice(),
    };
    
    // 使用 large_data 變量
    println!("Large data created.");
}
```

在這個示例中，我們使用了`Box::new`來創建一個包含1GB數據的堆分配的數組，這樣就不會出現編譯錯誤了。

### 補充學習：into_boxed_slice

`into_boxed_slice` 是一個用於將向量(`Vec`)轉換為 `Box<[T]>` 的方法。

如果向量有多餘的容量(excess capacity)，它的元素將會被移動到一個新分配的緩衝區，該緩衝區具有剛好正確的容量。

示例：

```rust
let v = vec![1, 2, 3];

let slice = v.into_boxed_slice();
```

在這個示例中，向量 `v` 被轉換成了一個 `Box<[T]>` 類型的切片 `slice`。**任何多餘的容量都會被移除。**

另一個示例，假設有一個具有預分配容量的向量：

```rust
let mut vec = Vec::with_capacity(10);
vec.extend([1, 2, 3]);

assert!(vec.capacity() >= 10);
let slice = vec.into_boxed_slice();
assert_eq!(slice.into_vec().capacity(), 3);
```

在這個示例中，首先創建了一個容量為10的向量，然後通過 `extend` 方法將元素添加到向量中。之後，通過 `into_boxed_slice` 將向量轉換為 `Box<[T]>` 類型的切片 `slice`。由於多餘的容量不再需要，所以它們會被移除。最後，我們使用 `into_vec` 方法將 `slice` 轉換迴向量，並檢查它的容量是否等於3。這是因為移除了多餘的容量，所以容量變為了3。

**總結：**

在Rust中，`Box` 類型雖然不是金融領域特定的工具，但在金融應用程序中具有以下一般應用：

1. **數據管理**：金融應用程序通常需要處理大量數據，如市場報價、交易訂單、投資組合等。`Box` 可以用於將數據分配在堆上，以避免棧溢出，同時確保數據的所有權在不同部分之間傳遞。
2. **構建複雜數據結構**：金融領域需要使用各種複雜的數據結構，如樹、圖、鏈表等，來表示金融工具和投資組合。`Box` 有助於構建這些數據結構，並管理數據的生命週期。
3. **異常處理**：金融應用程序需要處理各種異常情況，如錯誤交易、數據丟失等。`Box` 可以用於存儲和傳遞異常情況的詳細信息，以進行適當的處理和報告。
4. **多線程和併發**：金融應用程序通常需要處理多線程和併發，以確保高性能和可伸縮性。`Box` 可以用於在線程之間安全傳遞數據，避免競爭條件和數據不一致性。
5. **異步編程**：金融應用程序需要處理異步事件，如市場數據更新、交易執行等。`Box` 可以在異步上下文中安全地存儲和傳遞數據。



###  案例1： 向大型金融數據集添加賬戶

當需要處理大型複雜數據集時，使用`Box`可以幫助管理內存並提高程序性能。下面是一個示例，展示如何使用Rust創建一個簡單的金融數據集(在實際生產過程中，可能是極大的。)，其中包含多個交易賬戶和每個賬戶的交易歷史。在這個示例中，我們使用`Box`來管理賬戶和交易歷史的內存，以避免在棧上分配過多內存。

```rust
#[allow(dead_code)] 
#[derive(Debug)]
struct Transaction {
    amount: f64,
    date: String,
}

#[allow(dead_code)] 
#[derive(Debug)]
struct Account {
    name: String,
    transactions: Vec<Transaction>,
}

fn main() {
    // 創建一個包含多個賬戶的金融數據集
    let mut financial_data: Vec<Box<Account>> = Vec::new();

    // 添加一些示例賬戶和交易歷史
    let account1 = Account {
        name: "Account 1".to_string(),
        transactions: vec![
            Transaction {
                amount: 1000.0,
                date: "2023-09-14".to_string(),
            },
            Transaction {
                amount: -500.0,
                date: "2023-09-15".to_string(),
            },
        ],
    };

    let account2 = Account {
        name: "Account 2".to_string(),
        transactions: vec![
            Transaction {
                amount: 2000.0,
                date: "2023-09-14".to_string(),
            },
            Transaction {
                amount: -1000.0,
                date: "2023-09-15".to_string(),
            },
        ],
    };

    // 使用Box將賬戶添加到金融數據集
    financial_data.push(Box::new(account1));
    financial_data.push(Box::new(account2));

    // 打印金融數據集
    for account in financial_data.iter() {
        println!("{:?}", account);
    }
}
```

**執行結果:**

```text
Account { name: "Account 1", transactions: [Transaction { amount: 1000.0, date: "2023-09-14" }, Transaction { amount: -500.0, date: "2023-09-15" }] }
Account { name: "Account 2", transactions: [Transaction { amount: 2000.0, date: "2023-09-14" }, Transaction { amount: -1000.0, date: "2023-09-15" }] }
```

在上述示例中，我們定義了兩個結構體`Transaction`和`Account`，分別用於表示交易和賬戶。然後，我們創建了一個包含多個賬戶的`financial_data`向量，使用`Box`將賬戶放入其中。這允許我們有效地管理內存，並且可以輕鬆地擴展金融數據集。

請注意，這只是一個簡單的示例，實際的金融數據集可能會更加複雜，包括更多的字段和邏輯。使用`Box`來管理內存可以在處理大型數據集時提供更好的性能和可維護性。

### 案例2：處理多種可能的錯誤情況

當你處理多種錯誤的金融腳本時，經常需要使用`Box`來包裝錯誤類型，因為**不同的錯誤可能具有不同的大小**。這裡我將為你展示一個簡單的例子，假設我們要編寫一個金融腳本，它從用戶輸入中解析數字，並進行一些簡單的金融計算，同時處理可能的錯誤。

首先，我們需要在`main.rs`中創建一個Rust項目：

```rust
use std::error::Error;
use std::fmt;

// 定義自定義錯誤類型
#[derive(Debug)]
enum FinancialError {
    InvalidInput,
    DivisionByZero,
}

impl fmt::Display for FinancialError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FinancialError::InvalidInput => write!(f, "Invalid input"),
            FinancialError::DivisionByZero => write!(f, "Division by zero"),
        }
    }
}

impl Error for FinancialError {}

fn main() -> Result<(), Box<dyn Error>> {
    // 模擬用戶輸入
    let input = "10";

    // 解析用戶輸入為數字
    let num: i32 = input
        .parse()
        .map_err(|_| Box::new(FinancialError::InvalidInput))?; // 使用Box包裝錯誤

    // 檢查除以0的情況
    if num == 0 {
        return Err(Box::new(FinancialError::DivisionByZero));
    }

    // 進行一些金融計算
    let result = 100 / num;

    println!("Result: {}", result);

    Ok(())
}
```

在上述代碼中，我們創建了一個自定義錯誤類型`FinancialError`，它包括兩種可能的錯誤：`InvalidInput`和`DivisionByZero`。我們還實現了`Error`和`Display` trait，以便能夠格式化錯誤消息。

當你運行上述Rust代碼時，可能的執行後返回的錯誤情況如下：

1. **成功情況**：如果用戶輸入能夠成功解析為數字且不等於零，程序將執行金融計算，並打印結果，然後返回成功的`Ok(())`。

2. **無效輸入錯誤**：如果用戶輸入無法解析為數字，例如輸入了非數字字符，程序將返回一個包含"Invalid input"錯誤消息的`Box<FinancialError>`。

3. **除零錯誤**：如果用戶輸入解析為數字且為零，程序將返回一個包含"Division by zero"錯誤消息的`Box<FinancialError>`。

下面是在不同情況下的示例輸出：

成功情況：

```text
Result: 10
```

無效輸入錯誤情況：

```text
Error: Invalid input
```

除零錯誤情況：

```text
Error: Division by zero
```

這些是可能的執行後返回的錯誤示例，取決於用戶的輸入和腳本中的邏輯。程序能夠通過自定義錯誤類型和`Result`類型來明確指示發生的錯誤，並提供相應的錯誤消息。



### 案例3：多線程共享數據

另一個常見的情況是當我們想要在不同的線程之間共享數據時。如果數據存儲在棧上，其他線程無法訪問它，所以如果我們希望在線程之間共享數據，就需要將數據存儲在堆上。使用Box正是為瞭解決這個問題的方便方式，因為它允許我們輕鬆地在堆上分配數據，並在不同的線程之間共享它。

當需要在多線程和併發的金融腳本中共享數據時，可以使用`Box`來管理數據並確保線程安全性。以下是一個示例，展示如何使用`Box`來創建一個共享的數據池，以便多個線程可以讀寫它：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// 定義共享的數據結構
#[allow(dead_code)] 
#[derive(Debug)]
struct FinancialData {
    // 這裡可以放入金融數據的字段
    value: f64,
}

fn main() {
    // 創建一個共享的數據池，存儲FinancialData的Box
    let shared_data_pool: Arc<Mutex<Vec<Box<FinancialData>>>> = Arc::new(Mutex::new(Vec::new()));

    // 創建多個寫線程來添加數據到數據池
    let num_writers = 4;
    let mut writer_handles = vec![];

    for i in 0..num_writers {
        let shared_data_pool = Arc::clone(&shared_data_pool);

        let handle = thread::spawn(move || {
            // 在不同線程中創建新的FinancialData並添加到數據池
            let new_data = FinancialData {
                value: i as f64 * 100.0, // 舉例：假設每個線程添加的數據不同
            };
            
            let mut data_pool = shared_data_pool.lock().unwrap();
            data_pool.push(Box::new(new_data));
        });

        writer_handles.push(handle);
    }

    // 創建多個讀線程來讀取數據池
    let num_readers = 2;
    let mut reader_handles = vec![];

    for _ in 0..num_readers {
        let shared_data_pool = Arc::clone(&shared_data_pool);

        let handle = thread::spawn(move || {
            // 在不同線程中讀取數據池的內容
            let data_pool = shared_data_pool.lock().unwrap();
            for data in &*data_pool {
                println!("Reader thread - Data: {:?}", data);
            }
        });

        reader_handles.push(handle);
    }

    // 等待所有寫線程完成
    for handle in writer_handles {
        handle.join().unwrap();
    }

    // 等待所有讀線程完成
    for handle in reader_handles {
        handle.join().unwrap();
    }
}
```

**執行結果:**

```text
Reader thread - Data: FinancialData { value: 300.0 }
Reader thread - Data: FinancialData { value: 0.0 }
Reader thread - Data: FinancialData { value: 100.0 }
Reader thread - Data: FinancialData { value: 300.0 }
Reader thread - Data: FinancialData { value: 0.0 }
Reader thread - Data: FinancialData { value: 100.0 }
Reader thread - Data: FinancialData { value: 200.0 }
```



在這個示例中，我們創建了一個共享的數據池，其中存儲了`Box<FinancialData>`。多個**寫線程**用於創建新的`FinancialData`並將其添加到數據池，而多個**讀線程**用於讀取數據池的內容。`Arc`和`Mutex`用於確保線程安全性，以允許多個線程同時訪問數據池。

這個示例展示瞭如何使用`Box`和線程來創建一個共享的數據池，以滿足金融應用程序中的多線程和併發需求。注意，`FinancialData`結構體只是示例中的一個佔位符，你可以根據實際需求定義自己的金融數據結構。

##  5.7 多線程處理(Multithreading)

在Rust中，你可以使用多線程來並行處理任務。Rust提供了一些內置的工具和標準庫支持來實現多線程編程。以下是使用Rust進行多線程處理的基本步驟：

1. 創建線程：
   你可以使用`std::thread`模塊來創建新的線程。下面是一個創建單個線程的示例：

   ```rust
   use std::thread;
   
   fn main() {
       let thread_handle = thread::spawn(|| {
           // 在這裡編寫線程要執行的代碼
           println!("Hello from the thread!");
       });
   
       // 等待線程執行完成
       thread_handle.join().unwrap(); //輸出 "Hello from the thread!"
   }
   ```

2. 通過消息傳遞進行線程間通信：

   當多個線程需要在Rust中進行通信，就像朋友之間通過紙條傳遞消息一樣。每個線程就像一個朋友，它們可以獨立地工作，但有時需要互相交流信息。

   Rust提供了一種叫做通道(channel)的機制，就像是朋友們之間傳遞紙條的方式。一個線程可以把消息寫在紙條上，然後把紙條放在通道里。而其他線程可以從通道里拿到這些消息紙條。

   下面是一個簡單的例子，演示瞭如何在Rust中使用通道進行線程間通信：

   ```rust
   use std::sync::mpsc; // mpsc 是 Rust 中的一種消息傳遞方式，可以幫助多個線程之間互相發送消息，但只有一個線程能夠接收這些消息。
   use std::thread;
   
   fn main() {
       // 創建一個通道，就像準備一根傳遞紙條的管道
       let (sender, receiver) = mpsc::channel();
   
       // 創建一個線程，負責發送消息
       let sender_thread = thread::spawn(move || {
           let message = "Hello from the sender!";
           sender.send(message).unwrap(); // 發送消息
       });
   
       // 創建另一個線程，負責接收消息
       let receiver_thread = thread::spawn(move || {
           let received_message = receiver.recv().unwrap(); // 接收消息
           println!("Received: {}", received_message);
       });
   
       // 等待線程完成
       sender_thread.join().unwrap();
       receiver_thread.join().unwrap(); // 輸出"Received: Hello from the sender!"
   }
   ```

3. 線程安全性和共享數據：
   在多線程編程中，要注意確保對共享數據的訪問是安全的。Rust通過Ownership和Borrowing系統來強制執行線程安全性。你可以使用`std::sync`模塊中的`Mutex`、`Arc`等類型來管理共享數據的訪問。

   ```rust
   use std::sync::{Arc, Mutex};
   use std::thread;
   
   fn main() {
       // 創建一個共享數據結構，使用Arc包裝Mutex以實現多線程安全
       let shared_data = Arc::new(Mutex::new(0));
   
       // 創建一個包含四個線程的向量
       let threads: Vec<_> = (0..4)
           .map(|_| {
               // 克隆共享數據以便在線程間共享
               let data = Arc::clone(&shared_data);
   
               // 在線程中執行的代碼塊，鎖定數據並遞增它
               thread::spawn(move || {
                   let mut data = data.lock().unwrap();
                   *data += 1;
               })
           })
           .collect();
   
       // 等待所有線程完成
       for thread in threads {
           thread.join().unwrap();
       }
   
       // 鎖定共享數據並獲取結果
       let result = *shared_data.lock().unwrap();
   
       // 輸出結果
       println!("共享數據: {}", result);  //輸出"共享數據: 4"
   }
   ```



這是一個簡單的示例，展示瞭如何在Rust中使用多線程處理任務。多線程編程需要小心處理併發問題，確保線程安全性。在實際項目中，你可能需要更復雜的同步和通信機制來處理不同的併發場景。

## 5.8 互斥鎖

互斥鎖(Mutex)是一種在多線程編程中非常有用的工具，可以幫助我們解決多個線程同時訪問共享資源可能引發的問題。想象一下你和你的朋友們在一起玩一個遊戲，你們需要共享一個物品，比如一臺遊戲機。

現在，如果沒有互斥鎖，每個人都可以試圖同時操作這臺遊戲機，這可能會導致混亂，遊戲機崩潰，或者玩遊戲時出現奇怪的問題。互斥鎖就像一個虛擬的把手，只有一個人能夠握住它，其他人必須等待。當一個人使用遊戲機完成後，他們會放下這個把手，然後其他人可以繼續玩。

這樣，互斥鎖確保在同一時刻只有一個人能夠使用遊戲機，防止了競爭和混亂。在編程中，它確保了不同的線程不會同時修改同一個數據，從而避免了數據錯亂和程序崩潰。

在Rust編程語言中，它的作用是確保多個線程之間能夠安全地訪問共享數據，避免競態條件(Race Conditions)和數據競爭(Data Races)。

以下是`Mutex`的詳細特徵：

1. **互斥性(Mutual Exclusion)**：`Mutex`的主要目標是實現**互斥性**，即**一次只能有一個線程能夠訪問由鎖保護的共享資源**。如果一個線程已經獲得了`Mutex`的鎖，其他線程必須等待直到該線程釋放鎖。

2. **內部可變性(Interior Mutability)**：在Rust中，`Mutex`通常與內部可變性(Interior Mutability)一起使用。這意味著**你可以在不使用`mut`關鍵字的情況下修改由`Mutex`保護的數據**。這是通過`Mutex`提供的`lock`方法來實現的。

3. **獲取和釋放鎖**：要使用`Mutex`，線程必須首先獲取鎖，然後在臨界區內執行操作，最後釋放鎖。這通常是通過`lock`方法來完成的。當一個線程獲得鎖時，其他線程將被阻塞，直到鎖被釋放。

```rust
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    // 創建一個Mutex，用於共享整數
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            // 獲取鎖
            let mut num = counter.lock().unwrap();
            *num += 1; // 在臨界區內修改共享數據
        });
        handles.push(handle);
    }

    // 等待所有線程完成
    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

4. **錯誤處理**：在上面的示例中，我們使用`unwrap`方法來處理`lock`可能返回的錯誤。在實際應用中，你可能需要更復雜的錯誤處理來處理鎖的獲取失敗情況。

總之，`Mutex`是Rust中一種非常重要的同步原語，用於保護共享數據免受併發訪問的問題。通過正確地使用`Mutex`，你可以確保多線程程序的安全性和可靠性。

### 補充學習：lock方法

上面用到的 `lock` 方法是用來處理互斥鎖(Mutex)的一種特殊函數。它的作用有點像一把“鑰匙”，只有拿到這把鑰匙的線程才能進入被鎖住的房間，也就是臨界區，從而安全地修改共享的數據。

想象一下，你和你的朋友們一起玩一個遊戲，而這個遊戲有一個很酷的玩具，但是隻能一個人玩。大家都想要玩這個玩具，但不能同時。這時就需要用到 `lock` 方法。

1. **獲取鎖**：如果一個線程想要進入這個“玩具房間”，它必須使用 `lock` 方法，就像使用一把特殊的鑰匙。只有一個線程能夠拿到這個鑰匙，進入房間，然後進行操作。

2. **在臨界區內工作**：一旦線程拿到了鑰匙，就可以進入房間，也就是臨界區，安全地玩耍或修改共享數據。

3. **釋放鎖**：當線程完成了房間內的工作，就需要把鑰匙歸還，也就是釋放鎖。這時其他線程就有機會獲取鎖，進入臨界區，繼續工作。

`lock` 方法確保了在任何時候只有一個線程能夠進入臨界區，從而避免了數據錯亂和混亂。這就像是一個玩具的控制鑰匙，用來管理大家對玩具的訪問，讓程序更加可靠和安全。

####  案例：安全地更新賬戶餘額

在金融領域，`Mutex` 和多線程技術可以用於確保對共享數據的安全訪問，尤其是在多個線程同時訪問和更新賬戶餘額等重要金融數據時。

以下是一個完整的 Rust 代碼示例，演示如何使用 `Mutex` 來處理多線程的存款和取款操作，並確保賬戶餘額的一致性和正確性：

```rust
use std::sync::{Mutex, Arc};
use std::thread;

// 定義銀行賬戶結構
struct BankAccount {
    balance: f64,
}

fn main() {
    // 創建一個Mutex，用於包裝銀行賬戶
    let account = Arc::new(Mutex::new(BankAccount { balance: 1000.0 }));
    let mut handles = vec![];

    // 模擬多個線程進行存款和取款操作
    for _ in 0..5 {
        let account = Arc::clone(&account);
        let handle = thread::spawn(move || {
            // 獲取鎖
            let mut account = account.lock().unwrap();
            
            // 模擬存款和取款操作
            let deposit_amount = 200.0;
            let withdrawal_amount = 150.0;

            // 存款
            account.balance += deposit_amount;

            // 取款
            if account.balance >= withdrawal_amount {
                account.balance -= withdrawal_amount;
            }
        });
        handles.push(handle);
    }

    // 等待所有線程完成
    for handle in handles {
        handle.join().unwrap();
    }

    // 獲取鎖並打印最終的賬戶餘額
    let account = account.lock().unwrap();
    println!("Final Balance: ${:.2}", account.balance);
}
```

**執行結果：**

```text
Final Balance: $1250.00
```

在這個代碼示例中，我們首先定義了一個銀行賬戶結構 `BankAccount`，包括一個餘額字段。然後，我們創建一個 `Mutex` 來包裝這個賬戶，以確保多個線程可以安全地訪問它。

在 `main` 函數中，我們創建了多個線程來模擬存款和取款操作。每個線程首先使用 `lock` 方法獲取鎖，然後進行存款和取款操作，最後釋放鎖。最終，我們等待所有線程完成，獲取鎖，並打印出最終的賬戶餘額。



## 5.9 堆分配的指針(heap allocated pointers)

在Rust中，堆分配的指針通常是通過使用引用計數(Reference Counting)或智能指針(Smart Pointers)來管理堆上的數據的指針。Rust的安全性和所有權系統要求在訪問堆上的數據時進行明確的內存管理，而堆分配的指針正是為此目的而設計的。下面將詳細解釋堆分配的指針和它們在Rust中的使用。

在Rust中，常見的堆分配的指針有以下兩種：

1. **`Box<T>` 智能指針**：

   - `Box<T>` 是Rust的一種智能指針，它用於在堆上分配內存並管理其生命週期。
   - `Box<T>` 允許你在堆上存儲一個類型為 `T` 的值，並負責在其超出作用域時自動釋放該值。**這消除了常見的內存洩漏和Use-after-free錯誤。** "(Use-after-free" 是一種常見的內存安全錯誤，通常發生在編程語言中，包括Rust在內。這種錯誤發生在程序試圖訪問已經被釋放的內存區域時。)
   - 例如，你可以使用 `Box` 來創建一個在堆上分配的整數：

   ```rust
   let x = Box::new(42); // 在堆上分配一個整數，並將它存儲在Box中
   ```

2. **引用計數智能指針(`Rc<T>` 和 `Arc<T>`)**：

   - `Rc<T>`(引用計數)和 `Arc<T>`(原子引用計數)是Rust中的智能指針，用於跟蹤堆上數據的引用計數。它們允許多個所有者共享同一塊堆內存，直到所有所有者都離開作用域為止。
   - **`Rc<T>` 用於單線程環境，而 `Arc<T>` 用於多線程環境，因為後者具有原子引用計數。**
   - 例如，你可以使用 `Rc` 來創建一個堆上的字符串：

   ```rust
   use std::rc::Rc;
   
   let s1 = Rc::new(String::from("hello")); // 創建一個引用計數智能指針
   let s2 = s1.clone(); // 克隆指針，增加引用計數
   ```

這些堆分配的指針幫助Rust程序員在不違反所有權規則的情況下管理堆上的數據。當不再需要這些數據時，它們會自動釋放內存，從而減少了內存洩漏和安全問題的風險。但需要注意的是，使用堆分配的指針很多情況下能提升性能，但是也可能會引入運行時開銷，因此應謹慎使用，尤其是在需要高性能的代碼中。

現在我們再來詳細講一下`Rc<T>` 和 `Arc<T>`。

### 5.9.1 `Rc` 指針(Reference Counting)

**`Rc`** 表示"引用計數"(Reference Counting)，在單線程環境中使用，它允許多個所有者共享數據，但不能用於多線程併發。是故可以使用`Rc`(引用計數)來共享數據並在多個函數之間傳遞變量。

**示例代碼：**

```rust
use std::rc::Rc;

// 定義一個結構體，它包含一個整數字段
#[derive(Debug)]
struct Data {
    value: i32,
}

// 接受一個包含 Rc<Data> 的參數的函數
fn print_data(data: Rc<Data>) {
    println!("Data: {:?}", data);
}

// 修改 Rc<Data> 的值的函數
fn modify_data(data: Rc<Data>) -> Rc<Data> {
    println!("Modifying data...");
    Rc::new(Data {
        value: data.value + 1,
    })
}

fn main() {
    // 創建一個 Rc<Data> 實例
    let shared_data = Rc::new(Data { value: 42 });

    // 在不同的函數之間傳遞 Rc<Data>
    print_data(Rc::clone(&shared_data)); // 克隆 Rc<Data> 並傳遞給函數
    let modified_data = modify_data(Rc::clone(&shared_data)); // 克隆 Rc<Data> 並傳遞給函數

    // 打印修改後的數據
    println!("Modified Data: {:?}", modified_data);

    // 這裡還可以繼續使用 shared_data 和 modified_data，因為它們都是 Rc<Data> 的所有者
    println!("Shared Data: {:?}", shared_data);
}
```

在這個示例中，我們定義了一個包含整數字段的`Data`結構體，並使用`Rc`包裝它。然後，我們創建一個`Rc<Data>`實例並在不同的函數之間傳遞它。在 `print_data` 函數中，我們只是打印了`Rc<Data>`的值，而在`modify_data`函數中，我們創建了一個新的`Rc<Data>`實例，該實例修改了原始數據的值。由於`Rc`允許多個所有者，我們可以在不同的函數之間傳遞數據，而不需要擔心所有權的問題。

**執行結果：**

```text
Data: Data { value: 42 }
Modifying data...
Modified Data: Data { value: 43 }
Shared Data: Data { value: 42 }
```

### 5.9.2  `Arc指針(Atomic Reference Counting)

**`Arc`** 表示"原子引用計數"(Atomic Reference Counting)，在多線程環境中使用，它與 `Rc` 類似，但具備線程安全性。

```rust
use std::sync::Arc;
use std::thread;

// 定義一個結構體，它包含一個整數字段
#[allow(dead_code)] 
#[derive(Debug)]
struct Data {
    value: i32,
}

fn main() {
    // 創建一個 Arc<Data> 實例
    let shared_data = Arc::new(Data { value: 42 });

    // 創建一個線程，傳遞 Arc<Data> 到線程中
    let thread_data = Arc::clone(&shared_data);

    let handle = thread::spawn(move || {
        // 在新線程中打印 Arc<Data> 的值
        println!("Thread Data: {:?}", thread_data);
    });

    // 主線程繼續使用 shared_data
    println!("Main Data: {:?}", shared_data);

    // 等待新線程完成
    handle.join().unwrap();
}

```

在這個示例中，我們創建了一個包含整數字段的 `Data` 結構體，並將其用 `Arc` 包裝。然後，我們創建了一個新的線程，並在新線程中打印了 `thread_data`(一個克隆的 `Arc<Data>`)的值。同時，主線程繼續使用原始的 `shared_data`。由於 `Arc` 允許在多個線程之間共享數據，我們可以在不同線程之間傳遞數據而不擔心線程安全性問題。

**執行結果：**

```text
Main Data: Data { value: 42 }
Thread Data: Data { value: 42 }
```

###  5.9.3 常見的 Rust 智能指針類型之間的比較：

現在讓我們來回顧一下我們在本章學習的智能指針:

| 指針類型   | 描述                                                     | 主要特性和用途                                               |
| ---------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| `Box<T>`   | 堆分配的指針，擁有唯一所有權，通常用於數據所有權的轉移。 | 在編譯時檢查下，避免了內存洩漏和數據競爭。                   |
| `Rc<T>`    | 引用計數智能指針，允許多個所有者，但不能用於多線程環境。 | 用於共享數據的多個所有者，適用於單線程應用。                 |
| `Arc<T>`   | 原子引用計數智能指針，允許多個所有者，適用於多線程環境。 | 用於共享數據的多個所有者，適用於多線程應用。                 |
| `Mutex<T>` | 互斥鎖智能指針，用於多線程環境，提供內部可變性。         | 用於共享數據的多線程環境，確保一次只有一個線程可以訪問共享數據。 |

這個表格總結了 Rust 中常見的智能指針類型的比較，排除了 `RefCell<T>` 和 `Cell<T>` 這兩個類型。根據你的需求，選擇適合的智能指針類型，以滿足所有權、可變性和線程安全性的要求。

###  案例：使用多線程備份一組金融數據

在Rust中使用多線程，以更好的性能備份一組金融數據到本地可以通過以下步驟完成：

1. 導入所需的庫：
   首先，你需要導入標準庫中的多線程和文件操作相關的模塊。

```rust
use std::fs::File;
use std::io::Write;
use std::sync::{Arc, Mutex};
use std::thread;
```

2. 準備金融數據：
   準備好你想要備份的金融數據，可以存儲在一個向量或其他數據結構中。

```rust
// 假設有一組金融數據
let financial_data = vec![
    "Data1",
    "Data2",
    "Data3",
    // ...更多數據
];
```

3. 創建一個互斥鎖和一個共享數據的Arc(原子引用計數器)：
   這將用於多個線程之間共享金融數據。

```rust
let data_mutex = Arc::new(Mutex::new(financial_data));
```

4. 定義備份邏輯：
   編寫一個備份金融數據的函數，每個線程都會調用這個函數來備份數據。備份可以簡單地寫入文件。

```rust
fn backup_data(data: &str, filename: &str) -> std::io::Result<()> {
    let mut file = File::create(filename)?;
    file.write_all(data.as_bytes())?;
    Ok(())
}
```

5. 創建多個線程來備份數據：
   對每個金融數據啟動一個線程，使用互斥鎖來獲取要備份的數據。

```rust
let mut thread_handles = vec![];

for (index, data) in data_mutex.lock().unwrap().iter_mut().enumerate() {
    let filename = format!("financial_data_{}.txt", index);
    let data = data.clone();
    let handle = thread::spawn(move || {
        match backup_data(&data, &filename) {
            Ok(_) => println!("Backup successful: {}", filename),
            Err(err) => eprintln!("Error backing up {}: {:?}", filename, err),
        }
    });
    thread_handles.push(handle);
}
```

這段代碼遍歷金融數據，併為每個數據啟動一個線程。每個線程將金融數據備份到一個單獨的文件中，文件名包含了數據的索引。備份操作使用 `backup_data` 函數完成。

6. 等待線程完成：
   最後，等待所有線程完成備份操作。

```rust
for handle in thread_handles {
    handle.join().unwrap();
}
```

完整的Rust多線程備份金融數據的代碼如下：

```rust
use std::fs::File;
use std::io::Write;
use std::sync::{Arc, Mutex};
use std::thread;

fn backup_data(data: &str, filename: &str) -> std::io::Result<()> {
    let mut file = File::create(filename)?;
    file.write_all(data.as_bytes())?;
    Ok(())
}

fn main() {
    let financial_data = vec![
        "Data1",
        "Data2",
        "Data3",
        // ... 添加更多數據
    ];

    let data_mutex = Arc::new(Mutex::new(financial_data));
    let mut thread_handles = vec![];

    for (index, data) in data_mutex.lock().unwrap().iter_mut().enumerate() {
        let filename = format!("financial_data_{}.txt", index);
        let data = data.to_string(); // 將&str轉換為String
        let handle = thread::spawn(move || {
            match backup_data(&data, &filename) {
                Ok(_) => println!("Backup successful: {}", filename),
                Err(err) => eprintln!("Error backing up {}: {:?}", filename, err),
            }
        });
        thread_handles.push(handle);
    }

    for handle in thread_handles {
        handle.join().unwrap();
    }
}

```

執行結果：

```text
Backup successful: financial_data_0.txt
Backup successful: financial_data_1.txt
Backup successful: financial_data_2.txt
```

這段代碼使用多線程並行備份金融數據到不同的文件中，確保數據的備份操作是並行執行的。每個線程都備份一個數據。備份成功後，程序會打印成功的消息，如果發生錯誤，會打印錯誤信息。

# Chapter 6 - 變量和作用域

## 6.1 作用域和遮蔽

變量綁定有一個作用域(scope)，它被限定只在一個**代碼塊**(block)中生存(live)。 代碼塊是一個被 `{}` 包圍的語句集合。另外也允許變量遮蔽。

```rust
fn main() {
    // 此綁定生存於 main 函數中
    let outer_binding = 1;

    // 這是一個代碼塊，比 main 函數擁有更小的作用域
    {
        // 此綁定只存在於本代碼塊
        let inner_binding = 2;

        println!("inner: {}", inner_binding);

        // 此綁定*遮蔽*了外面的綁定
        let outer_binding = 5_f32;

        println!("inner shadowed outer: {}", outer_binding);
    }
    // 代碼塊結束

    // 此綁定仍然在作用域內
    println!("outer: {}", outer_binding);

    // 此綁定同樣*遮蔽*了前面的綁定
    let outer_binding = 'a';

    println!("outer shadowed outer: {}", outer_binding);
}
```

**執行結果：**

```text
inner: 2
inner shadowed outer: 5
outer: 1
outer shadowed outer: a
```



## 6.2 不可變變量

在Rust中，你可以使用 `mut` 關鍵字來聲明可變變量。可變變量與不可變變量相比，允許在綁定後修改它們的值。以下是一些常見的可變類型：

1. **可變綁定(Mutable Bindings)**：使用 `let mut` 聲明的變量是可變的。這意味著你可以在創建後修改它們的值。例如：

   ```rust
   let mut x = 5; // x是可變變量
   x = 10; // 可以修改x的值
   ```

2. **可變引用(Mutable References)**：通過使用可變引用，你可以在不改變變量綁定的情況下修改值。可變引用使用 `&mut` 聲明。例如：

   ```rust
   fn main() {
       let mut x = 5;
       modify_value(&mut x); // 通過可變引用修改x的值
       println!("x: {}", x); // 輸出 "x: 10"
   }
   
   fn modify_value(y: &mut i32) {
       *y = 10;
   }
   ```

3. **可變字段(Mutable Fields)**：結構體和枚舉可以包含可變字段，這些字段在結構體或枚舉創建後可以修改。你可以使用 `mut` 關鍵字來聲明結構體或枚舉的字段是可變的。例如：

   ```rust
   struct Point {
       x: i32,
       y: i32,
   }
   
   fn main() {
       let mut p = Point { x: 1, y: 2 };
       p.x = 10; // 可以修改Point結構體中的字段x的值
   }
   ```

4. **可變數組(Mutable Arrays)**：使用 `mut` 關鍵字聲明的數組是可變的，允許修改數組中的元素。例如：

   ```rust
   fn main() {
       let mut arr = [1, 2, 3];
       arr[0] = 4; // 可以修改數組中的元素
   }
   ```

5. **可變字符串(Mutable Strings)**：使用 `String` 類型的變量和 `push_str`、`push` 等方法可以修改字符串的內容。例如：

   ```rust
   fn main() {
       let mut s = String::from("Hello");
       s.push_str(", world!"); // 可以修改字符串的內容
   }
   ```

這些是一些常見的可變類型示例。可變性是Rust的一個關鍵特性，它允許你在需要修改值時更改綁定，同時仍然提供了強大的安全性和借用檢查。



##  6.3 可變變量

在Rust中，你可以使用 `mut` 關鍵字來聲明可變變量。可變變量與不可變變量相比，允許在綁定後修改它們的值。以下是一些常見的可變類型：

1. **可變綁定(Mutable Bindings)**：使用 `let mut` 聲明的變量是可變的。這意味著你可以在創建後修改它們的值。例如：

   ```rust
   let mut x = 5; // x是可變變量
   x = 10; // 可以修改x的值
   ```

2. **可變引用(Mutable References)**：通過使用可變引用，你可以在不改變變量綁定的情況下修改值。可變引用使用 `&mut` 聲明。例如：

   ```rust
   fn main() {
       let mut x = 5;
       modify_value(&mut x); // 通過可變引用修改x的值
       println!("x: {}", x); // 輸出 "x: 10"
   }
   
   fn modify_value(y: &mut i32) {
       *y = 10;
   }
   ```

3. **可變字段(Mutable Fields)**：結構體和枚舉可以包含可變字段，這些字段在結構體或枚舉創建後可以修改。你可以使用 `mut` 關鍵字來聲明結構體或枚舉的字段是可變的。例如：

   ```rust
   struct Point {
       x: i32,
       y: i32,
   }
   
   fn main() {
       let mut p = Point { x: 1, y: 2 };
       p.x = 10; // 可以修改Point結構體中的字段x的值
   }
   ```

4. **可變數組(Mutable Arrays)**：使用 `mut` 關鍵字聲明的數組是可變的，允許修改數組中的元素。例如：

   ```rust
   fn main() {
       let mut arr = [1, 2, 3];
       arr[0] = 4; // 可以修改數組中的元素
   }
   ```

5. **可變字符串(Mutable Strings)**：使用 `String` 類型的變量和 `push_str`、`push` 等方法可以修改字符串的內容。例如：

   ```rust
   fn main() {
       let mut s = String::from("Hello");
       s.push_str(", world!"); // 可以修改字符串的內容
   }
   ```

這些是一些常見的可變類型示例。可變性是Rust的一個關鍵特性，它允許你在需要修改值時更改綁定，同時仍然提供了強大的安全性和借用檢查。

## 6.4 語句(Statements)，表達式(Expressions) 和 變量綁定(Variable Bindings)

### 6.4.1 語句(Statements)

Rust 有多種語句。在Rust中，下面的內容通常被視為語句：

1. 變量聲明語句，如 `let x = 5;`。
2. 賦值語句，如 `x = 10;`。
3. 函數調用語句，如 `println!("Hello, world!");`。
4. 控制流語句，如 `if`、`else`、`while`、`for` 等。

```rust
fn main() {
    // 變量聲明語句
    let x = 5;

    // 賦值語句
    let mut y = 10;
    y = y + x;

    // 函數調用語句
    println!("The value of y is: {}", y);

    // 控制流語句
    if y > 10 {
        println!("y is greater than 10");
    } else {
        println!("y is not greater than 10");
    }
}
```

### 6.4.2 表達式(Expressions)

在Rust中，語句(Statements)和表達式(Expressions)有一些重要的區別：

1. **返回值：**
   - 語句沒有返回值。它們執行某些操作或賦值，但不產生值本身。例如，賦值語句 `let x = 5;` 不返回任何值。
   - 表達式總是有返回值。每個表達式都會計算出一個值，並可以被用於其他表達式或賦值給變量。例如，`5 + 3` 表達式返回值 `8`。

2. **可嵌套性：**
   - 語句可以包含表達式，但不能嵌套其他語句。例如，`let x = { 5 + 3; };` 在代碼塊中包含了一個表達式，但代碼塊本身是一個語句。
   - 表達式可以包含其他表達式，形成複雜的表達式樹。例如，`let y = 5 + (3 * (2 - 1));` 中的表達式包含了嵌套的子表達式。

3. **使用場景：**
   - 語句通常用於執行某些操作，如聲明變量、賦值、執行函數調用等。它們不是為了返回值而存在的。
   - 表達式通常用於計算值，這些值可以被用於賦值、函數調用的參數、條件語句的判斷條件等。它們總是有返回值。

4. **分號：**
   - 語句通常以分號 `;` 結尾，表示語句的結束。
   - 表達式也可以以分號 `;` 結尾，但這樣做通常會忽略表達式的結果。如果省略分號，表達式的值將被返回。

下面是一些示例來說明語句和表達式之間的區別：

```rust
// 這是一個語句，它沒有返回值
let x = 5;

// 這是一個表達式，它的值為 8
let y = 5 + 3;

// 這是一個語句塊，其中包含了兩個語句，但沒有返回值
{
    let a = 1;
    let b = 2;
}

// 這是一個表達式，其值為 6，這個值可以被賦給變量或用於其他表達式中
let z = {
    let a = 2;
    let b = 3;
    a + b // 注意，沒有分號，所以這是一個表達式
};
```

再來看一下，如果給表達式強制以分號 `;` 結尾的效果。

```rust
fn main() {
    //變量綁定， 創建一個無符號整數變量 `x`
    let x = 5u32;

    // 創建一個新的變量 `y` 並初始化它
    let y = {
        // 創建 `x` 的平方
        let x_squared = x * x;

        // 創建 `x` 的立方
        let x_cube = x_squared * x;

        // 計算 `x_cube + x_squared + x` 並將結果賦給 `y`
        x_cube + x_squared + x
    };
    
    // 代碼塊也是表達式，所以它們可以用作賦值中的值。
    // 這裡的代碼塊的最後一個表達式是 `2 * x`，但由於有分號結束了這個代碼塊，所以將 `()` 賦給 `z`
    let z = {
        2 * x;
    };

    // 打印變量的值
    println!("x is {:?}", x);
    println!("y is {:?}", y);
    println!("z is {:?}", z);
}
```

返回的是

```rust
x is 5
y is 155
z is ()
```

總之，語句用於執行操作，而表達式用於計算值。理解這兩者之間的區別對於編寫Rust代碼非常重要。

# Chapter 7 - 類型系統

在量化金融領域，Rust 的類型系統具有出色的表現，它強調了類型安全、性能和靈活性，這使得 Rust 成為一個理想的編程語言來處理金融數據和算法交易。以下是一個詳細介紹 Rust 類型系統的案例，涵蓋瞭如何在金融領域中利用其特性：

## 7.1 字面量 (Literals)

對數值字面量，只要把類型作為後綴加上去，就完成了類型說明。比如指定字面量 `42` 的類型是 `i32`，只需要寫 `42i32`。

無後綴的數值字面量，其類型取決於怎樣使用它們。如果沒有限制，編譯器會對整數使用 `i32`，對浮點數使用 `f64`。

```rust
fn main() {
    let a = 3f32;
    let b = 1;
    let c = 1.0;
    let d = 2u32;
    let e = 1u8;

    println!("size of `a` in bytes: {}", std::mem::size_of_val(&a));
    println!("size of `b` in bytes: {}", std::mem::size_of_val(&b));
    println!("size of `c` in bytes: {}", std::mem::size_of_val(&c));
    println!("size of `d` in bytes: {}", std::mem::size_of_val(&d));
    println!("size of `e` in bytes: {}", std::mem::size_of_val(&e));
}
```

**執行結果**:

```text
size of `a` in bytes: 4
size of `b` in bytes: 4
size of `c` in bytes: 8
size of `d` in bytes: 4
size of `e` in bytes: 1
```



PS: 上面的代碼使用了一些還沒有討論過的概念。

`std::mem::size_of_val` 是 Rust 標準庫中的一個函數，用於獲取一個值(變量或表達式)所佔用的字節數。具體來說，它返回一個值的大小(以字節為單位)，即該值在內存中所佔用的空間大小。

`std::mem::size_of_val`的調用方式使用了完整路徑(full path)。在 Rust 中，代碼可以被組織成稱為模塊(module)的邏輯單元，而模塊可以嵌套在其他模塊內。在這個示例中：

- `size_of_val` 函數是在名為 `mem` 的模塊中定義的。
- `mem` 模塊又是在名為 `std` 的 crate 中定義的。

讓我們詳細解釋這些概念：

1. **Crate**：在 Rust 中，crate 是最高級別的代碼組織單元，可以看作是一個庫或一個包。Rust 的標準庫(Standard Library)也是一個 crate，通常被引用為 `std`。

2. **模塊**：模塊是用於組織和封裝代碼的邏輯單元。模塊可以包含函數、結構體、枚舉、常量等。在示例中，`std` crate 包含了一個名為 `mem` 的模塊，而 `mem` 模塊包含了 `size_of_val` 函數。

3. **完整路徑**：在 Rust 中，如果要調用一個函數、訪問一個模塊中的變量等，可以使用完整路徑來指定它們的位置。完整路徑包括 crate 名稱、模塊名稱、函數名稱等，用於明確指定要使用的項。在示例中，`std::mem::size_of_val` 使用了完整路徑，以確保編譯器能夠找到正確的函數。

所以，`std::mem::size_of_val` 的意思是從標準庫 crate(`std`)中的 `mem` 模塊中調用 `size_of_val` 函數。這種方式有助於防止命名衝突和確保代碼的可讀性和可維護性，因為它明確指定了要使用的函數的來源。

## 7.2 強類型系統 (Strong type system)

Rust 的類型系統是強類型的，這意味著每個變量都必須具有明確定義的類型，並且在編譯時會嚴格檢查類型的一致性。這一特性在金融計算中尤為重要，因為它有助於防止可能導致嚴重錯誤的類型不匹配問題。

舉例來說，考慮以下代碼片段：

```rust
let price: f64 = 150.0; // 價格是一個浮點數
let quantity: i32 = 100; // 數量是一個整數
let total_value = price * quantity; // 編譯錯誤，不能將浮點數與整數相乘
```

在這個示例中，我們明確指定了 `price` 是一個浮點數，而 `quantity` 是一個整數。當我們嘗試將它們相乘時，Rust 在編譯時就會立即捕獲到類型不匹配的錯誤。這種類型檢查的嚴格性有助於避免金融計算中常見的錯誤，例如將不同類型的數據混淆或錯誤地進行數學運算。因此，Rust 的強類型系統提供了額外的安全性層，確保金融應用程序在編譯時捕獲潛在的問題，從而減少了在運行時出現錯誤的風險。

在 Rust 的強類型系統中，類型之間的轉換通常需要顯式進行，以確保類型安全。

## 7.3 類型轉換 (Casting)

Rust 不支持原生類型之間的隱式類型轉換(coercion)，但允許通過 `as` 關鍵字進行明確的類型轉換(casting)。

1. **as 運算符**：可以使用 `as` 運算符執行類型轉換，但是隻能用於數值之間的轉換。例如，將整數轉換為浮點數或將浮點數轉換為整數。

   ```rust
   let integer_num: i32 = 42;
   let float_num: f64 = integer_num as f64;
   
   let float_value: f64 = 3.14;
   let integer_value: i32 = float_value as i32;
   ```

   需要注意的是，使用 `as` 進行類型轉換**可能會導致數據丟失或不確定行為**，因此要謹慎使用。在程序設計之初，最好就能規劃好變量數據的類型。

2. **From 和 Into trait**：

   在量化金融領域，`From` 和 `Into` trait 可以用來實現自定義類型之間的轉換，以便在處理金融數據和算法時更方便地操作不同的數據類型。下面讓我們使用一個簡單的例子來說明這兩個 trait 在量化金融中的應用。

   假設我們有兩種不同的金融工具類型：`Stock`(股票)和 `Option`(期權)。我們希望能夠在這兩種類型之間進行轉換，以便在金融算法中更靈活地處理它們。

   首先，我們可以定義這兩種類型的結構體：

   ```rust
   struct Stock {
       symbol: String,
       price: f64,
   }
   
   struct Option {
       symbol: String,
       strike_price: f64,
       expiration_date: String,
   }
   ```

   現在，讓我們使用 `From` 和 `Into` trait 來實現類型之間的轉換。

   **從 Stock 到 Option 的轉換**：

   假設我們希望從一個股票創建一個對應的期權。我們可以實現 `From` trait 來定義如何從 `Stock` 轉換為 `Option`：

   ```rust
   impl From<Stock> for Option {
       fn from(stock: Stock) -> Self {
           Option {
               symbol: stock.symbol,
               strike_price: stock.price * 1.1, // 假設期權的行權價是股票價格的110%
               expiration_date: String::from("2023-12-31"), // 假設期權到期日期
           }
       }
   }
   ```

   現在，我們可以這樣進行轉換：

   ```rust
   let stock = Stock {
       symbol: String::from("AAPL"),
       price: 150.0,
   };
   
   let option: Option = stock.into(); // 使用 Into trait 進行轉換
   ```

    **從 Option 到 Stock 的轉換**：

   如果我們希望從一個期權創建一個對應的股票，我們可以實現相反方向的轉換，使用 `From` trait 或 `Into` trait 的逆操作。

   ```rust
   impl From<Option> for Stock {
       fn from(option: Option) -> Self {
           Stock {
               symbol: option.symbol,
               price: option.strike_price / 1.1, // 假設期權的行權價是股票價格的110%
           }
       }
   }
   ```

   或者，我們可以使用 `Into` trait 進行相反方向的轉換：

   ```rust
   let option = Option {
       symbol: String::from("AAPL"),
       strike_price: 165.0,
       expiration_date: String::from("2023-12-31"),
   };
   
   let stock: Stock = option.into(); // 使用 Into trait 進行轉換
   ```

   通過實現 `From` 和 `Into` trait，我們可以自定義類型之間的轉換邏輯，使得在量化金融算法中更容易地處理不同的金融工具類型，提高了代碼的靈活性和可維護性。這有助於簡化金融數據處理的代碼，並使其更具可讀性。

## 7.4 自動類型推斷(Inference)

在Rust中，類型推斷引擎非常強大，它不僅在初始化變量時考慮右值(r-value)的類型，還會分析變量之後的使用情況，以便更準確地推斷類型。以下是一個更復雜的類型推斷示例，我們將詳細說明它的工作原理。

```rust
fn main() {
    let mut x = 5; // 變量 x 被初始化為整數 5
    x = 10; // 現在，將 x 更新為整數 10
    println!("x = {}", x);
}
```

在這個示例中，我們首先聲明瞭一個變量 `x`，並將其初始化為整數5。然後，我們將 `x` 的值更改為整數10，並最後打印出 `x` 的值。

Rust的類型推斷引擎如何工作：

1. **變量初始化**：當我們聲明 `x` 並將其初始化為5時，Rust的類型推斷引擎會根據右值的類型(這裡是整數5)推斷出 `x` 的類型為整數(`i32`)。
2. **賦值操作**：當我們執行 `x = 10;` 這行代碼時，Rust不僅檢查右值(整數10)的類型，還會考慮左值(變量 `x`)的類型。它發現 `x` 已經被推斷為整數(`i32`)，所以它知道我們嘗試將一個整數賦給 `x`，並且這是合法的。
3. **打印**：最後，我們使用 `println!` 宏打印 `x` 的值。Rust仍然知道 `x` 的類型是整數，因此它可以正確地將其格式化為字符串並打印出來。

## 7.5 泛型 (Generic Type)

在Rust中，泛型(Generics)允許你編寫可以處理多種數據類型的通用代碼，這對於金融領域的金融工具尤其有用。你可以編寫通用函數或數據結構，以處理不同類型的金融工具(即金融工具的各種數據類型)，而不必為每種類型都編寫重複的代碼。

以下是一個簡單的示例，演示如何使用Rust的泛型來處理不同類型的金融工具：

```rust
struct FinancialInstrument<T> {
    symbol: String,
    value: T,
}

impl<T> FinancialInstrument<T> {
    fn new(symbol: &str, value: T) -> Self {
        FinancialInstrument {
            symbol: String::from(symbol),
            value,
        }
    }

    fn get_value(&self) -> &T {
        &self.value
    }
}

fn main() {
    let stock = FinancialInstrument::new("AAPL", "150.0"); // 引發混淆，value的類型應該是數字
    let option = FinancialInstrument::new("AAPL Call", true); // 引發混淆，value的類型應該是數字或金額

    println!("Stock value: {}", stock.get_value()); // 這裡應該處理數字，但現在是字符串
    println!("Option value: {}", option.get_value()); // 這裡應該處理數字或金額，但現在是布爾值
}
```

**執行結果**:

```text
Stock value: 150.0
Option value: true
```



在這個示例中，我們定義了一個泛型結構體 `FinancialInstrument<T>`，它可以存儲不同類型的金融工具的值。無論是股票還是期權，我們都可以使用相同的代碼來創建和訪問它們的值。

在 `main` 函數中，我們創建了一個股票(`stock`)和一個期權(`option`)，它們都使用了相同的泛型結構體 `FinancialInstrument<T>`。然後，我們使用 `get_value` 方法來訪問它們的值，並打印出來。

**但是,**

在實際操作層面,這是一個**非常好的反例**,應該儘量避免,因為使用泛型把不同的金融工具歸納為FinancialInstrument, 會造成不必要的混淆。

在實際應用中使用泛型時需要考慮的建議：

1. **合理使用泛型**：只有在需要處理多種數據類型的情況下才使用泛型。如果只有一種或少數幾種數據類型，那麼可能不需要泛型，可以直接使用具體類型。
2. **提供有意義的類型參數名稱**：為泛型參數選擇有意義的名稱，以便其他開發人員能夠理解代碼的含義。避免使用過於抽象的名稱。
3. **文檔和註釋**：為使用泛型的代碼提供清晰的文檔和註釋，解釋泛型參數的作用和預期的數據類型。這有助於其他開發人員更容易理解代碼。
4. **測試和驗證**：確保使用泛型的代碼經過充分的測試和驗證，以確保其正確性和性能。泛型代碼可能會引入更多的複雜性，因此需要額外的關注。
5. **避免過度抽象**：避免在不必要的地方使用泛型。如果一個特定的實現對於某個特定問題更加清晰和高效，不要強行使用泛型。

### 案例：  通用投資組合

承接上文，讓我們看一個**更合適的案例**，其中泛型用於處理更具體的問題。考慮一個投資組合管理系統，其中有不同類型的資產(股票、債券、期權等)。我們可以使用泛型來實現一個通用的投資組合結構，但同時保留每種資產的具體類型：

```rust
// 定義一個泛型的資產結構
#[derive(Debug)]
struct Asset<T> {
    name: String,
    asset_type: T,
    // 這裡可以包含資產的其他屬性
}

// 定義不同類型的資產
#[derive(Debug)]
enum AssetType {
    Stock,
    Bond,
    Option,
    // 可以添加更多類型
}

// 示例資產類型之一：股票
#[allow(dead_code)]
#[derive(Debug)]
struct Stock {
    ticker: String,
    price: f64,
    // 其他股票相關屬性
}

// 示例資產類型之一：債券
#[allow(dead_code)]
#[derive(Debug)]
struct Bond {
    issuer: String,
    face_value: f64,
    // 其他債券相關屬性
}

// 示例資產類型之一：期權
#[allow(dead_code)]
#[derive(Debug)]
struct Option {
    underlying_asset: String,
    strike_price: f64,
    // 其他期權相關屬性
}

fn main() {
    // 創建不同類型的資產實例
    let stock = Asset {
        name: "Apple Inc.".to_string(),
        asset_type: AssetType::Stock,
    };

    let bond = Asset {
        name: "US Treasury Bond".to_string(),
        asset_type: AssetType::Bond,
    };

    let option = Asset {
        name: "Call Option on Google".to_string(),
        asset_type: AssetType::Option,
    };

    // 打印不同類型的資產
    println!("Asset 1: {} ({:?})", stock.name, stock.asset_type);
    println!("Asset 2: {} ({:?})", bond.name, bond.asset_type);
    println!("Asset 3: {} ({:?})", option.name, option.asset_type);
}

```

在這個示例中，我們定義了一個泛型結構體 `Asset<T>` 代表投資組閤中的資產。這個泛型結構體使用了泛型參數 `T`，以保持投資組合的多樣和靈活性——因為我們可以通過 trait 和具體的資產類型(比如 `Stock`、`Option` 等)來確保每種資產都有自己獨特的屬性和行為。

## 7.6 別名 (Alias)

在很多編程語言中，包括像Rust、TypeScript和Python等，都提供了一種機制來給已有的類型取一個新的名字，這通常被稱為"類型別名"或"類型重命名"。這可以增加代碼的可讀性和可維護性，尤其在處理複雜的類型時很有用。Rust的類型系統可以非常強大和靈活。

讓我們再次演示一個量化金融領域的案例，這次類型別名是主角。這個示例將使用類型別名來表示不同的金融數據， 如價格、交易量、日期等。



```rust
// 定義一個類型別名，表示價格
type Price = f64;

// 定義一個類型別名，表示交易量
type Volume = u32;

// 定義一個類型別名，表示日期
type Date = String;

// 定義一個結構體，表示股票數據
struct StockData {
    symbol: String,
    date: Date,
    price: Price,
    volume: Volume,
}

// 定義一個結構體，表示債券數據
struct BondData {
    name: String,
    date: Date,
    price: Price,
}

fn main() {
    // 創建股票數據
    let apple_stock = StockData {
        symbol: String::from("AAPL"),
        date: String::from("2023-09-13"),
        price: 150.0,
        volume: 10000,
    };

    // 創建債券數據
    let us_treasury_bond = BondData {
        name: String::from("US Treasury Bond"),
        date: String::from("2023-09-13"),
        price: 1000.0,
    };

    // 輸出股票數據和債券數據
    println!("Stock Data:");
    println!("Symbol: {}", apple_stock.symbol);
    println!("Date: {}", apple_stock.date);
    println!("Price: ${}", apple_stock.price);
    println!("Volume: {}", apple_stock.volume);

    println!("");

    println!("Bond Data:");
    println!("Name: {}", us_treasury_bond.name);
    println!("Date: {}", us_treasury_bond.date);
    println!("Price: ${}", us_treasury_bond.price);
}

```

**執行結果：**

```text
Stock Data:
Symbol: AAPL
Date: 2023-09-13
Price: $150
Volume: 10000

Bond Data:
Name: US Treasury Bond
Date: 2023-09-13
Price: $1000
```



# Chapter 8 - 類型轉換

## 8.1 From 和 Into 特性

在7.3我們已經講過通過From和Into Traits 來實現類型轉換，現在我們來詳細解釋以下它的基礎。

`From` 和 `Into` 是一種相關但略有不同的 trait，它們通常一起使用以提供類型之間的雙向轉換。這兩個 trait 的關係如下：

1. **`From` Trait**：它定義瞭如何從一個類型創建另一個類型的值。通常，你會為需要自定義類型轉換的情況實現 `From` trait。例如，你可以實現 `From<i32>` 來定義如何從 `i32` 轉換為你自定義的類型。
2. **`Into` Trait**：它是 `From` 的反向操作。`Into` trait 允許你定義如何將一個類型轉換為另一個類型。當你實現了 `From` trait 時，Rust 會自動為你提供 `Into` trait 的實現，因此你無需顯式地為類型的反向轉換實現 `Into`。

實際上，這兩個 trait 通常是一體的，因為它們是相互關聯的。如果你實現了 `From`，就可以使用 `into()` 方法來進行類型轉換，而如果你實現了 `Into`，也可以使用 `from()` 方法來進行類型轉換。這使得代碼更具靈活性和可讀性。

標準庫中具有 `From` 特性實現的類型有很多，以下是一些例子：

1. **&str 到 String**: 可以使用 `String::from()` 方法將字符串切片(`&str`)轉換為 `String`：

   ```rust
   let my_str = "hello";
   let my_string = String::from(my_str);
   ```

2. **&String 到 &str**: `String` 類型可以通過引用轉換為字符串切片：

   ```rust
   let my_string = String::from("hello");
   let my_str: &str = &my_string;
   ```

3. **數字類型之間的轉換**: 例如，可以將整數類型轉換為浮點數類型，或者反之：

   ```rust
   let int_num = 42;
   let float_num = f64::from(int_num);
   ```

4. **字符到字符串**: 字符類型可以使用 `to_string()` 方法轉換為字符串：

   ```rust
   let my_char = 'a';
   let my_string = my_char.to_string();
   ```

5. **Vec 到 Boxed Slice**: 可以使用 `Vec::into_boxed_slice()` 將 `Vec` 轉換為堆分配的切片(`Box<[T]>`)：

   ```rust
   let my_vec = vec![1, 2, 3];
   let boxed_slice: Box<[i32]> = my_vec.into_boxed_slice();
   ```

這些都是標準庫中常見的 `From` 實現的示例，它們使得不同類型之間的轉換更加靈活和方便。要記住，`From` 特性是一種用於定義類型之間轉換規則的強大工具。

## 8.2 TryFrom 和 TryInto 特性

與 `From` 和 `Into` 類似，`TryFrom` 和 `TryInto` 是用於類型轉換的通用 traits。不同之處在於，`TryFrom` 和 `TryInto` 主要用於可能會 **導致錯誤** 的轉換，因此它們的返回類型也是 `Result`。

當使用量化金融案例時，可以考慮如何處理不同金融工具的價格或指標之間的轉換，例如將股票價格轉換為對數收益率。以下是一個示例：

```rust
use std::convert::{TryFrom, TryInto};

// 我們來自己建立一個自定義的錯誤類型 ConversionError , 用來彙報類型轉換出錯
#[derive(Debug)]
struct ConversionError;

// 定義一個結構體表示股票價格
struct StockPrice {
    price: f64,
}

// 實現 TryFrom 來嘗試將股票價格轉換為對數收益率，可能失敗
impl TryFrom<StockPrice> for f64 {
    type Error = ConversionError;

    fn try_from(stock_price: StockPrice) -> Result<Self, Self::Error> {
        if stock_price.price > 0.0 {
            Ok(stock_price.price.ln()) // 計算對數收益率
        } else {
            Err(ConversionError)
        }
    }
}

fn main() {
    // 嘗試使用 TryFrom 進行類型轉換
    let valid_price = StockPrice { price: 50.0 };
    let result: Result<f64, ConversionError> = valid_price.try_into();
    println!("{:?}", result); // 打印對數收益率

    let invalid_price = StockPrice { price: -10.0 };
    let result: Result<f64, ConversionError> = invalid_price.try_into();
    println!("{:?}", result); // 打印錯誤信息
}

```

在這個示例中，我們定義了一個 `StockPrice` 結構體來表示股票價格，然後使用 `TryFrom` 實現了從 `StockPrice` 到 `f64` 的類型轉換，其中 `f64` 表示對數收益率。

![自然對數函數示意](https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Logarithm.svg/300px-Logarithm.svg.png)

自然對數(英語：Natural logarithm)為以數學常數e為底數的對數函數，我們知道它的定義域是**(0, +∞)**，也就是取值是要大於0的。如果股票價格小於等於0，轉換會產生錯誤。在 `main` 函數中，我們演示瞭如何使用 `TryFrom` 進行類型轉換，並在可能失敗的情況下獲取 `Result` 類型的結果。這個示例展示瞭如何在量化金融中處理不同類型之間的轉換。



## 8.3 ToString和FromStr

這兩個 trait 是用於類型轉換和解析字符串的常用方法。讓我給你解釋一下它們的作用和在量化金融領域中的一個例子。

首先，ToString trait 是用於將類型轉換為字符串的 trait。它是一個通用 trait，可以為任何類型實現。通過實現ToString trait，類型可以使用to_string()方法將自己轉換為字符串。例如，如果有一個表示價格的自定義結構體，可以實現ToString trait以便將其價格轉換為字符串形式。

```rust
struct Price {
    currency: String,
    value: f64,
}

impl ToString for Price {
    fn to_string(&self) -> String {
        format!("{} {}", self.value, self.currency)
    }
}

fn main() {
    let price = Price {
        currency: String::from("USD"),
        value: 10.99,
    };
    let price_string = price.to_string();
    println!("Price: {}", price_string); // 輸出: "Price: 10.99 USD"
}

```

接下來，FromStr trait 是用於從字符串解析出指定類型的 trait。它也是通用 trait，可以為任何類型實現。通過實現FromStr trait，類型可以使用from_str()方法從字符串中解析出自身。

例如，在金融領域中，如果有一個表示股票價格的類型，可以實現FromStr trait以便從字符串解析出股票價格。

```rust
use std::str::FromStr;

// 自定義結構體，表示股票價格
struct StockPrice {
    ticker_symbol: String,
    price: f64,
}

// 實現ToString trait，將StockPrice轉換為字符串
impl ToString for StockPrice {
    // 將StockPrice結構體轉換為字符串
    fn to_string(&self) -> String {
        format!("{}:{}", self.ticker_symbol, self.price)
    }
}

// 實現FromStr trait，從字符串解析出StockPrice
impl FromStr for StockPrice {
    type Err = ();

    // 從字符串解析StockPrice
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // 將字符串s根據冒號分隔成兩個部分
        let components: Vec<&str> = s.split(':').collect();

        // 如果字符串不由兩部分組成，那一定是發生錯誤了，返回錯誤
        if components.len() != 2 {
            return Err(());
        }

        // 解析第一個部分為股票代碼
        let ticker_symbol = String::from(components[0]);

        // 解析第二個部分為價格
        // 這裡使用unwrap()用於簡化示例，實際應用中可能需要更完備的錯誤處理
        let price = components[1].parse::<f64>().unwrap();

        // 返回解析後的StockPrice
        Ok(StockPrice {
            ticker_symbol,
            price,
        })
    }
}

fn main() {
    let price_string = "AAPL:150.64";

    // 使用from_str()方法從字符串解析出StockPrice
    let stock_price = StockPrice::from_str(price_string).unwrap();

    // 輸出解析得到的StockPrice字段
    println!("Ticker Symbol: {}", stock_price.ticker_symbol); // 輸出: "AAPL"
    println!("Price: {}", stock_price.price); // 輸出: "150.64"

    // 使用to_string()方法將StockPrice轉換為字符串
    let price_string_again = stock_price.to_string();

    // 輸出轉換後的字符串
    println!("Price String: {}", price_string_again); // 輸出: "AAPL:150.64"
}
```

**執行結果：**

```shell
Ticker Symbol: AAPL # from_str方法解析出來的股票代碼信息
Price: 150.64 # from_str方法解析出來的價格信息
Price String: AAPL:150.64 # 和"let price_string = "AAPL:150.64";"又對上了
```



# Chapter 9 - 流程控制

## 9.1 if 條件語句

在Rust中，`if` 語句用於條件控制，允許根據條件的真假來執行不同的代碼塊。Rust的`if`語句有一些特點和語法細節，以下是對Rust的`if`語句的介紹：

1. **基本語法**：

   ```rust
   if condition {
       // 如果條件為真(true)，執行這裡的代碼塊
   } else {
       // 如果條件為假(false)，執行這裡的代碼塊(可選)
   }
   ```

   `condition` 是一個布爾表達式，根據其結果，決定執行哪個代碼塊。`else`部分是可選的，你可以選擇不包括它。

2. **多條件的`if`語句**：

   你可以使用 `else if` 來添加多個條件分支，例如：

   ```rust
   if condition1 {
       // 條件1為真時執行
   } else if condition2 {
       // 條件1為假，條件2為真時執行
   } else {
       // 所有條件都為假時執行
   }
   ```

   這允許你在多個條件之間進行選擇。

3. **表達式返回值**：

   在Rust中，`if`語句是一個表達式，意味著它可以返回一個值。這使得你可以將`if`語句的結果賦值給一個變量，如下所示：

   ```rust
   let result = if condition { 1 } else { 0 };
   ```

   這裡，`result`的值將根據條件的真假來賦值為1或0。注意並不是布爾值。

4. **模式匹配**：

   你還可以使用`if`語句進行模式匹配，而不僅僅是布爾條件。例如，你可以匹配枚舉類型或其他自定義類型的值。

   ```rust
   enum Status {
       Success,
       Error,
   }
   
   let status = Status::Success;
   
   if let Status::Success = status {
       // 匹配成功
   } else {
       // 匹配失敗
   }
   ```

總的來說，Rust的`if`語句提供了強大的條件控制功能，同時具有表達式和模式匹配的特性，使得它在處理不同類型的條件和場景時非常靈活和可讀。

現在我們來簡單應用一下if語句，順便預習for語句：

```rust
fn main() {
    // 初始化投資組合的風險分數
    let portfolio_risk_scores = vec![0.8, 0.6, 0.9, 0.5, 0.7];
    let risk_threshold = 0.7; // 風險分數的閾值

    // 計算高風險資產的數量
    let mut high_risk_assets = 0;

    for &risk_score in portfolio_risk_scores.iter() {
        // 使用 if 條件語句判斷風險分數是否超過閾值
        if risk_score > risk_threshold {
            high_risk_assets += 1;
        }
    }

    // 基於高風險資產數量輸出不同的信息
    if high_risk_assets == 0 {
        println!("投資組合風險水平低，沒有高風險資產。");
    } else if high_risk_assets <= 2 {
        println!("投資組合風險水平中等，有少量高風險資產。");
    } else {
        println!("投資組合風險水平較高，有多個高風險資產。");
    }
}

```

**執行結果：**

```text
投資組合風險水平中等，有少量高風險資產。
```



## 9.2 for 循環  (For Loops)

Rust 是一種系統級編程語言，它具有強大的內存安全性和併發性能。在 Rust 中，使用 `for` 循環來迭代集合(如數組、向量、切片等)中的元素或者執行某個操作一定次數。下面是 Rust 中 `for` 循環的基本語法和一些示例：

### 9.2.1 範圍

你還可以使用 `for` 循環來執行某個操作一定次數，可以使用 `..` 運算符創建一個範圍，並在循環中使用它：

```rust
fn main() {
    for i in 1..=5 {
        println!("Iteration: {}", i);
    }
}
```

上述示例將打印數字 1 到 5，包括 5。範圍使用 `1..=5` 表示，包括起始值 1 和結束值 5。



### 9.2.2 迭代器

在 Rust 中，使用 `for` 循環來迭代集合(例如數組或向量)中的元素非常簡單。下面是一個示例，演示如何迭代一個整數數組中的元素：

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];

    for number in numbers.iter() {
        println!("Number: {}", number);
    }
}
```

在這個示例中，`numbers.iter()` 返回一個迭代器，通過 `for` 循環迭代器中的元素並打印每個元素的值。



## 9.3 迭代器的諸種方法

除了使用 `for` 循環，你還可以使用 Rust 的迭代器方法來處理集合中的元素。這些方法包括 `map`、`filter`、`fold` 等，它們允許你進行更復雜的操作。

### 9.3.1 map方法

在Rust中，`map`方法是用於迭代和轉換集合元素的常見方法之一。`map`方法接受一個閉包(或函數)，並將其應用於集合中的每個元素，然後返回一個新的集合，其中包含了應用了閉包後的結果。這個方法通常用於對集合中的每個元素執行某種操作，然後生成一個新的集合，而不會修改原始集合。

### 案例1 用map計算並映射x的平方

```rust
fn main() {
    // 創建一個包含一些數字的向量
    let numbers = vec![1, 2, 3, 4, 5];

    // 使用map方法對向量中的每個元素進行平方操作，並創建一個新的向量
    let squared_numbers: Vec<i32> = numbers.iter().map(|&x| x * x).collect();

    // 輸出新的向量
    println!("{:?}", squared_numbers);
}
```

在這個例子中，我們首先創建了一個包含一些整數的向量`numbers`。然後，我們使用`map`方法對`numbers`中的每個元素執行了平方操作，這個操作由閉包`|&x| x * x`定義。最後，我們使用`collect`方法將結果收集到一個新的向量` squared_numbers` 中，並打印出來。

### 案例2 計算對數收益率

```rust
fn main() {
    // 創建一個包含股票價格的向量
    let stock_prices = vec![100.0, 105.0, 110.0, 115.0, 120.0];

    // 使用map方法計算每個價格的對數收益率，並創建一個新的向量
    let log_returns: Vec<f64> = stock_prices.iter().map(|&price| price / 100.0f64.ln()).collect();

    // 輸出對數收益率
    println!("{:?}", log_returns);
}

```

**執行結果：**

```text
[21.71472409516259, 22.80046029992072, 23.88619650467885, 24.971932709436977, 26.05766891419511]
```



在上述示例中，我們使用了 `map` 方法將原始向量中的每個元素都乘以 2，然後使用 `collect` 方法將結果收集到一個新的向量中。

### 9.3.2 filter 方法

filter方法是一個在金融數據分析中常用的方法，它用於篩選出符合特定條件的元素並返回一個新的迭代器。這個方法需要傳入一個閉包作為參數，該閉包接受一個元素的引用並返回一個布爾值，用於判斷該元素是否應該被包含在結果迭代器中。

在金融分析中，我們通常需要篩選出符合某些條件的數據進行處理，例如篩選出大於某個閾值的股票或者小於某個閾值的交易。filter方法可以幫助我們方便地實現這個功能。

下面是一個使用filter方法篩選出大於某個閾值的交易的例子：

```rust
// 定義一個Trade結構體  
#[derive(Debug, PartialEq)]  
struct Trade {  
    price: f64,  
    volume: i32,  
}  
  
fn main() {  
    let trades = vec![  
        Trade { price: 10.0, volume: 100 },  
        Trade { price: 20.0, volume: 200 },  
        Trade { price: 30.0, volume: 300 },  
    ];  
  
    let threshold = 25.0;  
  
    let mut filtered_trades = trades.iter().filter(|trade| trade.price > threshold);  
  
    match filtered_trades.next() {  
        Some(&Trade { price: 30.0, volume: 300 }) => println!("第一個交易正確"),  
        _ => println!("第一個交易不正確"),  
    }  
  
    match filtered_trades.next() {  
        None => println!("沒有更多的交易"),  
        _ => println!("還有更多的交易"),  
    }  
}
```

**執行結果：**

```text
第一個交易正確
沒有更多的交易
```

在這個例子中，我們有一個包含多個交易的向量，每個交易都有一個價格和交易量。我們想要篩選出價格大於25.0的交易。我們使用filter方法傳入一個閉包來實現這個篩選。閉包接受一個Trade的引用並返回該交易的價格是否大於閾值。最終，我們得到一個只包含符合條件的交易的迭代器。

### 9.3.2 next方法

在金融領域，一個常見的用例是處理時間序列數據。假設我們有一個包含股票價格的時間序列數據集，我們想要找出大於給定閾值的下一個價格。我們可以使用Rust中的`next`方法來實現這個功能。

首先，我們需要定義一個結構體來表示時間序列數據。假設我們的數據存儲在一個`Vec<f64>`中，其中每個元素代表一個時間點的股票價格。我們可以創建一個名為`TimeSeries`的結構體，並實現`Iterator` trait來使其可迭代。

```rust
pub struct TimeSeries {  
    data: Vec<f64>,  
    index: usize,  
}  
  
impl TimeSeries {  
    pub fn new(data: Vec<f64>) -> Self {  
        Self { data, index: 0 }  
    }  
}  
  
impl Iterator for TimeSeries {  
    type Item = f64;  
  
    fn next(&mut self) -> Option<Self::Item> {  
        if self.index < self.data.len() {  
            let value = self.data[self.index];  
            self.index += 1;  
            Some(value)  
        } else {  
            None  
        }  
    }  
}
```

接下來，我們可以創建一個函數來找到大於給定閾值的下一個價格。我們可以使用`filter`方法和`next`方法來遍歷時間序列數據，並找到第一個大於閾值的價格。

```rust
pub fn find_next_threshold(time_series: &mut TimeSeries, threshold: f64) -> Option<f64> {  
    time_series.filter(|&price| price > threshold).next()  
}
```

現在，我們可以使用這個函數來查找時間序列數據中大於給定閾值的下一個價格。以下是一個示例：

```rust
fn main() {  
    let data = vec![10.0, 20.0, 30.0, 40.0, 50.0];  
    let mut time_series = TimeSeries::new(data);  
    let threshold = 35.0;  
  
    match find_next_threshold(&mut time_series, threshold) {  
        Some(price) => println!("下一個大於{}的價格是{}", threshold, price),  
        None => println!("沒有找到大於{}的價格", threshold),  
    }  
}
```

在這個示例中，我們創建了一個包含股票價格的時間序列數據，並使用`find_next_threshold`函數找到大於35.0的下一個價格。輸出將會是"下一個大於35的價格是40"。如果沒有找到大於閾值的價格，輸出將會是"沒有找到大於35的價格"。

### 9.3.4 fold 方法

`fold` 是 Rust 標準庫中 `Iterator` trait 提供的一個重要方法之一。它用於在迭代器中累積值，將一個初始值和一個閉包函數應用於迭代器的每個元素，並返回最終的累積結果。`fold` 方法的簽名如下：

```rust
fn fold<B, F>(self, init: B, f: F) -> B
where
    F: FnMut(B, Self::Item) -> B,
```

- `self` 是迭代器本身。
- `init` 是一個初始值，用於累積操作的初始狀態。
- `f` 是一個閉包函數，它接受兩個參數：累積值（初始值或上一次迭代的結果）和迭代器的下一個元素，然後返回新的累積值。

`fold` 方法的執行過程如下：

1. 使用初始值 `init` 初始化累積值。
2. 對於迭代器的每個元素，調用閉包函數 `f`，傳遞當前累積值和迭代器的元素。
3. 將閉包函數的返回值更新為新的累積值。
4. 重複步驟 2 和 3，直到迭代器中的所有元素都被處理。
5. 返回最終的累積值。

現在，讓我們通過一個金融案例來演示 `fold` 方法的使用。假設我們有一組金融交易記錄，每個記錄包含交易類型（存款或提款）和金額。我們想要計算總存款和總提款的差值，以查看賬戶的餘額。

```rust
struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

fn main() {
    let transactions = vec![
        Transaction { transaction_type: "Deposit", amount: 100.0 },
        Transaction { transaction_type: "Withdrawal", amount: 50.0 },
        Transaction { transaction_type: "Deposit", amount: 200.0 },
        Transaction { transaction_type: "Withdrawal", amount: 75.0 },
    ];

    let initial_balance = 0.0; // 初始餘額為零

    let balance = transactions.iter().fold(initial_balance, |acc, transaction| {
        match transaction.transaction_type {
            "Deposit" => acc + transaction.amount,
            "Withdrawal" => acc - transaction.amount,
            _ => acc,
        }
    });

    println!("Account Balance: ${:.2}", balance);
}
```

在這個示例中，我們首先定義了一個 `Transaction` 結構體來表示交易記錄，包括交易類型和金額。然後，我們創建了一個包含多個交易記錄的 `transactions` 向量。我們使用 `fold` 方法來計算總存款和總提款的差值，以獲取賬戶的餘額。

在 `fold` 方法的閉包函數中，我們根據交易類型來更新累積值 `acc`。如果交易類型是 "Deposit"，我們將金額添加到餘額上，如果是 "Withdrawal"，則將金額從餘額中減去。最終，我們打印出賬戶餘額。

### 9.3.5 collect 方法 

`collect` 是 Rust 中用於將迭代器的元素收集到一個集合（collection）中的方法。它是 `Iterator` trait 提供的一個重要方法。`collect` 方法的簽名如下：

```rust
fn collect<B>(self) -> B
where
    B: FromIterator<Self::Item>,
```

- `self` 是迭代器本身。
- `B` 是要收集到的集合類型，它必須實現 `FromIterator` trait，這意味著可以從迭代器的元素類型構建該集合類型。
- `collect` 方法將迭代器中的元素轉換為集合 `B` 並返回。

`collect` 方法的工作原理如下：

1. 創建一個空的集合 `B`，這個集合將用於存儲迭代器中的元素。
2. 對於迭代器的每個元素，將元素添加到集合 `B` 中。
3. 返回集合 `B`。

現在，讓我們通過一個金融案例來演示 `collect` 方法的使用。假設我們有一組金融交易記錄，每個記錄包含交易類型（存款或提款）和金額。我們想要將所有存款記錄收集到一個向量中，以進一步分析。

```rust
struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

fn main() {
    let transactions = vec![
        Transaction { transaction_type: "Deposit", amount: 100.0 },
        Transaction { transaction_type: "Withdrawal", amount: 50.0 },
        Transaction { transaction_type: "Deposit", amount: 200.0 },
        Transaction { transaction_type: "Withdrawal", amount: 75.0 },
    ];

    // 使用 collect 方法將存款記錄收集到一個向量中
    let deposits: Vec<Transaction> = transactions
        .iter()
        .filter(|&transaction| transaction.transaction_type == "Deposit")
        .cloned()
        .collect();

    println!("Deposit Transactions: {:?}", deposits);
}
```

在這個示例中，我們首先定義了一個 `Transaction` 結構體來表示交易記錄，包括交易類型和金額。然後，我們創建了一個包含多個交易記錄的 `transactions` 向量。

接下來，我們使用 `collect` 方法來將所有存款記錄收集到一個新的 `Vec<Transaction>` 向量中。我們首先使用 `iter()` 方法將 `transactions` 向量轉換為迭代器，然後使用 `filter` 方法篩選出交易類型為 "Deposit" 的記錄。接著，我們使用 `cloned()` 方法來克隆這些記錄，以便將它們收集到新的向量中。

最後，我們打印出包含所有存款記錄的向量。這樣，我們就成功地使用 `collect` 方法將特定類型的交易記錄收集到一個集合中，以便進一步分析或處理。

## 9.4 while 循環 (While Loops) 

`while` 循環是一種在 Rust 中用於重複執行代碼塊直到條件不再滿足的控制結構。它的執行方式是在每次循環迭代之前檢查一個條件表達式，只要條件為真，循環就會繼續執行。一旦條件為假，循環將終止，控制流將跳出循環。

以下是 `while` 循環的一般形式：

```rust
while condition {
    // 循環體代碼
}
```

- `condition` 是一個布爾表達式，它用於檢查循環是否應該繼續執行。只要 `condition` 為真，循環體中的代碼將被執行。
- 循環體包含要重複執行的代碼，通常會改變某些狀態以最終使得 `condition` 為假，從而退出循環。

下面是一個使用 `while` 循環的示例，演示瞭如何計算存款和提款的總和，直到交易記錄列表為空：

```rust
struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

fn main() {
    let mut transactions = vec![
        Transaction { transaction_type: "Deposit", amount: 100.0 },
        Transaction { transaction_type: "Withdrawal", amount: 50.0 },
        Transaction { transaction_type: "Deposit", amount: 200.0 },
        Transaction { transaction_type: "Withdrawal", amount: 75.0 },
    ];

    let mut total_balance = 0.0;

    while !transactions.is_empty() {
        let transaction = transactions.pop().unwrap(); // 從末尾取出一個交易記錄
        match transaction.transaction_type {
            "Deposit" => total_balance += transaction.amount,
            "Withdrawal" => total_balance -= transaction.amount,
            _ => (),
        }
    }

    println!("Account Balance: ${:.2}", total_balance);
}
```

在這個示例中，我們定義了一個 `Transaction` 結構體來表示交易記錄，包括交易類型和金額。我們創建了一個包含多個交易記錄的 `transactions` 向量，並初始化 `total_balance` 為零。

然後，我們使用 `while` 循環來迭代處理交易記錄，直到 `transactions` 向量為空。在每次循環迭代中，我們從 `transactions` 向量的末尾取出一個交易記錄，並根據交易類型更新 `total_balance`。最終，當所有交易記錄都處理完畢時，循環將終止，我們打印出賬戶餘額。

這個示例演示瞭如何使用 `while` 循環來處理一個動態變化的數據集，直到滿足退出條件為止。在金融領域，這種循環可以用於處理交易記錄、賬單或其他需要迭代處理的數據。

## 9.5 loop循環  

`loop` 循環是 Rust 中的一種基本循環結構，它允許你無限次地重複執行一個代碼塊，直到明確通過 `break` 語句終止循環。與 `while` 循環不同，`loop` 循環沒有條件表達式來判斷是否退出循環，因此它總是會無限循環，直到遇到 `break`。

以下是 `loop` 循環的一般形式：

```rust
loop {
    // 循環體代碼
    if condition {
        break; // 通過 break 語句終止循環
    }
}
```

- 循環體中的代碼塊將無限次地執行，直到遇到 `break` 語句。
- `condition` 是一個可選的條件表達式，當條件為真時，循環將終止。

下面是一個使用 `loop` 循環的示例，演示瞭如何計算存款和提款的總和，直到輸入的交易記錄為空：

```rust
struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

fn main() {
    let mut transactions = Vec::new();

    loop {
        let transaction_type: String = {
            println!("Enter transaction type (Deposit/Withdrawal) or 'done' to finish:");
            let mut input = String::new();
            std::io::stdin().read_line(&mut input).expect("Failed to read line");
            input.trim().to_string()
        };

        if transaction_type == "done" {
            break; // 通過 break 語句終止循環
        }

        let amount: f64 = {
            println!("Enter transaction amount:");
            let mut input = String::new();
            std::io::stdin().read_line(&mut input).expect("Failed to read line");
            input.trim().parse().expect("Invalid input")
        };

        transactions.push(Transaction {
            transaction_type: &transaction_type,
            amount,
        });
    }

    let mut total_balance = 0.0;

    for transaction in &transactions {
        match transaction.transaction_type {
            "Deposit" => total_balance += transaction.amount,
            "Withdrawal" => total_balance -= transaction.amount,
            _ => (),
        }
    }

    println!("Account Balance: ${:.2}", total_balance);
}
```

在這個示例中，我們首先定義了一個 `Transaction` 結構體來表示交易記錄，包括交易類型和金額。然後，我們創建了一個空的 `transactions` 向量，用於存儲用戶輸入的交易記錄。

接著，我們使用 `loop` 循環來反覆詢問用戶輸入交易類型和金額，直到用戶輸入 "done" 為止。如果用戶輸入 "done"，則通過 `break` 語句終止循環。否則，我們將用戶輸入的交易記錄添加到 `transactions` 向量中。

最後，我們遍歷 `transactions` 向量，計算存款和提款的總和，以獲取賬戶餘額，並打印出結果。

這個示例演示瞭如何使用 `loop` 循環處理用戶輸入的交易記錄，直到用戶選擇退出。在金融領域，這種循環可以用於交互式地記錄和計算賬戶的交易信息。



## 9.6 if let 和 while let語法糖  

`if let` 和 `while let` 是 Rust 中的語法糖，用於簡化模式匹配的常見用例，特別是用於處理 `Option` 和 `Result` 類型。它們允許你以更簡潔的方式進行模式匹配，以處理可能的成功或失敗情況。

**1. if let 表達式：**

`if let` 允許你檢查一個值是否匹配某個模式，並在匹配成功時執行代碼塊。語法如下：

```rust
if let Some(value) = some_option {
    // 匹配成功，使用 value
} else {
    // 匹配失敗
}
```

在上述示例中，如果 `some_option` 是 `Some` 包裝的值，那麼匹配成功，並且 `value` 將被綁定到 `Some` 中的值，然後執行相應的代碼塊。如果 `some_option` 是 `None`，則匹配失敗，執行 `else` 塊。

**2. while let 循環：**

`while let` 允許你重複執行一個代碼塊，直到匹配失敗（通常是直到 `None`）。語法如下：

```rust
while let Some(value) = some_option {
    // 匹配成功，使用 value
}
```

在上述示例中，只要 `some_option` 是 `Some` 包裝的值，就會重複執行代碼塊，並且 `value` 會在每次迭代中被綁定到 `Some` 中的值。一旦匹配失敗（即 `some_option` 變為 `None`），循環將終止。

**金融案例示例：**

假設我們有一個金融應用程序，其中用戶可以進行存款和提款操作，而每個操作都以 `Transaction` 結構體表示。我們將使用 `Option` 來模擬用戶輸入的交易，然後使用 `if let` 和 `while let` 處理這些交易。

```rust
struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

fn main() {
    let mut account_balance = 0.0;

    // 模擬用戶輸入的交易列表
    let transactions = vec![
        Some(Transaction { transaction_type: "Deposit", amount: 100.0 }),
        Some(Transaction { transaction_type: "Withdrawal", amount: 50.0 }),
        Some(Transaction { transaction_type: "Deposit", amount: 200.0 }),
        None, // 用戶結束輸入
    ];

    for transaction in transactions {
        if let Some(tx) = transaction {
            match tx.transaction_type {
                "Deposit" => {
                    account_balance += tx.amount;
                    println!("Deposited ${:.2}", tx.amount);
                }
                "Withdrawal" => {
                    account_balance -= tx.amount;
                    println!("Withdrawn ${:.2}", tx.amount);
                }
                _ => println!("Invalid transaction type"),
            }
        } else {
            break; // 用戶結束輸入，退出循環
        }
    }

    println!("Account Balance: ${:.2}", account_balance);
}
```

在這個示例中，我們使用 `transactions` 向量來模擬用戶輸入的交易記錄，包括存款和提款，以及一個 `None` 表示用戶結束輸入。然後，我們使用 `for` 循環和 `if let` 來處理每個交易記錄，當遇到 `None` 時，循環終止。

這個示例演示瞭如何使用 `if let` 和 `while let` 簡化模式匹配，以處理可能的成功和失敗情況，以及在金融應用程序中處理用戶輸入的交易記錄。

## 9.7 併發迭代器  

在 Rust 中，通過標準庫的 `rayon` crate，你可以輕鬆創建併發迭代器，用於在並行計算中高效處理集合的元素。`rayon` 提供了一種併發編程的方式，能夠利用多核處理器的性能，特別適合處理大規模數據集。

以下是如何使用併發迭代器的一般步驟：

1. 首先，確保在 `Cargo.toml` 中添加 `rayon` crate 的依賴：

   ```toml
   [dependencies]
   rayon = "1.5"
   ```

2. 導入 `rayon` crate：

   ```rust
   use rayon::prelude::*;
   ```

3. 使用 `.par_iter()` 方法將集合轉換為併發迭代器。然後，你可以調用 `.for_each()`、`.map()`、`.filter()` 等方法來進行並行操作。

以下是一個金融案例，演示如何使用併發迭代器計算多個賬戶的總餘額。每個賬戶包含一組交易記錄，每個記錄都有交易類型（存款或提款）和金額。我們將並行計算每個賬戶的總餘額，然後計算所有賬戶的總餘額。

```rust
use rayon::prelude::*;

struct Transaction {
    transaction_type: &'static str,
    amount: f64,
}

struct Account {
    transactions: Vec<Transaction>,
}

impl Account {
    fn new(transactions: Vec<Transaction>) -> Self {
        Account { transactions }
    }

    fn calculate_balance(&self) -> f64 {
        self.transactions
            .par_iter() // 將迭代器轉換為併發迭代器
            .map(|transaction| {
                match transaction.transaction_type {
                    "Deposit" => transaction.amount,
                    "Withdrawal" => -transaction.amount,
                    _ => 0.0,
                }
            })
            .sum() // 並行計算總和
    }
}

fn main() {
    let account1 = Account::new(vec![
        Transaction { transaction_type: "Deposit", amount: 100.0 },
        Transaction { transaction_type: "Withdrawal", amount: 50.0 },
        Transaction { transaction_type: "Deposit", amount: 200.0 },
    ]);

    let account2 = Account::new(vec![
        Transaction { transaction_type: "Deposit", amount: 300.0 },
        Transaction { transaction_type: "Withdrawal", amount: 75.0 },
    ]);

    let total_balance: f64 = vec![&account1, &account2]
        .par_iter()
        .map(|account| account.calculate_balance())
        .sum(); // 並行計算總和

    println!("Total Account Balance: ${:.2}", total_balance);
}
```

在這個示例中，我們定義了 `Transaction` 結構體表示交易記錄和 `Account` 結構體表示賬戶。每個賬戶包含一組交易記錄。在 `Account` 結構體上，我們實現了 `calculate_balance()` 方法，該方法使用併發迭代器計算賬戶的總餘額。

在 `main` 函數中，我們創建了兩個賬戶 `account1` 和 `account2`，然後將它們放入一個向量中。接著，我們使用併發迭代器來並行計算每個賬戶的餘額，並將所有賬戶的總餘額相加，最後打印出結果。

這個示例演示瞭如何使用 `rayon` crate 的併發迭代器來高效處理金融應用程序中的數據，特別是在處理多個賬戶時，可以充分利用多核處理器的性能。

# Chapter 10 - 函數, 方法 和 閉包

在Rust中，函數、方法和閉包都是用於執行代碼的可調用對象，但它們在語法和用途上有相當的不同。下面我會詳細解釋每種可調用對象的特點和用法：

1. **函數(Function)**：

   - 函數是Rust中最基本的可調用對象。

   - 函數通常在全局作用域或模塊中定義，並且可以通過名稱來調用。

   - 函數可以接受參數，並且可以返回一個值。

   - 函數的定義以 `fn` 關鍵字開頭，如下所示：

     ```rust
     fn add(a: i32, b: i32) -> i32 {
         a + b
     }
     ```

   - 在調用函數時，你可以使用其名稱，並傳遞適當的參數，如下所示：

     ```rust
     let result = add(5, 3);
     ```

2. **方法(Method)**：

   - 方法是與特定類型關聯的函數。在Rust中，方法是面向對象編程的一部分。

   - 方法是通過將函數與結構體、枚舉、或者 trait 相關聯來定義的。

   - 方法使用 `self` 參數來訪問調用它們的實例的屬性和行為。

   - 方法的定義以 `impl` 關鍵字開始，如下所示：

     ```rust
     struct Rectangle {
         width: u32,
         height: u32,
     }
     
     impl Rectangle {
         fn area(&self) -> u32 {
             self.width * self.height
         }
     }
     ```

   - 在調用方法時，你首先創建一個實例，然後使用點號運算符調用方法，如下所示：

     ```rust
     let rect = Rectangle { width: 10, height: 20 };
     let area = rect.area();
     ```

3. **閉包(Closure)**：

   - 閉包是一個可以捕獲其環境的匿名函數。它們類似於函數，但可以捕獲局部變量和外部變量，使其具有一定的狀態。

   - 閉包可以存儲在變量中，傳遞給其他函數或返回作為函數的結果。

   - 閉包通常使用 `||` 語法來定義，如下所示：

     ```rust
     let add_closure = |a, b| a + b;
     ```

   - 你可以像調用函數一樣調用閉包，如下所示：

     ```rust
     let result = add_closure(5, 3);
     ```

   - 閉包可以捕獲外部變量，例如：

     ```rust
     let x = 5;
     let closure = |y| x + y;
     let result = closure(3); // result 等於 8
     ```

這些是Rust中函數、方法和閉包的基本概念和用法。每種可調用對象都有其自己的用途和適用場景，根據需要選擇合適的工具來編寫代碼。本章的重點則是函數的進階用法和閉包的學習。

## 10.1 函數進階

如同python支持泛型函數、高階函數、匿名函數;C語言也支持泛型函數和函數指針一樣，Rust中的函數支持許多進階用法，這些用法可以幫助你編寫更靈活、更高效的代碼。以下是一些常見的函數進階用法：

### 10.1.1 泛型函數(Generic Functions)

(在第14章，我們會進一步詳細瞭解泛型函數)

使用泛型參數可以編寫通用的函數，這些函數可以用於不同類型的數據。

通過在函數簽名中使用尖括號 `<T>` 來聲明泛型參數，並在函數體中使用這些參數來編寫通用代碼。

以下是一個更簡單的例子，演示如何編寫一個泛型函數 `find_max` 來查找任何類型的元素列表中的最大值：

```rust
fn find_max_and_report_letters(list: &[&str]) -> Option<f64> {
    if list.is_empty() {
        return None; // 如果列表為空，返回 None
    }

    let mut max = None; // 用 Option 來存儲最大值
    let mut has_letters = false; // 用來標記是否包含字母

    for item in list.iter() {
        match item.parse::<f64>() {
            Ok(number) => {
                // 如果成功解析為浮點數
                if max.is_none() || number > max.unwrap() {
                    max = Some(number);
                }
            }
            Err(_) => {
                // 解析失敗，表示列表中不小心混入了字母，無法比較。把這個bool傳給has_letters.
                has_letters = true;
            }
        }
    }

    if has_letters {
        println!("列表中包含字母。");
    }

    max // 返回找到的最大值作為 Option<f64>
}

fn main() {
    let data = vec!["3.5", "7.2", "1.8", "9.0", "4.7", "2.1", "A", "B"];
    let max_number = find_max_and_report_letters(&data);

    match max_number {
        Some(max) => println!("最大的數字是: {}", max),
        None => println!("沒有找到有效的數字。"),
    }
}

```

**執行結果**：

```
列表中包含字母。
最大的數字是: 9
```



在這個例子中，`find_max` 函數接受一個泛型切片 `list`，並在其中查找最大值。首先，它檢查列表是否為空，如果是，則返回 `None`。然後，它遍歷列表中的每個元素，將當前最大值與元素進行比較，如果找到更大的元素，就更新 `max`，並且如果有字母還會彙報給我們。最後，函數返回找到的最大值作為 `Option<&T>`。

### 10.1.2 高階函數(Higher-Order Functions)

高階函數(Higher-Order Functions)是一種編程概念，指可以接受其他函數作為參數或者返回函數作為結果的函數, 它在Rust中有廣泛的支持和應用。

以下是關於高階函數在Rust中的詳細介紹：

1. **函數作為參數：** 在Rust中，可以將函數作為參數傳遞給其他函數。這使得我們可以編寫通用的函數，以便它們可以操作不同類型的函數。通常，這樣的函數接受一個函數閉包(closure)作為參數，然後在其內部使用這個閉包來完成一些操作。

   ```rust
   fn apply<F>(func: F, value: i32) -> i32
   where
       F: Fn(i32) -> i32,
   {
       func(value)
   }
   
   fn double(x: i32) -> i32 {
       x * 2
   }
   
   fn main() {
       let result = apply(double, 5);
       println!("Result: {}", result);
   }
   ```

2. **返回函數：** 類似地，你可以編寫函數，以函數作為它們的返回值。這種函數通常被稱為工廠函數，因為它們返回其他函數的實例。

   ```rust
   fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 { //"impl Fn(i32) -> i32 " 是返回類型的標記，它用於指定閉包的類型簽名。
       move |x| x * factor
   }
   
   fn main() {
       let multiply_by_3 = create_multiplier(3);
       let result = multiply_by_3(5);
       println!("Result: {}", result); // 輸出 15
   }
   ```

   在上面的代碼中，`move` 關鍵字用於定義一個閉包(匿名函數)，這個閉包捕獲了外部的變量 `factor`。在 Rust 中，閉包默認是對外部變量的借用(borrow)，但在這個例子中，使用 `move` 關鍵字表示閉包會**擁有**捕獲的變量 `factor` 的所有權：

   1. `create_multiplier` 函數接受一個 `factor` 參數，它是一個整數。然後，它返回一個閉包，這個閉包接受一個整數 `x` 作為參數，並返回 `x * factor` 的結果。

   2. 在 `main` 函數中，我們首先調用 `create_multiplier(3)`，這將返回一個閉包，這個閉包捕獲了 `factor` 變量，其值為 3。

   3. 然後，我們調用 `multiply_by_3(5)`，這實際上是調用了我們之前創建的閉包。閉包中的 `factor` 值是 3，所以 `5 * 3` 的結果是 15。

   4. 最後，我們將結果打印到控制檯，輸出的結果是 `15`。

   `move` 關鍵字的作用是將外部變量的所有權移動到閉包內部，這意味著閉包在內部擁有這個變量的控制權，不再依賴於外部的變量。這對於在閉包中捕獲外部變量並在之後繼續使用它們非常有用，尤其是當這些外部變量可能超出了其作用域時(如在異步編程中)。

3. **迭代器和高階函數：** Rust的標準庫提供了豐富的迭代器方法，這些方法允許你對集合(如數組、向量、迭代器等)進行高級操作，例如`map`、`filter`、`fold`等。這些方法都可以接受函數閉包作為參數，使你能夠非常靈活地處理數據。

   ```rust
   let numbers = vec![1, 2, 3, 4, 5];
   
   // 使用map高階函數將每個數字加倍
   let doubled_numbers: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
   
   // 使用filter高階函數選擇偶數
   let even_numbers: Vec<i32> = numbers.iter().filter(|x| x % 2 == 0).cloned().collect();
   ```

高階函數使得在Rust中編寫更具可讀性和可維護性的代碼變得更容易，同時也允許你以一種更加抽象的方式處理數據和邏輯。通過使用閉包和泛型，Rust的高階函數提供了強大的工具，使得編程更加靈活和表達力強。

### 10.1.3 匿名函數(Anonymous Functions)

- 除了常規的函數定義，Rust還支持匿名函數，也就是閉包。
- 閉包可以在需要時定義，並且可以捕獲其環境中的變量。

```rust
let add = |a, b| a + b;
let result = add(5, 3); // result 等於 8
```

### 案例：計算投資組合的預期收益和風險

在金融領域，高階函數可以用來處理投資組合(portfolio)的各種分析和優化問題。以下是一個示例，演示如何使用高階函數來計算投資組合的收益和風險。

假設我們有一個投資組合，其中包含多個不同的資產，每個資產都有一個預期收益率和風險(標準差)率。我們可以定義一個高階函數來計算投資組合的預期收益和風險，以及根據風險偏好優化資產配置。

```rust
struct Asset {
    expected_return: f64,
    risk: f64,
}

fn calculate_portfolio_metrics(assets: &[Asset], weights: &[f64]) -> (f64, f64) {
    let expected_return: f64 = assets
        .iter()
        .zip(weights.iter())
        .map(|(asset, weight)| asset.expected_return * weight)
        .sum::<f64>();

    let portfolio_risk: f64 = assets
        .iter()
        .zip(weights.iter())
        .map(|(asset, weight)| asset.risk * asset.risk * weight * weight)
        .sum::<f64>();

    (expected_return, portfolio_risk)
}

fn optimize_with_algorithm<F>(_objective_function: F, initial_weights: Vec<f64>) -> Vec<f64>
where
    F: Fn(Vec<f64>) -> f64,
{
    // 這裡簡化為均勻分配權重的實現，實際中需要使用優化算法
    initial_weights
}

fn optimize_portfolio(assets: &[Asset], risk_preference: f64) -> Vec<f64> {
    let objective_function = |weights: Vec<f64>| -> f64 {
        let (expected_return, portfolio_risk) = calculate_portfolio_metrics(&assets, &weights);
        expected_return - risk_preference * portfolio_risk
    };

    let num_assets = assets.len();
    let initial_weights = vec![1.0 / num_assets as f64; num_assets];
    let optimized_weights = optimize_with_algorithm(objective_function, initial_weights);

    optimized_weights
}

fn main() {
    let asset1 = Asset {
        expected_return: 0.08,
        risk: 0.12,
    };
    let asset2 = Asset {
        expected_return: 0.12,
        risk: 0.18,
    };

    let assets = vec![asset1, asset2];
    let risk_preference = 2.0;

    let optimized_weights = optimize_portfolio(&assets, risk_preference);

    println!("Optimal Portfolio Weights: {:?}", optimized_weights);
}
```

在這個示例中，我們使用高階函數來計算投資組合的預期收益和風險，並定義了一個優化函數作為閉包。通過傳遞不同的風險偏好參數，我們可以優化資產配置，以在風險和回報之間找到最佳平衡點。這是金融領域中使用高階函數進行投資組合分析和優化的一個簡單示例。實際中，會有更多複雜的模型和算法用於處理這類問題。

### 補充學習：zip方法

在Rust中，`zip` 是一個迭代器適配器方法，它用於將兩個迭代器逐個元素地配對在一起，生成一個新的迭代器，該迭代器返回一個元組，其中包含來自兩個原始迭代器的對應元素。

`zip` 方法的簽名如下：

```rust
fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>
where
    U: IntoIterator;
```

這個方法接受另一個可迭代對象 `other` 作為參數，並返回一個 `Zip` 迭代器，該迭代器產生一個元組，其中包含來自調用 `zip` 方法的迭代器和 `other` 迭代器的對應元素。

以下是一個簡單的示例，演示如何使用 `zip` 方法：

```rust
fn main() {
    let numbers = vec![1, 2, 3];
    let letters = vec!['A', 'B', 'C'];

    let zipped = numbers.iter().zip(letters.iter());

    for (num, letter) in zipped {
        println!("Number: {}, Letter: {}", num, letter);
    }
}
```

在這個示例中，我們有兩個向量 `numbers` 和 `letters`，它們分別包含整數和字符。我們使用 `zip` 方法將它們配對在一起，創建了一個新的迭代器 `zipped`。然後，我們可以使用 `for` 循環遍歷 `zipped` 迭代器，每次迭代都會返回一個包含整數和字符的元組，允許我們同時訪問兩個向量的元素。

輸出結果將會是：

```
Number: 1, Letter: A
Number: 2, Letter: B
Number: 3, Letter: C
```

`zip` 方法在處理多個迭代器並希望將它們一一匹配在一起時非常有用。這使得同時遍歷多個集合變得更加方便。

## 10.2 閉包進階

閉包是 Rust 中非常強大和靈活的概念，它們允許你將代碼塊封裝為值，以便在程序中傳遞和使用。閉包通常用於以下幾種場景：

1. **匿名函數：** 閉包允許你創建匿名函數，它們可以在需要的地方定義和使用，而不必命名為函數。
2. **捕獲環境：** 閉包可以捕獲其周圍的變量和狀態，可以在閉包內部引用外部作用域中的變量。
3. **函數作為參數：** 閉包可以作為函數的參數傳遞，從而可以將自定義行為注入到函數中。
4. **迭代器：** Rust 中的迭代器方法通常接受閉包作為參數，用於自定義元素處理邏輯。

以下是閉包的一般語法：

```rust
|參數1, 參數2| -> 返回類型 {
    // 閉包體
    // 可以使用參數1、參數2以及捕獲的外部變量
}
```

閉包參數可以根據需要包含零個或多個，並且可以指定返回類型。閉包體是代碼塊，它定義了閉包的行為。

**閉包的種類：**

Rust 中有三種主要類型的閉包，分別是：

1. **FnOnce：** 只能調用一次的閉包，通常會消耗（move）捕獲的變量。
2. **FnMut：** 可以多次調用的閉包，通常會可變地借用捕獲的變量。
3. **Fn：** 可以多次調用的閉包，通常會不可變地借用捕獲的變量。

閉包的種類由閉包的行為和捕獲的變量是否可變來決定。

**示例1：**

```rust
// 一個簡單的閉包示例，計算兩個數字的和
let add = |x, y| x + y;
let result = add(2, 3); // 調用閉包
println!("Sum: {}", result);
```

**示例2：**

```rust
// 捕獲外部變量的閉包示例
let x = 10;
let increment = |y| y + x;
let result = increment(5); // 調用閉包
println!("Result: {}", result);
```

**示例3：**

```rust
// 使用閉包作為參數的函數示例
fn apply_operation<F>(a: i32, b: i32, operation: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    operation(a, b)
}

let sum = apply_operation(2, 3, |x, y| x + y);
let product = apply_operation(2, 3, |x, y| x * y);

println!("Sum: {}", sum);
println!("Product: {}", product);
```

**金融案例1：**

假設我們有一個存儲股票價格的向量，並希望計算這些價格的平均值。我們可以使用閉包來定義自定義的計算平均值邏輯。

```rust
fn main() {
    let stock_prices = vec![50.0, 55.0, 60.0, 65.0, 70.0];

    // 使用閉包計算平均值
    let calculate_average = |prices: &[f64]| {
        let sum: f64 = prices.iter().sum();
        sum / (prices.len() as f64)
    };

    let average_price = calculate_average(&stock_prices);
    println!("Average Stock Price: {:.2}", average_price);
}
```

**金融案例2：**

假設我們有一個銀行應用程序，需要根據不同的賬戶類型計算利息。我們可以使用閉包作為參數傳遞到函數中，根據不同的賬戶類型應用不同的利息計算邏輯。

```rust
fn main() {
    struct Account {
        balance: f64,
        account_type: &'static str,
    }

    let accounts = vec![
        Account { balance: 1000.0, account_type: "Savings" },
        Account { balance: 5000.0, account_type: "Checking" },
        Account { balance: 20000.0, account_type: "Fixed Deposit" },
    ];

    // 使用閉包計算利息
    let calculate_interest = |balance: f64, account_type: &str| -> f64 {
        match account_type {
            "Savings" => balance * 0.03,
            "Checking" => balance * 0.01,
            "Fixed Deposit" => balance * 0.05,
            _ => 
```



接下來，讓我們為 `FnOnce` 和 `FnMut` 也提供一個金融案例。

**金融案例3（`FnOnce`）：**

假設我們有一個賬戶管理應用程序，其中包含一個 `Transaction` 結構體表示交易記錄。我們希望使用 `FnOnce` 閉包來處理每個交易，確保每筆交易只處理一次，以防止重複計算。

```rust
fn main() {
    struct Transaction {
        transaction_type: &'static str,
        amount: f64,
    }

    let transactions = vec![
        Transaction { transaction_type: "Deposit", amount: 100.0 },
        Transaction { transaction_type: "Withdrawal", amount: 50.0 },
        Transaction { transaction_type: "Deposit", amount: 200.0 },
    ];

    // 定義處理交易的閉包
    let process_transaction = |transaction: Transaction| {
        match transaction.transaction_type {
            "Deposit" => println!("Processed deposit of ${:.2}", transaction.amount),
            "Withdrawal" => println!("Processed withdrawal of ${:.2}", transaction.amount),
            _ => println!("Invalid transaction type"),
        }
    };

    // 使用FnOnce閉包處理交易，每筆交易只能處理一次
    for transaction in transactions {
        process_transaction(transaction);
    }
}
```

在這個示例中，我們有一個 `Transaction` 結構體表示交易記錄，並定義了一個 `process_transaction` 閉包，用於處理每筆交易。由於 `FnOnce` 閉包只能調用一次，我們在循環中傳遞每個交易記錄，並在每次迭代中使用 `process_transaction` 閉包處理交易。

**金融案例4（`FnMut`）：**

假設我們有一個股票監控應用程序，其中包含一個股票價格列表，我們需要週期性地更新股票價格。我們可以使用 `FnMut` 閉包來更新價格列表中的股票價格。

```rust
fn main() {
    let mut stock_prices = vec![50.0, 55.0, 60.0, 65.0, 70.0];

    // 定義更新股票價格的閉包
    let mut update_stock_prices = |prices: &mut Vec<f64>| {
        for price in prices.iter_mut() {
            // 模擬市場波動，更新價格
            let market_fluctuation = rand::random::<f64>() * 5.0 - 2.5;
            *price += market_fluctuation;
        }
    };

    // 使用FnMut閉包週期性地更新股票價格
    for _ in 0..5 {
        update_stock_prices(&mut stock_prices);
        println!("Updated Stock Prices: {:?}", stock_prices);
    }
}
```

在這個示例中，我們有一個股票價格列表 `stock_prices`，並定義了一個 `update_stock_prices` 閉包，該閉包使用 `FnMut` 特性以可變方式更新價格列表中的股票價格。我們在循環中多次調用 `update_stock_prices` 閉包，模擬市場波動和價格更新。

# Chapter 11 - 模塊

在 Rust 中，模塊(Modules)是一種組織和管理代碼的方式，它允許你將相關的函數、結構體、枚舉、常量等項組織成一個單獨的單元。模塊有助於代碼的組織、可維護性和封裝性，使得大型項目更容易管理和理解。

以下是關於 Rust 模塊的重要概念和解釋：

1. **模塊的定義：** 模塊可以在 Rust 代碼中通過 `mod` 關鍵字定義。一個模塊可以包含其他模塊、函數、結構體、枚舉、常量和其他項。模塊通常以一個包含相關功能的文件為單位進行組織。

   ```rust
   // 定義一個名為 `my_module` 的模塊
   mod my_module {
       // 在模塊內部可以包含其他項
       fn my_function() {
           println!("This is my function.");
       }
   }
   ```

2. **模塊的嵌套：** 你可以在一個模塊內部定義其他模塊，從而創建嵌套的模塊結構，這有助於更細粒度地組織代碼。

   ```rust
   mod outer_module {
       mod inner_module {
           // ...
       }
   }
   ```

3. **訪問項：** 模塊內部的項默認是私有的，如果要從外部訪問模塊內的項，需要使用 `pub` 關鍵字來將它們標記為公共。

   ```rust
   mod my_module {
       pub fn my_public_function() {
           println!("This is a public function.");
       }
   }
   ```

4. **使用模塊：** 在其他文件中使用模塊內的項需要使用 `use` 關鍵字導入模塊。

   ```rust
   // 導入模塊
   use my_module::my_public_function;
   
   fn main() {
       // 調用模塊內的函數
       my_public_function();
   }
   ```

5. **模塊文件結構：** Rust 鼓勵按照文件和目錄的結構來組織模塊。每個模塊通常位於一個單獨的文件中，文件的結構和模塊結構相對應。例如，一個名為 `my_module` 的模塊通常存儲在一個名為 `my_module.rs` 的文件中。

   ```plaintext
   project/
   ├── src/
   │   ├── main.rs
   │   ├── my_module.rs
   │   └── other_module.rs
   ```

6. **模塊的可見性：** 默認情況下，模塊內的項對外是不可見的，除非它們被標記為 `pub`。這有助於封裝代碼，只有公共接口對外可見，內部實現細節被隱藏。

7. **模塊的作用域：** Rust 的模塊系統具有詞法作用域。這意味著模塊和項的可見性是通過它們在代碼中的位置來確定的。一個模塊可以訪問其父模塊的項，但不能訪問其子模塊的項，除非它們被導入。

模塊是 Rust 語言中的一個關鍵概念，它有助於構建模塊化、可維護和可擴展的代碼結構。通過合理使用模塊，可以將代碼分解為更小的、可重用的單元，提高代碼的可讀性和可維護性。

### 案例：軟件工程：組織金融產品模塊

在金融領域，使用 Rust 的模塊系統可以很好地組織和管理不同類型的金融工具和計算。以下是一個示例，演示如何使用模塊來組織不同類型的金融工具和相關計算。

假設我們有幾種金融工具，例如股票(Stock)、債券(Bond)和期權(Option)，以及一些計算函數，如計算收益、風險等。我們可以使用模塊來組織這些功能。

首先，創建一個 `financial_instruments` 模塊，其中包含不同類型的金融工具定義：

```rust
// financial_instruments.rs

pub mod stock {
    pub struct Stock {
        // ...
    }

    impl Stock {
        pub fn new() -> Self {
            // 初始化股票
            Stock {
                // ...
            }
        }

        // 其他股票相關方te x t法
    }
}

pub mod bond {
    pub struct Bond {
        // ...
    }

    impl Bond {
        pub fn new() -> Self {
            // 初始化債券
            Bond {
                // ...
            }
        }

        // 其他債券相關方法
    }
}

pub mod option {
    pub struct Option {
        // ...
    }

    impl Option {
        pub fn new() -> Self {
            // 初始化期權
            Option {
                // ...
            }
        }

        // 其他期權相關方法
    }
}
```

接下來，創建一個 `calculations` 模塊，其中包含與金融工具相關的計算函數：

```rust
// calculations.rs

use crate::financial_instruments::{stock::Stock, bond::Bond, option::Option};

pub fn calculate_stock_return(stock: &Stock) -> f64 {
    // 計算股票的收益
    // ...
}

pub fn calculate_bond_return(bond: &Bond) -> f64 {
    // 計算債券的收益
    // ...
}

pub fn calculate_option_risk(option: &Option) -> f64 {
    // 計算期權的風險
    // ...
}
```

最後，在主程序中，你可以導入模塊並使用定義的金融工具和計算函數：

```rust
// main.rs

mod financial_instruments;
mod calculations;

use financial_instruments::{stock::Stock, bond::Bond, option::Option};
use calculations::{calculate_stock_return, calculate_bond_return, calculate_option_risk};

fn main() {
    let stock = Stock::new();
    let bond = Bond::new();
    let option = Option::new();

    let stock_return = calculate_stock_return(&stock);
    let bond_return = calculate_bond_return(&bond);
    let option_risk = calculate_option_risk(&option);

    println!("Stock Return: {}", stock_return);
    println!("Bond Return: {}", bond_return);
    println!("Option Risk: {}", option_risk);
}
```

通過這種方式，你可以將不同類型的金融工具和相關計算函數封裝在不同的模塊中，使代碼更有結構和組織性。這有助於提高代碼的可維護性，使得在金融領域開發複雜應用程序更容易。

# Chapter 12 - Cargo 的進階使用

在金融領域，使用 Cargo 的進階功能可以幫助你更好地組織和管理金融軟件項目。以下是一些關於金融領域中使用 Cargo 進階功能的詳細敘述：

## 12.1 自定義構建腳本

金融領域的項目通常需要處理大量數據和計算。自定義構建腳本可以用於數據預處理、模型訓練、風險估算等任務。你可以使用構建腳本自動下載金融數據、執行復雜的數學計算或生成報告，以便項目構建流程更加自動化。

### 案例： 自動下載金融數據並執行計算任務

以下是一個示例，演示瞭如何在金融領域的 Rust 項目中使用自定義構建腳本來自動下載金融數據並執行計算任務。假設你正在開發一個金融分析工具，需要從特定數據源獲取歷史股票價格並計算其收益率。

1. 創建一個新的 Rust 項目並定義依賴關係。

首先，創建一個新的 Rust 項目並在 `Cargo.toml` 文件中定義所需的依賴關係，包括用於 HTTP 請求和數據處理的庫，例如 `reqwest` 和 `serde`。

```toml
[package]
name = "financial_analysis"
version = "0.1.0"
edition = "2018"

[dependencies]
reqwest = "0.11"
serde = { version = "1", features = ["derive"] }
```

2. 創建自定義構建腳本。

在項目根目錄下創建一個名為 `build.rs` 的自定義構建腳本文件。這個腳本將在項目構建前執行。

```rust
// build.rs

fn main() {
    // 使用 reqwest 庫從數據源下載歷史股票價格數據
    // 這裡只是示例，實際上需要指定正確的數據源和 URL
    let data_source_url = "https://example.com/financial_data.csv";
    let response = reqwest::blocking::get(data_source_url);

    match response {
        Ok(response) => {
            if response.status().is_success() {
                // 下載成功，將數據保存到文件或進行進一步處理
                println!("Downloaded financial data successfully.");
                // 在此處添加數據處理和計算邏輯
            } else {
                println!("Failed to download financial data.");
            }
        }
        Err(err) => {
            println!("Error downloading financial data: {:?}", err);
        }
    }
}
```

3. 編寫數據處理和計算邏輯。

在構建腳本中，我們使用 `reqwest` 庫從數據源下載了歷史股票價格數據，並且在成功下載後，可以在構建腳本中執行進一步的數據處理和計算邏輯。這些邏輯可以包括解析數據、計算收益率、生成報告等。

4. 在項目中使用數據。

在項目的其他部分(例如，主程序或庫模塊)中，你可以使用已經下載並處理過的數據來執行金融分析和計算任務。

這個示例演示瞭如何使用自定義構建腳本來自動下載金融數據並執行計算任務，從而實現項目構建流程的自動化。這對於金融領域的項目非常有用，因為通常需要處理大量數據和複雜的計算。請注意，實際數據源和計算邏輯可能會根據項目的需求有所不同。

#### 注意：自動構建腳本運行的前置條件

對於 Cargo 構建過程，自定義構建腳本 `build.rs` 不會在 `cargo build` 時自動執行。它主要用於在構建項目之前執行一些預處理或特定任務。

要運行自定義構建腳本，先要切換到nightly版本，然後要打開`-Z unstable-options`選項，然後才可以使用 `cargo build` 命令的 `--build-plan` 選項，該選項會顯示構建計劃，包括構建腳本的執行。例如：

```bash
cargo build --build-plan
```

這將顯示構建計劃，包括在構建過程中執行的步驟，其中包括執行 `build.rs` 腳本。

如果需要在每次構建項目時都執行自定義構建腳本，你可以考慮將其添加到構建的前置步驟，例如在構建腳本中調用 `cargo build` 命令前執行你的自定義任務。這可以通過在 `build.rs` 中使用 Rust 的 `std::process::Command` 來實現。

```rust
// build.rs

fn main() {
    // 在執行 cargo build 之前執行自定義任務
    let status = std::process::Command::new("cargo")
        .arg("build")
        .status()
        .expect("Failed to run cargo build");

    if status.success() {
        println!("Custom build script completed successfully.");
    } else {
        println!("Custom build script failed.");
    }
}
```

這樣，在運行 `cargo build` 時，自定義構建腳本會在構建之前執行你的自定義任務，並且可以根據任務的成功或失敗狀態採取進一步的操作。

## 12.2 自定義 Cargo 子命令

在金融領域，你可能需要執行特定的分析或風險評估，這些任務可以作為自定義 Cargo 子命令實現。你可以創建 Cargo 子命令來執行統計分析、蒙特卡洛模擬、金融模型評估等任務，以便更方便地在不同項目中重複使用這些功能。

### 案例： 蒙特卡洛模擬

以下是一個示例，演示如何在金融領域的 Rust 項目中創建自定義 Cargo 子命令來執行蒙特卡洛模擬，以評估投資組合的風險。

1. 創建一個新的 Rust 項目並定義依賴關係。

首先，創建一個新的 Rust 項目並在 `Cargo.toml` 文件中定義所需的依賴關係。在這個示例中，我們將使用 `rand` 庫來生成隨機數，以進行蒙特卡洛模擬。

```toml
[package]
name = "portfolio_simulation"
version = "0.1.0"
edition = "2018"

[dependencies]
rand = "0.8"
```

2. 創建自定義 Cargo 子命令。

在項目根目錄下創建一個名為 `src/bin` 的目錄，並在其中創建一個 Rust 文件，以定義自定義 Cargo 子命令。在本例中，我們將創建一個名為 `monte_carlo.rs` 的文件。

```rust
// src/bin/monte_carlo.rs
use rand::Rng;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        eprintln!("Usage: cargo run --bin monte_carlo <num_simulations>");
        std::process::exit(1);
    }

    let num_simulations: usize = args[1].parse().expect("Invalid number of simulations");

    let portfolio_value = 1000000.0; // 初始投資組合價值
    let expected_return = 0.08; // 年化預期收益率
    let risk = 0.15; // 年化風險(標準差)

    let mut rng = rand::thread_rng();
    let mut total_returns = Vec::new();

    for _ in 0..num_simulations {
        // 使用蒙特卡洛模擬生成投資組合的未來收益率
        let random_return = rng.gen_range(-risk, risk);
        let portfolio_return = expected_return + random_return;
        let new_portfolio_value = portfolio_value * (1.0 + portfolio_return);
        total_returns.push(new_portfolio_value);
    }

    // 在這裡執行風險評估、生成報告或其他分析任務
    let average_return: f64 = total_returns.iter().sum::<f64>() / num_simulations as f64;
    println!("Average Portfolio Return: {:.2}%", (average_return - 1.0) * 100.0);
}
```

3. 註冊自定義子命令。

要在 Cargo 項目中註冊自定義子命令，需要在項目的 `Cargo.toml` 中添加以下部分：

```toml
[[bin]]
name = "monte_carlo"
path = "src/bin/monte_carlo.rs"
```

這將告訴 Cargo 關聯 `monte_carlo.rs` 文件作為一個可執行子命令。

4. 運行自定義子命令。

現在，我們可以使用以下命令來運行自定義 Cargo 子命令並執行蒙特卡洛模擬：

```bash
cargo run --bin monte_carlo <num_simulations>
```

其中 `<num_simulations>` 是模擬的次數。子命令將模擬投資組合的多次收益，並計算平均收益率。在實際應用中，我們可以在模擬中添加更多參數和複雜的金融模型。

這個示例演示瞭如何創建自定義 Cargo 子命令來執行金融領域的蒙特卡洛模擬任務。這使我們可以更方便地在不同項目中重複使用這些分析功能，以評估投資組合的風險和收益。

### 補充學習：為cargo的子命令創造shell別名

要在 Linux 上為 `cargo run --bin monte_carlo <num_simulations>` 命令創建一個簡單的別名 `monte_carlo`，可以使用 shell 的別名機制，具體取決於使用的 shell(例如，bash、zsh、fish 等)。

**以下是使用 bash shell 的方式：**

1. 打開我們的終端。

2. 使用文本編輯器(如 `nano` 或 `vim`)打開我們的 shell 配置文件，通常是 `~/.bashrc` 或 `~/.bash_aliases`。例如：

   ```bash
   nano ~/.bashrc
   ```

3. 在配置文件的末尾添加以下行：

   ```bash
   alias monte_carlo='cargo run --bin monte_carlo'
   ```

   這將創建名為 `monte_carlo` 的別名，它會自動展開為 `cargo run --bin monte_carlo` 命令。

4. 保存並關閉配置文件。

5. 在終端中運行以下命令，使配置文件生效：

   ```bash
   source ~/.bashrc
   ```

   如果我們使用的是 `~/.bash_aliases` 或其他配置文件，請相應地使用 `source` 命令。

6. 現在，我們可以在終端中使用 `monte_carlo` 命令，後面加上模擬的次數，例如：

   ```bash
   monte_carlo 1000
   ```

   這將執行我們的 Cargo 子命令並進行蒙特卡洛模擬。

請注意，這個別名僅在當前 shell 會話中有效。如果我們希望在每次啟動終端時都使用這個別名，可以將它添加到我們的 shell 配置文件中。

## 12.3 工作空間

金融軟件通常由多個相關但獨立的模塊組成，如風險分析、投資組合優化、數據可視化等。使用 Cargo 的工作空間功能，可以將這些模塊組織到一個集成的項目中。工作空間允許你在一個統一的環境中管理和共享代碼，使得金融應用程序的開發更加高效。

確實，Cargo的工作空間功能可以使Rust項目的組織和管理更加高效。特別是在開發金融軟件這樣需要多個獨立但相互關聯的模塊的情況下，這個功能非常有用。

假設我們正在開發一個名為"FinancialApp"的金融應用程序，這個程序包含三個主要模塊：風險分析、投資組合優化和數據可視化。每個模塊都可以作為一個獨立的庫或者二進製程序進行開發和測試。

1. 首先，我們創建一個新的Cargo工作空間，命名為"FinancialApp"。

```bash
$ cargo new --workspace FinancialApp
```

1. 接著，我們為每個模塊創建一個新的庫或二進制項目。首先創建"risk_analysis"庫：

```bash
$ cargo new --lib risk_analysis
```

然後將"risk_analysis"庫加入到工作空間中：

```bash
$ cargo workspace add risk_analysis
```

用同樣的方式創建"portfolio_optimization"和"data_visualization"兩個庫，並將它們添加到工作空間中。

3. 現在我們可以在工作空間中開發和測試每個模塊。例如，我們可以進入"risk_analysis"目錄並運行測試：

```bash
$ cd risk_analysis  
$ cargo test
```

1. 當所有的模塊都開發完成後，我們可以將它們整合到一起，形成一個完整的金融應用程序。在工作空間根目錄下創建一個新的二進制項目：

```bash
$ cargo new --bin financial_app
```

然後在"financial_app"的Cargo.toml文件中，添加對"risk_analysis"、"portfolio_optimization"和"data_visualization"的依賴：

```toml
[dependencies]  
risk_analysis = { path = "../risk_analysis" }  
portfolio_optimization = { path = "../portfolio_optimization" }  
data_visualization = { path = "../data_visualization" }
```

現在，我們就可以在"financial_app"的主函數中調用這些模塊的函數和服務，形成一個完整的金融應用程序。

5. 最後，我們可以編譯和運行這個完整的金融應用程序：

```bash
$ cd ..  
$ cargo run --bin financial_app
```

這就是使用Cargo工作空間功能組織和管理金融應用程序的一個簡單案例。通過使用工作空間，我們可以將各個模塊整合到一個統一的項目中，共享代碼，提高開發效率。

# Chapter 13 - 屬性(Attributes)

屬性(Attributes)在 Rust 中是一種特殊的語法，它們可以提供關於代碼塊、函數、結構體、枚舉等元素的附加信息。Rust 編譯器會使用這些信息來更好地理解、處理代碼。

屬性有兩種主要形式：**內部屬性**和外部屬性。內部屬性(Inner Attributes)用於設置 crate 級別的元數據，例如 crate 名稱、版本和類型等。而外部屬性(Outer Attributes)則應用於模塊、函數、結構體等，用於設置編譯條件、禁用 lint、啟用編譯器特性等。

之前我們已經反覆接觸過了屬性應用的一個基本例子：

```rust
#[derive(Debug)]  
struct Person {  
    name: String,  
    age: u32,  
}
```

在這個例子中，`#[derive(Debug)]` 是一個屬性，它告訴 Rust 編譯器自動為 `Person` 結構體實現 `Debug` trait。這樣我們就可以打印出該結構體的調試信息。

下面是幾個常用屬性的具體說明：

## 13.1 條件編譯

`#[cfg(...)]`。這個屬性可以根據特定的編譯條件來決定是否編譯某段代碼。

### 13.1.1 在特定操作系統執行不同代碼

你可能想在只有在特定操作系統上才編譯某段代碼：

```rust
#[cfg(target_os = "linux")]  //編譯時會檢查代碼中的 #[cfg(target_os = "linux")] 屬性
fn on_linux() {  
    println!("This code is compiled on Linux only.");  
}  
  
#[cfg(target_os = "windows")]  //編譯時會檢查代碼中的 #[cfg(target_os = "windows")] 屬性
fn on_windows() {  
    println!("This code is compiled on Windows only.");  
}  
  
fn main() {  
    on_linux();  
    on_windows();  
}
```

在上面的示例中，`on_linux`函數只在目標操作系統是Linux時被編譯，而`on_windows`函數只在目標操作系統是Windows時被編譯。你可以根據需要在`cfg`屬性中使用不同的條件。

### 13.1.2 條件編譯測試

`#[cfg(test)]` 通常屬性用於條件編譯，將測試代碼限定在測試環境(`cargo test`)中。

當你的 Rust 源代碼中包含 `#[cfg(test)]` 時，這些代碼將僅在運行測試時編譯和執行。**在正常構建時，這些代碼會被排除在外。**所以一般用於編寫測試相關的輔助函數或測試模擬。

**示例：**

```
rustCopy code#[cfg(test)]
mod tests {
    // 此模塊中的代碼僅在測試時編譯和執行
    #[test]
    fn test_addition() {
        assert_eq!(2 + 2, 4);
    }
}
```

## 13.2 禁用 lint

`#[allow(...)]` 或 `#[deny(...)]`。這些屬性可以禁用或啟用特定的編譯器警告。例如，你可能會允許一個被認為是不安全的代碼模式，因為你的團隊和你本人都確定你的代碼是安全的。

### 13.2.1 允許可變引用轉變為不可變

```rust
#[allow(clippy::mut_from_ref)]  
fn main() {  
    let x = &mut 42;  
    let y = &*x;  
    **y += 1;  
    println!("{}", x); // 輸出 43  
}
```

在這個示例中，`#[allow(clippy::mut_from_ref)]`屬性允許使用`&mut`引用轉換為`&`引用的代碼模式。如果沒有該屬性，編譯器會發出警告，因為這種代碼模式可能會導致意外的行為。但是在這個特定的例子中，你知道代碼是安全的，因為你沒有在任何地方對`y`進行再次的借用。

### 13.2.2 強制禁止未使用的`self`參數

另一方面，`#[deny(...)]`屬性可以用於禁止特定的警告。這可以用於在團隊中強制執行一些編碼規則或安全性標準。例如：

```rust
#[deny(clippy::unused_self)]  
fn main() {  
    struct Foo;  
    impl Foo {  
        fn bar(&self) {}  
    }  
    Foo.bar(); // 這將引發一個編譯錯誤，因為`self`參數未使用  
}
```

在這個示例中，`#[deny(clippy::unused_self)]`屬性禁止了未使用的`self`參數的警告。這意味著，如果團隊成員在他們的代碼中沒有正確地使用`self`參數，他們將收到一個編譯錯誤，而不是一個警告。這有助於確保團隊遵循一致的編碼實踐，並減少潛在的錯誤或安全漏洞。

### 13.2.3 其他常見 可用屬性

下面是一些其他常見的`allow`和`deny`選項：

1. `warnings`: 允許或禁止所有警告。
   示例：`#[allow(warnings)]` 或 `#[deny(warnings)]`
2. `unused_variables`: 允許或禁止未使用變量的警告。
   示例：`#[allow(unused_variables)]` 或 `#[deny(unused_variables)]`
3. `unused_mut`: 允許或禁止未使用可變變量的警告。
   示例：`#[allow(unused_mut)]` 或 `#[deny(unused_mut)]`
4. `unused_assignments`: 允許或禁止未使用賦值的警告。
   示例：`#[allow(unused_assignments)]` 或 `#[deny(unused_assignments)]`
5. `dead_code`: 允許或禁止死代碼的警告。
   示例：`#[allow(dead_code)]` 或 `#[deny(dead_code)]`
6. `unreachable_patterns`: 允許或禁止不可達模式的警告。
   示例：`#[allow(unreachable_patterns)]` 或 `#[deny(unreachable_patterns)]`
7. `clippy::all`: 允許或禁止所有Clippy lints的警告。
   示例：`#[allow(clippy::all)]` 或 `#[deny(clippy::all)]`
8. `clippy::pedantic`: 允許或禁止所有Clippy lints的警告，包括一些可能誤報的情況。
   示例：`#[allow(clippy::pedantic)]` 或 `#[deny(clippy::pedantic)]`

這些選項只是其中的一部分，Rust編譯器和Clippy工具還提供了其他許多lint選項。你可以根據需要選擇適當的選項來配置編譯器的警告處理行為。

### 補充學習：不可達模式

'unreachable'宏是用來指示編譯器某段代碼是不可達的。

當編譯器無法確定某段代碼是否不可達時，這很有用。例如，在模式匹配語句中，如果某個分支的條件永遠不會滿足，編譯器就可能標記這個分支的代碼為'unreachable'。

如果這段被標記為'unreachable'的代碼實際上能被執行到，程序會立即panic並終止。此外，Rust還有一個對應的不安全函數'unreachable_unchecked'，即如果這段代碼被執行到，會導致未定義行為。

假設我們正在編寫一個程序來處理股票交易。在這個程序中，我們可能會遇到這樣的情況：

```rust
fn process_order(order: &Order) -> Result<(), Error> {  
    match order.get_type() {  
        OrderType::Buy => {  
            // 執行購買邏輯...  
            Ok(())  
        },  
        OrderType::Sell => {  
            // 執行賣出邏輯...  
            Ok(())  
        },  
        _ => unreachable!("Invalid order type"),  
    }  
}
```

在這個例子中，我們假設訂單類型只能是“買入”或“賣出”。如果有其他的訂單類型，我們就用 `unreachable!()` 宏來表示這種情況是不應該發生的。如果由於某種原因，我們的程序接收到了一個我們不知道的訂單類型，程序就會立即 panic，這樣我們就可以立即發現問題，而不是讓程序繼續執行並可能導致錯誤。

## 13.3 啟用編譯器的特性

在 Rust 中，`#[feature(...)]` 屬性用於啟用編譯器的特定特性。以下是一個示例案例，展示了使用 `#[feature(...)]` 屬性啟用全局導入(glob import)和宏(macros)的特性：

```rust
#![feature(glob_import, proc_macro_hygiene)]  
  
use std::collections::*; // 全局導入 std::collections 模塊中的所有內容  
  
#[macro_use]  
extern crate my_macros; // 啟用宏特性，並導入外部宏庫 my_macros  
  
fn main() {  
    let mut map = HashMap::new(); // 使用全局導入的 HashMap 類型  
    map.insert("key", "value");  
    println!("{:?}", map);  
  
    my_macro!("Hello, world!"); // 使用外部宏庫 my_macros 中的宏 my_macro!  
}
```

在這個示例中，`#![feature(glob_import, proc_macro_hygiene)]` 屬性啟用了全局導入和宏的特性。接下來，`use std::collections::*;` 語句使用全局導入將 `std::collections` 模塊中的**所有內容**導入到當前作用域。然後，`#[macro_use] extern crate my_macros;` 語句啟用了宏特性，並導入了名為 `my_macros` 的**外部宏庫**。

在 `main` 函數中，我們創建了一個 `HashMap` 實例，並使用了全局導入的 `HashMap` 類型。接下來，我們調用了 `my_macro!("Hello, world!");` 宏，該宏在編譯時會被擴展為相應的代碼。

注意，使用 `#[feature(...)]` 屬性啟用特性是編譯器相關的，**不同的 Rust 編譯器版本可能支持不同的特性集合**。在實際開發中，應該根據所使用的 Rust 版本和編譯器特性來選擇適當的特性。

## 13.4 鏈接到一個非 Rust 語言的庫

`#[link(...)]` 是 Rust 中用於告訴編譯器如何鏈接到外部庫的屬性。它通常用於與非 Rust 語言編寫的庫進行交互。 `#[link]` 屬性通常**不需要顯式聲明**，而是通過在 Cargo.toml 文件中的 `[dependencies]` 部分指定外部庫的名稱來完成鏈接。

假設你有一個C語言庫，其中包含一個名為 `my_c_library` 的函數，你想在Rust中使用這個函數。

1. 首先，確保你已經安裝了Rust，並且你的Rust項目已經初始化。

2. 創建一個新的Rust源代碼文件，例如 `main.rs`。

3. 在Rust源代碼文件中，使用 `extern` 關鍵字聲明外部C函數的原型，並使用 `#[link]` 屬性指定要鏈接的庫的名稱。示例如下：

```rust
extern {
    // 聲明外部C函數的原型
    fn my_c_library_function(arg1: i32, arg2: i32) -> i32;
}

fn main() {
    let result;
    unsafe {
        // 調用外部C函數
        result = my_c_library_function(42, 23);
    }
    println!("Result from C function: {}", result);
}
```

4. 編譯你的Rust代碼，同時鏈接到C語言庫，可以使用 `rustc` 命令，但更常見的是使用 `Cargo` 構建工具。首先，確保你的項目的 `Cargo.toml` 文件中包含以下內容：

```toml
[dependencies]
```

然後，運行以下命令：

```bash
cargo build
```

Cargo 將會自動查找系統中是否存在 `my_c_library`，如果找到的話，它將會鏈接到該庫並編譯你的Rust代碼。

## 13.5 標記函數作為單元測試

`#[test]`。這個屬性可以標記一個函數作為單元測試函數，這樣你就可以使用 Rust 的測試框架來運行這個測試。下面是一個簡單的例子：

```rust
#[test]  
fn test_addition() {  
    assert_eq!(2 + 2, 4);  
}
```

在這個例子中，`#[test]` 屬性被應用於 `test_addition` 函數，表示它是一個單元測試。函數體中的 `assert_eq!` 宏用於斷言兩個表達式是否相等。在這種情況下，它檢查 `2 + 2` 是否等於 `4`。如果這個表達式返回 `true`，那麼測試就會通過。如果返回 `false`，測試就會失敗，並輸出相應的錯誤信息。

你可以在測試函數中使用其他宏和函數來編寫更復雜的測試邏輯。例如，你可以使用 `assert!` 宏來斷言一個表達式是否為真，或者使用 `assert_ne!` 宏來斷言兩個表達式是否不相等。

**注意**，\#[test]和\#[cfg(test)]是有區別的：

| 特性             | `#[test]`                                     | `#[cfg(test)]`                            |
| ---------------- | --------------------------------------------- | ----------------------------------------- |
| 用途             | 用於標記單元測試函數                          | 用於條件編譯測試相關的代碼                |
| 所屬上下文       | 函數級別的屬性                                | 代碼塊級別的屬性                          |
| 執行時機         | 在測試運行時執行                              | 僅在運行測試時編譯和執行                  |
| 典型用法         | 編寫和運行測試用例                            | 包含測試輔助函數或模擬的代碼              |
| 示例             | ```rust fn test_function() {...}```           | ```rust #[cfg(test)] mod tests { ... }``` |
| 測試運行方式     | 在測試模塊中執行，通常由測試運行器管理        | 在測試環境中運行，正常構建時排除          |
| 是否需要斷言宏   | 通常需要使用斷言宏(例如 `assert_eq!`)進行測試 | 不一定需要，可以用於編寫測試輔助函數      |
| 用於組織測試代碼 | 直接包含在測試函數內部                        | 通常包含在模塊中                          |

但是這兩個屬性通常一起使用，`#[cfg(test)]` 用於包裝測試輔助代碼和模擬，而 `#[test]` 用於標記要運行的測試用例函數。在19章我們還會詳細敘述測試的應用。

## 13.6 標記函數作為基準測試的某個部分

使用 Rust 編寫基準測試時，可以使用 `#[bench]` 屬性來標記一個函數作為基準測試函數。下面是一個簡單的例子，展示瞭如何使用 `#[bench]` 屬性和 Rust 的基準測試框架來測試一個函數的性能。

```rust
use test::Bencher;  
  
#[bench]  
fn bench_addition(b: &mut Bencher) {  
    b.iter(|| {  
        let sum = 2 + 2;  
        assert_eq!(sum, 4);  
    });  
}
```

在這個例子中，我們定義了一個名為 `bench_addition` 的函數，並使用 `#[bench]` 屬性進行標記。函數接受一個 `&mut Bencher` 類型的參數 `b`，它提供了用於運行基準測試的方法。

在函數體中，我們使用 `b.iter` 方法來指定要重複運行的測試代碼塊。這裡使用了一個閉包 `|| { ... }` 來定義要運行的代碼。在這個例子中，我們簡單地將 `2 + 2` 的結果存儲在 `sum` 變量中，並使用 `assert_eq!` 宏來斷言 `sum` 是否等於 `4`。

要運行這個基準測試，可以在終端中使用 `cargo bench` 命令。Rust 的基準測試框架會自動識別並使用 `#[bench]` 屬性標記的函數，並運行它們以測量性能。

# Chapter 14 - 泛型進階(Advanced Generic Type Usage)


泛型是一種編程概念，用於泛化類型和函數功能，以擴展它們的適用範圍。使用泛型可以大大減少代碼的重複，但使用泛型的語法需要謹慎。換句話說，使用泛型意味著你需要明確指定在具體情況下，哪種類型是合法的。

簡單來說，泛型就是定義可以適用於不同具體類型的**代碼模板**。在使用時，**我們會為這些泛型類型參數提供具體的類型，就像傳遞參數一樣**。

在Rust中，我們使用尖括號和大寫字母的名稱(例如：`<Aaa, Bbb, ...>`)來指定泛型類型參數。通常情況下，我們使用`<T>`來表示一個泛型類型參數。在Rust中，泛型不僅僅表示類型，還表示可以接受一個或多個泛型類型參數`<T>`的任何內容。

讓我們編寫一個輕鬆的示例，以更詳細地說明Rust中泛型的概念：

```rust
// 定義一個具體類型 `Fruit`。
struct Fruit {
    name: String,
}

// 在定義類型 `Basket` 時，第一次使用類型 `Fruit` 之前沒有寫 `<Fruit>`。
// 因此，`Basket` 是個具體類型，`Fruit` 取上面的定義。
struct Basket(Fruit);
//            ^ 這裡是 `Basket` 對類型 `Fruit` 的第一次使用。

// 此處 `<T>` 在第一次使用 `T` 之前出現，所以 `BasketGen` 是一個泛型類型。
// 因為 `T` 是泛型的，所以它可以是任何類型，包括在上面定義的具體類型 `Fruit`。
struct BasketGen<T>(T);

fn main() {
    // `Basket` 是具體類型，並且顯式地使用類型 `Fruit`。
    let apple = Fruit {
        name: String::from("Apple"),
    };
    let _basket = Basket(apple);

    // 創建一個 `BasketGen<String>` 類型的變量 `_str_basket`，並令其值為 `BasketGen("Banana")`
    // 這裡的 `BasketGen` 的類型參數是顯式指定的。
    let _str_basket: BasketGen<String> = BasketGen(String::from("Banana"));

    // `BasketGen` 的類型參數也可以隱式地指定。
    let _fruit_basket = BasketGen(Fruit {
        name: String::from("Orange"),
    }); // 使用在上面定義的 `Fruit`。
    let _weight_basket = BasketGen(42); // 使用 `i32` 類型。
}
```

在這個示例中，我們定義了一個具體類型 `Fruit`，然後使用它在 `Basket` 結構體中創建了一個具體類型的實例。接下來，我們定義了一個泛型結構體 `BasketGen<T>`，它可以存儲任何類型的數據。我們創建了幾個不同類型的 `BasketGen` 實例，有些是顯式指定類型參數的，而有些則是隱式指定的。

這個示例演示了Rust中泛型的工作原理，以及如何在創建泛型結構體實例時明確或隱含地指定類型參數。泛型使得代碼更加通用和可複用，允許我們創建能夠處理不同類型的數據的通用數據結構。

## 14.1 泛型實現

泛型實現是Rust中一種非常強大的特性，它允許我們編寫通用的代碼，可以處理不同類型的數據，同時保持類型安全性。下面詳細解釋一下如何在Rust中使用泛型實現。

現在，讓我們瞭解如何在結構體、枚舉和trait中實現泛型。

### 14.1.1 在結構體中實現泛型

我們可以在結構體中使用泛型類型參數，併為該結構體實現方法。例如：

```rust
struct Pair<T> {
    first: T,
    second: T,
}

impl<T> Pair<T> {
    fn new(first: T, second: T) -> Self {
        Pair { first, second }
    }

    fn get_first(&self) -> &T {
        &self.first
    }

    fn get_second(&self) -> &T {
        &self.second
    }
}

fn main() {
    let pair_of_integers = Pair::new(1, 2);
    println!("First: {}", pair_of_integers.get_first());
    println!("Second: {}", pair_of_integers.get_second());

    let pair_of_strings = Pair::new("hello", "world");
    println!("First: {}", pair_of_strings.get_first());
    println!("Second: {}", pair_of_strings.get_second());
}
```

在上面的示例中，我們為泛型結構體`Pair<T>`實現了`new`方法和獲取`first`和`second`值的方法。

### 14.1.2 在枚舉中實現泛型

我們還可以在枚舉中使用泛型類型參數。例如經典的Result枚舉類型：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn main() {
    let success: Result<i32, &str> = Result::Ok(42);
    let failure: Result<i32, &str> = Result::Err("Something went wrong");

    match success {
        Result::Ok(value) => println!("Success: {}", value),
        Result::Err(err) => println!("Error: {}", err),
    }

    match failure {
        Result::Ok(value) => println!("Success: {}", value),
        Result::Err(err) => println!("Error: {}", err),
    }
}
```

在上面的示例中，我們定義了一個泛型枚舉`Result<T, E>`，它可以表示成功(`Ok`)或失敗(`Err`)的結果。在`main`函數中，我們創建了兩個不同類型的`Result`實例。

### 14.1.3 在特性中實現泛型

在trait中定義泛型方法，然後**為不同類型實現該trait**。例如：

```rust
trait Summable<T> {
    fn sum(&self) -> T;
}

impl Summable<i32> for Vec<i32> {
    fn sum(&self) -> i32 {
        self.iter().sum()
    }
}

impl Summable<f64> for Vec<f64> {
    fn sum(&self) -> f64 {
        self.iter().sum()
    }
}

fn main() {
    let numbers_int = vec![1, 2, 3, 4, 5];
    let numbers_float = vec![1.1, 2.2, 3.3, 4.4, 5.5];

    println!("Sum of integers: {}", numbers_int.sum());
    println!("Sum of floats: {}", numbers_float.sum());
}
```



## 14.2 多重約束 (Multiple-Trait Bounds)

多重約束 (Multiple Trait Bounds) 是 Rust 中一種強大的特性，允許在泛型參數上指定多個 trait 約束。這意味著泛型類型必須同時實現多個 trait 才能滿足這個泛型參數的約束。多重約束通常在需要對泛型參數進行更精確的約束時非常有用，因為它們允許你指定泛型參數必須具備多個特定的行為。

以下是如何使用多重約束的示例以及一些詳細解釋：

```rust
use std::fmt::{Debug, Display};

fn compare_prints<T: Debug + Display>(t: &T) {
    println!("Debug: `{:?}`", t);
    println!("Display: `{}`", t);
}

fn compare_types<T: Debug, U: Debug>(t: &T, u: &U) {
    println!("t: `{:?}`", t);
    println!("u: `{:?}`", u);
}

fn main() {
    let string = "words";
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&string);
    // compare_prints(&array);   //因為&array並未實現std::fmt::Display，所以只要這行被激活就會編譯失敗。
    
    compare_types(&array, &vec);
}
```

   因為`&array`並未實現`Display` trait，所以只要  `compare_prints(&array);`  被激活，就會編譯失敗。

## 14.3 where語句

在 Rust 中，`where` 語句是一種用於在 trait bounds 中提供更靈活和清晰的約束條件的方式。

下面是一個示例，演示瞭如何使用 `where` 語句來提高代碼的可讀性：

```rust
use std::fmt::{Debug, Display};

// 定義一個泛型函數，接受兩個泛型參數 T 和 U，
// 並要求 T 必須實現 Display trait，U 必須實現 Debug trait。
fn display_and_debug<T, U>(t: T, u: U)
where
    T: Display,
    U: Debug,
{
    println!("Display: {}", t);
    println!("Debug: {:?}", u);
}

fn main() {
    let number = 42;
    let text = "hello";

    display_and_debug(number, text);
}
```

在這個示例中，我們定義了一個 `display_and_debug` 函數，它接受兩個泛型參數 `T` 和 `U`。然後，我們使用 `where` 語句來指定約束條件：`T: Display` 表示 `T` 必須實現 `Display` trait，`U: Debug` 表示 `U` 必須實現 `Debug` trait。

## 14.4 關聯項 (associated items)

在 Rust 中，"關聯項"(associated items)是與特定 trait 或類型相關聯的項，這些項可以包括與 trait 相關的關聯類型(associated types)、關聯常量(associated constants)和關聯函數(associated functions)。關聯項是 trait 和類型的一部分，它們允許在 trait 或類型的上下文中定義與之相關的數據和函數。

以下是關聯項的詳細解釋：

1. **關聯類型(Associated Types)**：

   當我們定義一個 trait 並使用關聯類型時，我們希望在 trait 的實現中可以具體指定這些關聯類型。關聯類型允許我們在 trait 中引入與具體類型有關的佔位符，**然後在實現時提供具體類型**。

   ```rust
   trait Iterator {
       type Item; // 定義關聯類型
       fn next(&mut self) -> Option<Self::Item>; // 使用關聯類型
   }
   
   // 實現 Iterator trait，並指定關聯類型 Item 為 i32
   impl Iterator for Counter {
       type Item = i32;
       fn next(&mut self) -> Option<Self::Item> {
           // 實現方法
       }
   }
   ```

2. **關聯常量(Associated Constants)**：

   - 關聯常量是與 trait 相關聯的常量值。
   - 與關聯類型不同，關聯常量是具體的值，而不是類型。
   - 關聯常量使用 `const` 關鍵字來聲明，並在實現 trait 時提供具體值。

   ```rust
   trait MathConstants {
       const PI: f64; // 定義關聯常量
   }
   
   // 實現 MathConstants trait，並提供 PI 的具體值
   impl MathConstants for Circle {
       const PI: f64 = 3.14159265359;
   }
   ```

3. **關聯函數(Associated Functions)**：

   - 關聯函數是與類型關聯的函數，通常用於創建該類型的實例。
   - 關聯函數不依賴於具體的實例，因此它們可以在類型級別調用，而不需要實例。
   - 關聯函數使用 `fn` 關鍵字來定義。

   ```rust
   struct Point {
       x: i32,
       y: i32,
   }
   
   impl Point {
       // 定義關聯函數，用於創建 Point 的新實例
       fn new(x: i32, y: i32) -> Self {
           Point { x, y }
       }
   }
   
   fn main() {
       let point = Point::new(10, 20); // 調用關聯函數創建實例
   }
   ```

關聯項是 Rust 中非常強大和靈活的概念，它們使得 trait 和類型能夠定義更抽象和通用的接口，並且可以根據具體類型的需要進行定製化。這些概念對於創建可複用的代碼和實現通用數據結構非常有用。

# Chapter 15 - 作用域規則和生命週期

Rust的作用域規則和生命週期是該語言中的關鍵概念，用於管理變量的生命週期、引用的有效性和資源的釋放。

Rust的作用域規則和生命週期是該語言中的關鍵概念，用於管理變量的生命週期、引用的有效性和資源的釋放。讓我們更詳細地瞭解一下這些概念。

1. **變量的作用域規則**：

Rust中的變量有明確的作用域，這意味著變量只在其定義的作用域內可見和可訪問。作用域通常由大括號 `{}` 定義，例如函數、代碼塊或結構體定義。

```rust
fn main() {
    let x = 42; // x 在 main 函數的作用域內可見
    println!("x = {}", x);
} // x 的作用域在這裡結束，它被銷燬
```

2. **引用和借用**：

在Rust中，引用是一種允許你借用(或者說訪問)數據而不擁有它的方式。引用有兩種類型：可變引用和不可變引用。

- 不可變引用(`&T`)：允許多個只讀引用同時存在，但不允許修改數據。
- 可變引用(`&mut T`)：允許單一可變引用，但不允許同時存在多個引用。

```rust
fn main() {
    let mut x = 42;
    
    let y = &x; // 不可變引用
    // let z = &mut x; // 錯誤，不能同時存在可變和不可變引用
    
    println!("x = {}", x);
}
```

3. **生命週期**：

生命週期(Lifetime)是一種用於描述引用的有效範圍的標記，它確保引用在其生命週期內有效。生命週期參數通常以單引號 `'` 開頭，例如 `'a`。

```rust
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}

fn main() {
    let s1 = "Hello";
    let s2 = "World";
    
    let result = longest(s1, s2);
    
    println!("The longest string is: {}", result);
}
```

在上述示例中，`longest` 函數的參數和返回值都有相同的生命週期 `'a`，這表示函數返回的引用的生命週期與輸入參數中更長的那個引用的生命週期相同。這是通過生命週期參數 `'a` 來表達的。

4. **生命週期註解**：

有時，編譯器無法自動確定引用的生命週期關係，因此我們需要使用生命週期註解來幫助編譯器理解引用的關係。生命週期註解的語法是將生命週期參數放在函數簽名中，並使用單引號標識，例如 `'a`。

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &byte) in bytes.iter().enumerate() {
        if byte == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}
```

在上述示例中，`&str` 類型的引用 `s` 有一個生命週期，但編譯器可以自動推斷出來。如果編譯器無法自動推斷，我們可以使用生命週期註解來明確指定引用之間的生命週期關係。

這些是Rust中作用域規則和生命週期的基本概念。它們幫助編譯器進行正確性檢查，防止數據競爭和資源洩漏，使Rust成為一門安全的系統編程語言。

## 15.1 RAII(Resource Acquisition Is Initialization)

資源獲取即初始化 / RAII(Resource Acquisition Is Initialization)是一種編程範式，主要用於C++和Rust等編程語言中，旨在通過對象的生命週期來管理資源的獲取和釋放。RAII的核心思想是資源的獲取應該在對象的構造階段完成，而資源的釋放應該在對象的析構階段完成，從而確保資源的正確管理，避免資源洩漏。

在金融領域的語境中，RAII(Resource Acquisition Is Initialization)的原則可以理解為資源的獲取和釋放與金融數據對象的生命週期緊密相關，以確保金融數據的正確管理和資源的合理使用。下面詳細解釋在金融背景下應用RAII的重要概念和原則：

1. **資源的獲取和釋放綁定到金融數據對象的生命週期：** 在金融領域，資源可以是金融數據、交易訂單、數據庫連接等，這些資源的獲取和釋放應該與金融數據對象的生命週期緊密綁定。這確保了資源的正確使用，避免了資源洩漏或錯誤的資源釋放。

2. **金融數據對象的構造函數負責資源的獲取：** 在金融數據對象的構造函數中，應該負責獲取相關資源。例如，可以在金融數據對象創建時從數據庫中加載數據或建立網絡連接。

3. **金融數據對象的析構函數負責資源的釋放：** 金融數據對象的析構函數應該負責釋放與其關聯的資源。這可能包括關閉數據庫連接、釋放內存或提交交易訂單。

4. **自動化管理：** RAII的一個關鍵特點是資源管理的自動化。當金融數據對象超出其作用域(例如，離開函數或代碼塊)時，析構函數會自動調用，確保資源被正確釋放，從而減少了人為錯誤的可能性。

5. **異常安全性：** 在金融領域，異常處理非常重要。RAII確保了異常安全性，即使在處理金融數據時發生異常，也會確保相關資源的正確釋放，從而防止數據不一致或資源洩漏。

6. **嵌套資源管理：** 金融數據處理通常涉及多層嵌套，例如，一個交易可能包含多個訂單，每個訂單可能涉及不同的金融工具。RAII可以幫助管理這些嵌套資源，確保它們在正確的時間被獲取和釋放。

7. **通用性：** RAII原則在金融領域的通用性強，可以應用於不同類型的金融數據和資源管理，包括證券交易、風險管理、數據分析等各個方面，以確保代碼的可靠性和安全性。

在C++中，RAII通常使用類和析構函數來實現。在Rust中，RAII的概念與C++類似，但使用了所有權和生命週期系統來確保資源的安全管理，而不需要顯式的析構函數。

總之，RAII是一種重要的資源管理範式，它通過對象的生命週期來自動化資源的獲取和釋放，確保資源的正確管理和異常安全性。這使得代碼更加可靠、易於維護，同時減少了資源洩漏和內存洩漏的風險。

## 15.2 析構函數 & Drop trait

在Rust中，析構函數的概念與一些其他編程語言(如C++)中的析構函數不同。Rust中**沒有傳統的析構函數**，而是通過`Drop` trait來實現資源的釋放和清理操作。讓我詳細解釋一下`Drop` trait以及如何在Rust中使用它來管理資源。

`Drop` trait是Rust中的一種特殊trait，用於定義資源釋放的邏輯。當擁有實現`Drop` trait的類型的值的生命週期結束時(例如，離開作用域或通過`std::mem::drop`函數手動釋放)，Rust會自動調用這個類型的`drop`方法，以進行資源清理和釋放。

`Drop` trait的定義如下：

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

`Drop` trait只有一個方法，即`drop`方法，它接受一個可變引用`&mut self`，在其中編寫資源的釋放邏輯。

**示例**：以下是一個簡單示例，展示如何使用`Drop` trait來管理資源。在這個示例中，我們定義一個自定義結構`FileHandler`，用於打開文件，並在對象銷燬時關閉文件：

```rust
use std::fs::File;
use std::io::Write;

struct FileHandler {
    file: File,
}

impl FileHandler {
    fn new(filename: &str) -> std::io::Result<Self> {
        let file = File::create(filename)?;
        Ok(FileHandler { file })
    }

    fn write_data(&mut self, data: &[u8]) -> std::io::Result<usize> {
        self.file.write(data)
    }
}

impl Drop for FileHandler {
    fn drop(&mut self) {
        println!("Closing file.");
    }
}

fn main() -> std::io::Result<()> {
    let mut file_handler = FileHandler::new("example.txt")?;
    file_handler.write_data(b"Hello, RAII!")?;
    
    // file_handler對象在這裡離開作用域，觸發Drop trait中的drop方法
    // 文件會被自動關閉
    Ok(())
}
```

在上述示例中，`FileHandler`結構實現了`Drop` trait，在`drop`方法中關閉文件。當`file_handler`對象離開作用域時，`Drop` trait的`drop`方法會被自動調用，關閉文件。這確保了文件資源的正確釋放。

## 15.3 生命週期（Lifetimes）詳解 

生命週期（Lifetimes）是Rust中一個非常重要的概念，用於確保內存安全和防止數據競爭。在Rust中，生命週期指定了引用的有效範圍，幫助編譯器檢查引用是否合法。在進階Rust中，我們將深入探討生命週期的高級概念和應用。

在進階Rust中，我們將深入探討生命週期的高級概念和應用。

#### **15.3.1 生命週期的自動推斷和省略**

其實Rust在很多情況下，甚至式大部分情況下，可以自動推斷生命週期，但有時需要顯式註解來幫助編譯器理解引用的生命週期。以下是一些關於Rust生命週期自動推斷的示例和解釋。

```rust
fn get_length(s: &str) -> usize {
    s.len()
}

fn main() {
    let text = String::from("Hello, Rust!");
    let length = get_length(&text);
    println!("Length: {}", length);
}

```

在上述示例中，`get_length`函數接受一個`&str`引用作為參數，並沒有顯式指定生命週期。Rust會自動推斷引用的生命週期，使其與調用者的生命週期相符。

但是在這個案例中，你需要顯式聲明生命週期參數來使代碼合法：

```rust
fn shorter<'a>(x: &'a str, y: &'a str, z: &'a str) -> &str {
    if x.len() <= y.len() && x.len() <= z.len() {
        x
    } else if y.len() <= x.len() && y.len() <= z.len() {
        y
    } else {
        z
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    let string3 = "lmnop";

    let result = shorter(string1.as_str(), string2, string3);
    println!("The shortest string is {}", result);
}

```

**執行結果：**

```rust
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:55
  |
1 | fn shorter<'a>(x: &'a str, y: &'a str, z: &'a str) -> &str {
  |                   -------     -------     -------     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments
help: consider using the `'a` lifetime
  |
1 | fn shorter<'a>(x: &'a str, y: &'a str, z: &'a str) -> &'a str {
  |                                                        ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `book_test` (bin "book_test") due to previous error
```

在 Rust 中，生命週期參數應該在函數參數和返回值中保持一致。這是為了確保借用規則得到正確的應用和編譯器能夠理解代碼的生命週期要求。在你的 `shorter` 函數中，所有的參數和返回值引用都使用了相同的生命週期參數 `'a`，這是正確的做法，因為它們都應該在同一個生命週期內有效。

### 15.3.2 生命週期和結構體

在結構體中標註生命週期和函數的類似, 可以通過顯式標註來使變量或者引用的生命週期超過結構體或者枚舉本身。來看一個簡單的例子:

```rust
#[derive(Debug)]
struct Book<'a> {
    title: &'a str,
    author: &'a str,
}

#[derive(Debug)]
struct Chapter<'a> {
    book: &'a Book<'a>,
    title: &'a str,
}

fn main() {
    let book_title = "Rust Programming";
    let book_author = "Arthur";

    let book = Book {
        title: &book_title,
        author: &book_author,
    };

    let chapter_title = "Chapter 1: Introduction";
    let chapter = Chapter {
        book: &book,
        title: &chapter_title,
    };

    println!("Book: {:?}", book);
    println!("Chapter: {:?}", chapter);
}

```

在這裡，`'a` 是一個生命週期參數，它告訴編譯器引用 `title` 和 `author` 的有效範圍與 `'a` 相關聯。這意味著 `title` 和 `author` 引用的生命週期不能超過與 `Book` 結構體關聯的生命週期 `'a`。

然後，我們來看 `Chapter` 結構體，它包含了一個對 `Book` 結構體的引用，以及章節的標題引用。注意，`Chapter` 結構體的生命週期參數 `'a` 與 `Book` 結構體的生命週期參數相同，這意味著 `Chapter` 結構體中的引用也必須在 `'a` 生命週期內有效。

### 15.3.3 static

在Rust中，你可以使用`static`聲明來創建具有靜態生命週期的全局變量，這些變量將在整個程序運行期間存在，並且可以被強制轉換成更短的生命週期。以下是一個給樂隊成員報幕的Rust代碼示例：

```
// 定義一個包含樂隊成員信息的結構體
struct BandMember {
    name: &'static str,
    age: u32,
    instrument: &'static str,
}

// 聲明一個具有 'static 生命週期的全局變量
static BAND_MEMBERS: [BandMember; 4] = [
    BandMember { name: "John", age: 30, instrument: "吉他手" },
    BandMember { name: "Lisa", age: 28, instrument: "貝斯手" },
    BandMember { name: "Mike", age: 32, instrument: "鼓手" },
    BandMember { name: "Sarah", age: 25, instrument: "鍵盤手" },
];

fn main() {
    // 給樂隊成員報幕
    for member in BAND_MEMBERS.iter() {
        println!("歡迎 {}，{}歲，負責{}！", member.name, member.age, member.instrument);
    }
}

```

**執行結果**：

```
歡迎 John，30歲，負責吉他手！
歡迎 Lisa，28歲，負責貝斯手！
歡迎 Mike，32歲，負責鼓手！
歡迎 Sarah，25歲，負責鍵盤手！
```

在這個執行結果中，程序使用`println!`宏為每位樂隊成員生成了一條報幕信息，顯示了他們的姓名、年齡和擔任的樂器。這樣就模擬了給樂隊成員報幕的效果。

### 案例 `'static` 在量化金融中的作用

`'static` 在量化金融中可以具有重要的作用，尤其是在處理常量、全局配置、參數以及模型參數等方面。以下是五個簡單的案例示例：

####  1: 全局配置和參數

在一個量化金融系統中，你可以定義全局配置和參數，例如交易手續費、市場數據源和回測週期，並將它們存儲在具有 `'static` 生命週期的全局變量中：

```rust
static TRADING_COMMISSION: f64 = 0.005; // 交易手續費率 (0.5%)
static MARKET_DATA_SOURCE: &str = "NASDAQ"; // 市場數據源
static BACKTEST_PERIOD: u32 = 365; // 回測週期（一年）
```

這些參數可以在整個量化金融系統中共享和訪問，以確保一致性和方便的配置。

####  2: 模型參數

假設你正在開發一個金融模型，例如布萊克-斯科爾斯期權定價模型。模型中的參數（例如波動率、無風險利率）可以定義為 `'static` 生命週期的全局變量：

```rust
static VOLATILITY: f64 = 0.2; // 波動率參數
static RISK_FREE_RATE: f64 = 0.03; // 無風險利率
```

這些模型參數可以在整個模型的實現中使用，而不必在函數之間傳遞。

####  3: 常量定義

在量化金融中，常常有一些常量，如交易所的交易時間表、證券代碼前綴等。這些常量可以定義為 `'static` 生命週期的全局常量：

```rust
static TRADING_HOURS: [u8; 24] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 交易時間
static STOCK_PREFIX: &str = "AAPL"; // 證券代碼前綴
```

這些常量可以在整個應用程序中使用，而無需重複定義。

####  4: 緩存數據

在量化金融中，你可能需要緩存市場數據，以減少對外部數據源的頻繁訪問。你可以使用 `'static` 生命週期的變量來存儲緩存數據：

```rust
static mut PRICE_CACHE: HashMap<String, f64> = HashMap::new(); // 價格緩存
```

這個緩存可以在多個函數中使用，以便快速訪問最近的價格數據。

####  5: 單例模式

假設你需要創建一個單例對象，例如日誌記錄器，以確保在整個應用程序中只有一個實例。你可以使用 `'static` 生命週期來實現單例模式：

```rust
struct Logger {
    // 日誌記錄器的屬性和方法
}

impl Logger {
    fn new() -> Self {
        Logger {
            // 初始化日誌記錄器
        }
    }
}

static LOGGER: Logger = Logger::new(); // 單例日誌記錄器

fn main() {
    // 在整個應用程序中，你可以通過 LOGGER 訪問單例日誌記錄器
    LOGGER.log("This is a log message");
}
```

在這個案例中，`LOGGER` 是具有 `'static` 生命週期的全局變量，確保在整個應用程序中只有一個日誌記錄器實例。

這些案例突出了在量化金融中使用 `'static` 生命週期的不同情況，以管理全局配置、模型參數、常量、緩存數據和單例對象。這有助於提高代碼的可維護性、一致性和性能。

# Chapter 16 - 錯誤處理進階(Advanced Error handling)

Rust 中的錯誤處理具有很高的靈活性和表現力。除了基本的錯誤處理機制（使用 `Result` 和 `Option`），Rust 還提供了一些高階的錯誤處理技術，包括自定義錯誤類型、錯誤鏈、錯誤處理宏等。

以下是 Rust 中錯誤處理的一些高階用法：

## 16.1 自定義錯誤類型

Rust 允許你創建自定義的錯誤類型，以便更好地表達你的錯誤情況。這通常涉及創建一個枚舉，其中的變體表示不同的錯誤情況。你可以實現 `std::error::Error` trait 來為自定義錯誤類型提供額外的信息。

```rust
use std::error::Error;
use std::fmt;

// 自定義錯誤類型
#[derive(Debug)]
enum MyError {
    IoError(std::io::Error),
    CustomError(String),
}

// 實現 Error trait
impl Error for MyError {}

// 實現 Display trait 用於打印錯誤信息
impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            MyError::IoError(ref e) => write!(f, "IO Error: {}", e),
            MyError::CustomError(ref msg) => write!(f, "Custom Error: {}", msg),
        }
    }
}
```

## 16.2 錯誤鏈

Rust 允許你在錯誤處理中創建錯誤鏈，以跟蹤錯誤的來源。這在調試複雜的錯誤時非常有用，因為它可以顯示錯誤傳播的路徑。

```rust
// 定義一個函數 `foo`，它返回一個 Result 類型，其中包含一個錯誤對象
fn foo() -> Result<(), Box<dyn std::error::Error>> {
    // 模擬一個錯誤，創建一個包含自定義錯誤消息的 Result
    let err: Result<(), Box<dyn std::error::Error>> = Err(Box::new(MyError::CustomError("Something went wrong".to_string())));
    // 使用 `?` 運算符，如果 `err` 包含錯誤，則將錯誤立即返回
    err?;
    // 如果沒有錯誤，返回一個表示成功的 Ok(())
    Ok(())
}

fn main() {
    // 調用 `foo` 函數並檢查其返回值
    if let Err(e) = foo() {
        // 如果存在錯誤，打印錯誤消息
        println!("Error: {}", e);

        // 初始化一個錯誤鏈的源（source）迭代器
        let mut source = e.source();

        // 使用迭代器遍歷錯誤鏈
        while let Some(err) = source {
            // 打印每個錯誤鏈中的錯誤消息
            println!("Caused by: {}", err);
            // 獲取下一個錯誤鏈的源
            source = err.source();
        }
    }
}
```

**執行結果：**

```plaintext
Error: Something went wrong
Caused by: Something went wrong
```

解釋和原理：

1. `fn foo() -> Result<(), Box<dyn std::error::Error>>`：這是一個函數簽名，表示 `foo` 函數返回一個 `Result` 類型，其中包含一個空元組 `()`，表示成功時不返回具體的值。同時，錯誤類型為 `Box<dyn std::error::Error>`，這意味著可以返回任何實現了 `std::error::Error` trait 的錯誤類型。
2. `let err: Result<(), Box<dyn std::error::Error>> = Err(Box::new(MyError::CustomError("Something went wrong".to_string())));`：在函數內部，我們創建了一個自定義的錯誤對象 `MyError::CustomError` 並將其包裝在 `Box` 中，然後將其包裝成一個 `Result` 對象 `err`。這個錯誤表示 "Something went wrong"。
3. `err?;`：這是一個短路運算符，如果 `err` 包含錯誤，則會立即返回錯誤，否則繼續執行。在這種情況下，如果 `err` 包含錯誤，`foo` 函數會立即返回該錯誤。
4. `if let Err(e) = foo() { ... }`：在 `main` 函數中，我們調用 `foo` 函數並檢查其返回值。如果返回的結果是錯誤，將錯誤對象綁定到變量 `e` 中。
5. `println!("Error: {}", e);`：如果存在錯誤，打印錯誤消息。
6. `let mut source = e.source();`：初始化一個錯誤鏈的源（source）迭代器，以便遍歷錯誤鏈。
7. `while let Some(err) = source { ... }`：使用 `while let` 循環遍歷錯誤鏈，逐個打印錯誤鏈中的錯誤消息，並獲取下一個錯誤鏈的源。這允許你查看導致錯誤的全部歷史。

這段代碼演示瞭如何處理錯誤，並在錯誤鏈中追蹤錯誤的來源。這對於調試和排查問題非常有用，尤其是在複雜的錯誤場景下。

在量化金融 Rust 開發中，錯誤鏈可以應用於方方面面，以提高代碼的可維護性和可靠性。以下是一些可能的應用場景：

1. **數據源連接和解析：** 在量化金融中，數據源可能來自各種市場數據提供商和交易所。使用錯誤鏈可以更好地處理數據源的連接錯誤、數據解析錯誤以及數據質量問題。

2. **策略執行和交易：** 量化策略的執行和交易可能涉及到複雜的算法和訂單管理。錯誤鏈可以用於跟蹤策略執行中的錯誤，包括訂單執行錯誤、價格計算錯誤等。

3. **數據存儲和查詢：** 金融數據的存儲和查詢通常涉及數據庫操作。錯誤鏈可用於處理數據庫連接問題、數據插入/查詢錯誤以及數據一致性問題。

4. **風險管理：** 量化金融系統需要進行風險管理和監控。錯誤鏈可用於記錄風險檢測、風險限制違規以及風險報告生成中的問題。

5. **模型開發和驗證：** 金融模型的開發和驗證可能涉及數學計算和模擬。錯誤鏈可以用於跟蹤模型驗證過程中的錯誤和異常情況。

6. **通信和報告：** 金融系統需要與交易所、監管機構和客戶進行通信。錯誤鏈可用於處理通信錯誤、報告生成錯誤以及與外部實體的交互中的問題。

7. **監控和告警：** 錯誤鏈可用於建立監控系統，以檢測系統性能問題、錯誤率上升和異常行為，並生成告警以及執行相應的應急措施。

8. **回測和性能優化：** 在策略開發過程中，需要進行回測和性能優化。錯誤鏈可用於記錄回測錯誤、性能測試結果和優化過程中的問題。

9. **數據隱私和安全性：** 金融數據具有高度的敏感性，需要保護數據隱私和確保系統的安全性。錯誤鏈可用於處理安全性檢查、身份驗證錯誤以及數據洩露問題。

10. **版本控制和部署：** 在金融系統的開發和部署過程中，可能會出現版本控制和部署錯誤。錯誤鏈可用於跟蹤版本衝突、依賴問題以及部署失敗。

錯誤鏈的應用有助於更好地識別、記錄和處理系統中的問題，提高系統的可維護性和穩定性，同時也有助於快速定位和解決潛在的問題。這對於量化金融系統非常重要，因為這些系統通常需要高度的可靠性和穩定性。



### 補充學習： foo 和 bar

為什麼計算機科學中喜歡使用 `foo` 和 `bar` 這樣的名稱是有多種說法歷史淵源的。這些名稱最早起源於早期計算機編程和計算機文化，根據wiki,  foo 和 bar可能具有以下一些歷史和傳統背景：

1. **Playful Allusion（俏皮暗示）：** 有人認為 `foobar` 可能是對二戰時期軍事俚語 "FUBAR"（Fucked Up Beyond All Recognition）的一種戲謔引用。這種引用可能是為了強調代碼中的混亂或問題。
2. **Tech Model Railroad Club（TMRC）：** 在編程上下文中，"foo" 和 "bar" 的首次印刷使用出現在麻省理工學院（MIT）的 Tech Engineering News 的 1965 年版中。"foo" 在編程上下文中的使用通常歸功於 MIT 的 Tech Model Railroad Club（TMRC），大約在 1960 年左右。在 TMRC 的複雜模型系統中，房間各處都有緊急關閉開關，如果發生不期望的情況（例如，火車全速向障礙物前進），則可以觸發這些開關。系統的另一個特點是調度板上的數字時鐘。當有人按下關閉開關時，時鐘停止運行，並且顯示更改為單詞 "FOO"；因此，在 TMRC，這些關閉開關被稱為 "Foo 開關"。

總的來說，"foo" 和 "bar" 這些命名習慣在計算機編程中的使用起源於早期計算機文化和編程社區，並且已經成為了一種傳統。它們通常被用於示例代碼、測試和文檔中，以便簡化示例的編寫，並且不會對特定含義產生混淆。雖然它們是通用的、不具備特定含義的名稱，但它們在編程社區中得到了廣泛接受，並且用於教育和概念驗證。

###  補充學習： source方法

在 Rust 中，`source` 方法是用於訪問錯誤鏈中下一個錯誤源（source）的方法。它是由 `std::error::Error` trait 提供的方法，允許你在錯誤處理中遍歷錯誤鏈，以查看導致錯誤的全部歷史。

以下是 `source` 方法的簽名：

```rust
fn source(&self) -> Option<&(dyn Error + 'static)>
```

解釋每個部分的含義：

- `fn source(&self)`：這是一個方法簽名，表示一個方法名為 `source`，接受 `&self` 參數，也就是對實現了 `std::error::Error` trait 的錯誤對象的引用。

- `-> Option<&(dyn Error + 'static)>`：這是返回值類型，表示該方法返回一個 `Option`，其中包含一個對下一個錯誤源（如果存在）的引用。`Option` 可能是 `Some`（包含錯誤源）或 `None`（表示沒有更多的錯誤源）。`&(dyn Error + 'static)` 表示錯誤源的引用，`dyn Error` 表示實現了 `std::error::Error` trait 的錯誤類型。`'static` 是錯誤源的生命週期，通常為靜態生命週期，表示錯誤源的生命週期是靜態的。

要使用 `source` 方法，你需要在實現了 `std::error::Error` trait 的自定義錯誤類型上調用該方法，以訪問下一個錯誤源（如果存在）。

## 16.3 錯誤處理宏

Rust 的標準庫和其他庫提供了一些有用的宏，用於簡化自定義錯誤處理的代碼，例如，`anyhow`、`thiserror` 和 `failure` 等庫。

```rust
use anyhow::{Result, anyhow};

fn foo() -> Result<()> {
    let condition = false;
    if condition {
        Ok(())
    } else {
        Err(anyhow!("Something went wrong"))
    }
}
```

在上述示例中，我們使用 `anyhow` 宏來創建一個帶有錯誤消息的 `Result`。

## 16.4  把錯誤“裝箱”

在 Rust 中處理多種錯誤類型，可以將它們裝箱為 `Box<dyn error::Error>` 類型的結果。這種做法有幾個好處和原因：

1. **統一的錯誤處理**：使用 `Box<dyn error::Error>` 類型可以統一處理不同類型的錯誤，無論錯誤類型是何種具體的類型，都可以用相同的方式處理。這簡化了錯誤處理的代碼，減少了冗餘。
2. **錯誤信息的抽象**：Rust 的錯誤處理機制允許捕獲和處理不同類型的錯誤，但在上層代碼中，通常只需關心錯誤的抽象信息，而不需要關心具體的錯誤類型。使用 `Box<dyn error::Error>` 可以提供錯誤的抽象表示，而不暴露具體的錯誤類型給上層代碼。
3. **錯誤的封裝**：將不同類型的錯誤裝箱為 `Box<dyn error::Error>` 可以將錯誤信息和原因進行封裝。這允許在錯誤鏈中構建更豐富的信息，以便於調試和錯誤追蹤。在實際應用中，一個錯誤可能會導致另一個錯誤，而 `Box<dyn error::Error>` 允許將這些錯誤鏈接在一起。
4. **靈活性**：使用 `Box<dyn error::Error>` 作為錯誤類型，允許在運行時動態地處理不同類型的錯誤。這在某些情況下非常有用，例如處理來自不同來源的錯誤或插件系統中的錯誤。

將錯誤裝箱為 `Box<dyn error::Error>` 是一種通用的、靈活的錯誤處理方式，它允許處理多種不同類型的錯誤，並提供了更好的錯誤信息管理和抽象。這種做法使得代碼更容易編寫、維護和擴展，同時也提供了更好的錯誤診斷和追蹤功能。

## 16.5  用 map方法 處理 option鏈條 (case required)

以下是一個趣味性的示例，模擬了製作壽司的過程，包括淘米、準備食材、烹飪和包裹。在這個示例中，我們使用 `Option` 類型來表示每個製作步驟，並使用 `map` 方法來模擬每個步驟的處理過程：

```rust
#![allow(dead_code)]

// 壽司的食材
#[derive(Debug)] enum SushiIngredient { Rice, Fish, Seaweed, SoySauce, Wasabi }

// 壽司製作步驟
struct WashedRice(SushiIngredient);
struct PreparedIngredients(SushiIngredient);
struct CookedSushi(SushiIngredient);
struct WrappedSushi(SushiIngredient);

// 淘米。如果沒有食材，就返回 `None`。否則返回淘好的米。
fn wash_rice(ingredient: Option<SushiIngredient>) -> Option<WashedRice> {
    ingredient.map(|i| WashedRice(i))
}

// 準備食材。如果沒有食材，就返回 `None`。否則返回準備好的食材。
fn prepare_ingredients(rice: Option<WashedRice>) -> Option<PreparedIngredients> {
    rice.map(|WashedRice(i)| PreparedIngredients(i))
}

// 烹飪壽司。這裡，我們使用 `map()` 來替代 `match` 以處理各種情況。
fn cook_sushi(ingredients: Option<PreparedIngredients>) -> Option<CookedSushi> {
    ingredients.map(|PreparedIngredients(i)| CookedSushi(i))
}

// 包裹壽司。如果沒有食材，就返回 `None`。否則返回包裹好的壽司。
fn wrap_sushi(sushi: Option<CookedSushi>) -> Option<WrappedSushi> {
    sushi.map(|CookedSushi(i)| WrappedSushi(i))
}

// 吃壽司
fn eat_sushi(sushi: Option<WrappedSushi>) {
    match sushi {
        Some(WrappedSushi(i)) => println!("Delicious sushi with {:?}", i),
        None                  => println!("Oops! Something went wrong."),
    }
}

fn main() {
    let rice = Some(SushiIngredient::Rice);
    let fish = Some(SushiIngredient::Fish);
    let seaweed = Some(SushiIngredient::Seaweed);
    let soy_sauce = Some(SushiIngredient::SoySauce);
    let wasabi = Some(SushiIngredient::Wasabi);

    // 製作壽司
    let washed_rice = wash_rice(rice);
    let prepared_ingredients = prepare_ingredients(washed_rice);
    let cooked_sushi = cook_sushi(prepared_ingredients);
    let wrapped_sushi = wrap_sushi(cooked_sushi);

    // 吃壽司
    eat_sushi(wrapped_sushi);
}
```

這個示例模擬了製作壽司的流程，每個步驟都使用 `Option` 表示，並使用 `map` 方法進行處理。當食材經過一系列步驟後，最終製作出美味的壽司。

## 16.6 and_then 方法

組合算子 `and_then` 是另一種在 Rust 編程語言中常見的組合子（combinator）。它通常用於處理 Option 類型或 Result 類型的值，通過鏈式調用來組合多個操作。

在 Rust 中，`and_then` 是一個方法，可以用於 Option 類型的值。它的作用是當 Option 值為 Some 時，執行指定的操作，並返回一個新的 Option 值。如果 Option 值為 None，則不執行任何操作，直接返回 None。

下面是一個使用 `and_then` 的示例：

```rust
let option1 = Some(10);  
let option2 = option1.and_then(|x| Some(x + 5));  
let option3 = option2.and_then(|x| if x > 15 { Some(x * 2) } else { None });  
  
match option3 {  
    Some(value) => println!("Option 3: {}", value),  
    None => println!("Option 3 is None"),  
}
```

在上面的示例中，我們首先創建了一個 Option 值 `option1`，其值為 Some(10)。然後，我們使用 `and_then` 方法對 `option1` 進行操作，將其值加上 5，並將結果包裝為一個新的 Option 值 `option2`。接著，我們再次使用 `and_then` 方法對 `option2` 進行操作，如果值大於 15，則將其乘以 2，否則返回 None。最後，我們將結果賦值給 `option3`。

根據示例中的操作，`option3` 的值將為 Some(30)，因為 10 + 5 = 15，15 > 15，所以乘以 2 得到 30。

通過鏈式調用 `and_then` 方法，我們可以將多個操作組合在一起，以便在 Option 值上執行一系列的計算或轉換。這種組合子的使用可以使代碼更加簡潔和易讀。

## 16.7 用filter_map 方法忽略空值

在 Rust 中，可以使用 `filter_map` 方法來忽略集合中的空值。這對於從集合中過濾掉 `None` 值並同時提取 `Some` 值非常有用。下面是一個示例：

```rust
fn main() {
    let values: Vec<Option<i32>> = vec![Some(1), None, Some(2), None, Some(3)];

    // 使用 filter_map 過濾掉 None 值並提取 Some 值
    let filtered_values: Vec<i32> = values.into_iter().filter_map(|x| x).collect();

    println!("{:?}", filtered_values); // 輸出 [1, 2, 3]
}
```

在上面的示例中，我們有一個包含 `Option<i32>` 值的 `values` 向量。我們使用 `filter_map` 方法來過濾掉 `None` 值並提取 `Some` 值，最終將結果收集到一個新的 `Vec<i32>` 中。這樣，我們就得到了一個只包含非空值的新集合 `filtered_values`。

### 案例： 數據清洗

在量化金融領域，Rust 中的 `filter_map` 方法可以用於處理和清理數據。以下是一個示例，演示瞭如何在一個包含金融數據的 `Vec<Option<f64>>` 中過濾掉空值（`None`）並提取有效的價格數據（`Some` 值）：

```rust
fn main() {
    // 模擬一個包含金融價格數據的向量
    let financial_data: Vec<Option<f64>> = vec![
        Some(100.0),
        Some(105.5),
        None,
        Some(98.75),
        None,
        Some(102.3),
    ];

    // 使用 filter_map 過濾掉空值並提取價格數據
    let valid_prices: Vec<f64> = financial_data.into_iter().filter_map(|price| price).collect();

    // 打印有效價格數據
    for price in &valid_prices {
        println!("Price: {}", price);
    }
}
```

在這個示例中，我們模擬了一個包含金融價格數據的向量 `financial_data`，其中有一些條目是空值（`None`）。我們使用 `filter_map` 方法將有效的價格數據提取到新的向量 `valid_prices` 中。然後再打印。

## 16.8 用collect 方法讓整個操作鏈條失敗

在 Rust 中，可以使用 `collect` 方法將一個 `Iterator` 轉換為一個 `Result`，並且一旦遇到 `Result::Err`，遍歷就會終止。這在處理一系列 `Result` 類型的操作時非常有用，因為只要有一個操作失敗，整個操作可以立即失敗並返回錯誤。

以下是一個示例，演示瞭如何使用 `collect` 方法將一個包含 `Result<i32, Error>` 的迭代器轉換為 `Result<Vec<i32>, Error>`，並且如果其中任何一個 `Result` 是錯誤的，整個操作就失敗：

```rust
#[derive(Debug)]
struct Error {
    message: String,
}

fn main() {
    // 模擬包含 Result 類型的迭代器
    let data: Vec<Result<i32, Error>> = vec![Ok(1), Ok(2), Err(Error { message: "Error 1".to_string() }), Ok(3)];

    // 使用 collect 將 Result 迭代器轉換為 Result<Vec<i32>, Error>
    let result: Result<Vec<i32>, Error> = data.into_iter().collect();

    // 處理結果
    match result {
        Ok(numbers) => {
            println!("Valid numbers: {:?}", numbers);
        }
        Err(err) => {
            println!("Error occurred: {:?}", err);
        }
    }
}
```

在這個示例中，`data` 是一個包含 `Result` 類型的迭代器，其中一個 `Result` 是一個錯誤。通過使用 `collect` 方法，我們試圖將這些 `Result` 收集到一個 `Result<Vec<i32>, Error>` 中。由於有一個錯誤的 `Result`，整個操作失敗，最終結果是一個 `Result::Err`，並且我們可以捕獲和處理錯誤。

#### 思考：collect方法在金融領域有哪些用？

在量化金融領域，這種使用 `Result` 和 `collect` 的方法可以應用於一系列數據分析、策略執行或交易操作。以下是一些可能的應用場景：

1. **數據清洗和預處理**：在量化金融中，需要處理大量的金融數據，包括市場價格、財務報告等。這些數據可能包含錯誤或缺失值。使用 `Result` 和 `collect` 可以逐行處理數據，將每個數據點的處理結果（可能是成功的 `Result` 或失敗的 `Result`）收集到一個結果向量中。如果有任何錯誤發生，整個數據預處理操作可以被標記為失敗，確保不會使用不可靠的數據進行後續分析或交易。

2. **策略執行**：在量化交易中，需要執行一系列交易策略。每個策略的執行可能會導致成功或失敗的交易。使用 `Result` 和 `collect` 可以確保只有當所有策略都成功執行時，才會執行後續操作，例如訂單提交。如果任何一個策略執行失敗，整個策略組合可以被標記為失敗，以避免不必要的風險。

3. **訂單處理**：在金融交易中，訂單通常需要經歷多個步驟，包括校驗、拆分、路由、執行等。每個步驟都可能失敗。使用 `Result` 和 `collect` 可以確保只有當所有訂單的每個步驟都成功完成時，整個批量訂單處理操作才會繼續進行。這有助於避免不完整或錯誤的訂單被提交到市場。

4. **風險管理**：量化金融公司需要不斷監控和管理其風險曝露。如果某個風險分析或監控操作失敗，可能會導致對風險的不正確估計。使用 `Result` 和 `collect` 可以確保只有在所有風險操作都成功完成時，風險管理系統才會生成可靠的報告。

總之，`Result` 和 `collect` 的組合在量化金融領域可以用於確保數據的可靠性、策略的正確執行以及風險的有效管理。這有助於維護金融系統的穩定性和可靠性，降低操作錯誤的風險。

### 案例：“與門”邏輯的策略鏈條

"與門"（AND gate）是數字邏輯電路中的一種基本門電路，用於實現邏輯運算。與門的運算規則如下：

- 當所有輸入都是邏輯 "1" 時，輸出為邏輯 "1"。
- 只要有一個或多個輸入為邏輯 "0"，輸出為邏輯 "0"。

以下是一個簡單的示例，演示瞭如何使用 `Result` 和 `collect` 來執行“與門”邏輯的策略鏈條，並確保只有當所有策略成功執行時，才會提交訂單。

假設我們有三個交易策略，每個策略都有一個函數，它返回一個 `Result`，其中 `Ok` 表示策略成功執行，`Err` 表示策略執行失敗。我們希望只有當所有策略都成功時才執行後續操作。

```rust
// 定義交易策略和其執行函數
fn strategy_1() -> Result<(), &'static str> {
    // 模擬策略執行成功
    Ok(())
}

fn strategy_2() -> Result<(), &'static str> {
    // 模擬策略執行失敗
    Err("Strategy 2 failed")
}

fn strategy_3() -> Result<(), &'static str> {
    // 模擬策略執行成功
    Ok(())
}

fn main() {
    // 創建一個包含所有策略的向量
    let strategies = vec![strategy_1, strategy_2, strategy_3];

    // 使用 `collect` 將所有策略的結果收集到一個向量中
    let results: Vec<Result<(), &'static str>> = strategies.into_iter().map(|f| f()).collect();

    // 檢查是否存在失敗的策略
    if results.iter().any(|result| result.is_err()) {
        println!("One or more strategies failed. Aborting!");
        return;
    }

    // 所有策略成功執行，提交訂單或執行後續操作
    println!("All strategies executed successfully. Submitting orders...");
}
```

因為我們的其中一個策略失敗了，所以返回的是：

```text
One or more strategies failed. Aborting!
```

在這個示例中，我們使用 `collect` 將策略函數的結果收集到一個向量中。然後，我們使用 `iter().any()` 來檢查向量中是否存在失敗的結果。如果存在失敗的結果，我們可以中止一切後續操作以避免不必要的風險。

# Chapter 17 - 特性 (trait) 詳解

## 17.1 通過dyn關鍵詞輕鬆實現多態性

在Rust中，dyn 關鍵字在 Rust 中用於表示和關聯特徵（associated trait）相關的方法調用，在運行時進行動態分發（runtime dynamic dispatch）。因此`dyn` 關鍵字可以用於實現動態多態性（也稱為運行時多態性）。

通過 `dyn` 關鍵字，你可以創建接受不同類型的實現相同特徵（trait）的對象，然後在運行時根據實際類型來調用此方法不同的實現方法（比如貓狗都能叫，但是叫法當然不一樣）。以下是一個使用 `dyn` 關鍵字的多態性示例：

```rust
// 定義一個特徵（trait）叫做 Animal
trait Animal {
    fn speak(&self);
}

// 實現 Animal 特徵的結構體 Dog
struct Dog;

impl Animal for Dog {
    fn speak(&self) {
        println!("狗在汪汪叫！");
    }
}

// 實現 Animal 特徵的結構體 Cat
struct Cat;

impl Animal for Cat {
    fn speak(&self) {
        println!("貓在喵喵叫！");
    }
}

fn main() {
    // 創建一個存放實現 Animal 特徵的對象的動態多態性容器
    let animals: Vec<Box<dyn Animal>> = vec![Box::new(Dog), Box::new(Cat)];

    // 調用動態多態性容器中每個對象的 speak 方法
    for animal in animals.iter() {
        animal.speak();
    }
}
```

在這個示例中，我們定義了一個特徵 `Animal`，併為其實現了兩個不同的結構體 `Dog` 和 `Cat`。然後，我們在 `main` 函數中創建了一個包含實現 `Animal` 特徵的對象的 `Vec`，並使用 `Box` 包裝它們以實現動態多態性。最後，我們使用 `for` 循環迭代容器中的每個對象，並調用 `speak` 方法，根據對象的實際類型分別輸出不同的聲音。

## 17.2 派生(\#[derive])

在 Rust 中，通過 `#[derive]` 屬性，編譯器可以自動生成某些 traits 的基本實現，這些 traits 通常與 Rust 中的常見編程模式和功能相關。下面是關於不同 trait 的短例子：

### 17.2.1 `Eq` 和 `PartialEq` Trait

`Eq` 和 `PartialEq` 是 Rust 中用於比較兩個值是否相等的 trait。它們通常用於支持自定義類型的相等性比較。

`Eq` 和 `PartialEq` 是 Rust 中用於比較兩個值是否相等的 trait。它們通常用於支持自定義類型的相等性比較。

**`Eq` Trait**:

- `Eq` 是一個 trait，用於比較兩個值是否完全相等。
- 它的定義看起來像這樣：`trait Eq: PartialEq<Self> {}`，這表示 `Eq` **依賴於 `PartialEq`**，**因此，任何實現了 `Eq` 的類型也必須實現 `PartialEq`**。
- 當你希望兩個值在語義上完全相等時，你應該為你的類型實現 `Eq`。**這意味著如果兩個值通過 `==` 比較返回 `true`，則它們也應該通過 `eq` 方法返回 `true`。**
- 默認情況下，Rust 的內置類型都實現了 `Eq`，所以你可以對它們進行相等性比較。

**`PartialEq` Trait**:

- `PartialEq` 也是一個 trait，用於比較兩個值是否部分相等。
- 它的定義看起來像這樣：`trait PartialEq<Rhs> where Rhs: ?Sized {}`，這表示 `PartialEq` 有一個關聯類型 `Rhs`，它表示要與自身進行比較的類型。
- `PartialEq` 的主要方法是 `fn eq(&self, other: &Rhs) -> bool;`，這個方法接受另一個類型為 `Rhs` 的引用，並返回一個布爾值，表示兩個值是否相等。
- 當你希望自定義類型支持相等性比較時，你應該為你的類型實現 `PartialEq`。這允許你定義兩個值何時被認為是相等的。
- 默認情況下，Rust 的內置類型也實現了 `PartialEq`，所以你可以對它們進行相等性比較。

下面是一個示例，演示如何為自定義結構體實現 `Eq` 和 `PartialEq`：

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl PartialEq for Point {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

impl Eq for Point {}

fn main() {
    let point1 = Point { x: 1, y: 2 };
    let point2 = Point { x: 1, y: 2 };
    let point3 = Point { x: 3, y: 4 };

    println!("point1 == point2: {}", point1 == point2); // true
    println!("point1 == point3: {}", point1 == point3); // false
}
```

在這個示例中，我們定義了一個名為 `Point` 的結構體，併為它實現了 `PartialEq` 和 `Eq`。在 `PartialEq` 的 `eq` 方法中，我們定義了何時認為兩個 `Point` 實例是相等的，即當它們的 `x` 和 `y` 座標都相等時。在 `main` 函數中，我們演示瞭如何使用 `==` 運算符比較兩個 `Point` 實例，以及如何根據我們的相等性定義來判斷它們是否相等。

### 17.2.2 `Ord` 和 `PartialOrd` Traits

`Ord` 和 `PartialOrd` 是 Rust 中用於比較值的 trait，它們通常用於支持自定義類型的大小比較。

**`Ord` Trait**:

- `Ord` 是一個 trait，用於定義一個類型的大小關係，即定義了一種全序關係（total order）。
- 它的定義看起來像這樣：`trait Ord: Eq + PartialOrd<Self> {}`，**這表示 `Ord` 依賴於 `Eq` 和 `PartialOrd`，因此，任何實現了 `Ord` 的類型必須實現 `Eq` 和 `PartialOrd`。**
- `Ord` 主要方法是 `fn cmp(&self, other: &Self) -> Ordering;`，它接受另一個類型為 `Self` 的引用，並返回一個 `Ordering` 枚舉值，表示兩個值的大小關係。
- `Ordering` 枚舉有三個成員：`Less`、`Equal` 和 `Greater`，分別表示當前值小於、等於或大於另一個值。

**`PartialOrd` Trait**:

- `PartialOrd` 也是一個 trait，用於定義兩個值的部分大小關係。
- 它的定義看起來像這樣：`trait PartialOrd<Rhs> where Rhs: ?Sized {}`，這表示 `PartialOrd` 有一個關聯類型 `Rhs`，它表示要與自身進行比較的類型。
- `PartialOrd` 主要方法是 `fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;`，它接受另一個類型為 `Rhs` 的引用，並返回一個 `Option<Ordering>`，表示兩個值的大小關係。
- `Option<Ordering>` 可以有三個值：`Some(Ordering)` 表示有大小關係，`None` 表示無法確定大小關係。

通常情況下，你應該首先實現 `PartialOrd`，然後基於 `PartialOrd` 的實現來實現 `Ord`。這樣做的原因是，`Ord` 表示完全的大小關係，而 `PartialOrd` 表示部分的大小關係。如果你實現了 `PartialOrd`，那麼 Rust 將會為你自動生成 `Ord` 的默認實現。

下面是一個示例，演示如何為自定義結構體實現 `PartialOrd` 和 `Ord`：

```rust
#[derive(Debug, PartialEq, Eq)]
struct Person {
    name: String,
    age: u32,
}

impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.age.cmp(&other.age))
    }
}

impl Ord for Person {
    fn cmp(&self, other: &Self) -> Ordering {
        self.age.cmp(&other.age)
    }
}

use std::cmp::Ordering;

fn main() {
    let person1 = Person { name: "Alice".to_string(), age: 30 };
    let person2 = Person { name: "Bob".to_string(), age: 25 };

    println!("person1 < person2: {}", person1 < person2); // true
    println!("person1 > person2: {}", person1 > person2); // false
}
```

**執行結果**：

```text
person1 < person2: false
person1 > person2: true
```

在這個示例中，我們定義了一個名為 `Person` 的結構體，併為它實現了 `PartialOrd` 和 `Ord`。我們根據年齡來定義了兩個 `Person` 實例之間的大小關係。在 `main` 函數中，我們演示瞭如何使用 `<` 和 `>` 運算符來比較兩個 `Person` 實例，以及如何使用 `cmp` 方法來獲取它們的大小關係。因為我們實現了 `PartialOrd` 和 `Ord`，所以 Rust 可以為我們生成完整的大小比較邏輯。



### 17.2.3  `Clone` Trait

`Clone` 是 Rust 中的一個 trait，用於允許創建一個類型的副本（複製），從而在需要時複製一個對象，而不是移動（轉移所有權）它。`Clone` trait 對於某些類型的操作非常有用，例如需要克隆對象以避免修改原始對象時影響到副本的情況。

下面是有關 `Clone` trait 的詳細解釋：

1. **`Clone` Trait 的定義**：
   - `Clone` trait 定義如下：`pub trait Clone { fn clone(&self) -> Self; }`。
   - 它包含一個方法 `clone`，該方法接受 `self` 的不可變引用，並返回一個新的具有相同值的對象。

2. **為何需要 Clone**：
   - Rust 中的賦值默認是移動語義，即將值的所有權從一個變量轉移到另一個變量。這意味著在默認情況下，如果你將一個對象分配給另一個變量，原始對象將不再可用。
   - 在某些情況下，你可能需要創建一個對象的副本，而不是移動它，以便保留原始對象的拷貝。這是 `Clone` trait 的用武之地。

3. **Clone 的默認實現**：
   - 對於實現了 `Copy` trait 的類型，它們也自動實現了 `Clone` trait。這是因為 `Copy` 表示具有複製語義，它們總是可以安全地進行克隆。
   - 對於其他類型，你需要手動實現 `Clone` trait。通常，這涉及到深度複製所有內部數據。

4. **自定義 Clone 實現**：
   - 你可以為自定義類型實現 `Clone`，並在 `clone` 方法中定義如何進行克隆。這可能涉及到創建新的對象並複製所有內部數據。
   - 注意，如果類型包含引用或其他非 `Clone` 類型的字段，你需要確保正確地處理它們的克隆。

下面是一個示例，演示如何為自定義結構體實現 `Clone`：

```rust
#[derive(Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let original_point = Point { x: 1, y: 2 };
    let cloned_point = original_point.clone();

    println!("Original Point: {:?}", original_point);
    println!("Cloned Point: {:?}", cloned_point);
}
```

在這個示例中，我們定義了一個名為 `Point` 的結構體，並使用 `#[derive(Clone)]` 屬性自動生成 `Clone` trait 的實現。然後，我們創建了一個 `Point` 實例，並使用 `clone` 方法來克隆它，從而創建了一個新的具有相同值的對象。

總之，`Clone` trait 允許你在需要時複製對象，以避免移動語義，並確保你有一個原始對象的副本，而不是共享同一份數據。這對於某些應用程序中的數據管理和共享非常有用。

### 17.2.4 `Copy` Trait

`Copy` 是 Rust 中的一個特殊的 trait，用於表示類型具有 "複製語義"（copy semantics）。這意味著當將一個值賦值給另一個變量時，不會發生所有權轉移，而是會創建值的一個精確副本。因此，複製類型的變量之間的賦值操作不會導致原始值變得不可用。以下是有關 `Copy` trait 的詳細解釋：

1. **`Copy` Trait 的定義**：
   - `Copy` trait 定義如下：`pub trait Copy {}`。
   - 它沒有任何方法，只是一個標記 trait，用於表示實現了該 trait 的類型可以進行復制操作。

2. **複製語義**：
   - 複製語義意味著當你將一個 `Copy` 類型的值賦值給另一個變量時，實際上是對內存中的原始數據進行了一份拷貝，而不是將所有權從一個變量轉移到另一個變量。
   - 這意味著原始值和新變量都擁有相同的數據，它們是完全獨立的。修改其中一個不會影響另一個。

3. **`Clone` 與 `Copy` 的區別**：
   - `Clone` trait 允許你實現自定義的克隆邏輯，通常涉及深度複製內部數據，因此它的操作可能會更昂貴。
   - `Copy` trait 用於類型，其中克隆操作可以通過簡單的位拷貝完成，因此更高效。默認情況下，標量類型（如整數、浮點數、布爾值等）和元組（包含只包含 `Copy` 類型的元素）都實現了 `Copy`。

4. **`Copy` 的自動實現**：
   - 所有標量類型（例如整數、浮點數、布爾值）、元組（只包含 `Copy` 類型的元素）以及實現了 `Copy` 的結構體都自動實現了 `Copy`。
   - 對於自定義類型，如果類型的所有字段都實現了 `Copy`，那麼該類型也可以自動實現 `Copy`。

下面是一個示例，演示了 `Copy` 類型的使用：

```rust
fn main() {
    let x = 5;  // 整數是 Copy 類型
    let y = x;  // 通過複製語義創建 y，x 仍然有效

    println!("x: {}", x);  // 仍然可以訪問 x 的值
    println!("y: {}", y);
}
```

在這個示例中，整數是 `Copy` 類型，因此將 `x` 賦值給 `y` 時，實際上是創建了 `x` 的一個拷貝，而不是將 `x` 的所有權轉移到 `y`。因此，`x` 和 `y` 都可以獨立訪問它們的值。

總之，`Copy` trait 表示類型具有複製語義，這使得在賦值操作時不會發生所有權轉移，而是創建一個值的副本。這對於標量類型和某些結構體類型非常有用，因為它們可以在不涉及所有權的情況下進行復制。不過需要注意，如果類型包含不支持 `Copy` 的字段，那麼整個類型也無法實現 `Copy`。

以下是關於 `Clone` 和 `Copy` 的比較表格，包括適用場景和適用的類型：

| 特徵    | 描述                                                     | 適用場景                                                     | 適用類型                                                     |
| ------- | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Clone` | 允許創建一個類型的副本，通常涉及深度複製內部數據。       | 當需要對類型進行自定義的克隆操作時，或者類型包含非 `Copy` 字段時。 | **自定義類型**，包括具有非 `Copy` 字段的類型。               |
| `Copy`  | 表示類型具有複製語義，複製操作是通過簡單的位拷貝完成的。 | 當只需要進行簡單的值複製，不需要自定義克隆邏輯時。           | **標量類型（整數、浮點數、布爾值等）、元組（只包含 `Copy` 類型的元素）、實現了 `Copy` 的結構體**。 |

注意：

- 對於 `Clone`，你可以實現自定義的克隆邏輯，通常需要深度複製內部數據，因此它的操作可能會更昂貴。
- 對於 `Copy`，複製操作可以通過簡單的位拷貝完成，因此更高效。
- `Clone` 和 `Copy` trait 不是互斥的，某些類型可以同時實現它們，但大多數情況下只需要實現其中一個。
- 標量類型（如整數、浮點數、布爾值）通常是 `Copy` 類型，因為它們可以通過位拷貝複製。
- 自定義類型通常需要實現 `Clone`，除非它們包含只有 `Copy` 類型的字段。

根據你的需求和類型的特性，你可以選擇實現 `Clone` 或讓類型自動實現 `Copy`（如果適用）。

### 17.2.5 `Hash` Trait

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

#[derive(Debug)]
struct User {
    id: u32,
    username: String,
}

impl Hash for User {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.username.hash(state);
    }
}

fn main() {
    let user = User { id: 1, username: "user123".to_string() };

    let mut hasher = DefaultHasher::new();
    user.hash(&mut hasher);

    println!("Hash value: {}", hasher.finish());
} // 執行後會返回 "Hash value: 11664658372174354745"
```

這個示例演示瞭如何使用 `Hash` trait 來計算自定義結構體 `User` 的哈希值。

6. `Default` Trait：

```rust
#[derive(Default)]
struct Settings {
    width: u32,
    height: u32,
    title: String,
}

fn main() {
    let default_settings = Settings::default();
    println!("{:?}", default_settings);
}
```

在這個示例中，我們使用 `Default` trait 來創建一個數據類型的默認實例。

7. `Debug` Trait：

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person = Person { name: "Alice".to_string(), age: 30 };
    println!("Person: {:?}", person);
}
```

這個示例演示瞭如何使用 `Debug` trait 和 `{:?}` 格式化器來格式化一個值。

## 17.3 迭代器 (Iterator Trait)

迭代器（Iterator Trait）是 Rust 中用於迭代集合元素的標準方法。它是一個非常強大和通用的抽象，用於處理數組、向量、哈希表等不同類型的集合。迭代器使你能夠以統一的方式遍歷和處理這些集合的元素。

比如作者鄉下的家中養了18條小狗，需要向客人挨個介紹，作者就可以使用迭代器來遍歷和處理狗的集合，就像下面的示例一樣：

```rust
// 定義一個狗的結構體
struct Dog {
    name: String,
    breed: String,
}

fn main() {
    // 創建一個狗的集合，使用十八羅漢的名字命名
    let dogs = vec![
        Dog { name: "張飛".to_string(), breed: "吉娃娃".to_string() },
        Dog { name: "關羽".to_string(), breed: "貴賓犬".to_string() },
        Dog { name: "劉備".to_string(), breed: "柴犬".to_string() },
        Dog { name: "趙雲".to_string(), breed: "邊境牧羊犬".to_string() },
        Dog { name: "馬超".to_string(), breed: "比熊犬".to_string() },
        Dog { name: "黃忠".to_string(), breed: "拉布拉多".to_string() },
        Dog { name: "呂布".to_string(), breed: "杜賓犬".to_string() },
        Dog { name: "貂蟬".to_string(), breed: "傑克羅素梗".to_string() },
        Dog { name: "王異".to_string(), breed: "雪納瑞".to_string() },
        Dog { name: "諸葛亮".to_string(), breed: "比格犬".to_string() },
        Dog { name: "龐統".to_string(), breed: "波士頓梗".to_string() },
        Dog { name: "法正".to_string(), breed: "西高地白梗".to_string() },
        Dog { name: "孫尚香".to_string(), breed: "蘇格蘭梗".to_string() },
        Dog { name: "周瑜".to_string(), breed: "鬥牛犬".to_string() },
        Dog { name: "大喬".to_string(), breed: "德國牧羊犬".to_string() },
        Dog { name: "小喬".to_string(), breed: "邊境牧羊犬".to_string() },
        Dog { name: "黃月英".to_string(), breed: "西施犬".to_string() },
        Dog { name: "孟獲".to_string(), breed: "比格犬".to_string() },
    ];

    // 創建一個迭代器，用於遍歷狗的集合
    let mut dog_iterator = dogs.iter();

    // 使用 for 循環遍歷迭代器並打印每隻狗的信息
    println!("遍歷狗的集合：");
    for dog in &dogs {
        println!("名字: {}, 品種: {}", dog.name, dog.breed);
    }

    // 使用 take 方法提取前兩隻狗並打印
    println!("\n提取前兩隻狗：");
    for dog in dog_iterator.clone().take(2) {
        println!("名字: {}, 品種: {}", dog.name, dog.breed);
    }

    // 使用 skip 方法跳過前兩隻狗並打印剩下的狗的信息
    println!("\n跳過前兩隻狗後的狗：");
    for dog in dog_iterator.skip(2) {
        println!("名字: {}, 品種: {}", dog.name, dog.breed);
    }
}

```

在這個示例中，我們定義了一個名為 `Dog` 的結構體，用來表示狗的屬性。然後，我們創建了一個包含狗對象的向量 `dogs`。接下來，我們使用 `iter()` 方法將它轉換成一個迭代器，並使用 `for` 循環遍歷整個迭代器，使用 `take` 方法提取前兩隻狗，並使用 `skip` 方法跳過前兩隻狗來進行迭代。與之前一樣，我們在使用 `take` 和 `skip` 方法後，使用 `clone()` 創建了新的迭代器以便重新使用。

## 17.4 超級特性(Super Trait)

Rust 中的超級特性（Super Trait）是一種特殊的 trait，它是其他多個 trait 的超集。它可以用來表示一個 trait 包含或繼承了其他多個 trait 的所有功能，從而允許你以更抽象的方式來處理多個 trait 的實現。超級特性使得代碼更加模塊化、可複用和抽象化。

超級特性的語法很簡單，只需在 trait 定義中使用 `+` 運算符來列出該 trait 繼承的其他 trait 即可。例如：

```rust
trait SuperTrait: Trait1 + Trait2 + Trait3 {
    // trait 的方法定義
}
```

這裡，`SuperTrait` 是一個超級特性，它繼承了 `Trait1`、`Trait2` 和 `Trait3` 這三個 trait 的所有方法和功能。

好的，讓我們將上面的示例構建為某封神題材遊戲的角色，一個能夠上天入地的角色，哪吒三太子：

```rust
// 定義三個 trait：Flight、Submersion 和 Superpower
trait Flight {
    fn fly(&self);
}

trait Submersion {
    fn submerge(&self);
}

trait Superpower {
    fn use_superpower(&self);
}

// 定義一個超級特性 Nezha，繼承了 Flight、Submersion 和 Superpower 這三個 trait
trait Nezha: Flight + Submersion + Superpower {
    fn introduce(&self) {
        println!("我是哪吒三太子！");
    }

    fn describe_weapon(&self);
}

// 實現 Flight、Submersion 和 Superpower trait
struct NezhaCharacter;
impl Flight for NezhaCharacter {
    fn fly(&self) {
        println!("哪吒在天空翱翔，駕馭風火輪飛行。");
    }
}

impl Submersion for NezhaCharacter {
    fn submerge(&self) {
        println!("哪吒可以潛入水中，以蓮花根和寶蓮燈為助力。");
    }
}

impl Superpower for NezhaCharacter {
    fn use_superpower(&self) {
        println!("哪吒擁有火尖槍、風火輪和寶蓮燈等神器，可以操控火焰和風，戰勝妖魔。");
    }
}

// 實現 Nezha trait
impl Nezha for NezhaCharacter {
    fn describe_weapon(&self) {
        println!("哪吒的法寶包括火尖槍、風火輪和寶蓮燈。");
    }
}

fn main() {
    let nezha = NezhaCharacter;
    nezha.introduce();
    nezha.fly();
    nezha.submerge();
    nezha.use_superpower();
    nezha.describe_weapon();
}

```

**執行結果：**

```text
我是哪吒三太子！
哪吒在天空翱翔，駕馭風火輪飛行。
哪吒可以潛入水中，以蓮花根和寶蓮燈為助力。
哪吒擁有火尖槍、風火輪和寶蓮燈等神器，可以操控火焰和風，戰勝妖魔。
哪吒的法寶包括火尖槍、風火輪和寶蓮燈。


```

在這個主題中，我們定義了三個 trait：`Flight`、`Submersion` 和 `Superpower`，然後定義了一個超級特性 `Nezha`，它繼承了這三個 trait。最後，我們為 `NezhaCharacter` 結構體實現了這三個 trait，並且還實現了 `Nezha` trait。通過這種方式，我們創建了一個能夠上天入地並擁有超能力的角色，即哪吒。

# Chapter 18 - 創建自定義宏

在計算機編程中，宏（Macro）是一種元編程技術，它允許程序員編寫用於生成代碼的代碼。宏通常被用於簡化重複性高的任務，自動生成代碼片段，或者創建領域特定語言（DSL）的擴展，以簡化特定任務的編程。

在Rust中，我們可以用`macro_rules!`創建自定義的宏。自定義宏允許你編寫自己的代碼生成器，以在編譯時生成代碼。以下是`macro_rules!`的基本語法和一些詳解：

```rust
macro_rules! my_macro {
    // 規則1
    ($arg1:expr, $arg2:expr) => {
        // 宏展開時執行的代碼
        println!("Argument 1: {:?}", $arg1);
        println!("Argument 2: {:?}", $arg2);
    };
    // 規則2
    ($arg:expr) => {
        // 單個參數的情況
        println!("Only one argument: {:?}", $arg);
    };
    // 默認規則
    () => {
        println!("No arguments provided.");
    };
}
```

上面的代碼定義了一個名為`my_macro`的宏，它有三個不同的規則。每個規則由`=>`分隔，規則本身以模式（pattern）和展開代碼（expansion code）組成。下面是對這些規則的解釋：

1. 第一個規則：`($arg1:expr, $arg2:expr) => { ... }`
   - 這個規則匹配兩個表達式作為參數，並將它們打印出來。

2. 第二個規則：`($arg:expr) => { ... }`
   - 這個規則匹配單個表達式作為參數，並將它打印出來。

3. 第三個規則：`() => { ... }`
   - 這是一個默認規則，如果沒有其他規則匹配，它將被用於展開。

現在，讓我們看看如何使用這個自定義宏：

```rust
fn main() {
    my_macro!(42); // 調用第二個規則，打印 "Only one argument: 42"
    
    my_macro!(10, "Hello"); // 調用第一個規則，打印 "Argument 1: 10" 和 "Argument 2: "Hello"
    
    my_macro!(); // 調用默認規則，打印 "No arguments provided."
}
```

在上述示例中，我們通過`my_macro!`來調用自定義宏，根據傳遞的參數數量和類型，宏會選擇匹配的規則來展開並執行相應的代碼。

總結一下，`macro_rules!`可以用於創建自定義宏，你可以定義**多個規則來匹配不同的輸入模式**，並在展開時執行相應的代碼。這使得Rust中的宏非常強大，可以用於**代碼複用**(Code reuse)和**元編程**(Metaprogramming)。

### 補充學習：元編程(Metaprogramming)

元編程，又稱超編程，是一種計算機編程的方法，它允許程序操作或生成其他程序，或者在編譯時執行一些通常在運行時完成的工作。這種編程方法可以提高編程效率和程序的靈活性，因為它允許程序**動態地生成和修改代碼**，而無需手動編寫每一行代碼。如在Unix Shell中：

1. **代碼生成：** 在元編程中，程序可以生成代碼片段或整個程序。這對於自動生成重複性高的代碼非常有用。例如，在Shell腳本中，你可以使用循環來生成一系列命令，而不必手動編寫每個命令。

```bash
for i in {1..10}; do
  echo "This is iteration $i"
done
```

2. **模板引擎：** 元編程還可用於創建通用模板，根據不同的輸入數據自動生成特定的代碼或文檔。這對於動態生成網頁內容或配置文件非常有用。

```bash
#!/bin/bash
cat <<EOF > config.txt
ServerName $server_name
Port $port
EOF
```

我們也可以使用Rust的元編程工具來執行這類任務。Rust有一個強大的宏系統，可以用於生成代碼和進行元編程。以下是與之前的Shell示例相對應的Rust示例：

1. **代碼生成：** 在Rust中，你可以使用宏來生成代碼片段。

```rust
macro_rules! generate_code {
    ($count:expr) => {
        for i in 1..=$count {
            println!("This is iteration {}", i);
        }
    };
}

fn main() {
    generate_code!(10);
}
```

2. **模板引擎：** 在Rust中，你可以使用宏來生成配置文件或其他文檔。

```rust
macro_rules! generate_config {
    ($server_name:expr, $port:expr) => {
        format!("ServerName {}\nPort {}", $server_name, $port)
    };
}

fn main() {
    let server_name = "example.com";
    let port = 8080;
    let config = generate_config!(server_name, port);
    println!("{}", config);
}
```

### 案例：用宏來計算一組金融時間序列的平均值

現在讓我們來進入實戰演練，下面是一個用於量化金融的簡單Rust宏的示例。這個宏用於計算一組金融時間序列的平均值，並將其用於簡單的均線策略。

首先，讓我們定義一個包含金融時間序列的結構體：

```rust
struct TimeSeries {
    data: Vec<f64>,
}

impl TimeSeries {
    fn new(data: Vec<f64>) -> Self {
        TimeSeries { data }
    }
}
```

接下來，我們將創建一個自定義宏，用於計算平均值並執行均線策略：

```rust
macro_rules! calculate_average {
    ($ts:expr) => {
        {
            let sum: f64 = $ts.data.iter().sum();
            let count = $ts.data.len() as f64;
            sum / count
        }
    };
}

macro_rules! simple_moving_average_strategy {
    ($ts:expr, $period:expr) => {
        {
            let avg = calculate_average!($ts);
            let current_value = $ts.data.last().unwrap();
            
            if *current_value > avg {
                "Buy"
            } else {
                "Sell"
            }
        }
    };
}
```

上述代碼中，我們創建了兩個宏：

1. `calculate_average!($ts:expr)`：這個宏計算給定時間序列`$ts`的平均值。

2. `simple_moving_average_strategy!($ts:expr, $period:expr)`：這個宏使用`calculate_average!`宏計算平均值，並根據當前值與平均值的比較生成簡單的"Buy"或"Sell"策略信號。

現在，讓我們看看如何使用這些宏：

```rust
fn main() {
    let prices = vec![100.0, 110.0, 120.0, 130.0, 125.0];
    let time_series = TimeSeries::new(prices);

    let period = 3;

    let signal = simple_moving_average_strategy!(time_series, period);

    println!("Signal: {}", signal);
}
```

在上述示例中，我們創建了一個包含價格數據的時間序列`time_series`，並使用`simple_moving_average_strategy!`宏來生成交易信號。如果最後一個價格高於平均值，則宏將生成"Buy"信號，否則生成"Sell"信號。

這只是一個簡單的示例，展示瞭如何使用自定義宏來簡化量化金融策略的實現。在實際的金融應用中，你可以使用更復雜的數據處理和策略規則。但這個示例演示瞭如何使用Rust的宏系統來增強代碼的可讀性和可維護性。

# Chapter 19 - 時間處理

在Rust中進行時間處理通常涉及使用標準庫中的`std::time`模塊。這個模塊提供了一些結構體和函數，用於獲取、表示和操作時間。

以下是一些關於在Rust中進行時間處理的詳細信息：

## 19.1 系統時間交互

要獲取當前時間，可以使用`std::time::SystemTime`結構體和`SystemTime::now()`函數。

```rust
use std::time::{SystemTime};

fn main() {
    let current_time = SystemTime::now();
    println!("Current time: {:?}", current_time);
}
```

**執行結果：**

```text
Current time: SystemTime { tv_sec: 1694870535, tv_nsec: 559362022 }
```

## 19.2 時間間隔和時間運算

在Rust中，時間間隔通常由`std::time::Duration`結構體表示，它用於表示一段時間的長度。

```rust
use std::time::Duration;

fn main() {
    let duration = Duration::new(5, 0); // 5秒
    println!("Duration: {:?}", duration);
}
```

  **執行結果：**

```text
Duration: 5s
```

 時間間隔是可以直接拿來運算的，rust支持例如添加或減去時間間隔，以獲取新的時間點。

```rust
use std::time::{SystemTime, Duration};

fn main() {
    let current_time = SystemTime::now();
    let five_seconds = Duration::new(5, 0);

    let new_time = current_time + five_seconds;
    println!("New time: {:?}", new_time);
}
```

 **執行結果：**

```text
New time: SystemTime { tv_sec: 1694870769, tv_nsec: 705158112 }
```

## 19.3 格式化時間

若要將時間以特定格式顯示為字符串，可以使用`chrono`庫。

```rust
use chrono::{DateTime, Utc, Duration, Datelike};

fn main() {
    // 獲取當前時間
    let now = Utc::now();

    // 將時間格式化為字符串
    let formatted_time = now.format("%Y-%m-%d %H:%M:%S").to_string();
    println!("Formatted Time: {}", formatted_time);

    // 解析字符串為時間
    let datetime_str = "1983 Apr 13 12:09:14.274 +0800"; //注意rust最近更新後，這個輸入string需要帶時區信息。此處為+800代表東八區。
    let format_str = "%Y %b %d %H:%M:%S%.3f %z";
    let dt = DateTime::parse_from_str(datetime_str, format_str).unwrap();
     println!("Parsed DateTime: {}", dt);

    // 進行日期和時間的計算
    let two_hours_from_now = now + Duration::hours(2);
    println!("Two Hours from Now: {}", two_hours_from_now);

    // 獲取日期的部分
    let date = now.date_naive();
    println!("Date: {}", date);

    // 獲取時間的部分
    let time = now.time();
    println!("Time: {}", time);

    // 獲取星期幾
    let weekday = now.weekday();
    println!("Weekday: {:?}", weekday);
}
```

**執行結果：**

```text
Formatted Time: 2023-09-16 13:47:10
Parsed DateTime: 1983-04-13 12:09:14.274 +08:00
Two Hours from Now: 2023-09-16 15:47:10.882155748 UTC
Date: 2023-09-16
Time: 13:47:10.882155748
Weekday: Sat
```



這些是Rust中進行時間處理的基本示例。你可以根據具體需求使用這些功能來執行更高級的時間操作，例如計算時間差、定時任務、處理時間戳等等。要了解更多關於時間處理的細節，請查閱Rust官方文檔以及`chrono`庫的文檔。

## 19.4 時差處理

`chrono` 是 Rust 中用於處理日期和時間的庫。它提供了強大的日期時間處理功能，可以幫助你執行各種日期和時間操作，包括時差的處理。下面詳細解釋如何使用 `chrono` 來處理時差。

首先，你需要在 Rust 項目中添加 `chrono` 庫的依賴。在 `Cargo.toml` 文件中添加以下內容：

```toml
[dependencies]
chrono = "0.4"
chrono-tz = "0.8.3"
```

接下來，讓我們從一些常見的日期和時間操作開始，以及如何處理時差：

```rust
use chrono::{DateTime, Utc, TimeZone};  
use chrono_tz::{Tz, Europe::Berlin, America::New_York};  
  
fn main() {  
    // 獲取當前時間，使用UTC時區  
    let now_utc = Utc::now();  
    println!("Current UTC Time: {}", now_utc);  
  
    // 使用特定時區獲取當前時間  
    let now_berlin: DateTime<Tz> = Utc::now().with_timezone(&Berlin);  
    println!("Current Berlin Time: {}", now_berlin);  
  
    let now_new_york: DateTime<Tz> = Utc::now().with_timezone(&New_York);  
    println!("Current New York Time: {}", now_new_york);  
  
    // 時區之間的時間轉換  
    let berlin_time = now_utc.with_timezone(&Berlin);  
    let new_york_time = berlin_time.with_timezone(&New_York);  
    println!("Berlin Time in New York: {}", new_york_time);  
  
    // 獲取時區信息  
    let berlin_offset = Berlin.offset_from_utc_datetime(&now_utc.naive_utc());  
    println!("Berlin Offset: {:?}", berlin_offset);  
  
    let new_york_offset = New_York.offset_from_utc_datetime(&now_utc.naive_utc());  
    println!("New York Offset: {:?}", new_york_offset);  
}

```

**執行結果**：

```text
Current UTC Time: 2023-09-17 01:15:56.812663350 UTC
Current Berlin Time: 2023-09-17 03:15:56.812673617 CEST
Current New York Time: 2023-09-16 21:15:56.812679483 EDT
Berlin Time in New York: 2023-09-16 21:15:56.812663350 EDT
Berlin Offset: CEST
New York Offset: EDT
```

### 補充學習： `with_timezone` 方法

在 `chrono` 中，你可以使用 `with_timezone` 方法將日期時間對象轉換為常見的時區。以下是一些常見的時區及其在 `chrono` 中的表示和用法：

1. **UTC（協調世界時）：**

   ```rust
   use chrono::{DateTime, Utc};
   
   let utc: DateTime<Utc> = Utc::now();
   ```

   在 `chrono` 中，`Utc` 是用於表示協調世界時的類型。

2. **本地時區：**

   `chrono` 可以使用操作系統的本地時區。你可以使用 `Local` 來表示本地時區。

   ```rust
   use chrono::{DateTime, Local};
   
   let local: DateTime<Local> = Local::now();
   ```

3. **其他時區：**

   如果你需要表示其他時區，可以使用 `chrono-tz` 庫。這個庫擴展了 `chrono`，使其支持更多的時區。

   首先，你需要將 `chrono-tz` 添加到你的 `Cargo.toml` 文件中：

   ```toml
   [dependencies]
   chrono-tz = "0.8"
   ```

   創造一個datetime，然後把它轉化成一個帶時區信息的datetime：

   ```rust
   use chrono::{TimeZone, NaiveDate};
   use chrono_tz::Africa::Johannesburg;
   
   let naive_dt = NaiveDate::from_ymd(2038, 1, 19).and_hms(3, 14, 08);
   let tz_aware = Johannesburg.from_local_datetime(&naive_dt).unwrap();
   assert_eq!(tz_aware.to_string(), "2038-01-19 03:14:08 SAST");
   ```

   

請注意，`chrono-tz` 可以讓我們表示更多的時區，但也會增加項目的依賴和複雜性。根據你的需求，你可以選擇使用 `Utc`、`Local` 還是 `chrono-tz` 中的特定時區類型。

如果只需處理常見的 UTC 和本地時區，那麼 `Utc` 和 `Local` 就足夠了。如果需要更多的時區支持，可以考慮使用 `chrono-tz`，[[chrono-tz官方文檔] ](https://docs.rs/chrono-tz/latest/chrono_tz/#modules	)中詳細列有可用的時區的模塊和常量，有需要可以移步查詢。

# Chapter 20 - Redis、爬蟲、交易日庫

## 20.1 Redis入門、安裝和配置

Redis是一個開源的內存內(In-Memory)數據庫，它可以用於存儲和管理數據，通常用作緩存、消息隊列、會話存儲等用途。Redis支持多種數據結構，包括字符串、列表、集合、有序集合和哈希表。它以其高性能、低延遲和持久性存儲特性而聞名，適用於許多應用場景。

大多數主流的Linux發行版都提供了Redis的軟件包。

#### 在Ubuntu/Debian上安裝

你可以從官方的`packages.redis.io` APT存儲庫安裝最新的穩定版本的Redis。

先決條件

如果你正在運行一個非常精簡的發行版（比如Docker容器），你可能需要首先安裝`lsb-release`、`curl`和`gpg`。

```bash
sudo apt install lsb-release curl gpg
```

將該存儲庫添加到`apt`索引中，然後更新索引，最後進行安裝：

```bash
curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

sudo apt-get update
sudo apt-get install redis
```

#### 在Manjaro/Archlinux上安裝

```shell
sudo pacman -S redis
```

#### 用戶界面

除了傳統的CLI以外，Redis還提供了圖形化前端 [RedisInsight](https://redis.com/redis-enterprise/redis-insight/) 方便直觀查看：

![img.png](/home/arthur/Documents/Cookbook-for-Rustaceans-in-Finance/img.png)

下面在20.3小節我們會演示如何為通過Rust和Redis的Rust客戶端來插入圖示的這對鍵值對。

## 20.2 常見Redis數據結構類型

為了將Redis的不同數據結構類型與相應的命令詳細敘述並創建一個示例表格，我將按照以下格式為你展示：

**數據結構類型**：描述該數據結構類型的特點和用途。

**常用命令示例**：列出該數據結構類型的一些常用命令示例，包括命令和用途。

**示例表格**：創建一個示例表格，包含數據結構類型、命令示例以及示例值。

現在讓我們開始：

#### 字符串（Strings）

**數據結構類型**：
字符串是Redis中最簡單的數據結構，可以存儲文本、二進制數據等。

**常用命令示例**：

- 設置字符串值：`SET key value`
- 獲取字符串值：`GET key`

**示例表格**：

| 數據結構類型 | 命令示例               | 示例值                        |
| ------------ | ---------------------- | ----------------------------- |
| 字符串       | `SET username "Alice"` | Key: username, Value: "Alice" |
| 字符串       | `GET username`         | 返回值: "Alice"               |

#### 哈希表（Hashes）

**數據結構類型**：
哈希表是一個鍵值對的集合，適用於存儲多個字段和對應的值。

**常用命令示例**：

- 設置哈希表字段：`HSET key field value`
- 獲取哈希表字段值：`HGET key field`

**示例表格**：

| 數據結構類型 | 命令示例                  | 示例值                                  |
| ------------ | ------------------------- | --------------------------------------- |
| 哈希表       | `HSET user:id name "Bob"` | Key: user:id, Field: name, Value: "Bob" |
| 哈希表       | `HGET user:id name`       | 返回值: "Bob"                           |

#### 列表（Lists）

**數據結構類型**：
列表是一個有序的字符串元素集合，可用於實現隊列或棧。

**常用命令示例**：

- 從列表左側插入元素：`LPUSH key value1 value2 ...`
- 獲取列表範圍內的元素：`LRANGE key start stop`

**示例表格**：

| 數據結構類型 | 命令示例              | 示例值                      |
| ------------ | --------------------- | --------------------------- |
| 列表         | `LPUSH queue "item1"` | Key: queue, Values: "item1" |
| 列表         | `LRANGE queue 0 -1`   | 返回值: ["item1"]           |

#### 集合（Sets）

**數據結構類型**：
集合是一個無序的字符串元素集合，可用於存儲唯一值。

**常用命令示例**：

- 添加元素到集合：`SADD key member1 member2 ...`
- 獲取集合中的所有元素：`SMEMBERS key`

**示例表格**：

| 數據結構類型 | 命令示例                       | 示例值                                    |
| ------------ | ------------------------------ | ----------------------------------------- |
| 集合         | `SADD employees "Alice" "Bob"` | Key: employees, Members: ["Alice", "Bob"] |
| 集合         | `SMEMBERS employees`           | 返回值: ["Alice", "Bob"]                  |

#### 有序集合（Sorted Sets）

**數據結構類型**：
有序集合類似於集合，但每個元素都關聯一個分數，用於排序元素。

**常用命令示例**：

- 添加元素到有序集合：`ZADD key score1 member1 score2 member2 ...`
- 獲取有序集合範圍內的元素：`ZRANGE key start stop`

**示例表格**：

| 數據結構類型 | 命令示例                       | 示例值                                        |
| ------------ | ------------------------------ | --------------------------------------------- |
| 有序集合     | `ZADD leaderboard 100 "Alice"` | Key: leaderboard, Score: 100, Member: "Alice" |
| 有序集合     | `ZRANGE leaderboard 0 -1`      | 返回值: ["Alice"]                             |

這些示例展示了不同類型的Redis數據結構以及常用的命令示例，你可以根據你的具體需求和應用場景使用適當的數據結構和命令來構建你的Redis數據庫。在20.3的例子中，我們會用一個最簡單的字符串例子來做示範。

## 20.3 在Rust中使用Redis客戶端

將Redis與Rust結合使用可以提供高性能和安全的數據存儲和處理能力。下面詳細說明如何將Redis與Rust配合使用：

1. 安裝Redis客戶端庫：
   首先，你需要在Rust項目中引入Redis客戶端庫，最常用的庫是`redis-rs`，可以在Cargo.toml文件中添加以下依賴項：

   ```toml
   [dependencies]
   redis = "0.23"
   tokio = { version = "1.29.1", features = ["full"] }
   ```

   然後運行`cargo build`以安裝庫。

2. 創建Redis連接
   使用Redis客戶端庫連接到Redis服務器。以下是一個示例：

   ```rust
   use redis::Commands;
   
   #[tokio::main]
   async fn main() -> redis::RedisResult<()> {
       let redis_url = "redis://:@127.0.0.1:6379/0";
       let client = redis::Client::open(redis_url)?;
       let mut con = client.get_connection()?;
   
       // 執行Redis命令
       let _: () = con.set("my_key", "my_value")?;
       let result: String = con.get("my_key")?;
   
       println!("Got value: {}", result);
   
       Ok(())
   }
   ```

   這個示例首先創建了一個Redis客戶端，然後與服務器建立連接，並執行了一些基本的操作。

   **詳細解釋一下Redis鏈接的構成：**

   1. `redis://`：這部分指示了使用的協議，通常是 `redis://` 或 `rediss://`（如果你使用了加密連接）。

   2. `:@`：這部分表示用戶名和密碼，但在你的示例中是空白的，因此沒有提供用戶名和密碼。如果需要密碼驗證，你可以在 `:` 後面提供密碼，例如：`redis://password@127.0.0.1:6379/0`。

   3. `127.0.0.1`：這部分是 Redis 服務器的主機地址，指定了 Redis 服務器所在的機器的 IP 地址或主機名。在示例中，這是本地主機的 IP 地址，也就是 `127.0.0.1`，表示連接到本地的 Redis 服務器。

   4. `6379`：這部分是 Redis 服務器的端口號，指定了連接到 Redis 服務器的端口。默認情況下，Redis 使用 `6379` 端口。

   5. `/0`：這部分是 Redis 數據庫的索引，Redis 支持多個數據庫，默認情況下有 16 個數據庫，索引從 `0` 到 `15`。在示例中，索引為 `0`，表示連接到數據庫索引為 0 的數據庫。

   綜合起來，你的示例 Redis 連接字符串表示連接到本地 Redis 服務器（`127.0.0.1`）的默認端口（`6379`），並選擇索引為 0 的數據庫，沒有提供用戶名和密碼進行認證。如果你的 Redis 服務器有密碼保護，你需要提供相應的密碼來進行連接。

3. 處理錯誤：
   在Rust中，處理錯誤非常重要，因此需要考慮如何處理Redis操作可能出現的錯誤。在上面的示例中，我們使用了RedisResult來包裹返回結果，然後用`?`來處理Redis操作可能引發的錯誤。你可以根據你的應用程序需求來處理這些錯誤，例如，記錄日誌或採取其他適當的措施。

4. 使用異步編程：
   如果你需要處理大量的併發操作或需要高性能，可以考慮使用Rust的異步編程庫，如Tokio，與異步Redis客戶端庫配合使用。這將允許你以非阻塞的方式執行Redis操作，以提高性能。

5. 定期清理過期數據：
   Redis支持過期時間設置，你可以在將數據存儲到Redis中時為其設置過期時間。在Rust中，你可以編寫定期任務來清理過期數據，以確保Redis中的數據不會無限增長。

總之，將Redis與Rust配合使用可以為你提供高性能、安全的數據存儲和處理解決方案。通過使用Rust的強類型和內存安全性，以及Redis的速度和功能，你可以構建可靠的應用程序。當然，在實際應用中，還需要考慮更多複雜的細節，如連接池管理、性能優化和錯誤處理策略，以確保應用程序的穩定性和性能。

## 20.4 爬蟲

Rust 是一種圖靈完備的系統級編程語言，當然也可以用於編寫網絡爬蟲。Rust 具有出色的性能、內存安全性和併發性，這些特性使其成為編寫高效且可靠的爬蟲的理想選擇。以下是 Rust 爬蟲的簡要介紹：

### 20.4.1 爬蟲的基本原理

爬蟲是一個自動化程序，用於從互聯網上的網頁中提取數據。爬蟲的基本工作流程通常包括以下步驟：

1. 發送 HTTP 請求：爬蟲會向目標網站發送 HTTP 請求，以獲取網頁的內容。

2. 解析 HTML：爬蟲會解析 HTML 文檔，從中提取有用的信息，如鏈接、文本內容等。

3. 存儲數據：爬蟲將提取的數據存儲在本地數據庫、文件或內存中，以供後續分析和使用。

4. 遍歷鏈接：爬蟲可能會從當前頁面中提取鏈接，並遞歸地訪問這些鏈接，以獲取更多的數據。

### 20.4.2. Rust 用於爬蟲的優勢

Rust 在編寫爬蟲時具有以下優勢：

- **內存安全性**：Rust 的借用檢查器和所有權系統可以防止常見的內存錯誤，如空指針和數據競爭。這有助於減少爬蟲程序中的錯誤和漏洞。

- **併發性**：Rust 內置了併發性支持，可以輕鬆地創建多線程和異步任務，從而提高爬蟲的效率。

- **性能**：Rust 的性能非常出色，可以快速地下載和處理大量數據。

- **生態系統**：Rust 生態系統中有豐富的庫和工具，可用於處理 HTTP 請求、HTML 解析、數據庫訪問等任務。

- **跨平臺**：Rust 可以編寫跨平臺的爬蟲，運行在不同的操作系統上。

### 20.4.3. Rust 中用於爬蟲的庫和工具

在 Rust 中，有一些庫和工具可用於編寫爬蟲，其中一些包括：

- **reqwest**：用於發送 HTTP 請求和處理響應的庫。

- **scraper**：用於解析和提取 HTML 數據的庫。

- **tokio**：用於異步編程的庫，適用於高性能爬蟲。

- **serde**：用於序列化和反序列化數據的庫，有助於處理從網頁中提取的結構化數據。

- **rusqlite** 或 **diesel**：用於數據庫存儲的庫，可用於存儲爬取的數據。

- **regex**：用於正則表達式匹配，有時可用於從文本中提取數據。

### 20.4.4. 爬蟲的倫理和法律考慮

在編寫爬蟲時，務必遵守網站的 `robots.txt` 文件和相關法律法規。爬蟲應該尊重網站的隱私政策和使用條款，並避免對網站造成不必要的負擔。爬蟲不應濫用網站資源或進行未經授權的數據收集。

總之，Rust 是一種強大的編程語言，可用於編寫高性能、可靠和安全的網絡爬蟲。在編寫爬蟲程序時，始終要遵循最佳實踐和倫理準則，以確保合法性和道德性。

### 補充學習：序列化和反序列化

在Rust中，JSON（JavaScript Object Notation）是一種常見的數據序列化和反序列化格式，通常用於在不同的應用程序和服務之間交換數據。Rust提供了一些庫來處理JSON數據的序列化和反序列化操作，其中最常用的是`serde`庫。

以下是如何在Rust中進行JSON序列化和反序列化的簡要介紹：

1. **添加serde庫依賴：** 首先，你需要在項目的`Cargo.toml`文件中添加`serde`和`serde_json`依賴，因為`serde_json`是serde的JSON支持庫。在`Cargo.toml`中添加如下依賴：

```toml
[dependencies]
serde = { version = "1.0.188", features = ["derive"] }
serde_json = "1.0"
```

然後，在你的Rust代碼中導入`serde`和`serde_json`：

```rust
use serde::{Serialize, Deserialize};
```

2. **定義結構體：** 如果你要將自定義類型序列化為JSON，你需要在結構體上實現`Serialize`和`Deserialize` trait。例如：

```rust
#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u32,
}
```

3. **序列化為JSON：** 使用`serde_json::to_string`將Rust數據結構序列化為JSON字符串：

```rust
fn main() {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };

    let json_string = serde_json::to_string(&person).unwrap();
    println!("{}", json_string);
}
```

4. **反序列化：** 使用`serde_json::from_str`將JSON字符串反序列化為Rust數據結構：

```rust
fn main() {
    let json_string = r#"{"name":"Bob","age":25}"#;
    
    let person: Person = serde_json::from_str(json_string).unwrap();
    println!("Name: {}, Age: {}", person.name, person.age);
}
```

這只是一個簡單的介紹，你可以根據具體的需求進一步探索`serde`和`serde_json`庫的功能，以及如何處理更復雜的JSON數據結構和場景。這些庫提供了強大的工具，使得在Rust中進行JSON序列化和反序列化變得非常方便。

### 案例：在Redis中構建中國大陸交易日庫

這個案例演示瞭如何使用 Rust 編寫一個簡單的爬蟲，從指定的網址獲取中國大陸的節假日數據，然後將數據存儲到 Redis 數據庫中。這個案例涵蓋了許多 Rust 的核心概念，包括異步編程、HTTP 請求、JSON 解析、錯誤處理以及與 Redis 交互等。

```rust
use anyhow::{anyhow, Error as AnyError}; // 導入`anyhow`庫中的`anyhow`和`Error`別名為`AnyError`
use redis::{Commands}; // 導入`redis`庫中的`Commands`
use reqwest::Client as ReqwestClient; // 導入`reqwest`庫中的`Client`別名為`ReqwestClient`
use serde::{Deserialize, Serialize}; // 導入`serde`庫中的`Deserialize`和`Serialize`
use std::error::Error; // 導入標準庫中的`Error`

#[derive(Debug, Serialize, Deserialize)]
struct DayType {
    date: i32, // 定義一個結構體`DayType`，用於表示日期
}

#[derive(Debug, Serialize, Deserialize)]
struct HolidaysType {
    cn: Vec<DayType>, // 定義一個結構體`HolidaysType`，包含一個日期列表
}

#[derive(Debug, Serialize, Deserialize)]
struct CalendarBody {
    holidays: Option<HolidaysType>, // 定義一個結構體`CalendarBody`，包含一個可選的`HolidaysType`字段
}

// 異步函數，用於獲取API數據並存儲到Redis
async fn store_calendar_to_redis() -> Result<(), AnyError> {
    let url = "http://pc.suishenyun.net/peacock/api/h5/festival"; // API的URL
    let client = ReqwestClient::new(); // 創建一個Reqwest HTTP客戶端
    let response = client.get(url).send().await?; // 發送HTTP GET請求並等待響應
    let body_s = response.text().await?; // 讀取響應體的文本數據

    // 將API響應的JSON字符串解析為CalendarBody結構體
    let cb: CalendarBody = match serde_json::from_str(&body_s) {
        Ok(cb) => cb, // 解析成功，得到CalendarBody結構體
        Err(e) => return Err(anyhow!("Failed to parse JSON string: {}", e)), // 解析失敗，返回錯誤
    };

    if let Some(holidays) = cb.holidays { // 如果存在節假日數據
        let days = holidays.cn; // 獲取日期列表
        let mut dates = Vec::new(); // 創建一個空的日期向量

        for day in days {
            dates.push(day.date as u32); // 將日期添加到向量中，轉換為u32類型
        }

        let redis_url = "redis://:@127.0.0.1:6379/0"; // Redis服務器的連接URL
        let client = redis::Client::open(redis_url)?; // 打開Redis連接
        let mut con = client.get_connection()?; // 獲取Redis連接

        // 將每個日期添加到Redis集合中
        for date in &dates {
            let _: usize = con.sadd("holidays_set", date.to_string()).unwrap(); // 添加日期到Redis集合
        }

        Ok(()) // 操作成功，返回Ok(())
    } else {
        Err(anyhow!("No holiday data found.")) // 沒有節假日數據，返回錯誤
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // 調用存儲數據到Redis的函數
    if let Err(err) = store_calendar_to_redis().await {
        eprintln!("Error: {}", err); // 打印錯誤信息
    } else {
        println!("Holiday data stored in Redis successfully."); // 打印成功消息
    }

    Ok(()) // 返回Ok(())
}

```

**案例要點：**

1. **依賴庫引入：** 為了實現這個案例，首先引入了一系列 Rust 的外部依賴庫，包括 `reqwest` 用於發送 HTTP 請求、`serde` 用於 JSON 序列化和反序列化、`redis` 用於與 Redis 交互等等。這些庫提供了必要的工具和功能，以便從網站獲取數據並將其存儲到 Redis 中。
2. **數據結構定義：** 在案例中定義了三個結構體，`DayType`、`HolidaysType` 和 `CalendarBody`，用於將 JSON 數據解析為 Rust 數據結構。這些結構體的字段對應於 JSON 數據中的字段，用於存儲從網站獲取的數據。
3. **異步函數和錯誤處理：** 使用 `async` 關鍵字定義了一個異步函數 `store_calendar_to_redis`，該函數負責執行以下操作：
   - 發送 HTTP 請求以獲取節假日數據。
   - 解析 JSON 數據。
   - 將數據存儲到 Redis 數據庫中。 這個函數還演示了 Rust 中的錯誤處理機制，使用 `Result` 返回可能的錯誤，以及如何使用 `anyhow` 庫來創建自定義錯誤信息。
4. **Redis 數據存儲：** 使用 `redis` 庫連接到 Redis 數據庫，並使用 `sadd` 命令將節假日數據存儲到名為 `holidays_set` 的 Redis 集合中。
5. **main函數：** `main` 函數是程序的入口點。它使用 `tokio` 框架的 `#[tokio::main]` 屬性宏來支持異步操作。在 `main` 函數中，我們調用了 `store_calendar_to_redis` 函數來執行節假日數據的存儲操作。如果存儲過程中出現錯誤，錯誤信息將被打印到標準錯誤流中；否則，將打印成功消息。

#  Chapter 21 - 線程和管道

在 Rust 中，線程之間的通信通常通過管道（channel）來實現。管道提供了一種安全且高效的方式，允許一個線程將數據發送給另一個線程。下面詳細介紹如何在 Rust 中使用線程和管道進行通信。

首先，你需要在你的 `Cargo.toml` 文件中添加 `std` 庫的依賴，因為線程和管道是標準庫的一部分。

```toml
[dependencies]
```

接下來，我們將逐步介紹線程和管道通信的過程：

### 創建線程和管道

首先，導入必要的模塊：

```rust
use std::thread;
use std::sync::mpsc;
```

然後，創建一個管道，其中一個線程用於發送數據，另一個線程用於接收數據：

```rust
fn main() {
    // 創建一個管道，sender 發送者，receiver 接收者
    let (sender, receiver) = mpsc::channel();

    // 啟動一個新線程，用於發送數據
    thread::spawn(move || {
        let data = "Hello, from another thread!";
        sender.send(data).unwrap();
    });

    // 主線程接收來自管道的數據
    let received_data = receiver.recv().unwrap();
    println!("Received: {}", received_data);
}
```

### 線程間數據傳遞

在上述代碼中，我們創建了一個管道，然後在新線程中發送數據到管道中，主線程接收數據。請注意以下幾點：

- `mpsc::channel()` 創建了一個多生產者、單消費者管道（multiple-producer, single-consumer），這意味著你可以在多個線程中發送數據到同一個管道，但只能有一個線程接收數據。

- `thread::spawn()` 用於創建一個新線程。`move` 關鍵字用於將所有權轉移給新線程，以便在閉包中使用 `sender`。

- `sender.send(data).unwrap();` 用於將數據發送到管道中。`unwrap()` 用於處理發送失敗的情況。

- `receiver.recv().unwrap();` 用於接收來自管道的數據。這是一個阻塞操作，如果沒有數據可用，它將等待直到有數據。

### 錯誤處理

在實際應用中，你應該對線程和管道通信的可能出現的錯誤進行適當的處理，而不僅僅是使用 `unwrap()`。例如，你可以使用 `Result` 類型來處理錯誤，以確保程序的健壯性。

這就是在 Rust 中使用線程和管道進行通信的基本示例。通過這種方式，你可以在多個線程之間安全地傳遞數據，這對於併發編程非常重要。請根據你的應用場景進行適當的擴展和錯誤處理。

### 案例：多交易員-單一市場交互

以下是一個簡化的量化金融多線程通信的最小可行示例（MWE）。在這個示例中，我們將模擬一個簡單的股票交易系統，其中多個線程代表不同的交易員並與市場交互。線程之間使用管道進行通信，以模擬訂單的發送和交易的確認。

```rust
use std::sync::mpsc;
use std::thread;

// 定義一個訂單結構
struct Order {
    trader_id: u32,
    symbol: String,
    quantity: u32,
}

fn main() {
    // 創建一個市場和交易員之間的管道
    let (market_tx, trader_rx) = mpsc::channel();

    // 啟動多個交易員線程
    let num_traders = 3;
    for trader_id in 0..num_traders {
        let market_tx_clone = market_tx.clone();
        thread::spawn(move || {
            // 模擬交易員創建併發送訂單
            let order = Order {
                trader_id,
                symbol: format!("STK{}", trader_id),
                quantity: (trader_id + 1) * 100,
            };
            market_tx_clone.send(order).unwrap();
        });
    }

    // 主線程模擬市場接收和處理訂單
    for _ in 0..num_traders {
        let received_order = trader_rx.recv().unwrap();
        println!(
            "Received order: Trader {}, Symbol {}, Quantity {}",
            received_order.trader_id, received_order.symbol, received_order.quantity
        );

        // 模擬市場執行交易併發送確認
        let confirmation = format!(
            "Order for Trader {} successfully executed",
            received_order.trader_id
        );
        println!("Market: {}", confirmation);
    }
}
```

在這個示例中：

1. 我們定義了一個簡單的 `Order` 結構來表示訂單，包括交易員 ID、股票代碼和數量。

2. 我們創建了一個市場和交易員之間的管道，市場通過 `market_tx` 向交易員發送訂單，交易員通過 `trader_rx` 接收市場的確認。

3. 我們啟動了多個交易員線程，每個線程模擬一個交易員創建訂單並將其發送到市場。

4. 主線程模擬市場接收訂單、執行交易和發送確認。

請注意，這只是一個非常簡化的示例，實際的量化金融系統要複雜得多。在真實的應用中，你需要更復雜的訂單處理邏輯、錯誤處理和線程安全性保證。此示例僅用於演示如何使用多線程和管道進行通信以模擬量化金融系統中的交易流程。

#  Chapter 22 -  文件處理

在 Rust 中進行文件處理涉及到多個標準庫模塊和方法，主要包括 `std::fs`、`std::io` 和 `std::path`。下面詳細解釋如何在 Rust 中進行文件的創建、讀取、寫入和刪除等操作。

## 22.1 基礎操作

### 22.1.1 打開和創建文件

要在 Rust 中打開或創建文件，可以使用 `std::fs` 模塊中的方法。以下是一些常用的方法：

1. 打開文件以讀取內容：

   ```rust
   use std::fs::File;
   use std::io::Read;
   
   fn main() -> std::io::Result<()> {
       let mut file = File::open("file.txt")?;
       let mut contents = String::new();
       file.read_to_string(&mut contents)?;
       println!("File contents: {}", contents);
       Ok(())
   }
   ```

   上述代碼中，我們使用 `File::open` 打開文件並讀取其內容。

2. 創建新文件並寫入內容：

   ```rust
   use std::fs::File;
   use std::io::Write;
   
   fn main() -> std::io::Result<()> {
       let mut file = File::create("new_file.txt")?;
       file.write_all(b"Hello, Rust!")?;
       Ok(())
   }
   ```

   這裡，我們使用 `File::create` 創建一個新文件並寫入內容。

### 22.1.2 文件路徑操作

在進行文件處理時，通常需要處理文件路徑。`std::path` 模塊提供了一些實用方法來操作文件路徑，例如連接路徑、獲取文件名等。

```rust
use std::path::Path;

fn main() {
    let path = Path::new("folder/subfolder/file.txt");
    
    // 獲取文件名
    let file_name = path.file_name().unwrap().to_str().unwrap();
    println!("File name: {}", file_name);
    
    // 獲取文件的父目錄
    let parent_dir = path.parent().unwrap().to_str().unwrap();
    println!("Parent directory: {}", parent_dir);
    
    // 連接路徑
    let new_path = path.join("another_file.txt");
    println!("New path: {:?}", new_path);
}
```

### 22.1.3 刪除文件

要刪除文件，可以使用 `std::fs::remove_file` 方法。

```rust
use std::fs;

fn main() -> std::io::Result<()> {
    fs::remove_file("file_to_delete.txt")?;
    Ok(())
}
```

### 22.1.4 複製和移動文件

要複製和移動文件，可以使用 `std::fs::copy` 和 `std::fs::rename` 方法。

```rust
use std::fs;

fn main() -> std::io::Result<()> {
    // 複製文件
    fs::copy("source.txt", "destination.txt")?;
    
    // 移動文件
    fs::rename("old_name.txt", "new_name.txt")?;
    
    Ok(())
}
```

### 22.1.5 目錄操作

要處理目錄，你可以使用 `std::fs` 模塊中的方法。例如，要列出目錄中的文件和子目錄，可以使用 `std::fs::read_dir`。

```rust
use std::fs;

fn main() -> std::io::Result<()> {
    for entry in fs::read_dir("directory")? {
        let entry = entry?;
        let path = entry.path();
        println!("{}", path.display());
    }
    
    Ok(())
}
```

以上是 Rust 中常見的文件處理操作的示例。要在實際應用中進行文件處理，請確保適當地處理可能發生的錯誤，以保證代碼的健壯性。文件處理通常需要處理文件打開、讀取、寫入、關閉以及錯誤處理等情況。 Rust 提供了強大而靈活的標準庫來支持這些操作。

### 案例：遞歸刪除不符合要求的文件夾

這是一個經典的案例，現在我有一堆以期貨代碼所寫為名的文件夾，裡麵包含著期貨公司為我提供的大量的csv格式的原始數據（30 TB左右）， 如果我只想從中遴選出某幾個我需要的品種的文件夾，剩下的所有的文件都刪除掉，我該怎麼辦呢？。現在來一起看一下這是怎麼實現的：

```rust
// 引入需要的外部庫
use rayon::iter::ParallelBridge;
use rayon::iter::ParallelIterator;
use regex::Regex;
use std::sync::{Arc};
use std::fs;

// 定義一個函數，用於刪除文件夾中不符合要求的文件夾
fn delete_folders_with_regex(
    top_folder: &str,         // 頂層文件夾的路徑
    keep_folders: Vec<&str>, // 要保留的文件夾名稱列表
    name_regex: Arc<Regex>,  // 正則表達式對象，用於匹配文件夾名稱
) {
    // 內部函數：遞歸刪除文件夾
    fn delete_folders_recursive(
        folder: &str,               // 當前文件夾的路徑
        keep_folders: Arc<Vec<&str>>, // 要保留的文件夾名稱列表（原子引用計數指針）
        name_regex: Arc<Regex>,    // 正則表達式對象（原子引用計數指針）
    ) {
        // 使用fs::read_dir讀取文件夾內容，返回一個Result
        if let Ok(entries) = fs::read_dir(folder) {
            // 使用Rayon庫的並行迭代器處理文件夾內容
            entries.par_bridge().for_each(|entry| {
                if let Ok(entry) = entry {
                    let path = entry.path();
                    if path.is_dir() {
                        if let Some(folder_name) = path.file_name() {
                            if let Some(folder_name_str) = folder_name.to_str() {
                                let name_regex_ref = &*name_regex;
                                // 使用正則表達式檢查文件夾名稱是否匹配
                                if name_regex_ref.is_match(folder_name_str) {
                                    if !keep_folders.contains(&folder_name_str) {
                                        println!("刪除文件夾: {:?}", path);
                                        // 遞歸地刪除文件夾及其內容
                                        fs::remove_dir_all(&path)
                                            .expect("Failed to delete folder");
                                    } else {
                                        println!("保留文件夾: {:?}", path);
                                    }
                                } else {
                                    println!("忽略非字母文件夾: {:?}", path);
                                }
                            }
                        }
                        // 遞歸進入子文件夾
                        delete_folders_recursive(
                            &path.display().to_string(),
                            keep_folders.clone(),
                            name_regex.clone()
                        );
                    }
                }
            });
        }
    }

    // 使用fs::metadata檢查頂層文件夾的元數據信息
    if let Ok(metadata) = fs::metadata(top_folder) {
        if metadata.is_dir() {
            println!("開始處理文件夾: {:?}", top_folder);
            // 將要保留的文件夾名稱列表包裝在Arc中，以進行多線程訪問
            let keep_folders = Arc::new(keep_folders);
            // 調用遞歸函數開始刪除操作
            delete_folders_recursive(top_folder, keep_folders.clone(), name_regex);
        } else {
            println!("頂層文件夾不是一個目錄: {:?}", top_folder);
        }
    } else {
        println!("頂層文件夾不存在: {:?}", top_folder);
    }
}

// 定義要保留的文件夾名稱列表。此處使用了static聲明，是因為這個列表在整個程序的運行時都是不變的。
static KEEP_FOLDERS: [&str; 11] = ["SR", "CF", "OI", "TA", "M", "P", "AG", "CU", "AL", "ZN", "RU"];

fn main() {
    let top_folder = "/opt/sample"; // 指定頂層文件夾的路徑
    // 將靜態數組轉換為可變Vec以傳遞給函數
    let keep_folders: Vec<&str> = KEEP_FOLDERS.iter().map(|s| *s).collect();
    // 創建正則表達式對象，用於匹配文件夾名稱
    let name_regex = Regex::new("^[a-zA-Z]+$").expect("Invalid regex pattern");
    // 將正則表達式包裝在Arc中以進行多線程訪問
    let name_regex = Arc::new(name_regex);

    // 調用主要函數以啟動文件夾刪除操作
    delete_folders_with_regex(top_folder, keep_folders, name_regex);
}


```

讓我們詳細講解這個腳本的各個步驟：

1. 首先導入所需的庫：

   ```rust
   use rayon::iter::ParallelBridge;
   use rayon::iter::ParallelIterator;
   use regex::Regex;
   use std::sync::Arc;
   use std::fs;
   ```

   首先，我們導入了所需的外部庫。`rayon` 用於併發迭代，`regex` 用於處理正則表達式，`std::sync::Arc` 用於創建原子引用計數指針。

2. 創建 `delete_folders_with_regex` 函數：

   ```rust
   fn delete_folders_with_regex(
       top_folder: &str,
       keep_folders: Vec<&str>,
       name_regex: Arc<Regex>,
   ) -> Result<(), Box<dyn std::error::Error>> {
   ```

   我們定義了一個名為 `delete_folders_with_regex` 的函數，它接受頂層文件夾路徑 `top_folder`、要保留的文件夾名稱列表 `keep_folders` 和正則表達式對象 `name_regex` 作為參數。該函數返回一個 `Result`，以處理潛在的錯誤。

3. 創建 `delete_folders_recursive` 函數：

   ```rust
   fn delete_folders_recursive(
       folder: &str,
       keep_folders: &Arc<Vec<&str>>,
       name_regex: &Arc<Regex>,
   ) -> Result<(), Box<dyn std::error::Error>> {
   ```

   在 `delete_folders_with_regex` 函數內部，我們定義了一個名為 `delete_folders_recursive` 的內部函數，用於遞歸地刪除文件夾。它接受當前文件夾路徑 `folder`、要保留的文件夾名稱列表 `keep_folders` 和正則表達式對象 `name_regex` 作為參數。同樣，它返回一個 `Result`。

4. 使用 `fs::read_dir` 讀取文件夾內容：

   ```rust
   for entry in fs::read_dir(folder)? {
   ```

   我們使用 `fs::read_dir` 函數讀取了當前文件夾 `folder` 中的內容，並通過 `for` 循環迭代每個條目 `entry`。

5. 檢查條目是否是文件夾：

   ```rust
   let entry = entry?;
   let path = entry.path();
   if path.is_dir() {
   ```

   我們首先檢查 `entry` 是否是一個文件夾，因為只有文件夾才需要進一步處理，文件是會被忽略的。

6. 獲取文件夾名稱並匹配正則表達式：

   ```rust
   if let Some(folder_name) = path.file_name() {
       if let Some(folder_name_str) = folder_name.to_str() {
           if name_regex.is_match(folder_name_str) {
   ```

   我們獲取了文件夾的名稱，並將其轉換為字符串形式。然後，我們使用正則表達式 `name_regex` 來檢查文件夾名稱是否與要求匹配。

7. 根據匹配結果執行操作：

   ```rust
   if !keep_folders.contains(&folder_name_str) {
       println!("刪除文件夾: {:?}", path);
       fs::remove_dir_all(&path)?;
   } else {
       println!("保留文件夾: {:?}", path);
   }
   ```

   如果文件夾名稱匹配了正則表達式，並且不在要保留的文件夾列表中，我們會刪除該文件夾及其內容。否則，我們只是輸出一條信息告訴用戶，在命令行聲明該文件夾將被保留。

8. 遞歸進入子文件夾：

   ```rust
   delete_folders_recursive(
       &path.join(&folder_name_str),
       keep_folders,
       name_regex
   )?;
   ```

   最後，我們遞歸地調用 `delete_folders_recursive` 函數，進入子文件夾進行相同的處理。

9. 處理頂層文件夾：

   ```rust
   let metadata = fs::metadata(top_folder)?;
   if metadata.is_dir() {
       println!("開始處理文件夾: {:?}", top_folder);
       let keep_folders = Arc::new(keep_folders);
       delete_folders_recursive(top_folder, &keep_folders, &name_regex)?;
   } else {
       println!("頂層文件夾不是一個目錄: {:?}", top_folder);
   }
   ```

   在 `main` 函數中，我們首先檢查頂層文件夾是否存在，如果存在，就調用 `delete_folders_recursive` 函數開始處理。我們還使用 `Arc` 包裝了要保留的文件夾名稱列表，以便多線程訪問。

10. 完成處理並返回 `Result`：

    ```rust
    Ok(())
    ```

    最後，我們返回 `Ok(())` 表示操作成功完成。

    

### 補充學習：元數據

元數據可以理解為有關文件或文件夾的基本信息，就像一個文件的"身份證"一樣。這些信息包括文件的大小、創建時間、修改時間以及文件是不是文件夾等。比如，你可以通過元數據知道一個文件有多大，是什麼時候創建的，是什麼時候修改的，還能知道這個東西是不是一個文件夾。

在Rust中，元數據（metadata）通常不包括實際的數據內容。元數據提供了關於文件或實體的屬性和特徵的信息。我們可以使用 `std::fs::metadata` 函數來獲取文件或目錄的元數據。

```rust
use std::fs;

fn main() -> Result<(), std::io::Error> {
    let file_path = "example.txt"; 

    // 獲取文件的元數據
    let metadata = fs::metadata(file_path)?;

    // 獲取文件大小（以字節為單位）
    let file_size = metadata.len();
    println!("文件大小: {} 字節", file_size);

    // 獲取文件創建時間和修改時間
    let created = metadata.created()?;
    let modified = metadata.modified()?;

    println!("創建時間: {:?}", created);
    println!("修改時間: {:?}", modified);

    // 檢查文件類型
    if metadata.is_file() {
        println!("這是一個文件。");
    } else if metadata.is_dir() {
        println!("這是一個目錄。");
    } else {
        println!("未知文件類型。");
    }

    Ok(())
}
```

在這個示例中，我們首先使用 `fs::metadata` 獲取文件 "example.txt" 的元數據，然後從元數據中提取文件大小、創建時間、修改時間以及文件類型信息。

一般操作文件系統的函數可能會返回 `Result` 類型，所以你需要處理潛在的錯誤。在示例中，我們使用了 `?` 運算符來傳播錯誤，但你也可以選擇使用模式匹配等其他方式來自定義地處理錯誤。

### 補充學習：正則表達式

現在我們再來學一下正則表達式。正則表達式是一種強大的文本模式匹配工具，它允許你以非常靈活的方式搜索、匹配和操作文本數據。使用前我們有一些基礎的概念和語法需要了解。下面是正則表達式的一些基礎知識：

#### 1. 字面量字符匹配

正則表達式的最基本功能是匹配字面量字符。這意味著你可以創建一個正則表達式來精確匹配輸入文本中的特定字符。例如，正則表達式 `cat` 當然會匹配輸入文本中的 "cat"。

#### 2. 元字符

正則表達式時中的元字符是具有特殊含義的。以下是一些常見的元字符以及它們的說明和示例：

1. `.`（點號）：匹配除換行符外的任意字符。

   - 示例：正則表達式 `c.t` 匹配 "cat"、"cut"、"cot" 等。

2. `*`（星號）：匹配前一個元素零次或多次。

   - 示例：正則表達式 `ab*c` 匹配 "ac"、"abc"、"abbc" 等。

3. `+`（加號）：匹配前一個元素一次或多次。

   - 示例：正則表達式 `ca+t` 匹配 "cat"、"caat"、"caaat" 等。

4. `?`（問號）：匹配前一個元素零次或一次。

   - 示例：正則表達式 `colou?r` 匹配 "color" 或 "colour"。

5. `|`（豎線）：表示或，用於在多個模式之間選擇一個。

   - 示例：正則表達式 `apple|banana` 匹配 "apple" 或 "banana"。

6. `[]`（字符類）：用於定義一個字符集合，匹配方括號內的任何一個字符。

   - 示例：正則表達式 `[aeiou]` 匹配任何一個元音字母。

7. `()`（分組）：用於將多個模式組合在一起，以便對它們應用量詞或其他操作。

   - 示例：正則表達式 `(ab)+` 匹配 "ab"、"abab"、"ababab" 等。

這些元字符允許你創建更復雜的正則表達式模式，以便更靈活地匹配文本。你可以根據需要組合它們來構建各種不同的匹配規則，用於解決文本處理中的各種任務。

#### 3. 字符類

字符類用於匹配一個字符集合中的任何一個字符。例如，正則表達式 `[aeiou]` 會匹配任何一個元音字母（a、e、i、o 或 u）。

#### 4. 量詞

量詞是正則表達式中用於指定模式重複次數的重要元素。它們允許你定義匹配重複出現的字符或子模式的規則。以下是常見的量詞以及它們的說明和示例：

1. `*`（星號）：匹配前一個元素零次或多次。

   - 示例：正則表達式 `ab*c` 匹配 "ac"、"abc"、"abbc" 等。因為 `*` 表示零次或多次，所以它允許前一個字符 `b` 重複出現或完全缺失。

2. `+`（加號）：匹配前一個元素一次或多次。

   - 示例：正則表達式 `ca+t` 匹配 "cat"、"caat"、"caaat" 等。因為 `+` 表示一次或多次，所以它要求前一個字符 `a` 至少出現一次。

3. `?`（問號）：匹配前一個元素零次或一次。

   - 示例：正則表達式 `colou?r` 匹配 "color" 或 "colour"。因為 `?` 表示零次或一次，所以它允許前一個字符 `u` 的存在是可選的。

4. `{n}`：精確匹配前一個元素 n 次。

   - 示例：正則表達式 `x{3}` 匹配 "xxx"。它要求前一個字符 `x` 出現精確三次。

5. `{n,}`：至少匹配前一個元素 n 次。

   - 示例：正則表達式 `d{2,}` 匹配 "dd"、"ddd"、"dddd" 等。它要求前一個字符 `d` 至少出現兩次。

6. `{n,m}`：匹配前一個元素 n 到 m 次。

   - 示例：正則表達式 `[0-9]{2,4}` 匹配 "123"、"4567"、"89" 等。它要求前一個元素是數字，且出現的次數在 2 到 4 次之間。

這些量詞使你能夠定義更靈活的匹配規則，以適應不同的文本模式。

#### 5. 錨點

錨點是正則表達式中用於指定匹配發生的位置的特殊字符。它們不匹配字符本身，而是匹配輸入文本的特定位置。以下是一些常見的錨點以及它們的說明和示例：

1. `^`（脫字符）：匹配輸入文本的開頭。

   - 示例：正則表達式 `^Hello` 匹配以 "Hello" 開頭的文本。例如，它匹配 "Hello, world!" 中的 "Hello"，但不匹配 "Hi, Hello" 中的 "Hello"，因為後者不在文本開頭。

2. `$`（美元符號）：匹配輸入文本的結尾。

   - 示例：正則表達式 `world!$` 匹配以 "world!" 結尾的文本。例如，它匹配 "Hello, world!" 中的 "world!"，但不匹配 "world! Hi" 中的 "world!"，因為後者不在文本結尾。

3. `\b`（單詞邊界）：匹配單詞的邊界，通常用於確保匹配的**單詞完整**而不是**部分匹配**。
   - 示例：正則表達式 `\bapple\b` 匹配 "apple" 這個完整的單詞。它匹配 "I have an apple." 中的 "apple"，但不匹配 "apples" 中的 "apple"。

4. `\B`（非單詞邊界）：匹配非單詞邊界的位置。

- 示例：正則表達式 `\Bcat\B` 匹配 "The cat sat on the cat." 中的第二個 "cat"，因為它位於兩個非單詞邊界之間，而不是單詞 "cat" 的一部分。

這些錨點允許你精確定位匹配發生的位置，在處理文本中的單詞、行首、行尾等情況時非常有用。

#### 6. 轉義字符

如果你需要匹配元字符本身，你可以使用反斜槓 `\` 進行轉義。例如，要匹配 `.`，你可以使用 `\.`。

#### 7. 示例

以下是一些正則表達式的示例：

- 匹配一個郵箱地址：`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}`
- 匹配一個日期（例如，YYYY-MM-DD）：`[0-9]{4}-[0-9]{2}-[0-9]{2}`
- 匹配一個URL：`https?://[^\s/$.?#].[^\s]*`

#### 8. 工具和資源

為了學習和測試正則表達式，你可以使用在線工具或本地開發工具，例如：

- [regex101.com](https://regex101.com/): 一個在線正則表達式測試和學習工具，提供可視化解釋和測試功能。
- Rust 的 regex 庫文檔：Rust 的 regex 庫提供了強大的正則表達式支持，你可以查閱其文檔以學習如何在 Rust 中使用正則表達式。

正則表達式是一個強大的文本處理工具，它可以在文本中查找、匹配和操作複雜的模式。掌握正則表達式可以幫助你處理各種文本和文件處理任務。

> ####  



