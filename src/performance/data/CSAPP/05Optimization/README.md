<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第五章：優化程序性能](#%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD)
  - [5.1 編譯器優化的能力和侷限](#51-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B%E5%92%8C%E5%B1%80%E9%99%90)
  - [5.2 表示程序性能](#52-%E8%A1%A8%E7%A4%BA%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD)
  - [5.3 程序示例](#53-%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B)
  - [5.4 消除循環的低效率](#54-%E6%B6%88%E9%99%A4%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%8E%E6%95%88%E7%8E%87)
  - [5.5 減少過程調用](#55-%E5%87%8F%E5%B0%91%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8)
  - [5.6 消除不必要的內存引用](#56-%E6%B6%88%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8)
  - [5.7 理解現代處理器](#57-%E7%90%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8)
    - [整體操作](#%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C)
    - [功能單元的性能](#%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83%E7%9A%84%E6%80%A7%E8%83%BD)
    - [處理器操作的抽象模型](#%E5%A4%84%E7%90%86%E5%99%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B)
  - [5.8 循環展開](#58-%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80)
  - [5.9 提高並行性](#59-%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7)
  - [5.10 優化合並代碼的結果小結](#510-%E4%BC%98%E5%8C%96%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%9C%E5%B0%8F%E7%BB%93)
  - [5.11 一些限制因素](#511-%E4%B8%80%E4%BA%9B%E9%99%90%E5%88%B6%E5%9B%A0%E7%B4%A0)
  - [5.12 理解內存性能](#512-%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD)
  - [5.13 應用：性能提高技術](#513-%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF)
  - [5.14 確認和消除性能瓶頸](#514-%E7%A1%AE%E8%AE%A4%E5%92%8C%E6%B6%88%E9%99%A4%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 第五章：優化程序性能

關於程序的性能優化：
- 首先優化程序性能的前提一定是程序要正確執行。
- 某些時候程序對性能會有要求，比如要求實時處理的程序，如果性能不夠那麼程序就是不可用的。
- 對於運算量非常大需要按小時按天來計算運行時間的程序，即使20%的性能優化都會帶來顯著的改善。
- 編寫高效的程序需要注意幾點：
    - 選擇適當的算法和數據結構。
    - 編寫出編譯器能夠有效優化以轉化為高效可執行代碼的源碼。
    - 在特定場景中，針對運算量特別大但是可以劃分成多個部分，並且這些部分在多核、多處理器上並行執行的程序也可以優化程序性能。併發編程將在第12章介紹。
- 第一點是數據結構與算法的內容，這裡不討論。
- 理解第二點的前提是理解編譯器的能力和侷限性。
- 代碼性能優化通常都會降低代碼的可維護性和可讀性等，我們需要在性能和可維護性之間做出平衡。
- 所以通常來說代碼具體細節的優化都是在功能完成之後才進行的。（過早優化是萬惡之源！）
- 現代的編譯器已經具備各種各樣的措施來優化代碼，以產生高效的機器代碼。
- 但即使最好的編譯器也會受到妨礙優化的因素（optimization blocker）的阻礙。
- 程序員必須瞭解到這些東西，並編寫容易優化的代碼，這便是本章的主題。

本章主題：
- 瞭解機器的抽象模型，形象化處理器對執行的執行過程，並利用它來預測程序性能。
- 利用處理器提供的指令級並行，同時執行多條指令，通過降低一個計算不同部分的數據相關，增加並行度。
- 使用代碼剖析程序，測量程序各個部分的性能，幫助優化現實中的大型程序。

## 5.1 編譯器優化的能力和侷限

現代編譯器已經具備非常強大的優化能力：
- 但是某些優化只有在特定場景中才有用，某些時候我們不希望優化（典型情況：調試模式）。
- 編譯器通常會向用戶提供對它們所使用優化的控制，最簡單的控制是指定優化級別，在使用gcc時，可以指定優化級別為`-Og -O1 -O2 -O3`，每個選項都是一系列優化選項的組合，從前往後一次增多。
- 編譯器必須非常小心地對程序只使用**安全**的優化。也就是說必須在所有情況下，優化後程序都能和優化前得到同樣的結果。
- 例子：
```C
void p343_twiddle1(long *xp, long *yp)
{
    *xp += *yp;
    *xp += *yp;
}

void p343_twiddle2(long *xp, long *yp)
{
    *xp += 2 * *yp;
}
```
- 雖然看起來這兩個函數等價，但是需要考慮`xp yp`指向同一位置的情況，此時他們就不等價了，所以無論再高的優化等價前者都沒有被優化為後者。
- 他們的彙編都是：
```x86asm
p343_twiddle1:
	movq	(%rsi), %rax
	addq	(%rdi), %rax
	movq	%rax, (%rdi)
	addq	(%rsi), %rax
	movq	%rax, (%rdi)
	ret
p343_twiddle2:
	movq	(%rsi), %rax
	addq	%rax, %rax
	addq	%rax, (%rdi)
	ret
```
- 這種兩個指針可能指向同一位置的情況稱為**內存別名使用**（memory aliasing）。在只執行安全的優化中，編譯器必須假設不同指針可能指向同一內存。
- 這嚴重妨礙了編譯器的優化，除非我們提供更多的信息和假定，不然編譯器不會進行不安全的優化。即使這兩個指針在程序中不可能指向相同地址，即使這種優化在語義上是安全的，但編譯器也不會知道。
- 考慮下一種情況：
```C
long p343_f();
long p343_func1()
{
    return p343_f() + p343_f() + p343_f() + p343_f();
}
long p343_func2()
{
    return 4 * p343_f();
}
```
- 即使`-O3`也不會將前者優化為後者，因為編譯器不知道調用的`p343_f`是否存在副作用，如果存在副作用，那麼兩者就是不等價的。
- 但是如果在聲明時提供定義：
```C
long p343_f()
{
    return 1;
}
```
- 那麼編譯器就會知道這個函數不會有副作用，那麼甚至能免去計算，直接返回結果。
```x86asm
p343_f:
	movl	$1, %eax
	ret
p343_func1:
	movl	$4, %eax
	ret
p343_func2:
	movl	$4, %eax
	ret
```
- 在編譯期不知道優化所需要的信息時，總是會假定最糟的情況，才去最保守的策略，提供肯定不會出錯的編譯結果。
    - 所以不要總是說編譯器為什麼連XX這麼簡單的情況都不能優化了，分析編譯器為什麼要這麼做，也許你在第一層，而編譯器在第五層。當然編譯器能力再強都是有限的，所以確實可能出現它在第一層的情況。
- 所以是否知道函數的定義也會影響編譯期的優化，編譯器的各種細節優化不勝枚舉，這樣的因素還有很多。我們需要儘可能瞭解它們以編寫出編譯器能夠更好優化的程序。

## 5.2 表示程序性能

這裡引入度量標準——每元素的週期數（Cycles Per Element，CPE），作為表示程序性能的指標。
- 週期表示時鐘週期，比如在4GHz的CPU上，一個時鐘週期就是0.25ns。
- 這裡並不用整個程序運行時間，而是用每個元素的運行週期數。因為通常的算法在一系列元素上的操作。
- 在不同的元素數量上運行算法之後，使用最小二乘法做一個線性擬合，斜率即是每個元素的運行週期數。

## 5.3 程序示例

程序示例略。
- 試驗與優化的方法；反覆嘗試不同方法，進行測量，並檢查彙編代碼表示以確定底層的性能瓶頸。
- 度量標準依然是CPE。

## 5.4 消除循環的低效率

優化循環內代碼的手段：
- 將每輪循環都相同的計算移到循環外。由於編譯器會非常謹慎，不是每次都會進行這種優化，所有某些時候也需要程序員自己手動來移動。
    - 典型例子：循環的終止條件使用`strlen`來計算，並且長度不會在循環中改變，那麼最好移動循環外計算。
- 這樣的例子非常常見，一個成熟的程序員應該在寫每個算法時都估計出其時間複雜度，並嘗試優化到最佳。而更具體的不影響複雜度的優化則可以留到以後來做。

## 5.5 減少過程調用

某些循環內的反覆的簡單函數調用可能會成為性能瓶頸，這時候使用內聯函數，或者直接在循環內展開函數內容可能獲得客觀優化。

## 5.6 消除不必要的內存引用

在循環內部，應儘量消除不必要的內存引用：
- 比如每次循環取出內存位置的值進行計算後寫回。
- 寄存器存取比內存存取更快，如果使用臨時變量並且可以存放到寄存器中的話，效率會高很多。
- 由於可能的內存別名，編譯器可能不會優化這種內存存取，所以使用臨時變量是有意義的。
- 例子：
```C
void p355_f1(int *p, int *a, int n)
{
    for (int i = 0; i < n; ++i)
    {
        *p *= a[i];
    }
}
void p355_f2(int *p, int *a, int n)
{
    int res = *p;
    for (int i = 0; i < n; ++i)
    {
        res *= a[i];
    }
    *p = res;
}
```
- 彙編：
```x86asm
p355_f1:
	testl	%edx, %edx
	jle	.L7
	movq	%rsi, %rax
	movslq	%edx, %rdx
	leaq	(%rsi,%rdx,4), %rcx
.L9:
	movl	(%rdi), %edx      ; read memory in every loop
	imull	(%rax), %edx
	movl	%edx, (%rdi)      ; write memory in every loop
	addq	$4, %rax
	cmpq	%rcx, %rax
	jne	.L9
.L7:
	ret
p355_f2:
	movl	(%rdi), %ecx      ; res in %ecx
	testl	%edx, %edx
	jle	.L12
	movq	%rsi, %rax
	movslq	%edx, %rdx
	leaq	(%rsi,%rdx,4), %rdx
.L13:
	imull	(%rax), %ecx    ; only write register in every loop
	addq	$4, %rax
	cmpq	%rdx, %rax
	jne	.L13
.L12:
	movl	%ecx, (%rdi)
	ret
```

## 5.7 理解現代處理器

前面提到的優化僅僅是消除了妨礙編譯器優化的因素，這些優化都不依賴於目標機器的特性：
- 隨著進一步地優化，我們需要考慮處理器微體系結構的優化，也就是考慮處理器用來執行指令的底層系統設計。
- 這種優化不一定在所有機器上都適用，但是所有處理器體系結構上優化的道理是相同，但是優化的細節可能不同。
- 現代處理器提供了一個看起來是指令順序執行的模型，但是實際上現代處理器普遍採用了亂序發射、流水線等指令級並行的設計，某些設計中，同時甚至可能有100多條指令同時執行。處理器採用一系列精細的機制保證執行結果與順序語義模型完全一致。
- 在工業界中，將（平均）一個週期內可以執行多條指令的處理器成為超標量處理器，（注意不是向量處理器，向量處理器指的是SIMD這種數據級並行，現代處理器大多有向量指令集，這裡不做討論）。

### 整體操作

![](CPU.JPG)
現代微處理器的模型：
- 有兩個部分組成：指令控制單元（Instruction Control Unit，ICU），和執行單元（Execution Unit，EU）。
- 指令控制單元從指令高速緩存讀取指令，進行指令譯碼後把操作發送給執行單元。當程序遇到分支時，現代處理器會採用分支預測技術，取出可能的下一條指令進行執行。分支預測在指令控制單元的取指控制模塊中完成。
- 指令譯碼接收實際的程序指令，將他們轉換為一組基本操作（也稱之為微操作、微指令）。每個微操作完成某個簡單的計算任務：例如兩數相加，從內存讀數據，將數據寫回內存等。在複雜指令集比如X86-64中，一條指令可以被翻譯為多條微操作。
- EU接受來自取指單元的操作，通常每個時鐘週期接收多條操作，這些操作被分派到一組功能單元中，他們會執行實際的操作。
- 其中加載和存儲單元負責讀寫內存，他們通過數據高速緩存來訪問內存。
- 使用投機執行技術來執行指令時（也就是他們是通過分支預測來執行的，並不一定會被執行），最終結果不會被存放到寄存器或者數據內存中，直到處理器能夠確定確實是走這個分支。如果不是走這個分支，那麼結果會被丟棄。
- 分支操作也會被送到EU，用以確定分支預測是否正確。預測錯誤會丟棄結果，導致很大的性能開銷。
- 還有名為算術運算的單元用來執行整數、浮點數的算術運算。
- ICU中，還有名為退役單元（retirement unit）的單元記錄著正在進行的處理，並確保他們遵守機器程序的順序語義。
    - 一旦一條指令完成運行，而且引起這條指令的分支點被確認為預測正確，那麼這條指令就退役了。所有對寄存器的更新也就可以實際執行了。
    - 另一方面如果引起這條指令的分支點預測錯誤，那麼這條指令被清空，丟棄所有計算結果。
    - 任何對程序寄存器的更新只有在退役時才會發生。但是指令間可能會有數據依賴，所以為了加速一條指令到另一條的結果的傳送，許多此類信息是在執行單元之間發生交換的。而不需要指令結束後才發生。【這是上一節處理器設計中數據轉發技術的更精細版本】

### 功能單元的性能

功能單元：
- 在算術運算單元中，有各種各樣的計算單元：整數乘法、加法、除法，浮點數乘法、加法、乘法。
- 我們用兩個指標來刻畫一個計算單元完成計算的總時間：
    - **延遲**（latency）：完成計算所需總時間。
    - **發射時間**（issue time）：兩個連續的同類型運算之間需要的最小週期數。
- 總體來說整數運算快於浮點運算，並且無論整數還是浮點，他們的加法、乘法數倍快於除法操作。
- 憑藉流水線結構，發射時間可能快於延遲。如果沒有流水線結構，那麼發射時間和延遲相等。
- 在處理器中每種計算單元可能存在多套，它們可以同時執行，稱之計算單元的**容量**。
- 表示發射時間的一種更常見方法是這個功能單元的**吞吐量**，定義為**容量/發射時間**，吞吐量越大，平均單位時間能進行的該運算越多。
- 對於特定的CPU來說，計算單元能夠使用的硬件電路資源是有限的，怎麼分配各種計算單元就非常講究。為了獲得整體的最優性能，讓每個計算單元都能最大化利用，CPU設計者必須小心平衡功能單元的數量和他們各自的性能。一般會評估許多不同的基準程序，將大多數資源用於最關鍵的操作。
- 一般來說是整數乘法、浮點乘法和加法分配資源更多，除法相對來說用得更少一些。
- 根據吞吐量可以得到一個程序的理論CPE界限（越低性能越高，所以是下限），原理上來說，這個值是理論最優值，現實中無論如何優化，都只能接近而不能達到或者超過這個界限。（這裡暫不考慮向量指令）。

### 處理器操作的抽象模型

從機器代碼到數據流圖：
- 對於每一個彙編程序，我們都可以繪製出一個數據流圖表示其中數據的流動和依賴關係。不同操作之間的數據相關將會限制他們的執行順序，這些限制最終可以抽象為一條**關鍵路徑**（critical path），這是執行一組機器指令所需週期數的一個下界。
- 在優化時只有降低這條關鍵路徑上的執行週期數才可能真正優化程序性能。
- 至於具體的優化細節，則因具體程序而已。
- 數據流圖只是一種分析手法，並不是形式化的描述。

其他性能因素：
- 數據流中的關鍵路徑只是指明瞭一個執行週期數的下界（性能的上界），現實中的代碼執行是否能到達這個下界則不一定。
- 還會受制於計算單元數量、吞吐量等影響因素影響。

優化程序性能：
- 通過變化程序結構，降低關鍵路徑的運行週期數，增強指令級並行，可以使執行的CPE接近理論CPE界限。

## 5.8 循環展開

循環展開是一種程序變換，通過增加每次迭代計算的元素數量，減少循環的迭代次數，降低分支預測失敗帶來的消耗。

## 5.9 提高並行性

現代處理器擁有很高的指令級並行，通過減少指令間相關性，就可以達到更大程度的指令級並行。

具體手段：
- **多個累積變量**：對於一個可結合和可交換的操作來說，比如整數加法和乘法，可以通過將一組合並運算分割為多個不同部分，最後再合併結果提高性能。比如說循環中計算`acc = a[i] * b[i] + c[i] * d[i]`，那麼可以拆分為`acc0 = a[i] * b[i], acc1 = c[i] * d[i]`，最後結果為`acc0 + acc1`，就可以減少數據相關性，降低了指令數量，提高指令並行度。
- **重新結合變換**：例子循環中的`acc = acc * data[i] * data[i+1]`修改為`acc = acc * (data[i] * data[i+1])`，注意將`i`和`i+1`放到一輪循環中是因為循環展開。這看起來沒有變化，但是先計算`data[i] * data[i+1]`降低了循環變量`i`的數據相關鏈的長度。
- **使用向量指令**：在x86-64指令集中，使用MMX/SSE/AVX等SIMD指令集來在一條指令上操作一組多個數據，從而提高吞吐量。不過不是所有程序都能使用SIMD指令加速。

## 5.10 優化合並代碼的結果小結

略。

## 5.11 一些限制因素

除了上面的正面優化思路，還有一些問題會限制程序性能：
- 寄存器溢出：如果寄存器的使用超過了可用的寄存器數量，就會出現寄存器溢出，導致新的臨時值無寄存器可用，通常他們會被放到棧上，相比起來性能會下降很多。
- 分支預測懲罰：當分支預測邏輯不能正確預測一個分支是否要跳轉時，會有可觀的性能懲罰。
    - 不需要過分關係分支預測懲罰：現代處理器都比較複雜，預測成功的概率比較大。
    - 編寫適用於條件傳送的代碼：可以直接消除分支預測失敗帶來的可能的懲罰。

## 5.12 理解內存性能

下一章將會詳述。

## 5.13 應用：性能提高技術

總結，優化程序的基本策略：
- 高級設計：為問題選擇合適的算法與數據結構，避免使用糟糕複雜度的算法和數據結構。
- 基本編碼原則：避免限制優化的因素，這樣編譯器才能產生高效的代碼。
    - 消除連續的函數調用：可能時將函數移到循環外。
    - 消除不必要的內存引用：引入臨時變量保存中間結果，計算完成後才寫回結果中。
- 低級優化：結構化代碼以利用硬件功能。
    - 展開循環。
    - 多個累積變量、重新結合等技術，提高指令級並行的方法。
    - 用功能性風格編寫條件操作，使得編譯器可以使用條件傳送指令。
- 通常來說，高級設計是首要的必須要考慮的事情，基本編碼原則則可以在長期實踐中加以注意，低級優化則在編碼中並不需要太過關心，最多用在系統性能瓶頸代碼的優化中。
- 最後的最後：一定注意，性能優化的前提一定是程序保持正確性，不要因為性能優化引入錯誤。使用單元測試測試確保優化前優化後功能未發生改變！

## 5.14 確認和消除性能瓶頸

在優化任何程序的性能之前，第一件要做的事情就是測試程序各部分性能，確定性能瓶頸。

最簡單的測試方法是使用代碼剖析程序（code profiler），剖析工具會在源碼中插入測試代碼，在運行程序時為我們確定每一個部分的開銷：
- Unix系統也提供了一個剖析程序GPROF，這個程序會產生兩個信息：
    - 程序每個函數花費了多少CPU時間。
    - 每個函數被調用的次數。
- 使用方法：
    - 程序必須為剖析而編譯和鏈接：加上編譯選項`-pg`。並且我們使用優化選項`-Og`以保證正確追蹤函數調用。
    ```shell
    gcc -Og -pg prog.c -o prog
    ```
    - 像往常一樣執行程序：它運行得會比正常時候慢一些，除此之外唯一的區別就是會產生一個`gmon.out`文件。
    - 使用GPROF程序分析`gmon.out`文件中的數據即可得到各個函數花費時間。
    ```shell
    gprof ./prog
    ```
