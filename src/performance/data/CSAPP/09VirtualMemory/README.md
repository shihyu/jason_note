<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第九章：虛擬內存](#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
  - [9.1 物理和虛擬尋址](#91-%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80)
  - [9.2 地址空間](#92-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)
  - [9.3 虛擬內存作為緩存的工具](#93-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7)
  - [9.4 虛擬內存作為內存管理的工具](#94-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7)
  - [9.5 虛擬內存作為內存保護的工具](#95-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7)
  - [9.6 地址翻譯](#96-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91)
  - [9.7 案例研究：Intel Core i7/Linux](#97-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6intel-core-i7linux)
    - [Intel Core i7地址翻譯](#intel-core-i7%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91)
    - [Linux虛擬內存系統](#linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F)
  - [9.8 內存映射](#98-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84)
    - [共享對象](#%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1)
    - [fork](#fork)
    - [execve](#execve)
    - [使用mmap的用戶級內存映射](#%E4%BD%BF%E7%94%A8mmap%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84)
  - [9.9 動態內存分配](#99-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D)
  - [9.10 垃圾收集](#910-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86)
  - [9.11 C程序中常見的與內存相關的錯誤](#911-c%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 第九章：虛擬內存

為了更有效地隔離進程的內存空間，防止一個進程不小心使用進程的另一個的內存，現代的系統提供了一種對主存的抽象概念，叫做虛擬內存（virtual memory）。
- 虛擬內存是硬件異常、硬件地址翻譯、主存、磁盤文件和系統內核軟件的完美交互，它為每一個進程提供了一個大的、一致的和私有的地址空間。
- 它提供了三個能力：
    - 將主存看做一個存儲在磁盤上的地址空間的高速緩存，在主存中只保存活動區域，並根據需要在磁盤和主存之間來回傳遞數據，通過這種方式，更高效地使用了主存。
    - 為每個進程提供了一致的地址空間，簡化了內存管理。
    - 保護每個進程的地址空間不被其他進程破壞。


虛擬內存是計算機系統中最重要的概念之一，它是對程序員透明、自動工作的，不需要程序員的任何干涉，我們基於以下原因需要關心它：
- 虛擬內存是核心的：虛擬內存在計算機系統的所有層面，在硬件異常、彙編器、鏈接器、加載器、共享對象、文件和進程的設計中扮演重要角色。
- 虛擬內存很強大：虛擬內存給與程序強大的能力，可以創建和銷燬內存片（chunk）、將內存片映射到磁盤文件的某個部分，以及與其他進程共享內存。
- 虛擬內存是危險的：當應用程序引用一個變量、間接引用一個指針或者調用malloc這樣的動態分配程序時，就會和虛擬內存進行交互。引用的了錯誤的內存可能導致段錯誤。

本章主要包含兩部分：理解虛擬內存如何工作，使用和管理虛擬內存。後者建立在前者基礎之上。

## 9.1 物理和虛擬尋址

計算機的主存是一個由M個連續自己大小的單元組成的數組，每個字節都可以通過唯一的**物理地址**訪問。

- 當CPU執行加載指令時，會生成一個物理地址，通過內存總線傳遞給主存。
- 早期的PC使用物理尋址，現在諸如數字信號發生器、嵌入式微控制器之類的系統還會使用這種尋址方式。
- 然而，現代處理器都使用一種叫做虛擬尋址（virtual addressing）的尋址方式。
- CPU通過生成一個虛擬地址來訪問主存，在訪問之前，會由CPU中的內存管理單元（MMU）先將虛擬地址轉換成一個物理地址，這個任務叫做地址翻譯。
- 內存管理單元是CPU上的一個專用硬件，利用存放在主存中的查詢表動態翻譯虛擬地址，這個表的內容由操作系統管理。

## 9.2 地址空間

地址空間是線性的，物理地址空間就是從0到最大物理地址，而現代計算機系統的虛擬地址空間則支持32位或者64位，在64位系統上，虛擬地址空間就是64位的。

主存中的每一個字節都有一個物理地址和虛擬地址。

## 9.3 虛擬內存作為緩存的工具

虛擬內存：
- 概念上來說，虛擬內存被組織為一個存放在磁盤上的N個連續字節大小的單元組成的數組。每個字節都有一個唯一的虛擬地址，作為索引。
- 和其他層次一樣，虛擬內存被分割為塊，這個塊被稱為虛擬也（virutal page，VP），每個虛擬頁的大小為`2^p`字節。
- 類似地，物理內存被分隔為物理頁（physical page，PP），作為虛擬內存的緩存，大小和虛擬頁大小相同，也被稱為頁幀。
- 在任意時刻，虛擬頁面的集合被分為三個不相交的子集：
    - 未分配的：虛擬內存系統還未分配這個頁，和任何數據無關聯，不佔用任何磁盤空間。
    - 已緩存的：已緩存在物理內存中的已分配頁。
    - 為緩存的：未緩存在物理內存中的已分配頁。

DRAM緩存的組織結構：
- DRAM比SRAM大約慢10倍，而磁盤比DRAM大約慢100000倍。因為DRAM緩存未命中比SRAM緩存未命中昂貴得多。
- 因為非常大的未命中懲罰，虛擬頁往往很大，通常是4KB~2MB。
- 因為懲罰很大，所以替換策略也很重要，替換錯了虛擬頁的懲罰也很高。DRAM緩存替換算法通常更復雜精密。DRAM總是使用寫回而不是直寫。

頁表：
- 同任何緩存一樣，虛擬內存系統需要有某種方法判斷一個虛擬頁是否緩存在DRAM中的某個地方。
- 系統還需要確定這個虛擬頁存放在哪個物理頁中。如果未命中，系統需要判斷這個虛擬頁放在磁盤什麼位置。
- 這些功能由軟硬件聯合提供，包括操作系統、MMU（內存管理單元）的地址翻譯硬件、和一個存放在物理內存中的叫做**頁表**（page table）的數據結構。
- 頁表將虛擬頁映射到物理頁，每次地址翻譯硬件將一個虛擬地址轉換為物理地址時，都會讀取頁表。操作系統負責維護頁表內容，以及在磁盤和DRAM之間傳送頁。
- 頁表是一個頁表項（page table entry，PTE）的數組，虛擬地址空間中每個頁都對應一個頁表項，頁表項中保存著頁是否有效（也就是是否在DRAM中），以及物理頁號或者磁盤地址（如果為空則表示這個虛擬頁還未分配）。

頁命中：
- 當CPU有了虛擬地址需要讀取其中的數據時，地址翻譯硬件（MMU）先將地址作為一個索引用來定位其PTE，並從內存中讀取它得到物理頁的起始物理地址，然後構造出數據的物理內存。

缺頁：
- DRAM緩存未命中被稱之為缺頁（page fault）。
- 此時MMU從頁表項有效位推出頁面未被緩存的信息，並且觸發一個缺頁異常。
- 缺頁異常觸發後會調用內核中的缺頁異常處理程序，該程序會選擇一個犧牲頁，如果這個犧牲頁相教磁盤中被修改了，那麼會被複制回磁盤，然後內核將需要的頁從磁盤中複製到DRAM中犧牲頁的位置。
- 然後異常處理程序返回，此時會重新啟動導致缺頁的指令。
- 虛擬內存是20世紀60年代發明的，遠在SRAM緩存之前。按照虛擬內存中的習慣，塊被稱為頁，在磁盤和內存之間傳送頁的活動叫做**交換**（swapping）或者**頁面調度**（paging）。
- 頁從磁盤**換入**DRAM或者從DRAM**換出**到磁盤。
- 直到DRAM頁面未命中時，才換入頁面的策略成為**按需頁面調度**（demand paging）。也可以採用其他方法，嘗試預測未命中，在頁面實際需要前就換入頁面。
- 所有現代操作系統都採用按需頁面調度的方式。

分配頁面：當分配一個新頁面時（比如調用`malloc`），內核在磁盤上創建一個新虛擬頁。

局部性：
- 我們可能會擔心磁盤和DRAM的巨大性能差距是否會導致虛擬內存的效率低下，未命中懲罰代價過大，擔心頁面調度破壞程序性能。
- 實際上，虛擬內存機制工作得相當好，這主要歸功於局部性（locality）。
- 儘管整個運行過程中程序引用的不同頁面總數可能超過物理內存的總大小，但是局部性原理保證了在任意時刻，程序將趨向於在一個較小的活動頁面（active page）集合上工作，這個集合成為工作集（working set）或者常駐集合（resident set）。
- 只要我們的程序有良好的時間局部性，虛擬內存系統就能工作得相當好。
- 當然不是所有程序都能有良好的時間局部性，如果工作集超出了物理內存大小，就可能發生抖動（thrashing），這時頁面將不斷換入換出，導致性能大幅降低。
- Linux系統中可以通過`getrusage`函數監測缺頁數量。

## 9.4 虛擬內存作為內存管理的工具

- 前面提到的頁表其實是每個進程一個，每個進程的虛擬地址空間都是獨立的。
- 多個進程可以將不同進程中的虛擬頁面映射到同一個**共享物理頁面**。
- 按需頁面調度和獨立的虛擬地址空間結合，對系統中內存的使用和管理產生了深遠的影響。
- 特別是虛擬內存簡化了加載、代碼和數據共享，以及應用程序的內存分配過程：
    - **簡化鏈接**：獨立的地址空間允許每個進程的內存映象使用相同的基本格式，而不管代碼和數據實際存放在物理內存的何處。
        - 例如64位Linux中，代碼段地址總是從虛擬地址0x400000開始，數據段在代碼段之後，棧在用戶空間最高地址的部分，向低地址生長。
        - 這樣的一致性簡化了鏈接器的設計和實現，允許鏈接器生成完全可鏈接的可執行文件，這些可執行文件是獨立於物理地址中代碼和數據的最終位置的。
    - **簡化加載**：虛擬內存還使得容易向內存中加載可執行文件和共享目標文件。加載器不需要向內存複製數據，在CPU取指令或者引用內存位置時會自動有虛擬內存系統將頁面調入。
        - 將一組連續的虛擬頁映射到任意一個文件中的任意位置的表示法叫做**內存映射**（memory mapping）。Linux提供一個`mmap`的系統調用，允許應用程序自己做內存映射。
    - **簡化共享**：獨立地址空間為操作系統提供了一個管理用戶進程和操作系統自身之間的共享的一致機制。
    - **簡化內存分配**：分配內存時（比如`malloc`），操作系統分配適當的連續的虛擬內存頁面，並將其映射到任意位置的（物理頁面不必連續）的物理頁面。

## 9.5 虛擬內存作為內存保護的工具

任何現代操作系統都必須為操作系統提供手段來控制對內存的訪問：
- 不應該允許用戶修改他的只讀代碼段。
- 不應該允許用戶讀取或者修改任何內核中的代碼或者數據結構（要修改必須通過系統調用）。
- 不應該允許用戶讀或者寫其他進程的私有內存，不應該允許修改與其他進程共享的虛擬頁面，除非共享者顯式允許這麼做。
- 要提供這些機制很簡單：
    - 在PTE中添加一些額外的位來標誌進程是否必須運行在內核態才能訪問（即通過系統調用才能修改）、是否能夠讀取、能夠寫入。
    - 通過加入SUP、READ、WRITE三個位就能控制對內存的訪問了。
- 如果一條指令違背了這些許可條件，那麼CPU就會觸發一個保護屏障，將控制傳遞給內核中的異常處理程序。在Linux Shell中一般將這種異常報告為**段錯誤**（segment fault）。

## 9.6 地址翻譯

形式上來說，地址翻譯是一個將一個N（`2^n`）元素的虛擬地址空間（VAS）映射到一個M（`2^m`）元素的物理地址空間（PAS）的過程：
- 虛擬地址n位，其中虛擬頁偏移量（VPO）p位，頁面大小為`2^p`，虛擬頁號（VPN）n-p位。
- 物理地址m位，其中物理頁偏移量（PPO）p位，頁面大小為`2^p`，物理頁號（PPN）m-p位。
- CPU中有一個控制寄存器——頁表基址寄存器（PTBR）指向當前（進程的）頁表。
- 通過n-p位虛擬頁號作為頁表索引，找到當前要查找的內存的頁表項（PTE），頁表命中的情況下，從中提取出m-p位物理頁號，拼接p位物理頁偏移量（也即是虛擬頁偏移量）後得到m位物理地址，然後使用物理地址訪存。

![](Address_Translation.JPG)

- 頁面命中時，CPU硬件執行步驟：
    - 處理器生成虛擬地址，傳送給MMU。
    - MMU生成PTE地址，並傳送給緩存/主存得到PTE。
    - MMU通過PTE中的物理頁號構造出物理地址，並傳送給緩存/主存得到請求的數據。
- 缺頁時，則需要操作系統內核和硬件協作完成：
    - 第二步後，得到PTE地址，PTE地址中有效位為0，MMU觸發缺頁異常，傳遞CPU控制到操作系統內核中的缺頁異常處理程序。
    - 缺頁處理程序確定物理內存中的犧牲頁，將其換出到磁盤。
    - 缺頁處理程序調入新的頁面，更新內存中的PTE。
    - 缺頁處理程序返回到原來的進程，再次執行導致缺頁的指令，CPU將虛擬地址重新發送給MMU。

結合高速緩存與虛擬內存：
- 在既使用虛擬內存又使用SRAM高速緩存的系統中，都有應該使用虛擬地址還是物理地址來訪問SRAM的問題。
- 大多數系統都是使用物理地址的。
- 使用物理地址，多個進程都在緩存中有存儲塊、共享來自相同虛擬頁面的塊是非常簡單的事情。而且高速緩存無需額外保護處理，因為訪問權限檢查是地址保護的一部分。

利用TLB加速地址翻譯：
- CPU每產生一個虛擬地址，MMU都需要查閱一個PTE，以將虛擬地址翻譯為物理地址。
- 在最糟糕的情況下，所有緩存都未命中，這要求從內存中多取一次數據，代價將高達幾十到幾百個時鐘週期。
- 即使PTE緩存在L1緩存緩存中，也會有幾個時鐘週期的開銷。
- 許多系統識圖消除這種開銷，都在MMU中繼承了一個PTE的緩存，稱為**快表**（Translation Lookaside Buffer，**TLB**，轉換查找表）。
- TLB是一個小的，虛擬尋址的緩存，其中每一行保存著一個由單個PTE組成的塊，TLB通常都有高度的相連度。
- 用於組選擇和行選擇的TLB索引和TLB標記是從虛擬地址的虛擬頁號中提取出來的。TLB索引是虛擬頁號中低t位組成，而TLB標記是VPN中剩餘位組成。
- 當TLB命中時，MMU可以在一個時鐘週期之內從TLB中取出PTE。
- 當TLB未命中時，需要從L1緩存中取出PTE，新取出的PTE將被緩存到TLB，可能會覆蓋一個條目。

多級頁表：
- 即使在32位系統、4KB的頁面大小、4字節的PTE情況下，對於每個線程我們將需要4MB的大小才能夠存下整個頁表。相對來說代價是比較大的。
- 對於64位來說，情況將更復雜。
- 所以需要將頁表進行壓縮，最常用的手段是使用多級層次結構的頁表。
- 比如，每個一級頁表PTE管理4MB的虛擬內存，其中保存二級頁表地址，二級頁表中保存1024個PTE，每個PTE映射一個4KB的頁面。
- 這種方法從兩個方面減少了內存需求：
    - 如果一級頁表中PTE為空（未分配），那麼對應二級頁表根本就不會存在。對於一個普通程序來說，大部分地址空間都是未分配，這是一種巨大的節約。
    - 第二，只有一級頁表才需要總是在主存中，虛擬內存系統可以在需要時創建、頁面調入或者調出二級頁表。這樣減小了主存的壓力，只有最常使用的二級頁表才需要緩存在主存中。
- 對於k級頁表層次結構的地址翻譯來說，將虛擬頁號分割成k個部分，每個部分用來所以相應層級的頁表。
- 在確定PPN前，MMU必須訪問k個所有層次的PTE。
- 看起來訪問k次PTE會非常昂貴，但是MMU中的TLB在這裡會起作用。通過將不同層次上的頁表PTE緩存起來，實際上，帶多級頁表的地址翻譯並不比單級頁錶慢很多。

## 9.7 案例研究：Intel Core i7/Linux

### Intel Core i7地址翻譯

Intel Core i7的一些參數：
- 64位虛擬和物理地址空間，現在的實現支持最高48位有效虛擬地址空間（更高位不會用都是0，256TB）和52位物理地址空間（4PB）。
- 處理器封裝4個核心，所有核心共享的大的8MB L3緩存和一個內存控制器。
- 有一組QuickPath的點到點鏈路，在每個核心內部，基於QuickPath技術，為了讓一個核心與其他核心和外部I/O橋直接通信。
- 每個核心內部有獨立的32KB數據和32KB指令L1緩存，以及256KB統一L2緩存。
- 每個核心內部有一個MMU，其下有著一個64條目的L1數據TLB，和128條目的L2指令TLB，以及一個統一的512條目的L2 TLB。
- L1、L2、L3緩存是物理尋址，分別是8路、8路、16路組相聯。L1、L2 TLB都是4路組相聯。
- 頁面大小可以在啟動時配置為4KB或者4MB，Linux使用4KB的頁。

![](Corei7_memory_system.JPG)

Core i7地址翻譯：
- Core i7使用4級頁表層次，每個進程都有自己的私有頁表層次結構。
- 當一個Linux進程運行時，雖然core i7允許頁表換入換出，但是與已分配的頁關聯的頁表都是常駐內存的。
- CR3控制寄存器指向一級頁表的起始位置，作為進程上下文的一部分，在上下文切換時，會被保存和恢復。

![](Corei7_address_translation.JPG)

PTE:
- core i7使用四級頁表。
- 每一級頁表項都是9位尋址，512個PTE，每個PTE 8個字節，所以每一級頁表都是4KB。
- 並且要求每個物理頁表都4KB對齊，也就是每個物理頁表剛好佔據一個物理頁，而不會跨兩個物理頁。
- 第一二三級頁表項如下：

![](Corei7_L1L2L3_PTE.JPG)

- 最後一位是有效位，表示位於內存還是磁盤。
- 如果位於內存，則有40位物理頁號，其他都是權限位或者策略。
- 如果位於磁盤，則除去最後一位後都表示磁盤上的頁表位置。
- 在Linux中，運行著的進程的頁表的有效位總是1。
- 第四級頁表項如下：

![](Corei7_L4_PTE.JPG)

權限位：
- PTE中有三個權限位：
    - R/W確定頁是可以讀寫還是隻讀。
    - U/S確定是否能夠在用戶態訪問，從而保護內核代碼和數據。
    - XD（禁止執行）是64位系統引入，用來禁止從某些內存頁取指令，這是一個重要特性，通過限制只能執行只讀代碼段，使得操作系統內核降低了緩衝區溢出攻擊的風險。

Core i7MMU使用四級頁表來翻譯虛擬地址到物理地址的過程：

![](Corei7_PT_translation.JPG)

### Linux虛擬內存系統

這裡只是做一個大致描述，並非全面細緻的討論細節。瞭解實際操作系統如何組織虛擬內存，以及如何處理缺頁的。

Linux為每個進程維護了一個單獨的虛擬地址空間，其結構如圖：

![](Linux_Process_VirtualMemory.JPG)

- 其中比棧地址更高的一部分被映射為內核中所有進程共享的物理頁面。

Linux虛擬內存區域：
- Linux將虛擬內存組織為一些區域（area）的集合，一個區域是已經分配的虛擬內存的連續片（chunk）。
- 每個已分配的虛擬頁面都保存在某個區域中，而不屬於某個區域的虛擬頁是不存在的，並且不能被進程引用。
- 區域的概念很重要，它允許虛擬地址空間存在間隙，內核不用記錄不存在的虛擬頁，這樣的頁也不用佔用內存、磁盤或者內核本身的任何額外資源。
- Linux內核中用於管理進程虛擬地址空間的結構是任務結構`task_struct`，其中包含了內核運行該進程所需要的所有信息：PID、指向用戶棧的指針、可執行目標文件名字、程序計數器、頁表地址等。
- 其中保存的`mm_struct`描述了虛擬內存的狀態：

![](Linux_Kernel_VM.JPG)

- `pgd`中是第一級頁表的基址（首地址）。

Linux缺頁異常處理：
- 當MMU試圖訪問虛擬地址A時，觸發了一個缺頁，這個異常導致轉到內核的缺頁處理程序，然後執行下列步驟：
- 判斷地址是否合法，會遍歷這個區域結構鏈表，如果在鏈表中，那麼合法，如果不在，那麼就是引用一個不存在的頁中內存，會報**段錯誤**。
- 如果這個頁面存在，那麼會判斷權限是否合法，比如執行寫內存指令就需要對該內存有寫權限，取內存中指令執行那麼就必須有執行權限。如果權限不夠，那麼會觸發一個保護異常，終止程序。
- 如果頁面存在且有權限，那麼就正常處理缺頁，選擇一個犧牲頁面，並換入缺了的那個頁面。返回CPU會重新啟動引起缺頁的指令，這條指令將A再次發到MMU，這次就不會缺頁中斷了。

## 9.8 內存映射

Linux中，通過將虛擬內存區域與磁盤上的一個對象關聯起來，以初始化這個虛擬內存區域的內容，這個過程稱之為內存映射（memory mapping）。虛擬內存可以映射到兩種文件之一：
- **Linux文件系統中的普通文件**：因為按需頁面調度，直到CPU第一次引用這個頁面才會將文件內容加載到主存中。如果區域比文件大，那麼用0填充剩餘部分。
- **匿名文件**：一個區域可以映射到一個匿名文件，匿名文件是由內核創建的，包含的二進制全0，CPU第一次引用這個頁面時，內核會在物理內存中找一個合適的犧牲頁面（如果這個頁面修改過，會將其換出到磁盤），然後用二進制0覆蓋犧牲頁面並更新頁表。注意此時其實磁盤和主存沒有實際的數據傳送。因為這個原因，映射到匿名文件區域的頁面也叫請求二進制零的頁（demand-zero page）。
- 無論哪種情況，一旦虛擬頁面初始化，它就在一個有內核維護的專門的交換文件（swap file）之間換來換去。交換文件也成為交換空間（swap space）或者交換區域（swap area）。

### 共享對象

某些對象會在多個進程中使用（比如C標準庫中的函數），內存映射為我們提供了一種共享對象的清晰機制：
- 一個對象可以被映射到虛擬內存的一個區域，要麼作為共享對象，要麼作為私有對象。
- 共享對象：映射共享對象的區域稱之為共享區域，對共享區域的更改對其他共享了該對象的線程可見。
- 私有對象：私有對象實現了寫時複製（Copy-on-write）功能，修改對其他線程不可見，並且在寫時才會複製。
- 私有對象寫時複製的實現：將頁面標記為只讀，並且區域結構被標記為**私有的寫時複製**，寫頁面內的內存會觸發內核的異常保護程序，此時複製區域到新頁面，並恢復頁面的可寫權限，並返回這個寫操作的執行位置重新執行。

### fork

fork函數被當前進程調用時，內核為新進程創建各種數據結構，並分配一個唯一的PID。
- 為了創建新進程的虛擬內存，它創建當前進程的`mm_struct`、區域結構、頁表的副本，並將兩個進程的所有頁面標記為只讀，每個區域結構標記為私有的寫時複製。
- 當兩個進程中的某個進行寫操作時，進行寫時複製創建並複製新頁面。

### execve

虛擬內存和內存映射在將程序加載到內存中的過程中也扮演重要角色：
- 以`execve("a.out", NULL, NULL)`為例，`execve`在當前進程中加載並運行包含在可執行目標程序`a.out`中的程序，用`a.out`程序代替當前程序。
- 執行步驟：
    - 刪除已存在的用戶區域。
    - 映射私有區域：為新程序的代碼、數據、bss、棧區域創建新的區域結構。這些區域都是私有、寫時複製的。其中bss區域、棧、堆是請求二進制0的，映射到匿名文件。
    - 映射共享區域，映射到用戶虛擬地址空間的共享區域內。
    - 設置程序計數器PC為代碼區域的入口點。
- 示意圖：

![](MemoryMapping_execve.JPG)

### 使用mmap的用戶級內存映射

```C
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);
```
- 通過`mmap`可以將文件`fd`中`offset`偏移處開始，連續對象片大小為`length`，最好從地址`addr`開始。
- `prot`為權限：執行、可讀、可寫、不能訪問。
- `flags`為對象類型標記：匿名對象（請求二進制0）、私有寫時複製、共享對象。
- `munmap`刪除虛擬內存區域。

## 9.9 動態內存分配

使用`mmap munmap`函數可以創建和刪除虛擬內存區域，但是一般來說對於C程序員，使用動態內存分配器會更方便更有移植性。
- 分配器有兩種風格：
    - 顯式：C的`malloc free`，C++的`operator new/delete`。
    - 隱式：要求分配器檢測已分配的塊不再被使用時自動回收，隱式分配器也叫垃圾收集器（garbage collector）。
- 大多數程序依賴顯式的內存分配器，而不是直接使用內存映射等底層虛擬內存管理機制。

至於實現動態內存分配，暫略。

## 9.10 垃圾收集

略。

## 9.11 C程序中常見的與內存相關的錯誤

常見內存錯誤：
- 間接引用壞指針：將非指針數據當做指針引用。
- 讀取未初始化內存：比如堆內存。
- 棧緩衝區溢出：棧中緩衝區長度有限，越界寫緩衝區導致棧數據損壞。
- 假設指針和他們指向的對象大小相等：可能正常工作，但不可移植，大多是筆誤。
- 錯位錯誤：越界寫數組寫壞了其他數據。
- 誤解指針運算：指針的算術運算有自己的規則。
- 引用不存在變量：比如返回局部對象指針，這個指針可能可以讀寫，但是並非想要的對象，可能寫壞棧。
- 引用空閒堆數據：引用已經釋放的堆中數據。
- 內存洩漏：內存分配後未釋放。
