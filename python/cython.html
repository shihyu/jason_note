<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cython - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>雖然cython非平行處理，但其可編譯python與openmp，因此cython是非常重要的套件。</li>
<li>Cython 是包含 C 資料類型的 Python。</li>
<li>Cython 是 Python：幾乎所有 Python 代碼都是合法的 Cython 程式碼。 Cython 的編譯器會轉化 Python 程式碼為 C 程式碼，這些 C 程式碼均可以調用 Python/C 的 API。</li>
<li>一般來講，在python中使用C/C++模組兩種常見的場景是:
<ul>
<li>原來的python代碼性能太差</li>
<li>有現成的C/C++可供直接調用 *</li>
</ul>
</li>
<li>pycharm IDE (professional version) 支援cython語法，建議使用。</li>
<li>cython簡單的說明，就是替python的變數加上type後再編譯成machine code，因此效能可提高不少。</li>
</ul>
<p><img src="images/cython_flow.png" alt="img" />Cython編譯引用流程。</p>
<p><img src="images/cython_compile_flow.png" alt="img" />Cython編譯流程2。</p>
<h2 id="pyxpxd檔案命名"><a class="header" href="#pyxpxd檔案命名">pyx/pxd檔案命名</a></h2>
<ul>
<li>
<p>cython的程式之副檔案為pyx(python extension)。</p>
</li>
<li>
<p>而另外還有.pxd的檔案，其功能如C語言的標頭檔(header file)，其包含了cython的宣告。</p>
</li>
<li>
<p>pyx可使用cimport引入pxd中的內容。</p>
</li>
<li>
<p>pxd的主要功能如下：</p>
<ul>
<li>
<p>共用C的外部宣告，或包裝已編譯的C函式庫。</p>
</li>
<li>
<p>inline C function</p>
<pre><code class="language-python">cdef inline int int_min(int a, int b):
  return b if b &lt; a else a
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="函數定義"><a class="header" href="#函數定義">函數定義</a></h2>
<ul>
<li>cython的函式有三種定義方式：
<ul>
<li>def: 傳入python物件，返回python物件，直接調用</li>
<li>cdef: 傳入python物件或C/C++值，返回python物件或C/C++值，不可直接調用</li>
<li>cpdef: 以上兩者的混合</li>
</ul>
</li>
</ul>
<p><img src="images/cython_function_import.png" alt="img" />Cython function定義可視範圍。</p>
<ul>
<li>然而使用cdef報錯不能很好的捕獲異常。你可以這樣使用:</li>
</ul>
<pre><code class="language-python"># 這樣當該函數內部出錯時，將會返回一個0。
# (所以此時應當避免正確的情況中有返回0的可能，以避免歧義。)
cdef int divide(int x, int y) except 0:
    ...
</code></pre>
<h2 id="函數參數傳遞"><a class="header" href="#函數參數傳遞">函數參數傳遞</a></h2>
<ul>
<li>python和C/C++之間有一些自動的類型轉換:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>C types</th><th>from python types</th><th>to python types</th></tr></thead><tbody>
<tr><td>[unsigned] char [unsigned] short int, long</td><td>int, long</td><td>int</td></tr>
<tr><td>unsigned int unsigned long [unsigned] long long</td><td>int, long</td><td>long</td></tr>
<tr><td>float, double, long double</td><td>int, long, float</td><td>float</td></tr>
<tr><td>char*</td><td>str/bytes</td><td>str/bytes</td></tr>
<tr><td>struct</td><td></td><td>dict</td></tr>
</tbody></table>
</div>
<ul>
<li>如果需要檢測傳入的參數不是None的話可以加上not None來檢測</li>
</ul>
<pre><code class="language-python">def func(x not None):
    ...
</code></pre>
<h2 id="字串傳遞"><a class="header" href="#字串傳遞">字串傳遞</a></h2>
<ul>
<li>python2.7的字串為ascii或是unicode，而python3.x之後全面使用unicode。</li>
<li>C的字串(char*)結尾是以\0為結尾。</li>
<li>C++使用string函式庫處理字串。</li>
</ul>
<h3 id="bytes-to-c-string"><a class="header" href="#bytes-to-c-string">bytes to C string</a></h3>
<pre><code class="language-python"># python: bytes to unicode
ustring = byte_string.decode('UTF-8')
// 如果C string沒有null bytes，也可用同樣方法轉換成unicode
cdef char* some_c_string = c_call_returning_a_c_string()
ustring = some_c_string.decode('UTF-8')

// 已知字串長度時，轉換會更有效率
cdef char* c_string = NULL
cdef Py_ssize_t length = 0

# get pointer and length from a C function
get_a_c_string(&amp;c_string, &amp;length)
ustring = c_string[:length].decode('UTF-8')
</code></pre>
<h3 id="c-string-to-bytes"><a class="header" href="#c-string-to-bytes">C string to bytes</a></h3>
<pre><code class="language-python">py_byte_string = py_unicode_string.encode('UTF-8')

#  pointer to the byte buffer of the Python byte string
cdef char* c_string = py_byte_string

# this will not compile !
cdef char* c_string = py_unicode_string.encode('UTF-8')

# Here, the Cython compiler notices that the code takes a pointer 
# to a temporary string result that will be garbage collected after the 
# assignment. Later access to the invalidated pointer will read invalid
# memory and likely result in a segfault. 
# Cython will therefore refuse to compile this code.
</code></pre>
<h3 id="for-c-string"><a class="header" href="#for-c-string">for C++ string</a></h3>
<ul>
<li>可直接將std:string的字串給python使用 ```python from libcpp.string cimport string cdef string cpp_string = py_unicode_string.encode('UTF-8')</li>
</ul>
<p>cdef string s = string(b'abcdefg') ustring1 = s.decode('UTF-8') ustring2 = s[2:-2].decode('UTF-8')</p>
<pre><code>### 自動轉換

* cython 0.19提供了兩個命令 &lt;span class='cmd'&gt; c_string_type&lt;/span&gt; 與 &lt;span class='cmd'&gt; c_string_encoding &lt;/span&gt;處理字串。

```python
# cython: c_string_type=unicode, c_string_encoding=utf8

cdef char* c_string = 'abcdefg'

# implicit decoding:
cdef object py_unicode_object = c_string

# explicit conversion to Python bytes:
py_bytes_object = &lt;bytes&gt;c_string
</code></pre>
<h2 id="hello-world程式"><a class="header" href="#hello-world程式">Hello world程式</a></h2>
<ul>
<li>
<p>hello.pyx</p>
<pre><code class="language-python">print ("hello world")
</code></pre>
</li>
<li>
<p>setup.py</p>
</li>
</ul>
<pre><code class="language-python">from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize("hello.pyx")
 )
</code></pre>
<ul>
<li>編譯cython檔案： python setup.py build_ext --inplace
<ul>
<li>在linux中預設使用gcc編譯，而windows中必須安裝visual c++才可編譯。</li>
<li>因為在編譯時指定--inplace，linux最後會生成同一資料夾中生成hello.so，而windows會生成hello.pyd。</li>
<li>而此時可在python檔案或是shell中，使用 import hello。</li>
</ul>
</li>
<li>如果你的模組不需要額外的 C 庫活特殊的構件安裝，可使用pyximport 模組來直接讀取 .pyx 檔，而不需要編寫 setup.py 文件。 它隨同 Cython 一併發佈和安裝，你可以這樣使用它。</li>
</ul>
<pre><code class="language-python">import pyximport; pyximport.install()
&gt;&gt;&gt; import helloworld
Hello World
</code></pre>
<h2 id="const修飾字"><a class="header" href="#const修飾字">const修飾字</a></h2>
<ul>
<li>cython自0.18開始支援const修飾字。</li>
<li>許多C函式庫會使用const修飾字指定不可修改的字串或陣列如下。</li>
</ul>
<pre><code class="language-c">typedef const char specialChar;
int process_string(const char* s);
const unsigned char* look_up_cached_string(const unsigned char* key);
# cython可使用const修飾字引用C的函式庫
cdef extern from "someheader.h":
    ctypedef const char specialChar
    int process_string(const char* s)
    const unsigned char* look_up_cached_string(const unsigned char* key)

# 即使在pxd中不使用const修飾字時，仍然可引用外部C函式
cdef extern from "someheader.h":
    int process_string(char* s)   # note: looses API information!
</code></pre>
<h2 id="調用c函式庫"><a class="header" href="#調用c函式庫">調用C函式庫</a></h2>
<ul>
<li>簡單來說，我們先以一個 C 標準庫中的函數為例。 你不需要向你的代碼中引入 額外的依賴，Cython 都已經幫你定義好了這些函數。所以你可以將這些函數直接 cimport 進來並使用。
<ul>
<li>cimport等同於C中的include</li>
<li>你可以在 Cython 的原始程式碼包<a href="https://github.com/cython/cython/tree/master/Cython/Includes">Cython/Includes/</a>_. 中找到所有的標準 cimport 檔。這些檔保存在.pxd 檔中，這是一種標準再模組間共用 Cython 函式宣告的方法</li>
</ul>
</li>
<li>舉個例子，比如說當你想用最簡單的方法將char*類型的值轉化為一個整型值時， 你可以使用atoi() 函數，這個函數是在stdlib.h 標頭檔中定義的。</li>
</ul>
<pre><code class="language-python">from libc.stdlib cimport atoi

# cdef: 為C函式
cdef parse_charptr_to_py_int(char* s):
    assert s is not NULL, "byte string value is NULL"
    # note: atoi() has no error detection!
    return atoi(s)
</code></pre>
<ul>
<li>使用C的數學庫</li>
</ul>
<pre><code class="language-python">from libc.math cimport sin

cdef double f(double x):
    return sin(x*x)
</code></pre>
<h2 id="動態連結dynamic-linking"><a class="header" href="#動態連結dynamic-linking">動態連結（Dynamic linking）</a></h2>
<ul>
<li>在一些類 Unix 系統（例如 linux）中，默認不提供libc math 庫。 所以除了 cimport函式宣告外，你還必須配置你的編譯器以連結共用庫m。 對於 distutils來說，在Extension()安裝變數libraries 中將其添加進來就可以了。</li>
</ul>
<pre><code class="language-python">from distutils.core import setup
from distutils.extension import Extension
from Cython.Build import cythonize

ext_modules=[
    Extension("demo",
    sources=["demo.pyx"],
    libraries=["m"] # Unix-like specific
)
]

setup(
    name = "Demos",
    ext_modules = cythonize(ext_modules)
)
</code></pre>
<h2 id="外部聲明external-declarations"><a class="header" href="#外部聲明external-declarations">外部聲明（External declarations）</a></h2>
<ul>
<li>如果你想調用一個 Cython 中沒有定義的函式宣告，那麼你必須自己進行聲明。例如，上文中的 sin()函數就是這樣定義的：</li>
</ul>
<pre><code class="language-python"> cdef extern from "math.h":
    double sin(double x)
</code></pre>
<ul>
<li>此處聲明瞭sin()函數，這時我們便可在 Cython 代碼中使用這個函數，並且讓 Cython 生成一份包括math.h 標頭檔的 C 代碼。C 編譯器在編譯時能夠在math.h 中找到原始的函式宣告。但是 Cython 不能解析math.h 並需要一個單獨的定義。</li>
<li>正如math 庫中的sin()函數一樣，只要 Cython 生成的模組正確的連結了共用庫或靜態程式庫，我們就可以聲明並調用任意的 C 庫函數。</li>
<li>注意，只要簡單地通過cpdef 聲明，你就能從 Cython 模組中匯出一個外部 C 函數。而且生成了一個 Python 擴展，使得我們可以在 Python 代碼中直接訪問到 C 函數sin()。</li>
</ul>
<h2 id="變數的命名naming-parameters"><a class="header" href="#變數的命名naming-parameters">變數的命名（Naming parameters）</a></h2>
<ul>
<li>C 和 Cython 都支持沒有參數明的signature declarations如下：</li>
</ul>
<pre><code class="language-python">cdef extern from "string.h":
    char* strstr(const char*, const char*)
</code></pre>
<ul>
<li>然而，這樣的話 Cython 代碼將不能通過關鍵字參數來調用這個函數（由Cython 0.19及以後的版本所支持）。所以，我們最好這樣去聲明一個函數：</li>
</ul>
<pre><code class="language-python">cdef extern from "string.h":
      char* strstr(const char *haystack, const char *needle)
</code></pre>
<ul>
<li>這會讓清楚地知道你所調用了哪兩個參數，從而能夠避免二義性並增強你的代碼的可讀性:</li>
</ul>
<pre><code class="language-python">cdef char* data = "hfvcakdfagbcffvschvxcdfgccbcfhvgcsnfxjh"

pos = strstr(needle='akd', haystack=data)
print (pos != NULL)
</code></pre>
<ul>
<li>注意，正如 Python 代碼一樣，對已有參數名的修改是不向後相容的。那麼， 如果你為外部的 C 或 C++ 函數進行了自己的聲明，通常花一點時間去 將參數名命名的更好是非常值得的。</li>
</ul>
<h2 id="memoryview切片"><a class="header" href="#memoryview切片">Memoryview切片</a></h2>
<ul>
<li>Cython 0.16中，增加了記憶體視圖(memoryview)，用它可以很方便地存取NumPy陣列等支援buffer介面的物件中的資料。</li>
<li>編寫如下三個檔，並保存到同一個目錄之下：
<ul>
<li>memview_test.py:用來測試編譯之後的擴展庫的測試程式</li>
<li>memview.pyx:Cython來源程式</li>
<li>setup.py:用於編譯Cython來源程式</li>
</ul>
</li>
<li>setup.py</li>
</ul>
<pre><code class="language-python">import numpy as np
from distutils.core import setup
from distutils.extension import Extension
from Cython.Distutils import build_ext

setup(
    cmdclass = {'build_ext': build_ext},
    ext_modules = [
        Extension("memview", ["memview.pyx"],
    ],

    # 使用numpy套件必須加上此行
    include_dirs=[np.get_include()]
)
</code></pre>
<ul>
<li>Memoryview切片(Memoryview slices)是Cython中的一種特殊類型，通過它可以高效地訪問支援buffer介面的Python物件內部的資料區，例如NumPy中的ndarray物件。下面我們通過一個例子說明它的用法</li>
</ul>
<pre><code class="language-python">def memview_sum(int[:] a):
    # 參數a是一個一維整數切片類型，可以將與此切片類型一致的陣列傳遞給它
    cdef int i
    cdef int s = 0
    # 和NumPy陣列一樣，它的shape屬性為其各個軸的長度
    for i in range(a.shape[0]):
        s += a[i]
    return s
</code></pre>
<ul>
<li>分析編譯後的檔案 cython.py -a memview.pyx ，會生成memview.html與memview.c，可知 s+=a[i] 這一行這段代碼可以處理下標越界以及下標為負數的情況。由於需要在迴圈中對每個元素進行判斷，因此這些代碼會降低運算速度。</li>
</ul>
<pre><code class="language-c">    /* "memview.pyx":5   
   *     cdef int s = 0
   *     for i in range(a.shape[0]):   
   *         s += a[i]             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
   *     return s   */
      __pyx_t_3 = __pyx_v_i;      
      __pyx_t_4 = -1;
      // 處理下標為負值及越界的狀況，每次迴圈都要處理，相當花時間
      if (__pyx_t_3 &lt; 0) {        
        __pyx_t_3 += __pyx_v_a.shape[0];
        if (unlikely(__pyx_t_3 &lt; 0)) __pyx_t_4 = 0;      
       } else if (unlikely(__pyx_t_3 &gt;= __pyx_v_a.shape[0])) __pyx_t_4 = 0;
      if (unlikely(__pyx_t_4 != -1)) {
        __Pyx_RaiseBufferIndexError(__pyx_t_4);
        __PYX_ERR(0, 5, __pyx_L1_error)
      }
      __pyx_v_s = (__pyx_v_s + (*((int *) ( /* dim=0 */ (__pyx_v_a.data + __pyx_t_3 * __pyx_v_a.strides[0]) ))));
    }
</code></pre>
<ul>
<li>由於需要在迴圈中對每個元素進行判斷，因此這些代碼會降低運算速度。可以使用Cython提供的wraparound和boundscheck修飾器關閉這兩項功能。</li>
</ul>
<pre><code class="language-python">cimport cython
@cython.boundscheck(False)
@cython.wraparound(False)
def memview_sum(int[:] a):
    # ...
</code></pre>
<ul>
<li>使用修飾器對整個函數體有效，如果只希望對某一段程式有效的話，可以使用with關鍵字：</li>
</ul>
<pre><code class="language-python">for i in range(a.shape[0]):
with cython.boundscheck(False):
    with cython.wraparound(False):
            s += a[i]
</code></pre>
<ul>
<li>關閉這兩個選項之後，輸出的代碼如下，很明顯可看出沒有檢查邊界。</li>
</ul>
<pre><code class="language-c">/* "memview.pyx":9
 *     cdef int s = 0
 *     for i in range(a.shape[0]):
 *         s += a[i]             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 *     return s
 */
    __pyx_t_3 = __pyx_v_i;
    __pyx_v_s = (__pyx_v_s + (*((int *) ( /* dim=0 */ (__pyx_v_a.data + __pyx_t_3 * __pyx_v_a.strides[0]) ))));
  }
</code></pre>
<ul>
<li>在控制檯中輸入</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; a = np.arange(11)
&gt;&gt;&gt; memview.memview_sum(a)
55
# 由於在C語言代碼中使用data和strides屬性訪問陣列中的資料，因此即使對於元素不是連續存儲的陣列也能正常運算。
&gt;&gt;&gt; memview.memview_sum(a[::2]) ❶
30
</code></pre>
<ul>
<li>如果希望資料在記憶體中是連續存儲的，那麼可以用int[::1] a定義：</li>
</ul>
<pre><code class="language-python">def memview_sum2(int[::1] a):
    cdef int i
    cdef int s = 0
    for i in range(a.shape[0]):
        s += a[i]
    return s

memview.memview_sum2(a)
55
&gt;&gt;&gt; memview.memview_sum2(a[::2])
...
ValueError: ndarray is not C-contiguous
</code></pre>
<ul>
<li>多維記憶體視圖切片類型可以用如下方式定義：</li>
</ul>
<pre><code class="language-python">cdef int[:, :]   # 二維切片
cdef int[:, ::1] # C語言連續(C-contiguous)的二維切片
cdef int[::1, :] # Fortran語言連續(Fortran-contiguous)的二維切片
</code></pre>
<h2 id="記憶體視圖物件"><a class="header" href="#記憶體視圖物件">記憶體視圖物件</a></h2>
<ul>
<li>當將Cython的記憶體視圖切片類型返回到Python中時，它就變成了一個記憶體視圖物件。</li>
</ul>
<pre><code class="language-python">def memview_object(int[:, :] a):
    # 參數a是一個二維切片類型
    # 它除了支援整數下標之外，還可以通過切片下標生成新的切片物件。
    # 我們直接將新生成的切片物件返回.
    return a[::2, ::2]
</code></pre>
<ul>
<li>
<p>在控制檯中執行如下代碼：</p>
<pre><code class="language-python">b = np.arange(24).reshape(6, 4)
&gt;&gt;&gt; mv = memview.memview_object(b)
&gt;&gt;&gt; mv
# 可得知傳回的是memoryview物件
&lt;MemoryView of 'ndarray' at 0x32bdb70&gt;
# 物件的屬性
&gt;&gt;&gt; dir(mv)
[..., 'T', 'base', 'copy', 'copy_fortran', 'is_c_contig', 'is_f_contig', 'itemsize',
'nbytes', 'ndim', 'shape', 'size', 'strides', 'suboffsets']
&gt;&gt;&gt; mv.shape
(3, 2)
</code></pre>
</li>
<li>
<p>MemoryView物件的這些屬性和NumPy陣列十分類似。我們可以通過numpy.asarray()將MemoryView轉換為NumPy陣列：</p>
<ul>
<li>新創建的陣列c和原來的陣列b共用記憶體，因此修改c[0,0]會同時修改b[0,0]。</li>
</ul>
</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; c = np.asanyarray(mv)
&gt;&gt;&gt; c
array([[ 0,  2],
       [ 8, 10],
       [16, 18]])
&gt;&gt;&gt; c[0,0] = 100
&gt;&gt;&gt; b[0,0]
100
</code></pre>
<h2 id="cython陣列"><a class="header" href="#cython陣列">Cython陣列</a></h2>
<ul>
<li>當在Cython中調用切片物件的copy()和copy_fortran()時，將創建一個Cython陣列，並在此陣列上創建一個切片物件。在Python中調用MemoryView物件的copy()方法也與此類似。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; mv.base
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23]])
&gt;&gt;&gt; mv2 = mv.copy()
&gt;&gt;&gt; mv2
&lt;MemoryView of 'array' at 0x317a210&gt;
# 使用copy()後，得到不同的物件
&gt;&gt;&gt; mv2.base
&lt;memview.array object at 0x0311BA98&gt;
</code></pre>
<ul>
<li>我們也可以在Cython中直接創建Cython陣列:</li>
</ul>
<pre><code class="language-python">cimport cython.view
def cython_array(int w, int h):
    # 創建一個形狀為(h, w)的整型Cython陣列，
    # 並用一個記憶體視圖切片m對它進行存取。
    cdef int [:,:] m = cython.view.array(shape=(h, w), 
                                 itemsize=sizeof(int), format="i")
    cdef int i, j
    for i in range(h):
        for j in range(w):
            m[i, j] = i+j 
    return m

import pylab as pl
m = memview.cython_array(400, 250)
pl.imshow(m)
pl.show()
</code></pre>
<p><img src="images/cython_memview_plot.png" alt="img" />Memoryview繪圖</p>
<ul>
<li>如果要向C傳遞一個陣列來處理，大部分情況下應該是numpy的array，推薦使用Memoryview來接受python傳入的numpy的array。
<ul>
<li>Note: 如果numpy轉成memoryview時，將無法使用numpy的內建函數功能。</li>
</ul>
</li>
</ul>
<pre><code class="language-python">cdef int[:,:,:] view = np.arange(27, dtype=np.dtype("i")).reshape((3, 3, 3))
cdef int x[3][3][3]
cdef int[:,:,:] view = x
cdef int[:, :, ::1] c_contiguous = c_contig # store by row
cdef int[::1, :, :] f_contiguous = f_contig # Fortran store by column

cpdef histogram(int[:,:] image):
    import numpy as np
    cdef int[:] hist = np.zeros((256,),dtype=np.intc)
    for x in range(image.shape[0]):
        for y in range(image.shape[1]):
            hist[image[x,y]] += 1
    return np.asarray(hist)
</code></pre>
<ul>
<li>舊式numpy傳參數做法如下：</li>
</ul>
<pre><code class="language-python">def func(np.ndarray[unsigned char, ndim=2, mode="c"] array not None):
    ...
</code></pre>
<h2 id="cc和物件導向"><a class="header" href="#cc和物件導向">C/C++和物件導向</a></h2>
<ul>
<li>選擇：ctypes/CFFI/boost.python/ SWIG/cython</li>
<li>cython優點：
<ul>
<li>易學，Python+C=Cython，重用舊知識 –</li>
<li>好用，pxd，重用聲明檔</li>
<li>C++支持全面，可從C++中回檔Python函數，為Python class重載C++ class行為提供可能</li>
</ul>
</li>
<li>在Cython中也可以方便的使用物件導向的方式工作，只要使用cdef class就能在Cython中像在pure Python中那樣使用類:</li>
<li>注意Cython中的類可以被pure Python中的類繼承，但反過來不行.</li>
</ul>
<pre><code class="language-python">cdef class Rect:
    cdef int width, height

    def __init__(self, int w, int h):
        self.width = w
        self.height = h

    def area(self):
        return self.width*self.height

    def test_it(int x, int y):
        cdef Rect R = Rect(x,y)
        return R.area()
class shop:
    cdef object goods

    def __cinit__(self):
        self.goods = []

    property goods:
        def __get__(self):
            return "We have: %s" % self.goods
        def __set__(self, value):
            self.goods.append(value)
        def __del__(self):
            del self.goods[:]
</code></pre>
<ul>
<li>上面還涉及到<strong>cinit</strong>這個方法和原生python的<strong>init</strong>有些區別，前者可以更快的執行，官方的例子是:</li>
<li>所以最求效率的化，儘量使用<strong>cinit</strong>吧。對於經常創建/刪除實例的類，可以在前面加上@cython.freelist(n)的裝飾器。可以獲得更好的性能。</li>
</ul>
<pre><code class="language-python">cdef class Penguin:
    cdef object food

    def __cinit__(self, food):
        # 新式建構函式
        self.food = food

    def __init__(self, food):
        # python建構函式
        print("eating!")

normal_penguin = Penguin('fish')
fast_penguin = Penguin.__new__(Penguin, 'wheat')  # note: not calling __init__() !
</code></pre>
<ul>
<li>使用C++中的STL:</li>
</ul>
<pre><code class="language-python"> from libcpp.vector cimport vector

 cdef vector[int] vect
 cdef int i
 for i in range(10):
     vect.push_back(i)
 for i in range(10):
     print vect[i]

 vect = xrange(1,10)
</code></pre>
<ul>
<li>python到C++容器的轉換規則是 | python types | =&gt; c++ types | =&gt; python types| |---|---|---| | bytes | std:string | types| | iterable | std:vector | list| | iterable | std:list | list | | iterable | std:set | set | | iterable(len 2) | std:pair | tuple(len 2) |</li>
</ul>
<h2 id="直接使用cc代碼"><a class="header" href="#直接使用cc代碼">直接使用C/C++代碼</a></h2>
<ul>
<li>如果你恰好已經有了C部分的代碼，想直接在python中調用而不是用cython自己重寫的話，你只需要寫一個.pyx進行簡單的封裝，就能達到目的。</li>
</ul>
<h3 id="封裝"><a class="header" href="#封裝">封裝</a></h3>
<ul>
<li>如果只是一些C的函數需要封裝進來，使用cdef extern可以把C代碼中的函式宣告到cython中，當然你得有一個.c的檔來實現add函數。</li>
</ul>
<pre><code class="language-python">cdef extern int add(int x, int y)

def add_py(int x, int y):
    return add(x, y)
</code></pre>
<ul>
<li>若是有一些C++的類需要封裝進來, 舉個官方的例子，你有一個rectangle.h</li>
</ul>
<pre><code class="language-c">//rectangle.h

namespace shapes {
    class Rectangle {
    public:
        int x0, y0, x1, y1;
        Rectangle(int x0, int y0, int x1, int y1);
            int getArea();
        };
}

//rectangle.cpp
#include "Rectangle.h"
namespace shapes {
    Rectangle::Rectangle(int X0, int Y0, int X1, int Y1) {
        x0 = X0;
        y0 = Y0;
        x1 = X1;
        y1 = Y1;
    }

    int Rectangle::getArea() {
        return (x1 - x0) * (y1 - y0);
    }
}
# _rectangle.pyx

cdef extern from "Rectangle.h" namespace "shapes":
    cdef cppclass Rectangle:
        Rectangle(int, int, int, int) except +
            int x0, y0, x1, y1
            int getArea()

        def func():
            cdef Rectangle *rec = new Rectangle(1, 2, 3, 4)
            try:
                area = rec.getArea()
                return area
                ...
            finally:
                del rec     # delete heap allocated object
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../python/Loguru.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../python/WebSocket_reconnect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../python/Loguru.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../python/WebSocket_reconnect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
