<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Poetry 完全入門指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="再見了-pip最佳-python-套件管理器poetry-完全入門指南"><a class="header" href="#再見了-pip最佳-python-套件管理器poetry-完全入門指南">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></h1>
<p>前陣子工作上的專案從原先的 pip 改用 Poetry 管理 Python 套件，由於採用 Poetry 正是我的提議，所以必須身先士卒，研究 Poetry 使用上的重點與學習成本，並評估是否真有所值——講白了就是至少要利大於弊，不然會徒增團隊適應上的負擔。</p>
<p>拜這個機會所賜，我對 Poetry 總算有了一個較為全面的理解。</p>
<p>習慣以後，現在我所有的個人開發也都改用 Poetry 來管理套件及虛擬環境，對於 Poetry 這個略嫌複雜的工具（相比於 pip），上手的同時我也感受到它確實存在一些學習門檻，間接促使了本文的誕生。</p>
<p>有鑑於 Poetry 真的有點複雜，如果要推薦別人使用，我想還是有必要好好介紹一下。</p>
<p>本文除了講解如何使用 Poetry，還會先不厭其煩地闡述它所解決的痛點，若興趣不大，可以直接跳到「<a href="https://blog.kyomind.tw/python-poetry/#%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8-Poetry">從零開始使用 Poetry</a>」章節，但看完前導部分，相信能更加體會 Poetry 的必要性。</p>
<p>為了讓你無痛上手！這將會是一篇超過 8000 字的長文，還請多多擔待。🙏</p>
<h3 id="主要目錄"><a class="header" href="#主要目錄">主要目錄</a></h3>
<p>供快速跳轉（桌面版用戶可和右下角的「回到最上方」搭配使用）：</p>
<ul>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F">Poetry 是什麼？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B%EF%BC%9A%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83%E7%AE%A1%E7%90%86%E3%80%81%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E3%80%81%E7%9B%B8%E4%BE%9D%E6%80%A7%E7%AE%A1%E7%90%86">名詞解釋：虛擬環境管理、套件管理、相依性管理</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#pip-%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E8%B6%B3">pip 的最大不足</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#pip-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E9%81%B8%E6%93%87">pip 替代方案選擇</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8-Poetry">從零開始使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%AE%89%E8%A3%9D-Poetry">安裝 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%88%9D%E5%A7%8B%E5%8C%96-Poetry-%E5%B0%88%E6%A1%88">初始化 Poetry 專案</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E7%AE%A1%E7%90%86-Poetry-%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">管理 Poetry 虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">Poetry 常用指令</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E8%A6%8B%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C-QA">Poetry 常見使用情境與操作 QA</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E7%B5%90%E8%AA%9E">結語</a></li>
</ul>
<h2 id="poetry-是什麼"><a class="header" href="#poetry-是什麼">Poetry 是什麼？</a></h2>
<p>比起 <a href="https://github.com/python-poetry/poetry#poetry-dependency-management-for-python">Poetry GitHub</a> 的說明：</p>
<blockquote>
<p><strong>Poetry: Dependency Management for Python</strong>
Poetry helps you declare, manage and install dependencies of Python projects, ensuring you have the right stack everywhere.</p>
</blockquote>
<p>我覺得 <a href="https://python-poetry.org/">Poetry 官網</a>的 slogan 更加簡潔有力：</p>
<p><img src="images/qTTgg0U.png" alt="" /></p>
<p>簡單來說，<strong>Poetry 類似 pip，能協助你進行套件管理</strong>（dependency management），<strong>但又比 pip 強大得多</strong>，因為它還包含了 pip 所未有的功能：</p>
<ul>
<li>虛擬環境管理</li>
<li>套件相依性管理</li>
<li>套件的打包與發布</li>
</ul>
<p>其中<strong>最為關鍵</strong>的是「<strong>套件的相依性管理</strong>」，也是本文的重點，而「套件的打包與發布」與本文主題較無關係，所以不會提及。</p>
<h2 id="名詞解釋虛擬環境管理套件管理相依性管理"><a class="header" href="#名詞解釋虛擬環境管理套件管理相依性管理">名詞解釋：虛擬環境管理、套件管理、相依性管理</a></h2>
<p>開始前，要先大致說明標題中這三者的區別，才不易混淆文中的內容。這裡的定義可能不盡準確，但至少對理解文中的表達能有所幫助。</p>
<h3 id="虛擬環境管理"><a class="header" href="#虛擬環境管理">虛擬環境管理</a></h3>
<p>指的是使用內建的 venv 或 vituralenv 套件來建立及管理 Python 的虛擬環境，不同的虛擬環境間各自獨立，講白了就是指向的路徑各不相同。</p>
<h3 id="套件管理依賴管理dependency-management"><a class="header" href="#套件管理依賴管理dependency-management">套件管理、依賴管理（dependency management）</a></h3>
<p>指的是使用 pip 這類的套件管理器來管理 Python 環境（未必是虛擬環境），即管理環境中所安裝的全部套件（package、dependency）及其版本。</p>
<p>在這個語境下，dependency 基本上就是指安裝的 package。</p>
<h3 id="套件的相依性管理依賴解析"><a class="header" href="#套件的相依性管理依賴解析">「套件的」相依性管理、依賴解析</a></h3>
<p>這個有點難定義，它並不是一個非常通俗且有共識的名詞，我在英文中也還難找到對應的名詞。本文使用它時，主要指的是<strong>套件與套件之間的依賴關係及版本衝突管理</strong>，也就是套件的「<strong>相依性管理</strong>」。在下文提及的 Podcast 中，又稱為「<strong>依賴解析</strong>」。</p>
<p>所謂套件的「版本衝突」指的是單一套件被兩個以上的套件所依賴，但不同的套件對依賴的套件有著不同的<strong>最低或最高版本要求</strong>，若兩者的要求沒有「交集」，則會產生衝突而導致套件失效或無法安裝。</p>
<h2 id="pip-的最大不足"><a class="header" href="#pip-的最大不足">pip 的最大不足</a></h2>
<p>大概在 2 年前就知道了 Poetry 的存在，不過那時我還沒有套件相依性管理的強烈需求，加上看起來需要一些學習成本（確實如此），所以就一直擱在一旁，直到真正體會到了 pip 的不足。</p>
<p>pip 是 Python 內建的套件管理工具，而它的最大罩門，就是對於「套件間的相依性管理」能力不足。尤其是在「移除」套件時的依賴解析——可以說基本沒有。這也是我提議改用 Poetry 的根本原因。</p>
<p>怎麼說？看完下面的例子就能明白。</p>
<h3 id="pip-uninstall的困境以-flask-為例"><a class="header" href="#pip-uninstall的困境以-flask-為例"><code>pip uninstall</code>的困境：以 Flask 為例</a></h3>
<p>假設現在你的工作專案中有開發 API 的需求，經過一番研究與討論，決定使用 <a href="https://github.com/pallets/flask">Flask</a> 網頁框架來進行開發。</p>
<p>我們知道，很多套件都有依賴的套件，也就是使用「別人已經造好的輪子」來構成套件功能的一部分。</p>
<p>安裝主套件時，這些依賴套件也必須一併安裝，主套件才能正常運作，這裡的 Flask 就是如此。安裝 Flask 時，不僅會安裝單一個套件<code>flask</code>，還會安裝所有 Flask 的必要構成部分，如下：</p>
<pre><code>❯ pip install flask
Collecting flask
  Downloading Flask-2.1.1-py3-none-any.whl (95 kB)
     |████████████████████████████████| 95 kB 993 kB/s
Collecting importlib-metadata&gt;=3.6.0
  Using cached importlib_metadata-4.11.3-py3-none-any.whl (18 kB)
Collecting itsdangerous&gt;=2.0
  Downloading itsdangerous-2.1.2-py3-none-any.whl (15 kB)
Collecting Werkzeug&gt;=2.0
  Downloading Werkzeug-2.1.1-py3-none-any.whl (224 kB)
     |████████████████████████████████| 224 kB 2.8 MB/s
Collecting click&gt;=8.0
  Downloading click-8.1.2-py3-none-any.whl (96 kB)
     |████████████████████████████████| 96 kB 1.9 MB/s
Collecting Jinja2&gt;=3.0
  Downloading Jinja2-3.1.1-py3-none-any.whl (132 kB)
     |████████████████████████████████| 132 kB 3.7 MB/s
Collecting zipp&gt;=0.5
  Using cached zipp-3.7.0-py3-none-any.whl (5.3 kB)
Collecting MarkupSafe&gt;=2.0
  Downloading MarkupSafe-2.1.1-cp38-cp38-macosx_10_9_x86_64.whl (13 kB)
Installing collected packages: zipp, MarkupSafe, Werkzeug, Jinja2, itsdangerous, importlib-metadata, click, flask
Successfully installed Jinja2-3.1.1 MarkupSafe-2.1.1 Werkzeug-2.1.1 click-8.1.2 flask-2.1.1 importlib-metadata-4.11.3 itsdangerous-2.1.2 zipp-3.7.0
</code></pre>
<p>從上可知，<code>pip install flask</code>還會一併安裝<code>importlib-metadata</code>、<code>itsdangerous</code>等 7 個依賴套件，實際上總共安裝了 8 個套件！</p>
<p>pip 在「安裝」套件時的相依性管理還是可以的，這並不難，因為套件的依賴要求都寫在安裝檔裡了，根本不需要「解析」。</p>
<hr />
<p>附帶一提，這 8 個套件包括<code>flask</code>，除了<code>importlib-metadata</code>和<code>zipp</code>外，其餘 6 個實際上都是 <a href="https://palletsprojects.com/p/">Flask 團隊自行開發的套件</a>。</p>
<p>但是並不是隻有 Flask 框架會使用（依賴）這些套件。</p>
<p>比如其中的 <a href="https://palletsprojects.com/p/click/">Click</a> 就是一個廣泛使用的命令製作工具。套件官網是這麼介紹的：</p>
<blockquote>
<p>Click is a Python package for <strong>creating beautiful command line interfaces</strong> in a composable way with as little code as necessary.</p>
</blockquote>
<p>別的套件也可能依賴<code>click</code>來提供命令列的功能，換句話說，主套件的依賴套件也可能被其他第三方套件所依賴、使用。</p>
<hr />
<p>好，一切都很美好，就這樣一年過去，團隊決定改用火紅的 FastAPI 取代 Flask 來實作專案的 API，作為 API 的主要開發人員，你興高採列地安裝了 FastAPI，更新了所有程式碼，最後要移除 Flask，這時問題就來了。</p>
<p>安裝 Flask 的時候，只需要<code>pip install flask</code>，pip 就會幫你一併安裝所有依賴套件。現在要移除它，也只要<code>pip uninstall flask</code>就可以了嗎？</p>
<p>很遺憾，<strong>答案是否定的</strong>。</p>
<h3 id="pip-的致命缺陷缺乏移除套件時的依賴解析相依性管理"><a class="header" href="#pip-的致命缺陷缺乏移除套件時的依賴解析相依性管理">pip 的致命缺陷：缺乏移除套件時的依賴解析（相依性管理）</a></h3>
<p>僅執行<code>pip uninstall flask</code>的話，pip 就<strong>真的只會</strong>幫你移除<code>flask</code>這個套件<strong>本身</strong>而已。那剩下的、再也用不到的套件怎麼辦？你只能一個一個手動移除！</p>
<p>但你千萬不要真的嘗試手動移除依賴套件！——因為你無法確定這些依賴套件<strong>是否同時被別的套件所依賴</strong>。</p>
<h3 id="pip-手動移除依賴套件的潛在風險以-flask--black-為例"><a class="header" href="#pip-手動移除依賴套件的潛在風險以-flask--black-為例">pip 手動移除依賴套件的潛在風險：以 Flask + Black 為例</a></h3>
<p>繼續以 Flask 為例，還記得其中一個依賴套件是<code>click</code>，如前所述，它是一個協助製作命令列界面的工具。</p>
<p>假設專案中同時也使用 <a href="https://github.com/psf/black">Black</a> 這個 formatter 進行程式碼風格管理（沒錯！我現在個人開發也都改用 Black 取代 <a href="https://github.com/google/yapf">yapf</a> 了），Black 是一個可以透過 CLI 執行的工具，很巧的，它也是使用<code>click</code>來實作命令列界面。</p>
<p>可想而知，移除 Flask 時，如果你同時把<code>click</code>也跟著一併移除，會發生什麼樣的悲劇——你的 Black 壞了。</p>
<p>簡言之，直接 pip 手動移除依賴套件存在下列兩大疑慮，不建議輕易嘗試：</p>
<p><strong>一、無法確定想移除的套件還有多少依賴套件</strong></p>
<p>正常而言，你不會去注意安裝時總共一併安裝了多少依賴套件。雖然有<code>pip show</code>這類的指令可以大概知曉套件的依賴，但這指令只會顯示「<strong>直接</strong>依賴套件」而不會顯示「依賴套件的依賴」，所以列出來的結果未必準確：</p>
<pre><code>❯ pip show flask
Name: Flask
Version: 2.1.1
Summary: A simple framework for building complex web applications.
Home-page: https://palletsprojects.com/p/flask
Author: Armin Ronacher
Author-email: armin.ronacher@active-4.com
License: BSD-3-Clause
Location: /Users/kyo/.pyenv/versions/3.8.12/envs/test/lib/python3.8/site-packages
Requires: importlib-metadata, Werkzeug, click, Jinja2, itsdangerous
Required-by:
</code></pre>
<p>可以看到，<code>Requires:</code>只顯示了 5 個依賴套件，因為剩下的 2 個（<code>zipp</code>、<code>markupsafe</code>）是「<strong>依賴的依賴</strong>」，在更下層，並未顯示。</p>
<p><strong>二、即使確定所有依賴套件，也無法確定這些套件是否還被其他套件所依賴</strong></p>
<p>好繞口啊！上述的<code>click</code>例子就是解釋這個困境。</p>
<h3 id="小結pip-只適合小型專案或只新增不移除套件的專案"><a class="header" href="#小結pip-只適合小型專案或只新增不移除套件的專案">小結：pip 只適合小型專案或「只新增不移除」套件的專案</a></h3>
<p>以前我的個人或工作上的專案往往規模不大，pip 就真的只負責新增，鮮少需要考慮移除套件的情況，所以缺少移除套件時的依賴解析，似乎也沒什麼大問題。</p>
<p>但稍具模規的專案往往就需要考慮套件的退場，以維持開發及部署環境的簡潔，尤其在使用容器化部署時，過多不必要的套件會徒增 image 的肥大，產生額外的成本與浪費。</p>
<p>然而透過上面的例子可知，僅靠 pip 想要乾淨移除過時的套件，且不影響既有的套件，簡直是不可能的任務！所以我們需要有完整套件<strong>依賴解析、相依性管理</strong>的套件管理器。</p>
<h2 id="pip-替代方案選擇"><a class="header" href="#pip-替代方案選擇">pip 替代方案選擇</a></h2>
<p>因為 pip 存在這樣的致命弱點，所以很早就有相關的方案提出想要解決它，最知名的莫過於 <a href="https://pipenv.pypa.io/en/latest/">Pipenv</a>！</p>
<p>關於 pip 的前世今生，以及為何它難以演化成理想的、可以完美管理套件相依性的版本，可以參考〈<a href="https://blog.kyomind.tw/pyenv-setup/">告別 Anaconda：在 macOS 上使用 pyenv + pyenv-virtualenv 建立 Python 開發環境</a>〉中推薦過的單集 Podcast：<a href="https://pythonhunter.org/episodes/ep15">《捕蛇者說》Ep 15. 和 PyPA 的成員聊聊 Python 開發工作流</a>。</p>
<p>從 Podcast 網頁「時間節點」目錄中可知，該集對 Python 的虛擬環境與套件管理機制及相關工具，有著非常廣泛的討論，十分精彩，強力推薦！（為了寫這篇又聽了第 3 次）</p>
<p><a href="https://i.imgur.com/gzcAU7e.png"><img src="https://i.imgur.com/gzcAU7e.png" alt="img" /></a></p>
<h3 id="pipenv-vs-poetry"><a class="header" href="#pipenv-vs-poetry">Pipenv vs Poetry</a></h3>
<p>講到需要有充分「套件相依性管理」功能的套件管理器，你基本上也只能從 Pipenv 和 Poetry 兩者之中二擇一了。</p>
<p>如果是在兩年前，這個選擇難題恐怕不容易回答，而且 Pipenv 會有較大的機率勝出，但兩年後的今天，我建議你毫不猶豫地選擇 Poetry。</p>
<h3 id="我選擇-poetry-的第一個理由"><a class="header" href="#我選擇-poetry-的第一個理由">我選擇 Poetry 的第一個理由</a></h3>
<p>第一個理由：不要選擇 Pipenv。</p>
<p>乍看之下有點鬧，但卻不失為一個具體的理由，因為當你搜尋「python poetry」關鍵字的時候，那些教你怎麼使用 Poetry 的文章往往也會一併提及為何不選擇 Pipenv。</p>
<p>以下兩篇有著較為完整的說明，請容我直接引用。</p>
<p>〈<a href="https://note.koko.guru/posts/using-poetry-manage-python-package-environments">Python - 取代 Pipenv 的新套件管理器 Poetry</a>〉：</p>
<blockquote>
<p>Pipenv 雖然強大，卻也暴露出了一些問題如 Lock 過慢、Windows 支援性差、對 PyPI 套件打包的友善度差…等更多其他問題，甚至有越來越多人表明 <a href="http://greyli.com/do-not-use-pipenv/">不要使用 Pipenv</a> 或 <a href="https://blog.gslin.org/archives/2019/12/21/9347/pipenv-%E7%9A%84%E5%87%8B%E9%9B%B6%E8%88%87%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-poetry/">pipenv 的凋零與替代方案 poetry</a> 等。</p>
</blockquote>
<blockquote>
<p>同時 Pipenv 的社群維護狀況也越來越差，有許多的 PR 都沒有被 Release，導致許多貢獻者抱怨，甚至有人發出了該篇 <a href="https://github.com/pypa/pipenv/issues/4058">If this project is dead, just tell us</a> issue 想知道是否專案已經不在維護。</p>
</blockquote>
<p>〈<a href="https://greyli.com/poetry-a-better-choice-than-pipenv/">相比 Pipenv，Poetry 是一個更好的選擇</a>〉（本文作者<a href="https://greyli.com/about/">李輝</a>為 Flask 團隊成員）：</p>
<blockquote>
<p>Pipenv 描繪了一個美夢，讓我們以為 Python 也有了其他語言那樣完善的包管理器，不過這一切卻在後來者 Poetry 這裡得到了更好的實現。</p>
</blockquote>
<blockquote>
<p>這幾年 Pipenv 收獲了很多用戶，但是也暴露了很多問題。雖然 Lock 太慢、Windows 支持不好和 bug 太多的問題都已經改進了很多，但對我來說，仍然不能接受隨時更新鎖定依賴的設定，在上一篇文章《<a href="http://greyli.com/do-not-use-pipenv/">不要用 Pipenv</a>》裡也吐槽了很多相關的問題。</p>
</blockquote>
<p>兩篇的內容總結就是一句話：不要用 Pipenv。</p>
<p>目前 Pipenv 已經由 <a href="https://github.com/pypa">PyPA</a>（同時也維護 pip 及 vituralenv）接手，上述「擺爛」的情況應該是有所好轉，不過我似乎還沒看到有什麼文章大力鼓吹或宣告 Pipenv 已經「great again」，所以個人對它的未來發展還是持保留態度。</p>
<h3 id="選擇-poetry-的第二個理由pyprojecttoml"><a class="header" href="#選擇-poetry-的第二個理由pyprojecttoml">選擇 Poetry 的第二個理由：pyproject.toml</a></h3>
<p>pyproject.toml 是 <a href="https://peps.python.org/pep-0518/">PEP 518</a> 所提出的新標準：</p>
<blockquote>
<p>The build system dependencies will be stored in a file named <code>pyproject.toml</code> that is written in the TOML format.</p>
</blockquote>
<p>雖然原意是作為套件打包的標準，但後來又有了 <a href="https://peps.python.org/pep-0621/">PEP 621</a>，擴充定性為 Python 生態系工具的共同設定檔標準，現在已經被愈來愈多套件所支援，詳細可參考<a href="https://github.com/carlosperate/awesome-pyproject">這個清單</a>及頁面中的說明：</p>
<blockquote>
<p><code>pyproject.toml</code> is a new configuration file defined in <a href="https://www.python.org/dev/peps/pep-0518/">PEP 518</a> and expanded in <a href="https://www.python.org/dev/peps/pep-0621/">PEP 621</a>. It is design to store build system requirements, but it can also store any tool configuration for your Python project, possibly replacing the need for <code>setup.cfg</code> or other tool-specific files.</p>
</blockquote>
<p>作為規範控，我很願意追隨這個標準。</p>
<p>並且，Poetry 使用<code>pyproject.toml</code>可遠遠不止是設定檔的程度，基本上相當於 Pipenv 的<code>Pipfile</code>或 npm 的<code>package.json</code>。</p>
<p>少了<code>pyproject.toml</code>，Poetry 是無法運作的。</p>
<p>好，漫長的前言到此結束，讓我們進入正題，開始學習上手 Poetry。</p>
<hr />
<h2 id="從零開始使用-poetry"><a class="header" href="#從零開始使用-poetry">從零開始使用 Poetry</a></h2>
<p>本文所有的參考資料會放在文末的「參考」一欄中，不過在此還是要特別提及主要的參考對象，總共有二：</p>
<ul>
<li><a href="https://python-poetry.org/docs/">Poetry 官方文件</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
</ul>
<p>在本文找不到你需要的內容，以上二處可能會有，所以特別提及。</p>
<p>另外本文主要以 macOS 和 Linux 環境來進行教學及安裝，Windows 用戶如果有無法順利安裝的情況，建議參考官方文件內容修正。相信如果有問題，應該也只會集中在安裝設定階段，本文其餘部分仍可適用。</p>
<h2 id="安裝-poetry"><a class="header" href="#安裝-poetry">安裝 Poetry</a></h2>
<p>Poetry 和 pip、git、pyenv 等工具一樣，都是典型的命令列工具，需要先安裝才能下達指令<code>poetry</code>。</p>
<h3 id="安裝方式選擇"><a class="header" href="#安裝方式選擇">安裝方式選擇</a></h3>
<p>而 Poetry 提供了兩種安裝方式：</p>
<ol>
<li><strong>全域安裝</strong>至使用者的家目錄。</li>
<li><strong>pip 安裝</strong>至專案的 Python 環境。</li>
</ol>
<p><strong>個人推薦使用全域安裝</strong>，連<a href="https://python-poetry.org/docs/#alternative-installation-methods-not-recommended">官方文件也這麼說</a>。</p>
<p>因為 pip 安裝是直接安裝到專案所屬的 Python 環境裡，而且 Poetry 所依賴的套件非常多，<strong>總計超過 30 個，會嚴重影響專案環境的整潔度</strong>。文件中也警告這些依賴套件的版本可能和專案既有的版本<strong>產生衝突</strong>：</p>
<blockquote>
<p>Be aware that it will also install Poetry’s dependencies which might cause conflicts with other packages.</p>
</blockquote>
<h3 id="全域安裝至家目錄"><a class="header" href="#全域安裝至家目錄">全域安裝至家目錄</a></h3>
<p>所以我們就使用全域安裝吧！參考 Poetry 的 <a href="https://github.com/python-poetry/poetry#installation">GitHub 說明</a>。</p>
<p>macOS / Linux：</p>
<pre><code>curl -sSL https://install.python-poetry.org | python3 -
</code></pre>
<p>Windows：</p>
<pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -
</code></pre>
<p>文件表示安裝的路徑如下：</p>
<blockquote>
<p>The installer installs the <code>poetry</code> tool to Poetry’s <code>bin</code> directory. This location depends on your system:</p>
</blockquote>
<ul>
<li><code>$HOME/.local/bin</code> for Unix</li>
<li><code>%APPDATA%\Python\Scripts</code> on Windows</li>
</ul>
<p>以 macOS 為例，此時如果要下指令，就需要打完整路徑<code>$HOME/.local/bin/poetry</code>，顯然不太方便，所以我們需要設定 PATH。</p>
<h3 id="設定-path"><a class="header" href="#設定-path">設定 PATH</a></h3>
<p>新增<code>poetry</code>指令執行檔所在的路徑至 PATH。</p>
<p>在<code>.zshrc</code>或<code>.bashrc</code>或<code>.bash_profile</code>新增：</p>
<pre><code>export PATH=$PATH:$HOME/.local/bin
</code></pre>
<p>存檔後重啟 shell 即可使用。直接在命令列打上<code>poetry</code>指令測試：</p>
<pre><code>❯ poetry
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]

...
</code></pre>
<h3 id="設定-alias"><a class="header" href="#設定-alias">設定 alias</a></h3>
<p>比起<code>pip</code>，<code>poetry</code>這個指令顯然太冗長了！我們還是給它一個 alias 吧！</p>
<p>基於它是我非常常用的指令，我願意賦與它「單字母」alias 的特權，我使用<code>p</code>：</p>
<pre><code>alias p='poetry'
</code></pre>
<p>測試結果：</p>
<pre><code>❯ p
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]
</code></pre>
<p>alias 是方便自己使用，但本文基於表達清晰考量，下面的解說原則上並不會使用 alias 表示。</p>
<h2 id="初始化-poetry-專案"><a class="header" href="#初始化-poetry-專案">初始化 Poetry 專案</a></h2>
<p>為了方便解說，我們先建立一個全新的專案，名為<code>poetry-demo</code>。</p>
<p>指令都很簡單，但還是建議可以一步一步跟著操作。</p>
<p>就像 git 專案需要初始化，Poetry 也需要，因為每一個使用了 Poetry 的專案中一定要有一個<code>pyproject.toml</code>。所以先來初始化，使用<code>poetry init</code>：</p>
<pre><code>mkdir poetry-demo
cd poetry-demo
poetry init
</code></pre>
<p>此時會跳出一連串的互動對話，協助你建立專案的資料，大部分可以直接<code>enter</code>跳過：</p>
<pre><code>This command will guide you through creating your pyproject.toml config.

Package name [poetry-demo]:
Version [0.1.0]:
Description []:
Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:
License []:
Compatible Python versions [^3.8]:

Would you like to define your main dependencies interactively? (yes/no) [yes]
</code></pre>
<p>直到出現「Would you like to define your main dependencies interactively? (yes/no) [yes]」，我會選「no」，隨即讓你確認本次產生的<code>toml</code>檔內容：</p>
<pre><code>Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file

[tool.poetry]
name = "poetry-demo"
version = "0.1.0"
description = ""
authors = ["kyo &lt;odinxp@gmail.com&gt;"]

[tool.poetry.dependencies]
python = "^3.8"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry-core&gt;=1.0.0"]
build-backend = "poetry.core.masonry.api"
</code></pre>
<p>並詢問你「Do you confirm generation? (yes/no) [yes]」，按<code>enter</code>使用預設選項或回答「yes」則<code>pyproject.toml</code>建立完成。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
└── pyproject.toml

0 directories, 1 file
</code></pre>
<h2 id="管理-poetry-虛擬環境"><a class="header" href="#管理-poetry-虛擬環境">管理 Poetry 虛擬環境</a></h2>
<p>我覺得學習 Poetry 的第一道關卡，就是它對於虛擬環境的管理。</p>
<h3 id="強制虛擬環境"><a class="header" href="#強制虛擬環境">強制虛擬環境</a></h3>
<p>Poetry 預設上（可透過<code>poetry config</code>修改）會強制套件都要安裝在虛擬環境中，以免汙染全域，所以它整合了<code>vitrualenv</code>。</p>
<p>在執行<code>poetry add、install</code>等指令時，Poetry 都會自動檢查<strong>是否正在使用虛擬環境：</strong></p>
<ul>
<li>如果是，則會直接安裝套件至當前的虛擬環境。</li>
<li>如果否，則會自行幫你建立一個獨立的虛擬環境，再進行套件安裝。</li>
</ul>
<h3 id="容易混淆的虛擬環境"><a class="header" href="#容易混淆的虛擬環境">容易混淆的虛擬環境</a></h3>
<p>Poetry 直接整合的虛擬環境管理算是立意良善，相當於把<code>pip</code>+<code>venv</code>的功能整合在一起，但如此也帶來一定的複雜度，尤其在你已經自行使用了<code>venv</code>、<code>vitrualenv</code>或 <code>pyenv-vitrualenv</code>或<code>conda</code>來管理虛擬環境的情況下！</p>
<p>沒錯，Python 的虛擬環境管理就是這麼麻煩。</p>
<p>個人建議，對新手而言，於 Poetry 的專案中，<strong>一律使用 Poetry</strong> 來管理虛擬環境即可。</p>
<h3 id="以指令建立虛擬環境"><a class="header" href="#以指令建立虛擬環境">以指令建立虛擬環境</a></h3>
<p>使用指令<code>poetry env use python</code>：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo-IEWSZKSE-py3.8 in /Users/kyo/Library/Caches/pypoetry/virtualenvs
Using virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重點說明：</p>
<ul>
<li>Poetry 原則上會使用目前的 Python 版本來建立虛擬環境，這取決於<code>python</code>在你的 PATH 是連結到哪個版本，也可以明示為<code>python3</code>或<code>python3.8</code>，前提是 PATH 中確實存在這些連結。</li>
<li>Poetry 會統一將虛擬環境建立在「特定目錄」下，本例中是<code>/Users/kyo/Library/Caches/pypoetry/virtualenvs</code>。</li>
<li>虛擬環境的命名模式固定為<code>專案名稱-亂數-Python版本</code>。</li>
</ul>
<p>老實說我個人不是很喜歡這樣的做法，因為如此一來單一專案允許建立複數個虛擬環境（Python 3.7、 3.8、3.9 可以各來一個），彈性之餘也增加了混亂程度，且命名模式我也不喜歡，太冗長了。</p>
<p>既然 Poetry 管理的套件環境是高度綁定專案本身的，我更偏好<code>venv</code>式的做法，也就是<strong>把虛擬環境放到專案目錄內</strong>，而不是統一放在獨立的目錄下，讓虛擬環境與專案呈現<strong>直觀的一對一關係</strong>。</p>
<p>所幸 Poetry 具備這樣的選項。</p>
<h3 id="修改config建立專案內的venv虛擬環境"><a class="header" href="#修改config建立專案內的venv虛擬環境">修改<code>config</code>，建立專案內的<code>.venv</code>虛擬環境</a></h3>
<p>讓我們使用<code>poetry config</code>指令來查看 Poetry 目前幾個主要的設定，需要使用<code>--list</code>這個參數：</p>
<pre><code>❯ poetry config --list
cache-dir = "/Users/kyo/Library/Caches/pypoetry"
experimental.new-installer = true
installer.parallel = true
virtualenvs.create = true
virtualenvs.in-project = false
virtualenvs.path = "{cache-dir}/virtualenvs"
</code></pre>
<p>其中<code>virtualenvs.create = true</code>若改成<code>false</code>，則可以停止 Poetry 在「偵測不到虛擬環境時會自行建立」的行為模式，但建議還是不要更動。</p>
<p>而<code>virtualenvs.in-project = false</code>就是我們要修改的目標：</p>
<pre><code>poetry config virtualenvs.in-project true
</code></pre>
<p>好，我們先把之前建立的虛擬環境刪除：</p>
<pre><code>❯ poetry env remove python
Deleted virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重新建立，看看行為有何差異：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo in /Users/kyo/Documents/code/poetry-demo/.venv
Using virtualenv: /Users/kyo/Documents/code/poetry-demo/.venv
</code></pre>
<p>可以看出：</p>
<ul>
<li>虛擬環境的路徑改為「專案的根目錄」。</li>
<li>名稱固定為<code>.venv</code>。</li>
</ul>
<p>我覺得這樣的設定更加簡潔。</p>
<h3 id="啟動與退出虛擬環境"><a class="header" href="#啟動與退出虛擬環境">啟動與退出虛擬環境</a></h3>
<p>啟動虛擬環境，需移至專案目錄底下，使用指令<code>poetry shell</code>：</p>
<pre><code>❯ poetry shell
Spawning shell within /Users/kyo/Documents/code/poetry-demo/.venv
❯ . /Users/kyo/Documents/code/poetry-demo/.venv/bin/activate 
</code></pre>
<p><code>poetry shell</code>指令會偵測當前目錄或所屬上層目錄是否存在<code>pyproject.toml</code>來確定所要啟動的虛擬環境，所以如果不移至專案目錄，則會出現下列錯誤：</p>
<pre><code>❯ poetry shell

  RuntimeError

  Poetry could not find a pyproject.toml file in /Users/kyo/Documents/code or its parents

  at ~/Library/Application Support/pypoetry/venv/lib/python3.8/site-packages/poetry/core/factory.py:369 in locate
      365│             if poetry_file.exists():
      366│                 return poetry_file
      367│
      368│         else:
    → 369│             raise RuntimeError(
      370│                 "Poetry could not find a pyproject.toml file in {} or its parents".format(
      371│                     cwd
      372│                 )
      373│             )
</code></pre>
<p>可以看出 Poetry 的錯誤訊息非常清楚，讓你很容易知曉修正的方向，這是作為一個命令列工具的必要優點。</p>
<p>退出就簡單多了，只需要<code>exit</code>即可。</p>
<h2 id="poetry-常用指令"><a class="header" href="#poetry-常用指令">Poetry 常用指令</a></h2>
<p>Poetry 是一個獨立的命令列工具，就像 pyenv，它有自己的指令，需要花費額外的心力學習。這可能是使用 Poetry 的第二道關卡。所幸和 pyenv 一樣，常用的指令就那幾個而已，所以不用擔心，下面會一一介紹。</p>
<p>繼續使用前面提過的 Flask 和 Black 這兩個套件來加以來示範並說明 Poetry 的優勢與和 pip 的不同之處。本文的示範就只會安裝或移除這兩個套件而已。</p>
<h3 id="poetry-新增套件"><a class="header" href="#poetry-新增套件">Poetry 新增套件</a></h3>
<p>使用指令：</p>
<pre><code>poetry add
</code></pre>
<p>相當於<code>pip install</code>，我們來試著安裝 Flask 看看會有什麼變化：</p>
<p><a href="https://i.imgur.com/H7pPtsk.png"><img src="https://i.imgur.com/H7pPtsk.png" alt="img" /></a></p>
<p>圖中可以看出 Poetry 漂亮的命令列資訊呈現，會清楚告知總共新增了幾個套件。</p>
<p>此時專案中的<code>pyproject.toml</code>也會發生變化：</p>
<pre><code>...
[tool.poetry.dependencies]
python = "^3.8"
Flask = "^2.1.1"

[tool.poetry.dev-dependencies]

[build-system]
...
</code></pre>
<p>這裡要說明，安裝 Flask，則<code>pyproject.toml</code>就只會顯示<code>Flask = "^2.1.1"</code>這個 <strong>top-level</strong> 的 package 項目，其餘的依賴套件<strong>不會</strong>直接記錄在<code>toml</code>檔中。</p>
<p>我覺得這是一大優點，方便區分哪些是你<strong>主動安裝</strong>的主要套件，而哪些又是基於套件的依賴關係而一併安裝的依賴套件。</p>
<h3 id="poetrylock-與更新順序"><a class="header" href="#poetrylock-與更新順序">poetry.lock 與更新順序</a></h3>
<p>除了<code>pyproject.toml</code>，此時專案中還會增加一個新增檔案，名為<code>poetry.lock</code>，它實際上就相當於 pip 中的<code>requirements.txt</code>，詳細記載了所有安裝的套件與版本。</p>
<p>當你使用<code>poetry add</code>指令時，Poetry 會自動依序幫你做完這三件事：</p>
<ul>
<li>更新<code>pyproject.toml</code>。</li>
<li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。</li>
<li>依照<code>poetry.lock</code>的內容，更新虛擬環境。</li>
</ul>
<p>換句話說，<code>poetry.lock</code>的內容主要是取決於<code>pyproject.toml</code>，但兩者並不會自己連動，一定要基於特定指令才會進行同步與更新，<code>poetry add</code>就是一個典型案例。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
└── pyproject.toml

0 directories, 2 files
</code></pre>
<h3 id="更新-poetrylock"><a class="header" href="#更新-poetrylock">更新 poetry.lock</a></h3>
<p>當你自行修改了<code>pyproject.toml</code>內容，比如變更特定套件的版本與範圍（這是有可能的，尤其在手動處理版本衝突的時候），此時<code>poetry.lock</code>的內容與<code>pyproject.toml</code>出現了脫鉤，必須讓它依照新的<code>pyproject.toml</code>內容來自我更新，使用指令：</p>
<pre><code>poetry lock
</code></pre>
<p>如此一來，手動修改的內容，才能確保也更新到<code>poetry.lock</code>，畢竟虛擬環境如果要重新建立，是基於<code>poetry.lock</code>的內容來安裝套件，而非<code>pyproject.toml</code>。</p>
<p>再次強調，<code>poetry.lock</code>相當於 Poetry 的<code>requirements.txt</code>。</p>
<h3 id="列出全部套件清單--樹狀顯示"><a class="header" href="#列出全部套件清單--樹狀顯示">列出全部套件清單 + 樹狀顯示</a></h3>
<p>類似<code>pip list</code>，這裡使用<code>poetry show</code>：</p>
<pre><code>❯ poetry show
click              8.1.2  Composable command line interface toolkit
flask              2.1.1  A simple framework for building complex web applications.
importlib-metadata 4.11.3 Read metadata from Python packages
itsdangerous       2.1.2  Safely pass data to untrusted environments and back.
jinja2             3.1.1  A very fast and expressive template engine.
markupsafe         2.1.1  Safely add untrusted strings to HTML/XML markup.
werkzeug           2.1.1  The comprehensive WSGI web application library.
zipp               3.8.0  Backport of pathlib-compatible object wrapper for zip files
</code></pre>
<p>特別提醒的是，這裡的清單內容並不是來自於虛擬環境，這點和 pip 不同，而是來自於<code>poetry.lock</code>的內容。</p>
<p>而 Poetry 最為人津津樂道的就是它的樹狀顯示<code>poetry show --tree</code>：</p>
<pre><code>❯ poetry show --tree
flask 2.1.1 A simple framework for building complex web applications.
├── click &gt;=8.0
│   └── colorama *
├── importlib-metadata &gt;=3.6.0
│   └── zipp &gt;=0.5
├── itsdangerous &gt;=2.0
├── jinja2 &gt;=3.0
│   └── markupsafe &gt;=2.0
└── werkzeug &gt;=2.0
</code></pre>
<p>讓主要套件與其依賴套件的關係層次，一目瞭然。</p>
<h3 id="安裝套件至-dev-dependencies"><a class="header" href="#安裝套件至-dev-dependencies">安裝套件至 dev-dependencies</a></h3>
<p>有些套件，比如<code>pytest</code>、<code>flake8</code>等等，只會在開發環境中使用，產品的部署環境並不需要，Poetry 允許你區分這兩者，將上述的套件安裝至<code>dev-dependencies</code>區塊，方便讓你輕鬆建立一份沒有這些套件的虛擬環境。</p>
<p>在此以 Black 為例，安裝方式如下：</p>
<pre><code>poetry add black -D
</code></pre>
<p>或</p>
<pre><code>poetry add black --dev
</code></pre>
<p>結果的區別顯示在<code>pyproject.toml</code>裡：</p>
<pre><code>...
[tool.poetry.dependencies]
python = "^3.8"
Flask = "^2.1.1"

[tool.poetry.dev-dependencies]
black = "^22.3.0"
...
</code></pre>
<p>可以看到<code>black</code>被列在不同區塊：<code>tool.poetry.dev-dependencies</code>。</p>
<p>然而這是記載上的差異，使用上具體的差別為何？下面會再次提及，可以理解為「輸出套件環境」上的差異。</p>
<h3 id="poetry-移除套件"><a class="header" href="#poetry-移除套件">Poetry 移除套件</a></h3>
<p>使用<code>poetry remove</code>指令。和<code>poetry add</code>一樣，可以加上<code>-D</code>參數來移除置於開發區的套件。</p>
<p>而移除套件時的「依賴解析」能力，正是 Poetry 遠遠優於 pip 的主要環節，因為 pip 沒有嘛！也是為何我提議改用 Poetry 的關鍵理由——為了順利移除套件。</p>
<p>前面已經提過，pip 的<code>pip uninstall</code>只會移除你所指定的套件，而不會連同依賴套件一起移除——因為 pip 沒有「依賴解析」功能。如果貿然移除「安裝時所有一併安裝」的依賴套件，可能會造成巨大的災難，讓別的套件失去效用。</p>
<p>前面也舉了 Flask 和 Black 都共同依賴<code>click</code>這個套件的例子，在人為手動移除的情況下，你可能未曾注意 Black 也依賴了<code>click</code>，結果為了「徹底移除」Flask 的所有相關套件，不小心把<code>click</code>也移除掉了。</p>
<p>當然，我知道，絕大部分的真實情況是——你根本不會去移除一段時間前安裝但已不再使用的套件。</p>
<hr />
<p>好，解釋了很多，接下來就是 Poetry 的表演了，它會幫你處理這些棘手的「套件相依性」難題，讓你輕鬆移除 Flask 而不影響 Black：</p>
<p><a href="https://i.imgur.com/79TycuL.png"><img src="https://i.imgur.com/79TycuL.png" alt="img" /></a></p>
<p>可以對比上面安裝 Flask 時的截圖，總共安裝了 8 個套件，但現在移除卻只有 7 個——沒錯，因為 Poetry 知道 Black 還需要<code>click</code>！不能移除：</p>
<pre><code>❯ poetry show --tree
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>一個套件直到環境中的<strong>其餘套件都不再依賴它</strong>，Poetry 才會安心讓它被移除。</p>
<h3 id="輸出-poetry-虛擬環境的-requirementstxt"><a class="header" href="#輸出-poetry-虛擬環境的-requirementstxt">輸出 Poetry 虛擬環境的 requirements.txt</a></h3>
<p>理論上，全面改用 Poetry 後，專案中是不需要存在<code>requirements.txt</code>，因為它的角色已經完全被<code>poetry.lock</code>所取代。</p>
<p>但事實是，你還是很可能需要它，甚至還需要隨著<code>poetry.lock</code>同步更新它的內容！至少對我而言就是如此，我在 Docker 部署環境中並不使用 Poetry，所以我需要一份完全等價於<code>poetry.lock</code>的<code>requirements.txt</code>用於 Docker 部署。</p>
<p>如果你想說，那我就在 Poetry 的虛擬環境下，使用以往熟悉的指令<code>pip freeze &gt; requirements.txt</code>，來產生一份不就好了？我本來也是這麼想的。但實際的產出卻是如此（目前 poetry-demo 專案僅剩下 Black）：</p>
<pre><code>black @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/11/4c/fc/cd6d885e9f5be135b161e365b11312cff5920d7574c8446833d7a9b1a3/black-22.3.0-cp38-cp38-macosx_10_9_x86_64.whl
click @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/f0/23/09/b13d61d1fa8b3cd7c26f67505638d55002e7105849de4c4432c28e1c0d/click-8.1.2-py3-none-any.whl
mypy-extensions @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/b6/a0/b0/a5dc9acd6fd12aba308634f21bb7cf0571448f20848797d7ecb327aa12/mypy_extensions-0.4.3-py2.py3-none-any.whl
...
</code></pre>
<p>這呈現好像不是我們以前熟悉的那種：</p>
<pre><code>black==22.3.0
click==8.1.2
mypy_extensions==0.4.3
...
</code></pre>
<p>沒錯，只要是使用<code>poetry add</code>安裝的套件，在<code>pip freeze</code>就會變成這樣。此時想輸出類似<code>requirements.txt</code>的樣式，需要使用<code>poetry export</code>。</p>
<p>預設輸出會有 hash 值，不想納入則要加上參數去除。現在我都是用以下指令來輸出：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes
</code></pre>
<p>我們再看一下輸出結果，雖然不盡相同，但也相去不遠了…嗎？等等，怎麼是空白？</p>
<hr />
<p>因為<code>poetry export</code>預設只會輸出<code>toml</code>中的<code>[tool.poetry.dependencies]</code>區塊的套件！還記得上面我們把 Black 安裝到<code>[tool.poetry.dev-dependencies]</code>了嗎？</p>
<p>顯然 Poetry 認為你的 export 需求基本上就為了部署，並不需要開發區的套件。這倒是沒錯，不過基於演示需求，我們必須輸出<code>[tool.poetry.dev-dependencies]</code>的套件，才能看到 Black。</p>
<p>加上<code>—-dev</code>參數即可：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes --dev
</code></pre>
<p>輸出的<code>requirements.txt</code>內容：</p>
<pre><code>black==22.3.0; python_full_version &gt;= "3.6.2"
click==8.1.2; python_version &gt;= "3.7" and python_full_version &gt;= "3.6.2"
colorama==0.4.4; python_version &gt;= "3.7" and python_full_version &gt;= "3.6.2" and platform_system == "Windows"
...
</code></pre>
<p>雖然長得有點不一樣，但這個檔案確實是可以<code>pip install</code>的。</p>
<p>從這裡也可以看出前面提及的「區分套件安裝區塊」的價值了——有些時候並不需要輸出開發專用套件。</p>
<p><code>poetry export</code>所有參數用法與說明，請參考<a href="https://python-poetry.org/docs/cli/#export">文件</a>。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
├── pyproject.toml
└── requirements.txt

0 directories, 3 files
</code></pre>
<h3 id="小結poetry-常用指令清單"><a class="header" href="#小結poetry-常用指令清單">小結：Poetry 常用指令清單</a></h3>
<p>算來算去，Poetry 的常用指令主要有下面幾個：</p>
<ul>
<li><code>poetry add</code></li>
<li><code>poetry remove</code></li>
<li><code>poetry export</code></li>
<li><code>poetry env use</code></li>
<li><code>poetry shell</code></li>
<li><code>poetry show</code></li>
<li><code>poetry init</code></li>
<li><code>poetry install</code></li>
</ul>
<p>其中一半以上，單一專案可能只會用個一兩次而已，比如<code>init</code>、<code>install</code>和<code>env use</code>，實際上需要學習的指令並不多。</p>
<p>那麼，只要知曉這些指令，就可以順利運用 Poetry 了嗎？可能是，也可能否，所以我下面還會再補充 Poetry 的常見使用情境與操作方式，讓你接納 Poetry 的阻力可以進一步下降！</p>
<h2 id="poetry-常見使用情境與操作-qa"><a class="header" href="#poetry-常見使用情境與操作-qa">Poetry 常見使用情境與操作 QA</a></h2>
<p>這部分會以「使用場景」的角度切入，介紹 Poetry 應用情境與操作說明，還包括一些自問自答，如下：</p>
<ol>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%80%E3%80%81%E6%96%B0%E5%A2%9E%E5%B0%88%E6%A1%88%E4%B8%A6%E4%BD%BF%E7%94%A8-Poetry">新增專案並使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%8C%E3%80%81%E7%8F%BE%E6%9C%89%E5%B0%88%E6%A1%88%E6%94%B9%E7%94%A8-Poetry">現有專案改用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%89%E3%80%81%E5%9C%A8%E5%88%A5%E8%87%BA%E4%B8%BB%E6%A9%9F%E5%9B%9E%E5%BE%A9%E5%B0%88%E6%A1%88%E7%8B%80%E6%85%8B">在別臺主機回復專案狀態</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%9B%9B%E3%80%81%E6%88%91%E6%83%B3%E8%A6%81%E9%87%8D%E5%BB%BA%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">我想要重建虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">為什麼我不在 Docker 環境中使用 Poetry？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%85%AD%E3%80%81%E6%88%91%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%BF%92%E6%85%A3%E7%9A%84-vituralenv-%E5%97%8E%EF%BC%9F">我可以使用自己習慣的 vituralenv 嗎？</a></li>
</ol>
<h3 id="一新增專案並使用-poetry"><a class="header" href="#一新增專案並使用-poetry">一、新增專案並使用 Poetry</a></h3>
<p>這是最理想的狀態，沒有過去的「包袱」，可謂是最能輕鬆採用 Poetry 的情境。</p>
<p>使用順序不外乎是：</p>
<ol>
<li><code>poetry init</code>：初始化，建立<code>pyproject.toml</code>。</li>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。</li>
<li><code>poetry shell</code>：進入專案但虛擬環境還未啟動，以這個指令啟動。如果使用本指令時虛擬環境<strong>還不存在或已移除</strong>，則會直接自動幫你建立虛擬環境並使用。</li>
<li><code>poetry add</code>：新增套件，必要使用<code>-D</code>參數新增至 dev 區塊。</li>
<li><code>poetry remove</code>：移除套件，若是移除 dev 區塊的套件，需要加上<code>-D</code>參數。</li>
</ol>
<p>這部分和前面內容沒有差別，因為前面內容就是以全新專案作為基礎。</p>
<h3 id="二現有專案改用-poetry"><a class="header" href="#二現有專案改用-poetry">二、現有專案改用 Poetry</a></h3>
<p>這是極為常見的需求，但並沒有很正式的做法，因為不存在<code>poetry import</code>之類的指令。</p>
<p>首先要考量的就是：要怎麼把<code>requirements.txt</code>的所有項目加到<code>pyproject.toml</code>中呢？經過一番 Google，基本上<a href="https://stackoverflow.com/questions/62764148/how-to-import-requirements-txt-from-an-existing-project-using-poetry">只能土法煉鋼</a>：</p>
<pre><code>cat requirements.txt | xargs poetry add
</code></pre>
<p>在這個過程是有可能遇到問題的，因為 Poetry 對套件的版本衝突比較敏感，所以在<code>requirements.txt</code>能正常安裝的項目，在上述指令的過程中可能會出錯。</p>
<p>那怎麼辦？只能照著錯誤訊息去修正<code>requirements.txt</code>中的套件版本。</p>
<p>並且，這個 import 做法實在是不得已，因為我們最早介紹<code>pyproject.toml</code>時有提到，原則上它只會記載「主套件」，但這個做法相當於把<code>requirements.txt</code>中的<strong>所有套件都當作主套件</strong>來<code>add</code>了！——畢竟<code>requirements.txt</code>沒有能力區分主套案與依賴套件，都是「一視同仁」地列出。</p>
<p>如此做法讓專案的套件失去了主從之分，日後想要移除主套件時，就需要比較多心力去分辨主從，比如使用<code>poetry show --tree</code>去一一檢視，終究是麻煩的事。</p>
<p>完成轉換後，保險起見，重建一個虛擬環境會比較合適。</p>
<h3 id="三在別臺主機回復專案狀態"><a class="header" href="#三在別臺主機回復專案狀態">三、在別臺主機回復專案狀態</a></h3>
<p>這也是非常常見的需求。</p>
<p>第一步當然是<code>git clone</code>專案，此時專案中已經有 Poetry 所需的必要資訊了——也就是<code>pyproject.toml</code>和<code>poetry.lock</code>。</p>
<p>你還缺少的僅僅是虛擬環境。如果是全新的主機，則還得先安裝、設定好 Poetry。</p>
<p>移至專案目錄底下，然後依序操作：</p>
<ol>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。如果你懶得打這麼長的指令，直接<code>poetry shell</code>也是可以。</li>
<li><code>poetry install</code>：因為是舊專案，不再需要<code>init</code>，直接從<code>poetry.lock</code>安裝套件！使用的就是這個指令，類似<code>npm install</code>。</li>
</ol>
<h3 id="四我想要重建虛擬環境"><a class="header" href="#四我想要重建虛擬環境">四、我想要重建虛擬環境</a></h3>
<p>在使用專案內虛擬環境方案，也就是<code>.venv</code>的前提下，想要刪除這個虛擬環境並加以重建，也不需要使用<code>poetry env remove python</code>指令了，因為會出錯。</p>
<p>還有更簡單暴力的方式，是什麼呢？當然是直接刪除<code>.venv</code>資料夾即可。</p>
<p>然後再<code>poetry env use python</code>或<code>poetry shell</code>建一個新的就好。</p>
<h3 id="五為什麼我不在-docker-環境中使用-poetry"><a class="header" href="#五為什麼我不在-docker-環境中使用-poetry">五、為什麼我不在 Docker 環境中使用 Poetry？</a></h3>
<p>因為啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會增加新的藕合與依賴，我覺得並不妥當。</p>
<p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p>
<h3 id="六我可以使用自己習慣的-vituralenv-嗎"><a class="header" href="#六我可以使用自己習慣的-vituralenv-嗎">六、我可以使用自己習慣的 vituralenv 嗎？</a></h3>
<p>當然可以。</p>
<p>我本來也繼續使用<code>pyenv</code>的<code>vituralenv</code>，但兩者有時候也是會小小打架，後來還是索性用 Poetry 的虛擬環境就好。一個專案對應一個虛擬環境，我認為還是比較簡潔的做法。</p>
<hr />
<h2 id="結語"><a class="header" href="#結語">結語</a></h2>
<p>使用 Poetry 來管理專案的套件與虛擬環境，雖然需要一定的學習成本，但帶來的效益還是相當可觀的，尤其在你希望能乾淨且安心地移除套件的時候。</p>
<p>別再猶豫，從今天起，加入 Poetry 的行列吧！</p>
<h3 id="參考"><a class="header" href="#參考">參考</a></h3>
<ul>
<li>https://python-poetry.org/docs/</li>
<li>https://github.com/python-poetry/poetry</li>
<li>https://github.com/python-poetry/poetry/issues/3248</li>
<li>https://github.com/python-poetry/poetry/issues/5185</li>
<li><a href="https://note.koko.guru/posts/using-poetry-manage-python-package-environments">Python - 取代 Pipenv 的新套件管理器 Poetry</a></li>
<li><a href="https://greyli.com/poetry-a-better-choice-than-pipenv/">相比 Pipenv，Poetry 是一個更好的選擇</a></li>
<li><a href="https://shazi.info/pip-pipenv-%E5%92%8C-poetry-%E7%9A%84%E9%81%B8%E6%93%87/">pip, pipenv 和 poetry 的選擇</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
<li><a href="https://pythonhunter.org/episodes/ep15">Ep 15. 和 PyPA 的成員聊聊 Python 開發工作流</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../python/python.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../python/搭建gRPC服務.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../python/python.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../python/搭建gRPC服務.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
