<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>從零開始使用 Poetry - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="從零開始使用-poetry"><a class="header" href="#從零開始使用-poetry">從零開始使用 Poetry</a></h2>
<p>出處: https://blog.kyomind.tw/python-poetry/</p>
<p>本文所有的參考資料會放在文末的「參考」一欄中，不過在此還是要特別提及主要的參考對象，總共有二：</p>
<ul>
<li><a href="https://python-poetry.org/docs/">Poetry 官方文件</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
</ul>
<p>如果在本文找不到你需要的內容，以上二處可能會有，所以主動列出。</p>
<p>另外本文主要以 macOS 和 Linux（Ubuntu）環境來進行安裝及教學，Windows 用戶如果有無法順利安裝的情況，建議參考官方文件內容修正。不過，即使有問題，應該也是集中在安裝與設定階段，本文其餘部分仍可適用。</p>
<h2 id="安裝-poetry"><a class="header" href="#安裝-poetry">安裝 Poetry</a></h2>
<p>Poetry 和 pip、git、pyenv 等工具一樣，都是典型的<strong>命令列工具</strong>，需要先安裝才能下達指令——<code>poetry</code>。</p>
<h3 id="安裝方式選擇"><a class="header" href="#安裝方式選擇">安裝方式選擇</a></h3>
<p>Poetry 主要提供了<a href="https://python-poetry.org/docs/#installation">兩種安裝方式</a>：</p>
<ol>
<li><strong>全域安裝</strong>至使用者的家目錄。</li>
<li><strong>pip 安裝</strong>至專案使用的 Python（虛擬）環境，即<code>pip install poetry</code>。</li>
</ol>
<p><strong>個人推薦使用全域安裝</strong>，官方文件也表示<a href="https://python-poetry.org/docs/#alternative-installation-methods-not-recommended">不推薦使用 pip 安裝</a>。</p>
<p>因為 pip 安裝是直接安裝到「<strong>專案所屬的 Python 虛擬環境</strong>」裡，而 Poetry 所依賴的套件非常多，<strong>總計超過 30 個，會嚴重影響專案虛擬環境的整潔度</strong>。文件中也警告這些依賴套件可能和專案本身的套件<strong>發生衝突</strong>：</p>
<blockquote>
<p>Be aware that it will also install Poetry’s dependencies which <strong>might cause conflicts with other packages.</strong></p>
</blockquote>
<h3 id="全域安裝-poetry-至家目錄"><a class="header" href="#全域安裝-poetry-至家目錄">全域安裝 Poetry 至家目錄</a></h3>
<p>所以我們就使用全域安裝吧！</p>
<h4 id="macos--linux--wslwindows-subsystem-for-linux"><a class="header" href="#macos--linux--wslwindows-subsystem-for-linux">macOS / Linux / WSL（Windows Subsystem for Linux）</a></h4>
<pre><code>curl -sSL https://install.python-poetry.org | python3 -
</code></pre>
<p>或</p>
<pre><code>curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -
</code></pre>
<p>Poetry 實際安裝路徑如下：</p>
<blockquote>
<p>The installer installs the <code>poetry</code> tool to Poetry’s <code>bin</code> directory. This location depends on your system:</p>
</blockquote>
<ul>
<li><code>$HOME/.local/bin</code> for Unix</li>
<li><code>%APPDATA%\Python\Scripts</code> on Windows</li>
</ul>
<p>以 macOS 為例，如果要下<code>poetry</code>指令，就需要打完整路徑<code>$HOME/.local/bin/poetry</code>，顯然不太方便，所以我們需要設定 PATH。</p>
<h3 id="設定-path"><a class="header" href="#設定-path">設定 PATH</a></h3>
<p>新增<code>poetry</code>指令執行檔所在的路徑至 PATH。</p>
<p>在<code>.zshrc</code>或<code>.bashrc</code>或<code>.bash_profile</code>新增：</p>
<pre><code>export PATH=$PATH:$HOME/.local/bin
</code></pre>
<p>存檔後重啟 shell 即可使用。直接在命令列打上<code>poetry</code>指令測試：</p>
<pre><code>❯ poetry
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]

...
</code></pre>
<h3 id="設定-alias"><a class="header" href="#設定-alias">設定 alias</a></h3>
<p>比起<code>pip</code>，<code>poetry</code>這個指令實在太冗長了！我們還是給它一個 alias 吧！</p>
<p>基於它是我極為常用的指令，我願意賦與它**「單字母」的 alias 特權**，我使用<code>p</code>：</p>
<pre><code>alias p='poetry'
</code></pre>
<p>測試結果：</p>
<pre><code>❯ p
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]
</code></pre>
<p>alias 是方便自己使用，但本文基於表達清晰考量，下面的解說除了圖片外，原則上並不會使用 alias 表示。</p>
<hr />
<h2 id="初始化-poetry-專案"><a class="header" href="#初始化-poetry-專案">初始化 Poetry 專案</a></h2>
<p>為了方便解說，我們先建立一個全新的專案，名為<code>poetry-demo</code>。</p>
<p>指令都很簡單，但還是建議可以一步一步跟著操作。</p>
<p>就像 git 專案需要初始化，Poetry 也需要，因為每一個使用了 Poetry 的專案中一定要有一個<code>pyproject.toml</code>作為它的<strong>設定檔</strong>。否則直接使用<code>poetry</code>相關指令就會出現下列錯誤訊息：</p>
<blockquote>
<p>Poetry could not find a pyproject.toml file in {cwd} or its parents</p>
</blockquote>
<p>所以一定先初始化，使用<code>poetry init</code>：</p>
<pre><code>mkdir poetry-demo
cd poetry-demo
poetry init
</code></pre>
<p>此時會跳出一連串的互動對話，協助你建立專案的資料，大部分可以直接<code>enter</code>跳過：</p>
<pre><code>This command will guide you through creating your pyproject.toml config.

Package name [poetry-demo]:
Version [0.1.0]:
Description []:
Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:
License []:
Compatible Python versions [^3.8]:

Would you like to define your main dependencies interactively? (yes/no) [yes]
</code></pre>
<p>直到出現「<code>Would you like to define your main dependencies interactively? (yes/no) [yes]</code>」，我們先選擇「<strong>no</strong>」後，會讓你確認本次產生的<code>toml</code>檔內容：</p>
<pre><code>Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file

[tool.poetry]
name = "poetry-demo"
version = "0.1.0"
description = ""
authors = ["kyo &lt;odinxp@gmail.com&gt;"]

[tool.poetry.dependencies]
python = "^3.8"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry-core&gt;=1.0.0"]
build-backend = "poetry.core.masonry.api"
</code></pre>
<p>並詢問你「<code>Do you confirm generation? (yes/no) [yes]</code>」，按<code>enter</code>使用預設選項「yes」或直接回答「yes」，則<code>pyproject.toml</code>建立完成。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
└── pyproject.toml

0 directories, 1 file
</code></pre>
<h2 id="管理-poetry-虛擬環境"><a class="header" href="#管理-poetry-虛擬環境">管理 Poetry 虛擬環境</a></h2>
<p>我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於虛擬環境的管理。</p>
<h3 id="強制虛擬環境"><a class="header" href="#強制虛擬環境">「強制」虛擬環境</a></h3>
<p>Poetry 預設上（可透過<code>poetry config</code>修改）會強制套件都要安裝在虛擬環境中，以免汙染全域，所以它整合了<code>virtualenv</code>。</p>
<p>所以在執行<code>poetry add、install</code>等指令時，Poetry 都會自動檢查<strong>當下是否正在使用虛擬環境：</strong></p>
<ul>
<li>如果<strong>是</strong>，則會直接安裝套件至<strong>當前</strong>的虛擬環境。</li>
<li>如果<strong>否</strong>，則會自動幫你建立一個<strong>新的</strong>虛擬環境，再進行套件安裝。</li>
</ul>
<h3 id="容易混淆的虛擬環境"><a class="header" href="#容易混淆的虛擬環境">容易混淆的虛擬環境</a></h3>
<p>Poetry 主動納入虛擬環境管理算是立意良善，相當於把<code>pip</code>+<code>venv</code>兩者的功能直接整合在一起，<strong>但也帶來一定的複雜度</strong>，尤其在你已經自行使用了<code>venv</code>、<code>virtualenv</code>或 <code>pyenv-virtualenv</code>或<code>conda</code>等工具來管理虛擬環境的情況下！</p>
<p><strong>沒錯，Python 的虛擬環境管理就是這麼麻煩！</strong></p>
<p>個人建議，對新手而言，於 Poetry 的專案中，<strong>一律使用 Poetry</strong> 來管理虛擬環境即可。我目前也是這樣，省得麻煩。</p>
<h3 id="以指令建立虛擬環境"><a class="header" href="#以指令建立虛擬環境">以指令建立虛擬環境</a></h3>
<p>使用指令<code>poetry env use python</code>：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo-IEWSZKSE-py3.8 in /Users/kyo/Library/Caches/pypoetry/virtualenvs
Using virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>可以看出 Poetry 為我們建立了名為<code>poetry-demo-IEWSZKSE-py3.8</code>的虛擬環境。</p>
<h3 id="重點說明"><a class="header" href="#重點說明">重點說明</a></h3>
<ul>
<li><code>poetry env use python</code>建立虛擬環境所使用的 Python 版本，取決於<code>python</code>指令在你的 PATH 是連結到哪個版本。同理，你也可以將指令明示為<code>use python3</code>或<code>use python3.8</code>，只要這些指令確實存在 PATH 中。</li>
<li>預設上，Poetry 會統一將虛擬環境建立在「<strong>特定目錄</strong>」裡，比如本例中存放的路徑是<code>/Users/kyo/Library/Caches/pypoetry/virtualenvs</code>。</li>
<li>虛擬環境的<strong>命名模式為<code>專案名稱-亂數-Python版本</code>。</strong></li>
</ul>
<p>老實說我個人不是很喜歡這樣的做法，因為這意味著單一專案允許建立複數個虛擬環境（比如 Python 3.7、3.8、3.9 可以各來一個），<strong>彈性之餘也增加了混亂的可能</strong>，而且這命名模式我也不太欣賞，顯得過於僵化且冗長。</p>
<p>既然 Python 的虛擬環境理論上都是<strong>高度綁定專案本身</strong>的，我更偏好<code>venv</code>式的做法，也就是<strong>把虛擬環境放到專案目錄內</strong>，而非統一放在獨立的目錄，讓虛擬環境與專案呈現<strong>直觀的一對一關係</strong>。</p>
<p>所幸，Poetry 具備這樣的選項。</p>
<hr />
<h3 id="修改config建立專案內的venv虛擬環境"><a class="header" href="#修改config建立專案內的venv虛擬環境">修改<code>config</code>，建立專案內的<code>.venv</code>虛擬環境</a></h3>
<p>我們先使用<code>poetry config</code>指令來查看 Poetry 目前幾個主要的設定，需要<code>--list</code>這個參數：</p>
<pre><code>❯ poetry config --list
cache-dir = "/Users/kyo/Library/Caches/pypoetry"
experimental.new-installer = true
installer.parallel = true
virtualenvs.create = true
virtualenvs.in-project = false
virtualenvs.path = "{cache-dir}/virtualenvs"
</code></pre>
<p>其中<code>virtualenvs.create = true</code>若改成<code>false</code>，則可以停止 Poetry 在「偵測不到虛擬環境時會自行建立」的行為模式，但建議還是不要更動。</p>
<p>而<code>virtualenvs.in-project = false</code>就是我們要修改的目標，使用指令：</p>
<pre><code>poetry config virtualenvs.in-project true
</code></pre>
<p>好，我們先把之前建立的虛擬環境刪除：</p>
<pre><code>❯ poetry env remove python
Deleted virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重新建立，看看行為有何差異：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo in /Users/kyo/Documents/code/poetry-demo/.venv
Using virtualenv: /Users/kyo/Documents/code/poetry-demo/.venv
</code></pre>
<p>可以看出：</p>
<ul>
<li>虛擬環境的路徑改為「<strong>專案的根目錄</strong>」。</li>
<li>名稱固定為<code>.venv</code>。</li>
</ul>
<p>我覺得這樣的設定更加簡潔。</p>
<h3 id="啟動與退出虛擬環境"><a class="header" href="#啟動與退出虛擬環境">啟動與退出虛擬環境</a></h3>
<p>啟動虛擬環境，需移至專案目錄底下，使用指令<code>poetry shell</code>：</p>
<pre><code>❯ poetry shell
Spawning shell within /Users/kyo/Documents/code/poetry-demo/.venv
❯ . /Users/kyo/Documents/code/poetry-demo/.venv/bin/activate
</code></pre>
<p><code>poetry shell</code>指令會偵測當前目錄或所屬上層目錄是否存在<code>pyproject.toml</code>來確定所要啟動的虛擬環境，所以如果不移至專案目錄，則會出現下列錯誤：</p>
<pre><code>❯ poetry shell

  RuntimeError

  Poetry could not find a pyproject.toml file in /Users/kyo/Documents/code or its parents

  at ~/Library/Application Support/pypoetry/venv/lib/python3.8/site-packages/poetry/core/factory.py:369 in locate
      365│             if poetry_file.exists():
      366│                 return poetry_file
      367│
      368│         else:
    → 369│             raise RuntimeError(
      370│                 "Poetry could not find a pyproject.toml file in {} or its parents".format(
      371│                     cwd
      372│                 )
      373│             )
</code></pre>
<p>可以看到，Poetry 的錯誤訊息非常清楚，讓你很容易知曉修正的方向，這是作為一個優秀命令列工具的必要條件。</p>
<p>退出就簡單多了，只需要<code>exit</code>即可。</p>
<hr />
<h2 id="poetry-常用指令"><a class="header" href="#poetry-常用指令">Poetry 常用指令</a></h2>
<p>Poetry 是一個獨立的命令列工具，就像 pyenv，它有自己的指令，需要花費額外的心力學習，且較 pip 更加複雜，這可能是使用 Poetry 的<strong>第二道關卡</strong>。好在常用的指令，其實也不超過 10 個，下面就來一一介紹。</p>
<p>在此我們繼續使用前面提過的 Flask 和 Black 套件，來示範並說明 Poetry 的優勢以及它和 pip 的不同之處。</p>
<h2 id="poetry-新增套件"><a class="header" href="#poetry-新增套件">Poetry 新增套件</a></h2>
<p>使用指令：</p>
<pre><code>poetry add
</code></pre>
<p>相當於<code>pip install</code>，我們來試著安裝 Flask 看看會有什麼變化：</p>
<p><a href="https://i.imgur.com/H7pPtsk.png"><img src="https://i.imgur.com/H7pPtsk.png" alt="img" /></a></p>
<p>圖中可以看出 Poetry 漂亮的命令列資訊呈現，會清楚告知總共新增了幾個套件。</p>
<p>此時專案中的<code>pyproject.toml</code>也會發生變化：</p>
<pre><code>...
[tool.poetry.dependencies]
python = "^3.8"
Flask = "^2.1.1"  # 新增部分

[tool.poetry.dev-dependencies]

[build-system]
...
</code></pre>
<p>這裡要說明，安裝 Flask，則<code>pyproject.toml</code>就只會新增記載<code>Flask = "^2.1.1"</code>這個 <strong>top-level</strong> 的 package 項目，其餘的依賴套件<strong>不會</strong>直接記錄在<code>toml</code>檔中。</p>
<p>我覺得這是一大優點，方便區分哪些是你<strong>主動安裝</strong>的主要套件，而哪些又是基於套件的依賴關係而一併安裝的依賴套件。</p>
<h3 id="poetrylock-與更新順序"><a class="header" href="#poetrylock-與更新順序">poetry.lock 與更新順序</a></h3>
<p>除了更新<code>pyproject.toml</code>，此時專案中還會新增一個檔案，名為<code>poetry.lock</code>，它實際上就相當於 pip 的<code>requirements.txt</code>，詳細記載了所有安裝的套件與版本。</p>
<p>當你使用<code>poetry add</code>指令時，Poetry 會<strong>自動依序</strong>幫你做完這三件事：</p>
<ol>
<li>更新<code>pyproject.toml</code>。</li>
<li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。</li>
<li>依照<code>poetry.lock</code>的內容，更新虛擬環境。</li>
</ol>
<p>由此可見，<code>poetry.lock</code>的內容是取決於<code>pyproject.toml</code>，但兩者並不會自己連動，一定要基於特定指令才會進行同步與更新，<code>poetry add</code>就是一個典型案例。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
└── pyproject.toml

0 directories, 2 files
</code></pre>
<h3 id="更新-poetrylock"><a class="header" href="#更新-poetrylock">更新 poetry.lock</a></h3>
<p>當你自行修改了<code>pyproject.toml</code>內容，比如變更特定套件的版本（這是有可能的，尤其在手動處理版本衝突的時候），此時<code>poetry.lock</code>的內容與<code>pyproject.toml</code>出現了「<strong>脫鉤</strong>」，必須讓它依照新的<code>pyproject.toml</code>內容更新、同步，使用指令：</p>
<pre><code>poetry lock
</code></pre>
<p>如此一來，才能確保手動修改的內容，也更新到<code>poetry.lock</code>中，畢竟虛擬環境如果要重新建立，是基於<code>poetry.lock</code>的內容來安裝套件，而非<code>pyproject.toml</code>。</p>
<p>還是那句話：<code>poetry.lock</code>相當於 Poetry 的<code>requirements.txt</code>。</p>
<hr />
<h3 id="安裝套件至-dev-dependencies"><a class="header" href="#安裝套件至-dev-dependencies">安裝套件至 dev-dependencies</a></h3>
<p>有些套件，比如<code>pytest</code>、<code>flake8</code>等等，<strong>只會在開發環境中使用</strong>，產品的<strong>部署環境</strong>並不需要。</p>
<p>Poetry 允許你<strong>區分</strong>這兩者，將上述的套件安裝至<code>dev-dependencies</code>區塊，方便讓你<strong>輕鬆建立一份「不包含」<code>dev-dependencies</code>開發套件的安裝清單</strong>。</p>
<p>在此以 Black 為例，安裝方式如下：</p>
<pre><code>poetry add black -D
</code></pre>
<p>或</p>
<pre><code>poetry add black --dev
</code></pre>
<p>結果的區別顯示在<code>pyproject.toml</code>裡：</p>
<pre><code>...
[tool.poetry.dependencies]
python = "^3.8"
Flask = "^2.1.1"

[tool.poetry.dev-dependencies]
black = "^22.3.0"
...
</code></pre>
<p>可以看到<code>black</code>被列在不同區塊：<code>tool.poetry.dev-dependencies</code>。</p>
<h3 id="強烈建議善用-dev-dependencies"><a class="header" href="#強烈建議善用-dev-dependencies">強烈建議：善用 dev-dependencies</a></h3>
<p>善用<code>-D</code>參數，明確區分<strong>開發環境專用</strong>的套件，我認為<strong>非常必要</strong>。</p>
<p>首先，這些套件常常屬於「<strong>檢測型</strong>」工具，相關的<strong>依賴套件</strong>著實不少！比如<code>flake8</code>，它依賴了<code>pycodestyle</code>、<code>pyflakes</code>、<code>mccabe</code>等等，還有<code>black</code>、<code>pre-commit</code>，依賴套件數量也都很可觀。</p>
<p>其次，既然它們都只在開發階段才需要，則完全可以從部署環境中<strong>缺席</strong>。如果不分青紅皂白一律安裝到<code>dependencies</code>區塊，部署環境容易顯得過於<strong>臃腫</strong>。</p>
<p>常見的<code>dev-dependencies</code>區塊項目，例示如下：</p>
<pre><code>[tool.poetry.dev-dependencies]
flake8 = "4.0.1"
yapf = "0.32.0"
pytest = "7.1.2"
pytest-django = "4.5.2"
pytest-cov = "3.0.0"
pytest-env = "0.6.2"
pytest-sugar = "0.9.4"
pre-commit = "2.20.0"
</code></pre>
<hr />
<h2 id="列出全部套件清單"><a class="header" href="#列出全部套件清單">列出全部套件清單</a></h2>
<p>類似<code>pip list</code>，這裡要使用<code>poetry show</code>：</p>
<pre><code>❯ poetry show
black              22.3.0 The uncompromising code formatter.
click              8.1.3  Composable command line interface toolkit
flask              2.1.2  A simple framework for building complex web applications.
importlib-metadata 4.11.4 Read metadata from Python packages
itsdangerous       2.1.2  Safely pass data to untrusted environments and back.
jinja2             3.1.2  A very fast and expressive template engine.
markupsafe         2.1.1  Safely add untrusted strings to HTML/XML markup.
mypy-extensions    0.4.3  Experimental type system extensions for programs checked...
pathspec           0.9.0  Utility library for gitignore style pattern matching of ...
platformdirs       2.5.2  A small Python module for determining appropriate platfo...
...
</code></pre>
<p>特別提醒的是，這裡的清單內容<strong>並不是來自於虛擬環境</strong>，這點和 pip 不同，而是來自於<code>poetry.lock</code>的內容。</p>
<p>你可能會想，來自於<code>poetry.lock</code>或虛擬環境，有差嗎？兩者不是應該要一致？</p>
<p>沒錯，理論上是，但也有不一致的時候，比如你使用了<code>pip install</code>指令安裝套件，就不會記載在<code>poetry.lock</code>中，那<code>poetry show</code>自然也不會顯示。</p>
<h3 id="樹狀顯示套件依賴層級"><a class="header" href="#樹狀顯示套件依賴層級">「樹狀」顯示套件依賴層級</a></h3>
<p>Poetry 最為人津津樂道的就是它的樹狀顯示——<code>poetry show --tree</code>。</p>
<pre><code>❯ poetry show --tree
flask 2.1.1 A simple framework for building complex web applications.
├── click &gt;=8.0
│   └── colorama *
├── importlib-metadata &gt;=3.6.0
│   └── zipp &gt;=0.5
├── itsdangerous &gt;=2.0
├── jinja2 &gt;=3.0
│   └── markupsafe &gt;=2.0
└── werkzeug &gt;=2.0
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>讓主要套件與其依賴套件的<strong>關係與層次，一目瞭然</strong>。</p>
<p>而且很貼心的是，它也可以**只顯示「指定套件」**的依賴層級，以<code>celery</code>為例：</p>
<pre><code>❯ poetry show celery --tree
celery 4.4.0 Distributed Task Queue.
├── billiard &gt;=3.6.1,&lt;4.0
├── kombu &gt;=4.6.7,&lt;4.7
│   ├── amqp &gt;=2.6.0,&lt;2.7
│   │   └── vine &gt;=1.1.3,&lt;5.0.0a1
│   └── importlib-metadata &gt;=0.18
│       ├── typing-extensions &gt;=3.6.4
│       └── zipp &gt;=0.5
├── pytz &gt;0.0-dev
└── vine 1.3.0
</code></pre>
<hr />
<h2 id="poetry-移除套件"><a class="header" href="#poetry-移除套件">Poetry 移除套件</a></h2>
<p>使用<code>poetry remove</code>指令。和<code>poetry add</code>一樣，可以加上<code>-D</code>參數來移除置於開發區的套件。</p>
<p>而移除套件時的「<strong>依賴解析（相依性管理）</strong>」能力，正是 Poetry 遠優於 pip 的主要環節，因為 pip 沒有嘛！也是我提議改用 Poetry 的關鍵理由——<strong>為了順利移除套件</strong>。</p>
<p>前面已經提過，pip 的<code>pip uninstall</code>只會移除你所指定的套件，而不會連同依賴套件一起移除。</p>
<p>這是基於安全考量，因為 pip 沒有「依賴解析」功能。如果貿然移除所有「安裝時一併安裝」的依賴套件，可能會造成巨大災難，讓別的套件失去效用。</p>
<p>前面也舉了 Flask 和 Black 都共同依賴<code>click</code>這個套件的例子，在手動移除套件的情況下，你可能未曾注意 Black 也依賴了<code>click</code>，結果為了「徹底移除」Flask 的所有相關套件，不小心把<code>click</code>也移除掉了。</p>
<p>所以，使用 pip 時，我們鮮少會去移除已經不再使用的套件。畢竟<strong>依賴關係錯綜複雜</strong>，移除套件可能造成許多「<strong>副作用</strong>」，實在是太麻煩了。</p>
<h3 id="poetry-remove的依賴解析"><a class="header" href="#poetry-remove的依賴解析"><code>poetry remove</code>的依賴解析</a></h3>
<p>好，解釋了很多，接下來就是 Poetry 的表演了，它會幫你處理這些棘手的「套件相依性」難題，讓你輕鬆移除 Flask 而不影響 Black：</p>
<p><a href="https://i.imgur.com/79TycuL.png"><img src="https://i.imgur.com/79TycuL.png" alt="poetry remove flask" /></a>poetry remove flask</p>
<p>可以對比上面安裝 Flask 時的截圖，那時總共安裝了 8 個套件，但現在移除的卻只有 7 個——沒錯，因為有依賴解析，<strong>Poetry 知道 Black 還需要</strong><code>click</code>！所以不能移除：</p>
<pre><code>❯ poetry show --tree
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>一個套件直到環境中的<strong>其餘套件都不再依賴它</strong>，Poetry 才會安心讓它被移除。</p>
<hr />
<h2 id="輸出-poetry-虛擬環境的-requirementstxt"><a class="header" href="#輸出-poetry-虛擬環境的-requirementstxt">輸出 Poetry 虛擬環境的 requirements.txt</a></h2>
<p>理論上，全面改用 Poetry 後，專案中是不需要存在<code>requirements.txt</code>，因為它的角色已經完全被<code>poetry.lock</code>所取代。</p>
<p>但事實是，你可能<strong>還是需要它</strong>，甚至希望它隨著<code>poetry.lock</code>的內容更新！至少對我而言就是如此，我在 Docker 部署環境中並不使用 Poetry，所以我需要一份完全等價於<code>poetry.lock</code>的<code>requirements.txt</code>，用於 Docker 部署。</p>
<p>你可能想說，那我就在 Poetry 的虛擬環境下，使用以往熟悉的指令<code>pip freeze &gt; requirements.txt</code>來產生一份就可以了吧？我本來也是這麼想，但實際的產出卻是如此：（提醒：目前 poetry-demo 專案中<strong>僅剩下 Black 和它的依賴套件</strong>）</p>
<pre><code>black @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/11/4c/fc/cd6d885e9f5be135b161e365b11312cff5920d7574c8446833d7a9b1a3/black-22.3.0-cp38-cp38-macosx_10_9_x86_64.whl
click @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/f0/23/09/b13d61d1fa8b3cd7c26f67505638d55002e7105849de4c4432c28e1c0d/click-8.1.2-py3-none-any.whl
mypy-extensions @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/b6/a0/b0/a5dc9acd6fd12aba308634f21bb7cf0571448f20848797d7ecb327aa12/mypy_extensions-0.4.3-py2.py3-none-any.whl
...
</code></pre>
<p>這呈現好像不是我們以前熟悉的那樣：</p>
<pre><code>black==22.3.0
click==8.1.2
mypy_extensions==0.4.3
...
</code></pre>
<p>沒錯，只要是使用<code>poetry add</code>安裝的套件，在<code>pip freeze</code>就會變成這樣。此時想輸出類似<code>requirements.txt</code>的格式，需要使用<code>poetry export</code>。</p>
<p>預設的輸出結果會有 hash 值，很乾擾閱讀。不想納入 hash 則要<strong>加上參數</strong>去除。<strong>以下就是我固定用來輸出<code>requirements.txt</code>的指令與參數：</strong></p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes
</code></pre>
<p><code>2022/08/24</code>補充：網友提醒，<strong>hash 有其價值，並建議保留</strong>，詳見<a href="https://github.com/kyomind/blog-reply/issues/5#issuecomment-1195904820">留言區</a>。</p>
<p>我們再看一下輸出結果，雖然不盡相同，但也相去不遠了……嗎？等等，怎麼是空白？</p>
<h3 id="輸出-dev-dependencies"><a class="header" href="#輸出-dev-dependencies">輸出 dev-dependencies</a></h3>
<p>因為<code>poetry export</code><strong>預設</strong>只會輸出<code>toml</code>中的<code>[tool.poetry.dependencies]</code>區塊的套件！還記得上面我們把 Black 安裝到<code>[tool.poetry.dev-dependencies]</code>了嗎？</p>
<p>顯然 Poetry 認為你 export 基本上就為了部署，並不需要開發區的套件。</p>
<p>這倒是沒錯，不過基於演示需求，我們必須輸出<code>[tool.poetry.dev-dependencies]</code>的套件，才能看到 Black。</p>
<p>加上<code>--dev</code>參數即可：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes --dev
</code></pre>
<p>輸出的<code>requirements.txt</code>內容：</p>
<pre><code>black==22.3.0; python_full_version &gt;= "3.6.2"
click==8.1.2; python_version &gt;= "3.7" and python_full_version &gt;= "3.6.2"
colorama==0.4.4; python_version &gt;= "3.7" and python_full_version &gt;= "3.6.2" and platform_system == "Windows"
...
</code></pre>
<p>雖然長得有點不一樣，但這個檔案確實是可以<code>pip install</code>的。</p>
<p>從這裡也可以看出先前一再提及「<strong>區分開發、部署套件</strong>」的價值——大部分時候我們並不需要輸出開發用套件。</p>
<p><code>poetry export</code>所有參數用法與說明，請參考<a href="https://python-poetry.org/docs/cli/#export">文件</a>。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
├── pyproject.toml
└── requirements.txt

0 directories, 3 files
</code></pre>
<hr />
<h2 id="poetry-常用指令清單"><a class="header" href="#poetry-常用指令清單">Poetry 常用指令清單</a></h2>
<p>算來算去，Poetry 的常用指令主要有下面幾個：</p>
<ul>
<li><code>poetry add</code></li>
<li><code>poetry remove</code></li>
<li><code>poetry export</code></li>
<li><code>poetry env use</code></li>
<li><code>poetry shell</code></li>
<li><code>poetry show</code></li>
<li><code>poetry init</code></li>
<li><code>poetry install</code></li>
</ul>
<p>其中一半，單一專案可能只會用個一兩次而已，比如<code>init</code>、<code>install</code>和<code>env use</code>，實際上需要學習的指令並不多。</p>
<p>那麼，只要知曉這些指令，就可以順利運用 Poetry 了嗎？可能是，也可能否，所以我下面還會再補充 Poetry 的常見使用情境與操作方式，讓你接納 Poetry 的阻力可以進一步下降！</p>
<hr />
<h2 id="poetry-常見使用情境與操作-qa"><a class="header" href="#poetry-常見使用情境與操作-qa">Poetry 常見使用情境與操作 QA</a></h2>
<p>這部分會以「<strong>使用場景</strong>」的角度切入，介紹 Poetry 應用情境與操作說明，還包括一些自問自答：</p>
<ol>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%80%E3%80%81%E6%96%B0%E5%A2%9E%E5%B0%88%E6%A1%88%E4%B8%A6%E4%BD%BF%E7%94%A8-Poetry">新增專案並使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%8C%E3%80%81%E7%8F%BE%E6%9C%89%E5%B0%88%E6%A1%88%E6%94%B9%E7%94%A8-Poetry">現有專案改用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%89%E3%80%81%E5%9C%A8%E5%88%A5%E8%87%BA%E4%B8%BB%E6%A9%9F%E5%9B%9E%E5%BE%A9%E5%B0%88%E6%A1%88%E7%8B%80%E6%85%8B">在別臺主機回復專案狀態</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%9B%9B%E3%80%81%E6%88%91%E6%83%B3%E8%A6%81%E9%87%8D%E5%BB%BA%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">我想要重建虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">為什麼我不在 Docker 環境中使用 Poetry？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%85%AD%E3%80%81%E6%88%91%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%BF%92%E6%85%A3%E7%9A%84-virtualenv-%E5%97%8E%EF%BC%9F">我可以使用自己習慣的 virtualenv 嗎？</a></li>
</ol>
<h3 id="一新增專案並使用-poetry"><a class="header" href="#一新增專案並使用-poetry">一、新增專案並使用 Poetry</a></h3>
<p>這是最理想的狀態，沒有過去的「包袱」，可謂是最能輕鬆採用 Poetry 的情境。</p>
<p>使用順序不外乎是：</p>
<ol>
<li><code>poetry init</code>：初始化，建立<code>pyproject.toml</code>。</li>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。</li>
<li><code>poetry shell</code>：進入專案但虛擬環境還未啟動，以這個指令啟動。如果使用本指令時虛擬環境<strong>尚未建立或已移除</strong>，則會<strong>直接自動幫你建立虛擬環境</strong>並使用。</li>
<li><code>poetry add</code>：新增套件並寫入虛擬環境。必要時使用<code>-D</code>參數新增至 dev 區塊。</li>
<li><code>poetry remove</code>：移除套件，若是移除 dev 區塊的套件，需要加上<code>-D</code>參數。</li>
</ol>
<p>這部分和前面內容沒有差別，因為前面內容就是以全新專案作為基礎。</p>
<h3 id="二現有專案改用-poetry"><a class="header" href="#二現有專案改用-poetry">二、現有專案改用 Poetry</a></h3>
<p>極為常見的需求，但並沒有很正式的做法，因為不存在<code>poetry import</code>之類的指令。</p>
<p>首先要考量的就是：要怎麼把<code>requirements.txt</code>的所有項目加到<code>pyproject.toml</code>中呢？經過一番 Google，基本上<a href="https://stackoverflow.com/questions/62764148/how-to-import-requirements-txt-from-an-existing-project-using-poetry">只能土法煉鋼</a>：</p>
<pre><code>cat requirements.txt | xargs poetry add
</code></pre>
<p>然而這樣做是有可能遇到一些問題的，因為 Poetry <strong>對套件的版本衝突比較敏感</strong>，所以即便用<code>pip install -r requirements.txt</code>都能正常安裝，透過上述指令的遷移過程卻仍有機會出現錯誤。</p>
<p>那怎麼辦？只能照著錯誤訊息手動修正<code>requirements.txt</code>中的套件版本。</p>
<p>只能說這個「<strong>手動 import</strong>」做法實在是不得已，因為我們最早介紹<code>pyproject.toml</code>時有提到，<code>poetry add</code>只會在<code>pyproject.toml</code>中寫入「主套件」，但這樣的 import 方式相當於把<code>requirements.txt</code>中的<strong>所有套件，都當作主套件</strong>來<code>add</code>了！</p>
<p>畢竟在<code>requirements.txt</code>中<strong>無從區分</strong>主套件與依賴套件，都是「一視同仁」地列出。</p>
<p>但如此做法也讓專案的套件<strong>失去主從之分</strong>，這樣會有什麼<strong>壞處</strong>？日後要移除主套件時，<strong>需要花額外的心力去區分主從</strong>（因為僅僅移除依賴套件<strong>並不會有移除效果</strong>），比如使用<code>poetry show --tree</code>去一個一個檢視，終究是件麻煩事。</p>
<p>完成轉換後，為保險起見，建議透過新的<code>pyproject.toml</code>來重建一個虛擬環境。</p>
<h3 id="三在別臺主機上重現專案的-poetry-虛擬環境"><a class="header" href="#三在別臺主機上重現專案的-poetry-虛擬環境">三、在別臺主機上重現專案的 Poetry 虛擬環境</a></h3>
<p>這也是非常常見的需求。</p>
<p>第一步當然是<code>git clone</code>專案，此時專案中已經有 Poetry 所需的必要資訊了——也就是<code>pyproject.toml</code>和<code>poetry.lock</code>。</p>
<p>你還缺少的僅僅是虛擬環境。如果是全新的主機，則還得先安裝、設定好 Poetry。</p>
<p>確定 Poetry 可正常使用後，移至專案目錄底下，依序執行指令：</p>
<ol>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。如果你懶得打這麼長的指令，直接<code>poetry shell</code>也是可以。此時我們會有一個「<strong>空的</strong>」虛擬環境。</li>
<li><code>poetry install</code>：因為是舊專案，不需要<code>init</code>，會直接依<code>poetry.lock</code>記載的套件版本安裝到虛擬環境中！類似<code>npm install</code>。</li>
</ol>
<h3 id="四我想要重建虛擬環境"><a class="header" href="#四我想要重建虛擬環境">四、我想要重建虛擬環境</a></h3>
<p>在使用專案內虛擬環境方案，也就是<code>.venv</code>的前提下，想要刪除這個虛擬環境並加以重建，也不需要使用<code>poetry env remove python</code>指令了，因為會出錯。</p>
<p>還有更簡單暴力的方式，是什麼呢？——直接刪除<code>.venv</code>資料夾即可。</p>
<p>然後再<code>poetry env use python</code>或<code>poetry shell</code>建一個新的就好。</p>
<h3 id="五為什麼我不在-docker-環境中使用-poetry"><a class="header" href="#五為什麼我不在-docker-環境中使用-poetry">五、為什麼我不在 Docker 環境中使用 Poetry？</a></h3>
<p>因為啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會<strong>增加新的耦合與依賴</strong>，我覺得並不妥當。</p>
<p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p>
<h3 id="六我可以使用自己習慣的-virtualenv-嗎"><a class="header" href="#六我可以使用自己習慣的-virtualenv-嗎">六、我可以使用自己習慣的 virtualenv 嗎？</a></h3>
<p>當然可以。</p>
<p>不過我本來也繼續使用<code>pyenv</code>的<code>virtualenv</code>，但兩者有時候也是會小小打架，後來還是索性用 Poetry 的虛擬環境就好。</p>
<p>一個專案對應一個虛擬環境，應該還是比較簡潔的做法，我的觀察啦！😎</p>
<hr />
<h2 id="結語井然有序的複雜"><a class="header" href="#結語井然有序的複雜">結語：井然有序的複雜</a></h2>
<p>總的來說，Poetry 是一款優秀的套件管理工具，但並不像 pip 那般簡單、好上手。</p>
<p>使用 Poetry 來管理專案的套件與虛擬環境，需要一定的學習成本，但帶來的效益還是相當可觀的，尤其在你希望能夠乾淨且安心地移除套件之際，可謂莫它莫屬。</p>
<p>所以，別再猶豫，從今天起，加入 Poetry 的行列吧！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../python/websocket_client_server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../python/fil-memory-usage-profiler.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../python/websocket_client_server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../python/fil-memory-usage-profiler.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
