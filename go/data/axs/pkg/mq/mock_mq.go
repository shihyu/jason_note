// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mq

import (
	"context"
	"time"

	mock "github.com/stretchr/testify/mock"
)

// NewMockConsumerReader creates a new instance of MockConsumerReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConsumerReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConsumerReader {
	mock := &MockConsumerReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConsumerReader is an autogenerated mock type for the ConsumerReader type
type MockConsumerReader struct {
	mock.Mock
}

type MockConsumerReader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConsumerReader) EXPECT() *MockConsumerReader_Expecter {
	return &MockConsumerReader_Expecter{mock: &_m.Mock}
}

// CommitAndClose provides a mock function for the type MockConsumerReader
func (_mock *MockConsumerReader) CommitAndClose(timeout time.Duration) error {
	ret := _mock.Called(timeout)

	if len(ret) == 0 {
		panic("no return value specified for CommitAndClose")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = returnFunc(timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConsumerReader_CommitAndClose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitAndClose'
type MockConsumerReader_CommitAndClose_Call struct {
	*mock.Call
}

// CommitAndClose is a helper method to define mock.On call
//   - timeout time.Duration
func (_e *MockConsumerReader_Expecter) CommitAndClose(timeout interface{}) *MockConsumerReader_CommitAndClose_Call {
	return &MockConsumerReader_CommitAndClose_Call{Call: _e.mock.On("CommitAndClose", timeout)}
}

func (_c *MockConsumerReader_CommitAndClose_Call) Run(run func(timeout time.Duration)) *MockConsumerReader_CommitAndClose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockConsumerReader_CommitAndClose_Call) Return(err error) *MockConsumerReader_CommitAndClose_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConsumerReader_CommitAndClose_Call) RunAndReturn(run func(timeout time.Duration) error) *MockConsumerReader_CommitAndClose_Call {
	_c.Call.Return(run)
	return _c
}

// ReadMessage provides a mock function for the type MockConsumerReader
func (_mock *MockConsumerReader) ReadMessage(ctx context.Context, readTimeout time.Duration) (ConsumedMessage, error) {
	ret := _mock.Called(ctx, readTimeout)

	if len(ret) == 0 {
		panic("no return value specified for ReadMessage")
	}

	var r0 ConsumedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) (ConsumedMessage, error)); ok {
		return returnFunc(ctx, readTimeout)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) ConsumedMessage); ok {
		r0 = returnFunc(ctx, readTimeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ConsumedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, readTimeout)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConsumerReader_ReadMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadMessage'
type MockConsumerReader_ReadMessage_Call struct {
	*mock.Call
}

// ReadMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - readTimeout time.Duration
func (_e *MockConsumerReader_Expecter) ReadMessage(ctx interface{}, readTimeout interface{}) *MockConsumerReader_ReadMessage_Call {
	return &MockConsumerReader_ReadMessage_Call{Call: _e.mock.On("ReadMessage", ctx, readTimeout)}
}

func (_c *MockConsumerReader_ReadMessage_Call) Run(run func(ctx context.Context, readTimeout time.Duration)) *MockConsumerReader_ReadMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConsumerReader_ReadMessage_Call) Return(consumedMessage ConsumedMessage, err error) *MockConsumerReader_ReadMessage_Call {
	_c.Call.Return(consumedMessage, err)
	return _c
}

func (_c *MockConsumerReader_ReadMessage_Call) RunAndReturn(run func(ctx context.Context, readTimeout time.Duration) (ConsumedMessage, error)) *MockConsumerReader_ReadMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockConsumedMessage creates a new instance of MockConsumedMessage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConsumedMessage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConsumedMessage {
	mock := &MockConsumedMessage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConsumedMessage is an autogenerated mock type for the ConsumedMessage type
type MockConsumedMessage struct {
	mock.Mock
}

type MockConsumedMessage_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConsumedMessage) EXPECT() *MockConsumedMessage_Expecter {
	return &MockConsumedMessage_Expecter{mock: &_m.Mock}
}

// Commit provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) Commit() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConsumedMessage_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockConsumedMessage_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) Commit() *MockConsumedMessage_Commit_Call {
	return &MockConsumedMessage_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *MockConsumedMessage_Commit_Call) Run(run func()) *MockConsumedMessage_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_Commit_Call) Return(err error) *MockConsumedMessage_Commit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConsumedMessage_Commit_Call) RunAndReturn(run func() error) *MockConsumedMessage_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Context provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) Context() context.Context {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Context")
	}

	var r0 context.Context
	if returnFunc, ok := ret.Get(0).(func() context.Context); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}
	return r0
}

// MockConsumedMessage_Context_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Context'
type MockConsumedMessage_Context_Call struct {
	*mock.Call
}

// Context is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) Context() *MockConsumedMessage_Context_Call {
	return &MockConsumedMessage_Context_Call{Call: _e.mock.On("Context")}
}

func (_c *MockConsumedMessage_Context_Call) Run(run func()) *MockConsumedMessage_Context_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_Context_Call) Return(context1 context.Context) *MockConsumedMessage_Context_Call {
	_c.Call.Return(context1)
	return _c
}

func (_c *MockConsumedMessage_Context_Call) RunAndReturn(run func() context.Context) *MockConsumedMessage_Context_Call {
	_c.Call.Return(run)
	return _c
}

// GetHeader provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetHeader(key string) []byte {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for GetHeader")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// MockConsumedMessage_GetHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHeader'
type MockConsumedMessage_GetHeader_Call struct {
	*mock.Call
}

// GetHeader is a helper method to define mock.On call
//   - key string
func (_e *MockConsumedMessage_Expecter) GetHeader(key interface{}) *MockConsumedMessage_GetHeader_Call {
	return &MockConsumedMessage_GetHeader_Call{Call: _e.mock.On("GetHeader", key)}
}

func (_c *MockConsumedMessage_GetHeader_Call) Run(run func(key string)) *MockConsumedMessage_GetHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockConsumedMessage_GetHeader_Call) Return(bytes []byte) *MockConsumedMessage_GetHeader_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *MockConsumedMessage_GetHeader_Call) RunAndReturn(run func(key string) []byte) *MockConsumedMessage_GetHeader_Call {
	_c.Call.Return(run)
	return _c
}

// GetKey provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetKey() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetKey")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// MockConsumedMessage_GetKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKey'
type MockConsumedMessage_GetKey_Call struct {
	*mock.Call
}

// GetKey is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) GetKey() *MockConsumedMessage_GetKey_Call {
	return &MockConsumedMessage_GetKey_Call{Call: _e.mock.On("GetKey")}
}

func (_c *MockConsumedMessage_GetKey_Call) Run(run func()) *MockConsumedMessage_GetKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_GetKey_Call) Return(bytes []byte) *MockConsumedMessage_GetKey_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *MockConsumedMessage_GetKey_Call) RunAndReturn(run func() []byte) *MockConsumedMessage_GetKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetOffset provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetOffset() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetOffset")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// MockConsumedMessage_GetOffset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOffset'
type MockConsumedMessage_GetOffset_Call struct {
	*mock.Call
}

// GetOffset is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) GetOffset() *MockConsumedMessage_GetOffset_Call {
	return &MockConsumedMessage_GetOffset_Call{Call: _e.mock.On("GetOffset")}
}

func (_c *MockConsumedMessage_GetOffset_Call) Run(run func()) *MockConsumedMessage_GetOffset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_GetOffset_Call) Return(n int64) *MockConsumedMessage_GetOffset_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockConsumedMessage_GetOffset_Call) RunAndReturn(run func() int64) *MockConsumedMessage_GetOffset_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartition provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetPartition() int32 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPartition")
	}

	var r0 int32
	if returnFunc, ok := ret.Get(0).(func() int32); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int32)
	}
	return r0
}

// MockConsumedMessage_GetPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartition'
type MockConsumedMessage_GetPartition_Call struct {
	*mock.Call
}

// GetPartition is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) GetPartition() *MockConsumedMessage_GetPartition_Call {
	return &MockConsumedMessage_GetPartition_Call{Call: _e.mock.On("GetPartition")}
}

func (_c *MockConsumedMessage_GetPartition_Call) Run(run func()) *MockConsumedMessage_GetPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_GetPartition_Call) Return(n int32) *MockConsumedMessage_GetPartition_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockConsumedMessage_GetPartition_Call) RunAndReturn(run func() int32) *MockConsumedMessage_GetPartition_Call {
	_c.Call.Return(run)
	return _c
}

// GetPayload provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetPayload() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPayload")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// MockConsumedMessage_GetPayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPayload'
type MockConsumedMessage_GetPayload_Call struct {
	*mock.Call
}

// GetPayload is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) GetPayload() *MockConsumedMessage_GetPayload_Call {
	return &MockConsumedMessage_GetPayload_Call{Call: _e.mock.On("GetPayload")}
}

func (_c *MockConsumedMessage_GetPayload_Call) Run(run func()) *MockConsumedMessage_GetPayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_GetPayload_Call) Return(bytes []byte) *MockConsumedMessage_GetPayload_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *MockConsumedMessage_GetPayload_Call) RunAndReturn(run func() []byte) *MockConsumedMessage_GetPayload_Call {
	_c.Call.Return(run)
	return _c
}

// GetTopic provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) GetTopic() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTopic")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockConsumedMessage_GetTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopic'
type MockConsumedMessage_GetTopic_Call struct {
	*mock.Call
}

// GetTopic is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) GetTopic() *MockConsumedMessage_GetTopic_Call {
	return &MockConsumedMessage_GetTopic_Call{Call: _e.mock.On("GetTopic")}
}

func (_c *MockConsumedMessage_GetTopic_Call) Run(run func()) *MockConsumedMessage_GetTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_GetTopic_Call) Return(s string) *MockConsumedMessage_GetTopic_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockConsumedMessage_GetTopic_Call) RunAndReturn(run func() string) *MockConsumedMessage_GetTopic_Call {
	_c.Call.Return(run)
	return _c
}

// SetContext provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) SetContext(ctx context.Context) {
	_mock.Called(ctx)
	return
}

// MockConsumedMessage_SetContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetContext'
type MockConsumedMessage_SetContext_Call struct {
	*mock.Call
}

// SetContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockConsumedMessage_Expecter) SetContext(ctx interface{}) *MockConsumedMessage_SetContext_Call {
	return &MockConsumedMessage_SetContext_Call{Call: _e.mock.On("SetContext", ctx)}
}

func (_c *MockConsumedMessage_SetContext_Call) Run(run func(ctx context.Context)) *MockConsumedMessage_SetContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockConsumedMessage_SetContext_Call) Return() *MockConsumedMessage_SetContext_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockConsumedMessage_SetContext_Call) RunAndReturn(run func(ctx context.Context)) *MockConsumedMessage_SetContext_Call {
	_c.Run(run)
	return _c
}

// Store provides a mock function for the type MockConsumedMessage
func (_mock *MockConsumedMessage) Store() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConsumedMessage_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockConsumedMessage_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
func (_e *MockConsumedMessage_Expecter) Store() *MockConsumedMessage_Store_Call {
	return &MockConsumedMessage_Store_Call{Call: _e.mock.On("Store")}
}

func (_c *MockConsumedMessage_Store_Call) Run(run func()) *MockConsumedMessage_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockConsumedMessage_Store_Call) Return(err error) *MockConsumedMessage_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConsumedMessage_Store_Call) RunAndReturn(run func() error) *MockConsumedMessage_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProducer creates a new instance of MockProducer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProducer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProducer {
	mock := &MockProducer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProducer is an autogenerated mock type for the Producer type
type MockProducer struct {
	mock.Mock
}

type MockProducer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProducer) EXPECT() *MockProducer_Expecter {
	return &MockProducer_Expecter{mock: &_m.Mock}
}

// AsyncPublish provides a mock function for the type MockProducer
func (_mock *MockProducer) AsyncPublish(ctx context.Context, message ...*ProducedMessage) []ProducedMessageResult {
	var tmpRet mock.Arguments
	if len(message) > 0 {
		tmpRet = _mock.Called(ctx, message)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for AsyncPublish")
	}

	var r0 []ProducedMessageResult
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*ProducedMessage) []ProducedMessageResult); ok {
		r0 = returnFunc(ctx, message...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ProducedMessageResult)
		}
	}
	return r0
}

// MockProducer_AsyncPublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsyncPublish'
type MockProducer_AsyncPublish_Call struct {
	*mock.Call
}

// AsyncPublish is a helper method to define mock.On call
//   - ctx context.Context
//   - message ...*ProducedMessage
func (_e *MockProducer_Expecter) AsyncPublish(ctx interface{}, message ...interface{}) *MockProducer_AsyncPublish_Call {
	return &MockProducer_AsyncPublish_Call{Call: _e.mock.On("AsyncPublish",
		append([]interface{}{ctx}, message...)...)}
}

func (_c *MockProducer_AsyncPublish_Call) Run(run func(ctx context.Context, message ...*ProducedMessage)) *MockProducer_AsyncPublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*ProducedMessage
		var variadicArgs []*ProducedMessage
		if len(args) > 1 {
			variadicArgs = args[1].([]*ProducedMessage)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockProducer_AsyncPublish_Call) Return(producedMessageResults []ProducedMessageResult) *MockProducer_AsyncPublish_Call {
	_c.Call.Return(producedMessageResults)
	return _c
}

func (_c *MockProducer_AsyncPublish_Call) RunAndReturn(run func(ctx context.Context, message ...*ProducedMessage) []ProducedMessageResult) *MockProducer_AsyncPublish_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function for the type MockProducer
func (_mock *MockProducer) Flush(to time.Duration) (int, error) {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(time.Duration) (int, error)); ok {
		return returnFunc(to)
	}
	if returnFunc, ok := ret.Get(0).(func(time.Duration) int); ok {
		r0 = returnFunc(to)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(time.Duration) error); ok {
		r1 = returnFunc(to)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProducer_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockProducer_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
//   - to time.Duration
func (_e *MockProducer_Expecter) Flush(to interface{}) *MockProducer_Flush_Call {
	return &MockProducer_Flush_Call{Call: _e.mock.On("Flush", to)}
}

func (_c *MockProducer_Flush_Call) Run(run func(to time.Duration)) *MockProducer_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockProducer_Flush_Call) Return(n int, err error) *MockProducer_Flush_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockProducer_Flush_Call) RunAndReturn(run func(to time.Duration) (int, error)) *MockProducer_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAndClose provides a mock function for the type MockProducer
func (_mock *MockProducer) FlushAndClose(to time.Duration) (int, error) {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for FlushAndClose")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(time.Duration) (int, error)); ok {
		return returnFunc(to)
	}
	if returnFunc, ok := ret.Get(0).(func(time.Duration) int); ok {
		r0 = returnFunc(to)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(time.Duration) error); ok {
		r1 = returnFunc(to)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProducer_FlushAndClose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAndClose'
type MockProducer_FlushAndClose_Call struct {
	*mock.Call
}

// FlushAndClose is a helper method to define mock.On call
//   - to time.Duration
func (_e *MockProducer_Expecter) FlushAndClose(to interface{}) *MockProducer_FlushAndClose_Call {
	return &MockProducer_FlushAndClose_Call{Call: _e.mock.On("FlushAndClose", to)}
}

func (_c *MockProducer_FlushAndClose_Call) Run(run func(to time.Duration)) *MockProducer_FlushAndClose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockProducer_FlushAndClose_Call) Return(n int, err error) *MockProducer_FlushAndClose_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockProducer_FlushAndClose_Call) RunAndReturn(run func(to time.Duration) (int, error)) *MockProducer_FlushAndClose_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type MockProducer
func (_mock *MockProducer) Publish(ctx context.Context, message ...*ProducedMessage) []ProducedMessageResult {
	var tmpRet mock.Arguments
	if len(message) > 0 {
		tmpRet = _mock.Called(ctx, message)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 []ProducedMessageResult
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*ProducedMessage) []ProducedMessageResult); ok {
		r0 = returnFunc(ctx, message...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ProducedMessageResult)
		}
	}
	return r0
}

// MockProducer_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockProducer_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - message ...*ProducedMessage
func (_e *MockProducer_Expecter) Publish(ctx interface{}, message ...interface{}) *MockProducer_Publish_Call {
	return &MockProducer_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx}, message...)...)}
}

func (_c *MockProducer_Publish_Call) Run(run func(ctx context.Context, message ...*ProducedMessage)) *MockProducer_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*ProducedMessage
		var variadicArgs []*ProducedMessage
		if len(args) > 1 {
			variadicArgs = args[1].([]*ProducedMessage)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockProducer_Publish_Call) Return(producedMessageResults []ProducedMessageResult) *MockProducer_Publish_Call {
	_c.Call.Return(producedMessageResults)
	return _c
}

func (_c *MockProducer_Publish_Call) RunAndReturn(run func(ctx context.Context, message ...*ProducedMessage) []ProducedMessageResult) *MockProducer_Publish_Call {
	_c.Call.Return(run)
	return _c
}
