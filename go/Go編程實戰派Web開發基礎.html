<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go 編程實戰派 Web 開發基礎 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="web開發基礎"><a class="header" href="#web開發基礎">Web開發基礎</a></h3>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#2_Go_Web_2">第2章 Go Web開發基礎</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#21_helloWorldWeb_4">2.1 helloWorldWeb</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#22_Web_28">2.2 Web程序運行原理簡介</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#221_Web_29">2.2.1 Web基本原理</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#222_HTTP_43">2.2.2 HTTP簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#223_HTTP_46">2.2.3 HTTP請求</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#224_HTTP_83">2.2.4 HTTP響應</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#225_URIURL_155">2.2.5 URI與URL</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#226_HTTPS_172">2.2.6 HTTPS簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#227_HTTP2_176">2.2.7 HTTP2簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#228_Web_193">2.2.8 Web應用程序的組成</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#23_nethttp_237">2.3 net/http包</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#231__238">2.3.1 創建簡單服務器端</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#232__342">2.3.2 創建簡單的客戶端</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#24_htmltemplate_496">2.4 html/template包</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#241__498">2.4.1 模板原理</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#242_htmltemplate_537">2.4.2 使用html/template包</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第2章-go-web開發基礎"><a class="header" href="#第2章-go-web開發基礎">第2章 Go Web開發基礎</a></h1>
<h2 id="21-helloworldweb"><a class="header" href="#21-helloworldweb">2.1 helloWorldWeb</a></h2>
<pre><code class="language-go">//helloWorldWeb.go
//go run helloWorldWeb.go
//127.0.0.1
package main
import (
	"fmt"
	"net/http"
)

func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello World")
}

func main() {
	server := &amp;http.Server {
		Addr: "0.0.0.0:80",
	}
	http.HandleFunc("/", hello)
	server.ListenAndServe()
}
</code></pre>
<h2 id="22-web程序運行原理簡介"><a class="header" href="#22-web程序運行原理簡介">2.2 Web程序運行原理簡介</a></h2>
<h3 id="221-web基本原理"><a class="header" href="#221-web基本原理">2.2.1 Web基本原理</a></h3>
<ol>
<li>運行原理
（1）用戶打開客戶端瀏覽器，輸入URL地址。
（2）客戶端瀏覽器通過HTTP協議向服務器端發送瀏覽請求。
（3）服務器端通過CGI程序接收請求，調用解釋引擎處理“動態內容”，訪問數據庫並處理數據，通過HTTP協議將得到的處理結果返回給客戶端瀏覽器。
（4）客戶端瀏覽器解釋並顯示HTML頁面。</li>
<li>DNS（Domain Name System，域名系統）
將主機名和域名轉換為IP地址。
DNS解析過程：
（1）用戶打開瀏覽器，輸入URL地址。瀏覽器從URL中抽取域名（主機名），傳給DNS應用程序的客戶端。
（2）DNS客戶端向DNS服務器端發送查詢報文，其中包含主機名。
（3）DNS服務器端向DNS客戶端發送回答報文，其中包含該主機名對應IP地址。
（4）瀏覽器收到DNS的IP地址後，向該IP地址定位的HTTP服務器端發起TCP連接。</li>
</ol>
<h3 id="222-http簡介"><a class="header" href="#222-http簡介">2.2.2 HTTP簡介</a></h3>
<p>HTTP（Hyper Text Transfer Protocal，超文本傳輸協議），簡單請求-響應協議，運行在TCP協議上，無狀態。它指定客戶端發送給服務器端的消息和得到的響應。請求和響應消息頭是ASCII碼；消息內容則類似MIME格式。</p>
<h3 id="223-http請求"><a class="header" href="#223-http請求">2.2.3 HTTP請求</a></h3>
<p>客戶端發送到服務器端的請求消息。</p>
<ol>
<li>請求行（Request Line）</li>
</ol>
<p>請求方法、URI、HTTP協議/協議版本組成。</p>
<div class="table-wrapper"><table><thead><tr><th>請求方法</th><th>方法描述</th></tr></thead><tbody>
<tr><td>GET</td><td>請求頁面，並返回頁面內容，請求參數包含在URL中，提交數據最多1024byte</td></tr>
<tr><td>HEAD</td><td>類似GET，只獲取報頭</td></tr>
<tr><td>POST</td><td>提交表單或上傳文件，數據（含請求參數）包含在請求體中</td></tr>
<tr><td>PUT</td><td>取代指定內容的文檔</td></tr>
<tr><td>DELETE</td><td>刪除指定資源</td></tr>
<tr><td>OPTIONS</td><td>查看服務器的性能</td></tr>
<tr><td>CONNECT</td><td>服務器當作跳板，訪問其他網頁</td></tr>
<tr><td>TRACE</td><td>回顯服務器收到的請求，用於測試或診斷</td></tr>
</tbody></table>
</div>
<ol>
<li>請求頭（Request Header）</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>請求頭</th><th>示例</th><th>說明</th></tr></thead><tbody>
<tr><td>Accept</td><td>Accept: text/plain, text/html</td><td>客戶端能夠接收的內容類型</td></tr>
<tr><td>Accept-charset</td><td>Accept-charset: iso-8859-5</td><td>字符編碼集</td></tr>
<tr><td>Accept-Encoding</td><td>Accept-Encoding: compress, gzip</td><td>壓縮編碼類型</td></tr>
<tr><td>Accept-Language</td><td>Accept-Language: en, zh</td><td>語言</td></tr>
<tr><td>Accept-Ranges</td><td>Accept-Ranges: bytes</td><td>子範圍字段</td></tr>
<tr><td>Authorization</td><td>Authorization: Basic dbXleoOEpePOetpoe2Ftyd==</td><td>授權證書</td></tr>
<tr><td>Cache-Control</td><td>Cache-Control: no-cache</td><td>緩存機制</td></tr>
<tr><td>Connection</td><td>Connection: close</td><td>是否需要持久連接（HTTP1.1默認持久連接）</td></tr>
<tr><td>Cookie</td><td>Cookie: $version=1; Skin=new;</td><td>請求域名下的所有cookie值</td></tr>
<tr><td>Content-Length</td><td>Content-Length: 348</td><td>內容長度</td></tr>
</tbody></table>
</div>
<ol>
<li>請求體（Request Body）</li>
</ol>
<p>HTTP請求中傳輸數據的實體。</p>
<h3 id="224-http響應"><a class="header" href="#224-http響應">2.2.4 HTTP響應</a></h3>
<p>服務器端返回給客戶端。</p>
<ol>
<li>響應狀態碼（Response Status Code）</li>
</ol>
<p>表示服務器的響應狀態。</p>
<div class="table-wrapper"><table><thead><tr><th>狀態碼</th><th>說明</th><th>詳情</th></tr></thead><tbody>
<tr><td>100</td><td>繼續</td><td>服務器收到部分請求，等待客戶端繼續提出請求</td></tr>
<tr><td>101</td><td>切換協議</td><td>請求者已要求服務器切換協議，服務器已確認並準備切換協議</td></tr>
<tr><td>200</td><td>成功</td><td>成功處理請求</td></tr>
<tr><td>201</td><td>已創建</td><td>服務器創建了新的資源</td></tr>
<tr><td>202</td><td>已接受</td><td>已接收請求，但尚未處理</td></tr>
<tr><td>203</td><td>非授權信息</td><td>成功處理請求，但返回信息來自另一個源</td></tr>
<tr><td>204</td><td>無內容</td><td>成功處理請求，無返回內容</td></tr>
<tr><td>205</td><td>重置內容</td><td>成功處理請求，內容重置</td></tr>
<tr><td>206</td><td>部分內容</td><td>成功處理部分內容</td></tr>
<tr><td>300</td><td>多種選擇</td><td>可執行多種操作</td></tr>
<tr><td>301</td><td>永久移動</td><td>永久重定向</td></tr>
<tr><td>302</td><td>臨時移動</td><td>暫時重定向</td></tr>
<tr><td>303</td><td>查看其他位置</td><td>重定向目標文檔應通過GET獲取</td></tr>
<tr><td>304</td><td>未修改</td><td>使用上次網頁資源</td></tr>
<tr><td>305</td><td>使用代理</td><td>應使用代理訪問</td></tr>
<tr><td>307</td><td>臨時重定向</td><td>臨時從其他位置響應</td></tr>
<tr><td>400</td><td>錯誤請求</td><td>無法解析</td></tr>
<tr><td>401</td><td>未授權</td><td>無身份驗證或驗證未通過</td></tr>
<tr><td>403</td><td>禁止訪問</td><td>拒絕</td></tr>
<tr><td>404</td><td>未找到</td><td>找不到</td></tr>
<tr><td>405</td><td>方法禁用</td><td>禁用指定方法</td></tr>
<tr><td>406</td><td>不接受</td><td>無法使用內容響應</td></tr>
<tr><td>407</td><td>需要代理授權</td><td>需要使用代理授權</td></tr>
<tr><td>408</td><td>請求超時</td><td>請求超時</td></tr>
<tr><td>409</td><td>沖突</td><td>完成請求時發生沖突</td></tr>
<tr><td>410</td><td>已刪除</td><td>資源永久刪除</td></tr>
<tr><td>411</td><td>需要有效長度</td><td>不接受標頭字段不含有效內容長度</td></tr>
<tr><td>412</td><td>未滿足前提條件</td><td>服務器未滿足某個前提條件</td></tr>
<tr><td>413</td><td>請求實體過大</td><td>超出能力</td></tr>
<tr><td>414</td><td>請求URI過長</td><td>網址過長，無法處理</td></tr>
<tr><td>415</td><td>不支持類型</td><td>格式不支持</td></tr>
<tr><td>416</td><td>請求範圍不符</td><td>頁面無法提供請求範圍</td></tr>
<tr><td>417</td><td>未滿足期望值</td><td>未滿足期望請求標頭字段</td></tr>
<tr><td>500</td><td>服務器內部發生錯誤</td><td>服務器錯誤</td></tr>
<tr><td>501</td><td>未實現</td><td>不具備功能</td></tr>
<tr><td>502</td><td>錯誤網關</td><td>收到無效響應</td></tr>
<tr><td>503</td><td>服務不可用</td><td>無法使用</td></tr>
<tr><td>504</td><td>網關超時</td><td>沒及時收到請求</td></tr>
<tr><td>505</td><td>HTTP版本不支持</td><td>不支持HTTP協議版本</td></tr>
</tbody></table>
</div>
<ol>
<li>響應頭（Response Headers）</li>
</ol>
<p>包含服務器對請求的應答信息。</p>
<div class="table-wrapper"><table><thead><tr><th>響應頭</th><th>說明</th></tr></thead><tbody>
<tr><td>Allow</td><td>服務器支持的請求方法</td></tr>
<tr><td>Content-Encondig</td><td>文檔編碼方法。</td></tr>
<tr><td>Content-Length</td><td>內容長度，瀏覽器持久HTTP連接時需要</td></tr>
<tr><td>Content-Type</td><td>文檔的MIME類型</td></tr>
<tr><td>Date</td><td>GMT時間</td></tr>
<tr><td>Expires</td><td>過期時間後，不再緩存</td></tr>
<tr><td>Last-Modified</td><td>文檔最後改動時間。通過比較客戶端頭if-Modified-Since，可能返回304（Not Modified）。</td></tr>
<tr><td>Location</td><td>客戶端應去哪裡提取文檔。</td></tr>
<tr><td>Refresh</td><td>瀏覽器應刷新時間，秒</td></tr>
<tr><td>Server</td><td>服務器名字</td></tr>
<tr><td>Set-Cookie</td><td>設置頁面關聯Cookie</td></tr>
<tr><td>WWW-Authenticate</td><td>客戶應在Authorization中提供授權信息，通常返回401。</td></tr>
</tbody></table>
</div>
<ol>
<li>響應體（Response Body）</li>
</ol>
<p>HTTP請求返回的內容。
HTML，二進制數據，JSON文檔，XML文檔等。</p>
<h3 id="225-uri與url"><a class="header" href="#225-uri與url">2.2.5 URI與URL</a></h3>
<ol>
<li>URI（Uniform Resource Identifier，統一資源標識符）
用來標識Web上每一種可用資源，概念。由資源的命名機制、存放資源的主機名、資源自身的名稱等組成。</li>
<li>URL（Uniform Resource Locator，統一資源定位符）
用於描述網絡上的資源（描述信息資源的字符串），實現。使用統一格式，包括文件、服務器地址和目錄等。</li>
</ol>
<pre><code class="language-URL">scheme://host[:port#]/path/.../[?query-string][#anchor]
//協議（服務方式）
//主機域名或IP地址（可含端口號）
//具體地址，目錄和文件名等
</code></pre>
<ol>
<li>URN（Uniform Resource Name，統一資源名）
帶有名字的因特網資源，是URL的更新形式，不依賴位置，可減少失效鏈接個數。</li>
</ol>
<h3 id="226-https簡介"><a class="header" href="#226-https簡介">2.2.6 HTTPS簡介</a></h3>
<p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），在HTTP基礎上，通過傳輸加密和身份認證保證傳輸過程的安全型。HTTP + SSL/TLS。</p>
<p>TLS（Transport Layer Security，傳輸層安全性協議），及其前身SSL（Secure Socket Layer，安全套接字層），保障通信安全和數據完整性。</p>
<h3 id="227-http2簡介"><a class="header" href="#227-http2簡介">2.2.7 HTTP2簡介</a></h3>
<ol>
<li>HTTP協議歷史</li>
</ol>
<ul>
<li>HTTP 0.9
只支持GET方法，不支持MIME類型和HTTP各種頭信息等。</li>
<li>HTTP 1.0
增加很多方法、各種HTTP頭信息，以及對多媒體對象的處理。</li>
<li>HTTP 1.1
主流HTTP協議，改善結構性缺陷，明確語義，增刪特性，支持更復雜的Web應用程序。</li>
<li>HTTP 2
優化性能，兼容HTTP 1.1語義，是二進制協議，頭部採用HPACK壓縮，支持多路復用、服務器推送等。</li>
</ul>
<ol>
<li>HTTP 1.1與HTTP 2的對比</li>
</ol>
<ul>
<li>頭信息壓縮
HTTP 1.1中，每一次發送和響應，都有HTTP頭信息。HTTP 2壓縮頭信息，減少帶寬。</li>
<li>推送功能
HTTP 2之前，只能客戶端發送數據，服務器端返回數據。HTTP2中，服務器可以主動向客戶端發起一些數據傳輸（如css和png等），服務器可以並行發送html，css，js等數據。</li>
</ul>
<h3 id="228-web應用程序的組成"><a class="header" href="#228-web應用程序的組成">2.2.8 Web應用程序的組成</a></h3>
<ol>
<li>處理器（hendler）
接收HTTP請求並處理。調用模板引擎生成html文檔返給客戶端。</li>
</ol>
<p>MVC軟件架構模型</p>
<ul>
<li>模型（Model）
處理與業務邏輯相關的數據，以及封裝對數據的處理方法。有對數據直接訪問的權力，例如訪問數據庫。</li>
<li>視圖（View）
實現有目的的顯示數據，一般沒有程序的邏輯。</li>
<li>控制器（Controller）
組織不同層面，控制流程，處理用戶請求，模型交互等事件，並做出響應。</li>
</ul>
<p>title模型Model控制器Controller視圖View瀏覽器模板引擎數據庫</p>
<ol>
<li>模板引擎（template engine）
分離界面與數據（內容），組合模板（template）與數據（data），生成html文檔。
分為置換型（模板內容中特定標記替換）、解釋型和編譯型等。</li>
</ol>
<p>模板template數據data模板引擎HTML文檔</p>
<h2 id="23-nethttp包"><a class="header" href="#23-nethttp包">2.3 net/http包</a></h2>
<h3 id="231-創建簡單服務器端"><a class="header" href="#231-創建簡單服務器端">2.3.1 創建簡單服務器端</a></h3>
<ol>
<li>創建和解析HTTP服務器端</li>
</ol>
<pre><code class="language-go">package main

import (
	"net/http"
)

func sayHello(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte("Hello World"))
}

func main() {
	//註冊路由
	http.HandleFunc("/hello", sayHello)
	//開啟對客戶端的監聽
	http.ListenAndServe(":8080", nil)
}
http.HandleFunc()函數

//輸入參數：監聽端口號和事件處理器handler
http.ListenAndServe()函數

type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
package main

import (
	"net/http"
)

type Refer struct {
	handler http.Handler
	refer string
}

func (this *Refer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Referer() == this.refer {
		this.handler.ServeHTTP(w, r)
	} else {
		w.WriteHeader(403)
	}
}

func myHandler(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte("this is handler"))
}

func hello(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte("hello"))
}

func main() {
	referer := &amp;Refer{
		handler: http.HandlerFunc(myHandler),
		refer: "www.shirdon.com",
	}
	http.HandleFunc("/hello", hello)
	http.ListenAndServe(":8080", referer)
}
</code></pre>
<ol>
<li>創建和解析HTTPS服務器端</li>
</ol>
<pre><code class="language-go">//證書文件路徑，私鑰文件路徑
func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
package main

import (
	"log"
	"net/http"
)

func handle(w http.ResponseWriter, r *http.Request) {
	log.Printf("Got connection: %s", r.Proto)
	w.Write([]byte("Hello this is a HTTP 2 message!"))
}

func main() {
	srv := &amp;http.Server{Addr: ":8088", Handler: http.HandlerFunc(handle)}
	log.Printf("Serving on https://0.0.0.0:8088")
	log.Fatal(srv.ListenAndServeTLS("server.crt", "server.key"))
}
</code></pre>
<h3 id="232-創建簡單的客戶端"><a class="header" href="#232-創建簡單的客戶端">2.3.2 創建簡單的客戶端</a></h3>
<pre><code class="language-go">//src/net/http/client.go
var DefaultClient = &amp;Client{}

func Get(url string) (resp *Response, err error) {
	return DefaultClient.Get(url)
}

func (c *Client) Get(url string) (resp *Response, err error) {
	req, err := NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	return c.Do(req)
}

func Post(url, contentType string, body io.Reader) (resp *Response, err error) {
	return DefaultClient.Post(url, contentType, body)
}

func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error) {
	req, err := NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.Header.set("Content-Type", contentType)
	return c.Do(req)
}
func NewRequest(method, url string, body io.Reader) (*Request, error)
//請求類型
//請求地址
//若body實現io.Closer接口，則Request返回值的Body字段會被設置為body值，並被Client的Do()、Post()和PostForm()方法關閉。
</code></pre>
<ol>
<li>創建GET請求</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

func main() {
	resp, err := http.Get("https://www.baidu.com")
	if err != nil {
		fmt.Println("err:", err)
	}
	closer := resp.Body
	bytes, err := ioutil.ReadAll(closer)
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建POST請求</li>
</ol>
<pre><code class="language-go">package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
)

func main() {
	url := "https://www.shirdon.com/comment/add"
	body := `{"userId": 1, "articleId": 1, "comment": 這是一條評論}`
	resp, err := http.Post(url, "application/x-www-form-urlencoded", bytes.NewBuffer([]byte(body)))
	if err != nil {
		fmt.Println("err:", err)
	}
	bytes, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建PUT請求</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	url := "https://www.shirdon.com/comment/update"
	payload := strings.NewReader(`{"userId": 1, "articleId": 1, "comment": 這是一條評論}`)
	req, _ := http.NewRequest("PUT", url, payload)
	req.Header.Add("Content-Type", "application/json")
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Println("err:", err)
	}
	defer res.Body.Close()
	bytes, err := ioutil.ReadAll(res.Body)
	fmt.Println(string(res))
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建DELETE請求</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	url := "https://www.shirdon.com/comment/delete"
	payload := strings.NewReader(`{"userId": 1, "articleId": 1, "comment": 這是一條評論}`)
	req, _ := http.NewRequest("DELETE", url, payload)
	req.Header.Add("Content-Type", "application/json")
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Println("err:", err)
	}
	defer res.Body.Close()
	bytes, err := ioutil.ReadAll(res.Body)
	fmt.Println(string(res))
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>請求頭設置</li>
</ol>
<pre><code class="language-go">type Header map[string][]string
headers := http.Header{"token": {"feeowiwpor23dlspweh"}}
headers.Add("Accept-Charset", "UTF-8")
headers.Set("Host", "www.shirdon.com")
headers.Set("Location", "www.baidu.com")
</code></pre>
<h2 id="24-htmltemplate包"><a class="header" href="#24-htmltemplate包">2.4 html/template包</a></h2>
<p>text/template處理任意格式的文本，html/template生成可對抗代碼注入的安全html文檔。</p>
<h3 id="241-模板原理"><a class="header" href="#241-模板原理">2.4.1 模板原理</a></h3>
<ol>
<li>模板和模板引擎
模板是事先定義好的不變的html文檔，模板渲染使用可變數據替換html文檔中的標記。模板用於顯示和數據分離（前後端分離）。模板技術，本質是模板引擎利用模板文件和數據生成html文檔。</li>
<li>Go語言模板引擎</li>
</ol>
<ul>
<li>模板文件後綴名通常為.tmpl和.tpl，UTF-8編碼</li>
<li>模板文件中{{和}}包裹和標識傳入數據</li>
<li>點號（.）訪問數據，{{.FieldName}}訪問字段</li>
<li>除{{和}}包裹內容外，其他內容原樣輸出</li>
</ul>
<p>使用：
（1）定義模板文件
按照相應語法規則去定義。
（2）解析模板文件
創建指定模板名稱的模板對象</p>
<pre><code class="language-go">func New(name string) *Template
</code></pre>
<p>解析模板內容</p>
<pre><code class="language-go">func (t *Template) Parse(src string) (*Template, error)
</code></pre>
<p>解析模板文件</p>
<pre><code class="language-go">func ParseFiles(filenames...string) (*Template, error)
</code></pre>
<p>正則匹配解析文件，template.ParaeGlob(“a*”)</p>
<pre><code class="language-go">func ParseGlob(pattern string) (*Template, error)
</code></pre>
<p>（3）渲染模板文件</p>
<pre><code class="language-go">func (t *Template) Execute(wr io.Writer, data interface{}) error

//配合ParseFiles()函數使用，需指定模板名稱
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error
</code></pre>
<h3 id="242-使用htmltemplate包"><a class="header" href="#242-使用htmltemplate包">2.4.2 使用html/template包</a></h3>
<ol>
<li>第1個模板
template_example.tmpl</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;模板使用示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;p&gt;加油，小夥伴， {{ . }} &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
package main

import (
	"fmt"
	"html/template"
	"net/http"
)

func helloHandleFunc(w http.ResponseWriter, r *http.Request) {
	// 1. 解析模板
	t, err := template.ParseFiles("./template_example.tmpl")
	if err != nil {
		fmt.Println("template parsefile failed, err:", err)
		return
	}
	// 2.渲染模板
	name := "我愛Go語言"
	t.Execute(w, name)
}

func main() {
	http.HandleFunc("/", helloHandleFunc)
	http.ListenAndServe(":8086", nil)
}
</code></pre>
<ol>
<li>模板語法
模板語法都包含在{{和}}中間。</li>
</ol>
<pre><code class="language-go">type UserInfo struct {
	Name string
	Gender string
	Age int
}

func sayHello(w http.ResponseWriter, r *http.Request) {
	tmpl, err := template.ParseFiles("./hello.html")
	if err != nil {
		fmp.Println("create template failed, err:", err)
		return
	}

	user := UserInfo {
		Name: "張三",
		Gender: "男",
		Age: 28,
	}
	tmpl.Execute(w, user)
}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;p&gt;Hello {{.Name}}&lt;/p&gt;
   &lt;p&gt;性別：{{.Gender}}&lt;/p&gt;
   &lt;p&gt;年齡：{{.Age}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>常用語法：</p>
<ul>
<li>注釋</li>
</ul>
<pre><code class="language-go">{{/* 這是一個注釋，不會解析 */}}
</code></pre>
<ul>
<li>管道（pipeline）
產生數據的操作，{{.Name}}等。支持|鏈接多個命令，類似UNIX下管道。</li>
<li>變量
變量捕獲管道的執行結果。</li>
</ul>
<pre><code class="language-go">$variable := pipeline
</code></pre>
<ul>
<li>條件判斷</li>
</ul>
<pre><code class="language-go">{{if pipeline}} T1 {{end}}
{{if pipeline}} T1 {{else}} T0 {{end}}
{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
</code></pre>
<ul>
<li>range關鍵字</li>
</ul>
<pre><code class="language-go">{{range pipeline}} T1 {{end}}
{{range pipeline}} T1 {{else}} T0 {{end}}
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	//創建一個模版
	rangeTemplate := `
{{if .Kind}}
{{range $i, $v := .MapContent}}
{{$i}} =&gt; {{$v}} , {{$.OutsideContent}}
{{end}}
{{else}}
{{range .MapContent}}
{{.}} , {{$.OutsideContent}}
{{end}}    
{{end}}`

	str1 := []string{"第一次 range", "用 index 和 value"}
	str2 := []string{"第二次 range", "沒有用 index 和 value"}

	type Content struct {
		MapContent     []string
		OutsideContent string
		Kind           bool
	}
	var contents = []Content{
		{str1, "第一次外面的內容", true},
		{str2, "第二次外面的內容", false},
	}

	// 創建模板並將字符解析進去
	t := template.Must(template.New("range").Parse(rangeTemplate))

	// 接收並執行模板
	for _, c := range contents {
		err := t.Execute(os.Stdout, c)
		if err != nil {
			log.Println("executing template:", err)
		}
	}
}
/*
//輸出
0 =&gt; 第一次 range, 第一次外面的內容
1 =&gt; 用 index 和 value, 第一次外面的內容

第二次 range, 第二次外面的內容
沒有用 index 和 value, 第二次外面的內容
*/
</code></pre>
<ul>
<li>with關鍵字</li>
</ul>
<pre><code class="language-go">{{with pipeline}} T1 {{end}}
{{with pipeline}} T1 {{else}} T0 {{end}}
</code></pre>
<ul>
<li>比較函數
比較函數只適用於基本函數（或重定義的基本類型，如type Banance float32），整數和浮點數不能相互比較。
布爾函數將任何類型的零值視為假。
只有eq可以接受2個以上參數。</li>
</ul>
<pre><code class="language-go">{{eq arg1 arg2 arg3}}
eq
ne
lt
le
gt
ge
</code></pre>
<ul>
<li>預定義函數</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>函數名</th><th>功能</th></tr></thead><tbody>
<tr><td>and</td><td>返回第1個空參數或最後一個參數，所有參數都執行。and x y等價於if x then y else x</td></tr>
<tr><td>or</td><td>返回第1個非空參數或最後一個參數，所有參數都執行。and x y等價於if x then y else x</td></tr>
<tr><td>not</td><td>非</td></tr>
<tr><td>len</td><td>長度</td></tr>
<tr><td>index</td><td>index y 1 2 3, index[1][2][3]</td></tr>
<tr><td>print</td><td>fmt.Sprint</td></tr>
<tr><td>printf</td><td>fmt.Sprintf</td></tr>
<tr><td>println</td><td>fmt.Sprintln</td></tr>
<tr><td>html</td><td>html逸碼等價表示</td></tr>
<tr><td>urlquery</td><td>可嵌入URL查詢的逸碼等價表示</td></tr>
<tr><td>js</td><td>JavaScript逸碼等價表示</td></tr>
<tr><td>call</td><td>call func a b, func(a, b);1或2個返回值，第2個為error，非nil會中斷並返回給調用者。</td></tr>
</tbody></table>
</div>
<ul>
<li>自定義函數
模板對象t的函數字典加入funcMap內的鍵值對。funcMap某個值不是函數類型，或該函數類型不符合要求，會panic。返回*Template便於鏈式調用。</li>
</ul>
<pre><code class="language-go">func (t *Template) Funcs(funcMap FuncMap) *Template
</code></pre>
<p>FuncMap映射函數要求1或2個返回值，第2個為error，非nil會中斷並返回給調用者。</p>
<pre><code class="language-go">type FuncMap map[string]interface{}
package main

import (
	"fmt"
	"html/template"
	"io/ioutil"
	"net/http"
)

func Welcome() string { //沒參數
	return "Welcome"
}

func Doing(name string) string { //有參數
	return name + ", Learning Go Web template "
}

func sayHello(w http.ResponseWriter, r *http.Request) {
	htmlByte, err := ioutil.ReadFile("./funcs.html")
	if err != nil {
		fmt.Println("read html failed, err:", err)
		return
	}
	// 自定義一個匿名模板函數
	loveGo := func() (string) {
		return "歡迎一起學習《Go Web編程實戰派從入門到精通》"
	}
	// 採用鏈式操作在Parse()方法之前調用Funcs添加自定義的loveGo函數
	tmpl1, err := template.New("funcs").Funcs(template.FuncMap{"loveGo": loveGo}).Parse(string(htmlByte))
	if err != nil {
		fmt.Println("create template failed, err:", err)
		return
	}
	funcMap := template.FuncMap{
		//在FuncMap中聲明相應要使用的函數，然後就能夠在template字符串中使用該函數
		"Welcome": Welcome,
		"Doing":   Doing,
	}
	name := "Shirdon"
	tmpl2, err := template.New("test").Funcs(funcMap).Parse("{{Welcome}}&lt;br/&gt;{{Doing .}}")
	if err != nil {
		panic(err)
	}

	// 使用user渲染模板，並將結果寫入w
	tmpl1.Execute(w, name)
	tmpl2.Execute(w, name)
}

func main() {
	http.HandleFunc("/", sayHello)
	http.ListenAndServe(":8087", nil)
}
</code></pre>
<p>funcs.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
		&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
		&lt;title&gt;tmpl test&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;{{loveGo}}&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>模板嵌套
可以通過文件嵌套和define定義</li>
</ul>
<pre><code class="language-go">{{define "name"}} T {{end}}
{{template "name"}}
{{template "name" pipeline}}
{{block "name" pipeline}} T {{end}}
//等價於
{{define "name"}} T {{end}}
{{template "name" pipeline}}
</code></pre>
<p>t.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;tmpl test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;測試嵌套template語法&lt;/h1&gt;
&lt;hr&gt;
{{template "ul.html"}}
&lt;hr&gt;
{{template "ol.html"}}
&lt;/body&gt;
&lt;/html&gt;
{{define "ol.html"}}
&lt;h1&gt;這是ol.html&lt;/h1&gt;
&lt;ol&gt;
    &lt;li&gt;I love Go&lt;/li&gt;
    &lt;li&gt;I love java&lt;/li&gt;
    &lt;li&gt;I love c&lt;/li&gt;
&lt;/ol&gt;
{{end}}
</code></pre>
<p>ul.html</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;注釋&lt;/li&gt;
    &lt;li&gt;日誌&lt;/li&gt;
    &lt;li&gt;測試&lt;/li&gt;
&lt;/ul&gt;
package main

import (
	"fmt"
	"html/template"
	"net/http"
)

//定義一個UserInfo結構體
type UserInfo struct {
	Name string
	Gender string
	Age int
}

func tmplSample(w http.ResponseWriter, r *http.Request) {
	tmpl, err := template.ParseFiles("./t.html", "./ul.html")
	if err != nil {
		fmt.Println("create template failed, err:", err)
		return
	}
	user := UserInfo{
		Name:   "張三",
		Gender: "男",
		Age:    28,
	}
	tmpl.Execute(w, user)
	fmt.Println(tmpl)
}

func main() {
	http.HandleFunc("/", tmplSample)
	http.ListenAndServe(":8087", nil)
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../go/Go編程實戰派基礎入門.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../go/golang_debugger.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../go/Go編程實戰派基礎入門.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../go/golang_debugger.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
