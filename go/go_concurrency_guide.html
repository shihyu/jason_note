<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go ä¸¦è¡Œæ©Ÿåˆ¶å®Œæ•´æŒ‡å— - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-ä¸¦è¡Œæ©Ÿåˆ¶å®Œæ•´æŒ‡å—-"><a class="header" href="#go-ä¸¦è¡Œæ©Ÿåˆ¶å®Œæ•´æŒ‡å—-">Go ä¸¦è¡Œæ©Ÿåˆ¶å®Œæ•´æŒ‡å— ğŸ¹</a></h1>
<h2 id="-ç›®éŒ„çµæ§‹"><a class="header" href="#-ç›®éŒ„çµæ§‹">ğŸ“‘ ç›®éŒ„çµæ§‹</a></h2>
<p>é€™ä»½æŒ‡å—åˆ†ç‚ºä»¥ä¸‹éƒ¨åˆ†ï¼š</p>
<h3 id="ç¬¬ä¸€éƒ¨åˆ†æ¦‚è¦½èˆ‡åŸºç¤"><a class="header" href="#ç¬¬ä¸€éƒ¨åˆ†æ¦‚è¦½èˆ‡åŸºç¤">ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¦‚è¦½èˆ‡åŸºç¤</a></h3>
<ul>
<li><a href="#%E8%A6%96%E8%A6%BA%E5%8C%96%E6%A6%82%E8%A6%BD">è¦–è¦ºåŒ–æ¦‚è¦½</a></li>
<li><a href="#goroutine-%E5%92%8C-channel">Goroutine å’Œ Channel</a></li>
<li><a href="#mutex-%E5%92%8C-rwmutex">Mutex å’Œ RWMutex</a></li>
</ul>
<h3 id="ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª"><a class="header" href="#ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª">ç¬¬äºŒéƒ¨åˆ†ï¼šé«˜æ•ˆèƒ½åŸèª</a></h3>
<ul>
<li><a href="#sync-%E5%8C%85%E5%8E%9F%E8%AA%9E">Sync åŒ…åŸèª</a></li>
<li><a href="#atomic-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">Atomic åŸå­æ“ä½œ</a></li>
</ul>
<h3 id="ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥æ©Ÿåˆ¶"><a class="header" href="#ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥æ©Ÿåˆ¶">ç¬¬ä¸‰éƒ¨åˆ†ï¼šé«˜ç´šåŒæ­¥æ©Ÿåˆ¶</a></h3>
<ul>
<li><a href="#context-%E4%B8%8A%E4%B8%8B%E6%96%87">Context ä¸Šä¸‹æ–‡</a></li>
<li><a href="#waitgroup-%E5%92%8C-once">WaitGroup å’Œ Once</a></li>
</ul>
<h3 id="ç¬¬å››éƒ¨åˆ†å¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸"><a class="header" href="#ç¬¬å››éƒ¨åˆ†å¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸">ç¬¬å››éƒ¨åˆ†ï¼šå¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸</a></h3>
<ul>
<li><a href="#%E9%AB%98%E7%B4%9A%E4%B8%A6%E8%A1%8C%E6%A8%A1%E5%BC%8F">é«˜ç´šä¸¦è¡Œæ¨¡å¼</a></li>
<li><a href="#%E9%81%B8%E6%93%87%E6%8C%87%E5%8D%97%E8%88%87%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90">é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸</a></li>
</ul>
<hr />
<h2 id="-è¦–è¦ºåŒ–æ¦‚è¦½"><a class="header" href="#-è¦–è¦ºåŒ–æ¦‚è¦½">ğŸ“Š è¦–è¦ºåŒ–æ¦‚è¦½</a></h2>
<pre><code>Go ä¸¦è¡Œçš„é¸æ“‡æµç¨‹åœ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   éœ€è¦ä¸¦è¡Œå—ï¼Ÿ   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ æ˜¯
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç°¡å–®ä¸¦è¡Œä»»å‹™ï¼Ÿ â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Goroutine  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸƒ å”ç¨‹          â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åŸ·è¡Œç·’é–“é€šè¨Šï¼Ÿ â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Channel    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ“¡ é€šé“          â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å…±äº«è¨˜æ†¶é«”ï¼Ÿ   â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Mutex      â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ”’ äº’æ–¥é–        â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¤šè®€å°‘å¯«ï¼Ÿ     â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ RWMutex    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ“– è®€å¯«é–        â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åŸå­æ“ä½œï¼Ÿ     â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Atomic     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  âš›ï¸ åŸå­é¡å‹      â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  çµ„åˆä½¿ç”¨å¤šç¨®   â”‚
â”‚  ğŸ¯ æ··åˆæ¨¡å¼     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ"><a class="header" href="#æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ">æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>é¡å‹</th><th>æ•ˆèƒ½</th><th>ä½¿ç”¨å ´æ™¯</th><th>ç‰¹é»</th></tr></thead><tbody>
<tr><td><code>Goroutine</code></td><td>ğŸ¥‡ æœ€å¿«</td><td>ä¸¦è¡Œä»»å‹™</td><td>è¼•é‡ç´šåŸ·è¡Œç·’</td></tr>
<tr><td><code>Channel</code></td><td>ğŸ¥ˆ å¾ˆå¿«</td><td>åŸ·è¡Œç·’é€šè¨Š</td><td>é¡å‹å®‰å…¨é€šè¨Š</td></tr>
<tr><td><code>sync/atomic</code></td><td>ğŸ¥‰ å¿«</td><td>åŸå­æ“ä½œ</td><td>ç„¡é–æ“ä½œ</td></tr>
<tr><td><code>RWMutex</code> (è®€)</td><td>ğŸ… ä¸­ç­‰</td><td>å¤šè®€å°‘å¯«</td><td>ä¸¦è¡Œè®€å–</td></tr>
<tr><td><code>Mutex</code></td><td>ğŸ… ä¸­ç­‰</td><td>åŸºæœ¬äº’æ–¥</td><td>ç°¡å–®å¯é </td></tr>
<tr><td><code>WaitGroup</code></td><td>ğŸ… ä¸­ç­‰</td><td>åŒæ­¥ç­‰å¾…</td><td>ä»»å‹™å”èª¿</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="goroutine-å’Œ-channel-åŸºç¤-"><a class="header" href="#goroutine-å’Œ-channel-åŸºç¤-">Goroutine å’Œ Channel åŸºç¤ ğŸƒğŸ“¡</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: Goroutine åƒè¼•é‡ç´šçš„å·¥äººï¼ŒChannel åƒä»–å€‘ä¹‹é–“çš„å‚³è¼¸å¸¶</p>
<pre><code>Goroutine + Channel å·¥ä½œç¤ºæ„åœ–ï¼š
Goroutine1: ğŸƒ â”€â”€â”
Goroutine2: ğŸƒ â”€â”€â”¼â”€â”€â–¶ ğŸ“¡ Channel â”€â”€â–¶ ğŸƒ Goroutine3
Goroutine3: ğŸƒ â”€â”€â”˜
</code></pre>
<h3 id="åŸºæœ¬-goroutine-ç¯„ä¾‹"><a class="header" href="#åŸºæœ¬-goroutine-ç¯„ä¾‹">åŸºæœ¬ Goroutine ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func basicGoroutineExample() {
    fmt.Println("ä¸»åŸ·è¡Œç·’é–‹å§‹")
    fmt.Printf("CPU æ ¸å¿ƒæ•¸: %d\n", runtime.NumCPU())
    
    var wg sync.WaitGroup
    
    // å•Ÿå‹•å¤šå€‹ goroutine
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j &lt; 3; j++ {
                fmt.Printf("Goroutine %d åŸ·è¡Œç¬¬ %d æ¬¡\n", id, j+1)
                time.Sleep(100 * time.Millisecond)
            }
            fmt.Printf("Goroutine %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰ goroutine å®Œæˆ")
}

func main() {
    basicGoroutineExample()
}
</code></pre>
<h3 id="channel-åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹"><a class="header" href="#channel-åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹">Channel åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func basicChannelExample() {
    // ç„¡ç·©è¡é€šé“
    ch := make(chan string)
    
    // ç™¼é€è€… goroutine
    go func() {
        messages := []string{"Hello", "World", "From", "Go"}
        for _, msg := range messages {
            fmt.Printf("ç™¼é€: %s\n", msg)
            ch &lt;- msg
            time.Sleep(500 * time.Millisecond)
        }
        close(ch)
    }()
    
    // æ¥æ”¶è€…
    for msg := range ch {
        fmt.Printf("æ¥æ”¶: %s\n", msg)
    }
}

// ç·©è¡é€šé“ç¯„ä¾‹
func bufferedChannelExample() {
    // å»ºç«‹ç·©è¡é€šé“ï¼Œå®¹é‡ç‚º3
    ch := make(chan int, 3)
    
    // ç™¼é€è€…
    go func() {
        for i := 1; i &lt;= 5; i++ {
            fmt.Printf("å˜—è©¦ç™¼é€ %d\n", i)
            ch &lt;- i
            fmt.Printf("æˆåŠŸç™¼é€ %d\n", i)
        }
        close(ch)
    }()
    
    // æ¥æ”¶è€…æ•…æ„å»¶é²
    time.Sleep(2 * time.Second)
    
    for value := range ch {
        fmt.Printf("æ¥æ”¶: %d\n", value)
        time.Sleep(500 * time.Millisecond)
    }
}
</code></pre>
<h3 id="ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹"><a class="header" href="#ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹">ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Output string
    Worker int
}

func producerConsumerExample() {
    const numWorkers = 3
    const numJobs = 10
    
    jobs := make(chan Job, 5)
    results := make(chan Result, 5)
    
    var wg sync.WaitGroup
    
    // å•Ÿå‹•å·¥ä½œè€…
    for w := 1; w &lt;= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &amp;wg)
    }
    
    // çµæœæ”¶é›†å™¨
    go func() {
        for result := range results {
            fmt.Printf("çµæœ: å·¥ä½œè€… %d å®Œæˆä»»å‹™ %d - %s\n",
                result.Worker, result.Job.ID, result.Output)
        }
    }()
    
    // ç”Ÿç”¢è€…ï¼šç™¼é€å·¥ä½œ
    for j := 1; j &lt;= numJobs; j++ {
        job := Job{
            ID:   j,
            Data: fmt.Sprintf("ä»»å‹™è³‡æ–™ %d", j),
        }
        jobs &lt;- job
    }
    close(jobs)
    
    wg.Wait()
    close(results)
    
    time.Sleep(100 * time.Millisecond) // ç­‰å¾…çµæœè¼¸å‡º
}

func worker(id int, jobs &lt;-chan Job, results chan&lt;- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("å·¥ä½œè€… %d é–‹å§‹è™•ç†ä»»å‹™ %d\n", id, job.ID)
        
        // æ¨¡æ“¬å·¥ä½œ
        time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
        
        result := Result{
            Job:    job,
            Output: fmt.Sprintf("è™•ç†å®Œæˆ: %s", job.Data),
            Worker: id,
        }
        
        results &lt;- result
    }
    
    fmt.Printf("å·¥ä½œè€… %d çµæŸ\n", id)
}
</code></pre>
<h3 id="select-å¤šè·¯å¾©ç”¨"><a class="header" href="#select-å¤šè·¯å¾©ç”¨">Select å¤šè·¯å¾©ç”¨</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func selectExample() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    quit := make(chan bool)
    
    // ç™¼é€è€…1
    go func() {
        for i := 0; i &lt; 5; i++ {
            time.Sleep(1 * time.Second)
            ch1 &lt;- fmt.Sprintf("é€šé“1è¨Šæ¯ %d", i)
        }
    }()
    
    // ç™¼é€è€…2
    go func() {
        for i := 0; i &lt; 5; i++ {
            time.Sleep(1500 * time.Millisecond)
            ch2 &lt;- fmt.Sprintf("é€šé“2è¨Šæ¯ %d", i)
        }
    }()
    
    // è¶…æ™‚æ§åˆ¶
    go func() {
        time.Sleep(8 * time.Second)
        quit &lt;- true
    }()
    
    // é¸æ“‡å™¨
    for {
        select {
        case msg1 := &lt;-ch1:
            fmt.Printf("æ”¶åˆ°é€šé“1: %s\n", msg1)
        case msg2 := &lt;-ch2:
            fmt.Printf("æ”¶åˆ°é€šé“2: %s\n", msg2)
        case &lt;-quit:
            fmt.Println("è¶…æ™‚é€€å‡º")
            return
        case &lt;-time.After(500 * time.Millisecond):
            fmt.Println("ç­‰å¾…ä¸­...")
        }
    }
}
</code></pre>
<hr />
<h2 id="mutex-å’Œ-rwmutex-"><a class="header" href="#mutex-å’Œ-rwmutex-">Mutex å’Œ RWMutex ğŸ”’ğŸ“–</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: Mutex åƒå»æ‰€é–€é–ï¼Œä¸€æ¬¡åªèƒ½ä¸€å€‹äººç”¨ï¼›RWMutex åƒåœ–æ›¸é¤¨ï¼Œå¤šäººå¯ä»¥çœ‹æ›¸ä½†å¯«å­—æ™‚è¦æ¸…å ´</p>
<pre><code>Mutex vs RWMutex:
Mutex:   ğŸšªğŸ”’ (äº’æ–¥å­˜å–)
RWMutex: ğŸ‘€ğŸ‘€ğŸ‘€ æˆ– âœï¸ğŸš« (è®€è€…ä¸¦è¡Œï¼Œå¯«è€…ç¨å )
</code></pre>
<h3 id="åŸºæœ¬-mutex-ç¯„ä¾‹"><a class="header" href="#åŸºæœ¬-mutex-ç¯„ä¾‹">åŸºæœ¬ Mutex ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.value++
    fmt.Printf("è¨ˆæ•¸å™¨å¢åŠ åˆ°: %d\n", c.value)
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func mutexExample() {
    counter := &amp;SafeCounter{}
    var wg sync.WaitGroup
    
    // å¤šå€‹ goroutine ä¸¦è¡Œå¢åŠ è¨ˆæ•¸å™¨
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j &lt; 3; j++ {
                counter.Increment()
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("æœ€çµ‚è¨ˆæ•¸: %d\n", counter.Value())
}
</code></pre>
<h3 id="rwmutex-è®€å¯«é–ç¯„ä¾‹"><a class="header" href="#rwmutex-è®€å¯«é–ç¯„ä¾‹">RWMutex è®€å¯«é–ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type ConfigCache struct {
    mu       sync.RWMutex
    settings map[string]string
    version  int
}

func NewConfigCache() *ConfigCache {
    return &amp;ConfigCache{
        settings: make(map[string]string),
        version:  1,
    }
}

func (c *ConfigCache) Get(key string) (string, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    value, exists := c.settings[key]
    fmt.Printf("è®€å–è¨­å®š %s: %s (ç‰ˆæœ¬: %d)\n", key, value, c.version)
    return value, exists
}

func (c *ConfigCache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.settings[key] = value
    c.version++
    fmt.Printf("æ›´æ–°è¨­å®š %s = %s (æ–°ç‰ˆæœ¬: %d)\n", key, value, c.version)
}

func (c *ConfigCache) GetAll() map[string]string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    // è¤‡è£½ map ä»¥é¿å…å¤–éƒ¨ä¿®æ”¹
    result := make(map[string]string)
    for k, v := range c.settings {
        result[k] = v
    }
    return result
}

func rwMutexExample() {
    cache := NewConfigCache()
    var wg sync.WaitGroup
    
    // åˆå§‹åŒ–ä¸€äº›è¨­å®š
    cache.Set("theme", "dark")
    cache.Set("language", "zh-TW")
    
    // å¤šå€‹è®€è€…
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j &lt; 3; j++ {
                cache.Get("theme")
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    // å°‘æ•¸å¯«è€…
    for i := 0; i &lt; 2; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            time.Sleep(200 * time.Millisecond)
            cache.Set("theme", fmt.Sprintf("theme_%d", id))
        }(i)
    }
    
    wg.Wait()
    
    fmt.Println("æœ€çµ‚è¨­å®š:")
    for k, v := range cache.GetAll() {
        fmt.Printf("  %s: %s\n", k, v)
    }
}
</code></pre>
<h3 id="æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹"><a class="header" href="#æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹">æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func performanceComparison() {
    const iterations = 100000
    const goroutines = 10
    
    // Mutex æ¸¬è©¦
    fmt.Println("æ¸¬è©¦ Mutex æ•ˆèƒ½...")
    start := time.Now()
    
    var mutex sync.Mutex
    data := 0
    var wg sync.WaitGroup
    
    for i := 0; i &lt; goroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iterations; j++ {
                mutex.Lock()
                _ = data // æ¨¡æ“¬è®€å–
                mutex.Unlock()
            }
        }()
    }
    
    wg.Wait()
    mutexTime := time.Since(start)
    
    // RWMutex æ¸¬è©¦ (åªè®€)
    fmt.Println("æ¸¬è©¦ RWMutex è®€å–æ•ˆèƒ½...")
    start = time.Now()
    
    var rwMutex sync.RWMutex
    
    for i := 0; i &lt; goroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iterations; j++ {
                rwMutex.RLock()
                _ = data // æ¨¡æ“¬è®€å–
                rwMutex.RUnlock()
            }
        }()
    }
    
    wg.Wait()
    rwMutexTime := time.Since(start)
    
    fmt.Printf("Mutex æ™‚é–“: %v\n", mutexTime)
    fmt.Printf("RWMutex æ™‚é–“: %v\n", rwMutexTime)
    fmt.Printf("RWMutex æ¯” Mutex å¿« %.2fx\n", 
        float64(mutexTime.Nanoseconds())/float64(rwMutexTime.Nanoseconds()))
}
</code></pre>
<hr />
<h2 id="sync-åŒ…åŸèª-"><a class="header" href="#sync-åŒ…åŸèª-">Sync åŒ…åŸèª ğŸ“¦</a></h2>
<h3 id="waitgroup-åŒæ­¥ç­‰å¾…"><a class="header" href="#waitgroup-åŒæ­¥ç­‰å¾…">WaitGroup åŒæ­¥ç­‰å¾…</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func waitGroupExample() {
    var wg sync.WaitGroup
    tasks := []string{"ä»»å‹™A", "ä»»å‹™B", "ä»»å‹™C", "ä»»å‹™D"}
    
    fmt.Println("é–‹å§‹åŸ·è¡Œä¸¦è¡Œä»»å‹™...")
    
    for i, task := range tasks {
        wg.Add(1)
        go func(id int, taskName string) {
            defer wg.Done()
            
            fmt.Printf("é–‹å§‹ %s\n", taskName)
            // æ¨¡æ“¬ä¸åŒçš„å·¥ä½œæ™‚é–“
            time.Sleep(time.Duration(id+1) * 500 * time.Millisecond)
            fmt.Printf("å®Œæˆ %s\n", taskName)
        }(i, task)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰ä»»å‹™å®Œæˆï¼")
}

// éŒ¯èª¤ç¤ºç¯„ï¼šWaitGroup çš„å¸¸è¦‹éŒ¯èª¤
func waitGroupWrongExample() {
    var wg sync.WaitGroup
    
    for i := 0; i &lt; 3; i++ {
        // âŒ éŒ¯èª¤ï¼šåœ¨ goroutine å…§éƒ¨èª¿ç”¨ Add
        go func(id int) {
            wg.Add(1) // ç«¶çˆ­æ¢ä»¶ï¼
            defer wg.Done()
            fmt.Printf("ä»»å‹™ %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait() // å¯èƒ½æå‰çµæŸ
}

// æ­£ç¢ºç¤ºç¯„
func waitGroupCorrectExample() {
    var wg sync.WaitGroup
    
    for i := 0; i &lt; 3; i++ {
        wg.Add(1) // âœ… æ­£ç¢ºï¼šåœ¨å•Ÿå‹• goroutine å‰èª¿ç”¨ Add
        go func(id int) {
            defer wg.Done()
            fmt.Printf("ä»»å‹™ %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait()
}
</code></pre>
<h3 id="once-å–®æ¬¡åŸ·è¡Œ"><a class="header" href="#once-å–®æ¬¡åŸ·è¡Œ">Once å–®æ¬¡åŸ·è¡Œ</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

type Singleton struct {
    data string
}

var (
    instance *Singleton
    once     sync.Once
)

func GetSingleton() *Singleton {
    once.Do(func() {
        fmt.Println("å»ºç«‹å–®ä¾‹å¯¦ä¾‹...")
        instance = &amp;Singleton{data: "æˆ‘æ˜¯å–®ä¾‹"}
    })
    return instance
}

func onceExample() {
    var wg sync.WaitGroup
    
    // å¤šå€‹ goroutine å˜—è©¦ç²å–å–®ä¾‹
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            singleton := GetSingleton()
            fmt.Printf("Goroutine %d ç²å¾—: %s\n", id, singleton.data)
        }(i)
    }
    
    wg.Wait()
}

// åˆå§‹åŒ–å‡½æ•¸ç¯„ä¾‹
var config map[string]string
var configOnce sync.Once

func loadConfig() {
    configOnce.Do(func() {
        fmt.Println("è¼‰å…¥é…ç½®æ–‡ä»¶...")
        config = map[string]string{
            "database_url": "localhost:5432",
            "api_key":      "secret123",
        }
    })
}

func getConfig(key string) string {
    loadConfig() // ä¿è­‰åªåŸ·è¡Œä¸€æ¬¡
    return config[key]
}
</code></pre>
<h3 id="cond-æ¢ä»¶è®Šæ•¸"><a class="header" href="#cond-æ¢ä»¶è®Šæ•¸">Cond æ¢ä»¶è®Šæ•¸</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func condExample() {
    var mu sync.Mutex
    cond := sync.NewCond(&amp;mu)
    queue := make([]int, 0)
    
    // æ¶ˆè²»è€…
    go func() {
        mu.Lock()
        defer mu.Unlock()
        
        for len(queue) == 0 {
            fmt.Println("æ¶ˆè²»è€…ç­‰å¾…...")
            cond.Wait() // é‡‹æ”¾é–ä¸¦ç­‰å¾…
        }
        
        item := queue[0]
        queue = queue[1:]
        fmt.Printf("æ¶ˆè²»è€…å–å¾—: %d\n", item)
    }()
    
    // ç”Ÿç”¢è€…
    go func() {
        for i := 1; i &lt;= 3; i++ {
            time.Sleep(1 * time.Second)
            
            mu.Lock()
            queue = append(queue, i)
            fmt.Printf("ç”Ÿç”¢è€…æ–°å¢: %d\n", i)
            cond.Signal() // é€šçŸ¥ç­‰å¾…çš„ goroutine
            mu.Unlock()
        }
    }()
    
    time.Sleep(5 * time.Second)
}

// å¤šæ¶ˆè²»è€…ç¯„ä¾‹
func multiConsumerExample() {
    var mu sync.Mutex
    cond := sync.NewCond(&amp;mu)
    items := []string{"è˜‹æœ", "é¦™è•‰", "æ©˜å­"}
    
    // å¤šå€‹æ¶ˆè²»è€…
    for i := 0; i &lt; 3; i++ {
        go func(id int) {
            mu.Lock()
            defer mu.Unlock()
            
            for len(items) == 0 {
                fmt.Printf("æ¶ˆè²»è€… %d ç­‰å¾…ä¸­...\n", id)
                cond.Wait()
            }
            
            if len(items) &gt; 0 {
                item := items[0]
                items = items[1:]
                fmt.Printf("æ¶ˆè²»è€… %d å–å¾—: %s\n", id, item)
            }
        }(i)
    }
    
    time.Sleep(1 * time.Second)
    
    // å–šé†’æ‰€æœ‰ç­‰å¾…è€…
    mu.Lock()
    fmt.Println("ç”Ÿç”¢è€…æº–å‚™å–šé†’æ‰€æœ‰æ¶ˆè²»è€…")
    cond.Broadcast()
    mu.Unlock()
    
    time.Sleep(1 * time.Second)
}
</code></pre>
<hr />
<h2 id="atomic-åŸå­æ“ä½œ-"><a class="header" href="#atomic-åŸå­æ“ä½œ-">Atomic åŸå­æ“ä½œ âš›ï¸</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åŸå­æ“ä½œåƒä¸å¯åˆ†å‰²çš„å‹•ä½œï¼Œè¦å˜›å…¨åšå®Œï¼Œè¦å˜›ä¸åš</p>
<h3 id="åŸºæœ¬åŸå­æ“ä½œ"><a class="header" href="#åŸºæœ¬åŸå­æ“ä½œ">åŸºæœ¬åŸå­æ“ä½œ</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

func basicAtomicExample() {
    var counter int64
    var wg sync.WaitGroup
    
    // å•Ÿå‹•å¤šå€‹ goroutine é€²è¡ŒåŸå­å¢åŠ 
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j &lt; 1000; j++ {
                atomic.AddInt64(&amp;counter, 1)
            }
            fmt.Printf("Goroutine %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait()
    
    fmt.Printf("æœ€çµ‚è¨ˆæ•¸: %d\n", atomic.LoadInt64(&amp;counter))
}

// åŸå­æ¨™èªŒç¯„ä¾‹
func atomicFlagExample() {
    var running int32 = 1
    var wg sync.WaitGroup
    
    // å·¥ä½œ goroutine
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        for atomic.LoadInt32(&amp;running) == 1 {
            fmt.Println("å·¥ä½œä¸­...")
            time.Sleep(500 * time.Millisecond)
        }
        fmt.Println("å·¥ä½œçµæŸ")
    }()
    
    // ä¸»åŸ·è¡Œç·’ç­‰å¾…å¾Œåœæ­¢
    time.Sleep(3 * time.Second)
    atomic.StoreInt32(&amp;running, 0)
    
    wg.Wait()
}
</code></pre>
<h3 id="compare-and-swap-cas-æ“ä½œ"><a class="header" href="#compare-and-swap-cas-æ“ä½œ">Compare-And-Swap (CAS) æ“ä½œ</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
    "unsafe"
)

func casExample() {
    var value int64 = 10
    var wg sync.WaitGroup
    
    // å¤šå€‹ goroutine å˜—è©¦å°‡å€¼ç¿»å€
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for {
                oldValue := atomic.LoadInt64(&amp;value)
                newValue := oldValue * 2
                
                if atomic.CompareAndSwapInt64(&amp;value, oldValue, newValue) {
                    fmt.Printf("Goroutine %d æˆåŠŸå°‡ %d æ›´æ–°ç‚º %d\n", 
                        id, oldValue, newValue)
                    break
                } else {
                    fmt.Printf("Goroutine %d CAS å¤±æ•—ï¼Œé‡è©¦...\n", id)
                    time.Sleep(1 * time.Millisecond)
                }
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("æœ€çµ‚å€¼: %d\n", atomic.LoadInt64(&amp;value))
}

// ç„¡é–å †ç–Šå¯¦ç¾
type LockFreeStack struct {
    head unsafe.Pointer
}

type node struct {
    data int
    next unsafe.Pointer
}

func (s *LockFreeStack) Push(data int) {
    newNode := &amp;node{data: data}
    
    for {
        oldHead := atomic.LoadPointer(&amp;s.head)
        newNode.next = oldHead
        
        if atomic.CompareAndSwapPointer(&amp;s.head, oldHead, unsafe.Pointer(newNode)) {
            break
        }
    }
}

func (s *LockFreeStack) Pop() (int, bool) {
    for {
        oldHead := atomic.LoadPointer(&amp;s.head)
        if oldHead == nil {
            return 0, false
        }
        
        oldNode := (*node)(oldHead)
        newHead := atomic.LoadPointer(&amp;oldNode.next)
        
        if atomic.CompareAndSwapPointer(&amp;s.head, oldHead, newHead) {
            return oldNode.data, true
        }
    }
}
</code></pre>
<h3 id="åŸå­å€¼-atomicvalue"><a class="header" href="#åŸå­å€¼-atomicvalue">åŸå­å€¼ (atomic.Value)</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

type Config struct {
    Host string
    Port int
}

func atomicValueExample() {
    var config atomic.Value
    
    // åˆå§‹é…ç½®
    config.Store(Config{Host: "localhost", Port: 8080})
    
    var wg sync.WaitGroup
    
    // å¤šå€‹è®€è€…
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j &lt; 5; j++ {
                cfg := config.Load().(Config)
                fmt.Printf("è®€è€… %d: %s:%d\n", id, cfg.Host, cfg.Port)
                time.Sleep(200 * time.Millisecond)
            }
        }(i)
    }
    
    // å¯«è€…
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        time.Sleep(1 * time.Second)
        config.Store(Config{Host: "production", Port: 9090})
        fmt.Println("é…ç½®å·²æ›´æ–°")
        
        time.Sleep(1 * time.Second)
        config.Store(Config{Host: "backup", Port: 7070})
        fmt.Println("é…ç½®å†æ¬¡æ›´æ–°")
    }()
    
    wg.Wait()
}
</code></pre>
<hr />
<h2 id="context-ä¸Šä¸‹æ–‡-"><a class="header" href="#context-ä¸Šä¸‹æ–‡-">Context ä¸Šä¸‹æ–‡ ğŸ¯</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: Context åƒæ§åˆ¶å™¨ï¼Œå¯ä»¥å–æ¶ˆæ“ä½œã€è¨­å®šè¶…æ™‚ã€å‚³éå€¼</p>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

// åŸºæœ¬è¶…æ™‚æ§åˆ¶
func contextTimeoutExample() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    go func() {
        select {
        case &lt;-time.After(3 * time.Second):
            fmt.Println("å·¥ä½œå®Œæˆ")
        case &lt;-ctx.Done():
            fmt.Printf("å·¥ä½œè¢«å–æ¶ˆ: %v\n", ctx.Err())
        }
    }()
    
    &lt;-ctx.Done()
    fmt.Println("ä¸»ç¨‹å¼çµæŸ")
}

// æ‰‹å‹•å–æ¶ˆ
func contextCancelExample() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go func() {
        for {
            select {
            case &lt;-ctx.Done():
                fmt.Printf("å·¥ä½œè¢«å–æ¶ˆ: %v\n", ctx.Err())
                return
            default:
                fmt.Println("å·¥ä½œé€²è¡Œä¸­...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
    
    time.Sleep(2 * time.Second)
    fmt.Println("ç™¼é€å–æ¶ˆä¿¡è™Ÿ")
    cancel()
    
    time.Sleep(1 * time.Second)
}

// å€¼å‚³é
func contextValueExample() {
    type key string
    
    ctx := context.WithValue(context.Background(), key("userID"), "12345")
    ctx = context.WithValue(ctx, key("requestID"), "req-789")
    
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    userID := ctx.Value("userID")
    requestID := ctx.Value("requestID")
    
    fmt.Printf("è™•ç†è«‹æ±‚ - ç”¨æˆ¶ID: %v, è«‹æ±‚ID: %v\n", userID, requestID)
    
    // å‚³éçµ¦ä¸‹å±¤å‡½æ•¸
    handleDatabase(ctx)
}

func handleDatabase(ctx context.Context) {
    userID := ctx.Value("userID")
    fmt.Printf("è³‡æ–™åº«æ“ä½œ - ç”¨æˆ¶ID: %v\n", userID)
}

// éˆå¼å–æ¶ˆ
func contextChainExample() {
    // æ ¹ä¸Šä¸‹æ–‡ï¼Œ10ç§’è¶…æ™‚
    parentCtx, parentCancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer parentCancel()
    
    // å­ä¸Šä¸‹æ–‡ï¼Œ5ç§’è¶…æ™‚
    childCtx, childCancel := context.WithTimeout(parentCtx, 5*time.Second)
    defer childCancel()
    
    // å­«ä¸Šä¸‹æ–‡ï¼Œæ‰‹å‹•å–æ¶ˆ
    grandChildCtx, grandChildCancel := context.WithCancel(childCtx)
    defer grandChildCancel()
    
    go func() {
        select {
        case &lt;-grandChildCtx.Done():
            fmt.Printf("å­«ä¸Šä¸‹æ–‡çµæŸ: %v\n", grandChildCtx.Err())
        }
    }()
    
    // 2ç§’å¾Œæ‰‹å‹•å–æ¶ˆå­«ä¸Šä¸‹æ–‡
    time.Sleep(2 * time.Second)
    grandChildCancel()
    
    time.Sleep(1 * time.Second)
}
</code></pre>
<h3 id="http-æœå‹™å™¨ç¯„ä¾‹"><a class="header" href="#http-æœå‹™å™¨ç¯„ä¾‹">HTTP æœå‹™å™¨ç¯„ä¾‹</a></h3>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

func httpServerExample() {
    http.HandleFunc("/long-task", longTaskHandler)
    
    server := &amp;http.Server{
        Addr:    ":8080",
        Handler: nil,
    }
    
    go func() {
        fmt.Println("æœå‹™å™¨å•Ÿå‹•åœ¨ :8080")
        if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed {
            fmt.Printf("æœå‹™å™¨éŒ¯èª¤: %v\n", err)
        }
    }()
    
    // æ¨¡æ“¬é‹è¡Œ10ç§’å¾Œé—œé–‰
    time.Sleep(10 * time.Second)
    
    shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer shutdownCancel()
    
    if err := server.Shutdown(shutdownCtx); err != nil {
        fmt.Printf("æœå‹™å™¨é—œé–‰éŒ¯èª¤: %v\n", err)
    } else {
        fmt.Println("æœå‹™å™¨å„ªé›…é—œé–‰")
    }
}

func longTaskHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // æ¨¡æ“¬é•·æ™‚é–“ä»»å‹™
    select {
    case &lt;-time.After(8 * time.Second):
        fmt.Fprintf(w, "ä»»å‹™å®Œæˆ")
    case &lt;-ctx.Done():
        fmt.Printf("è«‹æ±‚è¢«å–æ¶ˆ: %v\n", ctx.Err())
        http.Error(w, "è«‹æ±‚è¢«å–æ¶ˆ", http.StatusRequestTimeout)
    }
}
</code></pre>
<hr />
<h2 id="é«˜ç´šä¸¦è¡Œæ¨¡å¼-"><a class="header" href="#é«˜ç´šä¸¦è¡Œæ¨¡å¼-">é«˜ç´šä¸¦è¡Œæ¨¡å¼ ğŸš€</a></h2>
<h3 id="worker-pool-æ¨¡å¼"><a class="header" href="#worker-pool-æ¨¡å¼">Worker Pool æ¨¡å¼</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type WorkerPool struct {
    workerCount int
    jobs        chan Job
    results     chan Result
    wg          sync.WaitGroup
}

type Job struct {
    ID   int
    Data interface{}
}

type Result struct {
    Job    Job
    Output interface{}
    Error  error
}

func NewWorkerPool(workerCount int) *WorkerPool {
    return &amp;WorkerPool{
        workerCount: workerCount,
        jobs:        make(chan Job, workerCount*2),
        results:     make(chan Result, workerCount*2),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i &lt; wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for job := range wp.jobs {
        fmt.Printf("å·¥ä½œè€… %d è™•ç†ä»»å‹™ %d\n", id, job.ID)
        
        // æ¨¡æ“¬è™•ç†æ™‚é–“
        time.Sleep(time.Duration(job.ID%3+1) * 500 * time.Millisecond)
        
        result := Result{
            Job:    job,
            Output: fmt.Sprintf("ä»»å‹™ %d çš„çµæœ", job.ID),
            Error:  nil,
        }
        
        wp.results &lt;- result
    }
    
    fmt.Printf("å·¥ä½œè€… %d çµæŸ\n", id)
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs &lt;- job
}

func (wp *WorkerPool) Stop() {
    close(wp.jobs)
    wp.wg.Wait()
    close(wp.results)
}

func (wp *WorkerPool) Results() &lt;-chan Result {
    return wp.results
}

func workerPoolExample() {
    pool := NewWorkerPool(3)
    pool.Start()
    
    // æäº¤ä»»å‹™
    go func() {
        for i := 1; i &lt;= 10; i++ {
            pool.Submit(Job{ID: i, Data: fmt.Sprintf("data-%d", i)})
        }
        pool.Stop()
    }()
    
    // æ”¶é›†çµæœ
    for result := range pool.Results() {
        if result.Error != nil {
            fmt.Printf("ä»»å‹™ %d å¤±æ•—: %v\n", result.Job.ID, result.Error)
        } else {
            fmt.Printf("æ”¶åˆ°çµæœ: %v\n", result.Output)
        }
    }
}
</code></pre>
<h3 id="pipeline-ç®¡é“æ¨¡å¼"><a class="header" href="#pipeline-ç®¡é“æ¨¡å¼">Pipeline ç®¡é“æ¨¡å¼</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

// éšæ®µ1: æ•¸å­—ç”Ÿæˆå™¨
func numberGenerator(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out &lt;- n
        }
        close(out)
    }()
    return out
}

// éšæ®µ2: å¹³æ–¹è¨ˆç®—
func square(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out &lt;- n * n
        }
        close(out)
    }()
    return out
}

// éšæ®µ3: çµæœæ”¶é›†
func collect(in &lt;-chan int) []int {
    var results []int
    for n := range in {
        results = append(results, n)
    }
    return results
}

func pipelineExample() {
    // å»ºç«‹ç®¡é“
    numbers := numberGenerator(1, 2, 3, 4, 5)
    squares := square(numbers)
    results := collect(squares)
    
    fmt.Printf("çµæœ: %v\n", results)
}

// æ‰‡å‡º-æ‰‡å…¥æ¨¡å¼
func fanOutFanInExample() {
    numbers := numberGenerator(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // æ‰‡å‡º: å¤šå€‹å·¥ä½œè€…è™•ç†
    worker1 := square(numbers)
    worker2 := square(numbers)
    worker3 := square(numbers)
    
    // æ‰‡å…¥: åˆä½µçµæœ
    merged := fanIn(worker1, worker2, worker3)
    
    // æ”¶é›†çµæœ
    for result := range merged {
        fmt.Printf("çµæœ: %d\n", result)
    }
}

func fanIn(channels ...&lt;-chan int) &lt;-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    // ç‚ºæ¯å€‹è¼¸å…¥é€šé“å•Ÿå‹•ä¸€å€‹ goroutine
    multiplex := func(c &lt;-chan int) {
        for n := range c {
            out &lt;- n
        }
        wg.Done()
    }
    
    wg.Add(len(channels))
    for _, c := range channels {
        go multiplex(c)
    }
    
    // ç­‰å¾…æ‰€æœ‰è¼¸å…¥å®Œæˆå¾Œé—œé–‰è¼¸å‡ºé€šé“
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
</code></pre>
<h3 id="publish-subscribe-æ¨¡å¼"><a class="header" href="#publish-subscribe-æ¨¡å¼">Publish-Subscribe æ¨¡å¼</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type PubSub struct {
    mu          sync.RWMutex
    subscribers map[string][]chan interface{}
}

func NewPubSub() *PubSub {
    return &amp;PubSub{
        subscribers: make(map[string][]chan interface{}),
    }
}

func (ps *PubSub) Subscribe(topic string) &lt;-chan interface{} {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan interface{}, 1)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    
    return ch
}

func (ps *PubSub) Publish(topic string, data interface{}) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    for _, ch := range ps.subscribers[topic] {
        select {
        case ch &lt;- data:
        default:
            // éé˜»å¡ç™¼é€ï¼Œé¿å…æ…¢æ¶ˆè²»è€…é˜»å¡ç™¼å¸ƒè€…
        }
    }
}

func (ps *PubSub) Unsubscribe(topic string, ch &lt;-chan interface{}) {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    subs := ps.subscribers[topic]
    for i, subscriber := range subs {
        if subscriber == ch {
            ps.subscribers[topic] = append(subs[:i], subs[i+1:]...)
            close(subscriber)
            break
        }
    }
}

func pubSubExample() {
    ps := NewPubSub()
    
    // è¨‚é–±è€…1
    news := ps.Subscribe("news")
    go func() {
        for msg := range news {
            fmt.Printf("æ–°èè¨‚é–±è€…æ”¶åˆ°: %v\n", msg)
        }
    }()
    
    // è¨‚é–±è€…2
    sports := ps.Subscribe("sports")
    go func() {
        for msg := range sports {
            fmt.Printf("é«”è‚²è¨‚é–±è€…æ”¶åˆ°: %v\n", msg)
        }
    }()
    
    // è¨‚é–±è€…3 (ä¹Ÿè¨‚é–±æ–°è)
    news2 := ps.Subscribe("news")
    go func() {
        for msg := range news2 {
            fmt.Printf("æ–°èè¨‚é–±è€…2æ”¶åˆ°: %v\n", msg)
        }
    }()
    
    // ç™¼å¸ƒè¨Šæ¯
    time.Sleep(100 * time.Millisecond)
    
    ps.Publish("news", "é‡è¦æ–°èï¼šGo 1.22 ç™¼å¸ƒ")
    ps.Publish("sports", "è¶³çƒè³½äº‹ï¼šå°ç£ vs æ—¥æœ¬")
    ps.Publish("news", "ç§‘æŠ€æ–°èï¼šAI æ–°çªç ´")
    
    time.Sleep(1 * time.Second)
}
</code></pre>
<h3 id="é™åˆ¶å™¨-rate-limiter"><a class="header" href="#é™åˆ¶å™¨-rate-limiter">é™åˆ¶å™¨ (Rate Limiter)</a></h3>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type RateLimiter struct {
    tokens chan struct{}
    ticker *time.Ticker
    done   chan struct{}
}

func NewRateLimiter(rate int, capacity int) *RateLimiter {
    rl := &amp;RateLimiter{
        tokens: make(chan struct{}, capacity),
        ticker: time.NewTicker(time.Second / time.Duration(rate)),
        done:   make(chan struct{}),
    }
    
    // åˆå§‹å¡«æ»¿ä»¤ç‰Œæ¡¶
    for i := 0; i &lt; capacity; i++ {
        rl.tokens &lt;- struct{}{}
    }
    
    // å®šæœŸæ·»åŠ ä»¤ç‰Œ
    go func() {
        for {
            select {
            case &lt;-rl.ticker.C:
                select {
                case rl.tokens &lt;- struct{}{}:
                default:
                    // æ¡¶å·²æ»¿ï¼Œä¸Ÿæ£„ä»¤ç‰Œ
                }
            case &lt;-rl.done:
                return
            }
        }
    }()
    
    return rl
}

func (rl *RateLimiter) Allow() bool {
    select {
    case &lt;-rl.tokens:
        return true
    default:
        return false
    }
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    select {
    case &lt;-rl.tokens:
        return nil
    case &lt;-ctx.Done():
        return ctx.Err()
    }
}

func (rl *RateLimiter) Stop() {
    rl.ticker.Stop()
    close(rl.done)
}

func rateLimiterExample() {
    limiter := NewRateLimiter(2, 5) // æ¯ç§’2å€‹è«‹æ±‚ï¼Œå®¹é‡5
    defer limiter.Stop()
    
    var wg sync.WaitGroup
    
    // æ¨¡æ“¬10å€‹ä¸¦ç™¼è«‹æ±‚
    for i := 1; i &lt;= 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
            defer cancel()
            
            start := time.Now()
            if err := limiter.Wait(ctx); err != nil {
                fmt.Printf("è«‹æ±‚ %d è¶…æ™‚: %v\n", id, err)
                return
            }
            
            fmt.Printf("è«‹æ±‚ %d é€šéï¼Œç­‰å¾…æ™‚é–“: %v\n", id, time.Since(start))
        }(i)
    }
    
    wg.Wait()
}
</code></pre>
<hr />
<h2 id="é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸-"><a class="header" href="#é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸-">é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸ ğŸ¯</a></h2>
<h3 id="å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹"><a class="header" href="#å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹">å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹</a></h3>
<pre><code class="language-go">/*
Go ä¸¦è¡ŒåŸèªé¸æ“‡æŒ‡å—ï¼š

1. éœ€è¦ä¸¦è¡ŒåŸ·è¡Œå—ï¼Ÿ
   â””â”€ å¦ â†’ é †åºåŸ·è¡Œ
   â””â”€ æ˜¯ â†’ ç¹¼çºŒ

2. åŸ·è¡Œç·’é–“éœ€è¦é€šè¨Šå—ï¼Ÿ
   â”œâ”€ éœ€è¦ â†’ Channel (æ¨è–¦)
   â”‚   â”œâ”€ ä¸€å°ä¸€ â†’ ç„¡ç·©è¡ Channel
   â”‚   â”œâ”€ ä¸€å°å¤š â†’ ç·©è¡ Channel
   â”‚   â”œâ”€ å¤šå°ä¸€ â†’ å·¥ä½œè€…æ± 
   â”‚   â””â”€ è¤‡é›œè·¯ç”± â†’ Select + å¤š Channel
   â””â”€ ä¸éœ€è¦ â†’ ç¹¼çºŒ

3. éœ€è¦å…±äº«ç‹€æ…‹å—ï¼Ÿ
   â”œâ”€ ç°¡å–®è¨ˆæ•¸/æ¨™èªŒ â†’ Atomic
   â”œâ”€ è¤‡é›œè³‡æ–™çµæ§‹ â†’ Mutex/RWMutex
   â”‚   â”œâ”€ å¤šè®€å°‘å¯« â†’ RWMutex
   â”‚   â””â”€ è®€å¯«å¹³è¡¡ â†’ Mutex
   â””â”€ ä¸éœ€è¦ â†’ Goroutine + WaitGroup

4. éœ€è¦å–æ¶ˆ/è¶…æ™‚å—ï¼Ÿ
   â””â”€ æ˜¯ â†’ Context

5. éœ€è¦åŒæ­¥ç­‰å¾…å—ï¼Ÿ
   â”œâ”€ ç­‰å¾…å¤šå€‹ä»»å‹™å®Œæˆ â†’ WaitGroup
   â”œâ”€ å–®æ¬¡åˆå§‹åŒ– â†’ Once
   â””â”€ æ¢ä»¶ç­‰å¾… â†’ Cond

è¨˜ä½ï¼šå„ªå…ˆä½¿ç”¨ Channelï¼Œå®ƒæ˜¯ Go çš„æ ¸å¿ƒè¨­è¨ˆç†å¿µ
*/
</code></pre>
<h3 id="æ•ˆèƒ½å°æ¯”è¡¨"><a class="header" href="#æ•ˆèƒ½å°æ¯”è¡¨">æ•ˆèƒ½å°æ¯”è¡¨</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒæ­¥åŸèª</th><th>å»¶é²</th><th>ååé‡</th><th>è¨˜æ†¶é«”ä½¿ç”¨</th><th>è¤‡é›œåº¦</th><th>é©ç”¨å ´æ™¯</th></tr></thead><tbody>
<tr><td><code>Goroutine</code></td><td>ğŸŸ¢ æ¥µä½</td><td>ğŸŸ¢ æ¥µé«˜</td><td>ğŸŸ¢ æ¥µå°</td><td>ğŸŸ¢ ç°¡å–®</td><td>ä¸¦è¡Œä»»å‹™</td></tr>
<tr><td><code>Channel</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ é«˜</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ ç°¡å–®</td><td>åŸ·è¡Œç·’é€šè¨Š</td></tr>
<tr><td><code>sync/atomic</code></td><td>ğŸŸ¢ æ¥µä½</td><td>ğŸŸ¢ æ¥µé«˜</td><td>ğŸŸ¢ æ¥µå°</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>åŸå­æ“ä½œ</td></tr>
<tr><td><code>RWMutex</code> (è®€)</td><td>ğŸŸ¢ ä½</td><td>ğŸŸ¢ é«˜</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>å¤šè®€å°‘å¯«</td></tr>
<tr><td><code>Mutex</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ ç°¡å–®</td><td>åŸºæœ¬äº’æ–¥</td></tr>
<tr><td><code>WaitGroup</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>N/A</td><td>ğŸŸ¢ å°</td><td>ğŸŸ¢ ç°¡å–®</td><td>åŒæ­¥ç­‰å¾…</td></tr>
<tr><td><code>Context</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>N/A</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>å–æ¶ˆæ§åˆ¶</td></tr>
</tbody></table>
</div>
<h3 id="æœ€ä½³å¯¦è¸æŒ‡å—"><a class="header" href="#æœ€ä½³å¯¦è¸æŒ‡å—">æœ€ä½³å¯¦è¸æŒ‡å—</a></h3>
<h4 id="1-goroutine-ç®¡ç†"><a class="header" href="#1-goroutine-ç®¡ç†">1. Goroutine ç®¡ç†</a></h4>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// âœ… å¥½çš„æ¨¡å¼ï¼šæ˜ç¢ºçš„ç”Ÿå‘½é€±æœŸç®¡ç†
func goodGoroutineManagement() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    var wg sync.WaitGroup
    
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            worker(ctx, id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰å·¥ä½œè€…å®Œæˆ")
}

func worker(ctx context.Context, id int) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Printf("å·¥ä½œè€… %d æ”¶åˆ°å–æ¶ˆä¿¡è™Ÿ\n", id)
            return
        case &lt;-time.After(500 * time.Millisecond):
            fmt.Printf("å·¥ä½œè€… %d å·¥ä½œä¸­\n", id)
        }
    }
}

// âŒ é¿å…çš„æ¨¡å¼ï¼šæ´©æ¼ goroutine
func avoidGoroutineLeak() {
    ch := make(chan int)
    
    // é€™å€‹ goroutine å¯èƒ½æ°¸é ä¸æœƒçµæŸ
    go func() {
        for {
            select {
            case n := &lt;-ch:
                fmt.Println(n)
            // ç¼ºå°‘é€€å‡ºæ¢ä»¶ï¼
            }
        }
    }()
    
    // å¦‚æœæ²’æœ‰ç™¼é€è³‡æ–™ï¼Œgoroutine æœƒæ´©æ¼
}
</code></pre>
<h4 id="2-channel-æœ€ä½³å¯¦è¸"><a class="header" href="#2-channel-æœ€ä½³å¯¦è¸">2. Channel æœ€ä½³å¯¦è¸</a></h4>
<pre><code class="language-go">// âœ… å¥½çš„æ¨¡å¼ï¼šé©ç•¶çš„ Channel ç·©è¡
func goodChannelBuffering() {
    // ç„¡ç·©è¡ï¼šç”¨æ–¼åŒæ­¥
    sync := make(chan bool)
    
    go func() {
        // åšä¸€äº›å·¥ä½œ
        time.Sleep(1 * time.Second)
        sync &lt;- true // åŒæ­¥ä¿¡è™Ÿ
    }()
    
    &lt;-sync // ç­‰å¾…å®Œæˆ
    
    // æœ‰ç·©è¡ï¼šç”¨æ–¼è§£è€¦
    buffer := make(chan int, 10)
    
    // ç”Ÿç”¢è€…
    go func() {
        for i := 0; i &lt; 5; i++ {
            buffer &lt;- i
        }
        close(buffer)
    }()
    
    // æ¶ˆè²»è€…
    for val := range buffer {
        fmt.Println(val)
    }
}

// âœ… å¥½çš„æ¨¡å¼ï¼šChannel æ–¹å‘
func goodChannelDirection() {
    ch := make(chan int, 5)
    
    // åªèƒ½ç™¼é€
    go producer(ch)
    
    // åªèƒ½æ¥æ”¶
    consumer(ch)
}

func producer(ch chan&lt;- int) {
    for i := 0; i &lt; 5; i++ {
        ch &lt;- i
    }
    close(ch)
}

func consumer(ch &lt;-chan int) {
    for val := range ch {
        fmt.Printf("æ¶ˆè²»: %d\n", val)
    }
}
</code></pre>
<h4 id="3-éŒ¯èª¤è™•ç†"><a class="header" href="#3-éŒ¯èª¤è™•ç†">3. éŒ¯èª¤è™•ç†</a></h4>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

// å¼·å¥çš„éŒ¯èª¤è™•ç†
type WorkerResult struct {
    ID    int
    Data  interface{}
    Error error
}

func robustWorkerPattern() {
    jobs := make(chan int, 10)
    results := make(chan WorkerResult, 10)
    var wg sync.WaitGroup
    
    // å•Ÿå‹•å·¥ä½œè€…
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            defer func() {
                if r := recover(); r != nil {
                    results &lt;- WorkerResult{
                        ID:    workerID,
                        Error: fmt.Errorf("panic: %v", r),
                    }
                }
            }()
            
            for job := range jobs {
                result := processJob(workerID, job)
                results &lt;- result
            }
        }(i)
    }
    
    // ç™¼é€ä»»å‹™
    go func() {
        for i := 1; i &lt;= 10; i++ {
            jobs &lt;- i
        }
        close(jobs)
    }()
    
    // æ”¶é›†çµæœ
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // è™•ç†çµæœ
    for result := range results {
        if result.Error != nil {
            fmt.Printf("å·¥ä½œè€… %d éŒ¯èª¤: %v\n", result.ID, result.Error)
        } else {
            fmt.Printf("å·¥ä½œè€… %d å®Œæˆ: %v\n", result.ID, result.Data)
        }
    }
}

func processJob(workerID, job int) WorkerResult {
    // æ¨¡æ“¬å¯èƒ½å¤±æ•—çš„å·¥ä½œ
    if job%7 == 0 {
        return WorkerResult{
            ID:    workerID,
            Error: fmt.Errorf("ä»»å‹™ %d å¤±æ•—", job),
        }
    }
    
    time.Sleep(100 * time.Millisecond)
    return WorkerResult{
        ID:   workerID,
        Data: fmt.Sprintf("ä»»å‹™ %d å®Œæˆ", job),
    }
}
</code></pre>
<h4 id="4-æ•ˆèƒ½å„ªåŒ–æŠ€å·§"><a class="header" href="#4-æ•ˆèƒ½å„ªåŒ–æŠ€å·§">4. æ•ˆèƒ½å„ªåŒ–æŠ€å·§</a></h4>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
    "time"
)

// æ•ˆèƒ½ç›£æ§
type PerformanceMonitor struct {
    goroutineCount int64
    requestCount   int64
    errorCount     int64
}

func (pm *PerformanceMonitor) IncrementGoroutine() {
    atomic.AddInt64(&amp;pm.goroutineCount, 1)
}

func (pm *PerformanceMonitor) DecrementGoroutine() {
    atomic.AddInt64(&amp;pm.goroutineCount, -1)
}

func (pm *PerformanceMonitor) IncrementRequest() {
    atomic.AddInt64(&amp;pm.requestCount, 1)
}

func (pm *PerformanceMonitor) IncrementError() {
    atomic.AddInt64(&amp;pm.errorCount, 1)
}

func (pm *PerformanceMonitor) Report() {
    goroutines := atomic.LoadInt64(&amp;pm.goroutineCount)
    requests := atomic.LoadInt64(&amp;pm.requestCount)
    errors := atomic.LoadInt64(&amp;pm.errorCount)
    
    fmt.Printf("ğŸ“Š æ•ˆèƒ½å ±å‘Š:\n")
    fmt.Printf("  æ´»èº Goroutine: %d\n", goroutines)
    fmt.Printf("  ç³»çµ± Goroutine: %d\n", runtime.NumGoroutine())
    fmt.Printf("  è™•ç†è«‹æ±‚æ•¸: %d\n", requests)
    fmt.Printf("  éŒ¯èª¤æ•¸: %d\n", errors)
    if requests &gt; 0 {
        fmt.Printf("  éŒ¯èª¤ç‡: %.2f%%\n", float64(errors)/float64(requests)*100)
    }
}

// è‡ªé©æ‡‰å·¥ä½œè€…æ± 
type AdaptiveWorkerPool struct {
    minWorkers int
    maxWorkers int
    current    int
    jobs       chan func()
    monitor    *PerformanceMonitor
    mu         sync.Mutex
}

func NewAdaptiveWorkerPool(min, max int) *AdaptiveWorkerPool {
    pool := &amp;AdaptiveWorkerPool{
        minWorkers: min,
        maxWorkers: max,
        current:    min,
        jobs:       make(chan func(), max*2),
        monitor:    &amp;PerformanceMonitor{},
    }
    
    // å•Ÿå‹•æœ€å°å·¥ä½œè€…æ•¸é‡
    for i := 0; i &lt; min; i++ {
        go pool.worker()
    }
    
    // å®šæœŸèª¿æ•´å·¥ä½œè€…æ•¸é‡
    go pool.autoScale()
    
    return pool
}

func (pool *AdaptiveWorkerPool) worker() {
    pool.monitor.IncrementGoroutine()
    defer pool.monitor.DecrementGoroutine()
    
    for job := range pool.jobs {
        job()
        pool.monitor.IncrementRequest()
    }
}

func (pool *AdaptiveWorkerPool) Submit(job func()) {
    pool.jobs &lt;- job
}

func (pool *AdaptiveWorkerPool) autoScale() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        pool.mu.Lock()
        queueLen := len(pool.jobs)
        
        // å¦‚æœéšŠåˆ—ç©å£“å¤ªå¤šï¼Œå¢åŠ å·¥ä½œè€…
        if queueLen &gt; pool.current &amp;&amp; pool.current &lt; pool.maxWorkers {
            pool.current++
            go pool.worker()
            fmt.Printf("æ“´å±•å·¥ä½œè€…æ± åˆ° %d\n", pool.current)
        }
        
        // å¦‚æœéšŠåˆ—ç©ºé–’ï¼Œæ¸›å°‘å·¥ä½œè€…ï¼ˆå¯¦éš›å¯¦ç¾æœƒæ›´è¤‡é›œï¼‰
        if queueLen == 0 &amp;&amp; pool.current &gt; pool.minWorkers {
            // é€™è£¡ç°¡åŒ–è™•ç†ï¼Œå¯¦éš›éœ€è¦å„ªé›…é—œé–‰å·¥ä½œè€…
            pool.current--
            fmt.Printf("ç¸®æ¸›å·¥ä½œè€…æ± åˆ° %d\n", pool.current)
        }
        
        pool.mu.Unlock()
        pool.monitor.Report()
    }
}
</code></pre>
<h3 id="é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§"><a class="header" href="#é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§">é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§</a></h3>
<h4 id="1-goroutine-æ´©æ¼æª¢æ¸¬"><a class="header" href="#1-goroutine-æ´©æ¼æª¢æ¸¬">1. Goroutine æ´©æ¼æª¢æ¸¬</a></h4>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "time"
)

func detectGoroutineLeak() {
    initial := runtime.NumGoroutine()
    fmt.Printf("åˆå§‹ Goroutine æ•¸é‡: %d\n", initial)
    
    // åŸ·è¡Œä¸€äº›å¯èƒ½æ´©æ¼çš„æ“ä½œ
    for i := 0; i &lt; 10; i++ {
        leakyFunction()
    }
    
    // ç­‰å¾…ä¸€æ®µæ™‚é–“è®“æ­£å¸¸çš„ goroutine çµæŸ
    time.Sleep(2 * time.Second)
    
    final := runtime.NumGoroutine()
    fmt.Printf("æœ€çµ‚ Goroutine æ•¸é‡: %d\n", final)
    
    if final &gt; initial {
        fmt.Printf("âš ï¸ å¯èƒ½å­˜åœ¨ Goroutine æ´©æ¼: %d å€‹\n", final-initial)
        
        // æ‰“å° goroutine å †ç–Š
        buf := make([]byte, 1&lt;&lt;16)
        stackSize := runtime.Stack(buf, true)
        fmt.Printf("Goroutine å †ç–Š:\n%s\n", buf[:stackSize])
    }
}

func leakyFunction() {
    ch := make(chan int)
    
    // é€™å€‹ goroutine æœƒæ´©æ¼ï¼Œå› ç‚ºæ²’æœ‰ç™¼é€è€…
    go func() {
        &lt;-ch // æ°¸é é˜»å¡
    }()
}
</code></pre>
<h4 id="2-æ­»é–æª¢æ¸¬"><a class="header" href="#2-æ­»é–æª¢æ¸¬">2. æ­»é–æª¢æ¸¬</a></h4>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func deadlockExample() {
    var mu1, mu2 sync.Mutex
    
    // Goroutine 1: å…ˆé– mu1ï¼Œå†é– mu2
    go func() {
        mu1.Lock()
        defer mu1.Unlock()
        
        time.Sleep(100 * time.Millisecond)
        
        mu2.Lock()
        defer mu2.Unlock()
        
        fmt.Println("Goroutine 1 å®Œæˆ")
    }()
    
    // Goroutine 2: å…ˆé– mu2ï¼Œå†é– mu1 (æ­»é–)
    go func() {
        mu2.Lock()
        defer mu2.Unlock()
        
        time.Sleep(100 * time.Millisecond)
        
        mu1.Lock()
        defer mu1.Unlock()
        
        fmt.Println("Goroutine 2 å®Œæˆ")
    }()
    
    time.Sleep(1 * time.Second)
    fmt.Println("å¯èƒ½ç™¼ç”Ÿæ­»é–")
}

// æ­»é–é é˜²ï¼šé–æ’åº
func preventDeadlock() {
    var mu1, mu2 sync.Mutex
    
    lockInOrder := func(first, second *sync.Mutex) {
        first.Lock()
        defer first.Unlock()
        
        second.Lock()
        defer second.Unlock()
    }
    
    // ç¸½æ˜¯æŒ‰ç…§ç›¸åŒé †åºç²å–é–
    go func() {
        lockInOrder(&amp;mu1, &amp;mu2)
        fmt.Println("Goroutine 1 å®Œæˆ")
    }()
    
    go func() {
        lockInOrder(&amp;mu1, &amp;mu2) // ç›¸åŒé †åº
        fmt.Println("Goroutine 2 å®Œæˆ")
    }()
    
    time.Sleep(1 * time.Second)
}
</code></pre>
<hr />
<h2 id="å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ-"><a class="header" href="#å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ-">å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ ğŸ“</a></h2>
<h3 id="å­¸ç¿’è·¯å¾‘å»ºè­°"><a class="header" href="#å­¸ç¿’è·¯å¾‘å»ºè­°">å­¸ç¿’è·¯å¾‘å»ºè­°</a></h3>
<pre><code>ğŸŒ± åˆå­¸è€… (0-2å€‹æœˆ):
â”œâ”€â”€ ç†è§£ Goroutine åŸºç¤
â”œâ”€â”€ æŒæ¡ Channel åŸºæœ¬ç”¨æ³•
â”œâ”€â”€ å­¸ç¿’ WaitGroup å’ŒåŸºæœ¬åŒæ­¥
â””â”€â”€ å¯¦ä½œç°¡å–®ä¸¦è¡Œç¨‹å¼

ğŸš€ ä¸­ç´šè€… (2-4å€‹æœˆ):
â”œâ”€â”€ æ·±å…¥ Select å’Œè¤‡é›œ Channel æ¨¡å¼
â”œâ”€â”€ æŒæ¡ Context çš„ä½¿ç”¨
â”œâ”€â”€ å­¸ç¿’ Mutex å’Œ Atomic æ“ä½œ
â””â”€â”€ å¯¦ä½œ Worker Pool ç­‰æ¨¡å¼

ğŸ¯ é«˜ç´šè€… (4å€‹æœˆä»¥ä¸Š):
â”œâ”€â”€ æŒæ¡é«˜ç´šä¸¦è¡Œæ¨¡å¼
â”œâ”€â”€ æ•ˆèƒ½èª¿å„ªå’Œç›£æ§
â”œâ”€â”€ è‡ªè¨‚åŒæ­¥åŸèª
â””â”€â”€ å¤§è¦æ¨¡ä¸¦è¡Œç³»çµ±è¨­è¨ˆ
</code></pre>
<h3 id="go-ä¸¦è¡Œç·¨ç¨‹çš„æ ¸å¿ƒç†å¿µ"><a class="header" href="#go-ä¸¦è¡Œç·¨ç¨‹çš„æ ¸å¿ƒç†å¿µ">Go ä¸¦è¡Œç·¨ç¨‹çš„æ ¸å¿ƒç†å¿µ</a></h3>
<p><strong>ğŸ’¡ è¨­è¨ˆå“²å­¸:</strong></p>
<blockquote>
<p>"Don't communicate by sharing memory; share memory by communicating."
ä¸è¦é€éå…±äº«è¨˜æ†¶é«”ä¾†é€šè¨Šï¼›è¦é€éé€šè¨Šä¾†å…±äº«è¨˜æ†¶é«”ã€‚</p>
</blockquote>
<p><strong>ğŸ¯ æ ¸å¿ƒåŸå‰‡:</strong></p>
<ol>
<li><strong>Goroutine å„ªå…ˆ</strong> - ä½¿ç”¨è¼•é‡ç´šå”ç¨‹è€Œéå‚³çµ±åŸ·è¡Œç·’</li>
<li><strong>Channel ç‚ºç‹</strong> - å„ªå…ˆä½¿ç”¨ Channel é€²è¡Œé€šè¨Š</li>
<li><strong>CSP æ¨¡å‹</strong> - åŸºæ–¼é€šè¨Šå¾ªåºç¨‹åºçš„ä¸¦è¡Œæ¨¡å‹</li>
<li><strong>çµ„åˆå‹éç¹¼æ‰¿</strong> - é€éä»‹é¢å’Œçµ„åˆæ§‹å»ºè¤‡é›œç³»çµ±</li>
</ol>
<p><strong>ğŸ› ï¸ æœ€ä½³å¯¦è¸ç¸½çµ:</strong></p>
<h4 id="ä½•æ™‚ä½¿ç”¨ä»€éº¼"><a class="header" href="#ä½•æ™‚ä½¿ç”¨ä»€éº¼">ä½•æ™‚ä½¿ç”¨ä»€éº¼ï¼š</a></h4>
<div class="table-wrapper"><table><thead><tr><th>å ´æ™¯</th><th>æ¨è–¦æ–¹æ¡ˆ</th><th>åŸå› </th></tr></thead><tbody>
<tr><td>ğŸ”„ <strong>åŸ·è¡Œç·’é–“é€šè¨Š</strong></td><td>Channel</td><td>Go çš„æ ¸å¿ƒè¨­è¨ˆ</td></tr>
<tr><td>ğŸƒ <strong>ä¸¦è¡Œä»»å‹™</strong></td><td>Goroutine + WaitGroup</td><td>è¼•é‡ä¸”é«˜æ•ˆ</td></tr>
<tr><td>ğŸ”’ <strong>å…±äº«ç‹€æ…‹ä¿è­·</strong></td><td>Mutex/RWMutex</td><td>ç•¶ Channel ä¸é©ç”¨æ™‚</td></tr>
<tr><td>âš›ï¸ <strong>ç°¡å–®åŸå­æ“ä½œ</strong></td><td>sync/atomic</td><td>æœ€é«˜æ•ˆèƒ½</td></tr>
<tr><td>â° <strong>è¶…æ™‚å’Œå–æ¶ˆ</strong></td><td>Context</td><td>æ¨™æº–åšæ³•</td></tr>
<tr><td>ğŸ¯ <strong>ä¸€æ¬¡æ€§åˆå§‹åŒ–</strong></td><td>sync.Once</td><td>åŸ·è¡Œç·’å®‰å…¨çš„å–®ä¾‹</td></tr>
<tr><td>ğŸ“Š <strong>æ•ˆèƒ½ç›£æ§</strong></td><td>pprof + è‡ªè¨‚ç›£æ§</td><td>å¯è§€æ¸¬æ€§</td></tr>
</tbody></table>
</div>
<h4 id="å¸¸è¦‹é™·é˜±èˆ‡è§£æ±ºæ–¹æ¡ˆ"><a class="header" href="#å¸¸è¦‹é™·é˜±èˆ‡è§£æ±ºæ–¹æ¡ˆ">å¸¸è¦‹é™·é˜±èˆ‡è§£æ±ºæ–¹æ¡ˆï¼š</a></h4>
<div class="table-wrapper"><table><thead><tr><th>å•é¡Œ</th><th>ç—‡ç‹€</th><th>è§£æ±ºæ–¹æ¡ˆ</th></tr></thead><tbody>
<tr><td><strong>Goroutine æ´©æ¼</strong></td><td>è¨˜æ†¶é«”æŒçºŒå¢é•·</td><td>ä½¿ç”¨ Context æ§åˆ¶ç”Ÿå‘½é€±æœŸ</td></tr>
<tr><td><strong>Channel æ­»é–</strong></td><td>ç¨‹å¼æ›èµ·</td><td>æª¢æŸ¥ Channel çš„ç™¼é€/æ¥æ”¶å¹³è¡¡</td></tr>
<tr><td><strong>ç«¶çˆ­æ¢ä»¶</strong></td><td>ä¸ä¸€è‡´çš„çµæœ</td><td>ä½¿ç”¨é©ç•¶çš„åŒæ­¥åŸèª</td></tr>
<tr><td><strong>éåº¦åŒæ­¥</strong></td><td>æ•ˆèƒ½ä½ä¸‹</td><td>é‡æ–°è¨­è¨ˆï¼Œæ¸›å°‘å…±äº«ç‹€æ…‹</td></tr>
</tbody></table>
</div>
<h4 id="æ•ˆèƒ½èª¿å„ªæŒ‡å—"><a class="header" href="#æ•ˆèƒ½èª¿å„ªæŒ‡å—">æ•ˆèƒ½èª¿å„ªæŒ‡å—ï¼š</a></h4>
<pre><code class="language-go">// æ•ˆèƒ½èª¿å„ªæª¢æŸ¥æ¸…å–®
func performanceTuning() {
    // 1. Goroutine æ•¸é‡æ§åˆ¶
    // - é¿å…ç„¡é™åˆ¶å»ºç«‹ Goroutine
    // - ä½¿ç”¨ Worker Pool æ¨¡å¼
    
    // 2. Channel ç·©è¡å„ªåŒ–
    // - æ ¹æ“šç”Ÿç”¢æ¶ˆè²»é€Ÿåº¦èª¿æ•´ç·©è¡å¤§å°
    // - é¿å…éå¤§çš„ç·©è¡å€å°è‡´è¨˜æ†¶é«”æµªè²»
    
    // 3. é–ç«¶çˆ­æœ€å°åŒ–
    // - ç¸®çŸ­è‡¨ç•Œå€
    // - ä½¿ç”¨ RWMutex å„ªåŒ–è®€å¤šå¯«å°‘å ´æ™¯
    // - è€ƒæ…®ç„¡é–è³‡æ–™çµæ§‹
    
    // 4. è¨˜æ†¶é«”åˆ†é…å„ªåŒ–
    // - é‡ç”¨ç‰©ä»¶ï¼Œæ¸›å°‘ GC å£“åŠ›
    // - ä½¿ç”¨ sync.Pool æ± åŒ–ç‰©ä»¶
    
    // 5. ç›£æ§å’Œè¨ºæ–·
    // - ä½¿ç”¨ pprof åˆ†ææ•ˆèƒ½
    // - ç›£æ§ Goroutine æ•¸é‡
    // - æª¢æ¸¬è¨˜æ†¶é«”æ´©æ¼
}
</code></pre>
<h3 id="é€²éšå­¸ç¿’è³‡æº"><a class="header" href="#é€²éšå­¸ç¿’è³‡æº">é€²éšå­¸ç¿’è³‡æº</a></h3>
<p><strong>ğŸ“š å¿…è®€è³‡æ–™:</strong></p>
<ul>
<li><a href="https://talks.golang.org/2012/concurrency.slide">Go Concurrency Patterns</a></li>
<li><a href="https://talks.golang.org/2013/advconc.slide">Advanced Go Concurrency Patterns</a></li>
<li><a href="https://golang.org/ref/mem">Go Memory Model</a></li>
</ul>
<p><strong>ğŸ”§ å¯¦ç”¨å·¥å…·:</strong></p>
<ul>
<li><code>go tool pprof</code> - æ•ˆèƒ½åˆ†æ</li>
<li><code>go test -race</code> - ç«¶çˆ­æ¢ä»¶æª¢æ¸¬</li>
<li><code>GODEBUG=schedtrace=1000</code> - æ’ç¨‹å™¨è¿½è¹¤</li>
</ul>
<p><strong>ğŸ¯ å¯¦æˆ°é …ç›®å»ºè­°:</strong></p>
<ol>
<li><strong>èŠå¤©ä¼ºæœå™¨</strong> - ç·´ç¿’ Channel å’Œ Goroutine</li>
<li><strong>çˆ¬èŸ²ç³»çµ±</strong> - ç·´ç¿’ Worker Pool å’Œé™æµ</li>
<li><strong>å¿«å–æœå‹™</strong> - ç·´ç¿’ RWMutex å’ŒåŸå­æ“ä½œ</li>
<li><strong>å¾®æœå‹™é–˜é“å™¨</strong> - ç·´ç¿’ Context å’Œè¶…æ™‚æ§åˆ¶</li>
</ol>
<h3 id="ç¸½çµ"><a class="header" href="#ç¸½çµ">ç¸½çµ</a></h3>
<p>Go çš„ä¸¦è¡Œæ¨¡å‹æ˜¯å…¶æœ€å¤§çš„ç‰¹è‰²ä¹‹ä¸€ï¼Œé€é Goroutine å’Œ Channel æä¾›äº†ä¸€ç¨®ç›´è§€ä¸”é«˜æ•ˆçš„ä¸¦è¡Œç¨‹å¼è¨­è¨ˆæ–¹å¼ã€‚è¨˜ä½ä»¥ä¸‹è¦é»ï¼š</p>
<p><strong>ğŸ¯ æ ¸å¿ƒè¨˜æ†¶é»:</strong></p>
<ul>
<li><strong>Goroutine è¼•é‡</strong> - å¯ä»¥è¼•é¬†å»ºç«‹æ•¸ç™¾è¬å€‹</li>
<li><strong>Channel å®‰å…¨</strong> - å‹åˆ¥å®‰å…¨çš„é€šè¨Šæ©Ÿåˆ¶</li>
<li><strong>Context æ§åˆ¶</strong> - å„ªé›…çš„å–æ¶ˆå’Œè¶…æ™‚è™•ç†</li>
<li><strong>çµ„åˆå„ªæ–¼ç¹¼æ‰¿</strong> - é€éä»‹é¢å’ŒåµŒå…¥æ§‹å»ºè¤‡é›œç³»çµ±</li>
</ul>
<p><strong>ğŸš€ é€²éšç™¼å±•:</strong>
éš¨è‘—ç¶“é©—ç´¯ç©ï¼Œä½ æœƒç™¼ç¾ Go çš„ä¸¦è¡Œæ¨¡å‹ä¸åƒ…ç°¡å–®æ˜“ç”¨ï¼Œæ›´èƒ½å¹«åŠ©ä½ æ§‹å»ºé«˜æ•ˆã€å¯ç¶­è­·çš„åˆ†æ•£å¼ç³»çµ±ã€‚å¾ç°¡å–®çš„ Goroutine é–‹å§‹ï¼Œé€æ­¥æŒæ¡è¤‡é›œçš„ä¸¦è¡Œæ¨¡å¼ï¼Œæœ€çµ‚èƒ½å¤ è¨­è¨ˆå‡ºå„ªé›…çš„é«˜ä¸¦è¡Œæ¶æ§‹ã€‚</p>
<p>Go çš„å“²å­¸æ˜¯ "ç°¡å–®è€Œå¼·å¤§"ï¼Œå…¶ä¸¦è¡Œæ©Ÿåˆ¶å®Œç¾é«”ç¾äº†é€™ä¸€é»ã€‚é€éæœ¬æŒ‡å—çš„å­¸ç¿’ï¼Œç›¸ä¿¡ä½ å·²ç¶“æŒæ¡äº† Go ä¸¦è¡Œç¨‹å¼è¨­è¨ˆçš„ç²¾é«“ï¼Œç¾åœ¨æ˜¯æ™‚å€™åœ¨å¯¦éš›é …ç›®ä¸­æ‡‰ç”¨é€™äº›çŸ¥è­˜äº†ï¼ğŸ¹âœ¨</p>
<hr />
<p><em>å®Œæ•´æŒ‡å—åˆ°æ­¤çµæŸã€‚è¨˜ä½ï¼šåœ¨ Go ä¸­ï¼Œä¸¦è¡Œä¸åƒ…æ˜¯ä¸€ç¨®æŠ€è¡“ï¼Œæ›´æ˜¯ä¸€ç¨®æ€ç¶­æ–¹å¼ã€‚äº«å— Go ä¸¦è¡Œç¨‹å¼è¨­è¨ˆçš„æ¨‚è¶£å§ï¼</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../go/mutex-rwmutex.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../go/go_mysql_deadlock_debug.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../go/mutex-rwmutex.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../go/go_mysql_deadlock_debug.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
