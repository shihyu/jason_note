<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go Runtime 完整指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-runtime-完整指南"><a class="header" href="#go-runtime-完整指南">Go Runtime 完整指南</a></h1>
<h2 id="什麼是-go-runtime"><a class="header" href="#什麼是-go-runtime">什麼是 Go Runtime？</a></h2>
<p>Go Runtime 是 Go 語言的執行時系統，負責在操作系統和用戶代碼之間進行交互。它是一個內嵌在每個 Go 程序中的系統層，提供語言運行所需的基礎設施。</p>
<h2 id="runtime-的核心組件"><a class="header" href="#runtime-的核心組件">Runtime 的核心組件</a></h2>
<h3 id="1-調度器scheduler"><a class="header" href="#1-調度器scheduler">1. 調度器（Scheduler）</a></h3>
<p><strong>目的</strong>：管理 goroutine 的執行，實現並發編程模型。</p>
<p><strong>三層模型（G-M-P）</strong>：</p>
<ul>
<li><strong>G（Goroutine）</strong>：輕量級線程，用戶創建的並發任務</li>
<li><strong>M（Machine）</strong>：映射到操作系統線程，執行實際代碼</li>
<li><strong>P（Processor）</strong>：邏輯處理器，每個 P 管理一個本地 goroutine 隊列</li>
</ul>
<p><strong>調度策略</strong>：</p>
<ul>
<li>Work-stealing 算法：空閒的 P 會從其他 P 的隊列中竊取任務</li>
<li>協作式調度：goroutine 在系統調用、IO 操作或明確讓出時觸發調度</li>
<li>搶佔式調度（1.14+）：定期檢查點強制調度</li>
</ul>
<pre><code>┌─────────────────────────────────────────────┐
│              Go 程序                         │
├─────────────────────────────────────────────┤
│  Go Code                                    │
│  ├─ go func1() ──┐                          │
│  ├─ go func2() ──┼─→ G (Goroutines)        │
│  └─ go func3() ──┘                          │
├─────────────────────────────────────────────┤
│  Scheduler                                  │
│  ├─ P0 [G1, G2, G3, ...]                   │
│  ├─ P1 [G4, G5, ...]                       │
│  └─ P2 [...]                               │
├─────────────────────────────────────────────┤
│  OS Threads (M)                             │
│  ├─ M0 ─→ 執行 P0 的 goroutine             │
│  ├─ M1 ─→ 執行 P1 的 goroutine             │
│  └─ M2 ─→ 執行 P2 的 goroutine             │
├─────────────────────────────────────────────┤
│  操作系統                                    │
└─────────────────────────────────────────────┘
</code></pre>
<h3 id="2-垃圾回收器garbage-collector"><a class="header" href="#2-垃圾回收器garbage-collector">2. 垃圾回收器（Garbage Collector）</a></h3>
<p><strong>目的</strong>：自動管理內存，回收不再使用的對象。</p>
<p><strong>特性</strong>：</p>
<ul>
<li>並發 GC：與用戶代碼並行運行，減少 STW（Stop The World）時間</li>
<li>三色標記法：黑、灰、白三種顏色追蹤對象狀態</li>
<li>寫屏障：記錄堆上對象的修改</li>
</ul>
<p><strong>GC 階段</strong>：</p>
<ol>
<li>Mark Setup - 啟用寫屏障</li>
<li>Marking - 並發標記活對象</li>
<li>Mark Termination - 完成標記（需要 STW）</li>
<li>Sweep - 並發清掃死對象</li>
</ol>
<h3 id="3-內存管理"><a class="header" href="#3-內存管理">3. 內存管理</a></h3>
<p><strong>堆（Heap）</strong>：</p>
<ul>
<li>用於分配動態內存</li>
<li>由 GC 管理</li>
</ul>
<p><strong>棧（Stack）</strong>：</p>
<ul>
<li>每個 goroutine 有自己的棧</li>
<li>棧空間自動增長（segmented stack）</li>
</ul>
<p><strong>內存分配器</strong>：</p>
<ul>
<li>基於 TCMalloc 設計</li>
<li>多層級結構：小對象、中對象、大對象的不同分配策略</li>
</ul>
<h3 id="4-系統調用和-io-操作"><a class="header" href="#4-系統調用和-io-操作">4. 系統調用和 IO 操作</a></h3>
<p><strong>網絡 IO</strong>：</p>
<ul>
<li>使用非阻塞 socket 和 epoll/kqueue/IOCP</li>
<li>Runtime 監控 IO 事件，自動喚醒相關 goroutine</li>
</ul>
<p><strong>文件 IO</strong>：</p>
<ul>
<li>包裝操作系統的文件 API</li>
<li>支持異步操作</li>
</ul>
<p><strong>特殊處理</strong>：</p>
<ul>
<li>當 M 執行阻塞系統調用時，會自動分配新 M 給 P</li>
<li>系統調用完成後，goroutine 回到隊列</li>
</ul>
<h3 id="5-channel-和同步原語"><a class="header" href="#5-channel-和同步原語">5. Channel 和同步原語</a></h3>
<p><strong>Channel</strong>：</p>
<ul>
<li>內置的消息傳遞機制</li>
<li>實現 goroutine 間的通信和同步</li>
</ul>
<p><strong>同步原語</strong>：</p>
<ul>
<li>Mutex</li>
<li>RWMutex</li>
<li>Cond</li>
<li>WaitGroup</li>
<li>Semaphore</li>
</ul>
<h3 id="6-panic-和-recover"><a class="header" href="#6-panic-和-recover">6. Panic 和 Recover</a></h3>
<p><strong>運行時異常處理</strong>：</p>
<ul>
<li>nil 指針解引用檢查</li>
<li>數組邊界檢查</li>
<li>類型斷言檢查</li>
<li>panic/recover 機制</li>
</ul>
<h2 id="runtime-的生命周期"><a class="header" href="#runtime-的生命周期">Runtime 的生命周期</a></h2>
<h3 id="程序啟動"><a class="header" href="#程序啟動">程序啟動</a></h3>
<pre><code>1. 操作系統加載可執行檔案
2. 執行引導代碼（bootstrap code）
3. 初始化 runtime
   - 初始化全局變量
   - 啟動 GC 工作線程
   - 初始化調度器
4. 執行 init() 函數
5. 執行 main() 函數
</code></pre>
<h3 id="程序運行"><a class="header" href="#程序運行">程序運行</a></h3>
<pre><code>Runtime 在後台運行：
├─ Scheduler：調度 goroutine 執行
├─ GC：定期掃描堆內存
├─ Signal handler：處理操作系統信號
└─ Timer：管理 time.Timer 和 time.Ticker
</code></pre>
<h3 id="程序退出"><a class="header" href="#程序退出">程序退出</a></h3>
<pre><code>1. main() 函數返回
2. defer 語句執行（逆序）
3. goroutine 逐個終止
4. GC 最後一次運行
5. 釋放所有資源
6. 進程退出
</code></pre>
<h2 id="關鍵數據結構"><a class="header" href="#關鍵數據結構">關鍵數據結構</a></h2>
<h3 id="ggoroutine結構體"><a class="header" href="#ggoroutine結構體">G（Goroutine）結構體</a></h3>
<pre><code class="language-go">type g struct {
    stack       stack           // goroutine 的棧空間
    stackguard0 uintptr         // 棧溢出檢查
    m           *m              // 關聯的 M
    goid        uint64          // goroutine ID
    waiting     *sudog          // 阻塞在 channel 或 lock 上
    waitreason  waitReason      // 等待原因
    status      uint32          // goroutine 狀態
    // ... 更多字段
}
</code></pre>
<p><strong>Goroutine 狀態</strong>：</p>
<ul>
<li>Gidle：未使用</li>
<li>Grunnable：等待運行</li>
<li>Grunning：正在運行</li>
<li>Gsyscall：執行系統調用</li>
<li>Gwaiting：阻塞（IO、channel、lock）</li>
<li>Gdead：已終止</li>
</ul>
<h3 id="mmachine結構體"><a class="header" href="#mmachine結構體">M（Machine）結構體</a></h3>
<pre><code class="language-go">type m struct {
    p           puintptr        // 關聯的 P
    curg        *g              // 當前執行的 G
    id          int64
    procid      uint64          // 操作系統線程 ID
    // ... 更多字段
}
</code></pre>
<h3 id="pprocessor結構體"><a class="header" href="#pprocessor結構體">P（Processor）結構體</a></h3>
<pre><code class="language-go">type p struct {
    id          int32
    runq        [256]guintptr   // 本地隊列
    runnext     guintptr        // 下一個要運行的 G
    // ... 更多字段
}
</code></pre>
<h2 id="重要的-runtime-函數"><a class="header" href="#重要的-runtime-函數">重要的 Runtime 函數</a></h2>
<h3 id="調度相關"><a class="header" href="#調度相關">調度相關</a></h3>
<pre><code class="language-go">runtime.Gosched()           // 讓出 CPU，允許其他 goroutine 運行
runtime.NumGoroutine()      // 獲取當前 goroutine 數量
runtime.GOMAXPROCS(n)       // 設置最大 P 數量
runtime.LockOSThread()      // 將當前 goroutine 綁定到 OS 線程
runtime.UnlockOSThread()    // 解除綁定
</code></pre>
<h3 id="gc-相關"><a class="header" href="#gc-相關">GC 相關</a></h3>
<pre><code class="language-go">runtime.GC()                // 手動觸發垃圾回收
runtime.ReadMemStats(m)     // 讀取內存統計信息
runtime.SetGCPercent(p)     // 設置 GC 觸發阈值
</code></pre>
<h3 id="debug-和分析"><a class="header" href="#debug-和分析">Debug 和分析</a></h3>
<pre><code class="language-go">runtime.Stack(buf, all)     // 獲取棧信息
runtime.Caller(skip)        // 獲取調用者信息
runtime.SetMutexProfileFraction(r)  // 設置 mutex 分析
</code></pre>
<h2 id="性能優化技巧"><a class="header" href="#性能優化技巧">性能優化技巧</a></h2>
<h3 id="1-調整-gomaxprocs"><a class="header" href="#1-調整-gomaxprocs">1. 調整 GOMAXPROCS</a></h3>
<pre><code class="language-go">import "runtime"

// 充分利用多核
runtime.GOMAXPROCS(runtime.NumCPU())
</code></pre>
<h3 id="2-減少-gc-壓力"><a class="header" href="#2-減少-gc-壓力">2. 減少 GC 壓力</a></h3>
<pre><code class="language-go">// 複用對象，減少分配
var buffer bytes.Buffer
buffer.WriteString("hello")
buffer.Reset()  // 復用 buffer

// 使用對象池
var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}
</code></pre>
<h3 id="3-避免頻繁的系統調用"><a class="header" href="#3-避免頻繁的系統調用">3. 避免頻繁的系統調用</a></h3>
<pre><code class="language-go">// 不好：每次都調用系統調用
for i := 0; i &lt; 1000; i++ {
    syscall.Write(fd, data)
}

// 好：批量操作
syscall.Write(fd, largeData)
</code></pre>
<h3 id="4-合理使用-goroutine"><a class="header" href="#4-合理使用-goroutine">4. 合理使用 goroutine</a></h3>
<pre><code class="language-go">// 不好：創建過多 goroutine
for i := 0; i &lt; 1000000; i++ {
    go doSomething()
}

// 好：使用 worker pool
const numWorkers = 100
for i := 0; i &lt; numWorkers; i++ {
    go worker(jobChan)
}
</code></pre>
<h2 id="runtime-的來源和形式"><a class="header" href="#runtime-的來源和形式">Runtime 的來源和形式</a></h2>
<p>在源碼層面，<strong>Go Runtime 是用 Go 和 C 混寫的代碼</strong>，存在 Go 標準庫的 <code>runtime</code> 包中。當你編譯 Go 程序時，Runtime 會被<strong>靜態連結進去</strong>，最終成為可執行檔案的一部分。</p>
<p><strong>Runtime 不是一個獨立的執行檔案</strong>，而是代碼和數據結構的集合，包括：</p>
<ul>
<li>調度器（Scheduler）</li>
<li>垃圾回收器（GC）</li>
<li>內存管理器</li>
<li>goroutine 管理</li>
<li>Channel 實現</li>
<li>同步原語實現</li>
<li>異常處理</li>
</ul>
<h2 id="runtime-和編譯器的關係"><a class="header" href="#runtime-和編譯器的關係">Runtime 和編譯器的關係</a></h2>
<h3 id="編譯器的職責"><a class="header" href="#編譯器的職責">編譯器的職責</a></h3>
<ul>
<li>將 Go 源碼編譯成機器碼</li>
<li>識別 <code>go</code> 語句，生成對 <code>runtime.newproc</code> 的調用</li>
<li>插入棧溢出檢查代碼</li>
<li>插入邊界檢查代碼</li>
</ul>
<h3 id="runtime-的職責"><a class="header" href="#runtime-的職責">Runtime 的職責</a></h3>
<ul>
<li>執行調度算法</li>
<li>管理內存和垃圾回收</li>
<li>處理並發原語（channel、mutex）</li>
<li>處理異常和恢復</li>
</ul>
<h2 id="編譯和連結的完整流程"><a class="header" href="#編譯和連結的完整流程">編譯和連結的完整流程</a></h2>
<h3 id="三個關鍵階段"><a class="header" href="#三個關鍵階段">三個關鍵階段</a></h3>
<pre><code>Go 源碼文件                    Runtime 源碼
    │                            │
    │  (runtime 包在標準庫中)     │
    │                            │
    └────────────┬───────────────┘
                 │
            ┌────▼──────────────────┐
            │   編譯器 (go build)    │
            │  - 編譯用戶代碼         │
            │  - 編譯 runtime 代碼    │
            │  - 生成目標文件         │
            └────┬──────────────────┘
                 │
            ┌────▼────────────────────────┐
            │   目標文件 (.o)             │
            │  - 用戶代碼的機器碼          │
            │  - Runtime 的機器碼          │
            │  - 標準庫的機器碼            │
            └────┬─────────────────────────┘
                 │
            ┌────▼──────────────────┐
            │   Linker（連結器）    │
            │  - 連結所有目標文件    │
            │  - 連結 runtime       │
            │  - 解析符號引用        │
            │  - 生成最終可執行檔案  │
            └────┬──────────────────┘
                 │
       ┌─────────▼──────────────────────────┐
       │   可執行檔案（自包含）              │
       │  ┌──────────────────────────────┐ │
       │  │ 用戶代碼的機器碼              │ │
       │  ├──────────────────────────────┤ │
       │  │ Go Runtime 的機器碼           │ │
       │  │ - Scheduler                   │ │
       │  │ - GC                          │ │
       │  │ - Memory Manager              │ │
       │  │ - goroutine 管理              │ │
       │  │ - Channel 實現                │ │
       │  ├──────────────────────────────┤ │
       │  │ 標準庫的機器碼                │ │
       │  │ (fmt, io, sync 等)            │ │
       │  ├──────────────────────────────┤ │
       │  │ 其他必要資源                  │ │
       │  └──────────────────────────────┘ │
       └────────────────────────────────────┘
</code></pre>
<h3 id="階段-1編譯go-build"><a class="header" href="#階段-1編譯go-build">階段 1：編譯（go build）</a></h3>
<p><strong>輸入</strong>：Go 源碼文件 + Runtime 源碼</p>
<p><strong>處理</strong>：</p>
<ul>
<li>編譯器分別編譯用戶代碼和 runtime 代碼</li>
<li>每個 Go 文件（<code>.go</code>）都被編譯成目標文件（<code>.o</code>）</li>
<li>Runtime 中的 C 代碼也被編譯成機器碼</li>
</ul>
<p><strong>輸出</strong>：多個目標文件，包含編譯後的機器碼</p>
<pre><code class="language-bash">$ go build myprogram.go

# 在編譯過程中，編譯器會：
# 1. 編譯 myprogram.go → myprogram.o
# 2. 編譯 runtime/*.go → runtime_*.o
# 3. 編譯 runtime/*.c → runtime_*.o
# 4. 編譯標準庫 → stdlib_*.o
</code></pre>
<h3 id="階段-2連結linker"><a class="header" href="#階段-2連結linker">階段 2：連結（Linker）</a></h3>
<p><strong>輸入</strong>：所有目標文件和庫文件</p>
<p><strong>處理</strong>：</p>
<ul>
<li>將所有 <code>.o</code> 文件中的代碼和數據合併</li>
<li>解析符號引用（Symbol Resolution）</li>
<li>重定位地址（Relocation）</li>
<li>創建可執行檔案頭部</li>
</ul>
<p><strong>輸出</strong>：單個可執行檔案</p>
<h3 id="階段-3結果---自包含的可執行檔案"><a class="header" href="#階段-3結果---自包含的可執行檔案">階段 3：結果 - 自包含的可執行檔案</a></h3>
<p>最終生成的可執行檔案包含：</p>
<ol>
<li><strong>用戶代碼</strong> - 你寫的所有函數和邏輯</li>
<li><strong>Go Runtime</strong> - 核心部分，包括：
<ul>
<li>Scheduler（調度器）</li>
<li>GC（垃圾回收器）</li>
<li>Memory Manager（內存管理）</li>
<li>goroutine 管理機制</li>
<li>Channel 實現</li>
</ul>
</li>
<li><strong>標準庫</strong> - fmt、io、sync 等所有依賴的包</li>
<li><strong>元數據和資源</strong> - 符號表、重定位信息等</li>
</ol>
<h3 id="為什麼是靜態連結"><a class="header" href="#為什麼是靜態連結">為什麼是靜態連結？</a></h3>
<p>Go 選擇靜態連結而不是動態連結的原因：</p>
<ol>
<li><strong>跨平台部署</strong>：生成的二進制可以直接在目標系統運行，不需要安裝依賴</li>
<li><strong>性能</strong>：避免動態連結的開銷，啟動更快</li>
<li><strong>簡化分發</strong>：只需分發一個檔案，使用者無需配置環境</li>
<li><strong>版本穩定性</strong>：不會因為系統庫版本不同而導致問題</li>
</ol>
<h3 id="驗證靜態連結"><a class="header" href="#驗證靜態連結">驗證靜態連結</a></h3>
<p>你可以用以下命令查看編譯結果：</p>
<pre><code class="language-bash"># 檢查檔案類型和依賴
$ file ./myprogram
./myprogram: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), 
statically linked, Go BuildID=...

# 查看動態依賴（如果有的話）
$ ldd ./myprogram
    not a dynamic executable

# 查看檔案大小（包含 runtime）
$ ls -lh ./myprogram
-rwxr-xr-x 1 user group 5.2M Nov 26 12:34 myprogram

# 檢查編譯時包含的 runtime 信息
$ strings ./myprogram | grep "runtime\." | head -20
</code></pre>
<h3 id="runtime-在編譯過程中的集成"><a class="header" href="#runtime-在編譯過程中的集成">Runtime 在編譯過程中的集成</a></h3>
<pre><code>┌────────────────────────────────────────────┐
│      編譯器看到的 Go 代碼                    │
├────────────────────────────────────────────┤
│                                            │
│  package main                              │
│                                            │
│  func main() {                             │
│      go doWork()  ◄── 識別 go 語句         │
│      time.Sleep(1 * time.Second)           │
│  }                                         │
│                                            │
│  func doWork() { ... }                     │
│                                            │
└────────────────────────────────────────────┘
                    │
                    │ 編譯器處理
                    │
                    ▼
┌────────────────────────────────────────────┐
│         生成的機器碼（偽代碼）              │
├────────────────────────────────────────────┤
│                                            │
│  main:                                     │
│      ... 初始化代碼 ...                    │
│      call runtime.newproc  ◄── 創建 G    │
│      ... sleep 代碼 ...                    │
│                                            │
│  doWork:                                   │
│      ... 函數體 ...                        │
│                                            │
│  runtime.newproc:       ◄── Runtime 代碼  │
│      ... scheduler 代碼 ...                │
│      ... 管理 goroutine ...                │
│                                            │
└────────────────────────────────────────────┘
</code></pre>
<h3 id="實際編譯例子"><a class="header" href="#實際編譯例子">實際編譯例子</a></h3>
<pre><code class="language-go">// main.go
package main

import "fmt"

func main() {
    go func() {
        fmt.Println("Hello from goroutine")
    }()
    
    fmt.Println("Hello from main")
}
</code></pre>
<p>編譯時會發生：</p>
<pre><code class="language-bash">$ go build main.go

1. 編譯階段（go build）：
   - 編譯 main.go：
     * 編譯 main() 函數
     * 識別 go func(){...}，生成 runtime.newproc 調用
   
   - 編譯 fmt 包：
     * 編譯所有 fmt 函數
   
   - 編譯 runtime：
     * 編譯 scheduler（newproc、schedule 等）
     * 編譯 GC
     * 編譯 memory allocator
     * 編譯所有 runtime 包的代碼
   
   輸出：多個 .o 目標文件

2. 連結階段（Linker）：
   - 合併所有 .o 目標文件
   - 解析符號引用：
     * fmt.Println → fmt 包中的實現
     * newproc → runtime.newproc 的實現
   - 重定位地址
   - 生成可執行檔案
   
   輸出：main（可執行檔案，約 3-6 MB）
</code></pre>
<h2 id="查看-runtime-信息"><a class="header" href="#查看-runtime-信息">查看 Runtime 信息</a></h2>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 獲取運行時信息
    var m runtime.MemStats
    runtime.ReadMemStats(&amp;m)
    
    fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
    fmt.Printf("Memory Alloc: %v MB\n", m.Alloc/1024/1024)
    fmt.Printf("GC Runs: %d\n", m.NumGC)
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(-1))
}
</code></pre>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<div class="table-wrapper"><table><thead><tr><th>組件</th><th>作用</th></tr></thead><tbody>
<tr><td>Scheduler</td><td>管理 goroutine 的執行和切換</td></tr>
<tr><td>GC</td><td>自動回收不使用的內存</td></tr>
<tr><td>Memory Manager</td><td>分配和管理內存</td></tr>
<tr><td>Networking</td><td>支持高效的網絡 IO</td></tr>
<tr><td>Synchronization</td><td>提供 channel、mutex 等同步原語</td></tr>
</tbody></table>
</div>
<p>Go Runtime 的設計使得開發者可以輕鬆編寫高效的並發程序，而不需要手動管理線程和內存。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../go/Golang高效能開發完整指南.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../go/golang_debugger.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../go/Golang高效能開發完整指南.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../go/golang_debugger.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
