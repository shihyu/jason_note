<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go Runtime 完整指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-runtime-完整指南"><a class="header" href="#go-runtime-完整指南">Go Runtime 完整指南</a></h1>
<h2 id="什麼是-go-runtime"><a class="header" href="#什麼是-go-runtime">什麼是 Go Runtime？</a></h2>
<p>Go Runtime 是 Go 語言的執行時系統，負責在操作系統和用戶代碼之間進行交互。它是一個內嵌在每個 Go 程序中的系統層，提供語言運行所需的基礎設施。</p>
<h2 id="runtime-的核心組件"><a class="header" href="#runtime-的核心組件">Runtime 的核心組件</a></h2>
<h3 id="1-調度器scheduler"><a class="header" href="#1-調度器scheduler">1. 調度器（Scheduler）</a></h3>
<p><strong>目的</strong>：管理 goroutine 的執行，實現並發編程模型。</p>
<p><strong>三層模型（G-M-P）</strong>：</p>
<ul>
<li><strong>G（Goroutine）</strong>：輕量級線程，用戶創建的並發任務</li>
<li><strong>M（Machine）</strong>：映射到操作系統線程，執行實際代碼</li>
<li><strong>P（Processor）</strong>：邏輯處理器，每個 P 管理一個本地 goroutine 隊列</li>
</ul>
<p><strong>調度策略</strong>：</p>
<ul>
<li>Work-stealing 算法：空閒的 P 會從其他 P 的隊列中竊取任務</li>
<li>協作式調度：goroutine 在系統調用、IO 操作或明確讓出時觸發調度</li>
<li>搶佔式調度（1.14+）：定期檢查點強制調度</li>
</ul>
<pre><code>┌─────────────────────────────────────────────┐
│              Go 程序                         │
├─────────────────────────────────────────────┤
│  Go Code                                    │
│  ├─ go func1() ──┐                          │
│  ├─ go func2() ──┼─→ G (Goroutines)        │
│  └─ go func3() ──┘                          │
├─────────────────────────────────────────────┤
│  Scheduler                                  │
│  ├─ P0 [G1, G2, G3, ...]                   │
│  ├─ P1 [G4, G5, ...]                       │
│  └─ P2 [...]                               │
├─────────────────────────────────────────────┤
│  OS Threads (M)                             │
│  ├─ M0 ─→ 執行 P0 的 goroutine             │
│  ├─ M1 ─→ 執行 P1 的 goroutine             │
│  └─ M2 ─→ 執行 P2 的 goroutine             │
├─────────────────────────────────────────────┤
│  操作系統                                    │
└─────────────────────────────────────────────┘
</code></pre>
<h3 id="2-垃圾回收器garbage-collector"><a class="header" href="#2-垃圾回收器garbage-collector">2. 垃圾回收器（Garbage Collector）</a></h3>
<p><strong>目的</strong>：自動管理內存，回收不再使用的對象。</p>
<p><strong>特性</strong>：</p>
<ul>
<li>並發 GC：與用戶代碼並行運行，減少 STW（Stop The World）時間</li>
<li>三色標記法：黑、灰、白三種顏色追蹤對象狀態</li>
<li>寫屏障：記錄堆上對象的修改</li>
</ul>
<p><strong>GC 階段</strong>：</p>
<ol>
<li>Mark Setup - 啟用寫屏障</li>
<li>Marking - 並發標記活對象</li>
<li>Mark Termination - 完成標記（需要 STW）</li>
<li>Sweep - 並發清掃死對象</li>
</ol>
<h3 id="3-內存管理"><a class="header" href="#3-內存管理">3. 內存管理</a></h3>
<p><strong>堆（Heap）</strong>：</p>
<ul>
<li>用於分配動態內存</li>
<li>由 GC 管理</li>
</ul>
<p><strong>棧（Stack）</strong>：</p>
<ul>
<li>每個 goroutine 有自己的棧</li>
<li>棧空間自動增長（segmented stack）</li>
</ul>
<p><strong>內存分配器</strong>：</p>
<ul>
<li>基於 TCMalloc 設計</li>
<li>多層級結構：小對象、中對象、大對象的不同分配策略</li>
</ul>
<h3 id="4-系統調用和-io-操作"><a class="header" href="#4-系統調用和-io-操作">4. 系統調用和 IO 操作</a></h3>
<p><strong>網絡 IO</strong>：</p>
<ul>
<li>使用非阻塞 socket 和 epoll/kqueue/IOCP</li>
<li>Runtime 監控 IO 事件，自動喚醒相關 goroutine</li>
</ul>
<p><strong>文件 IO</strong>：</p>
<ul>
<li>包裝操作系統的文件 API</li>
<li>支持異步操作</li>
</ul>
<p><strong>特殊處理</strong>：</p>
<ul>
<li>當 M 執行阻塞系統調用時，會自動分配新 M 給 P</li>
<li>系統調用完成後，goroutine 回到隊列</li>
</ul>
<h3 id="5-channel-和同步原語"><a class="header" href="#5-channel-和同步原語">5. Channel 和同步原語</a></h3>
<p><strong>Channel</strong>：</p>
<ul>
<li>內置的消息傳遞機制</li>
<li>實現 goroutine 間的通信和同步</li>
</ul>
<p><strong>同步原語</strong>：</p>
<ul>
<li>Mutex</li>
<li>RWMutex</li>
<li>Cond</li>
<li>WaitGroup</li>
<li>Semaphore</li>
</ul>
<h3 id="6-panic-和-recover"><a class="header" href="#6-panic-和-recover">6. Panic 和 Recover</a></h3>
<p><strong>運行時異常處理</strong>：</p>
<ul>
<li>nil 指針解引用檢查</li>
<li>數組邊界檢查</li>
<li>類型斷言檢查</li>
<li>panic/recover 機制</li>
</ul>
<h2 id="runtime-的生命周期"><a class="header" href="#runtime-的生命周期">Runtime 的生命周期</a></h2>
<h3 id="程序啟動"><a class="header" href="#程序啟動">程序啟動</a></h3>
<pre><code>1. 操作系統加載可執行檔案
2. 執行引導代碼（bootstrap code）
3. 初始化 runtime
   - 初始化全局變量
   - 啟動 GC 工作線程
   - 初始化調度器
4. 執行 init() 函數
5. 執行 main() 函數
</code></pre>
<h3 id="程序運行"><a class="header" href="#程序運行">程序運行</a></h3>
<pre><code>Runtime 在後台運行：
├─ Scheduler：調度 goroutine 執行
├─ GC：定期掃描堆內存
├─ Signal handler：處理操作系統信號
└─ Timer：管理 time.Timer 和 time.Ticker
</code></pre>
<h3 id="程序退出"><a class="header" href="#程序退出">程序退出</a></h3>
<pre><code>1. main() 函數返回
2. defer 語句執行（逆序）
3. goroutine 逐個終止
4. GC 最後一次運行
5. 釋放所有資源
6. 進程退出
</code></pre>
<h2 id="關鍵數據結構"><a class="header" href="#關鍵數據結構">關鍵數據結構</a></h2>
<h3 id="ggoroutine結構體"><a class="header" href="#ggoroutine結構體">G（Goroutine）結構體</a></h3>
<pre><code class="language-go">type g struct {
    stack       stack           // goroutine 的棧空間
    stackguard0 uintptr         // 棧溢出檢查
    m           *m              // 關聯的 M
    goid        uint64          // goroutine ID
    waiting     *sudog          // 阻塞在 channel 或 lock 上
    waitreason  waitReason      // 等待原因
    status      uint32          // goroutine 狀態
    // ... 更多字段
}
</code></pre>
<p><strong>Goroutine 狀態</strong>：</p>
<ul>
<li>Gidle：未使用</li>
<li>Grunnable：等待運行</li>
<li>Grunning：正在運行</li>
<li>Gsyscall：執行系統調用</li>
<li>Gwaiting：阻塞（IO、channel、lock）</li>
<li>Gdead：已終止</li>
</ul>
<h3 id="mmachine結構體"><a class="header" href="#mmachine結構體">M（Machine）結構體</a></h3>
<pre><code class="language-go">type m struct {
    p           puintptr        // 關聯的 P
    curg        *g              // 當前執行的 G
    id          int64
    procid      uint64          // 操作系統線程 ID
    // ... 更多字段
}
</code></pre>
<h3 id="pprocessor結構體"><a class="header" href="#pprocessor結構體">P（Processor）結構體</a></h3>
<pre><code class="language-go">type p struct {
    id          int32
    runq        [256]guintptr   // 本地隊列
    runnext     guintptr        // 下一個要運行的 G
    // ... 更多字段
}
</code></pre>
<h2 id="重要的-runtime-函數"><a class="header" href="#重要的-runtime-函數">重要的 Runtime 函數</a></h2>
<h3 id="調度相關"><a class="header" href="#調度相關">調度相關</a></h3>
<pre><code class="language-go">runtime.Gosched()           // 讓出 CPU，允許其他 goroutine 運行
runtime.NumGoroutine()      // 獲取當前 goroutine 數量
runtime.GOMAXPROCS(n)       // 設置最大 P 數量
runtime.LockOSThread()      // 將當前 goroutine 綁定到 OS 線程
runtime.UnlockOSThread()    // 解除綁定
</code></pre>
<h3 id="gc-相關"><a class="header" href="#gc-相關">GC 相關</a></h3>
<pre><code class="language-go">runtime.GC()                // 手動觸發垃圾回收
runtime.ReadMemStats(m)     // 讀取內存統計信息
runtime.SetGCPercent(p)     // 設置 GC 觸發阈值
</code></pre>
<h3 id="debug-和分析"><a class="header" href="#debug-和分析">Debug 和分析</a></h3>
<pre><code class="language-go">runtime.Stack(buf, all)     // 獲取棧信息
runtime.Caller(skip)        // 獲取調用者信息
runtime.SetMutexProfileFraction(r)  // 設置 mutex 分析
</code></pre>
<h2 id="性能優化技巧"><a class="header" href="#性能優化技巧">性能優化技巧</a></h2>
<h3 id="1-調整-gomaxprocs"><a class="header" href="#1-調整-gomaxprocs">1. 調整 GOMAXPROCS</a></h3>
<pre><code class="language-go">import "runtime"

// 充分利用多核
runtime.GOMAXPROCS(runtime.NumCPU())
</code></pre>
<h3 id="2-減少-gc-壓力"><a class="header" href="#2-減少-gc-壓力">2. 減少 GC 壓力</a></h3>
<pre><code class="language-go">// 複用對象，減少分配
var buffer bytes.Buffer
buffer.WriteString("hello")
buffer.Reset()  // 復用 buffer

// 使用對象池
var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}
</code></pre>
<h3 id="3-避免頻繁的系統調用"><a class="header" href="#3-避免頻繁的系統調用">3. 避免頻繁的系統調用</a></h3>
<pre><code class="language-go">// 不好：每次都調用系統調用
for i := 0; i &lt; 1000; i++ {
    syscall.Write(fd, data)
}

// 好：批量操作
syscall.Write(fd, largeData)
</code></pre>
<h3 id="4-合理使用-goroutine"><a class="header" href="#4-合理使用-goroutine">4. 合理使用 goroutine</a></h3>
<pre><code class="language-go">// 不好：創建過多 goroutine
for i := 0; i &lt; 1000000; i++ {
    go doSomething()
}

// 好：使用 worker pool
const numWorkers = 100
for i := 0; i &lt; numWorkers; i++ {
    go worker(jobChan)
}
</code></pre>
<h2 id="runtime-的來源和形式"><a class="header" href="#runtime-的來源和形式">Runtime 的來源和形式</a></h2>
<p>在源碼層面，<strong>Go Runtime 是用 Go 和 C 混寫的代碼</strong>，存在 Go 標準庫的 <code>runtime</code> 包中。當你編譯 Go 程序時，Runtime 會被<strong>靜態連結進去</strong>，最終成為可執行檔案的一部分。</p>
<p><strong>Runtime 不是一個獨立的執行檔案</strong>，而是代碼和數據結構的集合，包括：</p>
<ul>
<li>調度器（Scheduler）</li>
<li>垃圾回收器（GC）</li>
<li>內存管理器</li>
<li>goroutine 管理</li>
<li>Channel 實現</li>
<li>同步原語實現</li>
<li>異常處理</li>
</ul>
<h2 id="runtime-和編譯器的關係"><a class="header" href="#runtime-和編譯器的關係">Runtime 和編譯器的關係</a></h2>
<h3 id="編譯器的職責"><a class="header" href="#編譯器的職責">編譯器的職責</a></h3>
<ul>
<li>將 Go 源碼編譯成機器碼</li>
<li>識別 <code>go</code> 語句，生成對 <code>runtime.newproc</code> 的調用</li>
<li>插入棧溢出檢查代碼</li>
<li>插入邊界檢查代碼</li>
</ul>
<h3 id="runtime-的職責"><a class="header" href="#runtime-的職責">Runtime 的職責</a></h3>
<ul>
<li>執行調度算法</li>
<li>管理內存和垃圾回收</li>
<li>處理並發原語（channel、mutex）</li>
<li>處理異常和恢復</li>
</ul>
<h2 id="編譯和連結的完整流程"><a class="header" href="#編譯和連結的完整流程">編譯和連結的完整流程</a></h2>
<h3 id="三個關鍵階段"><a class="header" href="#三個關鍵階段">三個關鍵階段</a></h3>
<pre><code>Go 源碼文件                    Runtime 源碼
    │                            │
    │  (runtime 包在標準庫中)     │
    │                            │
    └────────────┬───────────────┘
                 │
            ┌────▼──────────────────┐
            │   編譯器 (go build)    │
            │  - 編譯用戶代碼         │
            │  - 編譯 runtime 代碼    │
            │  - 生成目標文件         │
            └────┬──────────────────┘
                 │
            ┌────▼────────────────────────┐
            │   目標文件 (.o)             │
            │  - 用戶代碼的機器碼          │
            │  - Runtime 的機器碼          │
            │  - 標準庫的機器碼            │
            └────┬─────────────────────────┘
                 │
            ┌────▼──────────────────┐
            │   Linker（連結器）    │
            │  - 連結所有目標文件    │
            │  - 連結 runtime       │
            │  - 解析符號引用        │
            │  - 生成最終可執行檔案  │
            └────┬──────────────────┘
                 │
       ┌─────────▼──────────────────────────┐
       │   可執行檔案（自包含）              │
       │  ┌──────────────────────────────┐ │
       │  │ 用戶代碼的機器碼              │ │
       │  ├──────────────────────────────┤ │
       │  │ Go Runtime 的機器碼           │ │
       │  │ - Scheduler                   │ │
       │  │ - GC                          │ │
       │  │ - Memory Manager              │ │
       │  │ - goroutine 管理              │ │
       │  │ - Channel 實現                │ │
       │  ├──────────────────────────────┤ │
       │  │ 標準庫的機器碼                │ │
       │  │ (fmt, io, sync 等)            │ │
       │  ├──────────────────────────────┤ │
       │  │ 其他必要資源                  │ │
       │  └──────────────────────────────┘ │
       └────────────────────────────────────┘
</code></pre>
<h3 id="階段-1編譯go-build"><a class="header" href="#階段-1編譯go-build">階段 1：編譯（go build）</a></h3>
<p><strong>輸入</strong>：Go 源碼文件 + Runtime 源碼</p>
<p><strong>處理</strong>：</p>
<ul>
<li>編譯器分別編譯用戶代碼和 runtime 代碼</li>
<li>每個 Go 文件（<code>.go</code>）都被編譯成目標文件（<code>.o</code>）</li>
<li>Runtime 中的 C 代碼也被編譯成機器碼</li>
</ul>
<p><strong>輸出</strong>：多個目標文件，包含編譯後的機器碼</p>
<pre><code class="language-bash">$ go build myprogram.go

# 在編譯過程中，編譯器會：
# 1. 編譯 myprogram.go → myprogram.o
# 2. 編譯 runtime/*.go → runtime_*.o
# 3. 編譯 runtime/*.c → runtime_*.o
# 4. 編譯標準庫 → stdlib_*.o
</code></pre>
<h3 id="階段-2連結linker"><a class="header" href="#階段-2連結linker">階段 2：連結（Linker）</a></h3>
<p><strong>輸入</strong>：所有目標文件和庫文件</p>
<p><strong>處理</strong>：</p>
<ul>
<li>將所有 <code>.o</code> 文件中的代碼和數據合併</li>
<li>解析符號引用（Symbol Resolution）</li>
<li>重定位地址（Relocation）</li>
<li>創建可執行檔案頭部</li>
</ul>
<p><strong>輸出</strong>：單個可執行檔案</p>
<h3 id="階段-3結果---自包含的可執行檔案"><a class="header" href="#階段-3結果---自包含的可執行檔案">階段 3：結果 - 自包含的可執行檔案</a></h3>
<p>最終生成的可執行檔案包含：</p>
<ol>
<li><strong>用戶代碼</strong> - 你寫的所有函數和邏輯</li>
<li><strong>Go Runtime</strong> - 核心部分，包括：
<ul>
<li>Scheduler（調度器）</li>
<li>GC（垃圾回收器）</li>
<li>Memory Manager（內存管理）</li>
<li>goroutine 管理機制</li>
<li>Channel 實現</li>
</ul>
</li>
<li><strong>標準庫</strong> - fmt、io、sync 等所有依賴的包</li>
<li><strong>元數據和資源</strong> - 符號表、重定位信息等</li>
</ol>
<h3 id="為什麼是靜態連結"><a class="header" href="#為什麼是靜態連結">為什麼是靜態連結？</a></h3>
<p>Go 選擇靜態連結而不是動態連結的原因：</p>
<ol>
<li><strong>跨平台部署</strong>：生成的二進制可以直接在目標系統運行，不需要安裝依賴</li>
<li><strong>性能</strong>：避免動態連結的開銷，啟動更快</li>
<li><strong>簡化分發</strong>：只需分發一個檔案，使用者無需配置環境</li>
<li><strong>版本穩定性</strong>：不會因為系統庫版本不同而導致問題</li>
</ol>
<h3 id="驗證靜態連結"><a class="header" href="#驗證靜態連結">驗證靜態連結</a></h3>
<p>你可以用以下命令查看編譯結果：</p>
<pre><code class="language-bash"># 檢查檔案類型和依賴
$ file ./myprogram
./myprogram: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), 
statically linked, Go BuildID=...

# 查看動態依賴（如果有的話）
$ ldd ./myprogram
    not a dynamic executable

# 查看檔案大小（包含 runtime）
$ ls -lh ./myprogram
-rwxr-xr-x 1 user group 5.2M Nov 26 12:34 myprogram

# 檢查編譯時包含的 runtime 信息
$ strings ./myprogram | grep "runtime\." | head -20
</code></pre>
<h3 id="runtime-在編譯過程中的集成"><a class="header" href="#runtime-在編譯過程中的集成">Runtime 在編譯過程中的集成</a></h3>
<pre><code>┌────────────────────────────────────────────┐
│      編譯器看到的 Go 代碼                    │
├────────────────────────────────────────────┤
│                                            │
│  package main                              │
│                                            │
│  func main() {                             │
│      go doWork()  ◄── 識別 go 語句         │
│      time.Sleep(1 * time.Second)           │
│  }                                         │
│                                            │
│  func doWork() { ... }                     │
│                                            │
└────────────────────────────────────────────┘
                    │
                    │ 編譯器處理
                    │
                    ▼
┌────────────────────────────────────────────┐
│         生成的機器碼（偽代碼）              │
├────────────────────────────────────────────┤
│                                            │
│  main:                                     │
│      ... 初始化代碼 ...                    │
│      call runtime.newproc  ◄── 創建 G    │
│      ... sleep 代碼 ...                    │
│                                            │
│  doWork:                                   │
│      ... 函數體 ...                        │
│                                            │
│  runtime.newproc:       ◄── Runtime 代碼  │
│      ... scheduler 代碼 ...                │
│      ... 管理 goroutine ...                │
│                                            │
└────────────────────────────────────────────┘
</code></pre>
<h3 id="實際編譯例子"><a class="header" href="#實際編譯例子">實際編譯例子</a></h3>
<pre><code class="language-go">// main.go
package main

import "fmt"

func main() {
    go func() {
        fmt.Println("Hello from goroutine")
    }()
    
    fmt.Println("Hello from main")
}
</code></pre>
<p>編譯時會發生：</p>
<pre><code class="language-bash">$ go build main.go

1. 編譯階段（go build）：
   - 編譯 main.go：
     * 編譯 main() 函數
     * 識別 go func(){...}，生成 runtime.newproc 調用
   
   - 編譯 fmt 包：
     * 編譯所有 fmt 函數
   
   - 編譯 runtime：
     * 編譯 scheduler（newproc、schedule 等）
     * 編譯 GC
     * 編譯 memory allocator
     * 編譯所有 runtime 包的代碼
   
   輸出：多個 .o 目標文件

2. 連結階段（Linker）：
   - 合併所有 .o 目標文件
   - 解析符號引用：
     * fmt.Println → fmt 包中的實現
     * newproc → runtime.newproc 的實現
   - 重定位地址
   - 生成可執行檔案
   
   輸出：main（可執行檔案，約 3-6 MB）
</code></pre>
<h2 id="查看-runtime-信息"><a class="header" href="#查看-runtime-信息">查看 Runtime 信息</a></h2>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 獲取運行時信息
    var m runtime.MemStats
    runtime.ReadMemStats(&amp;m)
    
    fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
    fmt.Printf("Memory Alloc: %v MB\n", m.Alloc/1024/1024)
    fmt.Printf("GC Runs: %d\n", m.NumGC)
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(-1))
}
</code></pre>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<div class="table-wrapper"><table><thead><tr><th>組件</th><th>作用</th></tr></thead><tbody>
<tr><td>Scheduler</td><td>管理 goroutine 的執行和切換</td></tr>
<tr><td>GC</td><td>自動回收不使用的內存</td></tr>
<tr><td>Memory Manager</td><td>分配和管理內存</td></tr>
<tr><td>Networking</td><td>支持高效的網絡 IO</td></tr>
<tr><td>Synchronization</td><td>提供 channel、mutex 等同步原語</td></tr>
</tbody></table>
</div>
<p>Go Runtime 的設計使得開發者可以輕鬆編寫高效的並發程序，而不需要手動管理線程和內存。</p>
<hr />
<h1 id="go-runtime-原始碼檔案結構"><a class="header" href="#go-runtime-原始碼檔案結構">Go Runtime 原始碼檔案結構</a></h1>
<h2 id="原始碼路徑"><a class="header" href="#原始碼路徑">原始碼路徑</a></h2>
<pre><code>/home/shihyu/go/src/runtime/
</code></pre>
<p>本目錄包含約 507 個 Go 原始碼檔案，以及多個子目錄。以下是核心關鍵檔案的分類介紹。</p>
<hr />
<h2 id="一核心結構與型別定義"><a class="header" href="#一核心結構與型別定義">一、核心結構與型別定義</a></h2>
<h3 id="1-runtime2go-核心資料結構"><a class="header" href="#1-runtime2go-核心資料結構">1. runtime2.go (核心資料結構)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/runtime2.go</code></li>
<li><strong>說明</strong>: 定義 runtime 最核心的資料結構</li>
<li><strong>包含內容</strong>:
<ul>
<li><code>g</code> (goroutine) 結構體定義</li>
<li><code>m</code> (machine/OS thread) 結構體定義</li>
<li><code>p</code> (processor) 結構體定義</li>
<li>goroutine 狀態常數 (_Gidle, _Grunnable, _Grunning, _Gsyscall 等)</li>
<li>各種核心型別和常數定義</li>
</ul>
</li>
</ul>
<h3 id="2-typego"><a class="header" href="#2-typego">2. type.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/type.go</code></li>
<li><strong>說明</strong>: 型別系統的 runtime 表示</li>
</ul>
<hr />
<h2 id="二排程器-scheduler"><a class="header" href="#二排程器-scheduler">二、排程器 (Scheduler)</a></h2>
<h3 id="3-procgo-核心排程邏輯"><a class="header" href="#3-procgo-核心排程邏輯">3. proc.go (核心排程邏輯)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/proc.go</code></li>
<li><strong>說明</strong>: goroutine 排程器的核心實作</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>goroutine 的建立、執行、停止</li>
<li>M-P-G 排程模型實作</li>
<li>Work-stealing 演算法</li>
<li>系統呼叫的處理</li>
<li>執行緒停放與喚醒機制</li>
</ul>
</li>
<li><strong>設計文件</strong>: https://golang.org/s/go11sched</li>
</ul>
<h3 id="4-runtime1go"><a class="header" href="#4-runtime1go">4. runtime1.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/runtime1.go</code></li>
<li><strong>說明</strong>: runtime 初始化相關功能</li>
</ul>
<hr />
<h2 id="三記憶體管理-memory-management"><a class="header" href="#三記憶體管理-memory-management">三、記憶體管理 (Memory Management)</a></h2>
<h3 id="5-mallocgo-記憶體分配器"><a class="header" href="#5-mallocgo-記憶體分配器">5. malloc.go (記憶體分配器)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/malloc.go</code></li>
<li><strong>說明</strong>: 記憶體分配的主要邏輯</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>物件記憶體分配 (small/large objects)</li>
<li>span 管理</li>
<li>size class 定義</li>
</ul>
</li>
</ul>
<h3 id="6-mheapgo-堆記憶體管理"><a class="header" href="#6-mheapgo-堆記憶體管理">6. mheap.go (堆記憶體管理)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mheap.go</code></li>
<li><strong>說明</strong>: 堆記憶體的管理</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>mheap 結構體與操作</li>
<li>span 的分配與回收</li>
<li>記憶體頁管理</li>
</ul>
</li>
</ul>
<h3 id="7-mcachego-執行緒快取"><a class="header" href="#7-mcachego-執行緒快取">7. mcache.go (執行緒快取)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mcache.go</code></li>
<li><strong>說明</strong>: 每個 P 的本地記憶體快取</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>小物件快速分配</li>
<li>減少鎖競爭</li>
</ul>
</li>
</ul>
<h3 id="8-mcentralgo-中央快取"><a class="header" href="#8-mcentralgo-中央快取">8. mcentral.go (中央快取)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mcentral.go</code></li>
<li><strong>說明</strong>: 中央 span 快取，連接 mcache 和 mheap</li>
</ul>
<h3 id="9-mprofgo-記憶體-profiling"><a class="header" href="#9-mprofgo-記憶體-profiling">9. mprof.go (記憶體 profiling)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mprof.go</code></li>
<li><strong>說明</strong>: 記憶體分配追蹤與 profiling</li>
</ul>
<h3 id="10-msizego"><a class="header" href="#10-msizego">10. msize.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/msize.go</code></li>
<li><strong>說明</strong>: 記憶體 size class 計算</li>
</ul>
<h3 id="11-mstatsgo"><a class="header" href="#11-mstatsgo">11. mstats.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mstats.go</code></li>
<li><strong>說明</strong>: 記憶體統計資訊</li>
</ul>
<h3 id="12-mmapgo"><a class="header" href="#12-mmapgo">12. mmap*.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mmap*.go</code></li>
<li><strong>說明</strong>: 不同平台的記憶體映射實作</li>
</ul>
<hr />
<h2 id="四垃圾回收-garbage-collection"><a class="header" href="#四垃圾回收-garbage-collection">四、垃圾回收 (Garbage Collection)</a></h2>
<h3 id="13-mgcgo-垃圾回收主邏輯"><a class="header" href="#13-mgcgo-垃圾回收主邏輯">13. mgc.go (垃圾回收主邏輯)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgc.go</code></li>
<li><strong>說明</strong>: GC 的核心實作</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>並行標記清除 (concurrent mark-sweep)</li>
<li>GC 觸發條件</li>
<li>STW (stop-the-world) 控制</li>
<li>Write barrier</li>
</ul>
</li>
</ul>
<h3 id="14-mgcmarkgo-標記階段"><a class="header" href="#14-mgcmarkgo-標記階段">14. mgcmark.go (標記階段)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgcmark.go</code></li>
<li><strong>說明</strong>: GC 標記階段實作</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>物件掃描與標記</li>
<li>Work buffer 管理</li>
<li>協助標記 (assist marking)</li>
</ul>
</li>
</ul>
<h3 id="15-mgcsweepgo-清除階段"><a class="header" href="#15-mgcsweepgo-清除階段">15. mgcsweep.go (清除階段)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgcsweep.go</code></li>
<li><strong>說明</strong>: GC 清除階段實作</li>
</ul>
<h3 id="16-mgcscavengego-記憶體歸還"><a class="header" href="#16-mgcscavengego-記憶體歸還">16. mgcscavenge.go (記憶體歸還)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgcscavenge.go</code></li>
<li><strong>說明</strong>: 將未使用記憶體歸還給作業系統</li>
</ul>
<h3 id="17-mgcstackgo-堆疊掃描"><a class="header" href="#17-mgcstackgo-堆疊掃描">17. mgcstack.go (堆疊掃描)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgcstack.go</code></li>
<li><strong>說明</strong>: GC 掃描 goroutine 堆疊</li>
</ul>
<h3 id="18-mgcworkgo-gc-工作佇列"><a class="header" href="#18-mgcworkgo-gc-工作佇列">18. mgcwork.go (GC 工作佇列)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mgcwork.go</code></li>
<li><strong>說明</strong>: GC 工作佇列管理</li>
</ul>
<h3 id="19-mbarriergo-write-barrier"><a class="header" href="#19-mbarriergo-write-barrier">19. mbarrier.go (Write Barrier)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mbarrier.go</code></li>
<li><strong>說明</strong>: Write barrier 實作</li>
</ul>
<h3 id="20-mbitmapgo-記憶體-bitmap"><a class="header" href="#20-mbitmapgo-記憶體-bitmap">20. mbitmap.go (記憶體 bitmap)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/mbitmap.go</code></li>
<li><strong>說明</strong>: 記憶體標記 bitmap，用於追蹤指標</li>
</ul>
<hr />
<h2 id="五並發原語-concurrency-primitives"><a class="header" href="#五並發原語-concurrency-primitives">五、並發原語 (Concurrency Primitives)</a></h2>
<h3 id="21-chango-channel"><a class="header" href="#21-chango-channel">21. chan.go (Channel)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/chan.go</code></li>
<li><strong>說明</strong>: channel 的實作</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>send/receive 操作</li>
<li>緩衝管理</li>
<li>goroutine 阻塞與喚醒</li>
</ul>
</li>
</ul>
<h3 id="22-selectgo-select"><a class="header" href="#22-selectgo-select">22. select.go (Select)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/select.go</code></li>
<li><strong>說明</strong>: select 語句的實作</li>
</ul>
<h3 id="23-semago-semaphore"><a class="header" href="#23-semago-semaphore">23. sema.go (Semaphore)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/sema.go</code></li>
<li><strong>說明</strong>: semaphore 與 sync 原語的底層實作</li>
</ul>
<h3 id="24-lockgo-鎖機制"><a class="header" href="#24-lockgo-鎖機制">24. lock*.go (鎖機制)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/lock_*.go</code></li>
<li><strong>說明</strong>: mutex 等鎖機制的實作</li>
</ul>
<h3 id="25-rwmutexgo"><a class="header" href="#25-rwmutexgo">25. rwmutex.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/rwmutex.go</code></li>
<li><strong>說明</strong>: 讀寫鎖</li>
</ul>
<hr />
<h2 id="六堆疊管理-stack-management"><a class="header" href="#六堆疊管理-stack-management">六、堆疊管理 (Stack Management)</a></h2>
<h3 id="26-stackgo-堆疊管理"><a class="header" href="#26-stackgo-堆疊管理">26. stack.go (堆疊管理)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/stack.go</code></li>
<li><strong>說明</strong>: goroutine 堆疊管理</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>堆疊分配與釋放</li>
<li>堆疊增長 (stack growth)</li>
<li>堆疊收縮 (stack shrinking)</li>
<li>堆疊複製</li>
</ul>
</li>
</ul>
<hr />
<h2 id="七錯誤處理-error-handling"><a class="header" href="#七錯誤處理-error-handling">七、錯誤處理 (Error Handling)</a></h2>
<h3 id="27-panicgo-panicrecover"><a class="header" href="#27-panicgo-panicrecover">27. panic.go (Panic/Recover)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/panic.go</code></li>
<li><strong>說明</strong>: panic 與 recover 機制</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>panic 處理流程</li>
<li>defer 執行</li>
<li>recover 機制</li>
</ul>
</li>
</ul>
<h3 id="28-errorgo"><a class="header" href="#28-errorgo">28. error.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/error.go</code></li>
<li><strong>說明</strong>: runtime error 型別</li>
</ul>
<hr />
<h2 id="八訊號處理-signal-handling"><a class="header" href="#八訊號處理-signal-handling">八、訊號處理 (Signal Handling)</a></h2>
<h3 id="29-signal_unixgo"><a class="header" href="#29-signal_unixgo">29. signal_unix.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/signal_unix.go</code></li>
<li><strong>說明</strong>: Unix/Linux 訊號處理</li>
</ul>
<h3 id="30-os_go"><a class="header" href="#30-os_go">30. os_*.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/os_*.go</code></li>
<li><strong>說明</strong>: 不同作業系統的底層介面</li>
</ul>
<h3 id="31-sys_go"><a class="header" href="#31-sys_go">31. sys_*.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/sys_*.go</code></li>
<li><strong>說明</strong>: 系統呼叫相關</li>
</ul>
<hr />
<h2 id="九組合語言實作-assembly"><a class="header" href="#九組合語言實作-assembly">九、組合語言實作 (Assembly)</a></h2>
<h3 id="32-asm_s"><a class="header" href="#32-asm_s">32. asm_*.s</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/asm_*.s</code></li>
<li><strong>平台</strong>:
<ul>
<li><code>asm_amd64.s</code> - x86-64 架構</li>
<li><code>asm_arm64.s</code> - ARM64 架構</li>
<li><code>asm_386.s</code> - x86 架構</li>
<li>等各平台組語實作</li>
</ul>
</li>
<li><strong>說明</strong>: runtime 核心功能的組語實作</li>
<li><strong>包含</strong>:
<ul>
<li>context switch</li>
<li>系統呼叫</li>
<li>goroutine 啟動</li>
<li>堆疊操作</li>
</ul>
</li>
</ul>
<hr />
<h2 id="十介面與反射-interface--reflection"><a class="header" href="#十介面與反射-interface--reflection">十、介面與反射 (Interface &amp; Reflection)</a></h2>
<h3 id="33-ifacego-介面"><a class="header" href="#33-ifacego-介面">33. iface.go (介面)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/iface.go</code></li>
<li><strong>說明</strong>: interface 的 runtime 實作</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>interface value 表示</li>
<li>型別斷言 (type assertion)</li>
<li>型別轉換</li>
</ul>
</li>
</ul>
<h3 id="34-alggo-演算法"><a class="header" href="#34-alggo-演算法">34. alg.go (演算法)</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/alg.go</code></li>
<li><strong>說明</strong>: 雜湊、比較等演算法</li>
</ul>
<hr />
<h2 id="十一除錯與追蹤-debugging--tracing"><a class="header" href="#十一除錯與追蹤-debugging--tracing">十一、除錯與追蹤 (Debugging &amp; Tracing)</a></h2>
<h3 id="35-debuggo"><a class="header" href="#35-debuggo">35. debug.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/debug.go</code></li>
<li><strong>說明</strong>: runtime 除錯支援</li>
</ul>
<h3 id="36-debugloggo"><a class="header" href="#36-debugloggo">36. debuglog.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/debuglog.go</code></li>
<li><strong>說明</strong>: runtime 內部日誌</li>
</ul>
<h3 id="37-tracego"><a class="header" href="#37-tracego">37. trace.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/trace.go</code></li>
<li><strong>說明</strong>: 執行追蹤 (execution tracing)</li>
</ul>
<h3 id="38-tracebackgo"><a class="header" href="#38-tracebackgo">38. traceback.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/traceback.go</code></li>
<li><strong>說明</strong>: 堆疊回溯 (stack traceback)</li>
</ul>
<hr />
<h2 id="十二效能分析-profiling"><a class="header" href="#十二效能分析-profiling">十二、效能分析 (Profiling)</a></h2>
<h3 id="39-cpuprofgo"><a class="header" href="#39-cpuprofgo">39. cpuprof.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/cpuprof.go</code></li>
<li><strong>說明</strong>: CPU profiling</li>
</ul>
<h3 id="40-profbufgo"><a class="header" href="#40-profbufgo">40. profbuf.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/profbuf.go</code></li>
<li><strong>說明</strong>: Profiling buffer 管理</li>
</ul>
<hr />
<h2 id="十三cgo-支援"><a class="header" href="#十三cgo-支援">十三、CGO 支援</a></h2>
<h3 id="41-cgocallgo"><a class="header" href="#41-cgocallgo">41. cgocall.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/cgocall.go</code></li>
<li><strong>說明</strong>: Go 呼叫 C 程式碼的支援</li>
</ul>
<h3 id="42-cgogo"><a class="header" href="#42-cgogo">42. cgo*.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/cgo*.go</code></li>
<li><strong>說明</strong>: CGO 相關支援檔案</li>
</ul>
<hr />
<h2 id="十四計時器與時間-timer--time"><a class="header" href="#十四計時器與時間-timer--time">十四、計時器與時間 (Timer &amp; Time)</a></h2>
<h3 id="43-timego"><a class="header" href="#43-timego">43. time.go</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/time.go</code></li>
<li><strong>說明</strong>: 計時器管理</li>
<li><strong>關鍵功能</strong>:
<ul>
<li>timer 實作</li>
<li>ticker 實作</li>
<li>time.Sleep 支援</li>
</ul>
</li>
</ul>
<hr />
<h2 id="十五競態檢測與記憶體檢測"><a class="header" href="#十五競態檢測與記憶體檢測">十五、競態檢測與記憶體檢測</a></h2>
<h3 id="44-racego--race"><a class="header" href="#44-racego--race">44. race.go / race/</a></h3>
<ul>
<li><strong>路徑</strong>:
<ul>
<li><code>/home/shihyu/go/src/runtime/race.go</code></li>
<li><code>/home/shihyu/go/src/runtime/race/</code></li>
</ul>
</li>
<li><strong>說明</strong>: 資料競態檢測器 (race detector)</li>
</ul>
<h3 id="45-msango--msan"><a class="header" href="#45-msango--msan">45. msan.go / msan/</a></h3>
<ul>
<li><strong>路徑</strong>:
<ul>
<li><code>/home/shihyu/go/src/runtime/msan.go</code></li>
<li><code>/home/shihyu/go/src/runtime/msan/</code></li>
</ul>
</li>
<li><strong>說明</strong>: Memory Sanitizer 支援</li>
</ul>
<h3 id="46-asango--asan"><a class="header" href="#46-asango--asan">46. asan.go / asan/</a></h3>
<ul>
<li><strong>路徑</strong>:
<ul>
<li><code>/home/shihyu/go/src/runtime/asan.go</code></li>
<li><code>/home/shihyu/go/src/runtime/asan/</code></li>
</ul>
</li>
<li><strong>說明</strong>: Address Sanitizer 支援</li>
</ul>
<hr />
<h2 id="十六重要子目錄"><a class="header" href="#十六重要子目錄">十六、重要子目錄</a></h2>
<h3 id="47-internal"><a class="header" href="#47-internal">47. internal/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/internal/</code></li>
<li><strong>說明</strong>: runtime 內部套件</li>
<li><strong>子套件</strong>:
<ul>
<li><code>atomic/</code> - 原子操作</li>
<li><code>sys/</code> - 系統參數與常數</li>
<li><code>math/</code> - 數學函數</li>
</ul>
</li>
</ul>
<h3 id="48-pprof"><a class="header" href="#48-pprof">48. pprof/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/pprof/</code></li>
<li><strong>說明</strong>: pprof profiling 工具介面</li>
</ul>
<h3 id="49-debug"><a class="header" href="#49-debug">49. debug/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/debug/</code></li>
<li><strong>說明</strong>: runtime/debug 套件</li>
</ul>
<h3 id="50-trace"><a class="header" href="#50-trace">50. trace/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/trace/</code></li>
<li><strong>說明</strong>: runtime/trace 套件</li>
</ul>
<h3 id="51-metrics"><a class="header" href="#51-metrics">51. metrics/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/metrics/</code></li>
<li><strong>說明</strong>: runtime/metrics 套件</li>
</ul>
<h3 id="52-coverage"><a class="header" href="#52-coverage">52. coverage/</a></h3>
<ul>
<li><strong>路徑</strong>: <code>/home/shihyu/go/src/runtime/coverage/</code></li>
<li><strong>說明</strong>: 程式碼覆蓋率支援</li>
</ul>
<hr />
<h2 id="核心檔案學習順序建議"><a class="header" href="#核心檔案學習順序建議">核心檔案學習順序建議</a></h2>
<p>如果要深入學習 Go runtime，建議按以下順序閱讀:</p>
<h3 id="階段一基礎結構"><a class="header" href="#階段一基礎結構">階段一：基礎結構</a></h3>
<ol>
<li><code>runtime2.go</code> - 理解核心資料結構 (g, m, p)</li>
<li><code>type.go</code> - 理解型別系統</li>
</ol>
<h3 id="階段二排程器"><a class="header" href="#階段二排程器">階段二：排程器</a></h3>
<ol start="3">
<li><code>proc.go</code> - 理解 goroutine 排程</li>
<li><code>runtime1.go</code> - runtime 初始化</li>
</ol>
<h3 id="階段三記憶體管理"><a class="header" href="#階段三記憶體管理">階段三：記憶體管理</a></h3>
<ol start="5">
<li><code>malloc.go</code> - 記憶體分配</li>
<li><code>mheap.go</code> - 堆記憶體</li>
<li><code>mcache.go</code> - 執行緒快取</li>
<li><code>mcentral.go</code> - 中央快取</li>
</ol>
<h3 id="階段四垃圾回收"><a class="header" href="#階段四垃圾回收">階段四：垃圾回收</a></h3>
<ol start="9">
<li><code>mgc.go</code> - GC 主邏輯</li>
<li><code>mgcmark.go</code> - 標記階段</li>
<li><code>mgcsweep.go</code> - 清除階段</li>
<li><code>mbarrier.go</code> - Write barrier</li>
</ol>
<h3 id="階段五並發原語"><a class="header" href="#階段五並發原語">階段五：並發原語</a></h3>
<ol start="13">
<li><code>chan.go</code> - channel 實作</li>
<li><code>select.go</code> - select 實作</li>
<li><code>sema.go</code> - semaphore</li>
</ol>
<h3 id="階段六其他重要主題"><a class="header" href="#階段六其他重要主題">階段六：其他重要主題</a></h3>
<ol start="16">
<li><code>stack.go</code> - 堆疊管理</li>
<li><code>panic.go</code> - panic/recover</li>
<li><code>iface.go</code> - interface</li>
<li><code>signal_unix.go</code> - 訊號處理</li>
</ol>
<h3 id="階段七組語深入"><a class="header" href="#階段七組語深入">階段七：組語深入</a></h3>
<ol start="20">
<li><code>asm_amd64.s</code> - 組語實作 (依你的平台選擇)</li>
</ol>
<hr />
<h2 id="重要設計文件與資源"><a class="header" href="#重要設計文件與資源">重要設計文件與資源</a></h2>
<ol>
<li>
<p><strong>Go Scheduler Design Doc</strong>
https://golang.org/s/go11sched</p>
</li>
<li>
<p><strong>Go Memory Allocator</strong>
https://golang.org/s/go-memory-allocator</p>
</li>
<li>
<p><strong>Go GC Design Doc</strong>
https://golang.org/s/go15gcpacing</p>
</li>
<li>
<p><strong>Go Runtime 原始碼</strong>
https://github.com/golang/go/tree/master/src/runtime</p>
</li>
</ol>
<hr />
<h2 id="統計資訊"><a class="header" href="#統計資訊">統計資訊</a></h2>
<ul>
<li><strong>總 Go 檔案數</strong>: 約 507 個</li>
<li><strong>核心行數</strong>: 超過 23,000 行 (僅計算關鍵檔案)</li>
<li><strong>支援平台</strong>: linux, darwin, windows, freebsd, openbsd, netbsd, dragonfly, solaris, aix</li>
<li><strong>支援架構</strong>: amd64, 386, arm, arm64, ppc64, ppc64le, mips, mips64, riscv64, s390x, wasm</li>
</ul>
<hr />
<h2 id="備註"><a class="header" href="#備註">備註</a></h2>
<ul>
<li>所有 <code>*_test.go</code> 檔案為測試檔案</li>
<li>平台特定檔案使用 <code>_&lt;os&gt;_&lt;arch&gt;.go</code> 命名規則</li>
<li>組語檔案使用 <code>.s</code> 副檔名</li>
<li>runtime 程式碼屬於 Go 編譯器的內部實作，API 可能會改變</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../go/Golang高效能開發完整指南.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../go/golang_debugger.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../go/Golang高效能開發完整指南.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../go/golang_debugger.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
