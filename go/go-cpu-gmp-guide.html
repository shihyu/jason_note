<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go 語言 CPU、GMP 模型與多程式執行完整指南 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-語言-cpugmp-模型與多程式執行完整指南"><a class="header" href="#go-語言-cpugmp-模型與多程式執行完整指南">Go 語言 CPU、GMP 模型與多程式執行完整指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#1-go-%E7%A8%8B%E5%BC%8F%E8%88%87-cpu-%E6%A0%B8%E5%BF%83">Go 程式與 CPU 核心</a></li>
<li><a href="#2-gmp-%E8%AA%BF%E5%BA%A6%E6%A8%A1%E5%9E%8B%E8%A9%B3%E8%A7%A3">GMP 調度模型詳解</a></li>
<li><a href="#3-%E5%96%AE%E4%B8%80-go-%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%9F%B7%E8%A1%8C%E6%A8%A1%E5%9E%8B">單一 Go 程式的執行模型</a></li>
<li><a href="#4-%E5%85%A9%E6%94%AF-go-%E7%A8%8B%E5%BC%8F%E7%9A%84%E7%AB%B6%E7%88%AD%E5%95%8F%E9%A1%8C">兩支 Go 程式的競爭問題</a></li>
<li><a href="#5-%E5%AF%A6%E9%9A%9B%E9%A9%97%E8%AD%89%E7%AF%84%E4%BE%8B">實際驗證範例</a></li>
<li><a href="#6-%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E5%BB%BA%E8%AD%B0">最佳實踐建議</a></li>
</ol>
<hr />
<h2 id="1-go-程式與-cpu-核心"><a class="header" href="#1-go-程式與-cpu-核心">1. Go 程式與 CPU 核心</a></h2>
<h3 id="11-預設-processor-數量"><a class="header" href="#11-預設-processor-數量">1.1 預設 Processor 數量</a></h3>
<p><strong>Go 1.5+ 版本：</strong></p>
<pre><code>預設 P (Processor) 數量 = runtime.NumCPU()
</code></pre>
<p>在 16 核心 CPU 上：</p>
<pre><code class="language-go">runtime.GOMAXPROCS(0)  // 返回 16
runtime.NumCPU()        // 返回 16
</code></pre>
<p><strong>歷史變化：</strong></p>
<ul>
<li><strong>Go 1.5 之前</strong>：預設只有 1 個 P（需要手動設置)</li>
<li><strong>Go 1.5 之後</strong>：預設使用所有 CPU 核心</li>
</ul>
<p><strong>驗證範例：</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Printf("CPU 核心數: %d\n", runtime.NumCPU())
    fmt.Printf("GOMAXPROCS (預設使用): %d\n", runtime.GOMAXPROCS(0))
}
</code></pre>
<h3 id="12-手動設置-gomaxprocs"><a class="header" href="#12-手動設置-gomaxprocs">1.2 手動設置 GOMAXPROCS</a></h3>
<pre><code class="language-go">import "runtime"

// 設置使用 8 個核心
runtime.GOMAXPROCS(8)

// 查詢當前設置（傳入 0）
n := runtime.GOMAXPROCS(0)

// 獲取機器 CPU 核心數
numCPU := runtime.NumCPU()
</code></pre>
<p><strong>環境變數方式：</strong></p>
<pre><code class="language-bash">GOMAXPROCS=8 go run main.go
</code></pre>
<hr />
<h2 id="2-gmp-調度模型詳解"><a class="header" href="#2-gmp-調度模型詳解">2. GMP 調度模型詳解</a></h2>
<h3 id="21-核心概念"><a class="header" href="#21-核心概念">2.1 核心概念</a></h3>
<p>Go 使用 <strong>M:N 調度模型</strong>，將 M 個 Goroutine 調度到 N 個 OS Thread 上執行。</p>
<h4 id="三個核心組件"><a class="header" href="#三個核心組件"><strong>三個核心組件：</strong></a></h4>
<div class="table-wrapper"><table><thead><tr><th>組件</th><th>全名</th><th>說明</th><th>數量</th></tr></thead><tbody>
<tr><td><strong>G</strong></td><td>Goroutine</td><td>輕量級協程，用戶創建的並發任務</td><td>可以有幾萬個</td></tr>
<tr><td><strong>M</strong></td><td>Machine (OS Thread)</td><td>作業系統執行緒，真正執行代碼</td><td>動態調整（≥ P 的數量）</td></tr>
<tr><td><strong>P</strong></td><td>Processor</td><td>邏輯處理器，執行上下文</td><td>固定 = GOMAXPROCS</td></tr>
</tbody></table>
</div>
<h3 id="22-gmp-架構圖16-核心"><a class="header" href="#22-gmp-架構圖16-核心">2.2 GMP 架構圖（16 核心）</a></h3>
<pre><code>CPU 核心層:  [核1] [核2] [核3] [核4] ... [核16]
               ↓     ↓     ↓     ↓         ↓
P 層:        [P0]  [P1]  [P2]  [P3]  ... [P15]  (16個，固定)
               ↓     ↓     ↓     ↓         ↓
M 層:        [M0]  [M1]  [M2]  [M3]  ... [M15+] (16+ 個，動態)
               ↓     ↓     ↓     ↓         ↓
G 層:      本地隊列 本地隊列 本地隊列     本地隊列
          [G1,G2] [G10,G11] [G20]      [G150]
                            ↓
                      全局隊列: [G1000, G1001, ...]
</code></pre>
<h3 id="23-goroutine-特點"><a class="header" href="#23-goroutine-特點">2.3 Goroutine 特點</a></h3>
<p><strong>對比 OS Thread：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Goroutine</th><th>OS Thread</th></tr></thead><tbody>
<tr><td>初始堆疊大小</td><td>~2 KB</td><td>1-2 MB</td></tr>
<tr><td>創建成本</td><td>極低</td><td>較高</td></tr>
<tr><td>切換成本</td><td>極低（用戶態）</td><td>較高（內核態）</td></tr>
<tr><td>數量限制</td><td>幾萬～幾十萬</td><td>幾千</td></tr>
<tr><td>調度器</td><td>Go Runtime</td><td>OS Kernel</td></tr>
</tbody></table>
</div>
<p><strong>範例：</strong></p>
<pre><code class="language-go">// 輕鬆創建 10000 個 goroutine
for i := 0; i &lt; 10000; i++ {
    go func(id int) {
        // 執行任務
    }(i)
}
</code></pre>
<h3 id="24-調度流程"><a class="header" href="#24-調度流程">2.4 調度流程</a></h3>
<h4 id="本地隊列-local-run-queue"><a class="header" href="#本地隊列-local-run-queue"><strong>本地隊列 (Local Run Queue)</strong></a></h4>
<ul>
<li>每個 P 維護自己的 goroutine 隊列（最多 256 個）</li>
<li>優先從本地隊列取 goroutine 執行</li>
</ul>
<pre><code>P0 的本地隊列: [G1, G2, G3, G4, G5]
P1 的本地隊列: [G10, G11, G12]
P2 的本地隊列: [G20, G21]
</code></pre>
<h4 id="全局隊列-global-run-queue"><a class="header" href="#全局隊列-global-run-queue"><strong>全局隊列 (Global Run Queue)</strong></a></h4>
<ul>
<li>當本地隊列滿了，新 goroutine 放入全局隊列</li>
<li>當本地隊列空了，從全局隊列獲取</li>
</ul>
<h4 id="工作竊取-work-stealing"><a class="header" href="#工作竊取-work-stealing"><strong>工作竊取 (Work Stealing)</strong></a></h4>
<p>當某個 P 的本地隊列空了：</p>
<ol>
<li>先從全局隊列獲取 goroutine</li>
<li>如果全局隊列也空了，從其他 P「偷」一半的 goroutine</li>
</ol>
<p><strong>範例：</strong></p>
<pre><code>執行前：
P0: []  (空閒)
P5: [G50, G51, G52, G53, G54, G55, G56, G57]  (繁忙)

執行 Work Stealing 後：
P0: [G54, G55, G56, G57]  (偷了一半)
P5: [G50, G51, G52, G53]
</code></pre>
<h3 id="25-m-os-thread-的動態調整"><a class="header" href="#25-m-os-thread-的動態調整">2.5 M (OS Thread) 的動態調整</a></h3>
<h4 id="情況-1純-cpu-密集型"><a class="header" href="#情況-1純-cpu-密集型"><strong>情況 1：純 CPU 密集型</strong></a></h4>
<pre><code>16 個 P → 約 16-17 個 M
</code></pre>
<p>因為沒有阻塞，不需要額外的 M。</p>
<h4 id="情況-2有-io-阻塞"><a class="header" href="#情況-2有-io-阻塞"><strong>情況 2：有 I/O 阻塞</strong></a></h4>
<pre><code class="language-go">go func() {
    time.Sleep(time.Second)  // 阻塞！
}()
</code></pre>
<pre><code>16 個 P → 可能 20-30+ 個 M
</code></pre>
<p><strong>原因：</strong></p>
<ol>
<li>Goroutine 在 M1 上執行，遇到阻塞（如 I/O、Sleep）</li>
<li>M1 被阻塞，但 P0 還可以繼續工作</li>
<li>Go Runtime 創建新的 M2 來接管 P0</li>
<li>M1 等待阻塞結束後，可能重新綁定空閒的 P</li>
</ol>
<p><strong>時間軸範例：</strong></p>
<pre><code>時刻 1:
P0 -- M0 (執行 G1)

時刻 2: G1 遇到 I/O 阻塞
P0 -- M0 (阻塞中，等待 I/O)
P0 -- M16 (新創建，接管 P0，執行 G2)

時刻 3: M0 的 I/O 完成
M0 嘗試重新綁定空閒的 P，或進入休眠
</code></pre>
<h3 id="26-調度時機"><a class="header" href="#26-調度時機">2.6 調度時機</a></h3>
<p>Go Scheduler 會在以下時機進行調度：</p>
<ol>
<li>
<p><strong>主動讓出：</strong></p>
<pre><code class="language-go">runtime.Gosched()
</code></pre>
</li>
<li>
<p><strong>系統調用（阻塞）：</strong></p>
<pre><code class="language-go">os.ReadFile("file.txt")  // I/O
time.Sleep(time.Second)  // 睡眠
</code></pre>
</li>
<li>
<p><strong>Channel 操作阻塞：</strong></p>
<pre><code class="language-go">data := &lt;-ch  // 等待接收
ch &lt;- value   // 等待發送
</code></pre>
</li>
<li>
<p><strong>Goroutine 執行過久：</strong></p>
<ul>
<li>Go 1.14+ 使用基於信號的搶佔式調度</li>
<li>每個 goroutine 執行約 10ms 後可能被搶佔</li>
</ul>
</li>
</ol>
<hr />
<h2 id="3-單一-go-程式的執行模型"><a class="header" href="#3-單一-go-程式的執行模型">3. 單一 Go 程式的執行模型</a></h2>
<h3 id="31-整體架構16-核心"><a class="header" href="#31-整體架構16-核心">3.1 整體架構（16 核心）</a></h3>
<pre><code>【單一 Go 程式】
       ↓
  1 個 OS Process
       ↓
  16+ 個 OS Thread (M)
       ↓
  16 個 Processor (P)
       ↓
  幾萬個 Goroutine (G)
</code></pre>
<h3 id="32-資源使用"><a class="header" href="#32-資源使用">3.2 資源使用</a></h3>
<p>在 16 核心機器上運行單一 Go 程式：</p>
<div class="table-wrapper"><table><thead><tr><th>資源</th><th>數量</th><th>說明</th></tr></thead><tbody>
<tr><td><strong>Process</strong></td><td>1 個</td><td>單一進程</td></tr>
<tr><td><strong>OS Thread</strong></td><td>16+ 個</td><td>動態調整</td></tr>
<tr><td><strong>Processor (P)</strong></td><td>16 個</td><td>固定，對應核心數</td></tr>
<tr><td><strong>Goroutine</strong></td><td>不限</td><td>可以幾萬個</td></tr>
<tr><td><strong>CPU 使用</strong></td><td>100% (16 核心)</td><td>可以充分利用所有核心</td></tr>
</tbody></table>
</div>
<h3 id="33-範例程式"><a class="header" href="#33-範例程式">3.3 範例程式</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "os"
    "runtime"
    "sync"
    "time"
)

func main() {
    fmt.Printf("=== Go 程式資訊 ===\n")
    fmt.Printf("Process ID: %d\n", os.Getpid())
    fmt.Printf("CPU 核心數: %d\n", runtime.NumCPU())
    fmt.Printf("GOMAXPROCS (P): %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("初始 Goroutine: %d\n\n", runtime.NumGoroutine())
    
    var wg sync.WaitGroup
    
    // 創建 10000 個 goroutine
    for i := 0; i &lt; 10000; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // CPU 密集型任務
            sum := 0
            for j := 0; j &lt; 1000000; j++ {
                sum += j
            }
            
            // 模擬一些工作
            time.Sleep(time.Millisecond * 10)
        }(i)
    }
    
    time.Sleep(time.Millisecond * 100)
    fmt.Printf("峰值 Goroutine: %d\n", runtime.NumGoroutine())
    
    wg.Wait()
    fmt.Printf("完成後 Goroutine: %d\n", runtime.NumGoroutine())
}
</code></pre>
<p><strong>執行結果：</strong></p>
<pre><code>=== Go 程式資訊 ===
Process ID: 12345
CPU 核心數: 16
GOMAXPROCS (P): 16
初始 Goroutine: 1

峰值 Goroutine: 10001
完成後 Goroutine: 1
</code></pre>
<p><strong>CPU 使用情況：</strong></p>
<pre><code class="language-bash"># 使用 top 或 htop 查看
PID    CPU%   Command
12345  1600%  myapp    (16 個核心 × 100% = 1600%)
</code></pre>
<hr />
<h2 id="4-兩支-go-程式的競爭問題"><a class="header" href="#4-兩支-go-程式的競爭問題">4. 兩支 Go 程式的競爭問題</a></h2>
<h3 id="41-整體架構"><a class="header" href="#41-整體架構">4.1 整體架構</a></h3>
<p>當啟動兩支 Go 程式時：</p>
<pre><code>【Go 程式 A】              【Go 程式 B】
       ↓                        ↓
  Process 1                 Process 2
       ↓                        ↓
  16+ Thread                16+ Thread
       ↓                        ↓
  16 個 P                   16 個 P
       ↓                        ↓
  幾萬個 G                  幾萬個 G
       ↓                        ↓
       └────────┬────────────────┘
                ↓
          競爭 16 個 CPU 核心
</code></pre>
<h3 id="42-關鍵特點"><a class="header" href="#42-關鍵特點">4.2 關鍵特點</a></h3>
<div class="table-wrapper"><table><thead><tr><th>項目</th><th>單一程式</th><th>兩支程式</th></tr></thead><tbody>
<tr><td><strong>Process 數</strong></td><td>1 個</td><td>2 個（獨立）</td></tr>
<tr><td><strong>總 Thread 數</strong></td><td>16+ 個</td><td>32+ 個</td></tr>
<tr><td><strong>總 P 數</strong></td><td>16 個</td><td>32 個（各 16 個）</td></tr>
<tr><td><strong>記憶體共享</strong></td><td>✅ 所有 goroutine 共享</td><td>❌ 各自獨立</td></tr>
<tr><td><strong>CPU 使用</strong></td><td>獨佔 16 核心</td><td>競爭 16 核心</td></tr>
<tr><td><strong>通訊方式</strong></td><td>Channel（極快）</td><td>IPC/網路（較慢）</td></tr>
<tr><td><strong>隔離性</strong></td><td>無隔離</td><td>完全隔離</td></tr>
</tbody></table>
</div>
<h3 id="43-cpu-競爭情況"><a class="header" href="#43-cpu-競爭情況">4.3 CPU 競爭情況</a></h3>
<h4 id="情況-1兩個-cpu-密集型程式"><a class="header" href="#情況-1兩個-cpu-密集型程式"><strong>情況 1：兩個 CPU 密集型程式</strong></a></h4>
<pre><code>CPU: [核1] [核2] [核3] ... [核16]
       ↓     ↓     ↓         ↓
    Process A 和 Process B 的 Thread 競爭使用
</code></pre>
<p><strong>理想分配：</strong></p>
<pre><code>Process A: 使用 8 個核心  (800% CPU)
Process B: 使用 8 個核心  (800% CPU)
總計: 1600% (16 核心全滿)
</code></pre>
<p><strong>實際情況：</strong></p>
<ul>
<li>OS Scheduler 動態調度</li>
<li>可能不是均等分配</li>
<li>取決於各程式的負載</li>
</ul>
<h4 id="情況-2一個忙碌一個閒置"><a class="header" href="#情況-2一個忙碌一個閒置"><strong>情況 2：一個忙碌，一個閒置</strong></a></h4>
<pre><code>Process A (閒置): ~1-2 個核心  (100-200% CPU)
Process B (忙碌): ~14-15 個核心 (1400-1500% CPU)
</code></pre>
<h4 id="情況-3都是-io-密集型"><a class="header" href="#情況-3都是-io-密集型"><strong>情況 3：都是 I/O 密集型</strong></a></h4>
<pre><code>Process A: 創建 1000+ Thread，但大部分在等待 I/O
Process B: 創建 1000+ Thread，但大部分在等待 I/O

CPU 使用率: 可能只有 20-30%（大部分時間在等待）
</code></pre>
<h3 id="44-程式間隔離"><a class="header" href="#44-程式間隔離">4.4 程式間隔離</a></h3>
<p><strong>完全隔離：</strong></p>
<ul>
<li>❌ 不共享記憶體</li>
<li>❌ 無法直接通訊</li>
<li>❌ 一個崩潰不影響另一個</li>
<li>✅ 需要透過 IPC 通訊</li>
</ul>
<p><strong>通訊方式：</strong></p>
<h4 id="1-http網路通訊最常用"><a class="header" href="#1-http網路通訊最常用"><strong>1. HTTP/網路通訊（最常用）</strong></a></h4>
<pre><code class="language-go">// 程式 A - Server
http.HandleFunc("/", handler)
http.ListenAndServe(":8080", nil)

// 程式 B - Client
resp, _ := http.Get("http://localhost:8080")
</code></pre>
<h4 id="2-共享檔案"><a class="header" href="#2-共享檔案"><strong>2. 共享檔案</strong></a></h4>
<pre><code class="language-go">// 程式 A 寫入
os.WriteFile("/tmp/data.txt", data, 0644)

// 程式 B 讀取
data, _ := os.ReadFile("/tmp/data.txt")
</code></pre>
<h4 id="3-message-queue"><a class="header" href="#3-message-queue"><strong>3. Message Queue</strong></a></h4>
<pre><code class="language-go">// 使用 Redis, RabbitMQ 等
// 程式 A 發送
redis.Publish("channel", "message")

// 程式 B 接收
redis.Subscribe("channel")
</code></pre>
<h4 id="4-unix-socket"><a class="header" href="#4-unix-socket"><strong>4. Unix Socket</strong></a></h4>
<pre><code class="language-go">// 程式 A
listener, _ := net.Listen("unix", "/tmp/app.sock")

// 程式 B
conn, _ := net.Dial("unix", "/tmp/app.sock")
</code></pre>
<h3 id="45-手動控制核心分配"><a class="header" href="#45-手動控制核心分配">4.5 手動控制核心分配</a></h3>
<p>如果希望兩個程式各用一半核心：</p>
<pre><code class="language-go">// 程式 A
runtime.GOMAXPROCS(8)  // 限制使用 8 個 P

// 程式 B
runtime.GOMAXPROCS(8)  // 限制使用 8 個 P
</code></pre>
<p>或使用環境變數：</p>
<pre><code class="language-bash">GOMAXPROCS=8 ./app_a &amp;
GOMAXPROCS=8 ./app_b &amp;
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>這只是限制 P 的數量</li>
<li>實際 CPU 使用仍由 OS Scheduler 決定</li>
<li>無法「鎖定」特定 CPU 核心</li>
</ul>
<hr />
<h2 id="5-實際驗證範例"><a class="header" href="#5-實際驗證範例">5. 實際驗證範例</a></h2>
<h3 id="51-單一程式範例"><a class="header" href="#51-單一程式範例">5.1 單一程式範例</a></h3>
<p><strong>程式：single_app.go</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "os"
    "runtime"
    "time"
)

func main() {
    fmt.Printf("=== 單一 Go 程式 ===\n")
    fmt.Printf("PID: %d\n", os.Getpid())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumCPU: %d\n\n", runtime.NumCPU())
    
    // 創建 CPU 密集型 goroutine
    for i := 0; i &lt; 100; i++ {
        go func(id int) {
            for {
                sum := 0
                for j := 0; j &lt; 10000000; j++ {
                    sum += j
                }
            }
        }(i)
    }
    
    // 定期顯示狀態
    ticker := time.NewTicker(time.Second * 2)
    for range ticker.C {
        fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
    }
}
</code></pre>
<p><strong>執行與監控：</strong></p>
<pre><code class="language-bash"># Terminal 1: 運行程式
go run single_app.go

# Terminal 2: 監控 CPU
top -pid $(pgrep single_app)

# 應該看到 1600% CPU (16 核心全滿)
</code></pre>
<h3 id="52-雙程式範例"><a class="header" href="#52-雙程式範例">5.2 雙程式範例</a></h3>
<p><strong>程式 A：app_a.go</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "os"
    "runtime"
    "time"
)

func main() {
    fmt.Printf("=== Go 程式 A ===\n")
    fmt.Printf("PID: %d\n", os.Getpid())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    
    // CPU 密集型工作
    for i := 0; i &lt; 1000; i++ {
        go func(id int) {
            for {
                sum := 0
                for j := 0; j &lt; 10000000; j++ {
                    sum += j
                }
            }
        }(i)
    }
    
    ticker := time.NewTicker(time.Second * 2)
    for range ticker.C {
        fmt.Printf("[程式 A] PID: %d, Goroutines: %d\n", 
            os.Getpid(), runtime.NumGoroutine())
    }
}
</code></pre>
<p><strong>程式 B：app_b.go</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "os"
    "runtime"
    "time"
)

func main() {
    fmt.Printf("=== Go 程式 B ===\n")
    fmt.Printf("PID: %d\n", os.Getpid())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    
    // CPU 密集型工作
    for i := 0; i &lt; 1000; i++ {
        go func(id int) {
            for {
                sum := 0
                for j := 0; j &lt; 10000000; j++ {
                    sum += j
                }
            }
        }(i)
    }
    
    ticker := time.NewTicker(time.Second * 2)
    for range ticker.C {
        fmt.Printf("[程式 B] PID: %d, Goroutines: %d\n", 
            os.Getpid(), runtime.NumGoroutine())
    }
}
</code></pre>
<p><strong>執行與監控：</strong></p>
<pre><code class="language-bash"># Terminal 1: 運行程式 A
go run app_a.go

# Terminal 2: 運行程式 B
go run app_b.go

# Terminal 3: 監控兩個程式
top -pid $(pgrep -d',' app_)

# 或使用 htop 更直觀
htop
</code></pre>
<p><strong>預期結果：</strong></p>
<pre><code>PID    CPU%   Command
1234   800%   app_a    (約 8 個核心)
5678   800%   app_b    (約 8 個核心)
總計:  1600%  (16 個核心全滿)
</code></pre>
<h3 id="53-查看-thread-數量"><a class="header" href="#53-查看-thread-數量">5.3 查看 Thread 數量</a></h3>
<pre><code class="language-bash"># Linux: 查看某個進程的 thread 數
ps -T -p &lt;PID&gt;

# 或
ps -eLf | grep &lt;PID&gt;

# 或使用 top 查看 thread
top -H -p &lt;PID&gt;

# macOS:
ps -M &lt;PID&gt;
</code></pre>
<hr />
<h2 id="6-最佳實踐建議"><a class="header" href="#6-最佳實踐建議">6. 最佳實踐建議</a></h2>
<h3 id="61-單一程式場景"><a class="header" href="#61-單一程式場景">6.1 單一程式場景</a></h3>
<p><strong>何時使用預設配置（16 個 P）：</strong>
✅ 混合型工作負載（CPU + I/O）
✅ 微服務應用
✅ Web Server
✅ API Gateway</p>
<p><strong>範例：</strong></p>
<pre><code class="language-go">// 預設配置即可，無需設置
// runtime.GOMAXPROCS(runtime.NumCPU()) // 預設已經是這樣
</code></pre>
<h3 id="62-雙程式場景"><a class="header" href="#62-雙程式場景">6.2 雙程式場景</a></h3>
<p><strong>何時需要手動限制：</strong></p>
<ul>
<li>明確想要資源隔離</li>
<li>避免互相搶佔 CPU</li>
<li>確保關鍵程式有足夠資源</li>
</ul>
<p><strong>範例：</strong></p>
<pre><code class="language-go">// 關鍵服務 A - 使用 12 個核心
runtime.GOMAXPROCS(12)

// 次要服務 B - 使用 4 個核心
runtime.GOMAXPROCS(4)
</code></pre>
<h3 id="63-性能監控"><a class="header" href="#63-性能監控">6.3 性能監控</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "time"
)

func monitorPerformance() {
    ticker := time.NewTicker(time.Second * 5)
    
    for range ticker.C {
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        fmt.Printf("=== 性能指標 ===\n")
        fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
        fmt.Printf("OS Threads: %d\n", runtime.NumCPU())
        fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
        fmt.Printf("記憶體使用: %d MB\n", m.Alloc/1024/1024)
        fmt.Printf("GC 次數: %d\n\n", m.NumGC)
    }
}

func main() {
    go monitorPerformance()
    
    // 你的程式邏輯...
    select {}
}
</code></pre>
<h3 id="64-常見問題與解決方案"><a class="header" href="#64-常見問題與解決方案">6.4 常見問題與解決方案</a></h3>
<h4 id="問題-1創建太多-goroutine-導致記憶體耗盡"><a class="header" href="#問題-1創建太多-goroutine-導致記憶體耗盡"><strong>問題 1：創建太多 Goroutine 導致記憶體耗盡</strong></a></h4>
<p><strong>解決方案：使用 Worker Pool</strong></p>
<pre><code class="language-go">func workerPool(jobs &lt;-chan int, results chan&lt;- int) {
    // 限制並發數為 100
    for j := range jobs {
        results &lt;- process(j)
    }
}

func main() {
    jobs := make(chan int, 1000)
    results := make(chan int, 1000)
    
    // 創建固定數量的 worker
    for w := 0; w &lt; 100; w++ {
        go workerPool(jobs, results)
    }
    
    // 發送任務...
}
</code></pre>
<h4 id="問題-2單個-cpu-密集型任務無法利用多核"><a class="header" href="#問題-2單個-cpu-密集型任務無法利用多核"><strong>問題 2：單個 CPU 密集型任務無法利用多核</strong></a></h4>
<p><strong>解決方案：分割任務</strong></p>
<pre><code class="language-go">func processInParallel(data []int) {
    numWorkers := runtime.GOMAXPROCS(0)
    chunkSize := len(data) / numWorkers
    
    var wg sync.WaitGroup
    for i := 0; i &lt; numWorkers; i++ {
        wg.Add(1)
        go func(start int) {
            defer wg.Done()
            end := start + chunkSize
            // 處理 data[start:end]
        }(i * chunkSize)
    }
    wg.Wait()
}
</code></pre>
<h4 id="問題-3兩個程式互相干擾"><a class="header" href="#問題-3兩個程式互相干擾"><strong>問題 3：兩個程式互相干擾</strong></a></h4>
<p><strong>解決方案 1：使用容器隔離</strong></p>
<pre><code class="language-bash"># Docker 限制 CPU
docker run --cpus="8" myapp_a
docker run --cpus="8" myapp_b
</code></pre>
<p><strong>解決方案 2：使用 cgroups（Linux）</strong></p>
<pre><code class="language-bash"># 限制 CPU 使用
cgcreate -g cpu:/app_a
cgset -r cpu.cfs_quota_us=800000 app_a
cgexec -g cpu:app_a ./app_a
</code></pre>
<p><strong>解決方案 3：手動設置 GOMAXPROCS</strong></p>
<pre><code class="language-go">// 在程式啟動時設置
runtime.GOMAXPROCS(8)
</code></pre>
<h3 id="65-架構建議"><a class="header" href="#65-架構建議">6.5 架構建議</a></h3>
<h4 id="單體應用"><a class="header" href="#單體應用"><strong>單體應用</strong></a></h4>
<pre><code>單一 Go 程式
    ↓
使用預設 GOMAXPROCS
    ↓
利用全部 16 核心
</code></pre>
<h4 id="微服務架構"><a class="header" href="#微服務架構"><strong>微服務架構</strong></a></h4>
<pre><code>服務 A (8 核) ← HTTP → 服務 B (4 核)
                          ↓
                      服務 C (4 核)
</code></pre>
<h4 id="負載均衡"><a class="header" href="#負載均衡"><strong>負載均衡</strong></a></h4>
<pre><code>Nginx / HAProxy
        ↓
    ┌───┴───┬───────┬───────┐
    ↓       ↓       ↓       ↓
 實例 1  實例 2  實例 3  實例 4
 (4核)   (4核)   (4核)   (4核)
</code></pre>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<h3 id="關鍵要點"><a class="header" href="#關鍵要點">關鍵要點</a></h3>
<ol>
<li>
<p><strong>Go 程式結構：</strong></p>
<ul>
<li>1 個 Process</li>
<li>動態數量的 M (Thread)</li>
<li>固定數量的 P (= GOMAXPROCS)</li>
<li>大量的 G (Goroutine)</li>
</ul>
</li>
<li>
<p><strong>16 核心單一程式：</strong></p>
<ul>
<li>預設創建 16 個 P</li>
<li>至少 16 個 M</li>
<li>可以充分利用所有核心</li>
</ul>
</li>
<li>
<p><strong>16 核心雙程式：</strong></p>
<ul>
<li>兩個獨立的 Process</li>
<li>總共約 32+ 個 Thread</li>
<li>競爭 16 個 CPU 核心</li>
<li>需要 OS Scheduler 調度</li>
</ul>
</li>
<li>
<p><strong>調度機制：</strong></p>
<ul>
<li>本地隊列 + 全局隊列</li>
<li>Work Stealing 負載均衡</li>
<li>搶佔式調度（Go 1.14+）</li>
</ul>
</li>
</ol>
<h3 id="記憶口訣"><a class="header" href="#記憶口訣">記憶口訣</a></h3>
<pre><code>一個程式一個 Process
GOMAXPROCS 個 Processor
動態調整的 Machine Thread
成千上萬的 Goroutine
</code></pre>
<h3 id="參考資源"><a class="header" href="#參考資源">參考資源</a></h3>
<ul>
<li><a href="https://pkg.go.dev/runtime">Go 官方文檔 - Runtime</a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/proc.go">Go Scheduler 設計文檔</a></li>
<li><a href="https://go.dev/blog/waza-talk">Go 並發模型解析</a></li>
</ul>
<hr />
<p><strong>最後更新：</strong> 2025-10-17
<strong>適用版本：</strong> Go 1.18+</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../go/golang-goroutine.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../go/goroutine_complete_guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../go/golang-goroutine.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../go/goroutine_complete_guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
