Rust 中的動態內存分配
========================================================


本節導讀
--------------------------


到目前為止，如果將當前的操作系統內核也看成一個應用，那麼其中所有的變量都是被靜態分配在內存中的，這樣在對空閒內存的動態使用方面缺少靈活性。我們希望能在操作系統中提供動態申請和釋放內存的能力，這樣就可以加強操作系統對各種以內存為基礎的資源分配與管理。

在應用程序的視角中，動態內存分配中的內存，其實就是操作系統管理的“堆 （Heap）”。但現在要實現操作系統，那麼就需要操作系統自身能提供動態內存分配的能力。如果要實現動態內存分配的能力，需要操作系統提供如下功能：

- 初始時能提供一塊大內存空間作為初始的“堆”。在沒有分頁機制情況下，這塊空間是物理內存空間，否則就是虛擬內存空間。
- 提供在堆上分配和釋放內存的函數接口。這樣函數調用方通過分配內存函數接口得到地址連續的空閒內存塊進行讀寫，也能通過釋放內存函數接口回收內存，以備後續的內存分配請求。
- 提供空閒空間管理的連續內存分配算法。相關算法能動態地維護一系列空閒和已分配的內存塊，從而有效地管理空閒塊。
- （可選）提供建立在堆上的數據結構和操作。有了上述基本的內存分配與釋放函數接口，就可以實現類似動態數組，動態字典等空間靈活可變的堆數據結構，提高編程的靈活性。

考慮到我們是用 Rust 來編寫操作系統，為了在接下來的一些操作系統的實現功能中進一步釋放 Rust 語言的強表達能力來減輕我們的編碼負擔，本節我們嘗試在內核中支持動態內存分配，以能使用 Rust 核心庫中各種靈活的動態數據結構，如 Vec、HashMap 等，且不用考慮這些數據結構的動態內存釋放的繁瑣操作，充分利用 Rust 語言保證的內存安全能力。

靜態與動態內存分配
----------------------------------------------


靜態分配
^^^^^^^^^^^^^^^^^^^^^^^^^


若在某一時間點觀察一個應用的地址空間，可以看到若干個內存塊，每一塊都對應於一個生命週期尚未結束的變量。這個變量可能是一個局部變量，它來自於正在執行的當前函數調用棧上，即它是被分配在棧上；這個變量也可能是一個全局變量，它一般被分配在數據段中。它們有一個共同點：在編譯器編譯程序時已經知道這些變量所佔的字節大小，於是給它們分配一塊固定的內存將它們存儲其中，這樣變量在棧幀/數據段中的位置就被固定了下來。

.. _term-static-allocation:

這些變量是被 **靜態分配** (Static Allocation) 的，這一過程來源於我們在程序中對變量的聲明，在編譯期由編譯器完成。如果應用僅使用靜態分配，它可以應付一部分的需求，但是對於其它情況，如某些數據結構需求的內存大小取決於程序的實際運行情況，就不夠靈活了。比如，需要將一個文件讀到內存進行處理，而且必須將文件一次性完整讀進來處理。我們可以選擇聲明一個棧上的數組（局部變量）或者數據段中的數組（全局變量），作為緩衝區來暫存文件的內容。但我們在編程的時候並不知道待處理的文件大小，只能根據經驗將緩衝區的大小設置為某一固定常數。在程序真正運行的時候，如果待處理的文件很小，那麼緩衝區多出的部分被浪費掉了；如果待處理的文件很大，應用則無法正常運行。


動態分配
^^^^^^^^^^^^^^^^^^^^^^^^^


.. _term-dynamic-allocation:

如果使用 **動態分配** (Dynamic Allocation) 則可以解決上述問題。應用另外放置了一個大小可以隨著應用的運行動態增減的內存空間 -- 堆（Heap）。同時，應用還要能夠將這個堆管理起來，即支持在運行的時候從裡面分配一塊空間來存放變量，而在變量的生命週期結束之後，這塊空間需要被回收以待後面的使用。如果堆的大小固定，那麼這其實就是一個連續內存分配問題，同學們可以使用操作系統課上所介紹到的各種連續內存分配算法。一般情況下，應用所依賴的基礎系統庫（如 Linux 中的 glibc 庫等）會直接通過系統調用（如類 Unix 內核提供的 ``sbrk`` 系統調用）來向內核請求增加/縮減應用地址空間內堆的大小，之後應用就可以基於基礎系統庫提供的內存分配/釋放函數來獲取和釋放內存了。應用進行多次不同大小的內存分配和釋放操作後，會產生內存空間的浪費，即存在無法被應用使用的空閒內存碎片。

.. note::

    **內存碎片**

    內存碎片是指無法被分配和使用的空閒內存空間。可進一步細分為內碎片和外碎片：

    - 內碎片：已被分配出去（屬於某個在運行的應用）內存區域，佔有這些區域的應用並不使用這塊區域，操作系統也無法利用這塊區域。
    - 外碎片：還沒被分配出去（不屬於任何在運行的應用）內存空閒區域，由於太小而無法分配給提出申請內存空間的應用。

    為何應用開發者在編程中“看不到”內存碎片？這是因為動態內存管理是由更底層的系統標準庫來完成的，它能看到並進行管理。而應用開發者只需調用系統標準庫提供的內存申請/釋放函數接口即可。

鑑於動態分配是一項非常基礎的功能，很多高級語言的系統標準庫中都實現了它。以 C 語言為例，C 標準庫中提供瞭如下兩個動態分配
的接口函數：

.. code-block:: c

    void* malloc (size_t size);
    void free (void* ptr);

其中，``malloc`` 的作用是從堆中分配一塊大小為 ``size`` 字節的空間，並返回一個指向它的指針。而後續不用的時候，將這個指針傳給 ``free`` 即可在堆中回收這塊空間。我們通過返回的指針變量來 **間接** 訪問堆空間上的數據。事實上，我們在程序中能夠 **直接** 看到的變量都是被靜態分配在棧或者全局數據段上的，它們大小在編譯期已知。比如我們可以把固定大小的指針放到棧（局部變量）或數據段（全局變量）上，然後通過指針來指向運行時才確定的堆空間上的數據，並進行訪問。這樣就可以通過確定大小的指針來實現對編譯時大小不確定的堆數據的訪問。

除了可以靈活利用內存之外，動態分配還允許我們以儘可能小的代價靈活調整變量的生命週期。一個局部變量被靜態分配在它所在函數的棧幀中，一旦函數返回，這個局部變量的生命週期也就結束了；而靜態分配在數據段中的全局變量則是在應用的整個運行期間均存在。動態分配允許我們構造另一種並不一直存在也不綁定於函數調用的變量生命週期：以 C 語言為例，可以說自 ``malloc`` 拿到指向一個變量的指針到 ``free`` 將它回收之前的這段時間，這個變量在堆上存在。由於需要跨越函數調用，我們需要作為堆上數據代表的變量在函數間以參數或返回值的形式進行傳遞，而這些變量一般都很小（如一個指針），其拷貝開銷可以忽略。

而動態內存分配的缺點在於：它背後運行著連續內存分配算法，相比靜態分配會帶來一些額外的開銷。如果動態分配非常頻繁，可能會產生很多無法使用的內存碎片，甚至可能會成為應用的性能瓶頸。

.. _rust-heap-data-structures:

Rust 中的堆數據結構
------------------------------------------------

Rust 的標準庫中提供了很多開箱即用的堆數據結構，利用它們能夠大大提升我們的開發效率。

.. _term-smart-pointer:

首先是一類 **智能指針** (Smart Pointer) 。智能指針和 Rust 中的其他兩類指針：裸指針 ``*const T/*mut T`` 和引用 ``&T/&mut T`` 一樣，都指向地址空間中的另一個區域幷包含它的位置信息。但它們攜帶的信息數量不等，需要經過編譯器不同等級的安全檢查，所以它們在可靠性和靈活程度也有所不同。

.. _term-borrow-check:

- 裸指針 ``*const T/*mut T`` 基本等價於 C/C++ 裡面的普通指針 ``T*`` ，它自身的內容僅僅是一個地址。它最為靈活，但是也最不安全。編譯器只能對它進行最基本的可變性檢查（只讀的數據不能寫）， :ref:`第一章 <term-raw-pointer>` 曾經提到，通過裸指針解引用來訪問數據的行為是 unsafe 行為，需要被包裹在 unsafe 塊中。
- 引用 ``&T/&mut T`` 實質上只是一個地址範圍，但是 Rust 編譯器會在編譯的時候進行比較嚴格的 **借用檢查** (Borrow Check) ，來確保在編譯期就解決掉很多內存不安全問題。詳細內容可以參考 :ref:`Rust 所有權模型 <rust-ownership-model>` 。
- 智能指針不僅包含它指向區域的地址範圍，還含有一些額外的信息。從用途上看，它不僅可以作為一個媒介來訪問它指向的數據，還能在這個過程中起到管理和控制的功能。智能指針的大小通常大於裸指針，這被稱作 **胖指針** (Fat Pointer)。如果智能指針僅用堆維護元信息（如針對 ``Sided`` 類型的 ``Arc`` 與 ``Rc``），那麼它們“胖”在堆上，指針本身仍然是 8 字節的；反之，如果指針本身維護元信息（如 ``Mutex`` 和 ``Vec``），指針本身就會大於 8 字節。

具體可以參考下面這張 Rust 智能指針/容器及其他類型的內存佈局的 `經典圖示 <https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p>`_ 。

.. image:: rust-containers.png

在 Rust 中，與動態內存分配相關的智能指針主要有如下這些：

- ``Box<T>`` 在創建時會在堆上分配一個類型為 ``T`` 的變量，它自身也只保存在堆上的那個變量的位置。而和裸指針或引用不同的是，當 ``Box<T>`` 被回收的時候，它指向的那個變量（位於堆上）也會被回收。``Box<T>`` 可以對標 C++ 的 ``std::unique_ptr`` 。
- ``Rc<T>`` 是一個單線程上使用的引用計數類型，它提供了多所有權支持，即可同時存在多個智能指針指向同一個堆上變量的 ``Rc<T>`` ，它們都可以拿到指向變量的不可變引用來訪問這同一個變量。而它同時也是一個引用計數，事實上在堆上的另一個位置維護了這個變量目前被引用的次數 N ，即存在 N 個 ``Rc<T>`` 智能指針。這個計數會隨著 ``Rc<T>`` 智能指針的創建或複製而增加，並在 ``Rc<T>`` 智能指針生命週期結束時減少。當這個計數變為零之後，這個智能指針變量本身以及被引用的變量都會被回收。 ``Arc<T>`` 與 ``Rc<T>`` 功能相同，只是 ``Arc<T>`` 可以在多線程上使用。 ``Arc<T>`` 類似於 C++ 的 ``std::shared_ptr`` 。
- ``RefCell<T>`` 與  ``Box<T>`` 等智能指針不同，其 **借用檢查** 在運行時進行。對於 ``RefCell<T>`` ，如果違反借用規則，程序會編譯通過，但會在運行時 panic 並退出。使用 ``RefCell<T>`` 的好處是，可在其自身是不可變的情況下修改其內部的值。在Rust語言中，在不可變值內部改變值是一種 :ref:`內部可變性 <term-interior-mutability>` 的設計模式。
- ``Mutex<T>`` 是一個互斥鎖，在多線程中使用。它可以保護裡層的堆上的變量同一時間只有一個線程能對它進行操作，從而避免數據競爭，這是併發安全的問題，會在後面詳細說明。同時，它也能夠提供 :ref:`內部可變性 <term-interior-mutability>` 。``Mutex<T>`` 時常和 ``Arc<T>`` 配套使用，因為它是用來保護多線程（線程概念在後面會講，這裡可簡單理解為運行程序）可同時訪問的數據，其前提就是多個線程都拿到指向同一塊堆上數據的 ``Mutex<T>`` 。於是，要麼這個 ``Mutex<T>`` 作為全局變量被分配到數據段上，要麼將 ``Mutex<T>`` 包裹上一層多所有權 ``Arc`` ，變成 ``Arc<Mutex<T>>`` 這種經典組合結構，讓最裡層基於泛型 ``T`` 數據結構的變量可以在線程間安全傳遞。

  在講解 **同步互斥** 之前我們通過 ``RefCell<T>`` 來獲得內部可變性。可以將 ``Mutex<T>`` 看成 ``RefCell<T>`` 的多線程版本，
  因為 ``RefCell<T>`` 是隻能在單線程上使用的。而且 ``RefCell<T>`` 並不會在堆上分配內存，它僅用於基於數據段的靜態內存
  分配。 

.. _term-collection:
.. _term-container:

基於上述智能指針，可形成更強大的 **集合** (Collection) 或稱 **容器** (Container) 類型，它們負責管理一組數目可變的元素，這些元素的類型相同或是有著一些同樣的特徵。在 C++/Python/Java 等高級語言中我們已經對它們的使用方法非常熟悉了，對於 Rust 而言，我們可以直接使用以下容器：

- 向量 ``Vec<T>`` 類似於 C++ 中的 ``std::vector`` ；
- 鍵值對容器 ``BTreeMap<K, V>`` 類似於 C++ 中的 ``std::map`` ；
- 有序集合 ``BTreeSet<T>`` 類似於 C++ 中的 ``std::set`` ；
- 鏈表 ``LinkedList<T>`` 類似於 C++ 中的 ``std::list`` ；
- 雙端隊列 ``VecDeque<T>`` 類似於 C++ 中的 ``std::deque`` 。
- 變長字符串 ``String`` 類似於 C++ 中的 ``std::string`` 。

有對比才有更深入的理解，讓我們先來看其它一些語言使用動態內存的方式：

.. _term-reference-counting:
.. _term-garbage-collection:

- C 語言僅支持 ``malloc/free`` 這一對操作，它們必須恰好成對使用，否則就會出現各種內存錯誤。比如分配了之後沒有回收，則會導致內存洩漏；回收之後再次 free 相同的指針，則會造成 Double-Free 問題；又如回收之後再嘗試通過指針訪問它指向的區域，這屬於 Use-After-Free 問題。總之，這樣的內存安全問題層出不窮，畢竟人總是會犯錯的。
- Python/Java 通過 **引用計數** (Reference Counting) 對所有的對象進行運行時的動態管理，一套 **垃圾回收** (GC, Garbage Collection) 機制會被自動定期觸發，每次都會檢查所有的對象，如果其引用計數為零則可以將該對象佔用的內存從堆上回收以待後續其他的對象使用。這樣做完全杜絕了內存安全問題，但是性能開銷則很大，而且 GC 觸發的時機和每次 GC 的耗時都是無法預測的，還使得軟件的執行性能不夠確定。
- C++ 的智能指針（shared_ptr、unique_ptr、weak_ptr、auto_ptr等）和 **資源獲取即初始化** (RAII, Resource Acquisition Is Initialization，指將一個使用前必須獲取的資源的生命週期綁定到一個變量上，變量釋放時，對應的資源也一併釋放。) 風格都是致力於解決內存安全問題。但這些編程方式是“建議”而不是“強制”。

可以發現，在動態內存分配方面， Rust 和 C++ 很像，事實上 Rust 有意從 C++ 借鑑了這部分優秀特性，並強制Rust編程人員遵守 **借用規則** 。以 ``Box<T>`` 為例，在它被創建的時候，會在堆上分配一塊空間保存它指向的數據；而在 ``Box<T>`` 生命週期結束被回收的時候，堆上的那塊空間也會立即被一併回收。這也就是說，我們無需手動回收資源，它和綁定的變量會被自動回收；同時，由於編譯器清楚每個變量的生命週期，則變量對應的資源何時被回收是完全可預測的，回收操作的開銷也是確定的。在 Rust 中，不限於堆內存，將某種資源的生命週期與一個變量綁定的這種 RAII 的思想無處不在，甚至這種資源可能只是另外一種類型的變量。

.. _term-raii:

在內核中支持動態內存分配
--------------------------------------------------------

如果要在操作系統內核中支持動態內存分配，則需要實現在本節開始介紹的一系列功能：初始化堆、分配/釋放內存塊的函數接口、連續內存分配算法。相對於 C 語言而言，Rust語言在 ``alloc`` crate 中設定了一套簡潔規範的接口，只要實現了這套接口，內核就可以很方便地支持動態內存分配了。

上述與堆相關的智能指針或容器都可以在 Rust 自帶的 ``alloc`` crate 中找到。當我們使用 Rust 標準庫 ``std`` 的時候可以不用關心這個 crate ，因為標準庫內已經已經實現了一套堆管理算法，並將 ``alloc`` 的內容包含在 ``std`` 名字空間之下讓開發者可以直接使用。然而操作系統內核運行在禁用標準庫（即 ``no_std`` ）的裸機平臺上，核心庫 ``core`` 也並沒有動態內存分配的功能，這個時候就要考慮利用 ``alloc`` 庫定義的接口來實現基本的動態內存分配器。 

``alloc`` 庫需要我們提供給它一個 ``全局的動態內存分配器`` ，它會利用該分配器來管理堆空間，從而使得與堆相關的智能指針或容器數據結構可以正常工作。具體而言，我們的動態內存分配器需要實現它提供的 ``GlobalAlloc`` Trait，這個 Trait 有兩個必須實現的抽象接口：

.. code-block:: rust
    
    // alloc::alloc::GlobalAlloc

    pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);

可以看到，它們類似 C 語言中的 ``malloc/free`` ，分別代表堆空間的分配和回收，也同樣使用一個裸指針（也就是地址）作為分配的返回值和回收的參數。兩個接口中都有一個 ``alloc::alloc::Layout`` 類型的參數， 它指出了分配的需求，分為兩部分，分別是所需空間的大小 ``size`` ，以及返回地址的對齊要求 ``align`` 。這個對齊要求必須是一個 2 的冪次，單位為字節數，限制返回的地址必須是 ``align`` 的倍數。

.. note::

    **為何 C 語言 malloc 的時候不需要提供對齊需求？**

    在 C 語言中，所有對齊要求的最大值是一個平臺相關的常數（比如 8 bytes），消耗少量內存即可使得每一次分配都符合這個最大的對齊要求。因此也就不需要區分不同分配的對齊要求了。而在 Rust 中，某些分配的對齊要求的值可能很大，就只能採用更加複雜的方法。

然後只需將我們的動態內存分配器類型實例化為一個全局變量，並使用 ``#[global_allocator]`` 語義項標記即可。由於該分配器的實現比較複雜，我們這裡直接使用一個已有的夥伴分配器實現。首先添加 crate 依賴：

.. code-block:: toml

    # os/Cargo.toml

    buddy_system_allocator = "0.6"

接著，需要引入 ``alloc`` 庫的依賴，由於它算是 Rust 內置的 crate ，我們並不是在 ``Cargo.toml`` 中進行引入，而是在 ``main.rs`` 中聲明即可：

.. code-block:: rust

    // os/src/main.rs

    extern crate alloc;

然後，根據 ``alloc`` 留好的接口提供全局動態內存分配器：

.. code-block:: rust
    :linenos:

    // os/src/mm/heap_allocator.rs

    use buddy_system_allocator::LockedHeap;
    use crate::config::KERNEL_HEAP_SIZE;

    #[global_allocator]
    static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty();

    static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];

    pub fn init_heap() {
        unsafe {
            HEAP_ALLOCATOR
                .lock()
                .init(HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE);
        }
    }

- 第 7 行，我們直接將 ``buddy_system_allocator`` 中提供的 ``LockedHeap`` 實例化成一個全局變量，並使用 ``alloc`` 要求的 ``#[global_allocator]`` 語義項進行標記。注意 ``LockedHeap`` 已經實現了 ``GlobalAlloc`` 要求的抽象接口了。
- 第 11 行，在使用任何 ``alloc`` 中提供的堆數據結構之前，我們需要先調用 ``init_heap`` 函數來給我們的全局分配器一塊內存用於分配。在第 9 行可以看到，這塊內存是一個 ``static mut`` 且被零初始化的字節數組，位於內核的 ``.bss`` 段中。 ``LockedHeap`` 也是一個被互斥鎖 ``Mutex<T>`` 保護的類型，在對它任何進行任何操作之前都要先獲取鎖以避免其他線程同時對它進行操作導致數據競爭。然後，調用 ``init`` 方法告知它能夠用來分配的空間的起始地址和大小即可。

我們還需要處理動態內存分配失敗的情形，在這種情況下我們直接 panic ：

.. code-block:: rust

  // os/src/main.rs

  #![feature(alloc_error_handler)]

  // os/src/mm/heap_allocator.rs

  #[alloc_error_handler]
  pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
      panic!("Heap allocation error, layout = {:?}", layout);
  }

最後，讓我們嘗試一下動態內存分配吧！感興趣的同學可以在 ``rust_main`` 中嘗試調用下面的 ``heap_test`` 函數（調用 ``heap_test()`` 前要記得先調用 ``init_heap()`` ）。

.. code-block:: rust
    :linenos:

    // os/src/mm/heap_allocator.rs

    #[allow(unused)]
    pub fn heap_test() {
        use alloc::boxed::Box;
        use alloc::vec::Vec;
        extern "C" {
            fn sbss();
            fn ebss();
        }
        let bss_range = sbss as usize..ebss as usize;
        let a = Box::new(5);
        assert_eq!(*a, 5);
        assert!(bss_range.contains(&(a.as_ref() as *const _ as usize)));
        drop(a);
        let mut v: Vec<usize> = Vec::new();
        for i in 0..500 {
            v.push(i);
        }
        for i in 0..500 {
            assert_eq!(v[i], i);
        }
        assert!(bss_range.contains(&(v.as_ptr() as usize)));
        drop(v);
        println!("heap_test passed!");
    }

其中分別使用智能指針 ``Box<T>`` 和向量 ``Vec<T>`` 在堆上分配數據並管理它們，通過 ``as_ref`` 和 ``as_ptr`` 方法可以分別看到它們指向的數據的位置，能夠確認它們的確在位於 ``.bss`` 段的堆上。

.. note::

    本節部分內容參考自 `BlogOS 的相關章節 <https://os.phil-opp.com/heap-allocation/>`_ 。
