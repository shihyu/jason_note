練習
============================================

課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `**` 使用sbrk，mmap,munmap,mprotect內存相關係統調用的linux應用程序。
2. `***` 修改本章操作系統內核，實現任務和操作系統內核共用同一張頁表的單頁表機制。
3. `***` 擴展內核，支持基於缺頁異常機制，具有Lazy 策略的按需分頁機制。
4. `***` 擴展內核，支持基於缺頁異常的COW機制。（初始時，兩個任務共享一個只讀物理頁。當一個任務執行寫操作後，兩個任務擁有各自的可寫物理頁）
5. `***` 擴展內核，實現swap in/out機制，並實現Clock置換算法或二次機會置換算法。
6. `***` 擴展內核，實現自映射機制。

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. chyyuu   這次的實驗沒有涉及到缺頁有點遺憾，主要是缺頁難以測試，而且更多的是一種優化，不符合這次實驗的核心理念，所以這裡補兩道小題。

1. `*` 在使用高級語言編寫用戶程序的時候，手動用嵌入彙編的方法隨機訪問一個不在當前程序邏輯地址範圍內的地址，比如向該地址讀/寫數據。該用戶程序執行的時候可能會生什麼？
2. `*` 用戶程序在運行的過程中，看到的地址是邏輯地址還是物理地址？從用戶程序訪問某一個地址，到實際內存中的對應單元被讀/寫，會經過什麼樣的過程，這個過程中操作系統有什麼作用？（站在學過計算機組成原理的角度）
3. `*` 覆蓋、交換和虛擬存儲有何異同，虛擬存儲的優勢和挑戰體現在什麼地方？
4. `*` 什麼是局部性原理？為何很多程序具有局部性？局部性原理總是正確的嗎？為何局部性原理為虛擬存儲提供了性能的理論保證？
5. `**` 一條load指令，最多導致多少次頁訪問異常？嘗試考慮較多情況。
6. `**` 如果在頁訪問異常中斷服務例程執行時，再次出現頁訪問異常，這時計算機系統（軟件或硬件）會如何處理？這種情況可能出現嗎？
7. `*` 全局和局部置換算法有何不同？分別有哪些算法？
8. `*` 簡單描述OPT、FIFO、LRU、Clock、LFU的工作過程和特點 (不用寫太多字，簡明扼要即可)
9. `**` 綜合考慮置換算法的收益和開銷，綜合評判在哪種程序執行環境下使用何種算法比較合適？
10. `**` Clock算法僅僅能夠記錄近期是否訪問過這一信息，對於訪問的頻度幾乎沒有記錄，如何改進這一點？
11. `***` 哪些算法有belady現象？思考belady現象的成因，嘗試給出說明OPT和LRU等為何沒有belady現象。
12. `*` 什麼是工作集？什麼是常駐集？簡單描述工作集算法的工作過程。
13. `*` 請列舉 SV39 頁`*` 頁表項的組成，結合課堂內容，描述其中的標誌位有何作用／潛在作用？
14. `**` 請問一個任務處理 10G 連續的內存頁面，需要操作的頁表實際大致佔用多少內存(給出數量級即可)？
15. `**`  缺頁指的是進程訪問頁面時頁面不在頁表中或在頁表中無效的現象，此時 MMU 將會返回一箇中斷，告知操作系統：該進程內存訪問出了問題。然後操作系統可選擇填補頁表並重新執行異常指令或者殺死進程。操作系統基於缺頁異常進行優化的兩個常見策略中，其一是 Lazy 策略，也就是直到內存頁面被訪問才實際進行頁表操作。比如，一個程序被執行時，進程的代碼段理論上需要從磁盤加載到內存。但是 操作系統並不會馬上這樣做，而是會保存 .text 段在磁盤的位置信息，在這些代碼第一次被執行時才完成從磁盤的加載操作。 另一個常見策略是 swap 頁置換策略，也就是內存頁面可能被換到磁盤上了，導致對應頁面失效，操作系統在任務訪問到該頁產生異常時，再把數據從磁盤加載到內存。

    - 哪些異常可能是缺頁導致的？發生缺頁時，描述與缺頁相關的CSR寄存器的值及其含義。
    - Lazy 策略有哪些好處？請描述大致如何實現Lazy策略？
    - swap 頁置換策略有哪些好處？此時頁面失效如何表現在頁表項(PTE)上？請描述大致如何實現swap策略？
  
16. `**` 為了防範側信道攻擊，本章的操作系統使用了雙頁表。但是傳統的操作系統設計一般採用單頁表，也就是說，任務和操作系統內核共用同一張頁表，只不過內核對應的地址只允許在內核態訪問。(備註：這裡的單/雙的說法僅為自創的通俗說法，並無這個名詞概念，詳情見 `KPTI <https://en.wikipedia.org/wiki/Kernel_page-table_isolation>`_ )

    - 單頁表情況下，如何控制用戶態無法訪問內核頁面？
    - 相對於雙頁表，單頁表有何優勢？
    - 請描述：在單頁表和雙頁表模式下，分別在哪個時機，如何切換頁表？


實驗練習
-------------------------------

實驗練習包括實踐作業和問答作業兩部分。

實踐作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

重寫 sys_get_time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

引入虛存機制後，原來內核的 sys_get_time 函數實現就無效了。請你重寫這個函數，恢復其正常功能。

mmap 和 munmap 匿名映射
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`mmap <https://man7.org/linux/man-pages/man2/mmap.2.html>`_ 在 Linux 中主要用於在內存中映射文件，本次實驗簡化它的功能，僅用於申請內存。

請實現 mmap 和 munmap 系統調用，mmap 定義如下：


.. code-block:: rust

    fn sys_mmap(start: usize, len: usize, prot: usize) -> isize

- syscall ID：222
- 申請長度為 len 字節的物理內存（不要求實際物理內存位置，可以隨便找一塊），將其映射到 start 開始的虛存，內存頁屬性為 prot
- 參數：
    - start 需要映射的虛存起始地址，要求按頁對齊
    - len 映射字節長度，可以為 0
    - prot：第 0 位表示是否可讀，第 1 位表示是否可寫，第 2 位表示是否可執行。其他位無效且必須為 0
- 返回值：執行成功則返回 0，錯誤返回 -1
- 說明：
    - 為了簡單，目標虛存區間要求按頁對齊，len 可直接按頁向上取整，不考慮分配失敗時的頁回收。
- 可能的錯誤：
    - start 沒有按頁大小對齊
    - prot & !0x7 != 0 (prot 其餘位必須為0)
    - prot & 0x7 = 0 (這樣的內存無意義)
    - [start, start + len) 中存在已經被映射的頁
    - 物理內存不足

munmap 定義如下：

.. code-block:: rust

    fn sys_munmap(start: usize, len: usize) -> isize

- syscall ID：215
- 取消到 [start, start + len) 虛存的映射
- 參數和返回值請參考 mmap
- 說明：
    - 為了簡單，參數錯誤時不考慮內存的恢復和回收。
- 可能的錯誤：
    - [start, start + len) 中存在未被映射的虛存。


TIPS：注意 prot 參數的語義，它與內核定義的 MapPermission 有明顯不同！

實驗要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 實現分支：ch4-lab
- 實驗目錄要求不變
- 通過所有測例

  在 os 目錄下 ``make run TEST=1`` 測試 sys_get_time， ``make run TEST=2`` 測試 map 和 unmap。

challenge: 支持多核。

問答作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

無

實驗練習的提交報告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 簡單總結本次實驗與上個實驗相比你增加的東西。（控制在5行以內，不要貼代碼）
* 完成問答問題。
* (optional) 你對本次實驗設計及難度的看法。
   