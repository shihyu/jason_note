練習參考答案
=====================================================

.. toctree::
      :hidden:
      :maxdepth: 4

課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在Linux環境中，基於pthread線程，有一系列的系統調用實現對應用程序的線程間同步互斥的支持。

信號量是一種特殊的變量，可用於線程同步。它只取自然數值，並且只支持兩種操作：P(SV): 如果信號量SV大於0，將它減一；如果SV值為0，則掛起該線程。V(SV)： 如果有其他進程因為等待SV而掛起，則喚醒，然後將SV+1；否則直接將SV+1。其系統調用為：

- `sem_wait(sem_t *sem)`：以原子操作的方式將信號量減1，如果信號量值為0，則sem_wait將被阻塞，直到這個信號量具有非0值。
- `sem_post(sem_t *sem)`：以原子操作將信號量值+1。當信號量大於0時，其他正在調用sem_wait等待信號量的線程將被喚醒。
  
互斥量：互斥量又稱互斥鎖，主要用於線程互斥，不能保證按序訪問，可以和條件鎖一起實現同步。當進入臨界區 時，需要獲得互斥鎖並且加鎖；當離開臨界區時，需要對互斥鎖解鎖，以喚醒其他等待該互斥鎖的線程。其主要的系統調用如下：

- `pthread_mutex_init`: 初始化互斥鎖
- `pthread_mutex_destroy`： 銷燬互斥鎖
- pthread_mutex_lock： 以原子操作的方式給一個互斥鎖加鎖，如果目標互斥鎖已經被上鎖，pthread_mutex_lock調用將阻塞，直到該互斥鎖的佔有者將其解鎖。
- `pthread_mutex_unlock`: 以一個原子操作的方式給一個互斥鎖解鎖。


條件變量:條件變量，又稱條件鎖，用於在線程之間同步共享數據的值。條件變量提供一種線程間通信機制：當某個共享數據達到某個值時，喚醒等待這個共享數據的一個/多個線程。即，當某個共享變量等於某個值時，調用 signal/broadcast。此時操作共享變量時需要加鎖。其主要的系統調用如下：

- `pthread_cond_init`: 初始化條件變量
- `pthread_cond_destroy`： 銷燬條件變量
- `pthread_cond_signal`： 喚醒一個等待目標條件變量的線程。哪個線程被喚醒取決於調度策略和優先級。
- `pthread_cond_wait`： 等待目標條件變量。需要一個加鎖的互斥鎖確保操作的原子性。該函數中在進入wait狀態前首先進行解鎖，然後接收到信號後會再加鎖，保證該線程對共享資源正確訪問。

1. `**` 在Linux環境下，請用信號量實現哲學家就餐的多線程應用程序。
2. `**` 在Linux環境下，請用互斥鎖和條件變量實現哲學家就餐的多線程應用程序。
3. `**` 在Linux環境下，請建立一個多線程的模擬資源分配管理庫，可通過銀行家算法來避免死鎖。
4. `**`  擴展內核功能，實現讀者優先的讀寫信號量。
5. `**`  擴展內核功能，實現寫者優先的讀寫信號量。
6. `***` 擴展內核功能，在內核中支持內核線程。
7. `***` 進一步擴展內核功能，在內核線程中支持同步互斥機制，實現內核線程用的mutex, semaphore, cond-var。
8. `***` 擴展內核功能，實現多核支持下的同步互斥機制。
9. `***` 解決優先級反轉問題：實現RM實時調度算法，設計優先級反轉的實例，實現優先級天花板和優先級繼承方法。

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


1. `*` 什麼是並行？什麼是併發？

* "並行" 指的是同時進行多個任務。在多 CPU 環境中，計算機具有多個獨立的 CPU，可以同時執行多個任務。例如，如果你有兩個 CPU，那麼它們可以同時運行兩個不同的程序，這樣它們就是並行的。
* "併發" 指的是多個任務的同時發生，但它們不一定是同時執行的。在單 CPU 環境中，併發和並行是通過 CPU 快速地在多個任務之間切換來模擬同時發生的效果。例如，如果你在同時運行多個程序，那麼 CPU 可以快速地在這些程序之間切換，從而模擬它們同時發生的效果。這種情況下，這些程序是併發的，但不是並行的。

2. `*` 為了創造臨界區，單核處理器上可以【關中斷】，多核處理器上需要使用【自旋鎖】。請回答下列問題：

   - 多核上可不可以只用【關中斷】？ 
        * 在多核處理器上僅使用關中斷（disable interrupt）來實現臨界區是不可行的，因為關中斷只能保證當前核上的代碼不會被中斷，但不能保證其他核上的代碼不會進入臨界區，對共享數據進行修改。
   - 單核上可不可以只用【自旋鎖】？
        * 單核處理器上可以使用自旋鎖來實現臨界區，但是並不是必須使用自旋鎖，如上述的關中斷。
   - 多核上的【自旋鎖】是否需要同時【關中斷】？
        * 對於多核處理器上的自旋鎖，通常不需要關中斷來創建臨界區。相反，自旋鎖的實現會使用處理器提供的硬件特性來確保原子性，例如原子操作、內存屏障等。這種方式能夠避免全局中斷，從而提高系統的性能。
   - [進階] 假如某個鎖不會在中斷處理函數中被訪問，是否還需要【關中斷】？
        * 在單核處理器上，如果所有的代碼都是在同一個上下文中運行，也就是沒有中斷或者線程切換的情況下，如果在代碼中使用鎖來保護共享資源，那麼可以使用簡單的互斥鎖來實現臨界區的保護，而不需要關中斷。
        * 在多核處理器上，不同的核心可以獨立運行不同的線程，彼此之間不會互相干擾。在這種情況下，可以使用自旋鎖等更高效的同步機制來實現臨界區的保護。如果代碼中使用的鎖需要在中斷處理函數中被訪問，那麼在多核處理器上需要關中斷來保護臨界區。在中斷處理函數中，由於上下文的切換，可能會發生競爭條件，因此需要通過關中斷的方式來避免這種競爭。這樣可以保證在中斷處理函數執行期間，不會有其他線程在訪問共享資源，從而保證臨界區的安全性。

3. `**` Linux的多線程應用程序使用的鎖（例如 pthread_mutex_t）不是自旋鎖，當上鎖失敗時會切換到其它進程執行。分析它和自旋鎖的優劣，並說明為什麼它不用自旋鎖？

互斥鎖和自旋鎖的優劣：互斥鎖和自旋鎖的本質區別在於加鎖失敗時，是否會釋放CPU。互斥鎖在加鎖失敗時，會釋放CPU，因此與自旋鎖相比它的主要優勢在於可以提高處理器的資源利用率，避免CPU空轉的現象，但與之帶來的是互斥鎖的開銷更大。這些開銷主要包括兩次線程上下文切換的成本：
   * 當線程加鎖失敗時，內核會把線程的狀態從「運行」狀態設置為「睡眠」狀態，然後把 CPU 切換給其他線程運行；
   * 接著，當鎖被釋放時，之前「睡眠」狀態的線程會變為「就緒」狀態，然後內核會在合適的時間，把 CPU 切換給該線程運行。


不使用自旋鎖的原因是：
   * 可移植性：pthread_mutex_t是POSIX標準中定義的一種互斥鎖，不僅可以在Linux系統上使用，還可以在其他的POSIX兼容系統上使用，提高了應用程序的可移植性。
   * 性能：自旋鎖在多核處理器上可以提高併發性能，但是在單核處理器上可能會降低性能，因為自旋鎖需要不斷地檢查鎖的狀態，如果鎖一直處於被佔用的狀態，就會一直佔用處理器時間。而pthread_mutex_t是一種阻塞鎖，在鎖被佔用時，會將線程掛起，讓出處理器時間，從而避免了空轉浪費處理器資源的情況。
   * 死鎖：使用自旋鎖需要非常小心，否則容易出現死鎖的情況。例如，當一個線程持有一個自旋鎖並等待另一個自旋鎖時，如果另一個線程持有了這個自旋鎖並等待第一個自旋鎖，就會出現死鎖。而pthread_mutex_t是一種阻塞鎖，在鎖的等待隊列中維護了線程的等待關係，可以避免死鎖的情況。

4. `***` 程序在運行時具有兩種性質：safety: something bad will never happen；liveness: something good will eventually occur. 分析並證明 Peterson 算法的 safety 和 liveness 性質。

下面是這兩個性質的證明：

* Safety性質：
   假設同時有兩個線程$P_0$和$P_1$，它們都試圖進入其臨界區，即執行關鍵代碼段。如果兩個線程同時進入關鍵代碼段，就會發生競態條件，可能導致不正確的結果。因此，我們希望確保只有一個線程能夠進入其臨界區。
   
   Peterson算法確保了只有一個線程可以進入其臨界區。這是因為，在進入臨界區之前，線程必須首先嚐試獲取鎖。如果另一個線程已經獲得了鎖，則當前線程將被阻塞，直到另一個線程釋放鎖。因此，只有一個線程可以進入其臨界區，這證明了Peterson算法的safety性質。

* Liveness性質：
   我們需要證明，如果一個線程嘗試進入其臨界區，則它最終將能夠進入。假設線程$P_0$和$P_1$都試圖進入其臨界區。如果線程$P_0$先嚐試進入其臨界區，則線程$P_1$會被阻塞，直到線程$P_0$退出其臨界區並釋放鎖。反之亦然。
   
   假設線程$P_0$試圖進入其臨界區，但是線程$P_1$已經佔用了鎖並且正在執行其臨界區。線程$P_0$將被阻塞，並等待線程$P_1$釋放鎖。線程$P_1$將在其臨界區內執行，並最終退出其臨界區並釋放鎖。此時，線程$P_0$將獲得鎖，並能夠進入其臨界區。同樣，如果線程$P_1$試圖進入其臨界區，那麼也將發生類似的過程。

因此，Peterson算法保證了線程能夠最終進入其臨界區，這證明了Peterson算法的liveness性質。

1. `*` 信號量結構中的整數分別為+n、0、-n 的時候，各自代表什麼狀態或含義？

* +n：還有 n 個可用資源
* 0：所有可用資源恰好耗盡
* -n：有n個進程申請了資源但無資源可用，被阻塞。

6.  `**` 考慮如下信號量實現代碼：

.. code-block:: rust

    class Semaphore {
      int sem;
      WaitQueue q;
    }
    Semaphore::P() {
      sem --;
      if(sem < 0) {
        Add this thread to q.
        block.
      }
    }
    Semaphore::V() {
      sem ++;
      if(sem <= 0) {
        t = Remove a thread from q;
        wakeup(t);
      }
    }

假如 P操作或V操作不是原子操作，會出現什麼問題？舉一個例子說明。上述代碼能否運行在用戶態？上面代碼的原子性是如何保證的？

      如果P操作或V操作不是原子操作，將無法實現資源的互斥訪問。P操作和V操作都是通過關中斷來實現的（可以再確認一下這點）。上述代碼不能運行在用戶態，因為這將帶給用戶態程序使能/屏蔽中斷這種特權，相當於相信應用並放權給它。這會面臨和我們引入搶佔式調度之前一樣的問題：線程可以選擇惡意永久關閉中斷而獨佔所有 CPU 資源，這將會影響到整個系統的正常運行。因此，事實上至少在 RISC-V 這樣含多個特權級的架構中，這甚至是完全做不到的。

7.  `**` 條件變量的 Wait 操作為什麼必須關聯一個鎖？

當調用條件變量的 wait 操作阻塞當前線程的時候，該操作是在管程過程中，因此此時當前線程持有鎖。在持有鎖的情況下不能陷入阻塞 ，因此在陷入阻塞狀態之前當前線程必須先釋放鎖；當被阻塞的線程被其他線程使用 signal 操作喚醒之後，需要重新獲取到鎖才能繼續執行，不然的話就無法保證管程過程的互斥訪問。

因此，站在線程的視角，必須持有鎖才能調用條件變量的 wait 操作阻塞自身。

8. `**` 下面是條件變量的wait操作實現偽代碼：

.. code-block:: rust

    Condvar::wait(lock) {
      Add this thread to q.
      lock.unlock();
      schedule();
      lock.lock();
    }

如果改成下面這樣：

.. code-block:: rust

    Condvar::wait() {
      Add this thread to q.
      schedule();
    }
    lock.unlock();
    condvar.wait();
    lock.lock();

會出現什麼問題？舉一個例子說明。

      這種情況就是第7題提到的條件變量的wait操作沒有關聯一個鎖。會造成被阻塞的線程被其他線程使用 signal 操作喚醒之後，無法獲取鎖，從而無法保證管程過程的互斥訪問，導致管程失效。

9. `*` 死鎖的必要條件是什麼？

死鎖的四個必要條件：

* 互斥條件：一個資源每次只能被一個進程使用。
* 請求與保持條件：一個進程因請求資源而阻塞時，對已獲得的資源保持不放。
* 不剝奪條件:進程已獲得的資源，在末使用完之前，不能被其他進程強行剝奪。
* 循環等待條件:若干進程之間形成一種頭尾相接的循環等待資源關係。

這四個條件是死鎖的必要條件，只要系統發生死鎖，這些條件必然成立，而只要上述條件之一不滿足，就不會發生死鎖。

10.  `*` 什麼是死鎖預防，舉例並分析。

預防死鎖只需要破壞死鎖的四個必要條件之一即可，例如：

* 破壞互斥條件
* 破壞不可剝奪條件： 當進程的新資源不可取得時，釋放自己已有的資源，待以後需要時重新申請。
* 破壞請求並保持條件：進程在運行前一次申請完它所需要的全部資源，在它的資源為滿足前，不把它投入運行。一旦投入運行，這些資源都歸它所有，不能被剝奪。
* 破壞循環等待條件：給鎖/訪問的資源進行排序，要求每個線程都按照排好的順序依次申請鎖和訪問資源


11.   `**` 描述銀行家算法如何判斷安全性。

* 設置兩個向量:工作向量Work，表示操作系統可提供給線程繼續運行所需的各類資源數目，它含有m個元素，初始時，Work = Available；結束向量Finish，表示系統是否有足夠的資源分配給線程，使之運行完成。初始時 Finish[0..n-1] = false，表示所有線程都沒結束；當有足夠資源分配給線程時，設置Finish[i] = true。
* 從線程集合中找到一個能滿足下述條件的線程

.. code-block:: c

      Finish[i] == false;
      Need[i,j] <= Work[j];

若找到，執行步驟3，否則，執行步驟4。

* 當線程thr[i]獲得資源後，可順利執行，直至完成，並釋放出分配給它的資源，故應執行:

.. code-block:: c

      Work[j] = Work[j] + Allocation[i,j];
      Finish[i] = true;

跳轉回步驟2

* 如果Finish[0..n-1] 都為true，則表示系統處於安全狀態；否則表示系統處於不安全狀態。

通過操作系統調度，如銀行家算法來避免死鎖不是廣泛使用的通用方案。因為從線程執行的一般情況上看，銀行家算法需要提前獲知線程總的資源申請量，以及未來的每一次請求，而這些請求對於一般線程而言在運行前是不可知或隨機的。另外，即使在某些特殊情況下，可以提前知道線程的資源申請量等信息，多重循環的銀行家算法開銷也是很大的，不適合於對性能要求很高的操作系統中。

實驗練習
-------------------------------

實驗練習包括實踐作業和問答作業兩部分。


編程作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

銀行家算法——分數更新
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. note::
    
    本實驗為用戶態實驗，請在 Linux 環境下完成。

背景：在智能體大賽平臺 `Saiblo <https://www.saiblo.net>`_ 網站上每打完一場雙人天梯比賽後需要用 ELO 算法更新雙方比分。由於 Saiblo 的評測機併發性很高，且 ELO 算法中的分值變動與雙方變動前的分數有關，因此更新比分前時必須先為兩位選手加鎖。

作業：請模擬一下上述分數更新過程，簡便起見我們簡化為有 p 位選手參賽（編號 [0, p) 或 [1, p] ），初始分值為 1000 分，有 m 個評測機線程（生產者）給出隨機的評測結果（兩位不同選手的編號以及勝負結果，結果可能為平局），有 n 個 worker 線程（消費者）獲取結果隊列並更新數據庫（全局變量等共享數據）記錄的分數。m 個評測機各自模擬 k 場對局結果後結束線程，全部對局比分更新完成後主線程打印每位選手最終成績以及所有選手分數之和。

上述參數 p、m、n、k 均為可配置參數（命令行傳參或程序啟動時從stdin輸入）。

簡便起見不使用 ELO 算法，簡化更新規則為：若不為平局，當 勝者分數 >= 敗者分數 時勝者 +20，敗者 -20，否則勝者 +30，敗者 -30；若為平局，分高者 -10，分低者+10（若本就同分保持則不變）。

消費者核心部分可參考如下偽碼：
    獲取選手A的鎖
    獲取選手B的鎖
    更新A、B分數
    睡眠 1ms（模擬數據庫更新延時）
    釋放選手B的鎖
    釋放選手A的鎖

tips:
    - 由於 ELO 以及本題中給出的簡化更新算法均為零和算法，因此出現衝突後可以從所有選手分數之和明顯看出來，正確處理時它應該永遠為 1000p
    - 將一個 worker 線程看作哲學家，將 worker 正在處理的一場對局的兩位選手看作兩根筷子，則得到了經典的哲學家就餐問題

實現 eventfd
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 Linux 中有一種用於事件通知的文件描述符，稱為 eventfd 。其核心是一個 64 位無符號整數的計數器，在非信號量模式下，若計數器值不為零，則 `read` 函數會從中讀出計數值並將其清零，否則讀取失敗； `write` 函數將緩衝區中的數值加入到計數器中。在信號量模式下，若計數器值非零，則 `read` 操作將計數值減一，並返回 1 ； `write` 將計數值加一。我們將實現一個新的系統調用： `sys_eventfd2` 。

**eventfd**：

    * syscall ID: 290
    * 功能：創建一個 eventfd， `eventfd 標準接口 <https://linux.die.net/man/2/eventfd>`_ 。
    * C 接口： ``int eventfd(unsigned int initval, int flags)``
    * Rust 接口： ``fn eventfd(initval: u32, flags: i32) -> i32``
    * 參數：
        * initval: 計數器的初值。
        * flags: 可以設置為 0 或以下兩個 flag 的任意組合（按位或）：
            * EFD_SEMAPHORE (1) ：設置該 flag 時，將以信號量模式創建 eventfd 。
            * EFD_NONBLOCK (2048) ：若設置該 flag ，對 eventfd 讀寫失敗時會返回 -2 ，否則將阻塞等待直至讀或寫操作可執行為止。
    * 說明：
        * 通過 `write` 寫入 eventfd 時，緩衝區大小必須為 8 字節。
        * 進程 `fork` 時，子進程會繼承父進程創建的 eventfd ，且指向同一個計數器。
    * 返回值：如果出現了錯誤則返回 -1，否則返回創建成功的 eventfd 編號。
    * 可能的錯誤
        * flag 不合法。
        * 創建的文件描述符數量超過進程限制

.. note::
    還有一個 `sys_eventfd` 系統調用（調用號 284），與 `sys_eventfd2` 的區別在於前者不支持傳入 flags 。

    Linux 中的原生異步 IO 接口 libaio 就使用了 eventfd 作為內核完成 IO 操作之後通知應用程序的機制。


  
實驗要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 完成分支: ch8-lab
- 實驗目錄要求不變。
- 通過所有測例。

問答作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

無

實驗練習的提交報告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 簡單總結本次實驗與上個實驗相比你增加的東西。（控制在5行以內，不要貼代碼）
* 完成問答問題
* (optional) 你對本次實驗設計及難度的看法。
