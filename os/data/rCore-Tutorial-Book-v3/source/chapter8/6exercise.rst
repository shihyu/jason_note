練習
===========================================

課後練習
-------------------------------

編程題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在Linux環境中，基於pthread線程，有一系列的系統調用實現對應用程序的線程間同步互斥的支持。

信號量是一種特殊的變量，可用於線程同步。它只取自然數值，並且只支持兩種操作：P(SV): 如果信號量SV大於0，將它減一；如果SV值為0，則掛起該線程。V(SV)： 如果有其他進程因為等待SV而掛起，則喚醒，然後將SV+1；否則直接將SV+1。其系統調用為：

- `sem_wait(sem_t *sem)`：以原子操作的方式將信號量減1，如果信號量值為0，則sem_wait將被阻塞，直到這個信號量具有非0值。
- `sem_post(sem_t *sem)`：以原子操作將信號量值+1。當信號量大於0時，其他正在調用sem_wait等待信號量的線程將被喚醒。
  
互斥量：互斥量又稱互斥鎖，主要用於線程互斥，不能保證按序訪問，可以和條件鎖一起實現同步。當進入臨界區 時，需要獲得互斥鎖並且加鎖；當離開臨界區時，需要對互斥鎖解鎖，以喚醒其他等待該互斥鎖的線程。其主要的系統調用如下：

- `pthread_mutex_init`: 初始化互斥鎖
- `pthread_mutex_destroy`： 銷燬互斥鎖
- pthread_mutex_lock： 以原子操作的方式給一個互斥鎖加鎖，如果目標互斥鎖已經被上鎖，pthread_mutex_lock調用將阻塞，直到該互斥鎖的佔有者將其解鎖。
- `pthread_mutex_unlock`: 以一個原子操作的方式給一個互斥鎖解鎖。


條件變量:條件變量，又稱條件鎖，用於在線程之間同步共享數據的值。條件變量提供一種線程間通信機制：當某個共享數據達到某個值時，喚醒等待這個共享數據的一個/多個線程。即，當某個共享變量等於某個值時，調用 signal/broadcast。此時操作共享變量時需要加鎖。其主要的系統調用如下：

- `pthread_cond_init`: 初始化條件變量
- `pthread_cond_destroy`： 銷燬條件變量
- `pthread_cond_signal`： 喚醒一個等待目標條件變量的線程。哪個線程被喚醒取決於調度策略和優先級。
- `pthread_cond_wait`： 等待目標條件變量。需要一個加鎖的互斥鎖確保操作的原子性。該函數中在進入wait狀態前首先進行解鎖，然後接收到信號後會再加鎖，保證該線程對共享資源正確訪問。

1. `**` 在Linux環境下，請用信號量實現哲學家就餐的多線程應用程序。
2. `**` 在Linux環境下，請用互斥鎖和條件變量實現哲學家就餐的多線程應用程序。
3. `**` 在Linux環境下，請建立一個多線程的模擬資源分配管理庫，可通過銀行家算法來避免死鎖。
4. `**`  擴展內核功能，實現讀者優先的讀寫信號量。
5. `**`  擴展內核功能，實現寫者優先的讀寫信號量。
6. `***` 擴展內核功能，在內核中支持內核線程。
7. `***` 進一步擴展內核功能，在內核線程中支持同步互斥機制，實現內核線程用的mutex, semaphore, cond-var。
8. `***` 擴展內核功能，實現多核支持下的同步互斥機制。
9. `***` 解決優先級反轉問題：實現RM實時調度算法，設計優先級反轉的實例，實現優先級天花板和優先級繼承方法。

問答題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 什麼是並行？什麼是併發？
2. `*` 為了創造臨界區，單核處理器上可以【關中斷】，多核處理器上需要使用【自旋鎖】。請回答下列問題：

    - 多核上可不可以只用【關中斷】？ 
    - 單核上可不可以只用【自旋鎖】？
    - 多核上的【自旋鎖】是否需要同時【關中斷】？
    - [進階] 假如某個鎖不會在中斷處理函數中被訪問，是否還需要【關中斷】？

3. `**` Linux的多線程應用程序使用的鎖（例如 pthread_mutex_t）不是自旋鎖，當上鎖失敗時會切換到其它進程執行。分析它和自旋鎖的優劣，並說明為什麼它不用自旋鎖？
4. `***` 程序在運行時具有兩種性質：safety: something bad will never happen；liveness: something good will eventually occur. 分析並證明 Peterson 算法的 safety 和 liveness 性質。
5. `*` 信號量結構中的整數分別為+n、0、-n 的時候，各自代表什麼狀態或含義？
6.  `**` 考慮如下信號量實現代碼：

.. code-block:: rust

    class Semaphore {
      int sem;
      WaitQueue q;
    }
    Semaphore::P() {
      sem --;
      if(sem < 0) {
        Add this thread to q.
        block.
      }
    }
    Semaphore::V() {
      sem ++;
      if(sem <= 0) {
        t = Remove a thread from q;
        wakeup(t);
      }
    }

假如 P操作或V操作不是原子操作，會出現什麼問題？舉一個例子說明。上述代碼能否運行在用戶態？上面代碼的原子性是如何保證的？

7.  `**` 條件變量的 Wait 操作為什麼必須關聯一個鎖？

8. `**` 下面是條件變量的wait操作實現偽代碼：

.. code-block:: rust

    Condvar::wait(lock) {
      Add this thread to q.
      lock.unlock();
      schedule();
      lock.lock();
    }

如果改成下面這樣：

.. code-block:: rust

    Condvar::wait() {
      Add this thread to q.
      schedule();
    }
    lock.unlock();
    condvar.wait();
    lock.lock();

會出現什麼問題？舉一個例子說明。

9. `*` 死鎖的必要條件是什麼？
10. `*` 什麼是死鎖預防，舉例並分析。
11. `**` 描述銀行家算法如何判斷安全性。

實驗練習
-------------------------------

實驗練習包括實踐作業和問答作業兩部分。


編程作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

銀行家算法——分數更新
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. note::
    
    本實驗為用戶態實驗，請在 Linux 環境下完成。

背景：在智能體大賽平臺 `Saiblo <https://www.saiblo.net>`_ 網站上每打完一場雙人天梯比賽後需要用 ELO 算法更新雙方比分。由於 Saiblo 的評測機併發性很高，且 ELO 算法中的分值變動與雙方變動前的分數有關，因此更新比分前時必須先為兩位選手加鎖。

作業：請模擬一下上述分數更新過程，簡便起見我們簡化為有 p 位選手參賽（編號 [0, p) 或 [1, p] ），初始分值為 1000 分，有 m 個評測機線程（生產者）給出隨機的評測結果（兩位不同選手的編號以及勝負結果，結果可能為平局），有 n 個 worker 線程（消費者）獲取結果隊列並更新數據庫（全局變量等共享數據）記錄的分數。m 個評測機各自模擬 k 場對局結果後結束線程，全部對局比分更新完成後主線程打印每位選手最終成績以及所有選手分數之和。

上述參數 p、m、n、k 均為可配置參數（命令行傳參或程序啟動時從stdin輸入）。

簡便起見不使用 ELO 算法，簡化更新規則為：若不為平局，當 勝者分數 >= 敗者分數 時勝者 +20，敗者 -20，否則勝者 +30，敗者 -30；若為平局，分高者 -10，分低者+10（若本就同分保持則不變）。

消費者核心部分可參考如下偽碼：
    獲取選手A的鎖
    獲取選手B的鎖
    更新A、B分數
    睡眠 1ms（模擬數據庫更新延時）
    釋放選手B的鎖
    釋放選手A的鎖

tips:
    - 由於 ELO 以及本題中給出的簡化更新算法均為零和算法，因此出現衝突後可以從所有選手分數之和明顯看出來，正確處理時它應該永遠為 1000p
    - 將一個 worker 線程看作哲學家，將 worker 正在處理的一場對局的兩位選手看作兩根筷子，則得到了經典的哲學家就餐問題

實現 eventfd
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 Linux 中有一種用於事件通知的文件描述符，稱為 eventfd 。其核心是一個 64 位無符號整數的計數器，在非信號量模式下，若計數器值不為零，則 `read` 函數會從中讀出計數值並將其清零，否則讀取失敗； `write` 函數將緩衝區中的數值加入到計數器中。在信號量模式下，若計數器值非零，則 `read` 操作將計數值減一，並返回 1 ； `write` 將計數值加一。我們將實現一個新的系統調用： `sys_eventfd2` 。

**eventfd**：

    * syscall ID: 290
    * 功能：創建一個 eventfd， `eventfd 標準接口 <https://linux.die.net/man/2/eventfd>`_ 。
    * C 接口： ``int eventfd(unsigned int initval, int flags)``
    * Rust 接口： ``fn eventfd(initval: u32, flags: i32) -> i32``
    * 參數：
        * initval: 計數器的初值。
        * flags: 可以設置為 0 或以下兩個 flag 的任意組合（按位或）：
            * EFD_SEMAPHORE (1) ：設置該 flag 時，將以信號量模式創建 eventfd 。
            * EFD_NONBLOCK (2048) ：若設置該 flag ，對 eventfd 讀寫失敗時會返回 -2 ，否則將阻塞等待直至讀或寫操作可執行為止。
    * 說明：
        * 通過 `write` 寫入 eventfd 時，緩衝區大小必須為 8 字節。
        * 進程 `fork` 時，子進程會繼承父進程創建的 eventfd ，且指向同一個計數器。
    * 返回值：如果出現了錯誤則返回 -1，否則返回創建成功的 eventfd 編號。
    * 可能的錯誤
        * flag 不合法。
        * 創建的文件描述符數量超過進程限制

.. note::
    還有一個 `sys_eventfd` 系統調用（調用號 284），與 `sys_eventfd2` 的區別在於前者不支持傳入 flags 。

    Linux 中的原生異步 IO 接口 libaio 就使用了 eventfd 作為內核完成 IO 操作之後通知應用程序的機制。


  
實驗要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 完成分支: ch8-lab
- 實驗目錄要求不變。
- 通過所有測例。

問答作業
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

無

實驗練習的提交報告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 簡單總結本次實驗與上個實驗相比你增加的東西。（控制在5行以內，不要貼代碼）
* 完成問答問題
* (optional) 你對本次實驗設計及難度的看法。