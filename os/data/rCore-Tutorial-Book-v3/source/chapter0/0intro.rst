引言
=====================

本章導讀
--------------------------

本章主要解釋了在已經有一系列優秀的操作系統教材的情況下，為何要寫本書。所以本章一開始就是分析學生目前學習操作系統碰到的困難和問題，並介紹如何參考操作系統歷史，結合操作系統的完整實驗來設計本書的各個章節來編寫本書。接下來將從非常高層次的角度和計算機以及操作系統的發展史來進一步描述了什麼是操作系統、操作系統的訪問接口、操作系統的抽象、操作系統特徵，讓同學能夠對操作系統有一個大致的整體把握。最後介紹了本書關聯的操作系統實驗環境（包括在線實驗和本地實驗等）的搭建過程，為後續開展各個操作系統實驗打好基礎。


為何要寫這本操作系統書
-------------------------------------------------------

在目前的操作系統教學中，已有一系列優秀的操作系統教材，例如 William Stallings 的《Operating Systems Internals and Design Principles》，Avi Silberschatz 、 Peter Baer Galvin 和 Greg Gagne 的《Operating System Concepts》，
Remzi H. Arpaci-Dusseau 和 Andrea C. Arpaci-Dusseau 的《Operating Systems: Three Easy Pieces》等。

有待思考的問題
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

然而，從我們自 2000 年以來的教學實踐來看，某些經典教材對操作系統的概念和原理很重視，但還有如下一些問題有待進一步思考：

- 原理與實踐脫節：與操作系統的具體實現而言，操作系統的原理與概念相對過於抽象。目前的一些教材缺乏在“**操作系統的原理與概念**”和“**操作系統的設計與實現**”之間建立關聯關係的橋樑，使得二者之間存在較大的鴻溝。這導致學生即使知道了操作系統的概念，還只能停留在“紙上談兵”的階段，依然不知如何實現一個操作系統。另外，學生在完成設計與實現操作系統的實驗過程中，容易“一葉障目，不見泰山”，陷入到硬件規範、彙編代碼、數據結構、編程優化等細節中，不知這些細節與操作系統概念的關係，缺少全局觀和系統思維，難以與課堂上老師講解的操作系統基本概念對應起來。
- 缺少歷史發展的脈絡：以史為鑑，可以知興替。操作系統的概念和原理是從實際操作系統設計與實現的歷史發展過程中，隨著計算機硬件和應用需求的變化，從無到有逐步演進而產生的，有其發展的歷史淵源和規律。但目前的大部分教材只提及當前主流操作系統的概念和原理，有“憑空出現”的感覺，學生並不知道這些內容出現的前因後果，只知道 **“How”** ，而不知道 **“Why”** 。而且操作系統發展史上的很多設計思路和實踐方法起起伏伏，不斷演進，它們並沒有過時，而是以新的形態出現。如操作系統遠古階段的 **LibOS** 設計思路在當前雲計算時代重新煥發青春，成為學術機構和各大互聯網企業探索的新熱點。
- 忽視硬件細節或用複雜硬件：很多教材忽視或抽象硬件細節，使得操作系統概念難以落地，學生了解不到軟硬件是如何具體協同運行的。部分教材把複雜的 x86 處理器作為操作系統實驗的硬件參考平臺，缺乏對當前快速發展的 RISC-V 等精簡體系結構的實驗支持，使得學生在操作系統實驗中可能需要花較大代價瞭解相對繁雜的 x86 硬件細節，編程容易產生缺陷（bug），影響操作系統實驗的效果，以及對操作系統核心概念的掌握。

解決問題的思路
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

這些現存問題增加了學生學習和掌握操作系統的難度。我們嘗試通過如下方法來解決上面三個問題，達到緩解學生的學習壓力，提升學習興趣，能在一個學期內比較好地掌握操作系統的目標。

具體而言，為應對“原理與實踐脫節”的問題，我們強調 **實踐先行，實踐引領原理** 的教學理念。MIT 教授 Frans Kaashoek 等師生設計實現了基於 UNIX v6 的 xv6 教學操作系統用於每年的本科操作系統課的實驗中，並在課程講解中把原理和實驗結合起來，在國際上得到了廣泛的認可，也給了我們很好的啟發。經過十多年的操作系統教學工作，我們認為：對一位計算機專業的本科生而言，設計實現一個操作系統（包括CPU）有挑戰但可行，前提是這樣的操作系統要簡潔小巧，能體現操作系統中最基本的核心思想，並能把操作系統各主要部分的原理與概念關聯起來，形成一個整體。而且還需要豐富的配套資源，比如對操作系統的整體框架、核心算法、關鍵組件之間的聯繫等的分析文檔、配套的圖示和視頻講解、能夠自動測試操作系統功能的測試用例和測試環境、能展現操作系統逐步編寫過程的在線源代碼版本管理環境，以及逐步遞進的綜合性在線實驗環境等，這樣就能夠讓學生很方便地通過實踐來加深對操作系統原理和概念的理解，並能讓操作系統原理和概念落地。

為應對“缺少歷史發展的脈絡”的問題，我們重新設計操作系統實驗和教學內容，按照操作系統的歷史發展過程來設立每一章的內容，每一章會圍繞操作系統支持應用的某個核心目標來展開，形成相應的軟硬件基本知識點和具體實踐內容。同時建立與每章配套的多個逐步遞進且相對獨立的小實驗，每個實驗會形成一個獨立的操作系統，體現了操作系統的一個微縮的發展歷史，並可從中歸納總結出操作系統相關的概念與原理。這樣可以在教學中引導學生理解操作系統的這些概念和原理是如何一步一步演進的。表面上看，這樣會要求同學瞭解多個不同的操作系統，增加了同學的學習負擔。但其實每個實驗中的操作系統都是在前一個實驗的操作系統上的漸進式擴展，同學只需理解差異的部分即可。而且學生通過分析不同操作系統對應用支持能力和對應實現上的差異，可以更加深入地理解相關操作系統概念與原理出現的前因後果。也許有同學認為講解歷史上的操作系統太過時了。但我們認為：技術可以過時，思想值得傳承。

為應對“忽視硬件細節或用複雜硬件”的問題，我們在硬件（x86, ARM, MIPS, RISC-V 等）和編程語言（C, C++, Go, Rust 等）選擇方面進行了多年嘗試。在 2017 年把 複雜 x86 架構換為 簡潔 RISC-V 架構，作為操作系統實驗的硬件環境，降低了學生學習硬件細節的負擔。在 2018 年引入 Rust 編程語言作為開發操作系統的可選編程語言之一，減少了用C語言編程出現較多運行時缺陷的情況。使得學生以相對較小的開發和調試代價進行操作系統實驗。同時，我們把操作系統的概念和原理直接對應到程序代碼、硬件規範和操作系統的實際執行中，加強學生對操作系統內核的實際體驗和感受。


如何基於本書學習操作系統
---------------------------------------------

前期準備
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

學習操作系統需要有一些前期準備，主要包括計算機科學基礎知識，比如計算機組成原理、數據結構與算法、編程語言、軟件開發環境等。具體而言，需要了解計算機的基本原理，特別是RISC-V處理器的指令集和部分特權操作；還有就是需要掌握基本的數據結構和算法，畢竟操作系統也是一種軟件，需要通過多種數據結構和算法解決問題；在瞭解操作系統的設計並進行操作系統實驗的過程中，需要掌握系統級的高級編程語言和彙編語言，比如C或Rust編程語言，RISC-V彙編語言，這樣才能深入理解操作系統的實現細節和設計思想；最後還需掌握操作系統的開發與實驗環境，本書的主要涉及的開發與實驗環境是Linux，所以同學們需要能夠通過Linux的命令行界面使用各種開發工具和輔助工具，而掌握基於圖形界面或字符界面的IDE集成開發環境，如VSCode、Vim、Emacs等，可以提高分析操作系統源碼，簡化操作系統的開發與調試過程。


目標與步驟
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

所以本書的目標是以簡潔的 RISC-V 基本架構為底層硬件基礎，根據上層應用從小到大的需求，按 OS 發展的歷史脈絡，逐步講解如何設計實現能滿足“從簡單到複雜”應用需求的多個“小”操作系統。並且在設計實現操作系統的過程中，逐步解析操作系統各種概念與原理的知識點，做到有“理”可循和有“碼”可查，最終讓同學通過操作系統設計與實現來深入地掌握操作系統的概念與原理。


在本書中，第零章是對操作系統的一個概述，讓同學對操作系統的歷史、定義、特徵等概念上有一個大致的瞭解。後面的每個章節體現了操作系統的一個微縮的歷史發展過程，即從對應用由簡到繁的支持角度出發，每章會講解如何設計一個可運行應用的操作系統，滿足應用的階段性需求。從而同學可以通過配套的操作系統設計實驗，瞭解如何從一個微不足道的“小”操作系統，根據應用需求，添加或增強操作系統功能，逐步形成一個類似 UNIX 的相對完善的“小”操作系統。每一步都小到足以讓人感覺到易於掌控。而在每一步結束時，你都能運行一個支持不同應用執行的“小”操作系統。

..
  chyyuu：有一個比較大的ascii圖，畫出我們做出的各種OSes。

.. admonition:: **本書提供了哪些“小”操作系統？**
   :class: note

   我們按照操作系統的發展歷史，設計瞭如下一些逐步進化的“小”操作系統
  
   - LibOS: 讓APP與HW隔離，簡化應用訪問硬件的難度和複雜性
   - BatchOS： 讓APP與OS隔離，加強系統安全，提高執行效率
   - Multiprog & Timesharing OS: 讓APP共享CPU資源
   - Address Space OS: 隔離APP訪問的內存地址空間，限制APP之間的互相干涉，提高安全性
   - Process OS: 支持APP動態創建新進程，增強進程管理和資源管理能力
   - Filesystem OS：支持APP對數據的持久保存
   - IPC OS：支持多個APP進程間數據交互與事件通知 
   - Thread & Coroutine OS：支持線程和協程APP，簡化切換與數據共享  
   - SyncMutex OS：在多線程APP中支持對共享資源的同步互斥訪問
   - Device OS：提高APP的I/O效率和人機交互能力，支持基於外設中斷的串口/塊設備/鍵盤/鼠標/顯示設備

另外，通過足夠詳盡的測試程序和自動測試框架，可以隨時驗證同學實現的操作系統在每次更新後是否正常工作。由於實驗的代碼規模和實現複雜度在一個逐步遞增的可控範圍內，同學可以結合對應操作系統實驗的原理/概念分析，來建立操作系統概念原理和實際實現的對應關係，從而能夠通過操作系統實驗的實踐過程來加強對理論概念的理解，並通過理論概念來進一步指導操作系統實驗的實現與改進。

.. admonition:: **如何學習操作系統？**
   :class: note

   這取決於你想學習操作系統的目標，這裡主要分為兩類：

   - 掌握基本原理為主，瞭解具體實現為輔（一般學習）

     - 理解式學習方式：逐章閱讀與實踐，閱讀分析應用，並通過分析應用與OS的動態執行過程，掌握OS原理。

   - 掌握操作系統實現和原理為主（深入學習）

     - 構造式學習：在理解式學習方式基礎上，進一步分析源碼，逐步深入瞭解每個OS的內部增量實現，並且參考並基於這些小OS，擴展部分OS功能，通過測試用例，從而同時掌握操作系統實現和原理。

編程語言與硬件環境
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在你開始閱讀與實踐本書講解的內容之前，你需要決定用什麼編程語言來完成操作系統實驗。你可以選擇你喜歡的編程語言和在你喜歡的CPU上來實現操作系統。我們推薦的編程語言和架構分別是 Rust 和 RISC-V。



.. admonition:: **編程語言與指令集選擇**
   :class: note

   **目前常見的操作系統內核都是基於 C 語言的，為何要推薦 Rust 語言？**
   
   - 事實上， C 語言就是為寫 UNIX 而誕生的。Dennis Ritchie 和 Ken Thompson 沒有期望設計一種新語言能幫助高效地開發複雜與併發的操作系統邏輯(面向未來)，而是希望用一種簡潔的方式來代替難以使用的彙編語言抽象出計算機的行為，便於編寫控制計算機硬件的操作系統（符合當時實際情況）。
   - C 語言的指針既是天使又是魔鬼。它靈活且易於使用，但語言本身幾乎不保證安全性，且缺少有效的併發支持。這導致內存和併發漏洞成為當前基於 C 語言的主流操作系統的噩夢。
   - Rust 語言具有與 C 一樣的硬件控制能力，且大大強化了安全編程和抽象編程能力。從某種角度上看，新出現的 Rust 語言的核心目標是解決 C 的短板，取代 C 。所以用 Rust 寫 OS 具有很好的開發和運行體驗。
   - 用 Rust 寫 OS 的代價僅僅是學會用 Rust 編程。

   **目前常見的指令集架構是 x86 和 ARM ，為何要推薦 RISC-V ？**
   
   - 目前為止最常見的指令集架構是 x86 和 ARM ，它們已廣泛應用在服務器、臺式機、移動終端和很多嵌入式系統中。由於它們的通用性和向後兼容性需求，需要支持非常多（包括幾十年前實現）的軟件系統和應用需求，導致這些指令集架構越來越複雜。
   - x86 後向兼容的策略確保了它在桌面和服務器領域的江湖地位，但導致其丟不掉很多已經比較過時的硬件設計，讓操作系統通過冗餘的代碼來適配各種新老硬件特徵。
   - x86 和 ARM 在商業上都很成功，其廣泛使用使得其 CPU 硬件邏輯越來越複雜，且不夠開放，不能改變，不是開源的，難以讓感興趣探索硬件的學生了解硬件細節，在某種程度上讓CPU成為了一個黑盒子，並使得操作系統與硬件的交互變得不那麼透明，增加了學習操作系統的負擔。
   - 從某種角度上看，新出現的 RISC-V 的核心目標是靈活適應未來的 AIoT （人工智能物聯網, AI + IoT）場景，保證基本功能，提供可配置的擴展功能。其開源特徵使得學生都可以深入CPU的運行細節，甚至可以方便地設計一個 RISC-V CPU。從而可幫助學生深入瞭解操作系統與硬件的協同執行過程。
   - 編寫面向 RISC-V 的 OS 的硬件學習代價僅僅是你瞭解 RISC-V 的 Supervisor 特權模式，知道 OS 在 Supervisor 特權模式下的控制能力。

本書章節導引
-----------------------------------------------

本書由0~9共10章組成，其中第0章是本書的總覽，介紹了為何寫本書，概述了操作系統的簡要發展歷史，操作系統的定義，系統調用接口，操作系統的抽象表示和特徵等，以及如何基於本書來學習操作系統。

第1章主要講解了如何通過操作系統來解決應用和硬件隔離達到簡化應用編程的問題。並詳細講述瞭如何設計和實現建立在裸機上的執行環境，如何編寫可在裸機執行環境上運行的顯示“Hello World”的應用程序。最終形成可運行在裸機上的寒武紀“三葉蟲”操作系統 -- LibOS。這樣學生能對應用程序和它所依賴的執行環境的抽象概念與具體實現有一個全面和深入的理解。

第2章主要講解了如何通過操作系統來保障系統安全和多應用支持這兩個核心問題。並詳細講述了應該如何設計應用程序，如何通過批處理方式支持多個程序的自動加載和運行，如何實現應用程序與操作系統在執行特權上的隔離。最終形成可運行多個應用程序的泥盆紀“鄧式魚”操作系統 -- BatchOS。這樣學生可以看到系統調用、特權級、批處理等概念在操作系統上的具體實現，並瞭解如何通過批處理方式提高系統的整體性能，如何通過特許權隔離來保護操作系統，如何實現跨特權級的系統調用等操作系統核心技術。

第3章主要講解了如何在提高多程序運行的整體性能並保證多個程序運行的公平性這兩個核心問題。並詳細講述瞭如何通過提前加載應用程序到內存來減少應用程序切換開銷，如何通過應用程序之間的協作機制來支持程序主動放棄處理器並提高系統整體性能，如何通過基於硬件中斷的搶佔機制支持程序被動放棄處理器來保證不同程序對處理器資源使用的公平性，也進一步提高了應用對 I/O 事件的響應效率。最終形成了支持多道程序的二疊紀“鋸齒螈” 操作系統 -- MultiprogOS，支持協作機制的三疊紀“始初龍” 操作系統 -- CoopOS，支持分時多任務的三疊紀“腔骨龍” 操作系統 -- TimesharingOS。這樣學生可以通過分析這些操作系統的設計與實現，提煉出任務、任務切換等操作系統的核心概念，對計算機硬件的中斷處理機制、操作系統的分時共享等機制有更深入的理解。


第4章主要講解了內存的安全隔離問題和高效使用問題。有限的物理內存是操作系統需要管理的一個重要資源，如何讓運行在一臺計算機上的多個應用程序得到無限大的內存空間，如何能夠隔離運行應用能訪問的內存空間並保證不同應用之間的內存安全是本章要重點解決的問題。為此需要了解計算機硬件中的頁表和TLB機制，並通過操作系統在內存中構建面向自身和不同應用的頁表，形成應用與應用之間、應用與操作系統之間的內存隔離，從而解決內存安全隔離問題。通過缺頁異常和動態修改頁表等技術，讓當前運行的應用正在或即將訪問的數據位於內存中，不常用的數據緩存放到存儲設備（如硬盤等），形成分時複用內存的操作系統能力，即“虛存”能力。最終形成支持內存隔離的侏羅紀“頭甲龍”操作系統 -- Address Space OS。學生通過分析操作系統的設計與實現，可以把地址空間這樣的抽象概念和頁表的具體設計建立起聯繫，掌握如何通過頁表機制來實現地址空間。對任務切換中增加的地址空間切換機制也會有更深入的瞭解。能夠理解虛存機制中的各種頁面置換策略能否有效實現，以及如何具體實現。

第5章主要講解了如何提高應用程序動態執行的靈活性和交互性的問題，即讓開發者能夠及時控制程序的創建、運行和退出的管理問題。在第5章之前，在操作系統整個執行過程中，應用程序是被動地被操作系統加載運行，開發者與操作系統之間沒有交互，開發者與應用程序之間沒有交互，應用程序不能控制其它應用的執行。這使得用戶不能靈活地選擇執行某個程序。這需要給用戶提供一個靈活的應用程序（俗稱 shell ），形成用戶與操作系統進行交互的命令行界面（Command Line Interface）。用戶可以在這個 `shell` 程序中輸入命令即可啟動或殺死應用，或者監控系統的運行狀況，使得開發者可以更加靈活地控制系統。這種新的用戶需求需要重構操作系統的功能，讓操作系統提供支持應用程序動態創建/銷燬/等待/暫停等服務。這就在已有的 `任務` 抽象的基礎上進一步新抽象： `進程` ，用於表示和管理應用程序的整個執行過程。這樣最終形成具備靈活強大的進程管理功能的白堊紀“傷齒龍”操作系統 -- Process OS。學生通過分析操作系統的設計與實現，可以把進程、進程調度、進程切換、進程狀態、進程生命週期這樣的抽象概念與操作系統實現中的進程控制塊數據結構、進程相關係統調用功能、進程調度與進程切換函數的具體設計建立其聯繫，能夠更加深入掌握進程這一操作系統的核心概念。

第6章主要講解了如何讓程序方便地訪問存儲設備上的數據的問題。由於放在內存中的數據在計算機關機或掉電後就會消失，所以應用程序要把內存中需要長久保存的數據放到存儲設備上存起來，並在需要的時候能讀到內存中進行處理。文件和文件系統的出現極大地簡化了應用程序訪問存儲設備上數據的操作。第6章將設計並實現操作系統和核心模塊，即一個簡單的文件系統 -- easyfs，向上給應用程序提供了常規文件和目錄文件兩種抽象，並提供 `open` 、 `close` 、 `read` 、 `write` 四個系統調用來讀寫文件中的數據，向下通過存儲設備驅動程序對存儲設備這種 I/O 外設物理資源進行管理。這樣就形成了支持文件訪問的 “霸王龍” 操作系統 -- Filesystem OS。學生通過分析操作系統的設計與實現，可以看到文件、文件系統這樣的操作系統抽象如何通過一個具體的文件系統 -- easyfs 來體現的。並可以看到並理解文件系統與進程管理、內存管理之間的緊密聯繫，從而支持應用程序便捷地對存儲設備上的數據進行訪問。

第7章主要講解如何讓不同的應用進行數據共享與合作的問題。在第7章之前，進程之間被操作系統徹底隔離了，導致進程之間無法方便地分享數據，不能一起協作。如果能讓不同進程實現數據共享與交互，就能把不同程序的功能組合在一起，實現更加強大和靈活的複雜功能。第7章的核心目標就是讓不同應用通過進程間通信的方式組合在一起運行。為此，將引入新的操作系統概念 -- 管道（pipe），以支持進程間的I/O重定向功能，即讓一個進程的輸出成為另外一個進程的輸入，從而讓進程間能夠有效地合作起來。這樣管道其實也可以看成是一種特殊的內存文件，並可基於文件的操作來實現進程間的內存數據共享。除了數據共享機制，進程間也需要快捷的通知機制，這就引出了信號（Signal） 事件通知機制，讓進程能夠及時的獲得並處理來自其他進程或操作系統發的緊急通知。這樣最終形成支持多個APP進程間數據交互與事件通知功能的白堊紀“迅猛龍”操作系統 -- IPC OS。學生通過分析操作系統的設計與實現，可以看到進程間的隔離和共享是可以同時做到的，並可進一步瞭解在進程的基礎上如何通過管道機制來打破進程間建立的地址空間隔離，實現數據共享，以及如何通過信號機制打斷進程的正常執行來及時響應相對緊急的事件，從而掌握多應用共享協同的操作系統機制。

第8章主要講解如何提高多個應用併發執行的效率和如何保證能多個應用正確訪問共享資源的問題。進程的地址空間隔離會帶來管理上的運行時開銷，比如TLB刷新、頁表切換等。如果把一個進程內的多個可並行執行的任務通過一種更細粒度的方式讓操作系統進行調度，那麼就可以在進程內實現併發執行，且由於這些任務在進程內的地址空間中，不會帶來頁表切換等運行時開銷。這裡的任務就是線程（Thread）。線程間共享地址空間，使得它們訪問共享資源更加方便，但如果處理不當，就可能出現資源訪問衝突和競爭的問題。這就需要通過同步機制來協調進程或線程的執行順序，並通過互斥機制來保證在同一時刻只有一個進程或線程可以訪問共享資源，從而避免了資源衝突和競爭的問題。第8章在進程管理的基礎上進行重構，設計實現了線程管理機制，形成了支持多線程app的達科塔盜龍OS -- ThreadOS；並進一步設計了支持線程同步互斥訪問共享資源的鎖機制、信號量機制和條件變量機制，最終形成了支持多線程APP同步互斥訪問共享資源的白堊紀“慈母龍”操作系統 -- SyncMutex OS。學生通過分析操作系統的設計與實現，可以理解線程和進程的關係與區別，理解同步互斥機制的不同特徵和運行機理，從而能夠深入理解支持併發訪問共享資源的同步互斥機制的原理和實現。

第9章主要講解如何讓應用便捷訪問I/O設備並讓應用有更多感知與交互能力的問題。計算機中的外設特徵各異，如顯卡、觸摸屏、鍵盤、鼠標、網卡、聲卡等。在第9章之前，同學們已經接觸到了串口、時鐘、和磁盤設備，使得應用程序能通過操作系統輸入輸出字符、訪問時間、讀寫在磁盤上的數據，並通過時鐘中斷讓操作系統具有了搶佔式分時多任務調度的能力，但這僅僅覆蓋了很小的一部分外設，而且在實踐上對操作系統與外設的交互細節也涉及不多。操作系統需要對外設有更多的深入理解，才能有效地管理和訪問外設，給應用提供豐富的感知與交互能力。在原理與概念方面，第9章簡要分析了外設的發展歷程，外設的數據傳輸方式。並進一步闡述操作系統如何對外設建立不同層次的抽象和不同I/O執行模型，以便於操作系統對外設的內部管理，應用程序對外設的高效便捷訪問。在實踐上，第9章分析了操作系統如何通過設備樹(Device Tree)來解析出計算機中的外設信息，並重新設計了基於中斷方式的串口驅動程序，涉及串口設備初始化和串口數據輸入輸出，以及改進進程/線程的調度機制，讓等待串口輸入或輸出完成的進程/線程進入阻塞狀態，從而提高系統整體執行效率。在第9章還進一步介紹了QEMU模擬的virtio設備架構，以及virtio設備驅動程序的主要功能；並對virtio-blk設備及其驅動程序，virtio-gpu設備及其驅動程序進行了比較深入的分析。這樣最終形成支持圖形遊戲APP並具備高效外設中斷響應的侏羅紀侏羅獵龍操作系統 -- Device 學生通過分析操作系統的設計與實現，可以深入瞭解不同外設的特徵，外設的I/O傳輸方式，不同層次的外設抽象概念和I/O執行模型，從而對操作系統如何有效管理不同類型的外設有一個相關完整的理解。

百聞不如一見，如果同學們通過讀書和閱讀代碼能逐步地明確每一章要解決的應用需求和問題，漸進地瞭解每章操作系統中內核模塊的組成，並掌握內核模塊的功能，以及不同內核模塊之間的關係，能歸納總結出操作系統的設計思路、策略與機制、原理與概念，就能達到了解操作系統的層次。百見不如一干，僅僅看還是不夠的，本書的重要目標是希望能推動同學們能夠通過編程來掌握操作系統。如果同學們還能通過課後習題和編程實驗來完成操作系統的新功能，發現編程中的bug並修復bug，通過測試用例，實現你自己編寫的操作系統，那將達到掌握操作系統的更高層次。希望同學們能夠完整走完整個操作系統的學習和練習的過程，當你完成整個過程後，再回首看，能夠發現原來操作系統還可以這樣有趣和有用。
