<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux 網路程式設計 API 完整參考手冊 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-網路程式設計-api-完整參考手冊"><a class="header" href="#linux-網路程式設計-api-完整參考手冊">Linux 網路程式設計 API 完整參考手冊</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#socket-%E5%9F%BA%E7%A4%8E-api">Socket 基礎 API</a></li>
<li><a href="#tcp-%E5%B0%88%E7%94%A8%E5%87%BD%E6%95%B8">TCP 專用函數</a></li>
<li><a href="#udp-%E5%B0%88%E7%94%A8%E5%87%BD%E6%95%B8">UDP 專用函數</a></li>
<li><a href="#io-%E5%A4%9A%E5%B7%A5%E6%A9%9F%E5%88%B6">I/O 多工機制</a></li>
<li><a href="#socket-%E9%81%B8%E9%A0%85%E8%A8%AD%E5%AE%9A">Socket 選項設定</a></li>
<li><a href="#%E8%B3%87%E6%96%99%E6%94%B6%E7%99%BC%E5%87%BD%E6%95%B8">資料收發函數</a></li>
<li><a href="#%E4%BD%8D%E5%9D%80%E8%BD%89%E6%8F%9B%E5%87%BD%E6%95%B8">位址轉換函數</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F">完整範例程式</a></li>
</ol>
<hr />
<h2 id="socket-基礎-api"><a class="header" href="#socket-基礎-api">Socket 基礎 API</a></h2>
<h3 id="核心函數總覽"><a class="header" href="#核心函數總覽">核心函數總覽</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函數</th><th>功能</th><th>TCP</th><th>UDP</th><th>說明</th></tr></thead><tbody>
<tr><td><code>socket()</code></td><td>建立 socket</td><td>✅</td><td>✅</td><td>創建通訊端點</td></tr>
<tr><td><code>bind()</code></td><td>綁定位址</td><td>✅</td><td>✅</td><td>綁定本地 IP 和埠號</td></tr>
<tr><td><code>listen()</code></td><td>監聽連線</td><td>✅</td><td>❌</td><td>TCP 伺服器必須</td></tr>
<tr><td><code>accept()</code></td><td>接受連線</td><td>✅</td><td>❌</td><td>TCP 伺服器必須</td></tr>
<tr><td><code>connect()</code></td><td>建立連線</td><td>✅</td><td>可選</td><td>TCP 必須，UDP 可選</td></tr>
<tr><td><code>close()</code></td><td>關閉 socket</td><td>✅</td><td>✅</td><td>釋放資源</td></tr>
<tr><td><code>shutdown()</code></td><td>關閉部分連線</td><td>✅</td><td>✅</td><td>半關閉連線</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="1-socket---建立-socket"><a class="header" href="#1-socket---建立-socket">1. socket() - 建立 Socket</a></h2>
<h3 id="函數原型"><a class="header" href="#函數原型">函數原型</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre>
<h3 id="參數詳解"><a class="header" href="#參數詳解">參數詳解</a></h3>
<h4 id="domain協定家族"><a class="header" href="#domain協定家族">domain（協定家族）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th><th>用途</th></tr></thead><tbody>
<tr><td><code>AF_INET</code></td><td>IPv4 網路協定</td><td>最常用</td></tr>
<tr><td><code>AF_INET6</code></td><td>IPv6 網路協定</td><td>IPv6 網路</td></tr>
<tr><td><code>AF_UNIX</code> / <code>AF_LOCAL</code></td><td>Unix domain socket</td><td>本機行程間通訊</td></tr>
<tr><td><code>AF_PACKET</code></td><td>原始封包介面</td><td>網路監聽、封包分析</td></tr>
</tbody></table>
</div>
<h4 id="typesocket-類型"><a class="header" href="#typesocket-類型">type（socket 類型）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th><th>特性</th><th>協定</th></tr></thead><tbody>
<tr><td><code>SOCK_STREAM</code></td><td>串流 socket</td><td>可靠、有序、雙向位元組流</td><td>TCP</td></tr>
<tr><td><code>SOCK_DGRAM</code></td><td>資料報 socket</td><td>不可靠、無連線、訊息邊界</td><td>UDP</td></tr>
<tr><td><code>SOCK_RAW</code></td><td>原始 socket</td><td>直接存取網路層</td><td>ICMP、自訂協定</td></tr>
<tr><td><code>SOCK_SEQPACKET</code></td><td>有序封包 socket</td><td>可靠、有序、保留訊息邊界</td><td>SCTP</td></tr>
</tbody></table>
</div>
<p><strong>type 可加入的標誌：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>SOCK_NONBLOCK</code></td><td>非阻塞模式（Linux 2.6.27+）</td></tr>
<tr><td><code>SOCK_CLOEXEC</code></td><td>執行 exec 時關閉</td></tr>
</tbody></table>
</div>
<h4 id="protocol協定"><a class="header" href="#protocol協定">protocol（協定）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>自動選擇（最常用）</td></tr>
<tr><td><code>IPPROTO_TCP</code></td><td>明確指定 TCP</td></tr>
<tr><td><code>IPPROTO_UDP</code></td><td>明確指定 UDP</td></tr>
<tr><td><code>IPPROTO_ICMP</code></td><td>ICMP 協定</td></tr>
<tr><td><code>IPPROTO_RAW</code></td><td>原始 IP 封包</td></tr>
</tbody></table>
</div>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<ul>
<li><strong>成功</strong>：socket 檔案描述符（非負整數）</li>
<li><strong>失敗</strong>：-1，並設定 errno</li>
</ul>
<h3 id="常見錯誤碼"><a class="header" href="#常見錯誤碼">常見錯誤碼</a></h3>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th></tr></thead><tbody>
<tr><td><code>EACCES</code></td><td>權限不足（如建立 raw socket 需要 root）</td></tr>
<tr><td><code>EMFILE</code></td><td>行程打開檔案數達到上限</td></tr>
<tr><td><code>ENFILE</code></td><td>系統打開檔案數達到上限</td></tr>
<tr><td><code>EPROTONOSUPPORT</code></td><td>不支援的協定</td></tr>
</tbody></table>
</div>
<h3 id="使用範例"><a class="header" href="#使用範例">使用範例</a></h3>
<pre><code class="language-c">// TCP socket
int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
if (tcp_sock &lt; 0) {
    perror("socket");
    exit(1);
}

// UDP socket
int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);

// 非阻塞 TCP socket（Linux 2.6.27+）
int nonblock_sock = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);

// 原始 socket（需要 root 權限）
int raw_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
</code></pre>
<hr />
<h2 id="2-bind---綁定位址"><a class="header" href="#2-bind---綁定位址">2. bind() - 綁定位址</a></h2>
<h3 id="函數原型-1"><a class="header" href="#函數原型-1">函數原型</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<h3 id="參數說明"><a class="header" href="#參數說明">參數說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>socket 檔案描述符</td></tr>
<tr><td><code>addr</code></td><td>要綁定的位址結構</td></tr>
<tr><td><code>addrlen</code></td><td>位址結構的長度</td></tr>
</tbody></table>
</div>
<h3 id="sockaddr-結構家族"><a class="header" href="#sockaddr-結構家族">sockaddr 結構家族</a></h3>
<h4 id="ipv4-位址結構"><a class="header" href="#ipv4-位址結構">IPv4 位址結構</a></h4>
<pre><code class="language-c">struct sockaddr_in {
    sa_family_t    sin_family;  // AF_INET
    in_port_t      sin_port;    // 埠號（網路位元組序）
    struct in_addr sin_addr;    // IP 位址
    char           sin_zero[8]; // 填充（必須為 0）
};

struct in_addr {
    uint32_t s_addr;  // IP 位址（網路位元組序）
};
</code></pre>
<h4 id="ipv6-位址結構"><a class="header" href="#ipv6-位址結構">IPv6 位址結構</a></h4>
<pre><code class="language-c">struct sockaddr_in6 {
    sa_family_t     sin6_family;   // AF_INET6
    in_port_t       sin6_port;     // 埠號
    uint32_t        sin6_flowinfo; // IPv6 流量資訊
    struct in6_addr sin6_addr;     // IPv6 位址
    uint32_t        sin6_scope_id; // 範圍 ID
};
</code></pre>
<h4 id="通用位址結構"><a class="header" href="#通用位址結構">通用位址結構</a></h4>
<pre><code class="language-c">struct sockaddr {
    sa_family_t sa_family;  // 位址家族
    char        sa_data[14]; // 位址資料
};
</code></pre>
<h3 id="特殊-ip-位址"><a class="header" href="#特殊-ip-位址">特殊 IP 位址</a></h3>
<div class="table-wrapper"><table><thead><tr><th>IP 位址</th><th>巨集</th><th>說明</th><th>用途</th></tr></thead><tbody>
<tr><td><code>0.0.0.0</code></td><td><code>INADDR_ANY</code></td><td>任意位址</td><td>伺服器監聽所有網卡</td></tr>
<tr><td><code>127.0.0.1</code></td><td><code>INADDR_LOOPBACK</code></td><td>回環位址</td><td>本機測試</td></tr>
<tr><td><code>255.255.255.255</code></td><td><code>INADDR_BROADCAST</code></td><td>廣播位址</td><td>UDP 廣播</td></tr>
</tbody></table>
</div>
<h3 id="埠號說明"><a class="header" href="#埠號說明">埠號說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>埠號範圍</th><th>類型</th><th>說明</th></tr></thead><tbody>
<tr><td>0-1023</td><td>知名埠</td><td>需要特權（root）</td></tr>
<tr><td>1024-49151</td><td>註冊埠</td><td>常用服務埠</td></tr>
<tr><td>49152-65535</td><td>動態埠</td><td>客戶端臨時埠</td></tr>
<tr><td>0</td><td>自動分配</td><td>系統自動選擇可用埠</td></tr>
</tbody></table>
</div>
<h3 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h3>
<ul>
<li><strong>成功</strong>：0</li>
<li><strong>失敗</strong>：-1，並設定 errno</li>
</ul>
<h3 id="常見錯誤碼-1"><a class="header" href="#常見錯誤碼-1">常見錯誤碼</a></h3>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th><th>解決方法</th></tr></thead><tbody>
<tr><td><code>EADDRINUSE</code></td><td>位址已被使用</td><td>設定 SO_REUSEADDR 或等待 TIME_WAIT</td></tr>
<tr><td><code>EACCES</code></td><td>權限不足</td><td>使用 &gt;1024 的埠或提升權限</td></tr>
<tr><td><code>EINVAL</code></td><td>socket 已綁定</td><td>每個 socket 只能 bind 一次</td></tr>
<tr><td><code>EADDRNOTAVAIL</code></td><td>位址不可用</td><td>檢查 IP 位址是否正確</td></tr>
</tbody></table>
</div>
<h3 id="使用範例-1"><a class="header" href="#使用範例-1">使用範例</a></h3>
<pre><code class="language-c">// TCP 伺服器綁定
int sockfd = socket(AF_INET, SOCK_STREAM, 0);

// 設定 SO_REUSEADDR（重要！）
int reuse = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));

struct sockaddr_in addr;
memset(&amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(8080);           // 埠號 8080
addr.sin_addr.s_addr = INADDR_ANY;     // 監聽所有網卡

if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {
    perror("bind");
    exit(1);
}

// 綁定特定 IP
addr.sin_addr.s_addr = inet_addr("192.168.1.100");
bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));

// UDP 伺服器綁定（與 TCP 相同）
int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
bind(udp_sock, (struct sockaddr*)&amp;addr, sizeof(addr));

// 客戶端不綁定（自動分配）
// TCP/UDP 客戶端通常不需要 bind，connect() 或第一次 sendto() 會自動綁定
</code></pre>
<hr />
<h2 id="3-listen---監聽連線tcp-專用"><a class="header" href="#3-listen---監聽連線tcp-專用">3. listen() - 監聽連線（TCP 專用）</a></h2>
<h3 id="函數原型-2"><a class="header" href="#函數原型-2">函數原型</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);
</code></pre>
<h3 id="參數說明-1"><a class="header" href="#參數說明-1">參數說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>已綁定的 socket</td></tr>
<tr><td><code>backlog</code></td><td>連線佇列長度</td></tr>
</tbody></table>
</div>
<h3 id="backlog-詳解"><a class="header" href="#backlog-詳解">backlog 詳解</a></h3>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th><th>建議</th></tr></thead><tbody>
<tr><td>小值（1-10）</td><td>低並發場景</td><td>簡單服務</td></tr>
<tr><td>中值（128-512）</td><td>一般 Web 服務</td><td>推薦 128</td></tr>
<tr><td>大值（1024+）</td><td>高並發場景</td><td>大型服務</td></tr>
<tr><td><code>SOMAXCONN</code></td><td>系統最大值</td><td>通常 128（可調整）</td></tr>
</tbody></table>
</div>
<p><strong>注意</strong>：<code>backlog</code> 是<strong>已完成三次握手但未被 accept() 的連線數</strong>，不是總連線數。</p>
<h3 id="系統限制"><a class="header" href="#系統限制">系統限制</a></h3>
<pre><code class="language-bash"># 查看系統最大值
cat /proc/sys/net/core/somaxconn

# 修改系統最大值
sudo sysctl -w net.core.somaxconn=1024
</code></pre>
<h3 id="返回值-2"><a class="header" href="#返回值-2">返回值</a></h3>
<ul>
<li><strong>成功</strong>：0</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="使用範例-2"><a class="header" href="#使用範例-2">使用範例</a></h3>
<pre><code class="language-c">int sockfd = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(8080);
addr.sin_addr.s_addr = INADDR_ANY;

bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));

// 開始監聽
if (listen(sockfd, 128) &lt; 0) {
    perror("listen");
    exit(1);
}

printf("伺服器正在監聽埠 8080...\n");

// 使用系統最大值
listen(sockfd, SOMAXCONN);
</code></pre>
<h3 id="tcp-連線佇列"><a class="header" href="#tcp-連線佇列">TCP 連線佇列</a></h3>
<p>TCP 有兩個佇列：</p>
<div class="table-wrapper"><table><thead><tr><th>佇列</th><th>說明</th><th>狀態</th></tr></thead><tbody>
<tr><td><strong>SYN 佇列</strong>（半連線）</td><td>收到 SYN，未完成三次握手</td><td>SYN_RCVD</td></tr>
<tr><td><strong>ACCEPT 佇列</strong>（全連線）</td><td>完成三次握手，等待 accept()</td><td>ESTABLISHED</td></tr>
</tbody></table>
</div>
<p><code>backlog</code> 參數控制 <strong>ACCEPT 佇列</strong>的長度。</p>
<hr />
<h2 id="4-accept---接受連線tcp-專用"><a class="header" href="#4-accept---接受連線tcp-專用">4. accept() - 接受連線（TCP 專用）</a></h2>
<h3 id="函數原型-3"><a class="header" href="#函數原型-3">函數原型</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<h3 id="參數說明-2"><a class="header" href="#參數說明-2">參數說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>監聽 socket</td></tr>
<tr><td><code>addr</code></td><td>客戶端位址（輸出參數，可為 NULL）</td></tr>
<tr><td><code>addrlen</code></td><td>位址結構長度（輸入輸出參數）</td></tr>
</tbody></table>
</div>
<h3 id="返回值-3"><a class="header" href="#返回值-3">返回值</a></h3>
<ul>
<li><strong>成功</strong>：新的連線 socket 檔案描述符</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="重要概念"><a class="header" href="#重要概念">重要概念</a></h3>
<p><strong>兩個 socket 的區別：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Socket</th><th>功能</th><th>生命週期</th></tr></thead><tbody>
<tr><td><strong>監聽 socket</strong></td><td>接受新連線</td><td>伺服器整個生命週期</td></tr>
<tr><td><strong>連線 socket</strong></td><td>與客戶端通訊</td><td>單次連線</td></tr>
</tbody></table>
</div>
<h3 id="常見錯誤碼-2"><a class="header" href="#常見錯誤碼-2">常見錯誤碼</a></h3>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th></tr></thead><tbody>
<tr><td><code>EAGAIN/EWOULDBLOCK</code></td><td>非阻塞模式下無連線</td></tr>
<tr><td><code>EINTR</code></td><td>被信號中斷</td></tr>
<tr><td><code>EMFILE</code></td><td>行程檔案描述符用盡</td></tr>
<tr><td><code>ENFILE</code></td><td>系統檔案描述符用盡</td></tr>
</tbody></table>
</div>
<h3 id="accept4---linux-擴展"><a class="header" href="#accept4---linux-擴展">accept4() - Linux 擴展</a></h3>
<pre><code class="language-c">int accept4(int sockfd, struct sockaddr *addr, 
            socklen_t *addrlen, int flags);
</code></pre>
<p><strong>flags 可用值：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>SOCK_NONBLOCK</code></td><td>返回的 socket 為非阻塞</td></tr>
<tr><td><code>SOCK_CLOEXEC</code></td><td>執行 exec 時關閉</td></tr>
</tbody></table>
</div>
<h3 id="使用範例-3"><a class="header" href="#使用範例-3">使用範例</a></h3>
<pre><code class="language-c">// 1. 基本用法
struct sockaddr_in client_addr;
socklen_t addr_len = sizeof(client_addr);

int connfd = accept(listenfd, (struct sockaddr*)&amp;client_addr, &amp;addr_len);
if (connfd &lt; 0) {
    perror("accept");
    exit(1);
}

// 取得客戶端資訊
char *client_ip = inet_ntoa(client_addr.sin_addr);
int client_port = ntohs(client_addr.sin_port);
printf("客戶端連線: %s:%d\n", client_ip, client_port);

// 2. 不關心客戶端位址
int connfd = accept(listenfd, NULL, NULL);

// 3. 非阻塞模式處理
while (1) {
    int connfd = accept(listenfd, NULL, NULL);
    if (connfd &lt; 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            break;  // 沒有新連線
        }
        perror("accept");
        break;
    }
    // 處理新連線
}

// 4. 使用 accept4（Linux）
int connfd = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK | SOCK_CLOEXEC);
</code></pre>
<hr />
<h2 id="5-connect---建立連線"><a class="header" href="#5-connect---建立連線">5. connect() - 建立連線</a></h2>
<h3 id="函數原型-4"><a class="header" href="#函數原型-4">函數原型</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<h3 id="參數說明-3"><a class="header" href="#參數說明-3">參數說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>socket 檔案描述符</td></tr>
<tr><td><code>addr</code></td><td>伺服器位址</td></tr>
<tr><td><code>addrlen</code></td><td>位址結構長度</td></tr>
</tbody></table>
</div>
<h3 id="tcp-vs-udp"><a class="header" href="#tcp-vs-udp">TCP vs UDP</a></h3>
<div class="table-wrapper"><table><thead><tr><th>協定</th><th>是否必須</th><th>行為</th></tr></thead><tbody>
<tr><td><strong>TCP</strong></td><td>✅ 必須</td><td>發起三次握手，阻塞直到連線建立</td></tr>
<tr><td><strong>UDP</strong></td><td>❌ 可選</td><td>不發送封包，只記錄對端位址</td></tr>
</tbody></table>
</div>
<h3 id="返回值-4"><a class="header" href="#返回值-4">返回值</a></h3>
<ul>
<li><strong>成功</strong>：0</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="常見錯誤碼-3"><a class="header" href="#常見錯誤碼-3">常見錯誤碼</a></h3>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th><th>原因</th></tr></thead><tbody>
<tr><td><code>ECONNREFUSED</code></td><td>連線被拒絕</td><td>伺服器未監聽該埠</td></tr>
<tr><td><code>ETIMEDOUT</code></td><td>連線超時</td><td>網路不通或防火牆阻擋</td></tr>
<tr><td><code>ENETUNREACH</code></td><td>網路不可達</td><td>路由問題</td></tr>
<tr><td><code>EINPROGRESS</code></td><td>連線進行中</td><td>非阻塞模式正常情況</td></tr>
<tr><td><code>EISCONN</code></td><td>已經連線</td><td>socket 已連線，不能重複</td></tr>
</tbody></table>
</div>
<h3 id="非阻塞-connect-處理"><a class="header" href="#非阻塞-connect-處理">非阻塞 connect 處理</a></h3>
<pre><code class="language-c">// 1. 設定非阻塞
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

// 2. 發起連線
if (connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {
    if (errno == EINPROGRESS) {
        // 正常：連線正在進行中
        
        // 使用 select/poll/epoll 等待連線完成
        fd_set wset;
        FD_ZERO(&amp;wset);
        FD_SET(sockfd, &amp;wset);
        
        struct timeval timeout = {5, 0};  // 5 秒超時
        int ret = select(sockfd + 1, NULL, &amp;wset, NULL, &amp;timeout);
        
        if (ret &gt; 0) {
            // 檢查連線是否成功
            int error;
            socklen_t len = sizeof(error);
            getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);
            
            if (error == 0) {
                printf("連線成功\n");
            } else {
                printf("連線失敗: %s\n", strerror(error));
            }
        } else if (ret == 0) {
            printf("連線超時\n");
        }
    } else {
        perror("connect");
    }
}
</code></pre>
<h3 id="使用範例-4"><a class="header" href="#使用範例-4">使用範例</a></h3>
<pre><code class="language-c">// TCP 客戶端連線
int sockfd = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in server_addr;
memset(&amp;server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(8080);
server_addr.sin_addr.s_addr = inet_addr("192.168.1.100");

if (connect(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
    perror("connect");
    exit(1);
}

printf("已連線到伺服器\n");

// UDP「連線」（可選）
int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
connect(udp_sock, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
// UDP connect 後可以使用 send/recv 而不是 sendto/recvfrom
</code></pre>
<hr />
<h2 id="6-close-和-shutdown---關閉連線"><a class="header" href="#6-close-和-shutdown---關閉連線">6. close() 和 shutdown() - 關閉連線</a></h2>
<h3 id="close---完全關閉"><a class="header" href="#close---完全關閉">close() - 完全關閉</a></h3>
<h4 id="函數原型-5"><a class="header" href="#函數原型-5">函數原型</a></h4>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int fd);
</code></pre>
<h4 id="行為說明"><a class="header" href="#行為說明">行為說明</a></h4>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>說明</th></tr></thead><tbody>
<tr><td><strong>引用計數</strong></td><td>fd 引用計數減 1，為 0 時才真正關閉</td></tr>
<tr><td><strong>雙向關閉</strong></td><td>同時關閉讀和寫</td></tr>
<tr><td><strong>資料處理</strong></td><td>根據 SO_LINGER 決定</td></tr>
</tbody></table>
</div>
<h4 id="返回值-5"><a class="header" href="#返回值-5">返回值</a></h4>
<ul>
<li><strong>成功</strong>：0</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="shutdown---半關閉"><a class="header" href="#shutdown---半關閉">shutdown() - 半關閉</a></h3>
<h4 id="函數原型-6"><a class="header" href="#函數原型-6">函數原型</a></h4>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int shutdown(int sockfd, int how);
</code></pre>
<h4 id="how-參數"><a class="header" href="#how-參數">how 參數</a></h4>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th><th>效果</th></tr></thead><tbody>
<tr><td><code>SHUT_RD</code> (0)</td><td>關閉讀端</td><td>不能再 recv，但對端仍可 send</td></tr>
<tr><td><code>SHUT_WR</code> (1)</td><td>關閉寫端</td><td>不能再 send，發送 FIN 給對端</td></tr>
<tr><td><code>SHUT_RDWR</code> (2)</td><td>關閉讀寫</td><td>等同 close，但不減少引用計數</td></tr>
</tbody></table>
</div>
<h3 id="close-vs-shutdown-對比"><a class="header" href="#close-vs-shutdown-對比">close() vs shutdown() 對比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>close()</th><th>shutdown()</th></tr></thead><tbody>
<tr><td><strong>影響範圍</strong></td><td>只影響本行程的 fd</td><td>影響所有引用該 socket 的行程</td></tr>
<tr><td><strong>引用計數</strong></td><td>減少引用計數</td><td>不影響引用計數</td></tr>
<tr><td><strong>半關閉</strong></td><td>不支援</td><td>支援（SHUT_RD/SHUT_WR）</td></tr>
<tr><td><strong>發送 FIN</strong></td><td>引用計數為 0 時發送</td><td>SHUT_WR 立即發送</td></tr>
</tbody></table>
</div>
<h3 id="使用範例-5"><a class="header" href="#使用範例-5">使用範例</a></h3>
<pre><code class="language-c">// 1. 正常關閉
close(sockfd);

// 2. 優雅關閉（半關閉）
shutdown(sockfd, SHUT_WR);  // 告訴對方：我不再發送資料
// 此時還可以繼續接收對方資料
while (recv(sockfd, buffer, sizeof(buffer), 0) &gt; 0) {
    // 接收剩餘資料
}
close(sockfd);

// 3. 立即關閉（丟棄未發送資料）
struct linger lng = {1, 0};
setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;lng, sizeof(lng));
close(sockfd);  // 發送 RST 而非 FIN

// 4. 父子行程共享 socket
int sockfd = accept(listenfd, NULL, NULL);
pid_t pid = fork();
if (pid == 0) {
    // 子行程
    close(listenfd);  // 關閉監聽 socket
    // 處理 sockfd
    close(sockfd);
    exit(0);
} else {
    // 父行程
    close(sockfd);  // 父行程不處理此連線
}
</code></pre>
<hr />
<h2 id="tcp-專用函數"><a class="header" href="#tcp-專用函數">TCP 專用函數</a></h2>
<h3 id="tcp-狀態機"><a class="header" href="#tcp-狀態機">TCP 狀態機</a></h3>
<pre><code>客戶端狀態                    伺服器狀態
                            LISTEN
CLOSED     ─── SYN ──&gt;     SYN_RCVD
SYN_SENT   &lt;── SYN+ACK ─   
ESTABLISHED ─── ACK ──&gt;    ESTABLISHED
    ↓                           ↓
    ↓       [資料傳輸]          ↓
    ↓                           ↓
FIN_WAIT_1  ─── FIN ──&gt;    CLOSE_WAIT
FIN_WAIT_2  &lt;── ACK ───    CLOSE_WAIT
TIME_WAIT   &lt;── FIN ───    LAST_ACK
TIME_WAIT   ─── ACK ──&gt;    CLOSED
CLOSED (2MSL 後)
</code></pre>
<h3 id="tcp-函數呼叫流程"><a class="header" href="#tcp-函數呼叫流程">TCP 函數呼叫流程</a></h3>
<h4 id="伺服器端"><a class="header" href="#伺服器端">伺服器端</a></h4>
<pre><code>socket() → bind() → listen() → accept() → recv()/send() → close()
</code></pre>
<h4 id="客戶端"><a class="header" href="#客戶端">客戶端</a></h4>
<pre><code>socket() → connect() → send()/recv() → close()
</code></pre>
<hr />
<h2 id="udp-專用函數"><a class="header" href="#udp-專用函數">UDP 專用函數</a></h2>
<h3 id="sendto---udp-發送"><a class="header" href="#sendto---udp-發送">sendto() - UDP 發送</a></h3>
<h4 id="函數原型-7"><a class="header" href="#函數原型-7">函數原型</a></h4>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);
</code></pre>
<h4 id="參數說明-4"><a class="header" href="#參數說明-4">參數說明</a></h4>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>UDP socket</td></tr>
<tr><td><code>buf</code></td><td>要發送的資料</td></tr>
<tr><td><code>len</code></td><td>資料長度</td></tr>
<tr><td><code>flags</code></td><td>發送標誌（通常為 0）</td></tr>
<tr><td><code>dest_addr</code></td><td>目標位址</td></tr>
<tr><td><code>addrlen</code></td><td>位址長度</td></tr>
</tbody></table>
</div>
<h4 id="返回值-6"><a class="header" href="#返回值-6">返回值</a></h4>
<ul>
<li><strong>成功</strong>：實際發送的位元組數</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="recvfrom---udp-接收"><a class="header" href="#recvfrom---udp-接收">recvfrom() - UDP 接收</a></h3>
<h4 id="函數原型-8"><a class="header" href="#函數原型-8">函數原型</a></h4>
<pre><code class="language-c">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
</code></pre>
<h4 id="參數說明-5"><a class="header" href="#參數說明-5">參數說明</a></h4>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>sockfd</code></td><td>UDP socket</td></tr>
<tr><td><code>buf</code></td><td>接收緩衝區</td></tr>
<tr><td><code>len</code></td><td>緩衝區大小</td></tr>
<tr><td><code>flags</code></td><td>接收標誌（通常為 0）</td></tr>
<tr><td><code>src_addr</code></td><td>來源位址（輸出參數）</td></tr>
<tr><td><code>addrlen</code></td><td>位址長度（輸入輸出參數）</td></tr>
</tbody></table>
</div>
<h4 id="返回值-7"><a class="header" href="#返回值-7">返回值</a></h4>
<ul>
<li><strong>成功</strong>：實際接收的位元組數</li>
<li><strong>失敗</strong>：-1</li>
</ul>
<h3 id="udp-完整範例"><a class="header" href="#udp-完整範例">UDP 完整範例</a></h3>
<pre><code class="language-c">// ============ UDP 伺服器 ============
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

struct sockaddr_in server_addr;
memset(&amp;server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(8080);
server_addr.sin_addr.s_addr = INADDR_ANY;

bind(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));

char buffer[1024];
struct sockaddr_in client_addr;
socklen_t addr_len = sizeof(client_addr);

while (1) {
    // 接收資料
    int n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                     (struct sockaddr*)&amp;client_addr, &amp;addr_len);
    if (n &gt; 0) {
        buffer[n] = '\0';
        printf("收到來自 %s:%d 的資料: %s\n",
               inet_ntoa(client_addr.sin_addr),
               ntohs(client_addr.sin_port),
               buffer);
        
        // 回傳資料
        sendto(sockfd, buffer, n, 0,
               (struct sockaddr*)&amp;client_addr, addr_len);
    }
}

// ============ UDP 客戶端 ============
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

struct sockaddr_in server_addr;
memset(&amp;server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(8080);
server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

char *msg = "Hello, UDP!";
sendto(sockfd, msg, strlen(msg), 0,
       (struct sockaddr*)&amp;server_addr, sizeof(server_addr));

// 接收回應
char buffer[1024];
struct sockaddr_in recv_addr;
socklen_t addr_len = sizeof(recv_addr);
int n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                 (struct sockaddr*)&amp;recv_addr, &amp;addr_len);
buffer[n] = '\0';
printf("伺服器回應: %s\n", buffer);

close(sockfd);
</code></pre>
<h3 id="udp-使用連線模式"><a class="header" href="#udp-使用連線模式">UDP 使用「連線」模式</a></h3>
<pre><code class="language-c">// UDP 也可以使用 connect()，好處：
// 1. 可以使用 send()/recv() 而非 sendto()/recvfrom()
// 2. 可以接收 ICMP 錯誤（如 ECONNREFUSED）

int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(8080);
server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

// 「連線」到伺服器
connect(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));

// 現在可以使用 send/recv
send(sockfd, "Hello", 5, 0);
char buffer[1024];
recv(sockfd, buffer, sizeof(buffer), 0);

close(sockfd);
</code></pre>
<hr />
<h2 id="io-多工機制"><a class="header" href="#io-多工機制">I/O 多工機制</a></h2>
<h3 id="socket-阻塞與非阻塞模式"><a class="header" href="#socket-阻塞與非阻塞模式">Socket 阻塞與非阻塞模式</a></h3>
<p>在討論 I/O 多工之前，需要先理解 <strong>socket 本身就有阻塞和非阻塞兩種模式</strong>。</p>
<h4 id="1-阻塞模式-blocking-io---預設模式"><a class="header" href="#1-阻塞模式-blocking-io---預設模式">1. 阻塞模式 (Blocking I/O) - 預設模式</a></h4>
<pre><code class="language-c">int sockfd = socket(AF_INET, SOCK_STREAM, 0);
// 預設就是阻塞模式

// accept() 會阻塞等待，直到有連線進來
int connfd = accept(sockfd, NULL, NULL);

// recv() 會阻塞等待，直到收到資料
recv(connfd, buffer, sizeof(buffer), 0);
</code></pre>
<h4 id="2-非阻塞模式-non-blocking-io"><a class="header" href="#2-非阻塞模式-non-blocking-io">2. 非阻塞模式 (Non-blocking I/O)</a></h4>
<pre><code class="language-c">// 設定非阻塞
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

// 或建立時直接設定 (Linux 2.6.27+)
int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);

// accept() 立即返回，沒連線就返回 -1 (errno=EAGAIN)
int connfd = accept(sockfd, NULL, NULL);

// recv() 立即返回，沒資料就返回 -1 (errno=EAGAIN)
recv(connfd, buffer, sizeof(buffer), 0);
</code></pre>
<hr />
<h3 id="為什麼需要-selectpollepoll"><a class="header" href="#為什麼需要-selectpollepoll">為什麼需要 select/poll/epoll？</a></h3>
<p><strong>問題場景：</strong></p>
<ul>
<li>你有 100 個 socket 需要監控</li>
<li>不知道哪個 socket 有資料可讀</li>
</ul>
<h4 id="-沒有-io-多工的解決方案"><a class="header" href="#-沒有-io-多工的解決方案">❌ 沒有 I/O 多工的解決方案</a></h4>
<h5 id="方案-1阻塞模式---無法同時監控多個-socket"><a class="header" href="#方案-1阻塞模式---無法同時監控多個-socket">方案 1：阻塞模式 - 無法同時監控多個 socket</a></h5>
<pre><code class="language-c">// 只能一個一個檢查，會卡在第一個 recv
recv(sock1, buf, size, 0);  // 卡在這裡
recv(sock2, buf, size, 0);  // 永遠執行不到
</code></pre>
<h5 id="方案-2非阻塞模式---cpu-空轉浪費資源"><a class="header" href="#方案-2非阻塞模式---cpu-空轉浪費資源">方案 2：非阻塞模式 - CPU 空轉浪費資源</a></h5>
<pre><code class="language-c">// 輪詢 (polling) - 不斷檢查每個 socket
while (1) {
    for (int i = 0; i &lt; 100; i++) {
        int n = recv(socks[i], buf, size, 0);
        if (n &gt; 0) {
            // 處理資料
        }
    }
    // CPU 空轉，100% 使用率！
}
</code></pre>
<h5 id="方案-3多執行緒---資源浪費"><a class="header" href="#方案-3多執行緒---資源浪費">方案 3：多執行緒 - 資源浪費</a></h5>
<pre><code class="language-c">// 為每個 socket 開一個執行緒
for (int i = 0; i &lt; 100; i++) {
    pthread_create(&amp;thread, NULL, handle_client, &amp;socks[i]);
}
// 100 個連線 = 100 個執行緒！記憶體、context switch 開銷大
</code></pre>
<h4 id="-有-selectpollepoll-的解決方案"><a class="header" href="#-有-selectpollepoll-的解決方案">✅ 有 select/poll/epoll 的解決方案</a></h4>
<pre><code class="language-c">int epfd = epoll_create1(0);

// 註冊 100 個 socket
for (int i = 0; i &lt; 100; i++) {
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = socks[i];
    epoll_ctl(epfd, EPOLL_CTL_ADD, socks[i], &amp;ev);
}

// 一次監控所有 socket，只有就緒的會被通知
struct epoll_event events[100];
while (1) {
    // 這裡會阻塞等待，但只要有任何一個 socket 就緒就會返回
    int nfds = epoll_wait(epfd, events, 100, -1);

    for (int i = 0; i &lt; nfds; i++) {
        int fd = events[i].data.fd;
        recv(fd, buffer, size, 0);  // 這裡保證有資料，不會阻塞
    }
}
</code></pre>
<p><strong>核心優勢：</strong></p>
<ol>
<li><strong>不需要輪詢</strong> - 系統會通知你哪些 socket 就緒</li>
<li><strong>不浪費 CPU</strong> - 沒有事件時進程休眠</li>
<li><strong>可擴展性好</strong> - 輕鬆處理成千上萬的連線</li>
</ol>
<hr />
<h3 id="io-模型總結對比"><a class="header" href="#io-模型總結對比">I/O 模型總結對比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>模式</th><th>優點</th><th>缺點</th><th>使用場景</th></tr></thead><tbody>
<tr><td><strong>阻塞 I/O</strong></td><td>簡單</td><td>一次只能處理一個連線</td><td>單一連線、簡單應用</td></tr>
<tr><td><strong>非阻塞 I/O (輪詢)</strong></td><td>可處理多個連線</td><td>CPU 空轉浪費</td><td><strong>不建議單獨使用</strong></td></tr>
<tr><td><strong>多執行緒/行程</strong></td><td>可處理多個連線</td><td>資源開銷大</td><td>連線數少 (&lt;100)</td></tr>
<tr><td><strong>select/poll/epoll</strong></td><td>高效監控多個連線</td><td>程式碼複雜度高</td><td><strong>高並發 (&gt;100 連線)</strong></td></tr>
</tbody></table>
</div>
<p><strong>實際使用建議：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>連線數</th><th>推薦方案</th><th>範例</th></tr></thead><tbody>
<tr><td><strong>&lt; 10</strong></td><td>阻塞 I/O + 多執行緒</td><td><code>pthread_create(&amp;tid, NULL, handle_client, &amp;connfd);</code></td></tr>
<tr><td><strong>100-1000</strong></td><td>poll + 非阻塞</td><td><code>poll(fds, nfds, -1);</code></td></tr>
<tr><td><strong>&gt; 1000</strong></td><td>epoll + 非阻塞 + 邊緣觸發</td><td><code>epoll_wait(epfd, events, MAX_EVENTS, -1);</code></td></tr>
</tbody></table>
</div>
<p><strong>核心結論：</strong></p>
<ol>
<li>✅ <strong>Socket 本身可以阻塞/非阻塞</strong> - 這是 socket 的屬性</li>
<li>✅ <strong>select/poll/epoll 用於監控多個 socket</strong> - 解決「不知道哪個 socket 就緒」的問題</li>
<li>✅ <strong>搭配使用才高效</strong> - epoll + 非阻塞是高並發伺服器的標準做法</li>
</ol>
<hr />
<h3 id="selectpollepoll-比較表"><a class="header" href="#selectpollepoll-比較表">select、poll、epoll 比較表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody>
<tr><td><strong>監控數量限制</strong></td><td>1024（FD_SETSIZE）</td><td>無限制</td><td>無限制</td></tr>
<tr><td><strong>時間複雜度</strong></td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td><strong>記憶體複製</strong></td><td>每次都要複製</td><td>每次都要複製</td><td>只需註冊一次</td></tr>
<tr><td><strong>跨平台</strong></td><td>✅ 所有 Unix/Linux/Windows</td><td>✅ 所有 Unix/Linux</td><td>❌ 僅 Linux</td></tr>
<tr><td><strong>事件通知</strong></td><td>水平觸發</td><td>水平觸發</td><td>水平/邊緣觸發</td></tr>
<tr><td><strong>適用場景</strong></td><td>&lt;100 連線</td><td>100-1000 連線</td><td>&gt;1000 連線</td></tr>
</tbody></table>
</div>
<h3 id="select---posix-標準"><a class="header" href="#select---posix-標準">select() - POSIX 標準</a></h3>
<h4 id="函數原型-9"><a class="header" href="#函數原型-9">函數原型</a></h4>
<pre><code class="language-c">#include &lt;sys/select.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<h4 id="參數說明-6"><a class="header" href="#參數說明-6">參數說明</a></h4>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>nfds</code></td><td>最大 fd + 1</td></tr>
<tr><td><code>readfds</code></td><td>監控可讀的 fd 集合</td></tr>
<tr><td><code>writefds</code></td><td>監控可寫的 fd 集合</td></tr>
<tr><td><code>exceptfds</code></td><td>監控異常的 fd 集合</td></tr>
<tr><td><code>timeout</code></td><td>超時時間</td></tr>
</tbody></table>
</div>
<h4 id="fd_set-操作巨集"><a class="header" href="#fd_set-操作巨集">fd_set 操作巨集</a></h4>
<div class="table-wrapper"><table><thead><tr><th>巨集</th><th>功能</th></tr></thead><tbody>
<tr><td><code>FD_ZERO(fd_set *set)</code></td><td>清空集合</td></tr>
<tr><td><code>FD_SET(int fd, fd_set *set)</code></td><td>加入 fd</td></tr>
<tr><td><code>FD_CLR(int fd, fd_set *set)</code></td><td>移除 fd</td></tr>
<tr><td><code>FD_ISSET(int fd, fd_set *set)</code></td><td>檢查 fd 是否就緒</td></tr>
</tbody></table>
</div>
<h4 id="使用範例-6"><a class="header" href="#使用範例-6">使用範例</a></h4>
<pre><code class="language-c">fd_set readfds;
struct timeval timeout;

while (1) {
    FD_ZERO(&amp;readfds);
    FD_SET(sockfd, &amp;readfds);
    
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    
    int ret = select(sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout);
    
    if (ret &gt; 0 &amp;&amp; FD_ISSET(sockfd, &amp;readfds)) {
        // sockfd 可讀
        recv(sockfd, buffer, sizeof(buffer), 0);
    }
}
</code></pre>
<h3 id="poll---system-v-標準"><a class="header" href="#poll---system-v-標準">poll() - System V 標準</a></h3>
<h4 id="函數原型-10"><a class="header" href="#函數原型-10">函數原型</a></h4>
<pre><code class="language-c">#include &lt;poll.h&gt;

int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd {
    int   fd;       // 檔案描述符
    short events;   // 要監控的事件
    short revents;  // 實際發生的事件
};
</code></pre>
<h4 id="events-標誌"><a class="header" href="#events-標誌">events 標誌</a></h4>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>POLLIN</code></td><td>有資料可讀</td></tr>
<tr><td><code>POLLOUT</code></td><td>可以寫入資料</td></tr>
<tr><td><code>POLLERR</code></td><td>發生錯誤</td></tr>
<tr><td><code>POLLHUP</code></td><td>連線掛斷</td></tr>
<tr><td><code>POLLNVAL</code></td><td>無效的 fd</td></tr>
</tbody></table>
</div>
<h4 id="使用範例-7"><a class="header" href="#使用範例-7">使用範例</a></h4>
<pre><code class="language-c">struct pollfd fds[2];
fds[0].fd = sockfd;
fds[0].events = POLLIN | POLLOUT;

while (1) {
    int ret = poll(fds, 1, 5000);  // 5 秒超時
    
    if (ret &gt; 0) {
        if (fds[0].revents &amp; POLLIN) {
            recv(sockfd, buffer, sizeof(buffer), 0);
        }
        if (fds[0].revents &amp; POLLOUT) {
            send(sockfd, data, len, 0);
        }
    }
}
</code></pre>
<h3 id="epoll---linux-專用高效能方案"><a class="header" href="#epoll---linux-專用高效能方案">epoll() - Linux 專用高效能方案</a></h3>
<h4 id="三個核心函數"><a class="header" href="#三個核心函數">三個核心函數</a></h4>
<h5 id="1-epoll_create1---建立-epoll-實例"><a class="header" href="#1-epoll_create1---建立-epoll-實例">1. epoll_create1() - 建立 epoll 實例</a></h5>
<pre><code class="language-c">int epoll_create1(int flags);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>flags</code></td><td>0 或 <code>EPOLL_CLOEXEC</code></td></tr>
<tr><td><strong>返回值</strong></td><td>epoll 檔案描述符</td></tr>
</tbody></table>
</div>
<h5 id="2-epoll_ctl---控制-epoll"><a class="header" href="#2-epoll_ctl---控制-epoll">2. epoll_ctl() - 控制 epoll</a></h5>
<pre><code class="language-c">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>epfd</code></td><td>epoll 實例</td></tr>
<tr><td><code>op</code></td><td>操作（ADD/MOD/DEL）</td></tr>
<tr><td><code>fd</code></td><td>要操作的檔案描述符</td></tr>
<tr><td><code>event</code></td><td>事件結構</td></tr>
</tbody></table>
</div>
<p><strong>op 操作類型：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>說明</th></tr></thead><tbody>
<tr><td><code>EPOLL_CTL_ADD</code></td><td>加入新的監控</td></tr>
<tr><td><code>EPOLL_CTL_MOD</code></td><td>修改已有的監控</td></tr>
<tr><td><code>EPOLL_CTL_DEL</code></td><td>刪除監控</td></tr>
</tbody></table>
</div>
<h5 id="3-epoll_wait---等待事件"><a class="header" href="#3-epoll_wait---等待事件">3. epoll_wait() - 等待事件</a></h5>
<pre><code class="language-c">int epoll_wait(int epfd, struct epoll_event *events, 
               int maxevents, int timeout);
</code></pre>
<h4 id="epoll_event-結構"><a class="header" href="#epoll_event-結構">epoll_event 結構</a></h4>
<pre><code class="language-c">struct epoll_event {
    uint32_t     events;   // 事件類型
    epoll_data_t data;     // 使用者資料
};

typedef union epoll_data {
    void    *ptr;
    int      fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
</code></pre>
<h4 id="events-標誌-1"><a class="header" href="#events-標誌-1">events 標誌</a></h4>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>EPOLLIN</code></td><td>可讀</td></tr>
<tr><td><code>EPOLLOUT</code></td><td>可寫</td></tr>
<tr><td><code>EPOLLET</code></td><td><strong>邊緣觸發模式</strong></td></tr>
<tr><td><code>EPOLLONESHOT</code></td><td>只觸發一次</td></tr>
<tr><td><code>EPOLLRDHUP</code></td><td>對端關閉連線</td></tr>
</tbody></table>
</div>
<h4 id="觸發模式對比"><a class="header" href="#觸發模式對比">觸發模式對比</a></h4>
<div class="table-wrapper"><table><thead><tr><th>模式</th><th>說明</th><th>優缺點</th></tr></thead><tbody>
<tr><td><strong>水平觸發（LT）</strong></td><td>只要有資料就通知</td><td>簡單，但可能重複通知</td></tr>
<tr><td><strong>邊緣觸發（ET）</strong></td><td>狀態變化時才通知一次</td><td>高效能，但必須一次讀完</td></tr>
</tbody></table>
</div>
<h4 id="完整範例"><a class="header" href="#完整範例">完整範例</a></h4>
<pre><code class="language-c">// 1. 建立 epoll
int epfd = epoll_create1(0);

// 2. 註冊監聽 socket
struct epoll_event ev;
ev.events = EPOLLIN | EPOLLET;
ev.data.fd = listenfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);

// 3. 事件迴圈
struct epoll_event events[MAX_EVENTS];
while (1) {
    int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
    
    for (int i = 0; i &lt; nfds; i++) {
        int fd = events[i].data.fd;
        
        if (fd == listenfd) {
            // 處理新連線
            int connfd = accept(listenfd, NULL, NULL);
            setnonblocking(connfd);
            
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = connfd;
            epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);
        } else {
            // 處理資料
            if (events[i].events &amp; EPOLLIN) {
                // 邊緣觸發必須迴圈讀取
                while (1) {
                    int n = recv(fd, buffer, sizeof(buffer), 0);
                    if (n &gt; 0) {
                        // 處理資料
                    } else if (n == 0 || errno != EAGAIN) {
                        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
                        close(fd);
                        break;
                    } else {
                        break;  // 資料讀完
                    }
                }
            }
        }
    }
}
</code></pre>
<hr />
<h2 id="socket-選項設定"><a class="header" href="#socket-選項設定">Socket 選項設定</a></h2>
<h3 id="getsockopt--setsockopt"><a class="header" href="#getsockopt--setsockopt">getsockopt() / setsockopt()</a></h3>
<h4 id="函數原型-11"><a class="header" href="#函數原型-11">函數原型</a></h4>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int getsockopt(int sockfd, int level, int optname,
               void *optval, socklen_t *optlen);

int setsockopt(int sockfd, int level, int optname,
               const void *optval, socklen_t optlen);
</code></pre>
<h3 id="sol_socket-層級選項"><a class="header" href="#sol_socket-層級選項">SOL_SOCKET 層級選項</a></h3>
<div class="table-wrapper"><table><thead><tr><th>選項</th><th>資料型別</th><th>說明</th><th>預設值</th></tr></thead><tbody>
<tr><td><code>SO_REUSEADDR</code></td><td>int</td><td>允許重用本地位址</td><td>0（關閉）</td></tr>
<tr><td><code>SO_REUSEPORT</code></td><td>int</td><td>允許多個 socket 綁定同一埠</td><td>0（關閉）</td></tr>
<tr><td><code>SO_KEEPALIVE</code></td><td>int</td><td>啟用 TCP keepalive</td><td>0（關閉）</td></tr>
<tr><td><code>SO_RCVBUF</code></td><td>int</td><td>接收緩衝區大小（位元組）</td><td>系統預設</td></tr>
<tr><td><code>SO_SNDBUF</code></td><td>int</td><td>傳送緩衝區大小（位元組）</td><td>系統預設</td></tr>
<tr><td><code>SO_RCVTIMEO</code></td><td>struct timeval</td><td>接收超時</td><td>無限等待</td></tr>
<tr><td><code>SO_SNDTIMEO</code></td><td>struct timeval</td><td>傳送超時</td><td>無限等待</td></tr>
<tr><td><code>SO_LINGER</code></td><td>struct linger</td><td>關閉時行為</td><td>優雅關閉</td></tr>
<tr><td><code>SO_BROADCAST</code></td><td>int</td><td>允許廣播（UDP）</td><td>0（關閉）</td></tr>
<tr><td><code>SO_ERROR</code></td><td>int</td><td>取得錯誤狀態（唯讀）</td><td>-</td></tr>
<tr><td><code>SO_TYPE</code></td><td>int</td><td>取得 socket 類型（唯讀）</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="ipproto_tcp-層級選項"><a class="header" href="#ipproto_tcp-層級選項">IPPROTO_TCP 層級選項</a></h3>
<div class="table-wrapper"><table><thead><tr><th>選項</th><th>資料型別</th><th>說明</th><th>預設值</th></tr></thead><tbody>
<tr><td><code>TCP_NODELAY</code></td><td>int</td><td>禁用 Nagle 演算法</td><td>0（啟用 Nagle）</td></tr>
<tr><td><code>TCP_KEEPIDLE</code></td><td>int</td><td>Keepalive 開始時間（秒）</td><td>7200</td></tr>
<tr><td><code>TCP_KEEPINTVL</code></td><td>int</td><td>Keepalive 間隔（秒）</td><td>75</td></tr>
<tr><td><code>TCP_KEEPCNT</code></td><td>int</td><td>Keepalive 重試次數</td><td>9</td></tr>
<tr><td><code>TCP_CORK</code></td><td>int</td><td>暫停資料傳送（攢夠再發）</td><td>0（關閉）</td></tr>
<tr><td><code>TCP_DEFER_ACCEPT</code></td><td>int</td><td>延遲 accept（有資料才喚醒）</td><td>0（關閉）</td></tr>
<tr><td><code>TCP_QUICKACK</code></td><td>int</td><td>快速確認（禁用延遲 ACK）</td><td>0（啟用延遲）</td></tr>
</tbody></table>
</div>
<h3 id="ipproto_ip-層級選項"><a class="header" href="#ipproto_ip-層級選項">IPPROTO_IP 層級選項</a></h3>
<div class="table-wrapper"><table><thead><tr><th>選項</th><th>資料型別</th><th>說明</th></tr></thead><tbody>
<tr><td><code>IP_TOS</code></td><td>int</td><td>設定 Type of Service</td></tr>
<tr><td><code>IP_TTL</code></td><td>int</td><td>設定 Time to Live</td></tr>
<tr><td><code>IP_MULTICAST_LOOP</code></td><td>int</td><td>多播封包是否回環</td></tr>
<tr><td><code>IP_MULTICAST_TTL</code></td><td>int</td><td>多播封包 TTL</td></tr>
<tr><td><code>IP_ADD_MEMBERSHIP</code></td><td>struct ip_mreq</td><td>加入多播群組</td></tr>
<tr><td><code>IP_DROP_MEMBERSHIP</code></td><td>struct ip_mreq</td><td>離開多播群組</td></tr>
</tbody></table>
</div>
<h3 id="常用範例"><a class="header" href="#常用範例">常用範例</a></h3>
<pre><code class="language-c">// 1. SO_REUSEADDR（伺服器必備）
int reuse = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));

// 2. SO_REUSEPORT（負載均衡）
int reuse_port = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;reuse_port, sizeof(reuse_port));

// 3. TCP_NODELAY（低延遲）
int nodelay = 1;
setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;nodelay, sizeof(nodelay));

// 4. SO_KEEPALIVE + 參數設定
int keepalive = 1;
int idle = 60;        // 60 秒後開始
int interval = 5;     // 每 5 秒一次
int count = 3;        // 失敗 3 次斷線

setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;keepalive, sizeof(keepalive));
setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle));
setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;interval, sizeof(interval));
setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPCNT, &amp;count, sizeof(count));

// 5. SO_LINGER（控制 close 行為）
struct linger lng;
lng.l_onoff = 1;
lng.l_linger = 0;  // 立即關閉，發送 RST
setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;lng, sizeof(lng));

// 6. SO_RCVTIMEO（接收超時）
struct timeval timeout;
timeout.tv_sec = 5;
timeout.tv_usec = 0;
setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout));

// 7. SO_RCVBUF / SO_SNDBUF（緩衝區大小）
int buf_size = 64 * 1024;  // 64KB
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;buf_size, sizeof(buf_size));
setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;buf_size, sizeof(buf_size));

// 8. 取得 socket 類型
int type;
socklen_t len = sizeof(type);
getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &amp;type, &amp;len);
if (type == SOCK_STREAM) {
    printf("TCP socket\n");
} else if (type == SOCK_DGRAM) {
    printf("UDP socket\n");
}

// 9. 取得錯誤狀態（非阻塞 connect 後使用）
int error;
socklen_t len = sizeof(error);
getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);
if (error == 0) {
    printf("連線成功\n");
}
</code></pre>
<hr />
<h2 id="資料收發函數"><a class="header" href="#資料收發函數">資料收發函數</a></h2>
<h3 id="函數總覽"><a class="header" href="#函數總覽">函數總覽</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函數</th><th>TCP</th><th>UDP</th><th>說明</th></tr></thead><tbody>
<tr><td><code>recv()</code></td><td>✅</td><td>✅</td><td>接收資料</td></tr>
<tr><td><code>send()</code></td><td>✅</td><td>✅</td><td>傳送資料</td></tr>
<tr><td><code>recvfrom()</code></td><td>✅</td><td>✅</td><td>接收資料（含來源位址）</td></tr>
<tr><td><code>sendto()</code></td><td>✅</td><td>✅</td><td>傳送資料（指定目標位址）</td></tr>
<tr><td><code>read()</code></td><td>✅</td><td>✅</td><td>POSIX 讀取（無標誌）</td></tr>
<tr><td><code>write()</code></td><td>✅</td><td>✅</td><td>POSIX 寫入（無標誌）</td></tr>
<tr><td><code>recvmsg()</code></td><td>✅</td><td>✅</td><td>高階接收（支援控制訊息）</td></tr>
<tr><td><code>sendmsg()</code></td><td>✅</td><td>✅</td><td>高階傳送（支援控制訊息）</td></tr>
</tbody></table>
</div>
<h3 id="recv---接收資料"><a class="header" href="#recv---接收資料">recv() - 接收資料</a></h3>
<h4 id="函數原型-12"><a class="header" href="#函數原型-12">函數原型</a></h4>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
</code></pre>
<h4 id="flags-標誌"><a class="header" href="#flags-標誌">flags 標誌</a></h4>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>預設行為（最常用）</td></tr>
<tr><td><code>MSG_PEEK</code></td><td>偷看資料但不移除</td></tr>
<tr><td><code>MSG_WAITALL</code></td><td>等到收滿 len 位元組</td></tr>
<tr><td><code>MSG_DONTWAIT</code></td><td>非阻塞接收（單次）</td></tr>
<tr><td><code>MSG_OOB</code></td><td>接收帶外資料</td></tr>
<tr><td><code>MSG_TRUNC</code></td><td>返回真實長度（即使被截斷）</td></tr>
</tbody></table>
</div>
<h4 id="返回值說明"><a class="header" href="#返回值說明">返回值說明</a></h4>
<div class="table-wrapper"><table><thead><tr><th>返回值</th><th>說明</th></tr></thead><tbody>
<tr><td><code>&gt; 0</code></td><td>實際接收的位元組數</td></tr>
<tr><td><code>0</code></td><td>對方關閉連線（TCP）</td></tr>
<tr><td><code>-1</code></td><td>錯誤（檢查 errno）</td></tr>
</tbody></table>
</div>
<h4 id="常見-errno"><a class="header" href="#常見-errno">常見 errno</a></h4>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th><th>處理方式</th></tr></thead><tbody>
<tr><td><code>EAGAIN</code> / <code>EWOULDBLOCK</code></td><td>非阻塞模式無資料</td><td>稍後重試</td></tr>
<tr><td><code>EINTR</code></td><td>被信號中斷</td><td>重新呼叫</td></tr>
<tr><td><code>ECONNRESET</code></td><td>連線被重置</td><td>關閉 socket</td></tr>
<tr><td><code>ETIMEDOUT</code></td><td>接收超時</td><td>關閉 socket</td></tr>
</tbody></table>
</div>
<h4 id="使用範例-8"><a class="header" href="#使用範例-8">使用範例</a></h4>
<pre><code class="language-c">// 1. 基本用法
char buffer[1024];
int n = recv(sockfd, buffer, sizeof(buffer), 0);
if (n &gt; 0) {
    printf("收到 %d 位元組\n", n);
} else if (n == 0) {
    printf("對方關閉連線\n");
} else {
    perror("recv");
}

// 2. 偷看資料（不移除）
int n = recv(sockfd, buffer, sizeof(buffer), MSG_PEEK);
// 資料還在緩衝區，下次 recv 還會讀到

// 3. 非阻塞處理
int n = recv(sockfd, buffer, sizeof(buffer), 0);
if (n == -1) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // 無資料，稍後再試
    } else {
        perror("recv");
    }
}

// 4. 邊緣觸發必須迴圈讀取
while (1) {
    int n = recv(sockfd, buffer, sizeof(buffer), 0);
    if (n &gt; 0) {
        // 處理資料
    } else if (n == 0) {
        break;  // 對方關閉
    } else {
        if (errno == EAGAIN) {
            break;  // 讀完了
        }
        perror("recv");
        break;
    }
}

// 5. 確保接收指定長度
int total = 0;
int len = 1024;
while (total &lt; len) {
    int n = recv(sockfd, buffer + total, len - total, 0);
    if (n &gt; 0) {
        total += n;
    } else if (n == 0) {
        printf("連線關閉，只收到 %d 位元組\n", total);
        break;
    } else {
        perror("recv");
        break;
    }
}
</code></pre>
<h3 id="send---傳送資料"><a class="header" href="#send---傳送資料">send() - 傳送資料</a></h3>
<h4 id="函數原型-13"><a class="header" href="#函數原型-13">函數原型</a></h4>
<pre><code class="language-c">ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre>
<h4 id="flags-標誌-1"><a class="header" href="#flags-標誌-1">flags 標誌</a></h4>
<div class="table-wrapper"><table><thead><tr><th>標誌</th><th>說明</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>預設行為</td></tr>
<tr><td><code>MSG_NOSIGNAL</code></td><td>不產生 SIGPIPE 信號</td></tr>
<tr><td><code>MSG_DONTWAIT</code></td><td>非阻塞發送</td></tr>
<tr><td><code>MSG_MORE</code></td><td>還有更多資料（減少封包數）</td></tr>
<tr><td><code>MSG_OOB</code></td><td>發送帶外資料</td></tr>
</tbody></table>
</div>
<h4 id="返回值-8"><a class="header" href="#返回值-8">返回值</a></h4>
<div class="table-wrapper"><table><thead><tr><th>返回值</th><th>說明</th></tr></thead><tbody>
<tr><td><code>&gt; 0</code></td><td>實際傳送的位元組數（可能小於 len）</td></tr>
<tr><td><code>-1</code></td><td>錯誤</td></tr>
</tbody></table>
</div>
<h4 id="常見-errno-1"><a class="header" href="#常見-errno-1">常見 errno</a></h4>
<div class="table-wrapper"><table><thead><tr><th>errno</th><th>說明</th></tr></thead><tbody>
<tr><td><code>EAGAIN</code> / <code>EWOULDBLOCK</code></td><td>傳送緩衝區滿</td></tr>
<tr><td><code>EPIPE</code></td><td>連線已斷（會觸發 SIGPIPE）</td></tr>
<tr><td><code>ECONNRESET</code></td><td>連線被重置</td></tr>
</tbody></table>
</div>
<h4 id="使用範例-9"><a class="header" href="#使用範例-9">使用範例</a></h4>
<pre><code class="language-c">// 1. 基本用法
char *data = "Hello, World!";
int n = send(sockfd, data, strlen(data), 0);

// 2. 避免 SIGPIPE
send(sockfd, data, len, MSG_NOSIGNAL);

// 3. 確保全部發送
int total = 0;
int len = strlen(data);
while (total &lt; len) {
    int n = send(sockfd, data + total, len - total, MSG_NOSIGNAL);
    if (n &gt; 0) {
        total += n;
    } else if (n == -1) {
        if (errno == EAGAIN) {
            continue;  // 緩衝區滿，稍後再試
        }
        perror("send");
        break;
    }
}

// 4. MSG_MORE 優化（減少封包數）
send(sockfd, header, header_len, MSG_MORE | MSG_NOSIGNAL);
send(sockfd, body, body_len, MSG_NOSIGNAL);  // 最後一次不加 MSG_MORE
</code></pre>
<h3 id="recvfrom--sendto---udp-專用"><a class="header" href="#recvfrom--sendto---udp-專用">recvfrom() / sendto() - UDP 專用</a></h3>
<p>見前面 UDP 專用函數章節。</p>
<h3 id="read--write---posix-標準"><a class="header" href="#read--write---posix-標準">read() / write() - POSIX 標準</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
</code></pre>
<p><strong>與 recv/send 的區別：</strong></p>
<ul>
<li><code>read/write</code> 不支援 flags 參數</li>
<li><code>read/write</code> 是通用 I/O 函數，不限於 socket</li>
<li><code>recv/send</code> 是專門為 socket 設計的</li>
</ul>
<hr />
<h2 id="位址轉換函數"><a class="header" href="#位址轉換函數">位址轉換函數</a></h2>
<h3 id="字串--二進位"><a class="header" href="#字串--二進位">字串 ↔ 二進位</a></h3>
<h4 id="inet_pton--inet_ntop---推薦使用"><a class="header" href="#inet_pton--inet_ntop---推薦使用">inet_pton() / inet_ntop() - 推薦使用</a></h4>
<pre><code class="language-c">#include &lt;arpa/inet.h&gt;

// 字串 → 二進位
int inet_pton(int af, const char *src, void *dst);

// 二進位 → 字串
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>af</code></td><td><code>AF_INET</code> 或 <code>AF_INET6</code></td></tr>
<tr><td><code>src</code></td><td>來源位址</td></tr>
<tr><td><code>dst</code></td><td>目標緩衝區</td></tr>
<tr><td><code>size</code></td><td>緩衝區大小</td></tr>
</tbody></table>
</div>
<p><strong>使用範例：</strong></p>
<pre><code class="language-c">// IPv4 字串 → 二進位
struct sockaddr_in addr;
inet_pton(AF_INET, "192.168.1.100", &amp;addr.sin_addr);

// IPv4 二進位 → 字串
char ip_str[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &amp;addr.sin_addr, ip_str, sizeof(ip_str));
printf("IP: %s\n", ip_str);

// IPv6
struct sockaddr_in6 addr6;
inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr);

char ip6_str[INET6_ADDRSTRLEN];
inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip6_str, sizeof(ip6_str));
</code></pre>
<h4 id="inet_addr--inet_ntoa---舊版-api"><a class="header" href="#inet_addr--inet_ntoa---舊版-api">inet_addr() / inet_ntoa() - 舊版 API</a></h4>
<pre><code class="language-c">// 字串 → 二進位（僅 IPv4）
in_addr_t inet_addr(const char *cp);

// 二進位 → 字串（僅 IPv4，不可重入）
char *inet_ntoa(struct in_addr in);
</code></pre>
<p><strong>注意</strong>：<code>inet_ntoa()</code> 不是執行緒安全的！</p>
<h3 id="主機名稱解析"><a class="header" href="#主機名稱解析">主機名稱解析</a></h3>
<h4 id="getaddrinfo--getnameinfo---現代方法"><a class="header" href="#getaddrinfo--getnameinfo---現代方法">getaddrinfo() / getnameinfo() - 現代方法</a></h4>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);

void freeaddrinfo(struct addrinfo *res);

int getnameinfo(const struct sockaddr *addr, socklen_t addrlen,
                char *host, socklen_t hostlen,
                char *serv, socklen_t servlen, int flags);
</code></pre>
<p><strong>使用範例：</strong></p>
<pre><code class="language-c">// 解析主機名稱
struct addrinfo hints, *res;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_UNSPEC;     // IPv4 或 IPv6
hints.ai_socktype = SOCK_STREAM; // TCP

int ret = getaddrinfo("www.google.com", "80", &amp;hints, &amp;res);
if (ret == 0) {
    // 使用 res
    int sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    
    freeaddrinfo(res);  // 釋放記憶體
}

// 反向解析（位址 → 主機名稱）
struct sockaddr_in addr;
char host[NI_MAXHOST];
char serv[NI_MAXSERV];

getnameinfo((struct sockaddr*)&amp;addr, sizeof(addr),
            host, sizeof(host),
            serv, sizeof(serv),
            NI_NUMERICSERV);
printf("主機: %s, 埠: %s\n", host, serv);
</code></pre>
<h3 id="位元組序轉換"><a class="header" href="#位元組序轉換">位元組序轉換</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函數</th><th>說明</th></tr></thead><tbody>
<tr><td><code>htons()</code></td><td>Host to Network Short（16 位元）</td></tr>
<tr><td><code>htonl()</code></td><td>Host to Network Long（32 位元）</td></tr>
<tr><td><code>ntohs()</code></td><td>Network to Host Short（16 位元）</td></tr>
<tr><td><code>ntohl()</code></td><td>Network to Host Long（32 位元）</td></tr>
</tbody></table>
</div>
<pre><code class="language-c">// 埠號必須轉換為網路位元組序
uint16_t port = 8080;
addr.sin_port = htons(port);

// IP 位址也要轉換
uint32_t ip = 0xC0A80164;  // 192.168.1.100
addr.sin_addr.s_addr = htonl(ip);

// 讀取時轉回主機位元組序
uint16_t local_port = ntohs(addr.sin_port);
</code></pre>
<hr />
<h2 id="完整範例程式"><a class="header" href="#完整範例程式">完整範例程式</a></h2>
<h3 id="tcp-echo-伺服器epoll--非阻塞--et"><a class="header" href="#tcp-echo-伺服器epoll--非阻塞--et">TCP Echo 伺服器（epoll + 非阻塞 + ET）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define PORT 8080
#define MAX_EVENTS 1024
#define BUFFER_SIZE 4096

// 設定非阻塞
void setnonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

int main() {
    // 1. 建立 socket
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd &lt; 0) {
        perror("socket");
        exit(1);
    }
    
    // 2. 設定 SO_REUSEADDR
    int reuse = 1;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));
    
    // 3. 綁定位址
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;
    
    if (bind(listenfd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {
        perror("bind");
        exit(1);
    }
    
    // 4. 開始監聽
    if (listen(listenfd, 128) &lt; 0) {
        perror("listen");
        exit(1);
    }
    
    printf("伺服器正在監聽埠 %d...\n", PORT);
    
    // 5. 設定非阻塞
    setnonblocking(listenfd);
    
    // 6. 建立 epoll
    int epfd = epoll_create1(0);
    if (epfd &lt; 0) {
        perror("epoll_create1");
        exit(1);
    }
    
    // 7. 註冊監聽 socket（邊緣觸發）
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET;
    ev.data.fd = listenfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);
    
    // 8. 事件迴圈
    struct epoll_event events[MAX_EVENTS];
    char buffer[BUFFER_SIZE];
    
    while (1) {
        int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
        if (nfds &lt; 0) {
            perror("epoll_wait");
            continue;
        }
        
        for (int i = 0; i &lt; nfds; i++) {
            int fd = events[i].data.fd;
            
            // 新連線
            if (fd == listenfd) {
                while (1) {
                    struct sockaddr_in client_addr;
                    socklen_t len = sizeof(client_addr);
                    int connfd = accept(listenfd, (struct sockaddr*)&amp;client_addr, &amp;len);
                    
                    if (connfd &lt; 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            break;  // 沒有新連線了
                        }
                        perror("accept");
                        break;
                    }
                    
                    printf("新連線: %s:%d (fd=%d)\n",
                           inet_ntoa(client_addr.sin_addr),
                           ntohs(client_addr.sin_port),
                           connfd);
                    
                    // 設定非阻塞
                    setnonblocking(connfd);
                    
                    // 加入 epoll
                    ev.events = EPOLLIN | EPOLLET;
                    ev.data.fd = connfd;
                    epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);
                }
            }
            // 客戶端資料
            else {
                if (events[i].events &amp; EPOLLIN) {
                    // 邊緣觸發必須迴圈讀取
                    while (1) {
                        int n = recv(fd, buffer, sizeof(buffer), 0);
                        
                        if (n &gt; 0) {
                            printf("收到 %d 位元組 (fd=%d)\n", n, fd);
                            
                            // Echo 回去
                            int sent = 0;
                            while (sent &lt; n) {
                                int s = send(fd, buffer + sent, n - sent, MSG_NOSIGNAL);
                                if (s &gt; 0) {
                                    sent += s;
                                } else if (s == -1) {
                                    if (errno != EAGAIN) {
                                        perror("send");
                                        goto close_conn;
                                    }
                                    break;
                                }
                            }
                        } else if (n == 0) {
                            printf("客戶端關閉連線 (fd=%d)\n", fd);
                            goto close_conn;
                        } else {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                break;  // 資料讀完了
                            }
                            perror("recv");
                            goto close_conn;
                        }
                    }
                }
                
                if (events[i].events &amp; (EPOLLERR | EPOLLHUP)) {
                    printf("連線錯誤或掛斷 (fd=%d)\n", fd);
                    goto close_conn;
                }
                
                continue;
                
close_conn:
                epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
                close(fd);
            }
        }
    }
    
    close(epfd);
    close(listenfd);
    return 0;
}
</code></pre>
<h3 id="tcp-客戶端"><a class="header" href="#tcp-客戶端">TCP 客戶端</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 8080

int main() {
    // 1. 建立 socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        exit(1);
    }
    
    // 2. 連線到伺服器
    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &amp;server_addr.sin_addr);
    
    if (connect(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
        perror("connect");
        exit(1);
    }
    
    printf("已連線到伺服器 %s:%d\n", SERVER_IP, SERVER_PORT);
    
    // 3. 發送和接收資料
    char buffer[1024];
    while (1) {
        printf("輸入訊息: ");
        fgets(buffer, sizeof(buffer), stdin);
        
        // 移除換行符
        buffer[strcspn(buffer, "\n")] = 0;
        
        if (strlen(buffer) == 0) {
            continue;
        }
        
        if (strcmp(buffer, "quit") == 0) {
            break;
        }
        
        // 發送資料
        int len = strlen(buffer);
        int sent = 0;
        while (sent &lt; len) {
            int n = send(sockfd, buffer + sent, len - sent, 0);
            if (n &gt; 0) {
                sent += n;
            } else {
                perror("send");
                goto cleanup;
            }
        }
        
        // 接收回應
        int n = recv(sockfd, buffer, sizeof(buffer) - 1, 0);
        if (n &gt; 0) {
            buffer[n] = '\0';
            printf("伺服器回應: %s\n", buffer);
        } else if (n == 0) {
            printf("伺服器關閉連線\n");
            break;
        } else {
            perror("recv");
            break;
        }
    }
    
cleanup:
    close(sockfd);
    return 0;
}
</code></pre>
<h3 id="udp-echo-伺服器"><a class="header" href="#udp-echo-伺服器">UDP Echo 伺服器</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    // 1. 建立 UDP socket
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        exit(1);
    }
    
    // 2. 綁定位址
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;
    
    if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {
        perror("bind");
        exit(1);
    }
    
    printf("UDP 伺服器正在監聽埠 %d...\n", PORT);
    
    // 3. 接收和發送資料
    char buffer[BUFFER_SIZE];
    struct sockaddr_in client_addr;
    socklen_t addr_len;
    
    while (1) {
        addr_len = sizeof(client_addr);
        
        // 接收資料
        int n = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,
                        (struct sockaddr*)&amp;client_addr, &amp;addr_len);
        
        if (n &gt; 0) {
            buffer[n] = '\0';
            printf("收到來自 %s:%d 的資料: %s\n",
                   inet_ntoa(client_addr.sin_addr),
                   ntohs(client_addr.sin_port),
                   buffer);
            
            // Echo 回去
            sendto(sockfd, buffer, n, 0,
                   (struct sockaddr*)&amp;client_addr, addr_len);
        } else if (n &lt; 0) {
            perror("recvfrom");
        }
    }
    
    close(sockfd);
    return 0;
}
</code></pre>
<h3 id="udp-客戶端"><a class="header" href="#udp-客戶端">UDP 客戶端</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 8080

int main() {
    // 1. 建立 UDP socket
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        exit(1);
    }
    
    // 2. 設定伺服器位址
    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &amp;server_addr.sin_addr);
    
    // 3. 發送和接收資料
    char buffer[1024];
    while (1) {
        printf("輸入訊息: ");
        fgets(buffer, sizeof(buffer), stdin);
        buffer[strcspn(buffer, "\n")] = 0;
        
        if (strlen(buffer) == 0) {
            continue;
        }
        
        if (strcmp(buffer, "quit") == 0) {
            break;
        }
        
        // 發送資料
        sendto(sockfd, buffer, strlen(buffer), 0,
               (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
        
        // 接收回應
        struct sockaddr_in recv_addr;
        socklen_t addr_len = sizeof(recv_addr);
        int n = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,
                        (struct sockaddr*)&amp;recv_addr, &amp;addr_len);
        
        if (n &gt; 0) {
            buffer[n] = '\0';
            printf("伺服器回應: %s\n", buffer);
        }
    }
    
    close(sockfd);
    return 0;
}
</code></pre>
<hr />
<h2 id="編譯和執行"><a class="header" href="#編譯和執行">編譯和執行</a></h2>
<h3 id="編譯命令"><a class="header" href="#編譯命令">編譯命令</a></h3>
<pre><code class="language-bash"># TCP 伺服器
gcc -o tcp_server tcp_server.c -Wall -O2

# TCP 客戶端
gcc -o tcp_client tcp_client.c -Wall -O2

# UDP 伺服器
gcc -o udp_server udp_server.c -Wall -O2

# UDP 客戶端
gcc -o udp_client udp_client.c -Wall -O2
</code></pre>
<h3 id="執行"><a class="header" href="#執行">執行</a></h3>
<pre><code class="language-bash"># 終端機 1：啟動伺服器
./tcp_server

# 終端機 2：啟動客戶端
./tcp_client
</code></pre>
<hr />
<h2 id="最佳實踐建議"><a class="header" href="#最佳實踐建議">最佳實踐建議</a></h2>
<h3 id="1-socket-選項設定"><a class="header" href="#1-socket-選項設定">1. Socket 選項設定</a></h3>
<div class="table-wrapper"><table><thead><tr><th>場景</th><th>必要設定</th></tr></thead><tbody>
<tr><td><strong>TCP 伺服器</strong></td><td>SO_REUSEADDR</td></tr>
<tr><td><strong>低延遲應用</strong></td><td>TCP_NODELAY</td></tr>
<tr><td><strong>長連線</strong></td><td>SO_KEEPALIVE + 參數</td></tr>
<tr><td><strong>高並發</strong></td><td>epoll + 非阻塞 + 邊緣觸發</td></tr>
</tbody></table>
</div>
<h3 id="2-錯誤處理"><a class="header" href="#2-錯誤處理">2. 錯誤處理</a></h3>
<pre><code class="language-c">// EAGAIN/EWOULDBLOCK - 重試
if (errno == EAGAIN || errno == EWOULDBLOCK) {
    // 正常，稍後重試
}

// EINTR - 重新呼叫
if (errno == EINTR) {
    // 被信號中斷，重新呼叫
}

// EPIPE/ECONNRESET - 關閉連線
if (errno == EPIPE || errno == ECONNRESET) {
    close(sockfd);
}
</code></pre>
<h3 id="3-io-模型選擇"><a class="header" href="#3-io-模型選擇">3. I/O 模型選擇</a></h3>
<div class="table-wrapper"><table><thead><tr><th>連線數</th><th>推薦方案</th></tr></thead><tbody>
<tr><td>&lt; 100</td><td>select 或阻塞 I/O</td></tr>
<tr><td>100-1000</td><td>poll</td></tr>
<tr><td>&gt; 1000</td><td>epoll（Linux）</td></tr>
</tbody></table>
</div>
<h3 id="4-記憶體管理"><a class="header" href="#4-記憶體管理">4. 記憶體管理</a></h3>
<pre><code class="language-c">// 使用完後釋放
freeaddrinfo(res);

// 關閉 fd
close(sockfd);

// epoll 刪除監控
epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
</code></pre>
<hr />
<h2 id="參考資源"><a class="header" href="#參考資源">參考資源</a></h2>
<h3 id="線上手冊"><a class="header" href="#線上手冊">線上手冊</a></h3>
<pre><code class="language-bash">man 2 socket
man 2 bind
man 7 tcp
man 7 udp
man 7 ip
man 7 epoll
</code></pre>
<h3 id="重要標頭檔"><a class="header" href="#重要標頭檔">重要標頭檔</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;    // socket, bind, listen, accept, connect
#include &lt;netinet/in.h&gt;    // sockaddr_in, INADDR_ANY
#include &lt;arpa/inet.h&gt;     // inet_pton, inet_ntop
#include &lt;sys/epoll.h&gt;     // epoll_create1, epoll_ctl, epoll_wait
#include &lt;fcntl.h&gt;         // fcntl, O_NONBLOCK
#include &lt;unistd.h&gt;        // close, read, write
</code></pre>
<hr />
<h2 id="結語"><a class="header" href="#結語">結語</a></h2>
<p>這份文件涵蓋了 Linux 網路程式設計的核心 API，包括：</p>
<ul>
<li>✅ Socket 基礎函數（socket, bind, listen, accept, connect）</li>
<li>✅ TCP/UDP 專用函數</li>
<li>✅ I/O 多工機制（select, poll, epoll）</li>
<li>✅ Socket 選項設定（setsockopt）</li>
<li>✅ 資料收發函數（send, recv, sendto, recvfrom）</li>
<li>✅ 位址轉換函數</li>
<li>✅ 完整的範例程式</li>
</ul>
<p>希望這份參考手冊對你的網路程式設計有所幫助！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../network/socket.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../compilers-and-interpreters/compilers-and-interpreters.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../network/socket.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../compilers-and-interpreters/compilers-and-interpreters.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
