<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust é–æ©Ÿåˆ¶å®Œæ•´æŒ‡å— - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-é–æ©Ÿåˆ¶å®Œæ•´æŒ‡å—-"><a class="header" href="#rust-é–æ©Ÿåˆ¶å®Œæ•´æŒ‡å—-">Rust é–æ©Ÿåˆ¶å®Œæ•´æŒ‡å— ğŸ¦€</a></h1>
<h2 id="-ç›®éŒ„çµæ§‹"><a class="header" href="#-ç›®éŒ„çµæ§‹">ğŸ“‘ ç›®éŒ„çµæ§‹</a></h2>
<p>é€™ä»½æŒ‡å—åˆ†ç‚ºä»¥ä¸‹éƒ¨åˆ†ï¼š</p>
<h3 id="ç¬¬ä¸€éƒ¨åˆ†æ¦‚è¦½èˆ‡åŸºç¤"><a class="header" href="#ç¬¬ä¸€éƒ¨åˆ†æ¦‚è¦½èˆ‡åŸºç¤">ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¦‚è¦½èˆ‡åŸºç¤</a></h3>
<ul>
<li><a href="#%E8%A6%96%E8%A6%BA%E5%8C%96%E6%A6%82%E8%A6%BD">è¦–è¦ºåŒ–æ¦‚è¦½</a></li>
<li><a href="#arc-mutex-%E5%9F%BA%E6%9C%AC%E4%BA%92%E6%96%A5%E9%8E%96">Arc&lt;Mutex<T>&gt;</a></li>
<li><a href="#arc-rwlock-%E8%AE%80%E5%AF%AB%E9%8E%96">Arc&lt;RwLock<T>&gt;</a></li>
</ul>
<h3 id="ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª"><a class="header" href="#ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª">ç¬¬äºŒéƒ¨åˆ†ï¼šé«˜æ•ˆèƒ½åŸèª</a></h3>
<ul>
<li><a href="#atomic-%E9%A1%9E%E5%9E%8B">Atomic é¡å‹</a></li>
<li><a href="#channel-%E9%80%9A%E9%81%93">Channel é€šé“</a></li>
</ul>
<h3 id="ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥"><a class="header" href="#ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥">ç¬¬ä¸‰éƒ¨åˆ†ï¼šé«˜ç´šåŒæ­¥</a></h3>
<ul>
<li><a href="#condvar-%E6%A2%9D%E4%BB%B6%E8%AE%8A%E6%95%B8">Condvar æ¢ä»¶è®Šæ•¸</a></li>
<li><a href="#rc-refcell-%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E5%85%B1%E4%BA%AB">Rc&lt;RefCell<T>&gt;</a></li>
</ul>
<h3 id="ç¬¬å››éƒ¨åˆ†å¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸"><a class="header" href="#ç¬¬å››éƒ¨åˆ†å¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸">ç¬¬å››éƒ¨åˆ†ï¼šå¯¦æˆ°èˆ‡æœ€ä½³å¯¦è¸</a></h3>
<ul>
<li><a href="#%E9%AB%98%E7%B4%9A%E4%B8%A6%E8%A1%8C%E6%A8%A1%E5%BC%8F">é«˜ç´šä¸¦è¡Œæ¨¡å¼</a></li>
<li><a href="#%E9%81%B8%E6%93%87%E6%8C%87%E5%8D%97%E8%88%87%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90">é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸</a></li>
</ul>
<hr />
<h2 id="-è¦–è¦ºåŒ–æ¦‚è¦½"><a class="header" href="#-è¦–è¦ºåŒ–æ¦‚è¦½">ğŸ“Š è¦–è¦ºåŒ–æ¦‚è¦½</a></h2>
<pre><code>Rust é–çš„é¸æ“‡æµç¨‹åœ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   éœ€è¦å…±äº«å—ï¼Ÿ   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ æ˜¯
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç°¡å–®åŸå­æ“ä½œï¼Ÿ â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Atomic     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ”¢ åŸå­é¡å‹      â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å–®ä¸€åŸ·è¡Œç·’ï¼Ÿ   â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Rc&lt;RefCell&gt;â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ  å–®åŸ·è¡Œç·’å…±äº«  â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¤šè®€å°‘å¯«ï¼Ÿ     â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ RwLock     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸ“– è®€å¯«é–        â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   éœ€è¦ç­‰å¾…ï¼Ÿ     â”‚â”€â”€â”€â–¶â”‚  ä½¿ç”¨ Condvar    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ æ˜¯ â”‚  ğŸšŒ æ¢ä»¶è®Šæ•¸      â”‚
      â”‚ å¦           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä½¿ç”¨ Mutex     â”‚
â”‚  ğŸ”’ äº’æ–¥é–       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ"><a class="header" href="#æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ">æ•ˆèƒ½èˆ‡ä½¿ç”¨å ´æ™¯å¿«é€Ÿåƒè€ƒ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>é¡å‹</th><th>æ•ˆèƒ½</th><th>ä½¿ç”¨å ´æ™¯</th><th>ç‰¹é»</th></tr></thead><tbody>
<tr><td><code>Atomic</code></td><td>ğŸ¥‡ æœ€å¿«</td><td>ç°¡å–®è¨ˆæ•¸/æ¨™èªŒ</td><td>ç„¡é–ï¼Œç·¨è­¯æ™‚ä¿è­‰</td></tr>
<tr><td><code>Arc&lt;RwLock&gt;</code> (è®€)</td><td>ğŸ¥ˆ å¾ˆå¿«</td><td>å¤šè®€å°‘å¯«</td><td>ä¸¦è¡Œè®€å–</td></tr>
<tr><td><code>Channel</code></td><td>ğŸ¥‰ å¿«</td><td>åŸ·è¡Œç·’é€šè¨Š</td><td>é›¶æ‹·è²å‚³é</td></tr>
<tr><td><code>Arc&lt;Mutex&gt;</code></td><td>ğŸ… ä¸­ç­‰</td><td>åŸºæœ¬äº’æ–¥</td><td>ç°¡å–®å¯é </td></tr>
<tr><td><code>Condvar</code></td><td>ğŸ… ä¸­ç­‰</td><td>æ¢ä»¶ç­‰å¾…</td><td>äº‹ä»¶é©…å‹•</td></tr>
<tr><td><code>Rc&lt;RefCell&gt;</code></td><td>ğŸ… ä¸­ç­‰</td><td>å–®åŸ·è¡Œç·’å…±äº«</td><td>é‹è¡Œæ™‚æª¢æŸ¥</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="arcmutex-åŸºæœ¬äº’æ–¥é–-"><a class="header" href="#arcmutex-åŸºæœ¬äº’æ–¥é–-">Arc&lt;Mutex<T>&gt; åŸºæœ¬äº’æ–¥é– ğŸ”’</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒæœ‰å¤šæŠŠé‘°åŒ™çš„ä¿éšªç®±ï¼Œæ¯å€‹åŸ·è¡Œç·’éƒ½æœ‰é‘°åŒ™(Arc)ï¼Œä½†ä¸€æ¬¡åªèƒ½ä¸€å€‹äººé–‹ç®±å­(Mutex)</p>
<pre><code>Arc&lt;Mutex&lt;T&gt;&gt; å·¥ä½œç¤ºæ„åœ–ï¼š
Thread A: ğŸ”‘ â”€â”€â”
Thread B: ğŸ”‘ â”€â”€â”¼â”€â”€â–¶ ğŸ“¦ Mutex&lt;T&gt;
Thread C: ğŸ”‘ â”€â”€â”˜
</code></pre>
<h3 id="åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹"><a class="header" href="#åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹">åŸºæœ¬ä½¿ç”¨ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for i in 0..5 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
            println!("åŸ·è¡Œç·’ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€çµ‚è¨ˆæ•¸: {}", *counter.lock().unwrap());
}</code></pre></pre>
<h3 id="å…±äº«è³‡æ–™çµæ§‹ç¯„ä¾‹"><a class="header" href="#å…±äº«è³‡æ–™çµæ§‹ç¯„ä¾‹">å…±äº«è³‡æ–™çµæ§‹ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

#[derive(Debug)]
struct SharedData {
    value: i32,
    items: Vec&lt;String&gt;,
}

impl SharedData {
    fn new() -&gt; Self {
        SharedData {
            value: 0,
            items: Vec::new(),
        }
    }
    
    fn add_item(&amp;mut self, item: String) {
        self.value += 1;
        self.items.push(item);
    }
}

fn main() {
    let data = Arc::new(Mutex::new(SharedData::new()));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            for j in 0..3 {
                let item = format!("åŸ·è¡Œç·’{}-é …ç›®{}", i, j);
                {
                    let mut shared = data.lock().unwrap();
                    shared.add_item(item.clone());
                    println!("æ–°å¢: {}", item);
                }
                thread::sleep(Duration::from_millis(100));
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€çµ‚è³‡æ–™: {:?}", *data.lock().unwrap());
}</code></pre></pre>
<h3 id="éŒ¯èª¤è™•ç†èˆ‡æ¯’åŒ–æ©Ÿåˆ¶"><a class="header" href="#éŒ¯èª¤è™•ç†èˆ‡æ¯’åŒ–æ©Ÿåˆ¶">éŒ¯èª¤è™•ç†èˆ‡æ¯’åŒ–æ©Ÿåˆ¶</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    poison_handling_example();
    safe_wrapper_example();
}

fn poison_handling_example() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let data_clone = Arc::clone(&amp;data);
    
    // å»ºç«‹æœƒ panic çš„åŸ·è¡Œç·’
    let handle = thread::spawn(move || {
        let mut vec = data_clone.lock().unwrap();
        vec.push(4);
        panic!("æ•…æ„çš„ panic!");
    });
    
    let _ = handle.join();
    
    // è™•ç†æ¯’åŒ–çš„ Mutex
    match data.lock() {
        Ok(vec) =&gt; println!("æˆåŠŸç²å–: {:?}", *vec),
        Err(poisoned) =&gt; {
            println!("Mutex è¢«æ¯’åŒ–äº†ï¼");
            let vec = poisoned.into_inner();
            println!("å¼·åˆ¶ç²å–çš„è³‡æ–™: {:?}", *vec);
        }
    };
}

// å®‰å…¨çš„ Mutex å­˜å–åŒ…è£å™¨
fn safe_mutex_access&lt;T, F, R&gt;(mutex: &amp;Mutex&lt;T&gt;, f: F) -&gt; Result&lt;R, String&gt;
where
    F: FnOnce(&amp;mut T) -&gt; R,
{
    match mutex.lock() {
        Ok(mut guard) =&gt; Ok(f(&amp;mut guard)),
        Err(poisoned) =&gt; {
            eprintln!("è­¦å‘Š: Mutex è¢«æ¯’åŒ–ï¼Œå˜—è©¦æ¢å¾©...");
            let mut guard = poisoned.into_inner();
            Ok(f(&amp;mut guard))
        }
    }
}

fn safe_wrapper_example() {
    let data = Arc::new(Mutex::new(42));
    
    match safe_mutex_access(&amp;data, |value| {
        *value += 1;
        *value
    }) {
        Ok(result) =&gt; println!("æ“ä½œæˆåŠŸï¼Œæ–°å€¼: {}", result),
        Err(e) =&gt; println!("æ“ä½œå¤±æ•—: {}", e),
    }
}</code></pre></pre>
<hr />
<h2 id="arcrwlock-è®€å¯«é–-"><a class="header" href="#arcrwlock-è®€å¯«é–-">Arc&lt;RwLock<T>&gt; è®€å¯«é– ğŸ“–</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒåœ–æ›¸é¤¨è¦å‰‡ï¼Œå¤šäººå¯ä»¥åŒæ™‚çœ‹æ›¸(è®€)ï¼Œä½†å¯«å­—æ™‚è¦æ¸…å ´</p>
<pre><code>RwLock ç‹€æ…‹åœ–ï¼š
è®€å–æ¨¡å¼: ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ â†’ [Data] â† âœï¸ğŸ’¤ (å¯«è€…ç­‰å¾…)
å¯«å…¥æ¨¡å¼: âœï¸ â†’ [Data] â† ğŸ‘€ğŸ’¤ğŸ‘€ğŸ’¤ (è®€è€…ç­‰å¾…)
</code></pre>
<h3 id="è¨­å®šæª”å¿«å–ç¯„ä¾‹"><a class="header" href="#è¨­å®šæª”å¿«å–ç¯„ä¾‹">è¨­å®šæª”å¿«å–ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Config {
    settings: HashMap&lt;String, String&gt;,
    version: u32,
}

impl Config {
    fn new() -&gt; Self {
        let mut settings = HashMap::new();
        settings.insert("theme".to_string(), "dark".to_string());
        settings.insert("language".to_string(), "zh-TW".to_string());
        
        Config { settings, version: 1 }
    }
    
    fn get_setting(&amp;self, key: &amp;str) -&gt; Option&lt;String&gt; {
        self.settings.get(key).cloned()
    }
    
    fn update_setting(&amp;mut self, key: String, value: String) {
        self.settings.insert(key, value);
        self.version += 1;
    }
}

fn main() {
    config_cache_example();
}

fn config_cache_example() {
    let config = Arc::new(RwLock::new(Config::new()));
    let mut handles = vec![];
    
    // å¤šå€‹è®€è€…åŸ·è¡Œç·’
    for i in 0..5 {
        let config = Arc::clone(&amp;config);
        let handle = thread::spawn(move || {
            for j in 0..3 {
                let reader = config.read().unwrap();
                let theme = reader.get_setting("theme").unwrap_or_default();
                println!("è®€è€… {} ç¬¬ {} æ¬¡: theme={}", i, j, theme);
                drop(reader);
                thread::sleep(Duration::from_millis(100));
            }
        });
        handles.push(handle);
    }
    
    // å¯«è€…åŸ·è¡Œç·’
    for i in 0..2 {
        let config = Arc::clone(&amp;config);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(200));
            let mut writer = config.write().unwrap();
            let new_theme = if i == 0 { "light" } else { "auto" };
            writer.update_setting("theme".to_string(), new_theme.to_string());
            println!("å¯«è€… {} æ›´æ–°ä¸»é¡Œç‚º: {}", i, new_theme);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre></pre>
<h3 id="æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹"><a class="header" href="#æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹">æ•ˆèƒ½æ¯”è¼ƒç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, RwLock, Mutex};
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    performance_comparison();
}

fn performance_comparison() {
    let iterations = 10000;
    let thread_count = 4;
    
    // Mutex æ¸¬è©¦
    let mutex_data = Arc::new(Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..thread_count {
        let data = Arc::clone(&amp;mutex_data);
        let handle = thread::spawn(move || {
            for _ in 0..iterations {
                let _guard = data.lock().unwrap();
                // æ¨¡æ“¬è®€å–æ“ä½œ
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    let mutex_time = start.elapsed();
    
    // RwLock æ¸¬è©¦
    let rwlock_data = Arc::new(RwLock::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..thread_count {
        let data = Arc::clone(&amp;rwlock_data);
        let handle = thread::spawn(move || {
            for _ in 0..iterations {
                let _guard = data.read().unwrap();
                // æ¨¡æ“¬è®€å–æ“ä½œ
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    let rwlock_time = start.elapsed();
    
    println!("Mutex æ™‚é–“: {:?}", mutex_time);
    println!("RwLock æ™‚é–“: {:?}", rwlock_time);
    println!("RwLock æ¯” Mutex å¿« {:.2}x", 
        mutex_time.as_nanos() as f64 / rwlock_time.as_nanos() as f64);
}</code></pre></pre>
<h1 id="rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª-"><a class="header" href="#rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬äºŒéƒ¨åˆ†é«˜æ•ˆèƒ½åŸèª-">Rust é–æ©Ÿåˆ¶æŒ‡å— - ç¬¬äºŒéƒ¨åˆ†ï¼šé«˜æ•ˆèƒ½åŸèª âš¡</a></h1>
<h2 id="atomic-é¡å‹-"><a class="header" href="#atomic-é¡å‹-">Atomic é¡å‹ âš›ï¸</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒåŸå­å½ˆä¸€æ¨£ï¼Œæ“ä½œä¸å¯åˆ†å‰²ï¼Œè¦å˜›å…¨åšå®Œï¼Œè¦å˜›ä¸åš</p>
<pre><code>Atomic vs Mutex æ€§èƒ½å°æ¯”ï¼š
éåŸå­æ“ä½œå•é¡Œ âŒ:
Thread1: è®€å–(5) â†’ +1 â†’ å¯«å…¥(6)
Thread2:   è®€å–(5) â†’ +1 â†’ å¯«å…¥(6) â† ä¸Ÿå¤±æ›´æ–°!

åŸå­æ“ä½œ âœ…:
Thread1: fetch_add(1) â†’ 6
Thread2: fetch_add(1) â†’ 7 â† æ­£ç¢º!
</code></pre>
<h3 id="åŸºæœ¬åŸå­æ“ä½œç¯„ä¾‹"><a class="header" href="#åŸºæœ¬åŸå­æ“ä½œç¯„ä¾‹">åŸºæœ¬åŸå­æ“ä½œç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicI32, AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    basic_atomic_example();
}

fn basic_atomic_example() {
    let counter = Arc::new(AtomicI32::new(0));
    let mut handles = vec![];
    
    for i in 0..5 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
            println!("åŸ·è¡Œç·’ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€çµ‚è¨ˆæ•¸: {}", counter.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="åŸå­å¸ƒæ—å€¼æ§åˆ¶åŸ·è¡Œç·’"><a class="header" href="#åŸå­å¸ƒæ—å€¼æ§åˆ¶åŸ·è¡Œç·’">åŸå­å¸ƒæ—å€¼æ§åˆ¶åŸ·è¡Œç·’</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    atomic_flag_example();
}

fn atomic_flag_example() {
    let running = Arc::new(AtomicBool::new(true));
    let counter = Arc::new(AtomicUsize::new(0));
    
    // å·¥ä½œåŸ·è¡Œç·’
    let running_clone = Arc::clone(&amp;running);
    let counter_clone = Arc::clone(&amp;counter);
    let worker = thread::spawn(move || {
        while running_clone.load(Ordering::SeqCst) {
            counter_clone.fetch_add(1, Ordering::SeqCst);
            thread::sleep(Duration::from_millis(10));
        }
        println!("å·¥ä½œåŸ·è¡Œç·’çµæŸ");
    });
    
    // ä¸»åŸ·è¡Œç·’ç­‰å¾…3ç§’å¾Œåœæ­¢
    thread::sleep(Duration::from_secs(3));
    running.store(false, Ordering::SeqCst);
    
    worker.join().unwrap();
    println!("ç¸½è¨ˆæ•¸: {}", counter.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="compare-and-swap-cas-é€²éšæ“ä½œ"><a class="header" href="#compare-and-swap-cas-é€²éšæ“ä½œ">Compare-And-Swap (CAS) é€²éšæ“ä½œ</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    cas_example();
}

fn cas_example() {
    let value = Arc::new(AtomicI32::new(10));
    let mut handles = vec![];
    
    for i in 0..3 {
        let value = Arc::clone(&amp;value);
        let handle = thread::spawn(move || {
            loop {
                let current = value.load(Ordering::SeqCst);
                let new_value = current * 2;
                
                match value.compare_exchange_weak(
                    current, 
                    new_value, 
                    Ordering::SeqCst, 
                    Ordering::SeqCst
                ) {
                    Ok(_) =&gt; {
                        println!("åŸ·è¡Œç·’ {} æˆåŠŸå°‡ {} æ›´æ–°ç‚º {}", i, current, new_value);
                        break;
                    }
                    Err(actual) =&gt; {
                        println!("åŸ·è¡Œç·’ {} CAS å¤±æ•—ï¼ŒæœŸæœ› {} ä½†å¯¦éš›æ˜¯ {}", i, current, actual);
                    }
                }
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€çµ‚å€¼: {}", value.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="è¨˜æ†¶é«”é †åº-memory-ordering"><a class="header" href="#è¨˜æ†¶é«”é †åº-memory-ordering">è¨˜æ†¶é«”é †åº (Memory Ordering)</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicI32, AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    memory_ordering_example();
}

fn memory_ordering_example() {
    let data = Arc::new(AtomicI32::new(0));
    let flag = Arc::new(AtomicBool::new(false));
    
    // ç”Ÿç”¢è€…åŸ·è¡Œç·’
    let data_producer = Arc::clone(&amp;data);
    let flag_producer = Arc::clone(&amp;flag);
    let producer = thread::spawn(move || {
        // 1. å¯«å…¥è³‡æ–™
        data_producer.store(42, Ordering::Relaxed);
        
        // 2. è¨­å®šæ——æ¨™ (Releaseèªç¾©)
        flag_producer.store(true, Ordering::Release);
        
        println!("ç”Ÿç”¢è€…ï¼šè³‡æ–™å¯«å…¥å®Œæˆ");
    });
    
    // æ¶ˆè²»è€…åŸ·è¡Œç·’
    let data_consumer = Arc::clone(&amp;data);
    let flag_consumer = Arc::clone(&amp;flag);
    let consumer = thread::spawn(move || {
        // ç­‰å¾…æ——æ¨™ (Acquireèªç¾©)
        while !flag_consumer.load(Ordering::Acquire) {
            thread::sleep(Duration::from_millis(1));
        }
        
        let value = data_consumer.load(Ordering::Relaxed);
        println!("æ¶ˆè²»è€…ï¼šè®€å–åˆ°è³‡æ–™ {}", value);
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<h3 id="è¨˜æ†¶é«”é †åºæ•ˆèƒ½æ¯”è¼ƒ"><a class="header" href="#è¨˜æ†¶é«”é †åºæ•ˆèƒ½æ¯”è¼ƒ">è¨˜æ†¶é«”é †åºæ•ˆèƒ½æ¯”è¼ƒ</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Instant;

fn main() {
    ordering_performance_test();
}

fn ordering_performance_test() {
    let counter = Arc::new(AtomicI32::new(0));
    let iterations = 1_000_000;
    
    // æ¸¬è©¦ SeqCst (æœ€å¼·é †åº)
    let start = Instant::now();
    let counter_seqcst = Arc::clone(&amp;counter);
    let handle = thread::spawn(move || {
        for _ in 0..iterations {
            counter_seqcst.fetch_add(1, Ordering::SeqCst);
        }
    });
    handle.join().unwrap();
    let seqcst_time = start.elapsed();
    
    counter.store(0, Ordering::SeqCst);
    
    // æ¸¬è©¦ Relaxed (æœ€å¼±é †åº)
    let start = Instant::now();
    let counter_relaxed = Arc::clone(&amp;counter);
    let handle = thread::spawn(move || {
        for _ in 0..iterations {
            counter_relaxed.fetch_add(1, Ordering::Relaxed);
        }
    });
    handle.join().unwrap();
    let relaxed_time = start.elapsed();
    
    println!("SeqCst æ™‚é–“: {:?}", seqcst_time);
    println!("Relaxed æ™‚é–“: {:?}", relaxed_time);
    println!("Relaxed æ¯” SeqCst å¿« {:.2}x", 
        seqcst_time.as_nanos() as f64 / relaxed_time.as_nanos() as f64);
}</code></pre></pre>
<hr />
<h2 id="channel-é€šé“-"><a class="header" href="#channel-é€šé“-">Channel é€šé“ ğŸ“¡</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒéƒµç­’ï¼Œä¸€é‚ŠæŠ•ä¿¡ä¸€é‚Šæ”¶ä¿¡ï¼Œæ˜¯ Rust çš„ç‰¹è‰²ä¸¦è¡Œé€šè¨Šæ–¹å¼</p>
<pre><code>Channel é€šè¨Šç¤ºæ„åœ–ï¼š
Producer1: ğŸ“¤ â”€â”€â”
Producer2: ğŸ“¤ â”€â”€â”¼â”€â”€â–¶ ğŸ“¬ Channel â”€â”€â–¶ ğŸ“¥ Consumer
Producer3: ğŸ“¤ â”€â”€â”˜

åŒæ­¥ vs ç•°æ­¥:
Sync:   ç™¼é€è€…ç­‰å¾…æ¥æ”¶è€…æº–å‚™å¥½
Async:  ç™¼é€è€…ç«‹å³è¿”å›ï¼Œè¨Šæ¯é€²å…¥ä½‡åˆ—
</code></pre>
<h3 id="æ¨™æº–åº«-channel-åŸºæœ¬ç¯„ä¾‹"><a class="header" href="#æ¨™æº–åº«-channel-åŸºæœ¬ç¯„ä¾‹">æ¨™æº–åº« Channel åŸºæœ¬ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    basic_channel_example();
}

fn basic_channel_example() {
    let (tx, rx) = mpsc::channel();
    
    // ç™¼é€è€…åŸ·è¡Œç·’
    let tx_clone = tx.clone();
    thread::spawn(move || {
        for i in 0..5 {
            let message = format!("è¨Šæ¯ {}", i);
            tx_clone.send(message).unwrap();
            println!("ç™¼é€: è¨Šæ¯ {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // å¦ä¸€å€‹ç™¼é€è€…
    thread::spawn(move || {
        for i in 5..10 {
            let message = format!("è¨Šæ¯ {}", i);
            tx.send(message).unwrap();
            println!("ç™¼é€: è¨Šæ¯ {}", i);
            thread::sleep(Duration::from_millis(150));
        }
    });
    
    // æ¥æ”¶è€…
    for _ in 0..10 {
        let received = rx.recv().unwrap();
        println!("æ¥æ”¶: {}", received);
    }
}</code></pre></pre>
<h3 id="åŒæ­¥é€šé“ç¯„ä¾‹"><a class="header" href="#åŒæ­¥é€šé“ç¯„ä¾‹">åŒæ­¥é€šé“ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    sync_channel_example();
}

fn sync_channel_example() {
    // å»ºç«‹åŒæ­¥é€šé“ï¼Œç·©è¡å€å¤§å°ç‚º2
    let (tx, rx) = mpsc::sync_channel(2);
    
    let sender = thread::spawn(move || {
        for i in 0..5 {
            println!("æº–å‚™ç™¼é€ {}", i);
            match tx.send(i) {
                Ok(_) =&gt; println!("æˆåŠŸç™¼é€ {}", i),
                Err(e) =&gt; println!("ç™¼é€å¤±æ•—: {}", e),
            }
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // æ¥æ”¶è€…æ•…æ„å»¶é²
    thread::sleep(Duration::from_millis(500));
    
    for received in rx {
        println!("æ¥æ”¶: {}", received);
        thread::sleep(Duration::from_millis(200));
    }
    
    sender.join().unwrap();
}</code></pre></pre>
<h3 id="å·¥ä½œåˆ†ç™¼ç³»çµ±ç¯„ä¾‹"><a class="header" href="#å·¥ä½œåˆ†ç™¼ç³»çµ±ç¯„ä¾‹">å·¥ä½œåˆ†ç™¼ç³»çµ±ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex, mpsc};
use std::thread;
use std::time::Duration;

fn main() {
    work_distribution_example();
}

fn work_distribution_example() {
    let (job_tx, job_rx) = mpsc::channel();
    let (result_tx, result_rx) = mpsc::channel();
    
    // å°‡æ¥æ”¶ç«¯åŒ…è£åœ¨ Arc&lt;Mutex&lt;&gt;&gt; ä¸­ä»¥ä¾¿åœ¨å¤šå€‹åŸ·è¡Œç·’é–“å…±äº«
    let job_rx = Arc::new(Mutex::new(job_rx));
    
    // å·¥ä½œè€…åŸ·è¡Œç·’æ± 
    let mut workers = vec![];
    for worker_id in 0..3 {
        let job_rx = Arc::clone(&amp;job_rx);
        let result_tx = result_tx.clone();
        
        let worker = thread::spawn(move || {
            loop {
                let job_result = {
                    let receiver = job_rx.lock().unwrap();
                    receiver.recv()
                };
                
                match job_result {
                    Ok(job) =&gt; {
                        println!("å·¥ä½œè€… {} è™•ç†ä»»å‹™: {}", worker_id, job);
                        thread::sleep(Duration::from_millis(500));
                        let result = format!("ä»»å‹™ {} çš„çµæœ", job);
                        result_tx.send((worker_id, result)).unwrap();
                    }
                    Err(_) =&gt; {
                        println!("å·¥ä½œè€… {} çµæŸ", worker_id);
                        break;
                    }
                }
            }
        });
        workers.push(worker);
    }
    
    // ä»»å‹™åˆ†ç™¼è€…
    let job_distributor = thread::spawn(move || {
        for i in 0..10 {
            job_tx.send(i).unwrap();
        }
        drop(job_tx); // é—œé–‰é€šé“
    });
    
    // çµæœæ”¶é›†è€…
    let result_collector = thread::spawn(move || {
        let mut results = vec![];
        for (worker_id, result) in result_rx {
            println!("æ”¶åˆ°ä¾†è‡ªå·¥ä½œè€… {} çš„çµæœ: {}", worker_id, result);
            results.push(result);
            if results.len() == 10 {
                break;
            }
        }
        results
    });
    
    job_distributor.join().unwrap();
    let results = result_collector.join().unwrap();
    
    for worker in workers {
        worker.join().unwrap();
    }
    
    println!("æ‰€æœ‰çµæœ: {:?}", results);
}</code></pre></pre>
<h3 id="è·¨å¹³è‡ºé«˜æ•ˆèƒ½-channel-crossbeam"><a class="header" href="#è·¨å¹³è‡ºé«˜æ•ˆèƒ½-channel-crossbeam">è·¨å¹³è‡ºé«˜æ•ˆèƒ½ Channel (crossbeam)</a></h3>
<pre><pre class="playground"><code class="language-rust">// æ³¨æ„ï¼šæ­¤ç¯„ä¾‹éœ€è¦åœ¨ Cargo.toml ä¸­æ·»åŠ ï¼šcrossbeam = "0.8"
// å¦‚æœæ²’æœ‰ crossbeamï¼Œå¯ä»¥ä½¿ç”¨æ¨™æº–åº«çš„ mpsc æ›¿ä»£

use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    crossbeam_channel_example();
}

fn crossbeam_channel_example() {
    // ä½¿ç”¨æ¨™æº–åº«çš„ channelï¼Œå› ç‚º crossbeam å¯èƒ½ä¸å¯ç”¨
    let (tx, rx) = mpsc::channel();
    let (bounded_tx, bounded_rx) = mpsc::sync_channel(10);
    
    // å¤šå€‹ç”Ÿç”¢è€…
    let mut producers = vec![];
    for i in 0..3 {
        let tx = tx.clone();
        let producer = thread::spawn(move || {
            for j in 0..5 {
                let message = format!("ç”Ÿç”¢è€… {} çš„è¨Šæ¯ {}", i, j);
                tx.send(message).unwrap();
                thread::sleep(Duration::from_millis(50));
            }
        });
        producers.push(producer);
    }
    
    // ä½¿ç”¨ç°¡å–®çš„æ¥æ”¶å™¨è™•ç†å¤šå€‹é€šé“
    let selector = thread::spawn(move || {
        let mut count = 0;
        loop {
            match rx.try_recv() {
                Ok(message) =&gt; {
                    println!("å¾ç„¡ç•Œé€šé“æ”¶åˆ°: {}", message);
                    count += 1;
                }
                Err(_) =&gt; {
                    // æ²’æœ‰è¨Šæ¯ï¼Œæª¢æŸ¥æ˜¯å¦å®Œæˆ
                    if count &gt;= 15 { // 3 å€‹ç”Ÿç”¢è€… * 5 æ¢è¨Šæ¯
                        break;
                    }
                    thread::sleep(Duration::from_millis(10));
                }
            }
            
            // æª¢æŸ¥æœ‰ç•Œé€šé“
            match bounded_rx.try_recv() {
                Ok(message) =&gt; println!("å¾æœ‰ç•Œé€šé“æ”¶åˆ°: {}", message),
                Err(_) =&gt; {}
            }
        }
    });
    
    // å‘æœ‰ç•Œé€šé“ç™¼é€è¨Šæ¯
    thread::spawn(move || {
        for i in 0..3 {
            bounded_tx.send(format!("æœ‰ç•Œè¨Šæ¯ {}", i)).unwrap();
            thread::sleep(Duration::from_millis(200));
        }
    });
    
    for producer in producers {
        producer.join().unwrap();
    }
    
    drop(tx);
    selector.join().unwrap();
}

// å¦‚æœæƒ³ä½¿ç”¨ crossbeamï¼Œå¯ä»¥è§£é™¤è¨»é‡‹ä»¥ä¸‹ç¨‹å¼ç¢¼ï¼š
/*
// éœ€è¦åœ¨ Cargo.toml æ·»åŠ ï¼šcrossbeam = "0.8"
use crossbeam::channel;

fn crossbeam_example() {
    let (tx, rx) = channel::unbounded();
    
    crossbeam::select! {
        recv(rx) -&gt; msg =&gt; {
            println!("æ”¶åˆ°: {:?}", msg);
        },
        default(Duration::from_millis(100)) =&gt; {
            println!("è¶…æ™‚");
        },
    }
}
*/</code></pre></pre>
<h3 id="channel-æ•ˆèƒ½æ¸¬è©¦"><a class="header" href="#channel-æ•ˆèƒ½æ¸¬è©¦">Channel æ•ˆèƒ½æ¸¬è©¦</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Instant;

fn main() {
    channel_performance_test();
}

fn channel_performance_test() {
    let message_count = 100_000; // é™ä½æ•¸é‡ä»¥é¿å…éé•·åŸ·è¡Œæ™‚é–“
    
    // æ¨™æº–åº« channel (ç•°æ­¥)
    let start = Instant::now();
    let (tx, rx) = mpsc::channel();
    
    let sender = thread::spawn(move || {
        for i in 0..message_count {
            tx.send(i).unwrap();
        }
    });
    
    let receiver = thread::spawn(move || {
        for _ in 0..message_count {
            rx.recv().unwrap();
        }
    });
    
    sender.join().unwrap();
    receiver.join().unwrap();
    let async_time = start.elapsed();
    
    // æ¨™æº–åº«åŒæ­¥ channel
    let start = Instant::now();
    let (tx, rx) = mpsc::sync_channel(1000); // æœ‰ç•Œé€šé“
    
    let sender = thread::spawn(move || {
        for i in 0..message_count {
            tx.send(i).unwrap();
        }
    });
    
    let receiver = thread::spawn(move || {
        for _ in 0..message_count {
            rx.recv().unwrap();
        }
    });
    
    sender.join().unwrap();
    receiver.join().unwrap();
    let sync_time = start.elapsed();
    
    println!("ç•°æ­¥ channel: {:?}", async_time);
    println!("åŒæ­¥ channel: {:?}", sync_time);
    println!("æ•ˆèƒ½æ¯”è¼ƒ: ç•°æ­¥æ¯”åŒæ­¥å¿« {:.2}x", 
        sync_time.as_nanos() as f64 / async_time.as_nanos() as f64);
    
    // æ¸¬è©¦ååé‡
    let throughput_async = message_count as f64 / async_time.as_secs_f64();
    let throughput_sync = message_count as f64 / sync_time.as_secs_f64();
    
    println!("ç•°æ­¥é€šé“ååé‡: {:.0} è¨Šæ¯/ç§’", throughput_async);
    println!("åŒæ­¥é€šé“ååé‡: {:.0} è¨Šæ¯/ç§’", throughput_sync);
}</code></pre></pre>
<h3 id="channel-é¸æ“‡æŒ‡å—"><a class="header" href="#channel-é¸æ“‡æŒ‡å—">Channel é¸æ“‡æŒ‡å—</a></h3>
<div class="table-wrapper"><table><thead><tr><th>å ´æ™¯</th><th>æ¨è–¦é¡å‹</th><th>åŸå› </th></tr></thead><tbody>
<tr><td>ğŸ”„ ä¸€å°ä¸€é€šè¨Š</td><td><code>mpsc::channel</code></td><td>ç°¡å–®å¯é </td></tr>
<tr><td>ğŸš€ é«˜æ•ˆèƒ½éœ€æ±‚</td><td><code>crossbeam::channel</code></td><td>æ›´å¿«çš„å¯¦ç¾</td></tr>
<tr><td>ğŸ“¦ å›ºå®šç·©è¡å€</td><td><code>sync_channel</code></td><td>èƒŒå£“æ§åˆ¶</td></tr>
<tr><td>ğŸ¯ é¸æ“‡æ€§æ¥æ”¶</td><td><code>crossbeam::select!</code></td><td>å¤šé€šé“è™•ç†</td></tr>
<tr><td>ğŸ”‚ å»£æ’­æ¨¡å¼</td><td><code>crossbeam::channel</code> + clone</td><td>ä¸€å°å¤šé€šè¨Š</td></tr>
</tbody></table>
</div>
<h1 id="rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥æ©Ÿåˆ¶-"><a class="header" href="#rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬ä¸‰éƒ¨åˆ†é«˜ç´šåŒæ­¥æ©Ÿåˆ¶-">Rust é–æ©Ÿåˆ¶æŒ‡å— - ç¬¬ä¸‰éƒ¨åˆ†ï¼šé«˜ç´šåŒæ­¥æ©Ÿåˆ¶ ğŸš€</a></h1>
<h2 id="condvar-æ¢ä»¶è®Šæ•¸-"><a class="header" href="#condvar-æ¢ä»¶è®Šæ•¸-">Condvar æ¢ä»¶è®Šæ•¸ ğŸšŒ</a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒç­‰å…¬è»Šçš„ç«™ç‰Œï¼Œåªæœ‰ç•¶å…¬è»Šä¾†äº†(æ¢ä»¶æ»¿è¶³)æ‰ä¸Šè»Š</p>
<pre><code>Condvar å·¥ä½œæµç¨‹ï¼š
ç”Ÿç”¢è€…: ğŸ­ â”€â”€â–¶ [ç·©è¡å€] â”€â”€â–¶ ğŸ“¢ notify()
æ¶ˆè²»è€…: ğŸ‘¤ğŸ’¤ â”€â”€â–¶ ğŸ””æ”¶åˆ°é€šçŸ¥ â”€â”€â–¶ ğŸ‘¤ğŸƒâ€â™‚ï¸ é–‹å§‹å·¥ä½œ
</code></pre>
<h3 id="ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹"><a class="header" href="#ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹">ç”Ÿç”¢è€…-æ¶ˆè²»è€…ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;
use std::collections::VecDeque;

fn main() {
    producer_consumer_example();
}

struct ProducerConsumer&lt;T&gt; {
    buffer: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    not_empty: Condvar,
    not_full: Condvar,
    capacity: usize,
}

impl&lt;T&gt; ProducerConsumer&lt;T&gt; {
    fn new(capacity: usize) -&gt; Self {
        ProducerConsumer {
            buffer: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
            not_full: Condvar::new(),
            capacity,
        }
    }
    
    fn produce(&amp;self, item: T) {
        let mut buffer = self.buffer.lock().unwrap();
        
        // ç­‰å¾…ç·©è¡å€æœ‰ç©ºé–“
        while buffer.len() &gt;= self.capacity {
            println!("ç·©è¡å€æ»¿äº†ï¼Œç”Ÿç”¢è€…ç­‰å¾…...");
            buffer = self.not_full.wait(buffer).unwrap();
        }
        
        buffer.push_back(item);
        println!("ç”Ÿç”¢äº†ä¸€å€‹é …ç›®ï¼Œç·©è¡å€å¤§å°: {}", buffer.len());
        
        // é€šçŸ¥æ¶ˆè²»è€…
        self.not_empty.notify_one();
    }
    
    fn consume(&amp;self) -&gt; T {
        let mut buffer = self.buffer.lock().unwrap();
        
        // ç­‰å¾…ç·©è¡å€æœ‰è³‡æ–™
        while buffer.is_empty() {
            println!("ç·©è¡å€ç©ºäº†ï¼Œæ¶ˆè²»è€…ç­‰å¾…...");
            buffer = self.not_empty.wait(buffer).unwrap();
        }
        
        let item = buffer.pop_front().unwrap();
        println!("æ¶ˆè²»äº†ä¸€å€‹é …ç›®ï¼Œç·©è¡å€å¤§å°: {}", buffer.len());
        
        // é€šçŸ¥ç”Ÿç”¢è€…
        self.not_full.notify_one();
        
        item
    }
}

fn producer_consumer_example() {
    let pc = Arc::new(ProducerConsumer::new(3)); // ç·©è¡å€å¤§å°ç‚º3
    
    // ç”Ÿç”¢è€…åŸ·è¡Œç·’
    let pc_producer = Arc::clone(&amp;pc);
    let producer = thread::spawn(move || {
        for i in 0..10 {
            let item = format!("é …ç›®-{}", i);
            pc_producer.produce(item);
            thread::sleep(Duration::from_millis(100));
        }
        println!("ç”Ÿç”¢è€…å®Œæˆ");
    });
    
    // æ¶ˆè²»è€…åŸ·è¡Œç·’
    let pc_consumer = Arc::clone(&amp;pc);
    let consumer = thread::spawn(move || {
        for _ in 0..10 {
            let item = pc_consumer.consume();
            println!("æ”¶åˆ°: {}", item);
            thread::sleep(Duration::from_millis(200)); // æ¶ˆè²»æ¯”ç”Ÿç”¢æ…¢
        }
        println!("æ¶ˆè²»è€…å®Œæˆ");
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<h3 id="ä»»å‹™å”èª¿ç¯„ä¾‹"><a class="header" href="#ä»»å‹™å”èª¿ç¯„ä¾‹">ä»»å‹™å”èª¿ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    task_coordination_example();
}

struct TaskCoordinator {
    workers_ready: Mutex&lt;usize&gt;,
    all_ready: Condvar,
    target_count: usize,
}

impl TaskCoordinator {
    fn new(target_count: usize) -&gt; Self {
        TaskCoordinator {
            workers_ready: Mutex::new(0),
            all_ready: Condvar::new(),
            target_count,
        }
    }
    
    fn worker_ready(&amp;self, worker_id: usize) {
        let mut count = self.workers_ready.lock().unwrap();
        *count += 1;
        
        println!("å·¥ä½œè€… {} æº–å‚™å°±ç·’ ({}/{})", worker_id, *count, self.target_count);
        
        if *count &gt;= self.target_count {
            println!("æ‰€æœ‰å·¥ä½œè€…æº–å‚™å°±ç·’ï¼Œé–‹å§‹ä»»å‹™ï¼");
            self.all_ready.notify_all();
        } else {
            // ç­‰å¾…å…¶ä»–å·¥ä½œè€…
            while *count &lt; self.target_count {
                println!("å·¥ä½œè€… {} ç­‰å¾…å…¶ä»–å·¥ä½œè€…...", worker_id);
                count = self.all_ready.wait(count).unwrap();
            }
        }
    }
}

fn task_coordination_example() {
    let coordinator = Arc::new(TaskCoordinator::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let coordinator = Arc::clone(&amp;coordinator);
        let handle = thread::spawn(move || {
            // æ¨¡æ“¬æº–å‚™æ™‚é–“
            thread::sleep(Duration::from_millis(((i + 1) * 500) as u64));
            
            // å ±å‘Šæº–å‚™å°±ç·’ä¸¦ç­‰å¾…é–‹å§‹ä¿¡è™Ÿ
            coordinator.worker_ready(i);
            
            // é–‹å§‹åŸ·è¡Œä»»å‹™
            println!("å·¥ä½œè€… {} é–‹å§‹åŸ·è¡Œä»»å‹™", i);
            thread::sleep(Duration::from_secs(2));
            println!("å·¥ä½œè€… {} å®Œæˆä»»å‹™", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre></pre>
<h3 id="è¶…æ™‚ç­‰å¾…ç¯„ä¾‹"><a class="header" href="#è¶…æ™‚ç­‰å¾…ç¯„ä¾‹">è¶…æ™‚ç­‰å¾…ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    timeout_example();
}

fn timeout_example() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&amp;pair);
    
    // ç­‰å¾…åŸ·è¡Œç·’
    let waiter = thread::spawn(move || {
        let (lock, cvar) = &amp;*pair_clone;
        let mut started = lock.lock().unwrap();
        
        // ç­‰å¾…æ¢ä»¶æ»¿è¶³ï¼Œæœ€å¤šç­‰å¾…2ç§’
        let result = cvar.wait_timeout_while(
            started,
            Duration::from_secs(2),
            |&amp;mut pending| !pending,
        ).unwrap();
        
        if result.1.timed_out() {
            println!("ç­‰å¾…è¶…æ™‚ï¼");
        } else {
            println!("æ¢ä»¶æ»¿è¶³ï¼");
        }
    });
    
    // ä¸»åŸ·è¡Œç·’ç­‰å¾…3ç§’å¾Œè¨­å®šæ¢ä»¶
    thread::sleep(Duration::from_secs(3));
    
    let (lock, cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    *started = true;
    cvar.notify_one();
    
    waiter.join().unwrap();
}</code></pre></pre>
<hr />
<h2 id="rcrefcell-å–®åŸ·è¡Œç·’å…±äº«-"><a class="header" href="#rcrefcell-å–®åŸ·è¡Œç·’å…±äº«-">Rc&lt;RefCell<T>&gt; å–®åŸ·è¡Œç·’å…±äº« ğŸ </a></h2>
<p><strong>ç™½è©±è§£é‡‹</strong>: åƒå®¶è£¡çš„å…±ç”¨å†°ç®±ï¼Œåªæœ‰ä¸€å€‹å®¶åº­(åŸ·è¡Œç·’)ä½¿ç”¨ï¼Œä½†å¯ä»¥æœ‰å¤šå€‹ä½¿ç”¨è€…</p>
<pre><code>Rc&lt;RefCell&lt;T&gt;&gt; è¨­è¨ˆåœ–ï¼š
Reference Counting (Rc):
Owner1: ğŸ“ â”€â”€â”
Owner2: ğŸ“ â”€â”€â”¼â”€â”€â–¶ ğŸ“¦ RefCell&lt;T&gt;
Owner3: ğŸ“ â”€â”€â”˜

Runtime Borrow Checking:
Immutable: ğŸ‘€ğŸ‘€ğŸ‘€ (å¤šå€‹ä¸å¯è®Šå€Ÿç”¨)
Mutable:   âœï¸     (ä¸€å€‹å¯è®Šå€Ÿç”¨)
Panic:     ğŸ‘€âœï¸   (åŒæ™‚å­˜åœ¨æœƒpanic!)
</code></pre>
<h3 id="æ¨¹ç‹€çµæ§‹ç¯„ä¾‹"><a class="header" href="#æ¨¹ç‹€çµæ§‹ç¯„ä¾‹">æ¨¹ç‹€çµæ§‹ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    tree_example();
}

#[derive(Debug)]
struct Node {
    value: i32,
    children: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
    parent: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(value: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            value,
            children: Vec::new(),
            parent: None,
        }))
    }
    
    fn add_child(parent: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, child: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;) {
        // å€Ÿç”¨çˆ¶ç¯€é»ä¸¦æ·»åŠ å­ç¯€é»
        parent.borrow_mut().children.push(Rc::clone(child));
        
        // è¨­å®šå­ç¯€é»çš„çˆ¶ç¯€é»å¼•ç”¨
        child.borrow_mut().parent = Some(Rc::clone(parent));
    }
    
    fn print_tree(node: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, depth: usize) {
        let indent = "  ".repeat(depth);
        let borrowed = node.borrow();
        println!("{}Node: {}", indent, borrowed.value);
        
        for child in &amp;borrowed.children {
            Node::print_tree(child, depth + 1);
        }
    }
    
    fn update_value(node: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, new_value: i32) {
        node.borrow_mut().value = new_value;
    }
}

fn tree_example() {
    // å»ºç«‹æ¨¹ç‹€çµæ§‹
    let root = Node::new(1);
    let child1 = Node::new(2);
    let child2 = Node::new(3);
    let grandchild = Node::new(4);
    
    // å»ºç«‹çˆ¶å­é—œä¿‚
    Node::add_child(&amp;root, &amp;child1);
    Node::add_child(&amp;root, &amp;child2);
    Node::add_child(&amp;child1, &amp;grandchild);
    
    println!("åŸå§‹æ¨¹ç‹€çµæ§‹:");
    Node::print_tree(&amp;root, 0);
    
    // ä¿®æ”¹ç¯€é»å€¼
    Node::update_value(&amp;grandchild, 42);
    
    println!("\nä¿®æ”¹å¾Œçš„æ¨¹ç‹€çµæ§‹:");
    Node::print_tree(&amp;root, 0);
}</code></pre></pre>
<h3 id="éŠæˆ²ç‹€æ…‹ç®¡ç†ç¯„ä¾‹"><a class="header" href="#éŠæˆ²ç‹€æ…‹ç®¡ç†ç¯„ä¾‹">éŠæˆ²ç‹€æ…‹ç®¡ç†ç¯„ä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    game_state_example();
}

#[derive(Debug)]
struct GameState {
    score: i32,
    level: i32,
    lives: i32,
}

impl GameState {
    fn new() -&gt; Self {
        GameState {
            score: 0,
            level: 1,
            lives: 3,
        }
    }
    
    fn add_score(&amp;mut self, points: i32) {
        self.score += points;
        if self.score &gt;= self.level * 1000 {
            self.level_up();
        }
    }
    
    fn level_up(&amp;mut self) {
        self.level += 1;
        self.lives += 1;
        println!("å‡ç´šï¼ç­‰ç´š: {}, ç”Ÿå‘½: {}", self.level, self.lives);
    }
    
    fn lose_life(&amp;mut self) {
        self.lives -= 1;
        println!("å¤±å»ç”Ÿå‘½ï¼å‰©é¤˜: {}", self.lives);
    }
}

struct Player {
    name: String,
    game_state: Rc&lt;RefCell&lt;GameState&gt;&gt;,
}

impl Player {
    fn new(name: String, game_state: Rc&lt;RefCell&lt;GameState&gt;&gt;) -&gt; Self {
        Player { name, game_state }
    }
    
    fn score_points(&amp;self, points: i32) {
        println!("{} ç²å¾— {} åˆ†", self.name, points);
        self.game_state.borrow_mut().add_score(points);
    }
    
    fn take_damage(&amp;self) {
        println!("{} å—åˆ°å‚·å®³", self.name);
        self.game_state.borrow_mut().lose_life();
    }
    
    fn show_status(&amp;self) {
        let state = self.game_state.borrow();
        println!("{} - åˆ†æ•¸: {}, ç­‰ç´š: {}, ç”Ÿå‘½: {}", 
            self.name, state.score, state.level, state.lives);
    }
}

fn game_state_example() {
    let game_state = Rc::new(RefCell::new(GameState::new()));
    
    // å¤šå€‹ç©å®¶å…±äº«éŠæˆ²ç‹€æ…‹
    let player1 = Player::new("ç©å®¶1".to_string(), Rc::clone(&amp;game_state));
    let player2 = Player::new("ç©å®¶2".to_string(), Rc::clone(&amp;game_state));
    
    // éŠæˆ²éç¨‹
    player1.score_points(500);
    player1.show_status();
    
    player2.score_points(300);
    player2.show_status();
    
    player1.score_points(700); // æ‡‰è©²å‡ç´š
    player1.show_status();
    
    player2.take_damage();
    player2.show_status();
}</code></pre></pre>
<h3 id="å€Ÿç”¨æª¢æŸ¥éŒ¯èª¤è™•ç†"><a class="header" href="#å€Ÿç”¨æª¢æŸ¥éŒ¯èª¤è™•ç†">å€Ÿç”¨æª¢æŸ¥éŒ¯èª¤è™•ç†</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    borrowing_safety_example();
    safe_borrow_pattern();
}

fn borrowing_safety_example() {
    let data = Rc::new(RefCell::new(vec![1, 2, 3]));
    
    // âœ… æ­£ç¢ºçš„ä½¿ç”¨æ–¹å¼
    {
        let borrowed = data.borrow();
        println!("ä¸å¯è®Šå€Ÿç”¨: {:?}", *borrowed);
    } // borrowed åœ¨é€™è£¡è¢«é‡‹æ”¾
    
    {
        let mut borrowed = data.borrow_mut();
        borrowed.push(4);
        println!("å¯è®Šå€Ÿç”¨å¾Œ: {:?}", *borrowed);
    } // borrowed åœ¨é€™è£¡è¢«é‡‹æ”¾
    
    // âœ… å®‰å…¨çš„æª¢æŸ¥æ–¹å¼
    if let Ok(borrowed) = data.try_borrow() {
        println!("å®‰å…¨å€Ÿç”¨: {:?}", *borrowed);
    } else {
        println!("ç„¡æ³•å€Ÿç”¨ï¼Œå·²è¢«å…¶ä»–äººä½¿ç”¨");
    }
    
    // âŒ é€™æœƒåœ¨é‹è¡Œæ™‚ panicï¼
    // let borrowed1 = data.borrow();
    // let borrowed2 = data.borrow_mut(); // panic: already borrowed
}

// å®‰å…¨çš„å€Ÿç”¨åŒ…è£å™¨
fn safe_borrow_pattern() {
    let data = Rc::new(RefCell::new(0));
    
    // ä½¿ç”¨å‡½æ•¸åŒ…è£å™¨é¿å…é•·æ™‚é–“å€Ÿç”¨
    fn with_data&lt;F, R&gt;(data: &amp;Rc&lt;RefCell&lt;i32&gt;&gt;, f: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut i32) -&gt; R,
    {
        if let Ok(mut guard) = data.try_borrow_mut() {
            Some(f(&amp;mut guard))
        } else {
            None
        }
    }
    
    if let Some(result) = with_data(&amp;data, |value| {
        *value += 1;
        *value
    }) {
        println!("æ“ä½œæˆåŠŸï¼Œæ–°å€¼: {}", result);
    } else {
        println!("æ“ä½œå¤±æ•—ï¼Œè³‡æºè¢«å€Ÿç”¨ä¸­");
    }
}</code></pre></pre>
<h3 id="weak-å¼•ç”¨é¿å…å¾ªç’°å¼•ç”¨"><a class="header" href="#weak-å¼•ç”¨é¿å…å¾ªç’°å¼•ç”¨">Weak å¼•ç”¨é¿å…å¾ªç’°å¼•ç”¨</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::{Rc, Weak};
use std::cell::RefCell;

fn main() {
    weak_reference_example();
}

#[derive(Debug)]
struct Parent {
    children: RefCell&lt;Vec&lt;Rc&lt;RefCell&lt;Child&gt;&gt;&gt;&gt;,
}

#[derive(Debug)]
struct Child {
    parent: RefCell&lt;Weak&lt;RefCell&lt;Parent&gt;&gt;&gt;,
    value: i32,
}

impl Parent {
    fn new() -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Parent {
            children: RefCell::new(Vec::new()),
        }))
    }
    
    fn add_child(parent: &amp;Rc&lt;RefCell&lt;Parent&gt;&gt;, value: i32) -&gt; Rc&lt;RefCell&lt;Child&gt;&gt; {
        let child = Rc::new(RefCell::new(Child {
            parent: RefCell::new(Rc::downgrade(parent)),
            value,
        }));
        
        parent.borrow().children.borrow_mut().push(Rc::clone(&amp;child));
        child
    }
}

fn weak_reference_example() {
    let parent = Parent::new();
    let child1 = Parent::add_child(&amp;parent, 1);
    let child2 = Parent::add_child(&amp;parent, 2);
    
    println!("çˆ¶ç¯€é»æœ‰ {} å€‹å­ç¯€é»", 
        parent.borrow().children.borrow().len());
    
    // é€šé weak å¼•ç”¨è¨ªå•çˆ¶ç¯€é»
    if let Some(parent_ref) = child1.borrow().parent.borrow().upgrade() {
        println!("å­ç¯€é»å¯ä»¥è¨ªå•çˆ¶ç¯€é»");
    }
    
    // ç•¶çˆ¶ç¯€é»è¢«ä¸Ÿæ£„æ™‚ï¼Œweak å¼•ç”¨æœƒå¤±æ•ˆ
    drop(parent);
    
    if child1.borrow().parent.borrow().upgrade().is_none() {
        println!("çˆ¶ç¯€é»å·²è¢«ä¸Ÿæ£„ï¼Œweak å¼•ç”¨å¤±æ•ˆ");
    }
}</code></pre></pre>
<h3 id="ä½¿ç”¨å ´æ™¯ç¸½çµ"><a class="header" href="#ä½¿ç”¨å ´æ™¯ç¸½çµ">ä½¿ç”¨å ´æ™¯ç¸½çµ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>å ´æ™¯</th><th>é©ç”¨æ€§</th><th>åŸå› </th></tr></thead><tbody>
<tr><td>ğŸŒ³ <strong>æ¨¹ç‹€çµæ§‹</strong></td><td>âœ… å¾ˆé©åˆ</td><td>éœ€è¦çˆ¶å­é›™å‘å¼•ç”¨</td></tr>
<tr><td>ğŸ® <strong>å–®åŸ·è¡Œç·’éŠæˆ²ç‹€æ…‹</strong></td><td>âœ… é©åˆ</td><td>å¤šå€‹ç³»çµ±å…±äº«ç‹€æ…‹</td></tr>
<tr><td>ğŸ–¼ï¸ <strong>GUI å…ƒä»¶</strong></td><td>âœ… é©åˆ</td><td>å…ƒä»¶é–“è¤‡é›œå¼•ç”¨é—œä¿‚</td></tr>
<tr><td>ğŸ“Š <strong>å–®åŸ·è¡Œç·’åœ–çµæ§‹</strong></td><td>âœ… é©åˆ</td><td>ç¯€é»é–“ç›¸äº’å¼•ç”¨</td></tr>
<tr><td>ğŸŒ <strong>å¤šåŸ·è¡Œç·’å ´æ™¯</strong></td><td>âŒ ä¸é©åˆ</td><td>ç„¡æ³•è·¨åŸ·è¡Œç·’å…±äº«</td></tr>
<tr><td>ğŸ”„ <strong>ç°¡å–®è³‡æ–™</strong></td><td>âŒ ä¸æ¨è–¦</td><td>éåº¦è¤‡é›œåŒ–</td></tr>
</tbody></table>
</div>
<h1 id="rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬å››éƒ¨åˆ†å¯¦æˆ°æ‡‰ç”¨èˆ‡æœ€ä½³å¯¦è¸-"><a class="header" href="#rust-é–æ©Ÿåˆ¶æŒ‡å—---ç¬¬å››éƒ¨åˆ†å¯¦æˆ°æ‡‰ç”¨èˆ‡æœ€ä½³å¯¦è¸-">Rust é–æ©Ÿåˆ¶æŒ‡å— - ç¬¬å››éƒ¨åˆ†ï¼šå¯¦æˆ°æ‡‰ç”¨èˆ‡æœ€ä½³å¯¦è¸ ğŸ¯</a></h1>
<h2 id="é«˜ç´šä¸¦è¡Œæ¨¡å¼-"><a class="header" href="#é«˜ç´šä¸¦è¡Œæ¨¡å¼-">é«˜ç´šä¸¦è¡Œæ¨¡å¼ ğŸš€</a></h2>
<h3 id="actor-æ¨¡å¼å¯¦ç¾"><a class="header" href="#actor-æ¨¡å¼å¯¦ç¾">Actor æ¨¡å¼å¯¦ç¾</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::collections::HashMap;

fn main() {
    actor_pattern_example();
}

// Actor è¨Šæ¯å®šç¾©
#[derive(Debug)]
enum Message {
    Set { key: String, value: String },
    Get { key: String, response: mpsc::Sender&lt;Option&lt;String&gt;&gt; },
    Delete { key: String },
    Stop,
}

// Key-Value Actor
struct KeyValueActor {
    receiver: mpsc::Receiver&lt;Message&gt;,
    data: HashMap&lt;String, String&gt;,
}

impl KeyValueActor {
    fn new() -&gt; (mpsc::Sender&lt;Message&gt;, thread::JoinHandle&lt;()&gt;) {
        let (sender, receiver) = mpsc::channel();
        
        let handle = thread::spawn(move || {
            let mut actor = KeyValueActor {
                receiver,
                data: HashMap::new(),
            };
            actor.run();
        });
        
        (sender, handle)
    }
    
    fn run(&amp;mut self) {
        loop {
            match self.receiver.recv() {
                Ok(Message::Set { key, value }) =&gt; {
                    println!("Actor: è¨­å®š {} = {}", key, value);
                    self.data.insert(key, value);
                }
                Ok(Message::Get { key, response }) =&gt; {
                    let value = self.data.get(&amp;key).cloned();
                    println!("Actor: æŸ¥è©¢ {} = {:?}", key, value);
                    let _ = response.send(value);
                }
                Ok(Message::Delete { key }) =&gt; {
                    let removed = self.data.remove(&amp;key);
                    println!("Actor: åˆªé™¤ {} = {:?}", key, removed);
                }
                Ok(Message::Stop) =&gt; {
                    println!("Actor: åœæ­¢é‹è¡Œ");
                    break;
                }
                Err(_) =&gt; {
                    println!("Actor: ç™¼é€ç«¯å·²é—œé–‰ï¼Œé€€å‡º");
                    break;
                }
            }
        }
    }
}

fn actor_pattern_example() {
    let (actor_sender, actor_handle) = KeyValueActor::new();
    
    // å¤šå€‹å®¢æˆ¶ç«¯åŸ·è¡Œç·’
    let mut clients = vec![];
    
    for i in 0..3 {
        let sender = actor_sender.clone();
        let client = thread::spawn(move || {
            // è¨­å®šå€¼
            sender.send(Message::Set {
                key: format!("key{}", i),
                value: format!("value{}", i),
            }).unwrap();
            
            // æŸ¥è©¢å€¼
            let (response_tx, response_rx) = mpsc::channel();
            sender.send(Message::Get {
                key: format!("key{}", i),
                response: response_tx,
            }).unwrap();
            
            if let Ok(value) = response_rx.recv() {
                println!("å®¢æˆ¶ç«¯ {} æ”¶åˆ°å›æ‡‰: {:?}", i, value);
            }
            
            // åˆªé™¤å€¼
            sender.send(Message::Delete {
                key: format!("key{}", i),
            }).unwrap();
        });
        clients.push(client);
    }
    
    // ç­‰å¾…æ‰€æœ‰å®¢æˆ¶ç«¯å®Œæˆ
    for client in clients {
        client.join().unwrap();
    }
    
    // åœæ­¢ Actor
    actor_sender.send(Message::Stop).unwrap();
    actor_handle.join().unwrap();
}</code></pre></pre>
<h3 id="åŸ·è¡Œç·’æ± å¯¦ç¾"><a class="header" href="#åŸ·è¡Œç·’æ± å¯¦ç¾">åŸ·è¡Œç·’æ± å¯¦ç¾</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    thread_pool_example();
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);
        
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!("é—œé–‰æ‰€æœ‰å·¥ä½œè€…...");
        
        for worker in &amp;mut self.workers {
            println!("é—œé–‰å·¥ä½œè€… {}", worker.id);
            
            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();
            
            match job {
                Ok(job) =&gt; {
                    println!("å·¥ä½œè€… {} åŸ·è¡Œä»»å‹™", id);
                    job();
                }
                Err(_) =&gt; {
                    println!("å·¥ä½œè€… {} æ–·é–‹é€£æ¥ï¼Œé—œé–‰", id);
                    break;
                }
            }
        });
        
        Worker {
            id,
            thread: Some(thread),
        }
    }
}

fn thread_pool_example() {
    let pool = ThreadPool::new(4);
    
    for i in 0..8 {
        pool.execute(move || {
            println!("åŸ·è¡Œä»»å‹™ {}", i);
            thread::sleep(Duration::from_secs(1));
            println!("ä»»å‹™ {} å®Œæˆ", i);
        });
    }
    
    println!("æ‰€æœ‰ä»»å‹™å·²æäº¤");
    
    // ç­‰å¾…ä¸€æ®µæ™‚é–“è®“ä»»å‹™å®Œæˆ
    thread::sleep(Duration::from_secs(3));
}</code></pre></pre>
<h3 id="æ•ˆèƒ½ç›£æ§ç³»çµ±"><a class="header" href="#æ•ˆèƒ½ç›£æ§ç³»çµ±">æ•ˆèƒ½ç›£æ§ç³»çµ±</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use std::thread;

fn main() {
    performance_monitoring_example();
}

#[derive(Debug)]
struct LockMetrics {
    acquisitions: AtomicU64,
    contentions: AtomicU64,
    total_wait_time: AtomicU64,
    max_wait_time: AtomicU64,
}

impl LockMetrics {
    fn new() -&gt; Self {
        LockMetrics {
            acquisitions: AtomicU64::new(0),
            contentions: AtomicU64::new(0),
            total_wait_time: AtomicU64::new(0),
            max_wait_time: AtomicU64::new(0),
        }
    }
    
    fn record_acquisition(&amp;self, wait_time: Duration, contended: bool) {
        self.acquisitions.fetch_add(1, Ordering::Relaxed);
        
        if contended {
            self.contentions.fetch_add(1, Ordering::Relaxed);
        }
        
        let wait_nanos = wait_time.as_nanos() as u64;
        self.total_wait_time.fetch_add(wait_nanos, Ordering::Relaxed);
        
        // æ›´æ–°æœ€å¤§ç­‰å¾…æ™‚é–“
        let mut current_max = self.max_wait_time.load(Ordering::Relaxed);
        while wait_nanos &gt; current_max {
            match self.max_wait_time.compare_exchange_weak(
                current_max,
                wait_nanos,
                Ordering::Relaxed,
                Ordering::Relaxed,
            ) {
                Ok(_) =&gt; break,
                Err(x) =&gt; current_max = x,
            }
        }
    }
    
    fn report(&amp;self) {
        let acquisitions = self.acquisitions.load(Ordering::Relaxed);
        let contentions = self.contentions.load(Ordering::Relaxed);
        let total_wait = self.total_wait_time.load(Ordering::Relaxed);
        let max_wait = self.max_wait_time.load(Ordering::Relaxed);
        
        if acquisitions &gt; 0 {
            let contention_rate = (contentions as f64 / acquisitions as f64) * 100.0;
            let avg_wait = total_wait as f64 / acquisitions as f64;
            
            println!("ğŸ”’ é–çµ±è¨ˆå ±å‘Š:");
            println!("  ç¸½ç²å–æ¬¡æ•¸: {}", acquisitions);
            println!("  ç«¶çˆ­æ¬¡æ•¸: {}", contentions);
            println!("  ç«¶çˆ­ç‡: {:.2}%", contention_rate);
            println!("  å¹³å‡ç­‰å¾…æ™‚é–“: {:.2}ns", avg_wait);
            println!("  æœ€å¤§ç­‰å¾…æ™‚é–“: {}ns", max_wait);
        }
    }
}

// ç›£æ§åŒ…è£å™¨
struct MonitoredMutex&lt;T&gt; {
    inner: Mutex&lt;T&gt;,
    metrics: LockMetrics,
}

impl&lt;T&gt; MonitoredMutex&lt;T&gt; {
    fn new(data: T) -&gt; Self {
        MonitoredMutex {
            inner: Mutex::new(data),
            metrics: LockMetrics::new(),
        }
    }
    
    fn lock(&amp;self) -&gt; std::sync::MutexGuard&lt;T&gt; {
        let start = Instant::now();
        let guard = self.inner.lock().unwrap();
        let wait_time = start.elapsed();
        
        // åˆ¤æ–·æ˜¯å¦æœ‰ç«¶çˆ­ (ç°¡å–®çš„å•Ÿç™¼å¼æ–¹æ³•)
        let contended = wait_time &gt; Duration::from_nanos(1000);
        self.metrics.record_acquisition(wait_time, contended);
        
        guard
    }
    
    fn metrics(&amp;self) -&gt; &amp;LockMetrics {
        &amp;self.metrics
    }
}

fn performance_monitoring_example() {
    let counter = Arc::new(MonitoredMutex::new(0));
    let mut handles = vec![];
    
    // å»ºç«‹å¤šå€‹ç«¶çˆ­åŸ·è¡Œç·’
    for i in 0..4 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for j in 0..1000 {
                {
                    let mut guard = counter.lock();
                    *guard += 1;
                    
                    // æ¨¡æ“¬ä¸€äº›å·¥ä½œ
                    if j % 100 == 0 {
                        thread::sleep(Duration::from_micros(10));
                    }
                }
                
                // å¶çˆ¾è®“å‡ºCPU
                if j % 50 == 0 {
                    thread::yield_now();
                }
            }
            println!("åŸ·è¡Œç·’ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }
    
    // ç›£æ§åŸ·è¡Œç·’
    let counter_monitor = Arc::clone(&amp;counter);
    let monitor = thread::spawn(move || {
        for _ in 0..5 {
            thread::sleep(Duration::from_secs(1));
            counter_monitor.metrics().report();
        }
    });
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    monitor.join().unwrap();
    
    println!("æœ€çµ‚è¨ˆæ•¸: {}", *counter.lock());
    println!("\næœ€çµ‚çµ±è¨ˆ:");
    counter.metrics().report();
}</code></pre></pre>
<h3 id="æ­»é–æª¢æ¸¬ç³»çµ±"><a class="header" href="#æ­»é–æª¢æ¸¬ç³»çµ±">æ­»é–æª¢æ¸¬ç³»çµ±</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use std::thread::{self, ThreadId};
use std::time::Duration;

fn main() {
    deadlock_detection_example();
}

struct DeadlockDetector {
    // è¨˜éŒ„å“ªå€‹åŸ·è¡Œç·’æŒæœ‰å“ªäº›é–
    lock_owners: Arc&lt;Mutex&lt;HashMap&lt;String, ThreadId&gt;&gt;&gt;,
    // è¨˜éŒ„åŸ·è¡Œç·’ç­‰å¾…å“ªäº›é–
    waiting_for: Arc&lt;Mutex&lt;HashMap&lt;ThreadId, String&gt;&gt;&gt;,
}

impl DeadlockDetector {
    fn new() -&gt; Self {
        DeadlockDetector {
            lock_owners: Arc::new(Mutex::new(HashMap::new())),
            waiting_for: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn try_acquire_lock(&amp;self, lock_id: &amp;str) -&gt; bool {
        let current_thread = thread::current().id();
        
        // æª¢æŸ¥é–æ˜¯å¦è¢«å…¶ä»–åŸ·è¡Œç·’æŒæœ‰
        let mut owners = self.lock_owners.lock().unwrap();
        
        if let Some(&amp;owner) = owners.get(lock_id) {
            if owner != current_thread {
                // è¨˜éŒ„ç­‰å¾…é—œä¿‚
                drop(owners);
                let mut waiting = self.waiting_for.lock().unwrap();
                waiting.insert(current_thread, lock_id.to_string());
                drop(waiting);
                
                // æª¢æŸ¥æ­»é–
                if self.detect_deadlock(current_thread) {
                    println!("âš ï¸ æª¢æ¸¬åˆ°æ­»é–ï¼åŸ·è¡Œç·’ {:?} ç­‰å¾…é– {}", current_thread, lock_id);
                    return false;
                }
                
                println!("åŸ·è¡Œç·’ {:?} ç­‰å¾…é– {}", current_thread, lock_id);
                return false;
            }
        }
        
        // ç²å–é–
        owners.insert(lock_id.to_string(), current_thread);
        println!("ğŸ”’ åŸ·è¡Œç·’ {:?} ç²å–é– {}", current_thread, lock_id);
        
        // æ¸…é™¤ç­‰å¾…è¨˜éŒ„
        drop(owners);
        let mut waiting = self.waiting_for.lock().unwrap();
        waiting.remove(&amp;current_thread);
        
        true
    }
    
    fn release_lock(&amp;self, lock_id: &amp;str) {
        let current_thread = thread::current().id();
        let mut owners = self.lock_owners.lock().unwrap();
        
        if owners.get(lock_id) == Some(&amp;current_thread) {
            owners.remove(lock_id);
            println!("ğŸ”“ åŸ·è¡Œç·’ {:?} é‡‹æ”¾é– {}", current_thread, lock_id);
        }
    }
    
    fn detect_deadlock(&amp;self, start_thread: ThreadId) -&gt; bool {
        let waiting = self.waiting_for.lock().unwrap();
        let owners = self.lock_owners.lock().unwrap();
        
        let mut visited = HashSet::new();
        let mut current_thread = start_thread;
        
        loop {
            if visited.contains(&amp;current_thread) {
                return true; // ç™¼ç¾ç’°ï¼Œå³æ­»é–
            }
            
            visited.insert(current_thread);
            
            // æ‰¾åˆ°ç•¶å‰åŸ·è¡Œç·’ç­‰å¾…çš„é–
            if let Some(waiting_lock) = waiting.get(&amp;current_thread) {
                // æ‰¾åˆ°æŒæœ‰è©²é–çš„åŸ·è¡Œç·’
                if let Some(&amp;lock_owner) = owners.get(waiting_lock) {
                    if lock_owner == start_thread {
                        return true; // å›åˆ°èµ·å§‹åŸ·è¡Œç·’ï¼Œç™¼ç¾æ­»é–
                    }
                    current_thread = lock_owner;
                } else {
                    break; // é–æ²’æœ‰è¢«æŒæœ‰
                }
            } else {
                break; // åŸ·è¡Œç·’æ²’æœ‰ç­‰å¾…ä»»ä½•é–
            }
        }
        
        false
    }
}

// æœ‰åºé–åŒ…è£å™¨
struct OrderedLock {
    id: String,
    inner: Mutex&lt;i32&gt;,
    detector: Arc&lt;DeadlockDetector&gt;,
}

impl OrderedLock {
    fn new(id: String, detector: Arc&lt;DeadlockDetector&gt;) -&gt; Self {
        OrderedLock {
            id,
            inner: Mutex::new(0),
            detector,
        }
    }
    
    fn lock(&amp;self) -&gt; Option&lt;std::sync::MutexGuard&lt;i32&gt;&gt; {
        // å˜—è©¦ç²å–é–
        while !self.detector.try_acquire_lock(&amp;self.id) {
            thread::sleep(Duration::from_millis(10));
        }
        
        Some(self.inner.lock().unwrap())
    }
    
    fn unlock(&amp;self) {
        self.detector.release_lock(&amp;self.id);
    }
}

fn deadlock_detection_example() {
    let detector = Arc::new(DeadlockDetector::new());
    
    let lock1 = Arc::new(OrderedLock::new("lock1".to_string(), Arc::clone(&amp;detector)));
    let lock2 = Arc::new(OrderedLock::new("lock2".to_string(), Arc::clone(&amp;detector)));
    
    let lock1_clone = Arc::clone(&amp;lock1);
    let lock2_clone = Arc::clone(&amp;lock2);
    
    // åŸ·è¡Œç·’1: å…ˆé–lock1ï¼Œå†é–lock2
    let t1 = thread::spawn(move || {
        if let Some(_guard1) = lock1_clone.lock() {
            println!("åŸ·è¡Œç·’1ç²å¾—lock1");
            thread::sleep(Duration::from_millis(100));
            
            if let Some(_guard2) = lock2_clone.lock() {
                println!("åŸ·è¡Œç·’1ç²å¾—lock2");
                thread::sleep(Duration::from_millis(100));
                lock2_clone.unlock();
            }
            lock1_clone.unlock();
        }
    });
    
    let lock1_clone2 = Arc::clone(&amp;lock1);
    let lock2_clone2 = Arc::clone(&amp;lock2);
    
    // åŸ·è¡Œç·’2: å…ˆé–lock2ï¼Œå†é–lock1 (å¯èƒ½é€ æˆæ­»é–)
    let t2 = thread::spawn(move || {
        thread::sleep(Duration::from_millis(50)); // éŒ¯é–‹å•Ÿå‹•æ™‚é–“
        
        if let Some(_guard2) = lock2_clone2.lock() {
            println!("åŸ·è¡Œç·’2ç²å¾—lock2");
            thread::sleep(Duration::from_millis(100));
            
            if let Some(_guard1) = lock1_clone2.lock() {
                println!("åŸ·è¡Œç·’2ç²å¾—lock1");
                thread::sleep(Duration::from_millis(100));
                lock1_clone2.unlock();
            }
            lock2_clone2.unlock();
        }
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}</code></pre></pre>
<hr />
<h2 id="é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸-"><a class="header" href="#é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸-">é¸æ“‡æŒ‡å—èˆ‡æœ€ä½³å¯¦è¸ ğŸ¯</a></h2>
<h3 id="å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹"><a class="header" href="#å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹">å®Œæ•´é¸æ“‡æ±ºç­–æ¨¹</a></h3>
<pre><pre class="playground"><code class="language-rust">// æ±ºç­–è¼”åŠ©å‡½æ•¸
fn choose_synchronization_primitive() -&gt; &amp;'static str {
    // é€™æ˜¯ä¸€å€‹æ¦‚å¿µæ€§çš„æ±ºç­–æ¨¹
    "
    é¸æ“‡æµç¨‹ï¼š
    
    1. éœ€è¦å…±äº«è³‡æ–™å—ï¼Ÿ
       â””â”€ å¦ â†’ ä½¿ç”¨æ‰€æœ‰æ¬Šè½‰ç§» (move)
       â””â”€ æ˜¯ â†’ ç¹¼çºŒ
    
    2. å–®åŸ·è¡Œç·’é‚„æ˜¯å¤šåŸ·è¡Œç·’ï¼Ÿ
       â””â”€ å–®åŸ·è¡Œç·’ â†’ Rc&lt;RefCell&lt;T&gt;&gt;
       â””â”€ å¤šåŸ·è¡Œç·’ â†’ ç¹¼çºŒ
    
    3. ä»€éº¼é¡å‹çš„æ“ä½œï¼Ÿ
       â”œâ”€ ç°¡å–®è¨ˆæ•¸/æ¨™èªŒ â†’ Atomic é¡å‹
       â”œâ”€ è¤‡é›œè³‡æ–™çµæ§‹ â†’ ç¹¼çºŒ
       â””â”€ åŸ·è¡Œç·’é–“é€šè¨Š â†’ Channel
    
    4. è®€å¯«æ¨¡å¼ï¼Ÿ
       â”œâ”€ å¤šè®€å°‘å¯« â†’ Arc&lt;RwLock&lt;T&gt;&gt;
       â””â”€ è®€å¯«å¹³è¡¡ â†’ Arc&lt;Mutex&lt;T&gt;&gt;
    
    5. éœ€è¦ç­‰å¾…æ¢ä»¶ï¼Ÿ
       â””â”€ æ˜¯ â†’ Condvar + Mutex
    "
}

fn main() {
    let guide = choose_synchronization_primitive();
    println!("{}", guide);
}</code></pre></pre>
<h3 id="æ•ˆèƒ½å°æ¯”è¡¨"><a class="header" href="#æ•ˆèƒ½å°æ¯”è¡¨">æ•ˆèƒ½å°æ¯”è¡¨</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åŒæ­¥åŸèª</th><th>å»¶é²</th><th>ååé‡</th><th>è¨˜æ†¶é«”ä½¿ç”¨</th><th>è¤‡é›œåº¦</th><th>é©ç”¨å ´æ™¯</th></tr></thead><tbody>
<tr><td><code>Atomic</code></td><td>ğŸŸ¢ æ¥µä½</td><td>ğŸŸ¢ æ¥µé«˜</td><td>ğŸŸ¢ æ¥µå°</td><td>ğŸŸ¢ ç°¡å–®</td><td>è¨ˆæ•¸å™¨ã€æ¨™èªŒ</td></tr>
<tr><td><code>Arc&lt;RwLock&gt;</code> (è®€)</td><td>ğŸŸ¢ ä½</td><td>ğŸŸ¢ é«˜</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>è¨­å®šæª”ã€å¿«å–</td></tr>
<tr><td><code>Channel</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ ç°¡å–®</td><td>åŸ·è¡Œç·’é€šè¨Š</td></tr>
<tr><td><code>Arc&lt;Mutex&gt;</code></td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸŸ¢ ç°¡å–®</td><td>åŸºæœ¬å…±äº«</td></tr>
<tr><td><code>Condvar</code></td><td>ğŸ”´ é«˜</td><td>ğŸ”´ ä½</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>ğŸ”´ è¤‡é›œ</td><td>æ¢ä»¶ç­‰å¾…</td></tr>
<tr><td><code>Rc&lt;RefCell&gt;</code></td><td>ğŸŸ¢ ä½</td><td>ğŸŸ¢ é«˜</td><td>ğŸŸ¢ å°</td><td>ğŸŸ¡ ä¸­ç­‰</td><td>å–®åŸ·è¡Œç·’å…±äº«</td></tr>
</tbody></table>
</div>
<h3 id="æœ€ä½³å¯¦è¸æŒ‡å—"><a class="header" href="#æœ€ä½³å¯¦è¸æŒ‡å—">æœ€ä½³å¯¦è¸æŒ‡å—</a></h3>
<h4 id="1-æ‰€æœ‰æ¬Šé©…å‹•è¨­è¨ˆ"><a class="header" href="#1-æ‰€æœ‰æ¬Šé©…å‹•è¨­è¨ˆ">1. æ‰€æœ‰æ¬Šé©…å‹•è¨­è¨ˆ</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

// âœ… å¥½çš„è¨­è¨ˆï¼šæ¸…æ™°çš„æ‰€æœ‰æ¬Š
fn good_ownership_design() {
    let data = vec![1, 2, 3, 4, 5];
    
    // ç§»å‹•æ‰€æœ‰æ¬Šçµ¦å·¥ä½œåŸ·è¡Œç·’
    let handle = thread::spawn(move || {
        let processed: Vec&lt;_&gt; = data.iter().map(|x| x * 2).collect();
        processed
    });
    
    let result = handle.join().unwrap();
    println!("è™•ç†çµæœ: {:?}", result);
}

// âŒ é¿å…çš„æ¨¡å¼ï¼šä¸å¿…è¦çš„å…±äº«
fn avoid_unnecessary_sharing() {
    use std::sync::{Arc, Mutex};
    
    let data = Arc::new(Mutex::new(vec![1, 2, 3, 4, 5]));
    
    // å¦‚æœåªæ˜¯ç‚ºäº†å‚³éè³‡æ–™ï¼Œä¸å¦‚ç›´æ¥ç§»å‹•æ‰€æœ‰æ¬Š
    let data_clone = Arc::clone(&amp;data);
    thread::spawn(move || {
        let guard = data_clone.lock().unwrap();
        println!("è³‡æ–™: {:?}", *guard);
    });
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-é–çš„ç²’åº¦æ§åˆ¶"><a class="header" href="#2-é–çš„ç²’åº¦æ§åˆ¶">2. é–çš„ç²’åº¦æ§åˆ¶</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, RwLock, Mutex};
use std::collections::HashMap;

// âœ… ç´°ç²’åº¦é–ï¼šæ›´å¥½çš„ä¸¦è¡Œæ€§
struct FinegrainedCache {
    user_cache: Arc&lt;RwLock&lt;HashMap&lt;u64, User&gt;&gt;&gt;,
    session_cache: Arc&lt;RwLock&lt;HashMap&lt;String, Session&gt;&gt;&gt;,
    config: Arc&lt;RwLock&lt;Config&gt;&gt;,
}

// âŒ ç²—ç²’åº¦é–ï¼šé™åˆ¶ä¸¦è¡Œæ€§
struct CoarseGrainedCache {
    data: Arc&lt;Mutex&lt;(HashMap&lt;u64, User&gt;, HashMap&lt;String, Session&gt;, Config)&gt;&gt;,
}

#[derive(Clone)]
struct User { name: String }
#[derive(Clone)]
struct Session { token: String }
#[derive(Clone)]
struct Config { setting: String }

fn main() {
    // ç¤ºä¾‹ç”¨æ³•
    let _fine_cache = FinegrainedCache {
        user_cache: Arc::new(RwLock::new(HashMap::new())),
        session_cache: Arc::new(RwLock::new(HashMap::new())),
        config: Arc::new(RwLock::new(Config { setting: "default".to_string() })),
    };
    
    let _coarse_cache = CoarseGrainedCache {
        data: Arc::new(Mutex::new((HashMap::new(), HashMap::new(), Config { setting: "default".to_string() }))),
    };
    
    println!("ç·©å­˜çµæ§‹å·²å»ºç«‹");
}</code></pre></pre>
<h4 id="3-éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸"><a class="header" href="#3-éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸">3. éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex, PoisonError};

fn main() {
    safe_counter_increment();
}

// å¼·å¥çš„éŒ¯èª¤è™•ç†
fn robust_operation&lt;T, R&gt;(
    mutex: &amp;Arc&lt;Mutex&lt;T&gt;&gt;,
    operation: impl FnOnce(&amp;mut T) -&gt; R,
) -&gt; Result&lt;R, String&gt; {
    match mutex.lock() {
        Ok(mut guard) =&gt; Ok(operation(&amp;mut guard)),
        Err(poisoned) =&gt; {
            // è¨˜éŒ„æ¯’åŒ–äº‹ä»¶
            eprintln!("è­¦å‘Š: Mutex è¢«æ¯’åŒ–ï¼Œå˜—è©¦æ¢å¾©æ“ä½œ");
            
            // å˜—è©¦æ¢å¾©
            let mut guard = poisoned.into_inner();
            Ok(operation(&amp;mut guard))
        }
    }
}

// ä½¿ç”¨ç¯„ä¾‹
fn safe_counter_increment() {
    let counter = Arc::new(Mutex::new(0));
    
    match robust_operation(&amp;counter, |count| {
        *count += 1;
        *count
    }) {
        Ok(new_value) =&gt; println!("è¨ˆæ•¸å™¨å€¼: {}", new_value),
        Err(e) =&gt; eprintln!("æ“ä½œå¤±æ•—: {}", e),
    }
}</code></pre></pre>
<h4 id="4-channel-ä½¿ç”¨æ¨¡å¼"><a class="header" href="#4-channel-ä½¿ç”¨æ¨¡å¼">4. Channel ä½¿ç”¨æ¨¡å¼</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    graceful_shutdown_pattern();
}

// å„ªé›…é—œé–‰æ¨¡å¼
fn graceful_shutdown_pattern() {
    let (tx, rx) = mpsc::channel();
    let (shutdown_tx, shutdown_rx) = mpsc::channel();
    
    // å·¥ä½œåŸ·è¡Œç·’
    let worker = thread::spawn(move || {
        loop {
            // æª¢æŸ¥é—œé–‰ä¿¡è™Ÿ
            if let Ok(_) = shutdown_rx.try_recv() {
                println!("æ”¶åˆ°é—œé–‰ä¿¡è™Ÿ");
                break;
            }
            
            // è™•ç†å·¥ä½œ
            match rx.try_recv() {
                Ok(work) =&gt; process_work(work),
                Err(mpsc::TryRecvError::Empty) =&gt; {
                    // æ²’æœ‰å·¥ä½œï¼Œé€²è¡Œç¶­è­·
                    maintenance_work();
                    thread::sleep(Duration::from_millis(100));
                }
                Err(mpsc::TryRecvError::Disconnected) =&gt; {
                    println!("å·¥ä½œé€šé“å·²é—œé–‰");
                    break;
                }
            }
        }
        println!("å·¥ä½œåŸ·è¡Œç·’å„ªé›…é€€å‡º");
    });
    
    // ç™¼é€ä¸€äº›å·¥ä½œ
    for i in 0..5 {
        tx.send(i).unwrap();
        thread::sleep(Duration::from_millis(50));
    }
    
    // ç­‰å¾…å·¥ä½œå®Œæˆ
    thread::sleep(Duration::from_millis(500));
    
    // å„ªé›…é—œé–‰
    shutdown_tx.send(()).unwrap();
    worker.join().unwrap();
}

fn process_work(work: i32) {
    println!("è™•ç†å·¥ä½œ: {}", work);
    thread::sleep(Duration::from_millis(100));
}

fn maintenance_work() {
    // å®šæœŸç¶­è­·å·¥ä½œ
    println!("åŸ·è¡Œç¶­è­·å·¥ä½œ");
}</code></pre></pre>
<h4 id="5-è¨˜æ†¶é«”é †åºæŒ‡å—"><a class="header" href="#5-è¨˜æ†¶é«”é †åºæŒ‡å—">5. è¨˜æ†¶é«”é †åºæŒ‡å—</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, AtomicI32, Ordering};
use std::thread;

fn main() {
    optimized_memory_ordering();
}

// ç”Ÿç”¢è€…-æ¶ˆè²»è€…çš„æœ€ä½³åŒ–è¨˜æ†¶é«”é †åº
static DATA: AtomicI32 = AtomicI32::new(0);
static READY: AtomicBool = AtomicBool::new(false);

fn optimized_memory_ordering() {
    // ç”Ÿç”¢è€…
    let producer = thread::spawn(|| {
        // 1. å¯«å…¥è³‡æ–™ (å¯ä»¥æ˜¯ Relaxed)
        DATA.store(42, Ordering::Relaxed);
        
        // 2. ç™¼å¸ƒæº–å‚™æ¨™èªŒ (å¿…é ˆæ˜¯ Release)
        READY.store(true, Ordering::Release);
        
        println!("ç”Ÿç”¢è€…: è³‡æ–™å·²æº–å‚™");
    });
    
    // æ¶ˆè²»è€…
    let consumer = thread::spawn(|| {
        // 1. ç­‰å¾…æº–å‚™æ¨™èªŒ (å¿…é ˆæ˜¯ Acquire)
        while !READY.load(Ordering::Acquire) {
            std::hint::spin_loop();
        }
        
        // 2. è®€å–è³‡æ–™ (å¯ä»¥æ˜¯ Relaxed)
        let value = DATA.load(Ordering::Relaxed);
        println!("æ¶ˆè²»è€…: è®€å–åˆ° {}", value);
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
    
    // é‡ç½®ç‹€æ…‹
    READY.store(false, Ordering::Relaxed);
    DATA.store(0, Ordering::Relaxed);
}</code></pre></pre>
<h3 id="é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§"><a class="header" href="#é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§">é™¤éŒ¯èˆ‡è¨ºæ–·æŠ€å·§</a></h3>
<h4 id="1-æ­»é–è¨ºæ–·"><a class="header" href="#1-æ­»é–è¨ºæ–·">1. æ­»é–è¨ºæ–·</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ä½¿ç”¨ parking_lot çš„æ­»é–æª¢æ¸¬
use std::thread;

#[cfg(feature = "deadlock_detection")]
fn enable_deadlock_detection() {
    use parking_lot::deadlock;
    use std::time::Duration;
    
    thread::spawn(move || {
        loop {
            thread::sleep(Duration::from_secs(10));
            let deadlocks = deadlock::check_deadlock();
            
            if deadlocks.is_empty() {
                continue;
            }
            
            println!("ğŸš¨ æª¢æ¸¬åˆ° {} å€‹æ­»é–", deadlocks.len());
            for (i, threads) in deadlocks.iter().enumerate() {
                println!("æ­»é– #{}", i);
                for t in threads {
                    println!("  åŸ·è¡Œç·’ ID: {:?}", t.thread_id());
                    println!("  å †ç–Šè¿½è¹¤: {:#?}", t.backtrace());
                }
            }
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-æ•ˆèƒ½åˆ†æå·¥å…·"><a class="header" href="#2-æ•ˆèƒ½åˆ†æå·¥å…·">2. æ•ˆèƒ½åˆ†æå·¥å…·</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Instant;

fn main() {
    let profiler = PerformanceProfiler::new();
    
    // æ¨¡æ“¬ä¸€äº›æ“ä½œ
    for _ in 0..1000 {
        profiler.record_operation();
        // æ¨¡æ“¬å·¥ä½œ
        std::thread::sleep(std::time::Duration::from_micros(10));
    }
    
    profiler.report();
}

// è‡ªè¨‚æ•ˆèƒ½åˆ†æå™¨
struct PerformanceProfiler {
    start_time: Instant,
    operations: AtomicUsize,
}

impl PerformanceProfiler {
    fn new() -&gt; Self {
        PerformanceProfiler {
            start_time: Instant::now(),
            operations: AtomicUsize::new(0),
        }
    }
    
    fn record_operation(&amp;self) {
        self.operations.fetch_add(1, Ordering::Relaxed);
    }
    
    fn report(&amp;self) {
        let elapsed = self.start_time.elapsed();
        let ops = self.operations.load(Ordering::Relaxed);
        let ops_per_sec = ops as f64 / elapsed.as_secs_f64();
        
        println!("ğŸ“Š æ•ˆèƒ½å ±å‘Š:");
        println!("  åŸ·è¡Œæ™‚é–“: {:?}", elapsed);
        println!("  ç¸½æ“ä½œæ•¸: {}", ops);
        println!("  æ¯ç§’æ“ä½œæ•¸: {:.2}", ops_per_sec);
    }
}</code></pre></pre>
<hr />
<h2 id="å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ-"><a class="header" href="#å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ-">å­¸ç¿’è·¯å¾‘èˆ‡ç¸½çµ ğŸ“</a></h2>
<h3 id="å­¸ç¿’è·¯å¾‘å»ºè­°"><a class="header" href="#å­¸ç¿’è·¯å¾‘å»ºè­°">å­¸ç¿’è·¯å¾‘å»ºè­°</a></h3>
<pre><code>ğŸŒ± åˆå­¸è€… (0-3å€‹æœˆ):
â”œâ”€â”€ ç†è§£æ‰€æœ‰æ¬Šç³»çµ±
â”œâ”€â”€ æŒæ¡ Arc&lt;Mutex&lt;T&gt;&gt;
â”œâ”€â”€ å­¸ç¿’åŸºæœ¬ Channel
â””â”€â”€ å¯¦ä½œç°¡å–®ä½µç™¼ç¨‹å¼

ğŸš€ ä¸­ç´šè€… (3-6å€‹æœˆ):
â”œâ”€â”€ æ·±å…¥ RwLock å’Œ Atomic
â”œâ”€â”€ æŒæ¡ Condvar ä½¿ç”¨
â”œâ”€â”€ å­¸ç¿’æ•ˆèƒ½æœ€ä½³åŒ–
â””â”€â”€ å¯¦ä½œè¤‡é›œä½µç™¼ç³»çµ±

ğŸ¯ é«˜ç´šè€… (6å€‹æœˆä»¥ä¸Š):
â”œâ”€â”€ ç„¡é–ç¨‹å¼è¨­è¨ˆ
â”œâ”€â”€ è‡ªè¨‚åŒæ­¥åŸèª
â”œâ”€â”€ è¨˜æ†¶é«”é †åºæ·±åº¦ç†è§£
â””â”€â”€ é«˜æ•ˆèƒ½ç³»çµ±è¨­è¨ˆ
</code></pre>
<h3 id="ç¸½çµè¦é»"><a class="header" href="#ç¸½çµè¦é»">ç¸½çµè¦é»</a></h3>
<p><strong>âœ¨ Rust ä¸¦è¡Œç·¨ç¨‹çš„ç¨ç‰¹å„ªå‹¢:</strong></p>
<ul>
<li>ğŸ›¡ï¸ <strong>ç·¨è­¯æ™‚å®‰å…¨</strong> - é˜²æ­¢è³‡æ–™ç«¶çˆ­</li>
<li>âš¡ <strong>é›¶æˆæœ¬æŠ½è±¡</strong> - é«˜æ•ˆèƒ½ä¸çŠ§ç‰²å®‰å…¨</li>
<li>ğŸ¯ <strong>æ‰€æœ‰æ¬Šæ¸…æ™°</strong> - æ˜ç¢ºçš„è³‡æºç®¡ç†</li>
<li>ğŸ”§ <strong>è±å¯Œå·¥å…·</strong> - å¾åŸºç¤åˆ°é«˜ç´šçš„å®Œæ•´å·¥å…·éˆ</li>
</ul>
<p><strong>ğŸ¯ æ ¸å¿ƒè¨­è¨ˆåŸå‰‡:</strong></p>
<ol>
<li><strong>å„ªå…ˆè¨Šæ¯å‚³é</strong> - Channel å‹éå…±äº«è¨˜æ†¶é«”</li>
<li><strong>æœ€å°åŒ–å…±äº«</strong> - åªåœ¨å¿…è¦æ™‚ä½¿ç”¨ Arc</li>
<li><strong>æ˜ç¢ºæ‰€æœ‰æ¬Š</strong> - è®“é¡å‹ç³»çµ±æŒ‡å°è¨­è¨ˆ</li>
<li><strong>æ¸¬è©¦é©…å‹•</strong> - ä½µç™¼ç¨‹å¼çš„æ­£ç¢ºæ€§è‡³é—œé‡è¦</li>
</ol>
<p><strong>ğŸš€ å¯¦è¸å»ºè­°:</strong></p>
<ul>
<li>å¾ç°¡å–®çš„ Arc&lt;Mutex<T>&gt; é–‹å§‹å­¸ç¿’</li>
<li>é‡è¦–ç·¨è­¯å™¨çš„éŒ¯èª¤è¨Šæ¯å’Œå»ºè­°</li>
<li>ä½¿ç”¨æ•ˆèƒ½åˆ†æå·¥å…·ç›£æ§ç¨‹å¼è¡Œç‚º</li>
<li>ç©æ¥µä½¿ç”¨ Rust ç¤¾ç¾¤çš„æœ€ä½³å¯¦è¸</li>
</ul>
<p>è¨˜ä½ Rust çš„æ ¸å¿ƒç†å¿µï¼š<strong>å¦‚æœç¨‹å¼èƒ½å¤ ç·¨è­¯é€šéï¼Œå®ƒå¾ˆå¯èƒ½å°±æ˜¯æ­£ç¢ºçš„ä¸¦è¡Œç¨‹å¼</strong> ğŸ¦€âœ¨</p>
<hr />
<p><em>å®Œæ•´æŒ‡å—åˆ°æ­¤çµæŸã€‚é€šéé€™å››å€‹éƒ¨åˆ†ï¼Œæ‚¨å·²ç¶“æŒæ¡äº† Rust ä¸¦è¡Œç¨‹å¼è¨­è¨ˆçš„å®Œæ•´çŸ¥è­˜é«”ç³»ï¼</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust/rust_wrappers_guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rust/rust_generics_guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust/rust_wrappers_guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rust/rust_generics_guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
