<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>給 C++ 使用者的 Rust 簡介 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="給-c-使用者的-rust-簡介"><a class="header" href="#給-c-使用者的-rust-簡介">給 C++ 使用者的 Rust 簡介</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> 是最近受到廣泛注目的新語言。最早由 Mozilla 資助開發，後來因為 Dropbox 使用 Rust 改寫檔案系統服務[<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn1">1]</a>而聲明大噪。目前 Rust 是很活躍的開源專案，有超過一千名開發者共同開發，大約一至兩個月就會有一次 minor release。</p>
<p>設計程式語言最困難的地方在於選擇，沒有一個語言是上山下海無所不能的，而 Rust 也不例外。Rust 的目標是成為高效率、易於平行運算的系統程式語言，因此它選擇了以下的特性：</p>
<ul>
<li>靜態型別 (static-typed)</li>
<li>區分 mutable 與 immutable，所有變數預設為 immutable，盡可能減少 mutable state</li>
<li>使用 tagged union 與 pattern matching</li>
<li>不使用動態垃圾回收 (garbage collection)，而使用靜態的 RAII</li>
<li>使用 Move semantics 避免複製物件</li>
<li>使用 borrow checker 確保 memory safety 與 thread safety</li>
</ul>
<p>因此，對於習慣主流程式語言的使用者來說，Rust 的學習曲線非常陡峭，光是要讓程式碼通過編譯就要花上不少時間。接下來這一系列的文章，是以 C++ 使用者為對象，介紹 Rust 的各種語言功能以及背後的設計目標，希望各位可以看得很愉快。</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>先從每個語言都會有的 hello world 開始吧：</p>
<pre><pre class="playground"><code class="language-rust">// hello.rs
fn main() {
    println!("hello world");
}</code></pre></pre>
<p>編譯與執行方法如下：</p>
<pre><code>$ rustc -o hello hello.rs
$ ./hello
hello world
</code></pre>
<p>從這個最簡單的範例可以看出與 C++ 相同的地方：</p>
<ul>
<li>註解也是 <code>//</code>，你也可以用 <code>/* */</code> 寫多行註解。</li>
<li>程式也是以 <code>main</code> 為進入點。</li>
<li>函式也同樣用大括號包起整個結構，每行敘述使用 <code>;</code> 作為結尾。</li>
</ul>
<p>不一樣的地方則是：</p>
<ul>
<li>沒有 <code>#include</code>。</li>
<li>需要用 <code>fn</code> 關鍵字來定義函式。</li>
<li><code>main</code> 沒有回傳值。</li>
<li><code>println!</code> 函式名稱多了一個驚嘆號。</li>
</ul>
<p><code>rustc</code> 會自動幫你引入一部份的標準函式庫 (std::prelude)，因此你不需要為了印一行字額外引入函式庫。另外 <code>println</code> 後面的驚嘆號代表它其實不是函式，而是巨集 (macro)。由於本文重點不在巨集，因此我們只要先知道 <code>println!</code> 可以拿來當 <code>printf</code> 那樣用就可以了。</p>
<h2 id="型別與變數"><a class="header" href="#型別與變數">型別與變數</a></h2>
<p>宣告變數的方法是使用 <code>let</code> 關鍵字：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 10;
    let y: f32 = 3.14;
    println!("x = {}, y = {}", x, y); // x = 10, y = 3.14
}</code></pre></pre>
<p>Rust 會自動推導型別，因此 <code>x</code> 的型別是 <code>i32</code>，意指 32bit signed integer。你也可以在變數名稱後加上冒號來指定型別，因此 <code>y</code> 的型別是 32bit floating point，而不是 floating point literal 預設的 <code>f64</code>。</p>
<p>Rust 的內建型別及對應的 C++ 型別如下：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Rust type</th><th style="text-align: left">C++ type</th><th style="text-align: left">說明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>bool</code></td><td style="text-align: left"><code>bool</code></td><td style="text-align: left">布林值</td></tr>
<tr><td style="text-align: left"><code>i8</code></td><td style="text-align: left"><code>int8_t</code></td><td style="text-align: left">8-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u8</code></td><td style="text-align: left"><code>uint8_t</code></td><td style="text-align: left">8-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i16</code></td><td style="text-align: left"><code>int16_t</code></td><td style="text-align: left">16-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u16</code></td><td style="text-align: left"><code>uint16_t</code></td><td style="text-align: left">16-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i32</code></td><td style="text-align: left"><code>int32_t</code></td><td style="text-align: left">32-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u32</code></td><td style="text-align: left"><code>uint32_t</code></td><td style="text-align: left">32-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i64</code></td><td style="text-align: left"><code>int64_t</code></td><td style="text-align: left">64-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u64</code></td><td style="text-align: left"><code>uint64_t</code></td><td style="text-align: left">64-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>usize</code></td><td style="text-align: left"><code>size_t</code></td><td style="text-align: left">可表達記憶體空間內最大物件大小的無號整數型別，常用來表示 array index</td></tr>
<tr><td style="text-align: left"><code>isize</code></td><td style="text-align: left"><code>ptrdiff_t</code></td><td style="text-align: left">上述型別的有號版本，可用來表達兩個 array index 的差異</td></tr>
<tr><td style="text-align: left"><code>f32</code></td><td style="text-align: left"><code>float</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn2">2]</a></td><td style="text-align: left">IEEE754 規範的 32-bit 浮點數</td></tr>
<tr><td style="text-align: left"><code>f64</code></td><td style="text-align: left"><code>double</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn2">2]</a></td><td style="text-align: left">IEEE754 規範的 64-bit 浮點數</td></tr>
<tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>char32_t</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn3">3]</a></td><td style="text-align: left">使用 UTF-32 表達的 Unicode 字元</td></tr>
</tbody></table>
</div>
<h2 id="mutable--immutable"><a class="header" href="#mutable--immutable">Mutable &amp; Immutable</a></h2>
<p>雖然講起來很矛盾，但預設情況下變數是不可變的 (immutable)：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
x = x + 1; // error: re-assignment of immutable variable `x`
<span class="boring">}</span></code></pre></pre>
<p>若要讓變數可以重新賦值，需要使用 <code>mut</code> 關鍵字來宣告：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut y = 10;
y = y + 1; // ok
<span class="boring">}</span></code></pre></pre>
<p>有很多理由支持讓 immutable 成為預設，比如說 compiler 的最佳化或是減少 race condition。在後續的文章中，我會更進一步討論。</p>
<h2 id="struct--tuple"><a class="header" href="#struct--tuple">Struct &amp; Tuple</a></h2>
<p>Rust 的 struct 宣告方式與 C++ 大同小異，差別僅在於各成員型別的位置、使用逗號作為分隔、以及結尾不需要加分號：</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
    y: f64,
}

fn main() {
    let foo = Foo { x: 10, y: 2.5 };
    println!("foo.x = {}, foo.y = {}", foo.x, foo.y);
}</code></pre></pre>
<p>而 tuple 其實是個語法糖 (syntactic sugar)，相當於使用編號當作成員名稱的 struct：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let triple = (10, 3.14, 'x');
println!("triple = ({}, {}, {})", triple.0, triple.1, triple.2)
<span class="boring">}</span></code></pre></pre>
<p>編譯器會把它轉變成這樣 (以下為示意，實際上宣告 struct 時不能拿數字當成員名稱)：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Triple {
    0: i32,
    1: f64,
    2: char,
}
let triple = Triple { 0: 10, 1: 3.14, 2: 'x'};
println!("triple = ({}, {}, {})", triple.0, triple.1, triple.2)
<span class="boring">}</span></code></pre></pre>
<p>值得注意的是，沒有任何元素的 tuple，也就是 0-tuple，也是一個合法的型別，稱之為 <em>unit type</em>。它具有唯一一個可能的值，就是空的 tuple，稱之為 <em>unit</em>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit: () = (); // 完全合法，雖然你沒辦法拿這個變數做什麼事
<span class="boring">}</span></code></pre></pre>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h2>
<p>若是沒有覆載賦值運算子，C++ 的 struct 具備 value-type semantics，意即使用等號賦值或進行參數傳遞時，會複製整個物件的內容。而 Java class 則具備 reference-type semantics，使用等號僅僅複製物件的位址，它們仍然會影響同一個物件的內容。</p>
<p>Rust 並沒有 class，那麼 rust 的 struct 是 value-type 還是 reference-type 呢？我們試著用最簡單的做法來判定 value-type 與 reference-type：宣告一個物件，用等號賦值給另一個物件並修改其內容，然後檢查原物件的值是否變動。對 value-type 來說是不變動的，而對 reference-type 來說，因為兩個變數實際指向同一塊記憶體，因此內容會變動。然而，這兩種狀況都不會發生在 Rust 上面，因為 compiler 把它擋下來了。</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
	x: i32,
	y: i32,
}

fn main() {
	let mut foo = Point { x: 10, y: 20 };
	let mut bar = foo;
	bar.x = 30;
	println!("foo.x = {}", foo.x); // error: use of moved value `foo.x`
}</code></pre></pre>
<p>Rust struct 具備了 move semantics，使用等號賦值時，資料並不是「複製」，而是「移動」到左值上。右值在移動後，就會成為未初始化的物件，因此 Rust 禁止你對它進行操作。如果你還是有點難以想像，把它理解成 C++11 的 <code>std::move</code> 就可以了：</p>
<pre><code class="language-c++">#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Point {
    int x, y;
};

int main() {
    auto foo = Point { x: 10, y: 20 };
    auto bar = std::move(foo);
    bar.x = 30;
    std::cout &lt;&lt; "foo.x = " &lt;&lt; foo.x &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>這段程式碼可以通過編譯，然而如果你把 <code>Point</code> 換成其它實作 move constructor 的物件 (比如 <code>std::string</code>)，那麼在 <code>std::move(foo)</code> 之後，很可能 <code>foo</code> 會成為內容未初始化的物件，印出其內容會造成 undefined behavior。</p>
<p>為了使用上的方便，Rust 的基本型別，也就是上面那張表格中的所有型別，都具備可複製的特性。因此使用等號賦值時，進行的動作是「複製」，讓你可以繼續操作右值。在後續的文章中，我會更進一步講解 Rust 的 move semantics。</p>
<h2 id="表達式"><a class="header" href="#表達式">表達式</a></h2>
<p>Rust 是 expression-oriented language，大部份的流程控制結構，比如說 <code>if</code>，其實都是可以求值的表達式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = -10;
let abs_x = if x &gt;= 0 {
                x
            } else {
                -x
            };
<span class="boring">}</span></code></pre></pre>
<p>這看起來其實就是 C++ 的 <code>?:</code> 運算子。然而，Rust 可以在表達式中用分號進行區隔，並使用最後一個表達式當作結果，因此可以組合出複雜的表達式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let year = 2016;
let is_leap = {
                  let div_4 = (year % 4 == 0);
                  let div_100 = (year % 100 == 0);
                  let div_400 = (year % 400 == 0);
                  if div_400 || (div_4 &amp;&amp; !div_100) {
                      "is"
                  } else {
                      "is not"
                  }
              };
println!("Year {} {} a leap year.", year, is_leap);
<span class="boring">}</span></code></pre></pre>
<p>分號可以用來分隔表達式，最後一個不帶分號的表達式會成為整個表達式的結果，因此 <code>is_leap</code> 會根據條件判斷，成為 <code>"is"</code> 或 <code>"is not"</code>。注意第七行與第九行都不能加分號，要是最後一個運算式也加上分號，那麼整個運算式的結果會變成 <code>()</code>，也就是那個沒啥用的 0-tuple。而在第 11 行的分號則用來區隔 <code>let</code> 變數宣告與 <code>println!</code>，是一定要加上去的。</p>
<h2 id="函式"><a class="header" href="#函式">函式</a></h2>
<p>前面提到 Rust 使用 <code>fn</code> 來宣告函式，而且回傳型別寫在後面，看起來很像 C++11 裡面新的函式宣告法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(x: f64) -&gt; f64 {
    return x * x;
}
<span class="boring">}</span></code></pre></pre>
<p>函式本體也是可以使用分號區隔的表達式，最後一個不帶分號的表達式會自動成為函式的回傳值，因此上一段檢查閏年的函式可以這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_leap(year: i32) -&gt; bool {
    let div_4 = (year % 4 == 0);
    let div_100 = (year % 100 == 0);
    let div_400 = (year % 400 == 0);

    div_400 || (div_4 &amp;&amp; !div_100)
}
<span class="boring">}</span></code></pre></pre>
<p>你可以用 tuple 輕易讓函式回傳多個值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 對兩個數字做排序
fn reorder(x: i32, y: i32) -&gt; (i32, i32) {
    if x &gt; y {
        (y, x)
    } else {
        (x, y)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>即使函式不回傳任何值，它還是有回傳型別，也就是上面提到那個好像沒啥用的 0-tuple。</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() -&gt; () { // -&gt; () 可省略
    println!("hello world");
}

fn main() { // 若無回傳型別，rust 會自動加上 -&gt; ()
    let result = say_hello(); // 合法，result 的值為 ()
}</code></pre></pre>
<p>這看起來好像沒什麼用，畢竟 0-tuple 什麼事都做不了。然而，當你要寫泛型函式 (generic function) 時，你會跪在電腦前感謝這個設計。</p>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<p>如同 C++ 那般，Rust 也可以利用模版 (template) 來達成泛型程式設計，語法也非常接近 C++：</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; { // 相當於 template&lt;typename T&gt; struct Point
    x: T,
    y: T,
    z: T,
}

fn main() {
    let point_i32 = Point { x: 10, y: 20, z: 30 };
    let point_f64 = Point { x: 2.078, y: 0.454, z: 3.1415 };
}</code></pre></pre>
<p>與 C++ 不同的是，大部份情況下 Rust 都能藉由前後文來自動推導出正確的模版型別，因此上面的例子中並不需要特別加入 <code>&lt;i32&gt;</code> 或是 <code>&lt;f64&gt;</code>，直接用 <code>Point</code> 即可。</p>
<p>泛型非常適合用來實作容器型別，比如 Rust 提供的 <code>Vec</code> 泛型容器，就相當於 C++ 的 <code>std::vector</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array = Vec::new();
    array.push(1);
    array.push(2);

    println!("{}", array[0] + array[1]);
}</code></pre></pre>
<p>同樣地，因為 Rust 從第三行的 <code>push(1)</code> 判斷出 array 的元素型別為 <code>i32</code>，因此在第二行就不需要寫明 <code>Vec&lt;i32&gt;::new()</code>，直接寫 <code>Vec::new()</code> 即可。</p>
<p>除了泛型類別，模版也可以用來定義泛型函式，然而與目前 C++ 不同的地方是，在 Rust 中，對泛型型別進行操作前，必需為它標上 constraint：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum&lt;T: Add&gt;(a: T, b: T) -&gt; T::Output {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>這邊 <code>Add</code> 意指 <code>T</code> 必需是可以使用加號相加的型別，包括整數及浮點數都包括在內。由於相加後輸出型別不一定仍然為 T，因此這個函式的回傳型別是 <code>T::Output</code>。Rust 也支援運算子覆載 (operator overloading)，只要你的自訂型別定義了加號操作以及輸出型別，那麼這個自訂型別也可以直接傳入 <code>sum</code> 進行運算。</p>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>這篇文章中，我把重點放在 Rust 最核心的語言功能上，甚至省略了陣列與字串處理，因為講解這部份就無可避免會提到 borrow checker。在後續幾篇文章中，我將會繼續深入解釋 move semantics 與 borrow checker。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust/pyo3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rust/可視化Rust各資料結構的記憶體佈局.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust/pyo3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rust/可視化Rust各資料結構的記憶體佈局.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
