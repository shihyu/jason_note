<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 筆記 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-筆記"><a class="header" href="#rust-筆記">Rust 筆記</a></h1>
<ul>
<li>as_ptr()</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!("{}", std::any::type_name::&lt;T&gt;());
}

fn main() {
    let free_coloring_book = vec![
        "mercury", "venus", "earth", "mars", "jupiter", "saturn", "uranus", "neptune",
    ];
    // 1. free_coloring_book堆上數據的地址
    println!("address: {:p}", free_coloring_book.as_ptr());

    // 2. free_coloring_book棧上的地址
    let a = &amp;free_coloring_book;
    println!("address: {:p}", a);

    let mut friends_coloring_book = free_coloring_book;

    // 3. friends_coloring_book堆上數據的地址，和1一樣
    println!("address: {:p}", friends_coloring_book.as_ptr());

    // 4. friends_coloring_book棧上的地址
    let b = &amp;friends_coloring_book;
    println!("address: {:p}", b);
}</code></pre></pre>
<ul>
<li>Rc / Box 用法</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

struct Aa {
    id: i32,
}

impl Drop for Aa {
    fn drop(&amp;mut self) {
        println!("Aa Drop, id: {}", self.id);
    }
}

fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!("{}", std::any::type_name::&lt;T&gt;());
}

fn test_1() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Rc::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
    //drop(a1);
    println!("xxxxxxx");
}

fn test_2() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Box::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
}

fn main() {
    test_1();
    test_2();
}</code></pre></pre>
<ul>
<li>data  bss text heap stack</li>
</ul>
<pre><pre class="playground"><code class="language-rust">/// .Text段存放的是程序中的可執行代碼
/// .Data段保存的是已經初始化了的全局變量和靜態變量
/// .ROData（ReadOnlyData）段存放程序中的常量值，如字符串常量
/// .BSS段存放的是未初始化的全局變量和靜態變量，程序執行前會先進行一遍初始化
const G_ARRAY: [i32; 5] = [10; 5];
const G_X: i32 = 100;
static G_VAR: i32 = 1000;

fn test06_heap_or_stack() {
    let s: &amp;str = "test list";
    //字符串字面量，位於ROData段
    println!("&amp;str: {:p}", s); //&amp;str: 0x7ff77e4c6b88
    println!("{:p}", &amp;G_ARRAY); //data段:0x7ff6c5fc6bb8
    println!("{:p}", &amp;G_X); //data段:0x7ff6c5fc64f0
    println!("{:p}", &amp;G_VAR); //data段:0x7ff77e4c6200
    println!("{}", "-".repeat(10));

    // 位於堆
    let bi = Box::new(30);
    println!("{:p}", bi); //堆:0x19f6c6585e0
                          // 將字符串字面量從內存中的代碼區（ROData段）復制一份到堆
                          // 棧上分配的變量s1指向堆內存
    let mut s1: String = String::from("Hello");
    // 可以通過std::mem::transmute將
    // 從24字節的長度的3個uszie讀出來
    let pstr: [usize; 3] = unsafe { std::mem::transmute(s1) };
    // pstr[0]是一個堆內存地址
    println!("ptr: 0x{:x}", pstr[0]); //ptr: 0x19f6c658750

    println!("{}", "-".repeat(10));
    // 位於棧
    let nums1 = [1, 2, 3, 4, 5, 6];
    let mut list: Vec&lt;i32&gt; = vec![20, 30, 40];
    let t = 100;
    println!("{:p}", &amp;t); //棧0x116aeff104
    println!("{:p}", &amp;nums1); //棧0x116aeff0d0
    println!("{:p}", &amp;list); //棧0x116aeff0e8
                             // 從ROData區復制了一份字符串字面量放到堆上，
                             // 然後用棧上分配的s指向堆
    let s: String = "Hello".to_owned();
    println!("{:p}", &amp;s); //0x116aeff1f8
    let s: String = String::from("Hello");
    println!("{:p}", &amp;s); //0x116aeff260
    let s: String = "Hello".into();
    println!("{:p}", &amp;s); //0x116aeff2c8
}

fn main() {
    test06_heap_or_stack();
}</code></pre></pre>
<h2 id="ownership有個特性是個大坑"><a class="header" href="#ownership有個特性是個大坑">ownership有個特性是個大坑</a></h2>
<pre><pre class="playground"><code class="language-rust">// ownership有個特性，感覺是個大坑，把不可變資料的ownership move到可變資料，那麼就改值了。這個設定不安全。
fn main() {
    let immutable = Box::new(5u32);
    println!("{:}", immutable);

    let mut mutable_box = immutable;
    println!("{:}", mutable_box);
    *mutable_box = 4;
    println!("{:}", mutable_box);
} </code></pre></pre>
<h2 id="rust中mut--mut的區別"><a class="header" href="#rust中mut--mut的區別">Rust中mut, &amp;, &amp;mut的區別</a></h2>
<p>資源：記憶體區塊。不同的記憶體區塊位置和大小就是不同的資源。</p>
<h3 id="str"><a class="header" href="#str">str</a></h3>
<p>let a = "xxx".to_string();　　
含義：a繫結到字串資源A上，擁有資源A的所有權</p>
<p>let mut a = "xxx".to_string();　
含義：a繫結到字串資源A上，擁有資源A的所有權，同時a還可繫結到新的資源上面去（更新繫結的能力，但新舊資源類型要同）；</p>
<h3 id="value"><a class="header" href="#value">value</a></h3>
<p>let b = a;
含義：a繫結的資源A轉移給b，b擁有這個資源A</p>
<p>let b = &amp;a;　　
含義：a繫結的資源A借給b使用，b只有資源A的讀權限</p>
<p>let b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限</p>
<p>let mut b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限。同時，b可繫結到新的資源上面去（更新繫結的能力）</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>fn do(c: String) {}　　
含義：傳參的時候，實參d繫結的資源D的所有權轉移給c</p>
<p>fn do(c: &amp;String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D唯讀</p>
<p>fn do(c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫</p>
<p>fn do(mut c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫。同時，c可繫結到新的資源上面去（更新繫結的能力）</p>
<p>函數參數裡面，冒號左邊的部分，mut c，這個mut是對函數體內部有效；冒號右邊的部分，&amp;mut String，這個 &amp;mut 是針對外部實參傳入時的形式化（類型）說明。</p>
<p>下面的例子輸出是什麼：</p>
<pre><pre class="playground"><code class="language-rust">fn concat_literal(s: &amp;mut String) {     
    s.extend("world!".chars());         
}                                       
                                          
fn main() {                             
    let mut s = "hello, ".to_owned();   
    concat_literal(&amp;mut s);             
    println!("{}", s);                  
}  </code></pre></pre>
<h2 id="打印-borrow-位址"><a class="header" href="#打印-borrow-位址">打印 borrow 位址</a></h2>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!("{}", std::any::type_name::&lt;T&gt;());
}

fn test(a: &amp;mut i32) {
    println!("{:p}", *&amp;a); // 打印 reference address 
    println!("{:p}", a); // 打印 reference address 
    println!("{:}", a);
    *a = 100;
    println!("{:p}", &amp;a);
}

fn main() {
    let mut a = 10;
    print_type_of(a);
    let b = &amp;mut a;
    *b = 50;
    print_type_of(b);
    println!("{:p}", &amp;a);
    test(&amp;mut a);
    println!("{:}", a);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!("{}", std::any::type_name::&lt;T&gt;());
}

fn main() {
    let a: i32 = 5;
    print_type_of(a);
    println!("addr：{:p}", &amp;a);
    let b = &amp;a;
    print_type_of(b);
    println!("addr：{:p}", b);
    println!("value ：{:}", b);
    //&amp;a先轉成raw指針，然後再把指針轉成usize，這個可以print的
    let addr = &amp;a as *const i32 as usize;
    println!("addr：0x{:X}", addr);

    //為了驗證剛才的地址是不是正確的，我們修改這個指針指向的數據
    //pa就是addr對應的raw指針
    let pa = addr as *mut i32;
    //解引用，*pa其實就是&amp;mut a了，給他賦值100
    unsafe { *pa = 100 };

    //打印a，可以看到a已經變成100了
    println!("value:{}", a);
}</code></pre></pre>
<h2 id="self-和-self-的區別"><a class="header" href="#self-和-self-的區別">&amp;self 和 self 的區別</a></h2>
<p>在 Rust 的方法中，第一個參數為 &amp; self，那麼如果改成 self（不是大寫的 Self）行不行，兩者有什麼區別。
&amp;self，表示向函數傳遞的是一個引用，不會發生對像所有權的轉移；
self，表示向函數傳遞的是一個對象，會發生所有權的轉移，對象的所有權會傳遞到函數中。
原文作者：linghuyichong
轉自鏈接：https://learnku.com/articles/39050</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyType {
    name: String,
}

impl MyType {
    fn do_something(self, age: u32) {
        //等價於 fn do_something(self: Self, age: u32) {
        //等價於 fn do_something(self: MyType, age: u32) {
        println!("name = {}", self.name);
        println!("age = {}", age);
    }

    fn do_something2(&amp;self, age: u32) {
        println!("name = {}", self.name);
        println!("age = {}", age);
    }
}

fn main() {
    let my_type = MyType {
        name: "linghuyichong".to_string(),
    };
    //使用self
    my_type.do_something(18); //等價於MyType::do_something(my_type, 18);
                              //println!("my_type: {:#?}", my_type);    //在do_something中，傳入的是對象，而不是引用，因此my_type的所有權就轉移到函數中了，因此不能再使用

    //使用&amp;self
    let my_type2 = MyType {
        name: "linghuyichong".to_string(),
    };
    my_type2.do_something2(18);
    my_type2.do_something2(18);
    println!("my_type2: {:#?}", my_type2); //在do_something中，傳入是引用，函數並沒有獲取my_type2的所有權，因此此處可以使用
    println!("Hello, world!");
}</code></pre></pre>
<ul>
<li>
<p>模擬C++ 建構/解構</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::process;

struct MyStruct {
    value: i32,
}

impl MyStruct {
    fn new(value: i32) -&gt; MyStruct {
        println!("MyStruct with value {} created by pid {} tid {:?}", value, process::id(), thread::current().id());
        MyStruct { value: value }
    }
}

impl Drop for MyStruct {
    fn drop(&amp;mut self) {
        println!("MyStruct with value {} dropped by pid {} tid {:?}", self.value, process::id(), thread::current().id());
    }
}

fn main() {
    let my_struct = MyStruct::new(42);
}</code></pre></pre>
</li>
<li>
<p>trait</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
/*
 * 這個程式碼定義了一個名叫 Movable 的 trait，這個 trait 定義了一個 movement 方法。
 * Human 和 Rabbit 是兩個結構體，分別實現了 Movable trait。在每個實現中，
 * 都定義了一個 movement 方法，實現了結構體如何移動的行為。
 * 在 main 函數中，我們創建了一個 Human 和一個 Rabbit 的實例，存儲在 human 和 rabbit 變數中。
 * 然後，我們依次對這兩個變數分別調用了 movement 方法，分別輸出了 "Human walk" 和 "Rabbit jump"。
 * 這個程式碼展示瞭如何使用 Rust 的 trait 和結構體來實現多態行為。
 * 使用 trait，可以將類似的操作組織成一個介面，並將其實現為多個不同的類型。這使得代碼更加模組化，可重用性更高。
 * */
trait Movable {
    fn movement(&amp;self);
}

struct Human;

impl Movable for Human {
    fn movement(&amp;self) {
        println!("Human walk");
    }
}

struct Rabbit;

impl Movable for Rabbit {
    fn movement(&amp;self) {
        println!("Rabbit jump");
    }
}

fn main() {
    let human = Human;
    let rabbit = Rabbit;

    human.movement();
    rabbit.movement();
}</code></pre></pre>
<ul>
<li>Rust 中有三種方式來引用這個結構實例：<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>。下面舉例說明這三種實例引用方式的不同之處。</li>
</ul>
<p>self<code>和</code>&amp;mut self` 都用於引用結構體實例，但有著不同的含義。</p>
<p><code>self</code> 表示方法使用結構體實例的所有權；而 <code>&amp;mut self</code> 則表示方法使用結構體實例的可變引用。</p>
<p>具體來說，當使用 <code>self</code> 定義方法時，這個方法會接受結構體實例的所有權，即將結構體實例移動到方法中，可以在方法內部進行修改或銷毀。當方法執行完畢後，結構體實例的控制權會返回到調用方。</p>
<p>而使用 <code>&amp;mut self</code> 定義方法時，這個方法會接受結構體實例的可變引用。當方法被調用時，結構體實例依然保持存在，並且可以在方法內部進行修改。當方法執行完畢後，結構體實例保持存在並且可以繼續使用。</p>
<p>總體來說，使用 <code>self</code> 比使用 <code>&amp;mut self</code> 更加靈活，但也更加危險，因為它轉移了結構體實例的所有權。而使用 <code>&amp;mut self</code> 可以讓方法在調用時保留結構體實例，並可以在方法內部進行修改，但需要注意如果結構體同時被多個可讀寫的引用進行修改，就會產生賽博會同步錯誤。因此，方法的實現必須小心處理對結構體實例的存儲和修改依賴關係。</p>
<p>首先，讓我們定義一個結構 <code>Person</code>，其中包含了一個名稱屬性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>接下來，我們為這個結構定義三種方法，分別使用 <code>self</code>、<code>&amp;self</code> 和 <code>&amp;mut self</code> 來引用實例。</p>
<ol>
<li>使用 <code>self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn set_name(self, new_name: String) -&gt; Person {
        Person { name: new_name }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在這個方法中，<code>self</code> 為結構體的值，透過使用 <code>set_name</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱，然後返回一個新的 <code>Person</code> 結構體，原來的實例沒有被修改。這種方式可以原地修改實例，因為它轉移了所有權。</p>
<ol>
<li>使用 <code>&amp;self</code> 引用實例，但不修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn greet(&amp;self) {
        println!("Hi, my name is {}", self.name);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在這個方法中，<code>&amp;self</code> 為結構體的借用引用，它將 <code>Person</code> 結構體的所有權借用給了 <code>greet</code> 方法，但不允許 <code>greet</code> 方法修改該實例的任何屬性。因此，這種方式適用於只需要讀取結構屬性的方法。</p>
<ol>
<li>使用 <code>&amp;mut self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn rename(&amp;mut self, new_name: String) {
        self.name = new_name;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在這個方法中，<code>&amp;mut self</code> 為結構體的可變引用，透過使用 <code>rename</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱。這種方式允許修改結構屬性，因為它使用了結構體的可變引用。</p>
<p>總結來說，這三種方式分別提供了不同的實例引用方法。使用 <code>self</code> 從原始的實例移動所有權，這在歸還新創建的 <code>Person</code> 結構體時特別有用。使用 <code>&amp;self</code> 或 <code>&amp;mut self</code> 以引用的方式讀取和修改結構屬性。使用 <code>&amp;self</code>可以保證實例是不可變的，而使用 <code>&amp;mut self</code> 允許修改實例的內容。</p>
<ul>
<li>
<p>在 Rust 中，<code>self</code> 和 <code>Self</code> 都表示結構體或枚舉的類型，但有著不同的含義。</p>
<p>self<code>在方法定義中是用來引用實例自身，而</code>Self<code>則用來表示結構體或枚舉本身的類型。下面是一個示例，說明瞭</code>Self<code>和</code>self` 的使用：</p>
<p>在這個示例中，我們定義了一個名為 <code>Rectangle</code> 的結構體，並為其實現了三個方法：<code>new</code>、<code>area</code> 和 <code>same</code>。</p>
<p>在 <code>new</code> 方法中，我們使用了 <code>Self</code> 來表示結構體的類型，並使用了 <code>self</code> 變量，它是一個引用結構體實例的不可變引用。這個方法創建了一個新的 <code>Rectangle</code> 結構體實例，並將其返回。</p>
<p>在 <code>area</code> 方法中，我們使用了 <code>&amp;self</code> 引用，這個方法只是計算結構體實例的面積，但不修改它。</p>
<p>在 <code>same</code> 方法中，我們使用了 <code>&amp;Self</code> 引用，這個方法不需要引用結構體實例本身，而是可以直接使用 <code>Rectangle</code> 類型來比較兩個實例是否具有相同的寬度和高度。</p>
<p>在 <code>main</code> 函數中，我們創建了一個 <code>Rectangle</code> 結構體實例，調用了 <code>area</code> 方法來計算實例的面積，並調用了 <code>same</code> 方法來檢查實例是否是一個正方形。</p>
<p>總結來說，<code>self</code> 主要用於方法中引用結構體實例本身，而 <code>Self</code> 則用作表示結構體或枚舉的類型。</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn new(width: u32, height: u32) -&gt; Self {
        Self { width, height }
    }

    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn same(rect: &amp;Self) -&gt; bool {
        rect.width == rect.height
    }
}

fn main() {
    let rectangle = Rectangle::new(10, 5);
    println!(
        "The area of the rectangle is {} square pixels.",
        rectangle.area()
    );
    println!("Is the rectangle a square? {}", Rectangle::same(&amp;rectangle));
}
</code></pre></pre>
<h2 id="handle-trait-的方式不同"><a class="header" href="#handle-trait-的方式不同"><code>Handle</code> trait 的方式不同</a></h2>
<p>第一個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個實例方法 <code>handle()</code>，它接受一個 <code>&amp;self</code> 參數，表示該方法是與 <code>Handler</code> 結構體實例相關聯的。在實現 <code>Handle</code> trait 時，我們對每個需要處理的類型都分別實現了 <code>handle()</code> 方法，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們創建了 <code>Handler</code> 結構體對象 <code>handler</code>，然後調用 <code>handler.handle(10)</code> 和 <code>handler.handle(10.5)</code> 方法來處理輸入的不同類型數據。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!("This is i32: {}", input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!("This is f64: {}", input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}</code></pre></pre>
<p>第二個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個關聯函數 <code>handle()</code>，它不需要 <code>&amp;self</code> 參數，表示該函數與 <code>Handler</code> 結構體實例無關。在實現 <code>Handle</code> trait 時，我們同樣對每個需要處理的類型都分別實現了 <code>handle()</code> 關聯函數，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們不創建任何 <code>Handler</code> 的對象，而是直接對 <code>Handler</code> 結構體類型調用 <code>Handler::handle(10)</code> 和 <code>Handler::handle(10.5)</code>方法來處理輸入的不同類型數據。</p>
<p>因此，這兩段代碼的區別在於實現 <code>Handle</code> trait 的方式不同。第一個代碼示例中實現了一個實例方法 <code>handle()</code>，第二個代碼示例中實現了一個關聯函數 <code>handle()</code>。這兩個方法/函數的調用方式也不同。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!("This is i32: {}", input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!("This is f64: {}", input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}</code></pre></pre>
</li>
</ul>
<h3 id="enum-用法"><a class="header" href="#enum-用法">enum 用法</a></h3>
<pre><pre class="playground"><code class="language-rust">#[allow(clippy::all)]
enum WebsocketAPI {
    Default,
    MultiStream,
    Custom(String),
}

fn handle_websocket_api(api: WebsocketAPI) {
    match api {
        WebsocketAPI::Default =&gt; {
            println!("Handling default WebSocket API");
            // Your code for the default case
        }
        WebsocketAPI::MultiStream =&gt; {
            println!("Handling multi-stream WebSocket API");
            // Your code for the multi-stream case
        }
        WebsocketAPI::Custom(custom_api) =&gt; {
            println!("Handling custom WebSocket API: {}", custom_api);
            // Your code for the custom case, using the custom API string
        }
    }
}

fn main() {
    let default_api = WebsocketAPI::Default;
    let multi_stream_api = WebsocketAPI::MultiStream;
    let custom_api = WebsocketAPI::Custom(String::from("wss://custom.api"));

    handle_websocket_api(default_api);
    handle_websocket_api(multi_stream_api);
    handle_websocket_api(custom_api);
}
</code></pre></pre>
<h3 id="hashmap-用法"><a class="header" href="#hashmap-用法">HashMap 用法：</a></h3>
<p><code>HashMap</code>是一種鍵-值對的集合，其中每個鍵必須是唯一的。它是Rust標準庫的一部分，用於實現字典或關聯數組。</p>
<p>這是一個使用<code>HashMap</code>的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    // Creating a new HashMap
    let mut my_map = HashMap::new();

    // Inserting key-value pairs
    my_map.insert("key1", "value1");
    my_map.insert("key2", "value2");
    my_map.insert("key3", "value3");

    // Accessing values using keys
    if let Some(value) = my_map.get("key2") {
        println!("Value for key2: {}", value);
    }

    // Iterating over key-value pairs
    for (key, value) in &amp;my_map {
        println!("Key: {}, Value: {}", key, value);
    }
}</code></pre></pre>
<h3 id="迭代器的-map-方法"><a class="header" href="#迭代器的-map-方法">迭代器的 <code>map</code> 方法：</a></h3>
<p>在Rust中，迭代器具有<code>map</code>方法，它通過將函數應用於每個元素來轉換迭代器中的每個項目。這裡是一個簡單的例子：</p>
<p>在此示例中，使用<code>map</code>方法創建了一個新的迭代器，其中每個元素都加倍。然後使用<code>collect</code>方法將迭代器轉換迴向量。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // Using map to double each number
    let doubled_numbers: Vec&lt;_&gt; = numbers.into_iter().map(|x| x * 2).collect();

    println!("Original numbers: {:?}", numbers);
    println!("Doubled numbers: {:?}", doubled_numbers);
}</code></pre></pre>
<h3 id="閉包closures"><a class="header" href="#閉包closures">閉包（closures）</a></h3>
<p>是一種特殊的函數類型，它可以捕獲其環境中的變數。閉包具有以下幾個用法和優勢：</p>
<h3 id="簡潔性和靈活性"><a class="header" href="#簡潔性和靈活性">簡潔性和靈活性：</a></h3>
<p>閉包允許你編寫更為簡潔、直觀的程式碼。相比於定義一個完整的函數，閉包可以直接在需要時聲明和使用，使程式碼更具靈活性。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用閉包
let add = |x, y| x + y;
println!("Sum: {}", add(3, 4));

// 相同的功能使用函數
fn add_function(x: i32, y: i32) -&gt; i32 {
    x + y
}
println!("Sum: {}", add_function(3, 4));
<span class="boring">}</span></code></pre></pre>
<h3 id="捕獲環境變數"><a class="header" href="#捕獲環境變數">捕獲環境變數：</a></h3>
<p>閉包可以捕獲其所在範疇中的變數，可以是引用（<code>&amp;</code>）或移動（<code>move</code>）。這允許你在閉包內部使用外部變數，而不需要顯式傳遞參數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let closure = || println!("x: {}", x);
closure();
<span class="boring">}</span></code></pre></pre>
<h3 id="所有權轉移"><a class="header" href="#所有權轉移"><strong>所有權轉移：</strong></a></h3>
<p>使用 <code>move</code> 關鍵字，閉包可以將其環境中的所有權轉移到閉包內，從而實現所有權的轉移。這對於將資料傳遞給執行緒或其他閉包非常有用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = vec![1, 2, 3];
let closure = move || {
    // data 所有權已轉移到閉包
    println!("{:?}", data);
};
closure();
// 下面的行將會引發編譯錯誤，因為 data 所有權已轉移
// println!("{:?}", data);
<span class="boring">}</span></code></pre></pre>
<h3 id="函數式程式設計"><a class="header" href="#函數式程式設計"><strong>函數式程式設計：</strong></a></h3>
<p>閉包使Rust更加適合函數式程式設計風格。你可以將閉包傳遞給其他函數，或者將其作為迭代器的參數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squared: Vec&lt;_&gt; = numbers.into_iter().map(|x| x * x).collect();
println!("{:?}", squared);
<span class="boring">}</span></code></pre></pre>
<h3 id="泛型和trait的使用"><a class="header" href="#泛型和trait的使用"><strong>泛型和trait的使用：</strong></a></h3>
<p>閉包可以與泛型和trait一起使用，使其更加通用和靈活。你可以定義一個接受閉包作為參數的泛型函數，以處理不同類型的操作。</p>
<pre><pre class="playground"><code class="language-rust">fn perform_operation&lt;T, U, F&gt;(value: T, operation: F) -&gt; U
where
    F: Fn(T) -&gt; U,
{
    operation(value)
}

fn main() {
    // 對整數進行操作
    let result_int = perform_operation(5, |x| x * 2);
    println!("Result for integer: {}", result_int);

    // 對浮點數進行操作
    let result_float = perform_operation(3.5, |x| x * 2.0);
    println!("Result for float: {}", result_float);

    // 對字串進行操作
    let result_string = perform_operation("Hello", |x| format!("{}!", x));
    println!("Result for string: {}", result_string);
}</code></pre></pre>
<ol>
<li><code>fn perform_operation&lt;T, U, F&gt;(value: T, operation: F) -&gt; U</code>: 這是一個泛型函數的聲明。它有三個泛型參數，分別為 <code>T</code>、<code>U</code> 和 <code>F</code>。這表示這個函數可以接受不同類型的值（<code>T</code>）和返回不同類型的結果（<code>U</code>），同時還接受一個泛型的函數或閉包（<code>F</code>）。</li>
<li><code>where F: Fn(T) -&gt; U</code>: 這是一個 trait bound（特徵約束），它規定了泛型 <code>F</code> 必須實現 <code>Fn(T) -&gt; U</code> 這個特徵。這表示 <code>F</code> 必須是一個接受 <code>T</code> 類型參數的函數，並返回 <code>U</code> 類型的值。換句話說，<code>operation</code> 參數必須是一個可以接受 <code>value</code> 類型的函數或閉包。</li>
<li><code>{ operation(value) }</code>: 函數體中的這一行是具體的實現。它調用了傳入的 <code>operation</code> 函數或閉包，並將 <code>value</code> 作為參數傳遞給它。整個函數最終返回 <code>operation</code> 的結果，這個結果的類型是 <code>U</code>。</li>
</ol>
<p>這段程式碼的目的是創建一個通用的函數，可以將一個值和一個函數或閉包傳遞給它，並返回該函數或閉包對該值的操作結果。通過使用泛型，這個函數可以處理不同類型的輸入和輸出。</p>
<p><code>T</code>、<code>U</code> 和 <code>F</code> 只是慣例上常用的泛型參數名稱，實際上你可以使用任何有效的識別符號作為泛型參數名稱。這些字母通常代表不同的概念：</p>
<ul>
<li><code>T</code>：通常表示 "Type"，表示泛型的類型參數。</li>
<li><code>U</code>：通常用於表示第二個泛型類型參數。</li>
<li><code>F</code>：通常表示 "Function"，用於表示接受或返回函數的泛型參數。</li>
</ul>
<p>這些僅僅是慣例，而不是強制的規則。當你閱讀其他人的代碼或寫自己的代碼時，習慣上使用這樣的字母可以讓代碼更容易閱讀和理解。</p>
<pre><pre class="playground"><code class="language-rust">fn perform_operation&lt;Input, Output, Func&gt;(value: Input, operation: Func) -&gt; Output
where
    Func: Fn(Input) -&gt; Output,
{
    operation(value)
}

fn main() {
    // 對整數進行操作
    let result_int = perform_operation(5, |x| x * 2);
    println!("Result for integer: {}", result_int);

    // 對浮點數進行操作
    let result_float = perform_operation(3.5, |x| x * 2.0);
    println!("Result for float: {}", result_float);

    // 對字串進行操作
    let result_string = perform_operation("Hello", |x| format!("{}!", x));
    println!("Result for string: {}", result_string);
}</code></pre></pre>
<h2 id="trait"><a class="header" href="#trait">trait</a></h2>
<p>trait是一種定義共享行為的機制，它類似於其他語言中的接口（interface）。trait可以用於定義方法簽名，然後類型實現這些trait，以提供對這些方法的具體實現。</p>
<p>以下是一個簡單的示例，演示瞭如何定義trait和實現它：</p>
<pre><pre class="playground"><code class="language-rust">// 定義一個名為 Printable 的 trait
trait Printable {
    // 方法簽名，表示實現這個 trait 的類型需要實現 print 方法
    fn print(&amp;self);
}

// 實現 Printable trait 的結構體
struct Dog {
    name: String,
}

// 實現 Printable trait 的結構體
struct Cat {
    name: String,
}

// 實現 Printable trait for Dog
impl Printable for Dog {
    // 實現 print 方法
    fn print(&amp;self) {
        println!("Dog named {}", self.name);
    }
}

// 實現 Printable trait for Cat
impl Printable for Cat {
    // 實現 print 方法
    fn print(&amp;self) {
        println!("Cat named {}", self.name);
    }
}

fn main() {
    // 創建一個 Dog 實例
    let dog = Dog { name: String::from("Buddy") };
    // 呼叫 Printable trait 中的 print 方法
    dog.print();

    // 創建一個 Cat 實例
    let cat = Cat { name: String::from("Whiskers") };
    // 呼叫 Printable trait 中的 print 方法
    cat.print();
}</code></pre></pre>
<ul>
<li>我們定義了一個名為 <code>Printable</code> 的 trait，它包含一個方法 <code>print</code>。</li>
<li>我們創建了兩個結構體 <code>Dog</code> 和 <code>Cat</code>。</li>
<li>我們為每個結構體實現了 <code>Printable</code> trait，提供了對 <code>print</code> 方法的具體實現。</li>
<li>在 <code>main</code> 函數中，我們創建了一個 <code>Dog</code> 實例和一個 <code>Cat</code> 實例，然後分別呼叫了它們的 <code>print</code> 方法。</li>
</ul>
<p>這就是trait的基本用法。trait還可以用於實現泛型，以及在函數中指定trait約束，這樣可以在不同類型上使用相同的trait方法。</p>
<h2 id="trait-和泛型是-rust-中的兩個不同的概念但它們經常一起使用"><a class="header" href="#trait-和泛型是-rust-中的兩個不同的概念但它們經常一起使用">trait 和泛型是 Rust 中的兩個不同的概念，但它們經常一起使用。</a></h2>
<p>泛型（Generics）是一種通用編程概念，它允許編寫可以處理多種不同類型的代碼而不失靈活性和安全性的方式。通過使用泛型，可以在函數、結構、列舉和方法等多種場景中創建通用的代碼。</p>
<p><strong>範例：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug; // 引入 Debug trait

fn print&lt;T: Debug&gt;(value: T) {
    println!("Value: {:#?}", value);
}

fn main() {
    print(5);
    print("Hello");
}</code></pre></pre>
<p>這裡的 <code>print</code> 函數使用泛型，可以接受任何類型的參數。</p>
<h3 id="trait-1"><a class="header" href="#trait-1">Trait：</a></h3>
<p>Trait 定義了一組可以由類型實現的方法的集合，這樣就可以共享某種行為。Trait 提供了一種方式來描述類型之間的共同特徵。</p>
<p><strong>範例：</strong></p>
<pre><pre class="playground"><code class="language-rust">trait Printable {
    fn print(&amp;self);
}

struct Dog {
    name: String,
}

impl Printable for Dog {
    fn print(&amp;self) {
        println!("Dog named {}", self.name);
    }
}

struct Cat {
    name: String,
}

impl Printable for Cat {
    fn print(&amp;self) {
        println!("Cat named {}", self.name);
    }
}

fn main() {
    let dog = Dog {
        name: String::from("Buddy"),
    };
    dog.print();

    let cat = Cat {
        name: String::from("Whiskers"),
    };
    cat.print();
}</code></pre></pre>
<p>在這裡，<code>Printable</code> 是一個 trait，<code>Dog</code> 和 <code>Cat</code> 結構體實現了這個 trait，提供了對 <code>print</code> 方法的具體實現。</p>
<h3 id="結論"><a class="header" href="#結論">結論：</a></h3>
<p>總體而言，泛型是一種更通用的編程概念，用於創建可以處理多種類型的代碼，而 trait 則用於描述類型之間的共同特徵，讓不同的類型可以共享某種行為。在實踐中，泛型和 trait 經常一起使用，使得代碼更加靈活和可擴展。</p>
<h2 id="self-與-self-差異"><a class="header" href="#self-與-self-差異">Self 與 self 差異</a></h2>
<p><code>Self</code> 是一個特殊的關鍵字，通常用於表示實現 trait 的類型。它表示實際類型，即實現 trait 的類型本身。使用 <code>Self</code> 的時機主要包括：</p>
<ol>
<li>
<p><strong>返回類型聲明：</strong> 當你在 trait 的方法中聲明返回類型時，可以使用 <code>Self</code> 來表示實現該 trait 的具體類型。這允許實現方在方法中返回其實際類型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ExampleTrait {
    fn example_method(&amp;self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>關聯類型：</strong> <code>Self</code> 也可用於關聯類型，這是一種在 trait 中聲明類型並在實現中具體化的方式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ExampleTrait {
    type Item;
    
    fn get_item(&amp;self) -&gt; Self::Item;
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<p>總體而言，<code>Self</code> 用於在 trait 中表示實現該 trait 的類型，並在需要指代實際類型的地方使用。</p>
<p><code>type</code> 是一個關鍵字，用於聲明與trait關聯的關聯類型。關聯類型允許trait中使用的類型在實現trait時具體化。在你的例子中，<code>type Item;</code> 就是在trait <code>ExampleTrait</code> 中聲明瞭一個關聯類型 <code>Item</code>。</p>
<pre><pre class="playground"><code class="language-rust">trait ExampleTrait {
    type Item;  // 關聯類型聲明
    
    fn create_instance() -&gt; Self;  // 使用Self作為返回類型
    fn get_item(&amp;self) -&gt; Self::Item;  // 使用Self::Item作為返回類型
}

struct ExampleType;

impl ExampleTrait for ExampleType {
    type Item = i32;  // 具體化關聯類型
    
    fn create_instance() -&gt; Self {
        ExampleType  // 返回實現trait的具體類型
    }

    fn get_item(&amp;self) -&gt; Self::Item {
        42  // 在實現中返回關聯類型的實例
    }
}

fn main() {
    let instance = ExampleType::create_instance();
    let item = instance.get_item();
    
    println!("Item: {}", item);
}</code></pre></pre>
<h2 id="python-繼承-用-rust-實作"><a class="header" href="#python-繼承-用-rust-實作">python 繼承 用 Rust 實作</a></h2>
<pre><code class="language-python"># 定義父類
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass  # 父類中的方法，子類將覆蓋它

# 定義子類，繼承自 Animal
class Dog(Animal):
    def speak(self):
        return f"{self.name} says Woof!"

# 定義另一個子類，也繼承自 Animal
class Cat(Animal):
    def speak(self):
        return f"{self.name} says Meow!"

# 創建實例並調用方法
dog_instance = Dog("Buddy")
cat_instance = Cat("Whiskers")

print(dog_instance.speak())  # 輸出: Buddy says Woof!
print(cat_instance.speak())  # 輸出: Whiskers says Meow!
</code></pre>
<pre><pre class="playground"><code class="language-rust">// 定義 trait
trait Animal {
    fn new(name: &amp;str) -&gt; Self;
    fn speak(&amp;self) -&gt; String;
}

// 定義結構體實現 trait
struct Dog {
    name: String,
}

impl Animal for Dog {
    fn new(name: &amp;str) -&gt; Self {
        Dog {
            name: name.to_string(),
        }
    }

    fn speak(&amp;self) -&gt; String {
        format!("{} says Woof!", self.name)
    }
}

// 定義另一個結構體實現 trait
struct Cat {
    name: String,
}

impl Animal for Cat {
    fn new(name: &amp;str) -&gt; Self {
        Cat {
            name: name.to_string(),
        }
    }

    fn speak(&amp;self) -&gt; String {
        format!("{} says Meow!", self.name)
    }
}

fn main() {
    // 創建實例並調用方法
    let dog_instance = Dog::new("Buddy");
    let cat_instance = Cat::new("Whiskers");

    println!("{}", dog_instance.speak()); // 輸出: Buddy says Woof!
    println!("{}", cat_instance.speak()); // 輸出: Whiskers says Meow!
}</code></pre></pre>
<h3 id="enum-跟-impl"><a class="header" href="#enum-跟-impl">enum 跟 impl</a></h3>
<p>在這個例子中，我們使用了列舉 <code>Animal</code> 來表示不同類型的動物（狗和貓）。每個動物類型都有一個 <code>name</code> 欄位。我們通過在列舉上實現方法來模擬建構函式（<code>new_dog</code> 和 <code>new_cat</code>）和 <code>speak</code> 方法。在 <code>main</code> 函數中，我們建立了兩個不同類型的動物實例並呼叫了它們的 <code>speak</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">// 定義一個枚舉，表示不同類型的動物
enum Animal {
    Dog { name: String },
    Cat { name: String },
}

// 枚舉上的方法
impl Animal {
    // 構造函數
    fn new_dog(name: &amp;str) -&gt; Self {
        Animal::Dog { name: name.to_string() }
    }

    fn new_cat(name: &amp;str) -&gt; Self {
        Animal::Cat { name: name.to_string() }
    }

    // 說話的方法
    fn speak(&amp;self) -&gt; String {
        match self {
            Animal::Dog { name } =&gt; format!("{} says Woof!", name),
            Animal::Cat { name } =&gt; format!("{} says Meow!", name),
        }
    }
}

fn main() {
    // 創建實例並調用方法
    let dog_instance = Animal::new_dog("Buddy");
    let cat_instance = Animal::new_cat("Whiskers");

    println!("{}", dog_instance.speak()); // 輸出: Buddy says Woof!
    println!("{}", cat_instance.speak()); // 輸出: Whiskers says Meow!
}</code></pre></pre>
<h3 id="struct-跟-impl"><a class="header" href="#struct-跟-impl">struct 跟 impl</a></h3>
<p>在這個例子中，我們使用了 <code>struct</code> 定義了 <code>Animal</code> 結構體，其中包含了 <code>kind</code> 表示動物的種類（"Dog" 或 "Cat"），以及 <code>name</code> 表示動物的名字。建構函式 <code>new</code> 用於建立新的 <code>Animal</code> 實例，而 <code>speak</code> 方法根據動物的種類輸出不同的聲音。在 <code>main</code> 函數中，我們建立了兩個不同類型的動物實例並呼叫了它們的 <code>speak</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">// 定義結構體
struct Animal {
    kind: String,
    name: String,
}

// Animal 結構體的方法
impl Animal {
    // 構造函數
    fn new(kind: &amp;str, name: &amp;str) -&gt; Self {
        Animal {
            kind: kind.to_string(),
            name: name.to_string(),
        }
    }

    // 說話的方法
    fn speak(&amp;self) -&gt; String {
        match self.kind.as_str() {
            "Dog" =&gt; format!("{} says Woof!", self.name),
            "Cat" =&gt; format!("{} says Meow!", self.name),
            _ =&gt; format!("Unknown animal"),
        }
    }
}

fn main() {
    // 創建實例並調用方法
    let dog_instance = Animal::new("Dog", "Buddy");
    let cat_instance = Animal::new("Cat", "Whiskers");

    println!("{}", dog_instance.speak()); // 輸出: Buddy says Woof!
    println!("{}", cat_instance.speak()); // 輸出: Whiskers says Meow!
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 定義結構體
struct Point {
    x: f64,
    y: f64,
}

// 在結構體上實現方法
impl Point {
    // 構造函數
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x, y }
    }

    // 計算兩點之間的距離
    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }

    // 移動點的位置
    fn translate(&amp;mut self, dx: f64, dy: f64) {
        self.x += dx;
        self.y += dy;
    }
}

fn main() {
    // 創建 Point 的實例
    let point1 = Point::new(0.0, 0.0);
    let point2 = Point::new(3.0, 4.0);

    // 調用 Point 上的方法
    println!("Distance between points: {}", point1.distance(&amp;point2));

    let mut point3 = Point::new(1.0, 1.0);
    point3.translate(2.0, 3.0);
    println!("New point location: ({}, {})", point3.x, point3.y);
}</code></pre></pre>
<h2 id="async-await-spawn-用法"><a class="header" href="#async-await-spawn-用法">Async Await spawn 用法</a></h2>
<pre><pre class="playground"><code class="language-rust">use tokio::time::{sleep, Duration};

// 異步函數
async fn async_function(id: usize) {
    println!("Start of async function {}", id);

    // 模擬異步操作，例如 I/O 操作
    sleep(Duration::from_secs(2)).await;

    println!("End of async function {}", id);
}

// 您可以一次連續呼叫 async_function 多次。在非同步程式設計中，您可以使用 tokio::spawn 或其他類似的功能來並行執行多個非同步任務。下面是一個例子，演示如何連續呼叫 async_function 5 次
#[tokio::main]
async fn main() {
    println!("Start of main function");

    // 創建一個 Vec 來存儲任務句柄
    let mut handles = Vec::new();

    // 調用 async_function 5 次
    for i in 0..5 {
        // 使用 tokio::spawn 啟動異步任務，並將任務句柄存儲在 Vec 中
        let handle = tokio::spawn(async_function(i));
        handles.push(handle);
    }

    // 等待所有任務完成
    for handle in handles {
        handle.await.expect("Failed to await task");
    }

    println!("End of main function");
}</code></pre></pre>
<pre><code class="language-toml">[package]
name = "rust_async_test"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tokio = { version = "1", features = ["full"] }
</code></pre>
<h3 id="into"><a class="header" href="#into">into</a></h3>
<p><code>Into</code> trait 是一種常見的用於類型轉換的 trait，但並不是唯一的方式。Rust 還提供了一種簡化類型轉換的手段，即使用 <code>Into</code> trait 的 <code>into</code> 方法。</p>
<p>在 Rust 中，對於任何實現了 <code>From</code> trait 的類型，都可以使用 <code>into</code> 方法進行類型轉換。這是因為 <code>Into</code> trait 是 <code>From</code> trait 的逆。具體來說，<code>Into&lt;T&gt;</code> trait 的實現是由 <code>T</code> 實現的 <code>From&lt;U&gt;</code> trait 決定的。</p>
<pre><pre class="playground"><code class="language-rust">// 定義一個結構 Point
struct Point {
    x: i32,
    y: i32,
}

// 實現 Into&lt;T&gt; trait for Point
impl Into&lt;(i32, i32)&gt; for Point {
    fn into(self) -&gt; (i32, i32) {
        (self.x, self.y)
    }
}

fn main() {
    // 創建一個 Point 實例
    let point = Point { x: 10, y: 20 };

    // 使用 .into() 將 Point 轉換成 (i32, i32)
    let tuple: (i32, i32) = point.into();

    // 打印轉換後的結果
    println!("Tuple: {:?}", tuple);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 定義一個結構 Point
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 創建一個 Point 實例
    let point = Point { x: 10, y: 20 };

    // 使用 .into() 將 Point 轉換成 (i32, i32)
    let tuple: (i32, i32) = point.into();

    // 打印轉換後的結果
    println!("Tuple: {:?}", tuple);
}</code></pre></pre>
<p>struct 用於定義結構體（structure），即一種用來組織和存儲數據的自定義類型。而 trait 則用於定義接口，即一組方法的集合，這些方法可以被實現在各種不同的類型上。</p>
<pre><pre class="playground"><code class="language-rust">// 定義特徵 Displayable
trait Displayable {
    fn display(&amp;self);
}

// 實現特徵 Displayable for Point
struct Point {
    x: f64,
    y: f64,
}

impl Displayable for Point {
    fn display(&amp;self) {
        println!("Point: ({}, {})", self.x, self.y);
    }
}

// 實現特徵 Displayable for Circle
struct Circle {
    radius: f64,
}

impl Displayable for Circle {
    fn display(&amp;self) {
        println!("Circle with radius: {}", self.radius);
    }
}

// 定義特徵 Add
trait Add {
    fn add(&amp;self, other: &amp;Self) -&gt; Self;
}

// 實現特徵 Add for i32
impl Add for i32 {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        *self + *other
    }
}

// 實現特徵 Add for f64
impl Add for f64 {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        *self + *other
    }
}

// 定義特徵 Double
trait Double {
    fn double(&amp;self) -&gt; Self;
}

// 實現特徵 Double for i32
impl Double for i32 {
    fn double(&amp;self) -&gt; Self {
        *self * 2
    }
}

// 實現特徵 Double for f64
impl Double for f64 {
    fn double(&amp;self) -&gt; Self {
        *self * 2.0
    }
}

// 主函數
fn main() {
    // 使用 Displayable 特徵的方法
    let point = Point { x: 1.0, y: 2.0 };
    point.display();

    let circle = Circle { radius: 3.0 };
    circle.display();

    // 使用 Add 特徵的方法
    let sum_i32 = 10i32.add(&amp;5);
    let sum_f64 = 3.5f64.add(&amp;2.5);

    println!("Sum of i32: {}", sum_i32);
    println!("Sum of f64: {}", sum_f64);

    // 使用 Double 特徵的方法
    let doubled_i32 = 7i32.double();
    let doubled_f64 = 4.2f64.double();

    println!("Doubled i32: {}", doubled_i32);
    println!("Doubled f64: {}", doubled_f64);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 定義特徵 Add
trait Add {
    fn add(&amp;self, other: &amp;Self) -&gt; Self;
}

// 實現特徵 Add for i32
impl Add for i32 {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        *self + *other
    }
}

// 實現特徵 Add for f64
impl Add for f64 {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        *self + *other
    }
}

// 主函數
fn main() {
    // 使用 Add 特徵的方法
    let sum_i32 = 10i32.add(&amp;5);
    let sum_f64 = 3.5f64.add(&amp;2.5);

    println!("Sum of i32: {}", sum_i32);
    println!("Sum of f64: {}", sum_f64);
}</code></pre></pre>
<h2 id="多型polymorphism"><a class="header" href="#多型polymorphism">多型（polymorphism）</a></h2>
<p>在 Rust 中通常是通過 trait 和泛型實現的。下面是一個簡單的多型範例，其中使用了 trait 和泛型，允許一個函數接受不同類型的參數：</p>
<pre><pre class="playground"><code class="language-rust">// 定義一個特徵 Display
trait Display {
    fn display(&amp;self);
}

// 實現 Display 特徵的結構體 Point
struct Point {
    x: f64,
    y: f64,
}

impl Display for Point {
    fn display(&amp;self) {
        println!("Point: ({}, {})", self.x, self.y);
    }
}

// 實現 Display 特徵的結構體 Circle
struct Circle {
    radius: f64,
}

impl Display for Circle {
    fn display(&amp;self) {
        println!("Circle with radius: {}", self.radius);
    }
}

// 多型函數，接受實現 Display 特徵的任意類型
fn show_displayable&lt;T: Display&gt;(item: T) {
    item.display();
}

fn main() {
    let point = Point { x: 1.0, y: 2.0 };
    let circle = Circle { radius: 3.0 };

    // 調用多型函數，可以接受不同類型的參數
    show_displayable(point);
    show_displayable(circle);
}</code></pre></pre>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<pre><pre class="playground"><code class="language-rust">// 定義一個泛型函數，接受兩個參數並返回它們的和
fn add&lt;T&gt;(a: T, b: T) -&gt; T
where
    T: std::ops::Add&lt;Output = T&gt;,
{
    a + b
}

fn main() {
    // 使用泛型函數，可以處理不同類型的數據
    let sum_i32 = add(5, 3);
    let sum_f64 = add(3.5, 2.5);

    println!("Sum of i32: {}", sum_i32);
    println!("Sum of f64: {}", sum_f64);
}</code></pre></pre>
<p>在這個範例中，<code>add</code> 函數是一個泛型函數，它接受兩個相同類型的參數 <code>a</code> 和 <code>b</code>，並返回它們的和。泛型參數 <code>T</code> 表示可以是任何類型。<code>where T: std::ops::Add&lt;Output = T&gt;</code> 確保 <code>T</code> 實現了 <code>Add</code> trait，並指定了 <code>Output</code> 類型為 <code>T</code>。</p>
<p>在 <code>main</code> 函數中，我們分別使用整數和浮點數調用了 <code>add</code> 函數，顯示了泛型函數可以處理不同類型的數據並返回正確的結果。</p>
<p>在上述的泛型範例中，<code>where T: std::ops::Add&lt;Output = T&gt;</code> 是一個泛型約束（generic constraint）子句，用於指定泛型參數 <code>T</code> 必須滿足的條件。</p>
<p>這個約束的意義是，泛型參數 <code>T</code> 必須實現 <code>std::ops::Add</code> trait，並且其 <code>Add</code> 實現的輸出類型（Output）必須是 <code>T</code>。換句話說，<code>T</code> 只能與自己相加，而不是與其他類型相加。</p>
<p>這樣的約束確保了 <code>add</code> 函數在編譯時期只能被用於那些支持 <code>+</code> 運算的類型，並保證了在編譯時期就能夠確定 <code>add</code> 函數的行為。</p>
<p>不使用 <code>where</code> 子句的版本可能看起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn multiply_value&lt;T&gt;(value: T, factor: T) -&gt; T
where
    T: std::ops::Mul&lt;Output = T&gt;,
{
    value * factor
}

fn main() {
    let integer_result = multiply_value(5, 3);
    let float_result = multiply_value(3.5, 2.0);

    println!("Result of multiplying integers: {}", integer_result);
    println!("Result of multiplying floats: {}", float_result);
}</code></pre></pre>
<p><code>where</code> 子句的存在讓約束條件更為清晰，有時可以提高代碼的可讀性，特別是當約束條件較長或較複雜時。這種寫法的主要優勢是可以將約束從函數的簽名中分離出來，讓簽名更加簡潔。</p>
<p>總體而言，<code>where</code> 子句的使用是為了確定泛型參數滿足特定的條件，提高代碼的可讀性和可維護性。</p>
<h2 id="derivedebug"><a class="header" href="#derivedebug"><code>#[derive(Debug)] </code></a></h2>
<p>使用 <code>#[derive(Debug)]</code> 時，Rust 編譯器會自動生成一個 <code>Debug</code> trait 的實現。這個生成的實現通常包含一個 <code>fmt::Debug</code> trait 的 <code>fmt</code> 方法，該方法負責將類型的偵錯表示格式化為字串。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>當你使用 <code>#[derive(Debug)]</code> 註解時，Rust 編譯器會自動生成類似以下的程式碼：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        // 使用 Formatter 將調試信息格式化為字符串
        f.debug_struct("Point")
            .field("x", &amp;self.x)
            .field("y", &amp;self.y)
            .finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>這個生成的實現為 <code>Point</code> 類型實現了 <code>Debug</code> trait 中的 <code>fmt</code> 方法。在這個方法中，使用了 <code>std::fmt::Debug</code> 中提供的 <code>debug_struct</code>、<code>field</code> 和 <code>finish</code> 方法來建構偵錯表示。具體來說：</p>
<ul>
<li><code>debug_struct("Point")</code> 建立一個名為 "Point" 的偵錯結構體。</li>
<li><code>field("x", &amp;self.x)</code> 新增一個名為 "x" 的欄位，並將 <code>self.x</code> 的偵錯表示新增到結構體中。</li>
<li><code>field("y", &amp;self.y)</code> 同樣新增一個名為 "y" 的欄位，並將 <code>self.y</code> 的偵錯表示新增到結構體中。</li>
<li><code>finish()</code> 完成結構體的建構，生成最終的偵錯表示。</li>
</ul>
<p>這樣，當你使用 <code>println!</code> 宏並使用 <code>{:?}</code> 預留位置列印 <code>Point</code> 類型的實例時，編譯器自動生成的 <code>Debug</code> trait 實現將被呼叫，輸出類似於 <code>Point { x: 3.0, y: 4.0 }</code> 的偵錯資訊。這種自動生成的實現簡化了偵錯過程，使得偵錯資訊更加易讀和友好。</p>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p><code>Result</code> 是一個列舉類型，用於表示函數執行的結果，特別是可能發生錯誤的情況。<code>Result</code> 的定義如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>這裡有兩個變數，<code>T</code> 和 <code>E</code>。<code>T</code> 代表成功時返回的值的類型，而 <code>E</code> 代表錯誤時返回的值的類型。<code>Result</code> 列舉有兩個變體：</p>
<ol>
<li><code>Ok(T)</code>: 表示操作成功，包含一個成功時返回的值 <code>T</code>。</li>
<li><code>Err(E)</code>: 表示操作發生錯誤，包含一個錯誤時返回的值 <code>E</code>。</li>
</ol>
<p>例如，一個函數可能返回 <code>Result</code> 類型來表示執行結果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        // 如果嘗試除以零，則返回一個 Err 變體，包含錯誤信息
        Err("Cannot divide by zero!")
    } else {
        // 如果成功，返回 Ok 變體，包含結果值
        Ok(a / b)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result&lt;i32, &amp;'static str&gt;</code> 是一個 <code>Result</code> 類型的實例，表示可能返回一個整數（<code>i32</code>類型）的成功結果，或者返回一個靜態字串切片（<code>&amp;'static str</code>類型）的錯誤資訊。</p>
<p>讓我們詳細解釋這個類型：</p>
<ul>
<li><code>Result</code>: 這是Rust標準庫中的列舉類型，用於表示操作的結果，可以是成功的值（<code>Ok</code>變體）或錯誤的值（<code>Err</code>變體）。</li>
<li><code>&lt;i32, &amp;'static str&gt;</code>: 這是 <code>Result</code> 的兩個類型參數。第一個參數 <code>i32</code> 表示成功時返回的值的類型，第二個參數 <code>&amp;'static str</code> 表示錯誤時返回的值的類型。<code>&amp;'static str</code> 是一個指向靜態字串切片的引用，通常用於表示在整個程序生命週期中都有效的字串。</li>
</ul>
<p>在使用 <code>Result</code> 類型時，通常會使用模式匹配（pattern matching）或 <code>Result</code> 的方法來處理操作的成功和失敗情況。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match divide(10, 2) {
    Ok(result) =&gt; println!("Result: {}", result),
    Err(err) =&gt; println!("Error: {}", err),
}
<span class="boring">}</span></code></pre></pre>
<p>或者使用 <code>unwrap</code>、<code>expect</code>、<code>map</code>、<code>and_then</code> 等方法進行更複雜的處理。這樣的設計使得在Rust中明確處理可能發生的錯誤，避免了在執行階段出現未處理的異常。這也是Rust中的一種推崇錯誤處理的哲學，通過強制使用 <code>Result</code> 類型鼓勵開發者更加關注和處理潛在的錯誤情況。</p>
<h2 id="模擬-result-列舉"><a class="header" href="#模擬-result-列舉">模擬 Result 列舉</a></h2>
<pre><pre class="playground"><code class="language-rust">enum _Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn divide(a: i32, b: i32) -&gt; _Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        // 如果嘗試除以零，則返回一個 Err 變體，包含錯誤信息
        _Result::Err("Cannot divide by zero!")
    } else {
        // 如果成功，返回 Ok 變體，包含結果值
        _Result::Ok(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        _Result::Ok(result) =&gt; println!("Result: {}", result),
        _Result::Err(err) =&gt; println!("Error: {}", err),
    }
}</code></pre></pre>
<h2 id="rust中字串操作的擁有權和可變引用"><a class="header" href="#rust中字串操作的擁有權和可變引用">Rust中字串操作的擁有權和可變引用</a></h2>
<p>這兩個程式碼的主要區別在於函數 <code>greet</code> 如何處理字串的擁有權（ownership）：</p>
<h3 id="第一個範例"><a class="header" href="#第一個範例">第一個範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">rustCopy codefn greet(mut message: String) -&gt; String {
    message.push_str(", World!"); // 修改字串的內容
    println!("{}", message);
    message
}

fn main() {
    let message = String::from("Hello");
    println!("{}", message);
    let msg = greet(message);
    println!("{}", msg);
}</code></pre></pre>
<ol>
<li><code>greet</code> 函數接受一個 <code>String</code> 的擁有權，對它進行修改（push_str），然後返回修改後的字串，同時也轉移了擁有權。</li>
<li>在 <code>main</code> 函數中，<code>message</code> 的擁有權在調用 <code>greet</code> 函數時轉移到了 <code>greet</code> 內，因此 <code>main</code> 無法再使用原始的 <code>message</code>。</li>
</ol>
<h3 id="第二個範例"><a class="header" href="#第二個範例">第二個範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">rustCopy codefn greet(message: &amp;mut String) {
    message.push_str(", World!"); // 修改字串的內容
    println!("{}", message);
}

fn main() {
    let mut message = String::from("Hello");
    println!("{}", message);

    greet(&amp;mut message); // 傳遞字串的可變引用
    println!("{}", message);
}</code></pre></pre>
<ol>
<li><code>greet</code> 函數接受一個 <code>&amp;mut String</code>，這是字串的可變引用，它允許 <code>greet</code> 修改字串的內容，但不轉移擁有權。</li>
<li>在 <code>main</code> 函數中，<code>message</code> 保留了擁有權，你可以通過傳遞 <code>&amp;mut message</code> 來傳遞對字串的可變引用，使 <code>greet</code> 能夠修改字串的內容。</li>
<li><code>main</code> 仍然擁有 <code>message</code> 並且可以在 <code>greet</code> 被呼叫後繼續使用修改後的 <code>message</code>。</li>
</ol>
<p>總的來說，第二個範例使用了引用和可變引用，保留了 <code>message</code> 的擁有權，允許在函數間進行資料的共享，而不是轉移擁有權。</p>
<h2 id="borrow-checker-的限制"><a class="header" href="#borrow-checker-的限制">Borrow Checker 的限制</a></h2>
<p>Rust 的 Borrow Checker 的限制，這是為了確保在編譯時能夠避免數據競爭和安全性問題。具體來說，在同一個作用域中，你不能同時擁有兩個可變引用指向同一個值。這就是為什麼你無法同時擁有 a 和 b 兩個可變引用指向 array 的兩個元素的原因。</p>
<p>Rust 提供了一些方法來處理這種情況，其中一個方法是使用 .split_at_mut() 方法來將陣列分成兩個不重疊的可變引用。這裡是如何修改你的程式碼以解決這個問題：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array = [123, 456];
    
    // 將陣列拆分成兩個可變引用，分別指向不同的元素
    let (a, b) = array.split_at_mut(1);
    let a = &amp;mut a[0];
    let b = &amp;mut b[0];
    
    *a = 789;
    *b = 101112;
    println!("{:?}", array);
}</code></pre></pre>
<h2 id="如何使用-arc-和-mutex-在多個線程之間安全地共享和修改一個可變的向量數據結構"><a class="header" href="#如何使用-arc-和-mutex-在多個線程之間安全地共享和修改一個可變的向量數據結構">如何使用 <code>Arc</code> 和 <code>Mutex</code> 在多個線程之間安全地共享和修改一個可變的向量數據結構。</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
/*
 * // 克隆 Arc，以便在兩個線程間共享
 * let shared_data1 = Arc::clone(&amp;shared_data);
 * let shared_data2 = Arc::clone(&amp;shared_data);
 * Arc:clone 作用
 * Arc::clone(&amp;shared_data) 是用於在多個線程之間安全地共享資料的方法。
 * Arc 是 Rust 標準庫提供的一種參考計數智慧型指標類型,全稱是 Atomic Reference Counted。它的作用是在多個線程間共享所有權,並在沒有線程再使用資料時自動釋放其記憶體。
 * 當你調用 Arc::clone(&amp;shared_data) 時,它會建立一個新的 Arc 指標,指向與原始 shared_data 相同的堆上資料。這個新指標的參考計數會增加,表示有一個新的所有者。
 * 這種參考計數機制確保了只要有一個 Arc 指標存在,就不會釋放底層資料。當最後一個 Arc 指標被丟棄時,參考計數會歸零,底層資料的記憶體才會被自動釋放。
 * 通過在多個線程中克隆 Arc 指標,你可以安全地在它們之間共享資料,而無需深度複製資料或手動管理其生命週期。這在需要在線程間傳遞所有權的情況下非常有用。
 * 總的來說,Arc::clone 讓你可以建立指向相同資料的多個 Arc 指標,從而在線程間共享資料,而不會產生資料競爭或違反所有權規則。
 *
 */

// let mut data = shared_data1.lock().unwrap();` 這行代碼的作用是從 `Arc` 智慧指標中取得可變引用資料的存取權。讓我們仔細解釋一下:
// 1. `shared_data1` 是一個 `Arc&lt;T&gt;` 類型的智慧指標,它封裝了資料 `T` 並實現了資料的引用計數和線程間安全存取。
// 2. `.lock()` 方法是由 `Arc&lt;T&gt;` 實現的,它返回一個 `LockResult` 類型,代表對內部資料 `T` 的存取權。
// 3. `.unwrap()` 是解開 `Result` 類型。如果 `lock()` 成功獲取存取權,它會返回 `Ok(MutexGuard)` 類型,表示獲得了可變引用 `&amp;mut T`。如果失敗返回 `Err(PoisonError)`。`.unwrap()` 會直接解開這個 `Ok` 並取得 `MutexGuard`。
// 4. `let mut data = ...` 這一行賦值,將從 `lock()` 中獲取的可變引用 `&amp;mut T` 賦值給 `data`。
//
// 所以這行代碼的作用是:
// 1) 通過 `Arc` 智慧指標存取內部資料
// 2) 獲取該資料的互斥可變引用 (避免資料競爭)
// 3) 將可變引用賦給新變數 `data`
// 這樣就可以安全地在單個線程中修改資料,同時其他線程無法同時修改,從而避免資料競爭問題。當 `data` 離開作用域時,可變引用會自動被釋放。

fn main() {
    // 創建一個共享的可變數據結構
    let shared_data = Arc::new(Mutex::new(vec![1, 2, 3]));

    // 克隆 Arc，以便在兩個線程間共享
    let shared_data1 = Arc::clone(&amp;shared_data);
    let shared_data2 = Arc::clone(&amp;shared_data);

    // 在兩個線程中分別修改數據
    let thread1 = thread::spawn(move || {
        let mut data = shared_data1.lock().unwrap();
        data.push(4);
    });

    let thread2 = thread::spawn(move || {
        let mut data = shared_data2.lock().unwrap();
        data.push(5);
    });

    // 等待兩個線程完成
    thread1.join().unwrap();
    thread2.join().unwrap();

    // 打印最終結果
    println!("{:?}", shared_data.lock().unwrap());
}</code></pre></pre>
<h2 id="使用隊列queue在兩個線程之間傳遞資料rust-標準庫提供了-stdsyncmpsc-模組來實現多生產者單消費者multiple-producer-single-consumer-mpsc通道"><a class="header" href="#使用隊列queue在兩個線程之間傳遞資料rust-標準庫提供了-stdsyncmpsc-模組來實現多生產者單消費者multiple-producer-single-consumer-mpsc通道">使用隊列(queue)在兩個線程之間傳遞資料。Rust 標準庫提供了 <code>std::sync::mpsc</code> 模組來實現多生產者單消費者(Multiple Producer Single Consumer, MPSC)通道。</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    // 創建一個通道，這會產生一個發送端和一個接收端
    let (tx, rx) = mpsc::channel();

    // 啟動一個新的線程作為生產者
    let sender = thread::spawn(move || {
        // 向通道中發送一些資料
        tx.send(1).unwrap();
        // 等待一段時間
        thread::sleep(Duration::from_secs(3));
        tx.send(2).unwrap();
        tx.send(3).unwrap();
    });

    // 在主線程中接收資料
    for received in rx {
        println!("Received: {}", received);
    }

    // 等待生產者線程結束
    sender.join().unwrap();
}</code></pre></pre>
<hr />
<h3 id="示例-1使用可變引用"><a class="header" href="#示例-1使用可變引用">示例 1：使用可變引用</a></h3>
<pre><pre class="playground"><code class="language-rust">fn modify_buffer(buffer: &amp;mut [u8]) {
    buffer[0] = 1;
}

fn main() {
    let buf = &amp;mut [0u8; 1024];
    modify_buffer(buf);
}</code></pre></pre>
<h4 id="說明"><a class="header" href="#說明">說明</a></h4>
<ol>
<li>
<p><strong>函數聲明</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn modify_buffer(buffer: &amp;mut [u8]) {
    buffer[0] = 1;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>這個函數接受一個可變引用 <code>&amp;mut [u8]</code>，指向一個 <code>u8</code> 陣列。</li>
<li>函數將陣列的第一個元素設定為 1。</li>
</ul>
</li>
<li>
<p><strong>main 函數</strong>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let buf = &amp;mut [0u8; 1024];
    modify_buffer(buf);
}</code></pre></pre>
<ul>
<li><code>let buf = &amp;mut [0u8; 1024];</code> 建立一個長度為 1024 的 <code>u8</code> 陣列，並建立一個指向這個陣列的可變引用 <code>buf</code>。</li>
<li><code>modify_buffer(buf);</code> 呼叫 <code>modify_buffer</code> 函數，將 <code>buf</code> 傳遞給它。這傳遞的是陣列的引用，而不是陣列本身。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="示例-2直接使用可變陣列"><a class="header" href="#示例-2直接使用可變陣列">示例 2：直接使用可變陣列</a></h3>
<pre><pre class="playground"><code class="language-rust">fn modify_buffer(buffer: &amp;mut [u8; 1024]) {
    buffer[0] = 1;
}

fn main() {
    let mut buf = [0u8; 1024];
    modify_buffer(&amp;mut buf);
}</code></pre></pre>
<h4 id="說明-1"><a class="header" href="#說明-1">說明</a></h4>
<ol>
<li>
<p><strong>函數聲明</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn modify_buffer(buffer: &amp;mut [u8; 1024]) {
    buffer[0] = 1;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>這個函數接受一個可變引用 <code>&amp;mut [u8; 1024]</code>，指向一個長度為 1024 的 <code>u8</code> 陣列。</li>
<li>函數將陣列的第一個元素設定為 1。</li>
</ul>
</li>
<li>
<p><strong>main 函數</strong>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut buf = [0u8; 1024];
    modify_buffer(&amp;mut buf);
}</code></pre></pre>
<ul>
<li><code>let mut buf = [0u8; 1024];</code> 建立一個長度為 1024 的可變 <code>u8</code> 陣列 <code>buf</code>。</li>
<li><code>modify_buffer(&amp;mut buf);</code> 呼叫 <code>modify_buffer</code> 函數，將 <code>buf</code> 的可變引用傳遞給它。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="主要差異"><a class="header" href="#主要差異">主要差異</a></h3>
<ol>
<li><strong>參數類型</strong>：
<ul>
<li>示例 1 的 <code>modify_buffer</code> 函數接受一個切片 <code>&amp;mut [u8]</code>，這意味著它可以處理任何長度的可變 <code>u8</code> 陣列。</li>
<li>示例 2 的 <code>modify_buffer</code> 函數接受一個固定長度的陣列 <code>&amp;mut [u8; 1024]</code>，只能處理長度為 1024 的陣列。</li>
</ul>
</li>
<li><strong>靈活性</strong>：
<ul>
<li>示例 1 更靈活，因為它可以處理不同長度的陣列，只要它們是 <code>u8</code> 類型的切片。</li>
<li>示例 2 更固定，只能處理長度為 1024 的陣列。</li>
</ul>
</li>
<li><strong>記憶體管理</strong>：
<ul>
<li>兩個示例中的陣列都是在棧上分配的。沒有使用 <code>Box</code> 或 <code>Vec</code> 進行堆分配。</li>
</ul>
</li>
</ol>
<h3 id="何時使用哪種方式"><a class="header" href="#何時使用哪種方式">何時使用哪種方式</a></h3>
<ul>
<li>如果你需要處理不同長度的陣列或切片，示例 1 的方式更合適。</li>
<li>如果你只需要處理固定長度的陣列，示例 2 的方式更簡單和直接。</li>
</ul>
<p>選擇哪種方式取決於你的具體需求。如果需要更多靈活性和通用性，使用切片。如果只需要處理固定大小的陣列，直接使用陣列更好。</p>
<hr />
<p>雖然 Rust 的所有權規則和內存管理與棧（stack）和堆（heap）的概念有一定關係，但不能簡單地用“棧上的變量就是 <code>Copy</code>，堆上的變量就是 <code>Move</code>”來判斷。關鍵在於類型是否實現了 <code>Copy</code> trait，而不是變量存儲在棧還是堆上。</p>
<h3 id="棧和堆的區別"><a class="header" href="#棧和堆的區別">棧和堆的區別</a></h3>
<ul>
<li><strong>棧（Stack）</strong>：用於存儲函數調用和局部變量，具有後進先出（LIFO）原則。棧上分配的內存是自動管理的，且開銷小、速度快。</li>
<li><strong>堆（Heap）</strong>：用於動態分配內存，適用於大小在編譯時不確定的對象。堆上的內存分配和釋放需要程序員手動管理或通過垃圾回收機制進行管理。</li>
</ul>
<h3 id="copy-和-move-的區別"><a class="header" href="#copy-和-move-的區別"><code>Copy</code> 和 <code>Move</code> 的區別</a></h3>
<ul>
<li><strong><code>Copy</code> trait</strong>：實現了 <code>Copy</code> trait 的類型在賦值或傳遞時會執行按位複製。簡單的標量類型（如整數、浮點數、布爾值、字符）和複合類型（如元組，只要其所有元素都實現了 <code>Copy</code>）都實現了 <code>Copy</code> trait。</li>
<li><strong>所有權轉移（Move）</strong>：對於沒有實現 <code>Copy</code> trait 的類型（如 <code>String</code>、<code>Vec&lt;T&gt;</code> 等），賦值或傳遞時會轉移所有權，而不是按位複製。</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<h4 id="棧上的-copy-類型"><a class="header" href="#棧上的-copy-類型">棧上的 <code>Copy</code> 類型</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = x; // x 是一個實現了 Copy trait 的整數類型
    println!("x: {}, y: {}", x, y); // x 和 y 都可以正常使用，因為 x 是被複制的
}</code></pre></pre>
<h4 id="堆上的-move-類型"><a class="header" href="#堆上的-move-類型">堆上的 <code>Move</code> 類型</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 是 String 類型，沒有實現 Copy trait
    // println!("{}", s1); // 這行會導致編譯錯誤，因為 s1 的所有權已被轉移到 s2
    println!("{}", s2); // s2 可以正常使用
}</code></pre></pre>
<h3 id="綜合考慮棧和堆"><a class="header" href="#綜合考慮棧和堆">綜合考慮棧和堆</a></h3>
<p>即使某些類型的數據存儲在堆上，這些類型的變量仍然在棧上。重要的是，變量本身（指向堆數據的指針）是否實現了 <code>Copy</code> trait。</p>
<h4 id="結構體示例"><a class="header" href="#結構體示例">結構體示例</a></h4>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = p1; // Point 實現了 Copy trait，因此是按位複製
    println!("{:?}", p1); // p1 可以正常使用
    println!("{:?}", p2); // p2 也可以正常使用
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct Custom {
    data: String,
}

fn main() {
    let c1 = Custom { data: String::from("hello") };
    let c2 = c1; // Custom 沒有實現 Copy trait，因此是所有權轉移
    // println!("{:?}", c1); // 這行會導致編譯錯誤，因為 c1 的所有權已被轉移到 c2
    println!("{:?}", c2); // c2 可以正常使用
}</code></pre></pre>
<p>總結來說，判斷變量是 <code>Copy</code> 還是 <code>Move</code> 不能僅通過其存儲在棧上還是堆上來決定，而是要看該類型是否實現了 <code>Copy</code> trait。對於實現了 <code>Copy</code> trait 的類型，賦值和傳遞時會進行按位複製；對於未實現 <code>Copy</code> trait 的類型，賦值和傳遞時會進行所有權轉移。</p>
<hr />
<h2 id="使用-rust-特徵traits和組合composition來模擬繼承的一個完整範例"><a class="header" href="#使用-rust-特徵traits和組合composition來模擬繼承的一個完整範例">使用 Rust 特徵（Traits）和組合（Composition）來模擬繼承的一個完整範例</a></h2>
<pre><pre class="playground"><code class="language-rust">// 定義一個特徵 Animal，表示動物的行為
trait Animal {
    fn speak(&amp;self); // 定義一個方法 speak，沒有默認實現
}

// 定義一個結構體 Dog，表示狗
struct Dog;

// 為結構體 Dog 實現特徵 Animal
impl Animal for Dog {
    fn speak(&amp;self) {
        println!("汪汪!"); // 狗的具體實現，打印 "汪汪!"
    }
}

// 定義另一個結構體 Cat，表示貓
struct Cat;

// 為結構體 Cat 實現特徵 Animal
impl Animal for Cat {
    fn speak(&amp;self) {
        println!("喵喵!"); // 貓的具體實現，打印 "喵喵!"
    }
}

// 定義一個通用函數，接受一個實現了 Animal 特徵的引用
fn make_animal_speak(animal: &amp;dyn Animal) {
    animal.speak(); // 調用特徵的方法
}

// 定義一個結構體 Engine，表示引擎
struct Engine {
    horsepower: u32, // 引擎的馬力
}

// 定義一個結構體 Car，表示車輛
struct Car {
    engine: Engine, // 車輛包含一個引擎
    model: String, // 車輛的型號
}

// 為結構體 Car 定義方法
impl Car {
    fn start(&amp;self) {
        println!(
            "{} 的引擎擁有 {} 馬力正在啟動!",
            self.model, self.engine.horsepower
        );
    }
}

// 主函數
fn main() {
    // 創建一個 Dog 實例
    let dog = Dog;
    // 創建一個 Cat 實例
    let cat = Cat;

    // 調用通用函數，使動物發聲
    make_animal_speak(&amp;dog); // 輸出: 汪汪!
    make_animal_speak(&amp;cat); // 輸出: 喵喵!

    // 創建一個 Engine 實例
    let engine = Engine { horsepower: 150 };
    // 創建一個 Car 實例
    let car = Car {
        engine,
        model: String::from("Toyota"),
    };

    // 啟動車輛
    car.start(); // 輸出: Toyota 的引擎擁有 150 馬力正在啟動!
}</code></pre></pre>
<p>以下是幾種解決方案：</p>
<ol>
<li>返回所有權
讓函數返回傳入的 String，這樣可以將所有權返還給呼叫者。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: String) -&gt; String {
    println!("Hello {name}");
    name
}

fn main() {
    let name = String::from("Alice");
    let name = say_hello(name);
    let name = say_hello(name);
}</code></pre></pre>
<ol start="2">
<li>傳遞引用
如果你不需要在函數內部修改 String，可以傳遞一個引用，這樣所有權不會轉移。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: &amp;String) {
    println!("Hello {name}");
}

fn main() {
    let name = String::from("Alice");
    say_hello(&amp;name);
    say_hello(&amp;name);
}</code></pre></pre>
<ol start="3">
<li>使用 clone
你可以使用 clone 方法來建立一個 String 的深複製，並傳遞它給函數。這樣你可以保留原來的變數，但會有額外的記憶體開銷。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: String) {
    println!("Hello {name}");
}

fn main() {
    let name = String::from("Alice");
    say_hello(name.clone());
    say_hello(name.clone());
}</code></pre></pre>
<hr />
<p>了解這些概念後，我可以為你提供一些簡單的 C++ 範例來說明資料複製和轉移的行為。以下是相關範例及其解釋：</p>
<h3 id="1-c-中的資料複製"><a class="header" href="#1-c-中的資料複製">1. <strong>C++ 中的資料複製</strong></a></h3>
<p>在 C++ 中，當使用 <code>=</code> 進行賦值時，通常會執行資料複製。如果涉及到堆積記憶體分配（例如字串、動態陣列等），這樣的複製行為會影響資源管理。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string s1 = "Hello, World!";
    std::string s2 = s1;  // 複製 s1 到 s2

    std::cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; std::endl;
    std::cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>當 <code>s2 = s1</code> 時，s1 的資料會被複製到 s2。此時，s1 和 s2 各自擁有一份獨立的字串資料。如果 <code>s1</code> 被釋放，s2 仍然有效且可用。</li>
</ul>
<h3 id="2-c-中的資料轉移"><a class="header" href="#2-c-中的資料轉移">2. <strong>C++ 中的資料轉移</strong></a></h3>
<p>C++ 中使用 <code>std::move</code> 來明確表示資料應該被轉移而非複製。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string s1 = "Hello, World!";
    std::string s2 = std::move(s1);  // 轉移 s1 到 s2

    std::cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; std::endl;  // s1 處於有效但未指定的狀態
    std::cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; std::endl;  // s2 擁有原來 s1 的資料

    return 0;
}
</code></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>當 <code>s2 = std::move(s1)</code> 時，<code>s1</code> 的資料會被轉移到 <code>s2</code>。這意味著 <code>s2</code> 現在擁有 <code>s1</code> 的資源，而 <code>s1</code> 處於有效但未指定的狀態（內容可能是空的，但未定義）。</li>
<li>與 Rust 不同的是，C++ 中的 <code>s1</code> 雖然已經被轉移，但仍然可以使用，不會導致程序崩潰。</li>
</ul>
<h3 id="3-複製和轉移的行為差異"><a class="header" href="#3-複製和轉移的行為差異">3. <strong>複製和轉移的行為差異</strong></a></h3>
<p>C++ 的 <code>=</code> 運算符可以依據型別來決定是複製還是轉移。例如，如果使用的是基本型別，則會進行複製，而對於支持轉移語義的型別（如 <code>std::string</code>），則會根據上下文決定是否進行轉移。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v1 = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; v2 = std::move(v1);  // 轉移 v1 到 v2

    std::cout &lt;&lt; "v1 size: " &lt;&lt; v1.size() &lt;&lt; std::endl;  // v1 處於有效但未指定的狀態
    std::cout &lt;&lt; "v2 size: " &lt;&lt; v2.size() &lt;&lt; std::endl;  // v2 擁有原來 v1 的資料

    return 0;
}
</code></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>在這個例子中，<code>v1</code> 的資料會被轉移到 <code>v2</code>，使得 <code>v1</code> 成為一個空的容器，而 <code>v2</code> 則擁有原來 <code>v1</code> 的資料。</li>
<li><code>std::move</code> 允許程式設計師明確表示希望轉移所有權，而非進行昂貴的資料複製操作。</li>
</ul>
<p>這些範例展示了 C++ 中資料複製和轉移的基本概念，並且突顯了 C++ 與 Rust 在處理所有權和資源管理方面的一些差異。</p>
<p>在 Rust 中，所有權、借用和生命週期是核心概念，這些機制有助於避免記憶體洩漏和資料競爭。Rust 的所有權系統確保在編譯時檢查並強制執行資源管理的規則。</p>
<h3 id="1-rust-中的所有權轉移"><a class="header" href="#1-rust-中的所有權轉移">1. <strong>Rust 中的所有權轉移</strong></a></h3>
<p>在 Rust 中，當將一個變數賦值給另一個變數時，所有權會被轉移（移動），而不是複製。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, World!");
    let s2 = s1;  // s1 的所有權被轉移到 s2

    // println!("{}", s1);  // 這一行會導致編譯錯誤，因為 s1 的所有權已經被轉移
    println!("{}", s2);  // s2 現在擁有原來 s1 的所有權
}</code></pre></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>在這個例子中，<code>s1</code> 的所有權被轉移給 <code>s2</code>，因此 <code>s1</code> 在此之後不再有效。如果你試圖使用 <code>s1</code>，編譯器會報錯，提示 <code>s1</code> 已經被轉移。</li>
<li>Rust 的所有權轉移避免了重複釋放記憶體的問題，確保資源在一個特定時間點只能有一個所有者。</li>
</ul>
<h3 id="2-rust-中的資料複製"><a class="header" href="#2-rust-中的資料複製">2. <strong>Rust 中的資料複製</strong></a></h3>
<p>在 Rust 中，只有實現了 <code>Copy</code> trait 的類型（如整數、浮點數、布爾值等）可以進行淺複製（按位複製）。這些類型不會發生所有權轉移。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = x;  // x 被複製到 y

    println!("x = {}, y = {}", x, y);  // x 和 y 都有效，因為它們是 Copy 類型
}</code></pre></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>由於整數是 <code>Copy</code> 類型，當 <code>x</code> 賦值給 <code>y</code> 時，<code>x</code> 的值會被複製，而不是轉移。因此，<code>x</code> 和 <code>y</code> 都可以繼續使用。</li>
</ul>
<h3 id="3-rust-中的借用與引用"><a class="header" href="#3-rust-中的借用與引用">3. <strong>Rust 中的借用與引用</strong></a></h3>
<p>Rust 提供了引用來借用資料而不轉移所有權。這使得可以安全地共享資料。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, World!");
    let s2 = &amp;s1;  // s1 的不可變引用被借用給 s2

    println!("s1 = {}, s2 = {}", s1, s2);  // s1 和 s2 都可以被使用
}</code></pre></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>在這個例子中，<code>s2</code> 是 <code>s1</code> 的引用（借用），這意味著 <code>s2</code> 可以訪問 <code>s1</code> 的資料，而不會轉移所有權。Rust 確保在引用的生命週期內，原變數（<code>s1</code>）不會被修改或轉移。</li>
</ul>
<h3 id="4-rust-中的可變借用"><a class="header" href="#4-rust-中的可變借用">4. <strong>Rust 中的可變借用</strong></a></h3>
<p>Rust 允許可變借用，但同一時間只能有一個可變借用，這防止了資料競爭。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s1 = String::from("Hello, World!");
    let s2 = &amp;mut s1;  // s1 的可變引用被借用給 s2

    s2.push_str("!!!");  // 可以通過 s2 修改 s1 的值
    println!("s2 = {}", s2);  // s2 擁有對 s1 的可變借用
}</code></pre></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li>在這裡，<code>s2</code> 是 <code>s1</code> 的可變引用，允許通過 <code>s2</code> 修改 <code>s1</code> 的值。在可變借用期間，Rust 確保不會有其他引用可以訪問 <code>s1</code>，這樣避免了資料競爭。</li>
</ul>
<h3 id="5-rust-中的克隆"><a class="header" href="#5-rust-中的克隆">5. <strong>Rust 中的克隆</strong></a></h3>
<p>如果需要在 Rust 中顯式複製非 <code>Copy</code> 類型的資料，可以使用 <code>.clone()</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello, World!");
    let s2 = s1.clone();  // 顯式複製 s1 到 s2

    println!("s1 = {}, s2 = {}", s1, s2);  // s1 和 s2 都可以被使用
}</code></pre></pre>
<p><strong>解釋</strong>：</p>
<ul>
<li><code>clone</code> 方法會進行深複製，複製堆上的資料，讓 <code>s1</code> 和 <code>s2</code> 各自擁有一份獨立的資料。這避免了所有權轉移的問題，使得兩者都可以在之後使用。</li>
</ul>
<p>這些範例展示了 Rust 如何通過所有權和借用機制來管理資源，防止記憶體洩漏和資料競爭，同時與 C++ 的做法形成了鮮明對比。</p>
<h2 id="rust-異步編程示例"><a class="header" href="#rust-異步編程示例">Rust 異步編程示例</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll, Wake, Waker};
use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::{channel, Sender, Receiver};

// 定義一個簡單的 Future
struct CountDown {
    count: u32,
}

impl Future for CountDown {
    type Output = u32;
    
    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        println!("正在執行 poll，當前計數: {}", self.count);
        
        if self.count == 0 {
            Poll::Ready(0)
        } else {
            self.count -= 1;
            if self.count == 0 {
                Poll::Ready(0)
            } else {
                // 在真實情況下，我們應該在這裡安排一個喚醒（wake）
                let waker = cx.waker().clone();
                thread::spawn(move || {
                    thread::sleep(std::time::Duration::from_millis(500));
                    println!("喚醒 Future");
                    waker.wake();
                });
                
                Poll::Pending
            }
        }
    }
}

// 定義一個異步函數
async fn simple_async_function() -&gt; u32 {
    println!("進入異步函數");
    let countdown = CountDown { count: 3 };
    let result = countdown.await;
    println!("異步函數完成，結果: {}", result);
    result
}

// 一個簡單的執行器實現
struct SimpleExecutor {
    task_sender: Sender&lt;Arc&lt;SimpleFutureTask&gt;&gt;,
    task_receiver: Receiver&lt;Arc&lt;SimpleFutureTask&gt;&gt;,
}

struct SimpleFutureTask {
    future: Mutex&lt;Option&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;&gt;&gt;,
    task_sender: Sender&lt;Arc&lt;SimpleFutureTask&gt;&gt;,
}

impl Wake for SimpleFutureTask {
    fn wake(self: Arc&lt;Self&gt;) {
        let _ = self.task_sender.send(self.clone());
    }
}

impl SimpleExecutor {
    fn new() -&gt; Self {
        let (task_sender, task_receiver) = channel();
        SimpleExecutor {
            task_sender,
            task_receiver,
        }
    }

    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        let task = Arc::new(SimpleFutureTask {
            future: Mutex::new(Some(Box::pin(future))),
            task_sender: self.task_sender.clone(),
        });
        let _ = self.task_sender.send(task);
    }

    fn run(&amp;self) {
        while let Ok(task) = self.task_receiver.recv() {
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                let waker = Waker::from(task.clone());
                let mut cx = Context::from_waker(&amp;waker);
                match Future::poll(Pin::new(&amp;mut future), &amp;mut cx) {
                    Poll::Pending =&gt; {
                        *future_slot = Some(future);
                    }
                    Poll::Ready(()) =&gt; {
                        // Future 完成，不再放回隊列
                    }
                }
            }
        }
    }
}

/**
 * # 用生活白話解釋 Rust 中的 await
 * 
 * 想像你去麥當勞點餐。傳統的同步（非 await）方式和使用 await 的異步方式有很大不同：
 * 
 * ## 同步方式（沒有 await）
 * 
 * 你去麥當勞點了一個漢堡：
 * 1. 你站在櫃檯前，告訴店員你要一個漢堡
 * 2. 然後你就站在那裡**一動不動地等待**
 * 3. 其他人想點餐都不行，因為你擋住了櫃檯
 * 4. 店員做好漢堡後，終於把漢堡遞給你
 * 5. 你拿到漢堡，這時其他人才能點餐
 * 
 * 這就像程式中的阻塞調用 - 整個系統（櫃檯）被你占用，無法處理其他事情。
 * 
 * ## 異步方式（使用 await）
 * 
 * 你去麥當勞點了一個漢堡，但使用了"取餐號碼牌"系統：
 * 1. 你告訴店員你要一個漢堡
 * 2. 店員給你一個號碼牌，說："漢堡還沒好，你先去旁邊坐著吧，好了會叫你"
 * 3. 你拿著號碼牌去旁邊坐下（這就是 `await` 的時刻）
 * 4. **此時櫃檯空出來了**，其他人可以上前點餐
 * 5. 你可以玩手機、看書或聊天 - 做些其他事情
 * 6. 廣播叫到你的號碼時（相當於 `waker.wake()`），你回到櫃檯
 * 7. 拿到你的漢堡後，你才繼續後面的活動（買飲料、找座位等）
 * 
 * 這就是 `await` 的精髓：
 * - **讓出資源**：當你的漢堡還沒準備好時，你不是傻站在櫃檯前，而是先去坐著，讓櫃檯可以服務其他人
 * - **保留上下文**：系統記住你點了什麼、付了多少錢（你的程式狀態）
 * - **通知恢復**：漢堡做好時會通知你（wake 機制）
 * - **繼續執行**：拿到漢堡後，你可以繼續你的用餐計劃（代碼的後續部分）
 * 
 * ## 再具體一點的例子
 * 
 * `let result = simple_async_function().await;` 就像：
 * "我要點一個特殊漢堡（調用 simple_async_function）然後等它好了（await）才繼續點飲料"
 * 
 * 而在底層，系統不是讓你站在那傻等，而是：
 * 1. 記錄下你當前的狀態（"這人要特殊漢堡，之後想點飲料"）
 * 2. 給你一個號碼牌，讓你先坐著
 * 3. 當漢堡好了，叫你的號碼
 * 4. 你回來拿漢堡，然後繼續點飲料
 * 
 * 這就是為什麼 `await` 這麼神奇 - 它讓程式能高效利用等待時間做其他事情，而不是傻傻地阻塞在那裡。
 */

fn main() {
    println!("程序開始");
    
    let executor = SimpleExecutor::new();
    
    // 把我們的異步函數封裝並發送到執行器
    executor.spawn(async {
        let result = simple_async_function().await;
        println!("最終結果: {}", result);
    });
    
    // 運行執行器，處理所有任務
    executor.run();
    
    println!("程序結束");
}</code></pre></pre>
<h2 id="rust-生命週期省略規則總整理--最簡單範例"><a class="header" href="#rust-生命週期省略規則總整理--最簡單範例">Rust 生命週期省略規則總整理 &amp; 最簡單範例</a></h2>
<h3 id="什麼是生命週期省略規則"><a class="header" href="#什麼是生命週期省略規則">什麼是生命週期省略規則？</a></h3>
<p>Rust 編譯器會根據「省略規則」自動推斷引用的生命週期，讓你大部分情況不用手動標註 <code>'a</code>。但遇到複雜或不明確的情境，還是需要你明確標註。</p>
<hr />
<h3 id="省略規則可省略的情況"><a class="header" href="#省略規則可省略的情況">省略規則可省略的情況</a></h3>
<ol>
<li>
<p><strong>只有一個輸入引用參數，回傳引用</strong><br />
編譯器自動把回傳值生命週期綁到輸入參數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_first(s: &amp;str) -&gt; &amp;str {
    &amp;s[0..1]
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>方法只有 &amp;self 或 &amp;mut self，回傳引用</strong><br />
編譯器自動綁定到 self。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User { name: String }
impl User {
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<hr />
<h3 id="需要手動標註的情況"><a class="header" href="#需要手動標註的情況">需要手動標註的情況</a></h3>
<ol>
<li>
<p><strong>多個輸入引用參數，回傳引用</strong><br />
編譯器無法判斷回傳引用屬於哪個參數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 錯誤範例
// fn longest(a: &amp;str, b: &amp;str) -&gt; &amp;str { ... }

// 正確範例
fn longest(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {
    if a.len() &gt; b.len() { a } else { b }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>結構體/枚舉含有引用成員</strong><br />
必須標註生命週期參數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 錯誤範例
// struct Book { title: &amp;str }

// 正確範例
struct Book {
    title: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>無輸入引用但回傳引用</strong><br />
編譯器無法推斷，需明確標註（通常是 'static）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 錯誤範例
// fn get_str() -&gt; &amp;str { "hello" }

// 正確範例
fn get_str() -&gt; &amp;'static str {
    "hello"
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>閉包或函數指針涉及引用</strong><br />
通常要用 for 明確標註。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 正確範例
let closure: Box Fn(&amp;'a str) -&gt; &amp;'a str&gt; = Box::new(|s| s);
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<hr />
<h2 id="最簡單的生命週期標註範例"><a class="header" href="#最簡單的生命週期標註範例">最簡單的生命週期標註範例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 兩個輸入引用，回傳其中一個，需要標註
fn pick_first(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {
    a
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="小結"><a class="header" href="#小結">小結</a></h2>
<ul>
<li><strong>簡單情況</strong>（單一引用、self 方法）：編譯器自動推斷。</li>
<li><strong>複雜情況</strong>（多引用、結構體含引用、無輸入回傳引用、閉包）：必須手動標註。</li>
<li><strong>原則</strong>：只要回傳值的生命週期無法自動推斷，就要手動標註。</li>
</ul>
<p>這樣整理後，遇到錯誤訊息時就能快速判斷是否需要加上 <code>'a</code>！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust/rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rust/basic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust/rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rust/basic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
