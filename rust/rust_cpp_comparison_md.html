<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust vs C++ 詳細對比指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-vs-c-詳細對比指南"><a class="header" href="#rust-vs-c-詳細對比指南">Rust vs C++ 詳細對比指南</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>Rust 和 C++ 都是系統級程式語言，但設計哲學截然不同。C++ 給你完全的控制權，但需要你自己管理記憶體；Rust 則通過編譯時檢查來確保記憶體安全。</p>
<hr />
<h2 id="第1篇-rust基礎知識"><a class="header" href="#第1篇-rust基礎知識">第1篇 Rust基礎知識</a></h2>
<h3 id="第1章-rust入門"><a class="header" href="#第1章-rust入門">第1章 Rust入門</a></h3>
<h4 id="11-rust簡介"><a class="header" href="#11-rust簡介">1.1 Rust簡介</a></h4>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>C++</strong>: 像是一把瑞士刀，功能強大但容易割傷自己</li>
<li><strong>Rust</strong>: 像是一把智能刀，有安全鎖，不讓你割傷自己，但學會使用需要時間</li>
</ul>
<p><strong>設計理念對比：</strong></p>
<ul>
<li><strong>C++</strong>: "信任程序員，給他們所有控制權"</li>
<li><strong>Rust</strong>: "幫助程序員寫出安全的程式碼"</li>
</ul>
<h4 id="12-第1個程式"><a class="header" href="#12-第1個程式">1.2 第1個程式</a></h4>
<p><strong>C++ Hello World:</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    cout &lt;&lt; "Hello, World!" &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><strong>Rust Hello World:</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, World!");
}</code></pre></pre>
<p><strong>差異說明：</strong></p>
<ul>
<li>C++ 需要 <code>#include</code> 和 <code>return 0</code></li>
<li>Rust 更簡潔，<code>println!</code> 是宏（macro）</li>
<li>Rust 不需要明確返回值</li>
</ul>
<h4 id="13-rust基礎語法"><a class="header" href="#13-rust基礎語法">1.3 Rust基礎語法</a></h4>
<h5 id="131-註釋與打印文本"><a class="header" href="#131-註釋與打印文本">1.3.1 註釋與打印文本</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">// 單行註釋
/* 多行註釋 */
cout &lt;&lt; "Hello" &lt;&lt; endl;
printf("格式化: %d", 42);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 單行註釋
/* 多行註釋 */
println!("Hello");
println!("格式化: {}", 42);
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 的 <code>println!</code> 更安全，會在編譯時檢查格式</li>
<li>C++ 的 <code>printf</code> 在運行時才檢查，容易出錯</li>
</ul>
<h5 id="132-變量和變量可變性"><a class="header" href="#132-變量和變量可變性">1.3.2 變量和變量可變性</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int x = 5;          // 可變
const int y = 10;   // 不可變
x = 6;              // OK
// y = 11;          // 編譯錯誤
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;          // 不可變（預設）
let mut y = 10;     // 可變
let z = 15;         // 不可變
// x = 6;           // 編譯錯誤
y = 11;             // OK
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>C++</strong>: 變數預設可變，要不可變需要加 <code>const</code></li>
<li><strong>Rust</strong>: 變數預設不可變，要可變需要加 <code>mut</code></li>
<li>這個設計讓程式更安全，因為大部分時候我們不需要改變變數</li>
</ul>
<h5 id="133-常量"><a class="header" href="#133-常量">1.3.3 常量</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">const int MAX_SIZE = 100;
#define PI 3.14159
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_SIZE: i32 = 100;
const PI: f64 = 3.14159;
<span class="boring">}</span></code></pre></pre>
<p><strong>差異：</strong></p>
<ul>
<li>Rust 的常量必須指定類型</li>
<li>Rust 沒有 <code>#define</code>，所有常量都是類型安全的</li>
</ul>
<h5 id="134-運算符"><a class="header" href="#134-運算符">1.3.4 運算符</a></h5>
<p>基本運算符兩者相似，但有一些差異：</p>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int a = 5, b = 2;
int result = a / b;  // 整數除法 = 2
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5;
let b = 2;
let result = a / b;  // 整數除法 = 2
// let mixed = a / 2.0;  // 編譯錯誤！類型不匹配
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 不允許不同類型直接運算，需要明確轉換</li>
<li>這避免了意外的類型轉換錯誤</li>
</ul>
<h5 id="135-流程控制語句"><a class="header" href="#135-流程控制語句">1.3.5 流程控制語句</a></h5>
<p><strong>C++ if 語句:</strong></p>
<pre><code class="language-cpp">int x = 5;
if (x &gt; 0) {
    cout &lt;&lt; "正數" &lt;&lt; endl;
} else if (x &lt; 0) {
    cout &lt;&lt; "負數" &lt;&lt; endl;
} else {
    cout &lt;&lt; "零" &lt;&lt; endl;
}
</code></pre>
<p><strong>Rust if 語句:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
if x &gt; 0 {
    println!("正數");
} else if x &lt; 0 {
    println!("負數");
} else {
    println!("零");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rust 的 if 是表達式:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let description = if x &gt; 0 { "正數" } else { "非正數" };
<span class="boring">}</span></code></pre></pre>
<p><strong>迴圈比較:</strong></p>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">// for 迴圈
for (int i = 0; i &lt; 5; i++) {
    cout &lt;&lt; i &lt;&lt; endl;
}

// while 迴圈
int i = 0;
while (i &lt; 5) {
    cout &lt;&lt; i &lt;&lt; endl;
    i++;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// for 迴圈
for i in 0..5 {
    println!("{}", i);
}

// while 迴圈
let mut i = 0;
while i &lt; 5 {
    println!("{}", i);
    i += 1;
}

// loop 迴圈（無限迴圈）
let mut count = 0;
loop {
    println!("{}", count);
    count += 1;
    if count &gt;= 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="14-rust數據類型"><a class="header" href="#14-rust數據類型">1.4 Rust數據類型</a></h4>
<h5 id="141-標量類型"><a class="header" href="#141-標量類型">1.4.1 標量類型</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int a = 42;
float b = 3.14f;
double c = 3.14159;
char d = 'A';
bool e = true;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: i32 = 42;        // 32位整數
let b: f32 = 3.14;      // 32位浮點數
let c: f64 = 3.14159;   // 64位浮點數
let d: char = 'A';      // Unicode字符
let e: bool = true;     // 布林值
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 的整數類型更明確：<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li>
<li>Rust 的 <code>char</code> 是 4 位元組，支援所有 Unicode 字符</li>
<li>C++ 的 <code>char</code> 只有 1 位元組</li>
</ul>
<h5 id="142-複合數據類型"><a class="header" href="#142-複合數據類型">1.4.2 複合數據類型</a></h5>
<p><strong>陣列比較:</strong></p>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int arr[5] = {1, 2, 3, 4, 5};
int arr2[] = {1, 2, 3};  // 大小自動推斷
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [i32; 5] = [1, 2, 3, 4, 5];
let arr2 = [1, 2, 3];  // 類型推斷為 [i32; 3]
let arr3 = [0; 5];     // [0, 0, 0, 0, 0]
<span class="boring">}</span></code></pre></pre>
<p><strong>元組比較:</strong></p>
<p><strong>C++ (C++11後):</strong></p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
std::tuple&lt;int, double, char&gt; tup = std::make_tuple(1, 2.5, 'A');
auto [x, y, z] = tup;  // C++17 結構化綁定
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, char) = (1, 2.5, 'A');
let (x, y, z) = tup;  // 解構
let first = tup.0;    // 通過索引訪問
<span class="boring">}</span></code></pre></pre>
<h5 id="143-字符串"><a class="header" href="#143-字符串">1.4.3 字符串</a></h5>
<p>這是 Rust 和 C++ 最大的差異之一！</p>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#include &lt;string&gt;
std::string s1 = "Hello";
char s2[] = "World";
const char* s3 = "C++";
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = "Hello";           // &amp;str (字符串切片)
let s2 = String::from("World"); // String (擁有所有權)
let s3 = "Rust".to_string();    // 另一種創建String的方式
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>C++</strong>: 字符串類型複雜，容易混淆</li>
<li><strong>Rust</strong>:
<ul>
<li><code>&amp;str</code> 是借用的字符串切片（類似C++的<code>const char*</code>）</li>
<li><code>String</code> 是擁有所有權的字符串（類似C++的<code>std::string</code>）</li>
</ul>
</li>
</ul>
<h4 id="15-函數與閉包"><a class="header" href="#15-函數與閉包">1.5 函數與閉包</a></h4>
<h5 id="151-函數"><a class="header" href="#151-函數">1.5.1 函數</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int add(int a, int b) {
    return a + b;
}

void greet(const std::string&amp; name) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
    a + b  // 最後一個表達式是返回值
}

fn greet(name: &amp;str) {
    println!("Hello, {}", name);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 函數最後一個表達式自動成為返回值</li>
<li>如果有分號，就不是返回值了</li>
</ul>
<h5 id="152-閉包"><a class="header" href="#152-閉包">1.5.2 閉包</a></h5>
<p><strong>C++ (C++11後):</strong></p>
<pre><code class="language-cpp">auto add = [](int a, int b) -&gt; int {
    return a + b;
};

int x = 10;
auto add_x = [x](int a) -&gt; int {
    return a + x;
};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |a: i32, b: i32| -&gt; i32 {
    a + b
};

let x = 10;
let add_x = |a| a + x;  // 類型推斷
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 的閉包語法更簡潔</li>
<li>Rust 的閉包會自動捕獲環境變量</li>
</ul>
<h4 id="16-類型系統"><a class="header" href="#16-類型系統">1.6 類型系統</a></h4>
<h5 id="161-泛型"><a class="header" href="#161-泛型">1.6.1 泛型</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
T max(T a, T b) {
    return (a &gt; b) ? a : b;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;T: std::cmp::PartialOrd&gt;(a: T, b: T) -&gt; T {
    if a &gt; b { a } else { b }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>C++ 的模板在實例化時才檢查約束</li>
<li>Rust 的泛型在定義時就檢查約束（<code>T: PartialOrd</code>）</li>
</ul>
<h5 id="162-trait"><a class="header" href="#162-trait">1.6.2 trait</a></h5>
<p><strong>C++（使用介面）:</strong></p>
<pre><code class="language-cpp">class Drawable {
public:
    virtual void draw() = 0;
};

class Circle : public Drawable {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing a circle" &lt;&lt; std::endl;
    }
};
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Drawable {
    fn draw(&amp;self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&amp;self) {
        println!("Drawing a circle");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>C++ 用繼承實現多態</li>
<li>Rust 用 trait 實現多態，更靈活</li>
</ul>
<h5 id="163-類型轉換"><a class="header" href="#163-類型轉換">1.6.3 類型轉換</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">int x = 42;
double y = static_cast&lt;double&gt;(x);  // 顯式轉換
double z = x;  // 隱式轉換
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32;
let y = x as f64;  // 顯式轉換
// let z: f64 = x;  // 編譯錯誤！無隱式轉換
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 不允許隱式類型轉換，避免意外錯誤</li>
<li>所有轉換都必須明確</li>
</ul>
<hr />
<h2 id="第2章-rust基礎"><a class="header" href="#第2章-rust基礎">第2章 Rust基礎</a></h2>
<h3 id="21-所有權系統"><a class="header" href="#21-所有權系統">2.1 所有權系統</a></h3>
<p>這是 Rust 最獨特的特性！</p>
<h5 id="211-所有權機制"><a class="header" href="#211-所有權機制">2.1.1 所有權機制</a></h5>
<p><strong>C++（手動管理）:</strong></p>
<pre><code class="language-cpp">void example() {
    int* ptr = new int(42);
    // 使用 ptr
    delete ptr;  // 必須手動釋放
}
</code></pre>
<p><strong>Rust（自動管理）:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example() {
    let data = Box::new(42);
    // 使用 data
    // 自動釋放，無需手動管理
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>C++</strong>: "你負責清理你創建的東西"</li>
<li><strong>Rust</strong>: "我幫你自動清理，你不用擔心"</li>
</ul>
<h5 id="212-引用和借用"><a class="header" href="#212-引用和借用">2.1.2 引用和借用</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">void function(int&amp; ref) {  // 引用
    ref = 42;
}

void function2(const int&amp; ref) {  // 常量引用
    // ref = 42;  // 錯誤
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function(r: &amp;mut i32) {  // 可變借用
    *r = 42;
}

fn function2(r: &amp;i32) {  // 不可變借用
    // *r = 42;  // 錯誤
}
<span class="boring">}</span></code></pre></pre>
<p><strong>借用規則（Rust獨有）:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
let r1 = &amp;x;        // 不可變借用
let r2 = &amp;x;        // 可以有多個不可變借用
// let r3 = &amp;mut x; // 錯誤！不能同時有可變和不可變借用
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 的借用檢查器防止數據競爭</li>
<li>同一時間只能有一個可變借用，或多個不可變借用</li>
</ul>
<h5 id="213-生命周期"><a class="header" href="#213-生命周期">2.1.3 生命周期</a></h5>
<p><strong>C++（常見錯誤）:</strong></p>
<pre><code class="language-cpp">int* dangerous_function() {
    int local = 42;
    return &amp;local;  // 錯誤！返回局部變量的引用
}
</code></pre>
<p><strong>Rust（編譯時防止）:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangerous_function() -&gt; &amp;i32 {
    let local = 42;
    &amp;local  // 編譯錯誤！生命周期不匹配
}
<span class="boring">}</span></code></pre></pre>
<p><strong>正確的生命周期:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len() {
        s1
    } else {
        s2
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="22-宏"><a class="header" href="#22-宏">2.2 宏</a></h3>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))  // 不安全
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! max {
    ($a:expr, $b:expr) =&gt; {
        if $a &gt; $b { $a } else { $b }
    };
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>C++ 的宏是簡單的文本替換</li>
<li>Rust 的宏是語法感知的，更安全</li>
</ul>
<h3 id="23-智能指針"><a class="header" href="#23-智能指針">2.3 智能指針</a></h3>
<h5 id="231-什麼是智能指針"><a class="header" href="#231-什麼是智能指針">2.3.1 什麼是智能指針</a></h5>
<p><strong>白話解釋：</strong></p>
<ul>
<li>普通指針：就像房子的鑰匙，但你得記住鎖門</li>
<li>智能指針：像自動鎖門的鑰匙，會幫你管理</li>
</ul>
<h5 id="232-box"><a class="header" href="#232-box">2.3.2 Box</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr = Box::new(42);
<span class="boring">}</span></code></pre></pre>
<h5 id="233-rcreference-counting"><a class="header" href="#233-rcreference-counting">2.3.3 Rc（Reference Counting）</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42);
std::shared_ptr&lt;int&gt; ptr2 = ptr1;  // 引用計數 +1
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
let ptr1 = Rc::new(42);
let ptr2 = Rc::clone(&amp;ptr1);  // 引用計數 +1
<span class="boring">}</span></code></pre></pre>
<h5 id="234-refcell"><a class="header" href="#234-refcell">2.3.4 RefCell</a></h5>
<p><strong>白話解釋：</strong></p>
<ul>
<li>允許在不可變借用中進行可變操作</li>
<li>在運行時檢查借用規則，而不是編譯時</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
let data = RefCell::new(42);
let mut_ref = data.borrow_mut();
*mut_ref = 100;
<span class="boring">}</span></code></pre></pre>
<h3 id="24-多線程"><a class="header" href="#24-多線程">2.4 多線程</a></h3>
<h5 id="241-什麼是多線程"><a class="header" href="#241-什麼是多線程">2.4.1 什麼是多線程</a></h5>
<p><strong>白話解釋：</strong></p>
<ul>
<li>單線程：一個人做所有事情</li>
<li>多線程：多個人同時做不同事情</li>
</ul>
<h5 id="242-創建線程"><a class="header" href="#242-創建線程">2.4.2 創建線程</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#include &lt;thread&gt;
std::thread t([]() {
    std::cout &lt;&lt; "Hello from thread" &lt;&lt; std::endl;
});
t.join();
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
let handle = thread::spawn(|| {
    println!("Hello from thread");
});
handle.join().unwrap();
<span class="boring">}</span></code></pre></pre>
<h5 id="243-線程間的數據共享"><a class="header" href="#243-線程間的數據共享">2.4.3 線程間的數據共享</a></h5>
<p><strong>C++（需要手動同步）:</strong></p>
<pre><code class="language-cpp">#include &lt;mutex&gt;
std::mutex mtx;
int shared_data = 0;

void increment() {
    std::lock_guard&lt;std::mutex&gt; lock(mtx);
    shared_data++;
}
</code></pre>
<p><strong>Rust（編譯時保證安全）:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
let shared_data = Arc::new(Mutex::new(0));
let data_clone = shared_data.clone();

thread::spawn(move || {
    let mut data = data_clone.lock().unwrap();
    *data += 1;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="25-錯誤處理"><a class="header" href="#25-錯誤處理">2.5 錯誤處理</a></h3>
<h5 id="251-可恢復錯誤"><a class="header" href="#251-可恢復錯誤">2.5.1 可恢復錯誤</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#include &lt;optional&gt;
std::optional&lt;int&gt; divide(int a, int b) {
    if (b == 0) {
        return std::nullopt;
    }
    return a / b;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

// 使用
match divide(10, 2) {
    Ok(result) =&gt; println!("Result: {}", result),
    Err(error) =&gt; println!("Error: {}", error),
}
<span class="boring">}</span></code></pre></pre>
<h5 id="252-不可恢復錯誤"><a class="header" href="#252-不可恢復錯誤">2.5.2 不可恢復錯誤</a></h5>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
throw std::runtime_error("Something went wrong");
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!("Something went wrong");
<span class="boring">}</span></code></pre></pre>
<h3 id="26-包和crate"><a class="header" href="#26-包和crate">2.6 包和crate</a></h3>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>C++</strong>: 使用 <code>#include</code> 和鏈接器</li>
<li><strong>Rust</strong>: 使用 <code>Cargo.toml</code> 管理依賴</li>
</ul>
<p><strong>Cargo.toml:</strong></p>
<pre><code class="language-toml">[package]
name = "my_project"
version = "0.1.0"

[dependencies]
serde = "1.0"
</code></pre>
<h3 id="27-模塊"><a class="header" href="#27-模塊">2.7 模塊</a></h3>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">// math.h
namespace math {
    int add(int a, int b);
}

// math.cpp
#include "math.h"
int math::add(int a, int b) {
    return a + b;
}
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
mod math {
    pub fn add(a: i32, b: i32) -&gt; i32 {
        a + b
    }
}

// 使用
use math::add;
<span class="boring">}</span></code></pre></pre>
<h3 id="28-單元測試"><a class="header" href="#28-單元測試">2.8 單元測試</a></h3>
<p><strong>C++（需要外部框架）:</strong></p>
<pre><code class="language-cpp">// 使用 Google Test
TEST(MathTest, Addition) {
    EXPECT_EQ(add(2, 3), 5);
}
</code></pre>
<p><strong>Rust（內建支援）:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_addition() {
        assert_eq!(add(2, 3), 5);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="29-調試"><a class="header" href="#29-調試">2.9 調試</a></h3>
<p><strong>C++:</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
std::cout &lt;&lt; "Debug: x = " &lt;&lt; x &lt;&lt; std::endl;
</code></pre>
<p><strong>Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Debug: x = {:?}", x);
// 或者使用 debug 宏
dbg!(x);
<span class="boring">}</span></code></pre></pre>
<hr />
<hr />
<h2 id="rust-拿掉了-c-的什麼為什麼"><a class="header" href="#rust-拿掉了-c-的什麼為什麼">Rust 拿掉了 C++ 的什麼？為什麼？</a></h2>
<h3 id="1-拿掉了手動記憶體管理"><a class="header" href="#1-拿掉了手動記憶體管理">1. 拿掉了手動記憶體管理</a></h3>
<p><strong>C++ 的問題：</strong></p>
<pre><code class="language-cpp">void memory_leak_example() {
    int* ptr = new int(42);
    // 忘記 delete ptr; 
    // 記憶體洩漏！
}

void dangling_pointer_example() {
    int* ptr;
    {
        int local = 42;
        ptr = &amp;local;
    }
    // ptr 現在指向無效記憶體！
    cout &lt;&lt; *ptr;  // 未定義行為
}
</code></pre>
<p><strong>Rust 的解決方案：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_memory_example() {
    let data = Box::new(42);
    // 自動清理，不會洩漏
}

fn no_dangling_pointer() {
    let ptr;
    {
        let local = 42;
        // ptr = &amp;local;  // 編譯錯誤！
    }
    // Rust 不允許懸空指標
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：C++ 像是給你一把槍但沒有保險，你可能會意外射到自己</li>
<li><strong>解決</strong>：Rust 像是智能槍，有多重安全機制，防止意外傷害</li>
<li><strong>好處</strong>：99% 的記憶體相關 bug 在編譯時就被抓到了</li>
</ul>
<h3 id="2-拿掉了-null-指標"><a class="header" href="#2-拿掉了-null-指標">2. 拿掉了 NULL 指標</a></h3>
<p><strong>C++ 的問題：</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;
*ptr = 42;  // 程式崩潰！
</code></pre>
<p><strong>Rust 的解決方案：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value: Option&lt;i32&gt; = None;
match value {
    Some(v) =&gt; println!("值是: {}", v),
    None =&gt; println!("沒有值"),
}
// 強制你處理"沒有值"的情況
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：NULL 指標像是不存在的地址，去那裡會迷路</li>
<li><strong>解決</strong>：Rust 用 <code>Option&lt;T&gt;</code> 明確表示"可能沒有值"</li>
<li><strong>好處</strong>：編譯器強制你考慮所有情況，避免意外崩潰</li>
</ul>
<h3 id="3-拿掉了資料競爭"><a class="header" href="#3-拿掉了資料競爭">3. 拿掉了資料競爭</a></h3>
<p><strong>C++ 的問題：</strong></p>
<pre><code class="language-cpp">int counter = 0;

void thread1() { counter++; }
void thread2() { counter++; }

// 兩個執行緒同時修改 counter，結果不可預測
</code></pre>
<p><strong>Rust 的解決方案：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

let counter = Arc::new(Mutex::new(0));
let counter1 = counter.clone();
let counter2 = counter.clone();

thread::spawn(move || {
    let mut num = counter1.lock().unwrap();
    *num += 1;
});

thread::spawn(move || {
    let mut num = counter2.lock().unwrap();
    *num += 1;
});
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：多執行緒像是多人同時編輯同一文件，會亂掉</li>
<li><strong>解決</strong>：Rust 強制使用鎖或其他同步機制</li>
<li><strong>好處</strong>：編譯時就防止資料競爭，不會有神秘的併發 bug</li>
</ul>
<h3 id="4-拿掉了未初始化變數"><a class="header" href="#4-拿掉了未初始化變數">4. 拿掉了未初始化變數</a></h3>
<p><strong>C++ 的問題：</strong></p>
<pre><code class="language-cpp">int x;  // 未初始化
cout &lt;&lt; x;  // 印出垃圾值
</code></pre>
<p><strong>Rust 的解決方案：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;  // 聲明但未初始化
// println!("{}", x);  // 編譯錯誤！
x = 42;  // 必須先初始化
println!("{}", x);  // 現在可以用了
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：未初始化變數像是空的盒子，不知道裡面裝什麼</li>
<li><strong>解決</strong>：Rust 不允許使用未初始化的變數</li>
<li><strong>好處</strong>：避免讀取到隨機值導致的 bug</li>
</ul>
<h3 id="5-拿掉了隱式類型轉換"><a class="header" href="#5-拿掉了隱式類型轉換">5. 拿掉了隱式類型轉換</a></h3>
<p><strong>C++ 的問題：</strong></p>
<pre><code class="language-cpp">int a = 10;
double b = 3.14;
int result = a + b;  // 隱式轉換，可能失去精度
</code></pre>
<p><strong>Rust 的解決方案：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10i32;
let b = 3.14f64;
// let result = a + b;  // 編譯錯誤！
let result = a as f64 + b;  // 必須明確轉換
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：隱式轉換像是自動翻譯，有時會翻錯意思</li>
<li><strong>解決</strong>：Rust 要求所有轉換都要明確</li>
<li><strong>好處</strong>：避免意外的精度丟失或類型錯誤</li>
</ul>
<h3 id="6-拿掉了繼承"><a class="header" href="#6-拿掉了繼承">6. 拿掉了繼承</a></h3>
<p><strong>C++ 的複雜繼承：</strong></p>
<pre><code class="language-cpp">class A { public: virtual void foo() = 0; };
class B { public: virtual void bar() = 0; };
class C : public A, public B {  // 多重繼承
    // 複雜的菱形繼承問題...
};
</code></pre>
<p><strong>Rust 的組合方式：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

trait Bar {
    fn bar(&amp;self);
}

struct C;

impl Foo for C {
    fn foo(&amp;self) { println!("foo"); }
}

impl Bar for C {
    fn bar(&amp;self) { println!("bar"); }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li><strong>問題</strong>：繼承像是複雜的家族關係，容易搞混</li>
<li><strong>解決</strong>：Rust 用組合和 trait，更清晰</li>
<li><strong>好處</strong>：避免繼承帶來的複雜性和菱形問題</li>
</ul>
<hr />
<h2 id="rust-特有的功能"><a class="header" href="#rust-特有的功能">Rust 特有的功能</a></h2>
<h3 id="1-所有權系統ownership"><a class="header" href="#1-所有權系統ownership">1. 所有權系統（Ownership）</a></h3>
<p><strong>這是 Rust 最獨特的特性！</strong></p>
<pre><pre class="playground"><code class="language-rust">fn take_ownership(s: String) {
    println!("{}", s);
}  // s 在這裡被丟棄

fn main() {
    let s = String::from("hello");
    take_ownership(s);
    // println!("{}", s);  // 編譯錯誤！s 已被移動
}</code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>就像實體物品，同一時間只能有一個人擁有</li>
<li>當你把東西給別人，你就不再擁有它了</li>
<li><strong>好處</strong>：自動記憶體管理，無需垃圾回收器</li>
</ul>
<h3 id="2-借用檢查器borrow-checker"><a class="header" href="#2-借用檢查器borrow-checker">2. 借用檢查器（Borrow Checker）</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from("hello");
    
    let r1 = &amp;s;        // 不可變借用
    let r2 = &amp;s;        // 可以有多個不可變借用
    // let r3 = &amp;mut s; // 錯誤！不能同時有可變和不可變借用
    
    println!("{} and {}", r1, r2);
    // r1 和 r2 不再使用
    
    let r3 = &amp;mut s;    // 現在可以可變借用了
    println!("{}", r3);
}</code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>就像圖書館借書規則：
<ul>
<li>可以多人同時「讀」同一本書</li>
<li>但如果有人要「寫筆記」，就只能一個人用</li>
</ul>
</li>
<li><strong>好處</strong>：編譯時防止資料競爭</li>
</ul>
<h3 id="3-模式匹配pattern-matching"><a class="header" href="#3-模式匹配pattern-matching">3. 模式匹配（Pattern Matching）</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit =&gt; println!("退出"),
        Message::Move { x, y } =&gt; println!("移動到 ({}, {})", x, y),
        Message::Write(text) =&gt; println!("寫入: {}", text),
        Message::ChangeColor(r, g, b) =&gt; println!("顏色: ({}, {}, {})", r, g, b),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>像是超強的 switch，可以拆解複雜的數據結構</li>
<li>編譯器確保你處理了所有可能的情況</li>
<li><strong>好處</strong>：安全、強大、表達力強</li>
</ul>
<h3 id="4-零成本抽象zero-cost-abstractions"><a class="header" href="#4-零成本抽象zero-cost-abstractions">4. 零成本抽象（Zero-Cost Abstractions）</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 高階寫法
let numbers: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers
    .iter()
    .filter(|&amp;x| x % 2 == 0)
    .map(|&amp;x| x * 2)
    .sum();

// 編譯後等同於手寫的迴圈，沒有額外開銷
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>像是豪華汽車的自動檔，使用方便但不影響性能</li>
<li>高階抽象在編譯時被優化成低階代碼</li>
<li><strong>好處</strong>：寫得爽，跑得快</li>
</ul>
<h3 id="5-強大的類型推斷"><a class="header" href="#5-強大的類型推斷">5. 強大的類型推斷</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];  // 編譯器知道這是 Vec&lt;i32&gt;
let result = numbers.iter().sum();  // 知道這是 i32

// 複雜的情況也能推斷
let data: HashMap&lt;_, _&gt; = vec![("a", 1), ("b", 2)].into_iter().collect();
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>編譯器像是聰明的助手，能猜出你的意思</li>
<li>你不用寫一堆類型註釋</li>
<li><strong>好處</strong>：程式碼簡潔但類型安全</li>
</ul>
<h3 id="6-宏系統macro-system"><a class="header" href="#6-宏系統macro-system">6. 宏系統（Macro System）</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! say_hello {
    () =&gt; {
        println!("Hello!");
    };
    ($name:expr) =&gt; {
        println!("Hello, {}!", $name);
    };
}

say_hello!();           // Hello!
say_hello!("Rust");     // Hello, Rust!
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>像是程式碼的模板，可以生成重複的代碼</li>
<li>比 C++ 的 <code>#define</code> 更安全更強大</li>
<li><strong>好處</strong>：減少重複代碼，類型安全</li>
</ul>
<hr />
<h2 id="rust-的整體好處"><a class="header" href="#rust-的整體好處">Rust 的整體好處</a></h2>
<h3 id="1-記憶體安全--性能"><a class="header" href="#1-記憶體安全--性能">1. 記憶體安全 + 性能</a></h3>
<p><strong>白話解釋：</strong></p>
<ul>
<li>以前你只能選擇：要嘛安全但慢（如 Java），要嘛快但危險（如 C++）</li>
<li>Rust 讓你兩個都要：既安全又快</li>
<li><strong>比喻</strong>：像是既安全又跑得快的賽車</li>
</ul>
<h3 id="2-併發安全"><a class="header" href="#2-併發安全">2. 併發安全</a></h3>
<p><strong>白話解釋：</strong></p>
<ul>
<li>多執行緒程式設計不再是「祈禱不要出錯」</li>
<li>編譯器幫你檢查，確保執行緒安全</li>
<li><strong>比喻</strong>：像是有安全網的走鋼絲</li>
</ul>
<h3 id="3-現代化的工具鏈"><a class="header" href="#3-現代化的工具鏈">3. 現代化的工具鏈</a></h3>
<p><strong>Cargo（包管理器）：</strong></p>
<pre><code class="language-bash">cargo new my_project    # 創建新專案
cargo build            # 編譯
cargo test             # 測試
cargo run              # 執行
</code></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>一個工具搞定所有事情</li>
<li>不像 C++ 需要學一堆不同的工具</li>
<li><strong>比喻</strong>：像是瑞士刀，功能齊全</li>
</ul>
<h3 id="4-優秀的錯誤訊息"><a class="header" href="#4-優秀的錯誤訊息">4. 優秀的錯誤訊息</a></h3>
<p><strong>Rust 的錯誤訊息：</strong></p>
<pre><code>error[E0382]: borrow of moved value: `s`
  --&gt; src/main.rs:5:20
   |
3  |     let s = String::from("hello");
   |         - move occurs because `s` has type `String`
4  |     take_ownership(s);
   |                    - value moved here
5  |     println!("{}", s);
   |                    ^ value borrowed here after move
   |
   = note: this error occurs because `String` does not implement the `Copy` trait
</code></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>不只告訴你錯了，還教你怎麼修</li>
<li>像是有耐心的老師，不只說「錯」，還解釋為什麼錯</li>
<li><strong>好處</strong>：學習過程更順暢</li>
</ul>
<h3 id="5-向前相容性"><a class="header" href="#5-向前相容性">5. 向前相容性</a></h3>
<p><strong>白話解釋：</strong></p>
<ul>
<li>Rust 承諾向前相容：今天能編譯的程式，未來也能編譯</li>
<li>不像某些語言會突然改變，讓舊程式無法編譯</li>
<li><strong>好處</strong>：投資在 Rust 上比較安全</li>
</ul>
<h3 id="6-跨平台"><a class="header" href="#6-跨平台">6. 跨平台</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 同樣的程式碼可以跨平台編譯
cargo build --target x86_64-pc-windows-gnu     # Windows
cargo build --target x86_64-apple-darwin       # macOS  
cargo build --target x86_64-unknown-linux-gnu  # Linux
<span class="boring">}</span></code></pre></pre>
<p><strong>白話解釋：</strong></p>
<ul>
<li>一次寫，到處跑</li>
<li>不用為每個平台重寫程式</li>
<li><strong>好處</strong>：省時省力</li>
</ul>
<hr />
<h2 id="總結為什麼選擇-rust"><a class="header" href="#總結為什麼選擇-rust">總結：為什麼選擇 Rust？</a></h2>
<h3 id="簡單來說"><a class="header" href="#簡單來說">簡單來說：</a></h3>
<ol>
<li><strong>如果你想要 C++ 的速度，但不想被記憶體問題折磨</strong> → 選 Rust</li>
<li><strong>如果你想寫併發程式，但不想半夜被叫起來修 bug</strong> → 選 Rust</li>
<li><strong>如果你想要現代化的開發體驗</strong> → 選 Rust</li>
<li><strong>如果你的專案需要長期維護</strong> → 選 Rust</li>
</ol>
<h3 id="用一句話總結"><a class="header" href="#用一句話總結">用一句話總結：</a></h3>
<p><strong>Rust 是「如果重新設計 C++，考慮到過去 30 年的經驗教訓」的結果。</strong></p>
<p>它拿掉了 C++ 中容易出錯的部分，加上了現代程式語言的優秀特性，同時保持了系統級程式語言的性能。</p>
<h3 id="學習建議"><a class="header" href="#學習建議">學習建議</a></h3>
<ol>
<li><strong>如果你熟悉 C++</strong>：Rust 的概念不會太陌生，但需要適應所有權系統</li>
<li><strong>如果你是新手</strong>：Rust 可能更適合作為第一門系統語言</li>
<li><strong>選擇依據</strong>：
<ul>
<li>需要最大效能和控制：C++</li>
<li>需要安全和現代特性：Rust</li>
<li>維護大型代碼庫：Rust</li>
<li>與現有 C++ 代碼集成：C++</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust/rust_trait_markdown.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rust/rust_module_system_markdown.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust/rust_trait_markdown.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rust/rust_module_system_markdown.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
