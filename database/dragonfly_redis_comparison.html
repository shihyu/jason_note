<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dragonfly vs Redis 效能比較 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dragonflydb-vs-redis-完整比較指南"><a class="header" href="#dragonflydb-vs-redis-完整比較指南">DragonflyDB vs Redis 完整比較指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#%E7%B0%A1%E4%BB%8B">簡介</a></li>
<li><a href="#%E5%AE%89%E8%A3%9D%E6%8C%87%E5%8D%97">安裝指南</a></li>
<li><a href="#python-%E6%B8%AC%E8%A9%A6%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE">Python 測試環境設置</a></li>
<li><a href="#redis-vs-dragonflydb-%E8%A9%B3%E7%B4%B0%E6%AF%94%E8%BC%83">Redis vs DragonflyDB 詳細比較</a></li>
<li><a href="#%E6%95%88%E8%83%BD%E5%9F%BA%E6%BA%96%E6%B8%AC%E8%A9%A6">效能基準測試</a></li>
<li><a href="#%E9%81%B8%E6%93%87%E5%BB%BA%E8%AD%B0">選擇建議</a></li>
</ul>
<h2 id="簡介"><a class="header" href="#簡介">簡介</a></h2>
<h3 id="redis"><a class="header" href="#redis">Redis</a></h3>
<p>Redis (Remote Dictionary Server) 是一個開源的記憶體資料結構儲存系統，由 Salvatore Sanfilippo 在 2009 年創建。它可以用作資料庫、快取和訊息代理。</p>
<h3 id="dragonflydb"><a class="header" href="#dragonflydb">DragonflyDB</a></h3>
<p>DragonflyDB 是新一代的記憶體資料庫，於 2022 年推出，旨在成為 Redis 的現代替代品。它完全相容 Redis 協議，但底層架構完全重新設計。</p>
<h2 id="安裝指南"><a class="header" href="#安裝指南">安裝指南</a></h2>
<h3 id="dragonflydb-安裝"><a class="header" href="#dragonflydb-安裝">DragonflyDB 安裝</a></h3>
<h4 id="方法一使用-docker推薦"><a class="header" href="#方法一使用-docker推薦">方法一：使用 Docker（推薦）</a></h4>
<pre><code class="language-bash"># 拉取並執行 DragonflyDB
docker run --rm -p 6379:6379 docker.dragonflydb.io/dragonflydb/dragonfly

# 使用自訂配置
docker run --rm -p 6379:6379 \
  -v /path/to/dragonfly.conf:/etc/dragonfly/dragonfly.conf \
  docker.dragonflydb.io/dragonflydb/dragonfly \
  --flagfile=/etc/dragonfly/dragonfly.conf
</code></pre>
<h4 id="方法二在-ubuntudebian-上安裝"><a class="header" href="#方法二在-ubuntudebian-上安裝">方法二：在 Ubuntu/Debian 上安裝</a></h4>
<pre><code class="language-bash"># 下載最新版本
curl -L https://github.com/dragonflydb/dragonfly/releases/latest/download/dragonfly-x86_64.tar.gz | tar -xz

# 執行
./dragonfly --logtostderr

# 指定記憶體限制
./dragonfly --logtostderr --maxmemory=4gb
</code></pre>
<h4 id="方法三使用-kubernetes"><a class="header" href="#方法三使用-kubernetes">方法三：使用 Kubernetes</a></h4>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: dragonfly
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dragonfly
  template:
    metadata:
      labels:
        app: dragonfly
    spec:
      containers:
      - name: dragonfly
        image: docker.dragonflydb.io/dragonflydb/dragonfly
        ports:
        - containerPort: 6379
</code></pre>
<h3 id="redis-安裝"><a class="header" href="#redis-安裝">Redis 安裝</a></h3>
<h4 id="方法一使用-docker"><a class="header" href="#方法一使用-docker">方法一：使用 Docker</a></h4>
<pre><code class="language-bash">docker run --rm -p 6379:6379 redis:latest
</code></pre>
<h4 id="方法二在-ubuntudebian-上安裝-1"><a class="header" href="#方法二在-ubuntudebian-上安裝-1">方法二：在 Ubuntu/Debian 上安裝</a></h4>
<pre><code class="language-bash">sudo apt update
sudo apt install redis-server
sudo systemctl start redis-server
</code></pre>
<h2 id="python-測試環境設置"><a class="header" href="#python-測試環境設置">Python 測試環境設置</a></h2>
<h3 id="安裝必要套件"><a class="header" href="#安裝必要套件">安裝必要套件</a></h3>
<pre><code class="language-bash">pip install redis pytest pytest-asyncio aioredis hiredis redis-py-cluster
</code></pre>
<h3 id="dragonflydb-python-範例"><a class="header" href="#dragonflydb-python-範例">DragonflyDB Python 範例</a></h3>
<h4 id="1-基本連接與操作"><a class="header" href="#1-基本連接與操作">1. 基本連接與操作</a></h4>
<pre><code class="language-python">import redis
import time

# 連接到 DragonflyDB（與 Redis 客戶端相同）
client = redis.Redis(
    host='localhost',
    port=6379,
    decode_responses=True,
    socket_keepalive=True,
    socket_keepalive_options={
        1: 1,  # TCP_KEEPIDLE
        2: 1,  # TCP_KEEPINTVL
        3: 5,  # TCP_KEEPCNT
    }
)

# 測試連接
try:
    response = client.ping()
    print(f"✅ DragonflyDB 連接成功: {response}")

    # 取得伺服器資訊
    info = client.info()
    print(f"伺服器版本: {info.get('server', {}).get('dragonfly_version', 'Unknown')}")
    print(f"使用記憶體: {info.get('memory', {}).get('used_memory_human', 'Unknown')}")
except redis.ConnectionError:
    print("❌ 無法連接到 DragonflyDB")
</code></pre>
<h4 id="2-字串操作範例"><a class="header" href="#2-字串操作範例">2. 字串操作範例</a></h4>
<pre><code class="language-python">import redis
from datetime import timedelta

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 基本字串操作
client.set("user:1:name", "Alice")
client.set("user:1:email", "alice@example.com")

# 設定過期時間
client.setex("session:abc123", timedelta(hours=2), "user_data")
client.expire("user:1:name", timedelta(days=30))

# 批量設定
client.mset({
    "product:1:name": "筆記型電腦",
    "product:1:price": "25000",
    "product:1:stock": "50"
})

# 批量取得
values = client.mget(["product:1:name", "product:1:price", "product:1:stock"])
print(f"產品資訊: {values}")

# 原子操作
client.incr("page:views")
client.incrby("product:1:stock", -1)  # 減少庫存
new_stock = client.get("product:1:stock")
print(f"更新後庫存: {new_stock}")

# 條件設定
client.setnx("lock:resource", "1")  # 只在不存在時設定
</code></pre>
<h4 id="3-列表操作範例"><a class="header" href="#3-列表操作範例">3. 列表操作範例</a></h4>
<pre><code class="language-python">import redis

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 任務佇列範例
def add_task(task):
    client.lpush("task:queue", task)
    print(f"新增任務: {task}")

def get_task():
    task = client.rpop("task:queue")
    return task

# 新增任務
add_task("send_email:user123")
add_task("process_payment:order456")
add_task("generate_report:monthly")

# 處理任務
while True:
    task = get_task()
    if task:
        print(f"處理任務: {task}")
    else:
        print("沒有待處理任務")
        break

# 最近活動記錄
client.lpush("user:1:activities", "登入系統")
client.lpush("user:1:activities", "查看訂單")
client.lpush("user:1:activities", "修改個人資料")
client.ltrim("user:1:activities", 0, 99)  # 只保留最近100筆

# 取得最近活動
recent_activities = client.lrange("user:1:activities", 0, 4)
print(f"最近5筆活動: {recent_activities}")
</code></pre>
<h4 id="4-集合操作範例"><a class="header" href="#4-集合操作範例">4. 集合操作範例</a></h4>
<pre><code class="language-python">import redis

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 標籤系統
client.sadd("post:1:tags", "Python", "DragonflyDB", "教學")
client.sadd("post:2:tags", "Python", "Redis", "快取")
client.sadd("post:3:tags", "JavaScript", "Node.js", "教學")

# 找出共同標籤
common_tags = client.sinter("post:1:tags", "post:2:tags")
print(f"文章1和2的共同標籤: {common_tags}")

# 使用者興趣
client.sadd("user:alice:interests", "Python", "資料庫", "機器學習")
client.sadd("user:bob:interests", "Python", "網頁開發", "資料庫")

# 推薦系統 - 找出共同興趣
shared_interests = client.sinter("user:alice:interests", "user:bob:interests")
print(f"Alice 和 Bob 的共同興趣: {shared_interests}")

# 隨機抽獎
client.sadd("lottery:participants", "user1", "user2", "user3", "user4", "user5")
winner = client.srandmember("lottery:participants")
print(f"中獎者: {winner}")
</code></pre>
<h4 id="5-有序集合操作範例"><a class="header" href="#5-有序集合操作範例">5. 有序集合操作範例</a></h4>
<pre><code class="language-python">import redis
import time

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 排行榜系統
def update_score(user_id, score):
    client.zadd("leaderboard:global", {user_id: score})

def get_top_players(count=10):
    return client.zrevrange("leaderboard:global", 0, count-1, withscores=True)

def get_user_rank(user_id):
    rank = client.zrevrank("leaderboard:global", user_id)
    return rank + 1 if rank is not None else None

# 更新分數
update_score("player:alice", 1500)
update_score("player:bob", 2100)
update_score("player:charlie", 1800)
update_score("player:david", 2500)
update_score("player:eve", 1200)

# 取得排行榜
top_players = get_top_players(3)
print("🏆 排行榜前三名:")
for i, (player, score) in enumerate(top_players, 1):
    print(f"  {i}. {player}: {score:.0f} 分")

# 查詢排名
alice_rank = get_user_rank("player:alice")
print(f"\nAlice 的排名: 第 {alice_rank} 名")

# 時間序列資料
timestamp = int(time.time())
client.zadd("events:timeline", {
    f"event:{timestamp}:login": timestamp,
    f"event:{timestamp+10}:purchase": timestamp + 10,
    f"event:{timestamp+20}:logout": timestamp + 20
})

# 查詢時間範圍內的事件
recent_events = client.zrangebyscore(
    "events:timeline",
    timestamp,
    timestamp + 30,
    withscores=True
)
print(f"\n最近30秒的事件: {recent_events}")
</code></pre>
<h4 id="6-雜湊操作範例"><a class="header" href="#6-雜湊操作範例">6. 雜湊操作範例</a></h4>
<pre><code class="language-python">import redis

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 使用者資料管理
def create_user(user_id, user_data):
    client.hset(f"user:{user_id}", mapping=user_data)

def get_user(user_id):
    return client.hgetall(f"user:{user_id}")

def update_user_field(user_id, field, value):
    client.hset(f"user:{user_id}", field, value)

# 建立使用者
create_user("1001", {
    "username": "alice_wang",
    "email": "alice@example.com",
    "age": "28",
    "city": "台北",
    "created_at": "2024-01-15"
})

# 取得使用者資料
user_data = get_user("1001")
print(f"使用者資料: {user_data}")

# 更新特定欄位
update_user_field("1001", "city", "高雄")
update_user_field("1001", "last_login", "2024-01-20")

# 檢查欄位是否存在
exists = client.hexists("user:1001", "email")
print(f"Email 欄位存在: {exists}")

# 增加數值欄位
client.hincrby("user:1001", "login_count", 1)

# 購物車系統
def add_to_cart(user_id, product_id, quantity):
    client.hincrby(f"cart:{user_id}", product_id, quantity)

def get_cart(user_id):
    return client.hgetall(f"cart:{user_id}")

def remove_from_cart(user_id, product_id):
    client.hdel(f"cart:{user_id}", product_id)

# 購物車操作
add_to_cart("user:1001", "product:laptop", 1)
add_to_cart("user:1001", "product:mouse", 2)
add_to_cart("user:1001", "product:keyboard", 1)

cart = get_cart("user:1001")
print(f"\n購物車內容: {cart}")
</code></pre>
<h4 id="7-pipeline-批次操作範例"><a class="header" href="#7-pipeline-批次操作範例">7. Pipeline 批次操作範例</a></h4>
<pre><code class="language-python">import redis
import time

client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# 使用 Pipeline 提升效能
def batch_insert_with_pipeline(count=10000):
    start_time = time.time()

    pipe = client.pipeline()
    for i in range(count):
        pipe.set(f"key:{i}", f"value:{i}")
        if i % 100 == 0:  # 每100個命令執行一次
            pipe.execute()
            pipe = client.pipeline()

    pipe.execute()  # 執行剩餘的命令

    elapsed = time.time() - start_time
    print(f"Pipeline 插入 {count} 筆資料耗時: {elapsed:.2f} 秒")
    print(f"平均每秒: {count/elapsed:.0f} ops")

# 不使用 Pipeline 的對照組
def batch_insert_without_pipeline(count=1000):
    start_time = time.time()

    for i in range(count):
        client.set(f"test:{i}", f"value:{i}")

    elapsed = time.time() - start_time
    print(f"一般插入 {count} 筆資料耗時: {elapsed:.2f} 秒")
    print(f"平均每秒: {count/elapsed:.0f} ops")

# 測試效能差異
print("效能比較:")
batch_insert_without_pipeline(1000)
batch_insert_with_pipeline(10000)

# 事務性 Pipeline
def transfer_points(from_user, to_user, points):
    pipe = client.pipeline()
    pipe.watch(f"user:{from_user}:points")

    current_points = int(client.get(f"user:{from_user}:points") or 0)
    if current_points &gt;= points:
        pipe.multi()
        pipe.decrby(f"user:{from_user}:points", points)
        pipe.incrby(f"user:{to_user}:points", points)
        result = pipe.execute()
        return True
    else:
        pipe.reset()
        return False
</code></pre>
<h4 id="8-pubsub-發布訂閱範例"><a class="header" href="#8-pubsub-發布訂閱範例">8. Pub/Sub 發布訂閱範例</a></h4>
<pre><code class="language-python">import redis
import threading
import time

# 發布者
def publisher():
    pub_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
    time.sleep(1)  # 等待訂閱者準備好

    messages = [
        {"channel": "news", "message": "突發新聞：DragonflyDB 效能測試結果出爐"},
        {"channel": "news", "message": "科技新聞：Python 3.13 正式發布"},
        {"channel": "chat:room1", "message": "Alice: 大家好！"},
        {"channel": "chat:room1", "message": "Bob: 嗨，Alice！"},
    ]

    for msg in messages:
        pub_client.publish(msg["channel"], msg["message"])
        print(f"📢 發布到 {msg['channel']}: {msg['message']}")
        time.sleep(0.5)

# 訂閱者
def subscriber():
    sub_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
    pubsub = sub_client.pubsub()

    # 訂閱頻道
    pubsub.subscribe('news', 'chat:room1')

    # 接收訊息
    for message in pubsub.listen():
        if message['type'] == 'message':
            print(f"📨 收到 [{message['channel']}]: {message['data']}")

# 執行發布訂閱範例
if __name__ == "__main__":
    # 啟動訂閱者執行緒
    sub_thread = threading.Thread(target=subscriber)
    sub_thread.daemon = True
    sub_thread.start()

    # 啟動發布者
    publisher()

    time.sleep(2)  # 等待所有訊息處理完成
</code></pre>
<h4 id="9-非同步操作範例"><a class="header" href="#9-非同步操作範例">9. 非同步操作範例</a></h4>
<pre><code class="language-python">import asyncio
import aioredis

async def async_operations():
    # 建立非同步連接
    redis = await aioredis.create_redis_pool(
        'redis://localhost:6379',
        encoding='utf-8'
    )

    try:
        # 非同步設定值
        await redis.set('async:key1', 'value1')
        await redis.set('async:key2', 'value2')

        # 非同步批量操作
        tasks = []
        for i in range(100):
            task = redis.set(f'async:batch:{i}', f'value:{i}')
            tasks.append(task)

        # 等待所有操作完成
        await asyncio.gather(*tasks)

        # 非同步取值
        value = await redis.get('async:key1')
        print(f"非同步取得的值: {value}")

        # 非同步 Pipeline
        pipe = redis.pipeline()
        pipe.incr('async:counter')
        pipe.incr('async:counter')
        pipe.incr('async:counter')
        results = await pipe.execute()
        print(f"Pipeline 結果: {results}")

    finally:
        redis.close()
        await redis.wait_closed()

# 執行非同步操作
# asyncio.run(async_operations())
</code></pre>
<h4 id="10-連接池管理範例"><a class="header" href="#10-連接池管理範例">10. 連接池管理範例</a></h4>
<pre><code class="language-python">import redis
from redis import ConnectionPool
from contextlib import contextmanager

# 建立全域連接池
pool = ConnectionPool(
    host='localhost',
    port=6379,
    decode_responses=True,
    max_connections=50,
    socket_connect_timeout=5,
    socket_timeout=5,
    retry_on_timeout=True,
    health_check_interval=30
)

# 連接管理器
@contextmanager
def get_redis_connection():
    client = redis.Redis(connection_pool=pool)
    try:
        yield client
    finally:
        # 連接會自動返回池中
        pass

# 使用連接池
def perform_operations():
    with get_redis_connection() as client:
        # 執行操作
        client.set("pool:test", "value")
        value = client.get("pool:test")
        print(f"使用連接池取得: {value}")

# 監控連接池狀態
def check_pool_status():
    with get_redis_connection() as client:
        pool_stats = {
            "created_connections": pool.connection_kwargs,
            "max_connections": pool.max_connections,
            "encoding": pool.encoder.encoding
        }
        print(f"連接池狀態: {pool_stats}")

perform_operations()
check_pool_status()
</code></pre>
<h4 id="11-錯誤處理與重試機制"><a class="header" href="#11-錯誤處理與重試機制">11. 錯誤處理與重試機制</a></h4>
<pre><code class="language-python">import redis
from redis.exceptions import ConnectionError, TimeoutError, RedisError
import time
from functools import wraps

def retry_on_failure(max_retries=3, delay=1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            while retries &lt; max_retries:
                try:
                    return func(*args, **kwargs)
                except (ConnectionError, TimeoutError) as e:
                    retries += 1
                    if retries &gt;= max_retries:
                        print(f"❌ 操作失敗，已重試 {max_retries} 次")
                        raise
                    print(f"⚠️ 連接錯誤，{delay}秒後重試... (第{retries}次)")
                    time.sleep(delay)
                except RedisError as e:
                    print(f"❌ Redis 錯誤: {e}")
                    raise
            return None
        return wrapper
    return decorator

@retry_on_failure(max_retries=3, delay=2)
def safe_redis_operation():
    client = redis.Redis(host='localhost', port=6379, decode_responses=True)

    # 測試連接
    client.ping()

    # 執行操作
    result = client.set("safe:key", "value", ex=3600)
    return result

# 使用安全操作
try:
    result = safe_redis_operation()
    if result:
        print("✅ 操作成功")
except Exception as e:
    print(f"❌ 最終失敗: {e}")
</code></pre>
<h4 id="12-效能監控範例"><a class="header" href="#12-效能監控範例">12. 效能監控範例</a></h4>
<pre><code class="language-python">import redis
import time
from datetime import datetime

class DragonflyDBMonitor:
    def __init__(self, host='localhost', port=6379):
        self.client = redis.Redis(host=host, port=port, decode_responses=True)

    def get_metrics(self):
        """取得 DragonflyDB 效能指標"""
        info = self.client.info()

        metrics = {
            'timestamp': datetime.now().isoformat(),
            'clients': {
                'connected': info.get('clients', {}).get('connected_clients', 0),
                'blocked': info.get('clients', {}).get('blocked_clients', 0)
            },
            'memory': {
                'used': info.get('memory', {}).get('used_memory_human', 'N/A'),
                'peak': info.get('memory', {}).get('used_memory_peak_human', 'N/A'),
                'rss': info.get('memory', {}).get('used_memory_rss_human', 'N/A')
            },
            'stats': {
                'total_commands': info.get('stats', {}).get('total_commands_processed', 0),
                'ops_per_sec': info.get('stats', {}).get('instantaneous_ops_per_sec', 0),
                'total_connections': info.get('stats', {}).get('total_connections_received', 0),
                'rejected_connections': info.get('stats', {}).get('rejected_connections', 0)
            },
            'cpu': {
                'used_cpu_sys': info.get('cpu', {}).get('used_cpu_sys', 0),
                'used_cpu_user': info.get('cpu', {}).get('used_cpu_user', 0)
            }
        }

        return metrics

    def benchmark_operations(self, iterations=10000):
        """執行基準測試"""
        results = {}

        # SET 操作測試
        start = time.time()
        for i in range(iterations):
            self.client.set(f'bench:key:{i}', f'value:{i}')
        set_time = time.time() - start
        results['set_ops_per_sec'] = iterations / set_time

        # GET 操作測試
        start = time.time()
        for i in range(iterations):
            self.client.get(f'bench:key:{i}')
        get_time = time.time() - start
        results['get_ops_per_sec'] = iterations / get_time

        # Pipeline 測試
        start = time.time()
        pipe = self.client.pipeline()
        for i in range(iterations):
            pipe.set(f'pipe:key:{i}', f'value:{i}')
        pipe.execute()
        pipe_time = time.time() - start
        results['pipeline_ops_per_sec'] = iterations / pipe_time

        # 清理測試資料
        for i in range(iterations):
            self.client.delete(f'bench:key:{i}', f'pipe:key:{i}')

        return results

    def print_report(self):
        """列印效能報告"""
        print("=" * 60)
        print("DragonflyDB 效能監控報告")
        print("=" * 60)

        metrics = self.get_metrics()

        print(f"\n📊 連接狀態:")
        print(f"  • 活躍連接: {metrics['clients']['connected']}")
        print(f"  • 阻塞連接: {metrics['clients']['blocked']}")

        print(f"\n💾 記憶體使用:")
        print(f"  • 當前使用: {metrics['memory']['used']}")
        print(f"  • 尖峰使用: {metrics['memory']['peak']}")
        print(f"  • RSS: {metrics['memory']['rss']}")

        print(f"\n⚡ 效能指標:")
        print(f"  • 總處理命令: {metrics['stats']['total_commands']:,}")
        print(f"  • 當前 OPS: {metrics['stats']['ops_per_sec']:,}")

        print(f"\n🧪 基準測試結果:")
        bench_results = self.benchmark_operations(1000)
        print(f"  • SET 效能: {bench_results['set_ops_per_sec']:.0f} ops/sec")
        print(f"  • GET 效能: {bench_results['get_ops_per_sec']:.0f} ops/sec")
        print(f"  • Pipeline 效能: {bench_results['pipeline_ops_per_sec']:.0f} ops/sec")

        print("=" * 60)

# 執行監控
if __name__ == "__main__":
    monitor = DragonflyDBMonitor()
    monitor.print_report()
</code></pre>
<h3 id="完整應用範例即時排行榜系統"><a class="header" href="#完整應用範例即時排行榜系統">完整應用範例：即時排行榜系統</a></h3>
<pre><code class="language-python">import redis
import random
import time
from datetime import datetime, timedelta

class GameLeaderboard:
    """遊戲排行榜系統 - 使用 DragonflyDB"""

    def __init__(self, host='localhost', port=6379):
        self.client = redis.Redis(host=host, port=port, decode_responses=True)
        self.leaderboard_key = "game:leaderboard:global"
        self.weekly_key = f"game:leaderboard:week:{datetime.now().strftime('%Y-%W')}"
        self.daily_key = f"game:leaderboard:day:{datetime.now().strftime('%Y-%m-%d')}"

    def update_score(self, player_id, score):
        """更新玩家分數"""
        pipe = self.client.pipeline()

        # 更新多個排行榜
        pipe.zadd(self.leaderboard_key, {player_id: score})
        pipe.zadd(self.weekly_key, {player_id: score})
        pipe.zadd(self.daily_key, {player_id: score})

        # 記錄玩家最高分
        pipe.hset(f"player:{player_id}", "high_score", score)
        pipe.hset(f"player:{player_id}", "last_played", datetime.now().isoformat())

        pipe.execute()

    def get_leaderboard(self, board_type='global', limit=10):
        """取得排行榜"""
        key_map = {
            'global': self.leaderboard_key,
            'weekly': self.weekly_key,
            'daily': self.daily_key
        }

        key = key_map.get(board_type, self.leaderboard_key)
        return self.client.zrevrange(key, 0, limit-1, withscores=True)

    def get_player_rank(self, player_id, board_type='global'):
        """取得玩家排名"""
        key_map = {
            'global': self.leaderboard_key,
            'weekly': self.weekly_key,
            'daily': self.daily_key
        }

        key = key_map.get(board_type, self.leaderboard_key)
        rank = self.client.zrevrank(key, player_id)
        score = self.client.zscore(key, player_id)

        return {
            'rank': rank + 1 if rank is not None else None,
            'score': score
        }

    def get_nearby_players(self, player_id, distance=2):
        """取得附近排名的玩家"""
        rank = self.client.zrevrank(self.leaderboard_key, player_id)
        if rank is None:
            return []

        start = max(0, rank - distance)
        end = rank + distance

        return self.client.zrevrange(
            self.leaderboard_key,
            start,
            end,
            withscores=True
        )

    def simulate_game(self, num_players=100, num_rounds=10):
        """模擬遊戲進行"""
        print("🎮 開始遊戲模擬...")

        # 建立玩家
        players = [f"player_{i:03d}" for i in range(num_players)]

        # 模擬多輪遊戲
        for round_num in range(num_rounds):
            print(f"\n第 {round_num + 1} 輪:")

            # 隨機選擇玩家並更新分數
            active_players = random.sample(players, k=random.randint(10, 30))
            for player in active_players:
                score = random.randint(100, 10000)
                self.update_score(player, score)

            # 顯示當前前5名
            top_5 = self.get_leaderboard(limit=5)
            print("  目前排行榜前5名:")
            for i, (player, score) in enumerate(top_5, 1):
                print(f"    {i}. {player}: {score:.0f}分")

            time.sleep(0.5)

        # 顯示最終結果
        print("\n" + "="*50)
        print("🏆 最終排行榜")
        print("="*50)

        # 全球排行榜
        print("\n📊 全球排行榜前10名:")
        global_top = self.get_leaderboard('global', limit=10)
        for i, (player, score) in enumerate(global_top, 1):
            print(f"  {i:2d}. {player}: {score:.0f}分")

        # 查詢特定玩家
        sample_player = random.choice(players)
        player_stats = self.get_player_rank(sample_player)
        print(f"\n👤 {sample_player} 的排名:")
        print(f"  • 全球排名: 第 {player_stats['rank']} 名")
        print(f"  • 分數: {player_stats['score']:.0f}")

        # 顯示附近玩家
        nearby = self.get_nearby_players(sample_player, distance=2)
        print(f"\n📍 {sample_player} 附近的玩家:")
        for player, score in nearby:
            marker = " ← (你)" if player == sample_player else ""
            print(f"  • {player}: {score:.0f}分{marker}")

# 執行範例
if __name__ == "__main__":
    leaderboard = GameLeaderboard()
    leaderboard.simulate_game(num_players=50, num_rounds=5)
</code></pre>
<h2 id="redis-vs-dragonflydb-詳細比較"><a class="header" href="#redis-vs-dragonflydb-詳細比較">Redis vs DragonflyDB 詳細比較</a></h2>
<h3 id="架構差異"><a class="header" href="#架構差異">架構差異</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Redis</th><th>DragonflyDB</th></tr></thead><tbody>
<tr><td><strong>核心架構</strong></td><td>單執行緒事件循環</td><td>多執行緒、共享無鎖架構</td></tr>
<tr><td><strong>並發模型</strong></td><td>單執行緒處理命令</td><td>利用所有 CPU 核心</td></tr>
<tr><td><strong>記憶體管理</strong></td><td>jemalloc</td><td>mimalloc + 自訂最佳化</td></tr>
<tr><td><strong>持久化</strong></td><td>RDB + AOF</td><td>RDB + 改進的快照機制</td></tr>
<tr><td><strong>資料結構</strong></td><td>標準 Redis 資料結構</td><td>相同資料結構 + 內部最佳化</td></tr>
</tbody></table>
</div>
<h3 id="效能比較"><a class="header" href="#效能比較">效能比較</a></h3>
<div class="table-wrapper"><table><thead><tr><th>指標</th><th>Redis</th><th>DragonflyDB</th></tr></thead><tbody>
<tr><td><strong>吞吐量</strong></td><td>~100K ops/sec (單核)</td><td>~4M ops/sec (32核)</td></tr>
<tr><td><strong>延遲</strong></td><td>&lt; 1ms (P99)</td><td>&lt; 1ms (P99)</td></tr>
<tr><td><strong>垂直擴展</strong></td><td>受限於單核</td><td>線性擴展至所有核心</td></tr>
<tr><td><strong>記憶體效率</strong></td><td>基準</td><td>節省 30-50%</td></tr>
<tr><td><strong>啟動時間</strong></td><td>快速</td><td>快速</td></tr>
</tbody></table>
</div>
<h3 id="功能對比"><a class="header" href="#功能對比">功能對比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>功能</th><th>Redis</th><th>DragonflyDB</th></tr></thead><tbody>
<tr><td><strong>Redis 協議相容性</strong></td><td>100% (原生)</td><td>99%+</td></tr>
<tr><td><strong>叢集支援</strong></td><td>Redis Cluster</td><td>單節點即可處理大規模</td></tr>
<tr><td><strong>Lua 腳本</strong></td><td>✅ 支援</td><td>✅ 支援</td></tr>
<tr><td><strong>Pub/Sub</strong></td><td>✅ 支援</td><td>✅ 支援</td></tr>
<tr><td><strong>事務</strong></td><td>✅ MULTI/EXEC</td><td>✅ 支援</td></tr>
<tr><td><strong>串流 (Streams)</strong></td><td>✅ 支援</td><td>✅ 支援</td></tr>
<tr><td><strong>模組系統</strong></td><td>✅ 豐富生態系</td><td>❌ 不支援 Redis 模組</td></tr>
<tr><td><strong>地理空間</strong></td><td>✅ 支援</td><td>✅ 支援</td></tr>
<tr><td><strong>JSON</strong></td><td>需要 RedisJSON 模組</td><td>原生支援基本 JSON</td></tr>
</tbody></table>
</div>
<h3 id="優缺點分析"><a class="header" href="#優缺點分析">優缺點分析</a></h3>
<h4 id="redis-優點"><a class="header" href="#redis-優點">Redis 優點</a></h4>
<p>✅ <strong>成熟穩定</strong> - 超過 15 年的生產環境驗證<br />
✅ <strong>生態系統豐富</strong> - 大量工具、客戶端、模組<br />
✅ <strong>社群龐大</strong> - 廣泛的社群支援和資源<br />
✅ <strong>文件完整</strong> - 詳盡的官方文件和教學<br />
✅ <strong>模組擴展</strong> - RedisJSON、RedisSearch、RedisGraph 等<br />
✅ <strong>企業支援</strong> - Redis Enterprise 提供商業支援</p>
<h4 id="redis-缺點"><a class="header" href="#redis-缺點">Redis 缺點</a></h4>
<p>❌ <strong>單執行緒限制</strong> - 無法充分利用多核 CPU<br />
❌ <strong>記憶體使用較高</strong> - 相同資料需要更多記憶體<br />
❌ <strong>擴展複雜</strong> - 需要 Redis Cluster 或 Sentinel<br />
❌ <strong>大資料集啟動慢</strong> - RDB 載入可能很慢<br />
❌ <strong>Fork 開銷</strong> - 持久化時的 fork 操作開銷大</p>
<h4 id="dragonflydb-優點"><a class="header" href="#dragonflydb-優點">DragonflyDB 優點</a></h4>
<p>✅ <strong>超高效能</strong> - 可達 Redis 25 倍效能<br />
✅ <strong>多核心利用</strong> - 自動使用所有 CPU 核心<br />
✅ <strong>記憶體效率</strong> - 節省 30-50% 記憶體<br />
✅ <strong>無需叢集</strong> - 單實例處理 TB 級資料<br />
✅ <strong>快照不阻塞</strong> - 改進的持久化機制<br />
✅ <strong>現代架構</strong> - 使用 C++20 和現代技術<br />
✅ <strong>相容性佳</strong> - 幾乎完全相容 Redis API</p>
<h4 id="dragonflydb-缺點"><a class="header" href="#dragonflydb-缺點">DragonflyDB 缺點</a></h4>
<p>❌ <strong>相對較新</strong> - 2022 年推出，生產環境經驗較少<br />
❌ <strong>生態系統小</strong> - 工具和資源相對較少<br />
❌ <strong>無模組支援</strong> - 不支援 Redis 模組<br />
❌ <strong>社群較小</strong> - 社群支援和資源有限<br />
❌ <strong>功能差異</strong> - 某些進階功能可能略有不同<br />
❌ <strong>企業支援有限</strong> - 商業支援選項較少</p>
<h2 id="效能基準測試"><a class="header" href="#效能基準測試">效能基準測試</a></h2>
<h3 id="測試環境"><a class="header" href="#測試環境">測試環境</a></h3>
<ul>
<li>CPU: 32 核心</li>
<li>RAM: 128GB</li>
<li>資料集: 10GB</li>
</ul>
<h3 id="測試結果"><a class="header" href="#測試結果">測試結果</a></h3>
<h4 id="set-操作-opssec"><a class="header" href="#set-操作-opssec">SET 操作 (ops/sec)</a></h4>
<pre><code>Redis (單核):        120,000
Redis (叢集-8節點):   800,000
DragonflyDB:       3,800,000
</code></pre>
<h4 id="get-操作-opssec"><a class="header" href="#get-操作-opssec">GET 操作 (ops/sec)</a></h4>
<pre><code>Redis (單核):        130,000
Redis (叢集-8節點):   900,000
DragonflyDB:       4,200,000
</code></pre>
<h4 id="記憶體使用-10m-keys"><a class="header" href="#記憶體使用-10m-keys">記憶體使用 (10M keys)</a></h4>
<pre><code>Redis:          8.5 GB
DragonflyDB:    5.2 GB
節省:           39%
</code></pre>
<h2 id="選擇建議"><a class="header" href="#選擇建議">選擇建議</a></h2>
<h3 id="選擇-redis-的情況"><a class="header" href="#選擇-redis-的情況">選擇 Redis 的情況</a></h3>
<ol>
<li>
<p><strong>穩定性優先</strong></p>
<ul>
<li>金融、醫療等關鍵應用</li>
<li>需要長期穩定運行的生產環境</li>
</ul>
</li>
<li>
<p><strong>需要特定模組</strong></p>
<ul>
<li>需要 RedisSearch 進行全文搜尋</li>
<li>需要 RedisGraph 進行圖形資料庫操作</li>
<li>需要 RedisTimeSeries 進行時序資料處理</li>
</ul>
</li>
<li>
<p><strong>企業支援需求</strong></p>
<ul>
<li>需要商業級技術支援</li>
<li>需要 SLA 保證</li>
</ul>
</li>
<li>
<p><strong>保守的技術策略</strong></p>
<ul>
<li>團隊熟悉 Redis</li>
<li>不願承擔新技術風險</li>
</ul>
</li>
</ol>
<h3 id="選擇-dragonflydb-的情況"><a class="header" href="#選擇-dragonflydb-的情況">選擇 DragonflyDB 的情況</a></h3>
<ol>
<li>
<p><strong>效能需求高</strong></p>
<ul>
<li>需要處理百萬級 QPS</li>
<li>低延遲要求嚴格</li>
</ul>
</li>
<li>
<p><strong>成本敏感</strong></p>
<ul>
<li>希望減少伺服器數量</li>
<li>需要降低記憶體成本</li>
</ul>
</li>
<li>
<p><strong>大規模資料</strong></p>
<ul>
<li>單機需要處理 TB 級資料</li>
<li>不想管理複雜的叢集</li>
</ul>
</li>
<li>
<p><strong>新專案</strong></p>
<ul>
<li>全新的專案，沒有歷史包袱</li>
<li>可以接受較新技術</li>
</ul>
</li>
</ol>
<h3 id="混合使用策略"><a class="header" href="#混合使用策略">混合使用策略</a></h3>
<pre><code>生產環境關鍵服務 → Redis
高流量快取層 → DragonflyDB  
開發測試環境 → DragonflyDB
資料分析快取 → DragonflyDB
</code></pre>
<h2 id="遷移指南"><a class="header" href="#遷移指南">遷移指南</a></h2>
<h3 id="從-redis-遷移到-dragonflydb"><a class="header" href="#從-redis-遷移到-dragonflydb">從 Redis 遷移到 DragonflyDB</a></h3>
<ol>
<li><strong>相容性測試</strong></li>
</ol>
<pre><code class="language-bash"># 使用 redis-cli 測試基本功能
redis-cli -h dragonfly-host ping
redis-cli -h dragonfly-host set test "value"
redis-cli -h dragonfly-host get test
</code></pre>
<ol start="2">
<li><strong>資料遷移</strong></li>
</ol>
<pre><code class="language-bash"># 方法一：使用 REPLICAOF
# 在 DragonflyDB 中執行
REPLICAOF redis-host 6379

# 方法二：使用 redis-dump
redis-dump -h redis-host | redis-load -h dragonfly-host
</code></pre>
<ol start="3">
<li><strong>應用程式調整</strong></li>
</ol>
<pre><code class="language-python"># 不需要修改程式碼，只需改變連接字串
# 從
client = redis.Redis(host='redis-host', port=6379)
# 到
client = redis.Redis(host='dragonfly-host', port=6379)
</code></pre>
<h2 id="監控和維運"><a class="header" href="#監控和維運">監控和維運</a></h2>
<h3 id="dragonflydb-監控指標"><a class="header" href="#dragonflydb-監控指標">DragonflyDB 監控指標</a></h3>
<pre><code class="language-bash"># 查看統計資訊
redis-cli -h dragonfly-host INFO

# 監控重要指標
- used_memory: 使用的記憶體
- connected_clients: 連接的客戶端數
- total_commands_processed: 處理的命令總數
- instantaneous_ops_per_sec: 即時 OPS
</code></pre>
<h3 id="效能優化建議"><a class="header" href="#效能優化建議">效能優化建議</a></h3>
<ol>
<li><strong>DragonflyDB 優化</strong></li>
</ol>
<pre><code class="language-bash"># 設定最大記憶體
./dragonfly --maxmemory=32gb

# 設定執行緒數（預設使用所有核心）
./dragonfly --proactor_threads=16

# 啟用快照
./dragonfly --dbfilename=dump.rdb --save_schedule="0 1"
</code></pre>
<ol start="2">
<li><strong>客戶端優化</strong></li>
</ol>
<pre><code class="language-python"># 使用連接池
pool = redis.ConnectionPool(
    host='localhost',
    port=6379,
    max_connections=50
)
client = redis.Redis(connection_pool=pool)

# 使用 Pipeline 批次操作
pipe = client.pipeline()
for i in range(10000):
    pipe.set(f'key_{i}', f'value_{i}')
pipe.execute()
</code></pre>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<h3 id="快速決策矩陣"><a class="header" href="#快速決策矩陣">快速決策矩陣</a></h3>
<div class="table-wrapper"><table><thead><tr><th>需求</th><th>推薦選擇</th></tr></thead><tbody>
<tr><td>穩定性最重要</td><td>Redis</td></tr>
<tr><td>效能最重要</td><td>DragonflyDB</td></tr>
<tr><td>需要 Redis 模組</td><td>Redis</td></tr>
<tr><td>成本控制</td><td>DragonflyDB</td></tr>
<tr><td>小型應用</td><td>Redis</td></tr>
<tr><td>大規模應用</td><td>DragonflyDB</td></tr>
<tr><td>保守策略</td><td>Redis</td></tr>
<tr><td>創新策略</td><td>DragonflyDB</td></tr>
</tbody></table>
</div>
<h3 id="未來展望"><a class="header" href="#未來展望">未來展望</a></h3>
<ul>
<li><strong>Redis</strong>: 持續優化，加強企業功能，擴展模組生態</li>
<li><strong>DragonflyDB</strong>: 快速發展，增加功能，建立生態系統</li>
</ul>
<p>兩者都是優秀的記憶體資料庫，選擇取決於具體需求、風險承受度和技術策略。建議先在非關鍵環境測試 DragonflyDB，評估是否符合需求後再決定是否採用。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../database/hash.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../database/clickhouse.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../database/hash.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../database/clickhouse.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
