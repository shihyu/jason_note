<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++/Rust 函數追蹤技術指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c-和-rust-函數追蹤技術完整指南"><a class="header" href="#c-和-rust-函數追蹤技術完整指南">C++ 和 Rust 函數追蹤技術完整指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#gcc-%E7%B7%A8%E8%AD%AF%E5%99%A8%E5%85%A7%E5%BB%BA%E8%BF%BD%E8%B9%A4">GCC 編譯器內建追蹤</a></li>
<li><a href="#%E5%B0%88%E6%A5%AD%E5%87%BD%E6%95%B8%E8%BF%BD%E8%B9%A4%E5%B7%A5%E5%85%B7">專業函數追蹤工具</a></li>
<li><a href="#rust-%E8%BF%BD%E8%B9%A4%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88">Rust 追蹤解決方案</a></li>
<li><a href="#gdb-%E8%87%AA%E5%8B%95%E5%8C%96%E8%BF%BD%E8%B9%A4">GDB 自動化追蹤</a></li>
<li><a href="#%E7%B3%BB%E7%B5%B1%E7%B4%9A%E8%BF%BD%E8%B9%A4%E5%B7%A5%E5%85%B7">系統級追蹤工具</a></li>
<li><a href="#%E9%80%B2%E9%9A%8E%E8%BF%BD%E8%B9%A4%E6%8A%80%E8%A1%93">進階追蹤技術</a></li>
<li><a href="#%E8%A6%96%E8%A6%BA%E5%8C%96%E5%B7%A5%E5%85%B7">視覺化工具</a></li>
<li><a href="#%E5%AF%A6%E7%94%A8%E5%BB%BA%E8%AD%B0%E8%88%87%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90">實用建議與最佳實踐</a></li>
<li><a href="#%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C%E8%88%87%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88">常見問題與解決方案</a></li>
</ul>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>函數追蹤是理解程式執行流程、診斷問題和優化效能的關鍵技術。本指南涵蓋從基礎到進階的各種追蹤方法，適用於 C++、Rust 等系統程式語言。</p>
<h3 id="為什麼需要函數追蹤"><a class="header" href="#為什麼需要函數追蹤">為什麼需要函數追蹤？</a></h3>
<ul>
<li><strong>程式碼理解</strong>: 快速掌握大型專案的架構和執行邏輯</li>
<li><strong>效能優化</strong>: 識別熱點函數和效能瓶頸</li>
<li><strong>除錯診斷</strong>: 追蹤難以重現的錯誤和異常行為</li>
<li><strong>記憶體分析</strong>: 發現記憶體洩漏和不當使用</li>
<li><strong>並發分析</strong>: 理解多執行緒程式的執行順序</li>
</ul>
<h2 id="gcc-編譯器內建追蹤"><a class="header" href="#gcc-編譯器內建追蹤">GCC 編譯器內建追蹤</a></h2>
<h3 id="finstrument-functions-方法"><a class="header" href="#finstrument-functions-方法">finstrument-functions 方法</a></h3>
<p>GCC 內建函數插樁是最直接的方法：</p>
<pre><code class="language-bash"># 編譯時加入 -finstrument-functions
gcc -finstrument-functions -g your_program.cpp -o your_program

# 排除特定函數不被插樁
gcc -finstrument-functions -finstrument-functions-exclude-function-list=main,foo -g your_program.cpp

# 排除特定檔案
gcc -finstrument-functions -finstrument-functions-exclude-file-list=/usr/include -g your_program.cpp
</code></pre>
<h4 id="基礎實現"><a class="header" href="#基礎實現">基礎實現</a></h4>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;execinfo.h&gt;
#include &lt;dlfcn.h&gt;

extern "C" __attribute__((no_instrument_function))
void __cyg_profile_func_enter(void *callee, void *caller) {
    Dl_info info;
    if (dladdr(callee, &amp;info)) {
        printf("&gt;&gt;&gt; 進入函數: %s [%p]\n", 
               info.dli_sname ? info.dli_sname : "unknown", callee);
    }
}

extern "C" __attribute__((no_instrument_function))  
void __cyg_profile_func_exit(void *callee, void *caller) {
    Dl_info info;
    if (dladdr(callee, &amp;info)) {
        printf("&lt;&lt;&lt; 離開函數: %s [%p]\n", 
               info.dli_sname ? info.dli_sname : "unknown", callee);
    }
}
</code></pre>
<h4 id="進階實現帶時間戳和調用深度"><a class="header" href="#進階實現帶時間戳和調用深度">進階實現：帶時間戳和調用深度</a></h4>
<pre><code class="language-cpp">#include &lt;chrono&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;

class FunctionTracer {
private:
    static thread_local int depth_;
    static thread_local std::stack&lt;std::chrono::high_resolution_clock::time_point&gt; time_stack_;
    static std::mutex output_mutex_;
    
public:
    static void enter(void* func, void* caller) {
        auto now = std::chrono::high_resolution_clock::now();
        time_stack_.push(now);
        
        std::lock_guard&lt;std::mutex&gt; lock(output_mutex_);
        for (int i = 0; i &lt; depth_; ++i) printf("  ");
        printf("→ %p\n", func);
        depth_++;
    }
    
    static void exit(void* func, void* caller) {
        auto now = std::chrono::high_resolution_clock::now();
        auto duration = now - time_stack_.top();
        time_stack_.pop();
        depth_--;
        
        std::lock_guard&lt;std::mutex&gt; lock(output_mutex_);
        for (int i = 0; i &lt; depth_; ++i) printf("  ");
        printf("← %p [%lld µs]\n", func, 
               std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(duration).count());
    }
};

extern "C" __attribute__((no_instrument_function))
void __cyg_profile_func_enter(void *callee, void *caller) {
    FunctionTracer::enter(callee, caller);
}

extern "C" __attribute__((no_instrument_function))
void __cyg_profile_func_exit(void *callee, void *caller) {
    FunctionTracer::exit(callee, caller);
}
</code></pre>
<h3 id="call-stack-logger-專案"><a class="header" href="#call-stack-logger-專案">Call Stack Logger 專案</a></h3>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/TomaszAugustyn/call-stack-logger">TomaszAugustyn/call-stack-logger</a></li>
<li><strong>功能特色</strong>:
<ul>
<li>自動函數名稱解析和記憶體地址轉換</li>
<li>帶縮進的調用樹狀結構輸出</li>
<li>時間戳記錄和調用深度追蹤</li>
<li>支援多執行緒程式的完整追蹤</li>
<li>輸出到檔案或標準輸出</li>
</ul>
</li>
</ul>
<h3 id="clang-編譯器支援"><a class="header" href="#clang-編譯器支援">Clang 編譯器支援</a></h3>
<p>Clang 也支援類似的功能：</p>
<pre><code class="language-bash"># Clang 使用相同的選項
clang++ -finstrument-functions -g program.cpp -o program

# Clang 特有的 XRay 追蹤
clang++ -fxray-instrument -g program.cpp -o program
XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic" ./program
</code></pre>
<h2 id="專業函數追蹤工具"><a class="header" href="#專業函數追蹤工具">專業函數追蹤工具</a></h2>
<h3 id="uftrace---強大的使用者空間追蹤工具"><a class="header" href="#uftrace---強大的使用者空間追蹤工具">uftrace - 強大的使用者空間追蹤工具</a></h3>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/namhyung/uftrace">namhyung/uftrace</a></li>
<li><strong>安裝</strong>:</li>
</ul>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install uftrace

# Fedora/RHEL
sudo dnf install uftrace

# 從原始碼編譯
git clone https://github.com/namhyung/uftrace.git
cd uftrace
./configure
make
sudo make install
</code></pre>
<h4 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h4>
<pre><code class="language-bash"># 編譯程式時加入追蹤選項
gcc -pg -g program.c -o program
# 或者
gcc -finstrument-functions -g program.c -o program

# 追蹤執行
uftrace record ./program
uftrace replay

# 即時追蹤並顯示
uftrace ./program

# 只顯示執行時間超過 1ms 的函數
uftrace -t 1ms ./program

# 追蹤特定函數
uftrace -F main -F process_data ./program

# 生成調用圖
uftrace graph
</code></pre>
<h4 id="進階功能"><a class="header" href="#進階功能">進階功能</a></h4>
<pre><code class="language-bash"># 記錄函數參數和返回值
uftrace record -A . -R . ./program

# 生成火焰圖
uftrace record ./program
uftrace dump --flame-graph | flamegraph.pl &gt; flame.svg

# 生成 Chrome tracing 格式
uftrace dump --chrome &gt; trace.json
# 在 Chrome 中開啟 chrome://tracing 並載入 trace.json

# 統計函數執行時間
uftrace report --stats

# 追蹤 Python 程式
uftrace record -t 1ms python3 script.py
</code></pre>
<h3 id="其他追蹤工具專案"><a class="header" href="#其他追蹤工具專案">其他追蹤工具專案</a></h3>
<h4 id="funtrace"><a class="header" href="#funtrace">funtrace</a></h4>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/yosefk/funtrace">yosefk/funtrace</a></li>
<li><strong>特色</strong>: 快速、小型函數調用追蹤器，適合嵌入式系統</li>
</ul>
<pre><code class="language-bash"># 使用範例
gcc -finstrument-functions program.c funtrace.c -ldl -o program
./program
</code></pre>
<h4 id="ftracer"><a class="header" href="#ftracer">ftracer</a></h4>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/finaldie/ftracer">finaldie/ftracer</a></li>
<li><strong>特色</strong>: 生成時間軸調用圖的工具包</li>
</ul>
<pre><code class="language-bash"># 編譯時連結 ftracer
gcc -finstrument-functions program.c -lftracer -o program
FTRACER_OUTPUT=trace.log ./program
ftracer_plot trace.log &gt; timeline.html
</code></pre>
<h4 id="tracer"><a class="header" href="#tracer">tracer</a></h4>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/mohsenmahroos/tracer">mohsenmahroos/tracer</a></li>
<li><strong>特色</strong>: 簡單的 C++ 追蹤類別，使用 RAII 模式</li>
</ul>
<pre><code class="language-cpp">#include "tracer.h"

void function() {
    TRACE_FUNC();  // 自動追蹤函數進入和離開
    // 函數邏輯
}
</code></pre>
<h3 id="valgrind-callgrind"><a class="header" href="#valgrind-callgrind">Valgrind Callgrind</a></h3>
<pre><code class="language-bash"># 編譯程式（需要調試符號）
gcc -g program.c -o program

# 使用 callgrind 追蹤
valgrind --tool=callgrind ./program

# 生成調用圖
callgrind_annotate callgrind.out.*

# 使用 KCachegrind 視覺化
kcachegrind callgrind.out.*
</code></pre>
<h2 id="rust-追蹤解決方案"><a class="header" href="#rust-追蹤解決方案">Rust 追蹤解決方案</a></h2>
<h3 id="tracing-crate---rust-官方推薦"><a class="header" href="#tracing-crate---rust-官方推薦">tracing crate - Rust 官方推薦</a></h3>
<h4 id="基本設置"><a class="header" href="#基本設置">基本設置</a></h4>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h4 id="使用範例"><a class="header" href="#使用範例">使用範例</a></h4>
<pre><pre class="playground"><code class="language-rust">use tracing::{instrument, info, warn, error, span, Level};
use tracing_subscriber;

// 自動為函數添加追蹤
#[instrument(level = "info", ret, err)]
async fn process_data(data: &amp;str) -&gt; Result&lt;String, Error&gt; {
    info!("Processing data: {}", data);
    
    // 創建子 span
    let span = span!(Level::DEBUG, "validation");
    let _enter = span.enter();
    
    if data.is_empty() {
        warn!("Empty data received");
        return Err(Error::EmptyData);
    }
    
    Ok(data.to_uppercase())
}

// 追蹤異步函數
#[instrument(skip(db), fields(user_id = %user_id))]
async fn fetch_user(db: &amp;Database, user_id: u64) -&gt; Result&lt;User, Error&gt; {
    let user = db.get_user(user_id).await?;
    info!("Found user: {}", user.name);
    Ok(user)
}

fn main() {
    // 初始化追蹤訂閱器
    tracing_subscriber::fmt()
        .with_max_level(Level::TRACE)
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .init();
    
    // 程式邏輯
}</code></pre></pre>
<h4 id="進階配置"><a class="header" href="#進階配置">進階配置</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn init_tracing() {
    let fmt_layer = tracing_subscriber::fmt::layer()
        .with_target(false)
        .with_timer(tracing_subscriber::fmt::time::uptime())
        .with_level(true)
        .with_thread_ids(true)
        .with_thread_names(true);
    
    // 添加過濾器
    let filter_layer = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "info,my_app=debug".into());
    
    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .init();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rftrace---rust-函數追蹤器"><a class="header" href="#rftrace---rust-函數追蹤器">rftrace - Rust 函數追蹤器</a></h3>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/hermit-os/rftrace">hermit-os/rftrace</a></li>
<li><strong>功能</strong>: 專為 Rust 設計的函數追蹤器，支援內核和使用者空間的完整追蹤</li>
</ul>
<h3 id="cargo-flamegraph"><a class="header" href="#cargo-flamegraph">cargo-flamegraph</a></h3>
<pre><code class="language-bash"># 安裝
cargo install flamegraph

# 生成火焰圖
cargo flamegraph --bin my_program

# 使用 release 模式並保留調試符號
cargo flamegraph --release -- my_arg1 my_arg2
</code></pre>
<h2 id="gdb-自動化追蹤"><a class="header" href="#gdb-自動化追蹤">GDB 自動化追蹤</a></h2>
<h3 id="gdb-腳本自動記錄"><a class="header" href="#gdb-腳本自動記錄">GDB 腳本自動記錄</a></h3>
<h4 id="基礎腳本"><a class="header" href="#基礎腳本">基礎腳本</a></h4>
<pre><code class="language-gdb"># trace_all.gdb
set pagination off
set logging file trace.log
set logging on
set height 0

# 為所有函數設置斷點
rbreak .*

# 定義自動執行的命令
commands
silent
printf "&gt;&gt;&gt; %s\n", $rip
backtrace 1
continue
end

# 執行程式
run
</code></pre>
<p>執行方式：</p>
<pre><code class="language-bash">gdb -x trace_all.gdb ./program
</code></pre>
<h4 id="進階腳本選擇性追蹤"><a class="header" href="#進階腳本選擇性追蹤">進階腳本：選擇性追蹤</a></h4>
<pre><code class="language-gdb"># selective_trace.gdb
set pagination off
set logging file trace.log
set logging on

# 只追蹤特定模組的函數
rbreak MyClass::.*
rbreak process_.*

# 記錄函數參數
commands
silent
printf "Function: "
x/i $pc
info args
info locals
continue
end

run
</code></pre>
<h4 id="python-擴展-gdb-腳本"><a class="header" href="#python-擴展-gdb-腳本">Python 擴展 GDB 腳本</a></h4>
<pre><code class="language-python"># trace_with_time.py
import gdb
import time

class FunctionTracer(gdb.Command):
    def __init__(self):
        super().__init__("trace-functions", gdb.COMMAND_USER)
        self.start_time = time.time()
        
    def invoke(self, arg, from_tty):
        # 設置所有函數斷點
        gdb.execute("rbreak .*")
        
        # 定義斷點處理
        def on_breakpoint(event):
            if isinstance(event, gdb.BreakpointEvent):
                frame = gdb.selected_frame()
                elapsed = time.time() - self.start_time
                print(f"[{elapsed:.6f}] {frame.name()}")
                gdb.execute("continue")
        
        gdb.events.stop.connect(on_breakpoint)
        gdb.execute("run")

FunctionTracer()
</code></pre>
<h2 id="系統級追蹤工具"><a class="header" href="#系統級追蹤工具">系統級追蹤工具</a></h2>
<h3 id="ltrace-和-strace"><a class="header" href="#ltrace-和-strace">ltrace 和 strace</a></h3>
<h4 id="ltrace---庫函數追蹤"><a class="header" href="#ltrace---庫函數追蹤">ltrace - 庫函數追蹤</a></h4>
<pre><code class="language-bash"># 基本使用
ltrace ./program

# 追蹤特定庫函數
ltrace -e malloc+free+strcpy ./program

# 顯示時間戳
ltrace -t ./program

# 追蹤子進程
ltrace -f ./program

# 統計函數調用
ltrace -c ./program

# 追蹤已執行的進程
ltrace -p $(pidof program)
</code></pre>
<h4 id="strace---系統調用追蹤"><a class="header" href="#strace---系統調用追蹤">strace - 系統調用追蹤</a></h4>
<pre><code class="language-bash"># 基本使用
strace ./program

# 只追蹤特定系統調用
strace -e open,read,write ./program

# 追蹤網路相關調用
strace -e trace=network ./program

# 顯示調用時間
strace -T ./program

# 統計系統調用
strace -c ./program

# 追蹤所有子進程
strace -ff -o trace ./program
</code></pre>
<h3 id="systemtap"><a class="header" href="#systemtap">SystemTap</a></h3>
<pre><code class="language-bash"># 安裝
sudo apt-get install systemtap systemtap-runtime

# 簡單的函數追蹤腳本
# trace_functions.stp
probe process("./program").function("*") {
    printf("%s -&gt; %s\n", thread_indent(1), probefunc())
}

probe process("./program").function("*").return {
    printf("%s &lt;- %s\n", thread_indent(-1), probefunc())
}

# 執行
sudo stap trace_functions.stp -c ./program
</code></pre>
<h3 id="ebpfbcc-工具"><a class="header" href="#ebpfbcc-工具">eBPF/BCC 工具</a></h3>
<pre><code class="language-python">#!/usr/bin/python
# trace_functions.py
from bcc import BPF

# BPF 程式
bpf_text = """
#include &lt;uapi/linux/ptrace.h&gt;

int trace_func_entry(struct pt_regs *ctx) {
    u64 pid = bpf_get_current_pid_tgid();
    bpf_trace_printk("PID %d entered function\\n", pid &gt;&gt; 32);
    return 0;
}
"""

# 載入 BPF 程式
b = BPF(text=bpf_text)
b.attach_uprobe(name="./program", sym="main", fn_name="trace_func_entry")

# 讀取輸出
b.trace_print()
</code></pre>
<h2 id="進階追蹤技術"><a class="header" href="#進階追蹤技術">進階追蹤技術</a></h2>
<h3 id="intel-vtune-profiler"><a class="header" href="#intel-vtune-profiler">Intel VTune Profiler</a></h3>
<pre><code class="language-bash"># 收集數據
vtune -collect hotspots ./program

# 分析結果
vtune -report summary -r r000hs

# GUI 模式
vtune-gui r000hs
</code></pre>
<h3 id="amd-uprof"><a class="header" href="#amd-uprof">AMD uProf</a></h3>
<pre><code class="language-bash"># 收集效能數據
AMDuProfCLI collect --config tbp ./program

# 生成報告
AMDuProfCLI report -i AMDuProf-program/
</code></pre>
<h3 id="linux-perf"><a class="header" href="#linux-perf">Linux Perf</a></h3>
<pre><code class="language-bash"># 記錄函數調用
perf record -g ./program

# 查看報告
perf report

# 生成火焰圖
perf record -F 99 -g ./program
perf script | stackcollapse-perf.pl | flamegraph.pl &gt; perf.svg

# 即時監控
perf top -g
</code></pre>
<h3 id="dtrace-macosfreebsdsolaris"><a class="header" href="#dtrace-macosfreebsdsolaris">DTrace (macOS/FreeBSD/Solaris)</a></h3>
<pre><code class="language-d">/* trace_functions.d */
pid$target::*:entry
{
    printf("%*s-&gt; %s\n", ++indent * 2, "", probefunc);
}

pid$target::*:return
{
    printf("%*s&lt;- %s\n", indent-- * 2, "", probefunc);
}
</code></pre>
<p>執行：</p>
<pre><code class="language-bash">sudo dtrace -s trace_functions.d -c ./program
</code></pre>
<h2 id="視覺化工具"><a class="header" href="#視覺化工具">視覺化工具</a></h2>
<h3 id="火焰圖-flame-graphs"><a class="header" href="#火焰圖-flame-graphs">火焰圖 (Flame Graphs)</a></h3>
<pre><code class="language-bash"># 安裝 FlameGraph 工具
git clone https://github.com/brendangregg/FlameGraph
cd FlameGraph

# 使用 perf 生成火焰圖
perf record -F 99 -ag -- ./program
perf script | ./stackcollapse-perf.pl | ./flamegraph.pl &gt; flame.svg

# 使用 uftrace 生成火焰圖
uftrace record ./program
uftrace dump --flame-graph | ./flamegraph.pl &gt; flame.svg
</code></pre>
<h3 id="perfetto-ui"><a class="header" href="#perfetto-ui">Perfetto UI</a></h3>
<pre><code class="language-bash"># 生成 Perfetto 格式追蹤
uftrace record ./program
uftrace dump --chrome &gt; trace.json

# 開啟 https://ui.perfetto.dev/ 並載入 trace.json
</code></pre>
<h3 id="kcachegrind"><a class="header" href="#kcachegrind">KCachegrind</a></h3>
<pre><code class="language-bash"># 生成 callgrind 數據
valgrind --tool=callgrind ./program

# 視覺化
kcachegrind callgrind.out.*
</code></pre>
<h3 id="graphviz-調用圖"><a class="header" href="#graphviz-調用圖">Graphviz 調用圖</a></h3>
<pre><code class="language-bash"># 使用 uftrace 生成 dot 檔案
uftrace record ./program
uftrace graph -f dot &gt; call_graph.dot

# 轉換為圖片
dot -Tpng call_graph.dot -o call_graph.png
dot -Tsvg call_graph.dot -o call_graph.svg
</code></pre>
<h2 id="實用建議與最佳實踐"><a class="header" href="#實用建議與最佳實踐">實用建議與最佳實踐</a></h2>
<h3 id="快速開始方案"><a class="header" href="#快速開始方案">快速開始方案</a></h3>
<h4 id="c-專案"><a class="header" href="#c-專案">C++ 專案</a></h4>
<ol>
<li><strong>輕量級追蹤</strong>: 使用 <code>-finstrument-functions</code> 配合簡單的追蹤函數</li>
<li><strong>完整分析</strong>: 使用 uftrace 配合 <code>-pg</code> 編譯選項</li>
<li><strong>效能分析</strong>: 使用 perf 或 VTune</li>
<li><strong>記憶體分析</strong>: 使用 Valgrind 配合 Callgrind</li>
</ol>
<h4 id="rust-專案"><a class="header" href="#rust-專案">Rust 專案</a></h4>
<ol>
<li><strong>開發階段</strong>: 使用 tracing crate 的 <code>#[instrument]</code> 宏</li>
<li><strong>效能分析</strong>: 使用 cargo-flamegraph</li>
<li><strong>系統級追蹤</strong>: 使用 uftrace 或 perf</li>
</ol>
<h4 id="無法重編譯的程式"><a class="header" href="#無法重編譯的程式">無法重編譯的程式</a></h4>
<ol>
<li><strong>動態追蹤</strong>: 使用 GDB 自動化腳本</li>
<li><strong>系統調用</strong>: 使用 strace</li>
<li><strong>庫函數</strong>: 使用 ltrace</li>
<li><strong>進階追蹤</strong>: 使用 SystemTap 或 eBPF</li>
</ol>
<h3 id="效能考量"><a class="header" href="#效能考量">效能考量</a></h3>
<h4 id="降低追蹤開銷"><a class="header" href="#降低追蹤開銷">降低追蹤開銷</a></h4>
<pre><code class="language-cpp">// 使用條件編譯
#ifdef ENABLE_TRACING
    #define TRACE_FUNC() FunctionTracer tracer(__FUNCTION__)
#else
    #define TRACE_FUNC()
#endif

// 採樣追蹤
static std::atomic&lt;int&gt; sample_counter{0};
extern "C" void __cyg_profile_func_enter(void *callee, void *caller) {
    if (++sample_counter % 100 == 0) {  // 只追蹤 1% 的調用
        // 執行追蹤
    }
}
</code></pre>
<h4 id="過濾策略"><a class="header" href="#過濾策略">過濾策略</a></h4>
<pre><code class="language-bash"># uftrace: 時間過濾
uftrace -t 10us ./program  # 只顯示超過 10 微秒的函數

# uftrace: 深度過濾
uftrace -D 3 ./program  # 只追蹤 3 層深度

# uftrace: 函數過濾
uftrace -F main -F 'process_*' ./program  # 只追蹤特定函數
uftrace -N 'std::*' ./program  # 排除 std 命名空間
</code></pre>
<h3 id="多執行緒追蹤"><a class="header" href="#多執行緒追蹤">多執行緒追蹤</a></h3>
<pre><code class="language-cpp">// 執行緒安全的追蹤實現
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_map&gt;

class ThreadSafeTracer {
private:
    static std::mutex mutex_;
    static std::unordered_map&lt;std::thread::id, int&gt; depth_map_;
    
public:
    static void enter(void* func) {
        std::lock_guard&lt;std::mutex&gt; lock(mutex_);
        auto tid = std::this_thread::get_id();
        auto&amp; depth = depth_map_[tid];
        
        std::cout &lt;&lt; "[" &lt;&lt; tid &lt;&lt; "] ";
        for (int i = 0; i &lt; depth; ++i) std::cout &lt;&lt; "  ";
        std::cout &lt;&lt; "→ " &lt;&lt; func &lt;&lt; std::endl;
        depth++;
    }
};
</code></pre>
<h3 id="分散式追蹤"><a class="header" href="#分散式追蹤">分散式追蹤</a></h3>
<h4 id="opentelemetry-整合"><a class="header" href="#opentelemetry-整合">OpenTelemetry 整合</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust with OpenTelemetry
use opentelemetry::{global, sdk::propagation::TraceContextPropagator};
use tracing_subscriber::layer::SubscriberExt;

fn init_telemetry() {
    global::set_text_map_propagator(TraceContextPropagator::new());
    
    let tracer = opentelemetry_jaeger::new_pipeline()
        .with_service_name("my_service")
        .install_simple()
        .unwrap();
    
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    tracing_subscriber::registry()
        .with(telemetry)
        .init();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="常見問題與解決方案"><a class="header" href="#常見問題與解決方案">常見問題與解決方案</a></h2>
<h3 id="問題-1符號解析失敗"><a class="header" href="#問題-1符號解析失敗">問題 1：符號解析失敗</a></h3>
<p><strong>症狀</strong>: 只看到記憶體地址，沒有函數名稱</p>
<p><strong>解決方案</strong>:</p>
<pre><code class="language-bash"># 確保編譯時包含調試符號
gcc -g -O0 program.c -o program

# 保留符號表（即使在 strip 後）
gcc -g program.c -o program
objcopy --only-keep-debug program program.debug
strip program
objcopy --add-gnu-debuglink=program.debug program

# 使用 addr2line 解析地址
addr2line -e program 0x401234
</code></pre>
<h3 id="問題-2追蹤開銷過大"><a class="header" href="#問題-2追蹤開銷過大">問題 2：追蹤開銷過大</a></h3>
<p><strong>症狀</strong>: 程式執行速度明顯變慢</p>
<p><strong>解決方案</strong>:</p>
<pre><code class="language-cpp">// 1. 使用編譯時開關
#ifdef DEBUG_TRACE
    // 追蹤程式碼
#endif

// 2. 動態開關
bool g_tracing_enabled = false;
extern "C" void __cyg_profile_func_enter(void *callee, void *caller) {
    if (!g_tracing_enabled) return;
    // 追蹤邏輯
}

// 3. 選擇性追蹤
// 只追蹤特定模組
gcc -finstrument-functions src/core/*.c -c
gcc src/other/*.c -c  # 不加追蹤選項
</code></pre>
<h3 id="問題-3輸出過多難以分析"><a class="header" href="#問題-3輸出過多難以分析">問題 3：輸出過多難以分析</a></h3>
<p><strong>症狀</strong>: 追蹤日誌檔案過大，難以找到關鍵資訊</p>
<p><strong>解決方案</strong>:</p>
<pre><code class="language-bash"># 1. 使用過濾器
uftrace -F main -D 3 ./program  # 只看 main 函數 3 層深度

# 2. 後處理過濾
grep "error\|warning" trace.log

# 3. 使用結構化日誌
# 輸出 JSON 格式，便於程式化處理
uftrace dump --format=json &gt; trace.json
jq '.[] | select(.name | contains("process"))' trace.json
</code></pre>
<h3 id="問題-4靜態連結程式無法追蹤"><a class="header" href="#問題-4靜態連結程式無法追蹤">問題 4：靜態連結程式無法追蹤</a></h3>
<p><strong>症狀</strong>: ltrace 無輸出，uftrace 無法工作</p>
<p><strong>解決方案</strong>:</p>
<pre><code class="language-bash"># 1. 使用 strace（系統調用仍可追蹤）
strace ./static_program

# 2. 重新編譯為動態連結
gcc -dynamic program.c -o program

# 3. 使用 GDB 或 SystemTap
gdb ./static_program
systemtap -e 'probe process("static_program").function("*") { println(probefunc()) }'
</code></pre>
<h3 id="問題-5即時系統的追蹤"><a class="header" href="#問題-5即時系統的追蹤">問題 5：即時系統的追蹤</a></h3>
<p><strong>症狀</strong>: 追蹤影響即時性能</p>
<p><strong>解決方案</strong>:</p>
<pre><code class="language-cpp">// 使用無鎖資料結構
#include &lt;atomic&gt;
#include &lt;array&gt;

class LockFreeTracer {
    struct TraceEntry {
        void* func;
        uint64_t timestamp;
    };
    
    static std::array&lt;TraceEntry, 10000&gt; buffer_;
    static std::atomic&lt;size_t&gt; index_;
    
public:
    static void trace(void* func) {
        size_t idx = index_.fetch_add(1) % buffer_.size();
        buffer_[idx] = {func, get_timestamp()};
    }
};
</code></pre>
<h3 id="使用場景建議"><a class="header" href="#使用場景建議">使用場景建議</a></h3>
<div class="table-wrapper"><table><thead><tr><th>場景</th><th>推薦工具</th><th>理由</th></tr></thead><tbody>
<tr><td>理解新專案結構</td><td>uftrace + 視覺化</td><td>快速生成調用圖</td></tr>
<tr><td>效能瓶頸分析</td><td>perf + 火焰圖</td><td>低開銷，準確採樣</td></tr>
<tr><td>記憶體問題診斷</td><td>Valgrind + GDB</td><td>完整的記憶體追蹤</td></tr>
<tr><td>生產環境診斷</td><td>eBPF/SystemTap</td><td>動態追蹤，無需重啟</td></tr>
<tr><td>單元測試覆蓋</td><td>gcov + lcov</td><td>程式碼覆蓋率分析</td></tr>
<tr><td>分散式系統</td><td>OpenTelemetry</td><td>跨服務追蹤</td></tr>
<tr><td>嵌入式系統</td><td>自定義輕量級追蹤</td><td>資源受限環境</td></tr>
</tbody></table>
</div>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>函數追蹤是強大的程式分析技術，選擇合適的工具和方法能夠大幅提升開發和除錯效率。從簡單的編譯器插樁到複雜的動態追蹤，每種方法都有其適用場景。關鍵是根據具體需求選擇最合適的解決方案，並在追蹤開銷和資訊價值之間找到平衡。</p>
<h3 id="快速決策樹"><a class="header" href="#快速決策樹">快速決策樹</a></h3>
<ol>
<li>
<p><strong>能否重新編譯？</strong></p>
<ul>
<li>是 → 使用 <code>-finstrument-functions</code> 或 <code>-pg</code></li>
<li>否 → 使用 GDB/ltrace/strace</li>
</ul>
</li>
<li>
<p><strong>需要視覺化？</strong></p>
<ul>
<li>是 → uftrace + Chrome tracing 或火焰圖</li>
<li>否 → 簡單文字輸出即可</li>
</ul>
</li>
<li>
<p><strong>效能敏感？</strong></p>
<ul>
<li>是 → 使用採樣式追蹤（perf）或 eBPF</li>
<li>否 → 完整插樁追蹤</li>
</ul>
</li>
<li>
<p><strong>多執行緒程式？</strong></p>
<ul>
<li>是 → 確保追蹤工具支援執行緒安全</li>
<li>否 → 任何工具皆可</li>
</ul>
</li>
</ol>
<p>記住：好的追蹤策略應該是漸進式的，從簡單開始，根據需要逐步增加複雜度。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tools/cpp-analysis-tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tools/solana_token_guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tools/cpp-analysis-tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tools/solana_token_guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
