<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Claude Code Skills 完整教學 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="claude-skill-教學如何建立自己的-skill有哪些-claude-code-技巧"><a class="header" href="#claude-skill-教學如何建立自己的-skill有哪些-claude-code-技巧">Claude Skill 教學｜如何建立自己的 Skill？有哪些 Claude Code 技巧？</a></h1>
<p>如果你已經用 Claude Code 一段時間，每次開新專案，Claude 都像個剛入職的新人，什麼都得從頭說明。你得告訴它「我們團隊用的是這套 Coding Style」、「Deploy 流程是這樣跑的」、「這個 API 要這樣串」。講一次還好，講十次、二十次之後就會開始懷疑到底我花錢是在用 AI 還是在當 AI 的助理？</p>
<p>你應該已經知道 CLAUDE.md 這個檔案的用途。把專案的慣例和規則寫在 CLAUDE.md 裡，Claude Code 啟動時就會自動讀取，省去每次重複解釋的麻煩。CLAUDE.md 常被拿來放專案指引，雖然 Claude Code 也支援使用者層級的 ~/.claude/CLAUDE.md 可以跨專案共用，但不管放哪一層，指引一長就會遇到難維護、而且啟動時全部載入的問題，我還遇過 Claude Code 提醒我再繼續下去效能會變差⋯⋯。</p>
<p>重點是，CLAUDE.md 的內容會在專案啟動的時候就全部載入，不管當前的任務用不用得到。</p>
<p>有沒有什麼方法，可以把「專業知識」打包成獨立的模組，讓 Agent 自己判斷什麼時候該用、只載入需要的部分、而且可以跨專案重複使用？嘿嘿，有的，就是 Anthropic 在 2025 年推出的 Skills 功能。</p>
<h2 id="什麼是-skills"><a class="header" href="#什麼是-skills">什麼是 Skills？</a></h2>
<p>根據 Anthropic 的官方定義，Skills 是這樣的東西：</p>
<blockquote>
<p><strong>Skills are modular, self-contained packages that extend Claude's capabilities by providing specialized knowledge, workflows, and tools. Think of them as 'onboarding guides' for specific domains or tasks—they transform Claude from a general-purpose agent into a specialized agent equipped with procedural knowledge.</strong></p>
</blockquote>
<p>翻成白話文就是： <strong>Skills 是一種打包好的「專業技能包」，可以把 Claude 從一個什麼好像都略懂的通才，變成某個領域的專家</strong> 。</p>
<p>想像你開了一間小吃店，你是一位什麼料理都會做、都能做但可能都做的不太好吃的廚師。有天我經過你的小吃店，我看你骨骼精奇，是一位百年難得一見的練武奇才，覺得維護世界的和平就要靠你了，所以決定給你一本「台南小吃完全手冊」，裡面寫著擔仔麵的湯頭怎麼熬、肉燥要用什麼部位的豬肉、蝦仁要去哪個市場買最新鮮、還有那個獨門醬油膏的調配比例。看完這本秘笈之後，你就能做出道地的府城味了。</p>
<p>Skills 就是這本「武功秘笈」。Skills 能提供的東西很多，包括：</p>
<ul>
<li><strong>專業工作流程：</strong> 多步驟的作業程序，例如「怎麼做 Code Review」、「怎麼處理 PR」</li>
<li><strong>工具整合：</strong> 跟特定檔案格式或 API 互動的方法，例如「怎麼處理 PDF」</li>
<li><strong>領域專業知識：</strong> 你們公司或團隊特有的商業邏輯和慣例</li>
<li><strong>資源：</strong> 腳本、參考文件、範本等執行任務時需要的素材</li>
</ul>
<h2 id="五分鐘速成你只需要知道這些"><a class="header" href="#五分鐘速成你只需要知道這些">五分鐘速成：你只需要知道這些</a></h2>
<p><strong>Skills 是什麼？</strong>
一個資料夾 + 一個 SKILL.md 檔案，裡面寫著「什麼時候該用這個技能」和「怎麼用」。</p>
<p><strong>為什麼要用？</strong>
解決三個痛點：</p>
<ol>
<li><strong>每次都要重複說明</strong>：不用再每個專案都從頭教 Claude 你們的規範</li>
<li><strong>CLAUDE.md 太肥</strong>：專案指引越寫越長，啟動時全部載入很浪費</li>
<li><strong>知識難以重用</strong>：這個專案寫過的規則，下個專案又要重寫一遍</li>
</ol>
<p><strong>怎麼用？三步驟</strong></p>
<p>第一步，建立資料夾和檔案：</p>
<pre><code class="language-bash">mkdir my-first-skill
cd my-first-skill
</code></pre>
<p>第二步，建立 SKILL.md：</p>
<pre><code class="language-markdown">---
name: my-first-skill
description: 告訴 Claude 什麼時候該用這個 Skill
---

# 我的第一個 Skill

這裡寫 Claude 需要遵循的規則和步驟...
</code></pre>
<p>第三步，放到正確位置：</p>
<ul>
<li><code>~/.claude/skills/my-first-skill/</code> - 個人層級，所有專案都能用</li>
<li><code>你的專案/.claude/skills/my-first-skill/</code> - 專案層級，只有這個專案能用</li>
</ul>
<p>完成！Claude 會自動判斷什麼時候該載入這個 Skill。</p>
<p><strong>關鍵概念：Progressive Disclosure（漸進式揭露）</strong></p>
<p>想像你去圖書館借書：</p>
<ul>
<li><strong>Metadata（100 tokens）</strong> = 書的封面和簡介 → Claude 用這個判斷「要不要借這本書」</li>
<li><strong>Instructions（5000 tokens）</strong> = 書的目錄和重點章節 → Claude 覺得有用才會翻開來讀</li>
<li><strong>Resources（無限制）</strong> = 書裡的附錄、參考資料 → Claude 需要時才會查閱</li>
</ul>
<p>這樣設計的好處：不會每次對話都把所有知識塞進去，用多少拿多少，省 token 又有效率。</p>
<hr />
<p>好了，速成講完了，下面是完整教學 👇</p>
<h2 id="skills-長什麼樣子"><a class="header" href="#skills-長什麼樣子">Skills 長什麼樣子？</a></h2>
<p>一個 Skills 的基本結構很簡單，至少需要一個 SKILL.md 檔案：</p>
<pre><code>skill-name/  
└── SKILL.md   # 必要的  

</code></pre>
<p>這個 SKILL.md 檔案開頭必須包含一段 YAML frontmatter：</p>
<pre><code>---  
name: skill-name  
description: A description of what this skill does and when to use it.  
---  

</code></pre>
<p>根據 <a href="https://agentskills.io/specification">agentskills.io</a> 的規格，<strong>name</strong> 欄位有一些規則要遵守：</p>
<ul>
<li>
<p>長度在 1 到 64 個字元之間</p>
</li>
<li>
<p>只能用小寫字母、數字和 -</p>
</li>
<li>
<p>不能以 - 開頭或結尾，也不能有連續的 -</p>
</li>
<li>
<p>必須與目錄名稱一致，待會我們實作的時候就會看到</p>
<p><strong>description 欄位也有限制：</strong></p>
</li>
<li>
<p>長度在 1 到 1024 個字元之間，所以這裡不是寫執行細節的地方</p>
</li>
<li>
<p>應該描述這個 Skills 做什麼、什麼時候該用</p>
</li>
</ul>
<p>frontmatter 之後的內容才是給 Agent 看的指令內容。你可以在裡面寫任何你想讓 Agent 知道的東西，例如操作步驟、注意事項、範例用法等等。如果你的 Skills 比較複雜，需要額外的腳本或參考資料，可以建立這樣的目錄結構：</p>
<pre><code>skill-name/  
├── SKILL.md      # 必要的  
├── scripts/      # 可執行的程式碼（Python、Bash、JavaScript）  
├── references/   # 額外的參考文件  
└── assets/       # 靜態資源（範本、圖片、資料檔）  

</code></pre>
<p>根據 <a href="https://agentskills.io/specification">Agent Skills 規格</a>，這三個目錄都是 Optional directories，也就是要加不加都可以。這些目錄名稱是規格建議的標準結構，讓不同的 Skills 有一致的組織方式。Claude 是透過你在 SKILL.md 裡的引用來發現這些檔案的，所以你需要在 SKILL.md 裡明確引用，Claude 才會知道它們的存在。</p>
<h2 id="progressive-disclosure是什麼"><a class="header" href="#progressive-disclosure是什麼">Progressive Disclosure是什麼？</a></h2>
<p>這裡要講一個我認為 Skills 設計得最漂亮的地方，叫做 Progressive Disclosure（漸進式揭露）。</p>
<p>這概念有點像用 Google Maps 導航。當輸入目的地之後，它不會一次把整條路線的每個細節都唸出來，而是先給一個大方向，例如「往北走，大約 10 分鐘後右轉」。等快到路口了，才會接著說「前方 50 公尺右轉，進入衡陽路」。如果中途想找加油站或停車場，它才會載入附近的資訊，Skills 的運作方式就是這樣。</p>
<p>根據 Anthropic 部落格的<a href="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills">說明</a>，Skills 的內容分成三層：</p>
<p><strong>第一層是 Metadata</strong> ，大概只有 100 個 tokens 左右。這層只包含 name 和 description 兩個欄位。當 Claude Code 啟動的時候，會預載所有已安裝 Skills 的 Metadata，用來判斷「這個任務跟哪些 Skills 有關」。</p>
<p><strong>第二層是 Instructions</strong> ，就是 SKILL.md 的主體內容。依 <a href="https://agentskills.io/specification">Agent Skills 規格</a>建議，這層最好控制在 5000 個 tokens 以內。當 Claude 判斷某個 Skills 跟當前任務相關，才會把這層載入。</p>
<p><strong>第三層是 Resources</strong> ，就是 scripts/、references/、assets/ 這些目錄裡的檔案。這些內容是按需載入的，Claude 需要用到哪個檔案才會去讀取。</p>
<p>這樣設計的好處在於只要把 Skills 正確地分層，由於檔案和資源是按需讀取的，理論上可以在一個 Skills 裡打包無限量的知識。在 Blog 文章裡有提到一句：</p>
<p>因為 context window 是有限的，如果每次對話都把所有知識塞進去，就算是像是有百萬 context window 的 Gemini，撐爆也只是早晚的問題。Progressive Disclosure 的設計讓 Claude 可以「用多少、拿多少」，不浪費 context 又能在需要的時候取得足夠完整的資訊。</p>
<h2 id="skills-跟其他機制有什麼不同"><a class="header" href="#skills-跟其他機制有什麼不同">Skills 跟其他機制有什麼不同？</a></h2>
<p>如果你用過 Claude Code 一段時間，應該會發現有好幾種方法可以「客製化」Claude 的行為。Skills 跟其他機制有什麼差別？什麼時候該用哪一種？我整理一個比較表：</p>
<div class="table-wrapper"><table><thead><tr><th>機制</th><th>觸發方式</th><th>持久性</th><th>內容類型</th><th>載入時機</th><th>可包含程式碼</th><th>適用場景</th></tr></thead><tbody>
<tr><td>Skills</td><td>Claude 自動判斷何時啟用（根據 description）</td><td>跨對話、跨專案可用</td><td>程序性知識 + 可執行腳本</td><td>動態載入（Progressive Disclosure）</td><td>是</td><td>重複性專業工作流程、需要 Claude 主動判斷的情境</td></tr>
<tr><td>Custom Commands</td><td>使用者輸入 /command（也可引導 Claude 代為呼叫）</td><td>專案或個人層級</td><td>Prompt 範本</td><td>使用者觸發時載入</td><td>否（單一 prompt 檔）</td><td>固定格式的重複操作、使用者明確知道要做什麼的情境</td></tr>
<tr><td>MCP</td><td>工具呼叫</td><td>啟動時載入</td><td>外部服務連接</td><td>按需呼叫</td><td>是（server 端）</td><td>連接外部 API、資料庫、檔案系統</td></tr>
<tr><td>Subagents</td><td>Claude 自動委派或手動啟動</td><td>任務期間</td><td>獨立 AI 實例</td><td>需要時建立</td><td>是</td><td>需要獨立 context、平行處理、專門化任務</td></tr>
</tbody></table>
</div>
<p>我來解釋一下這些機制的差異。</p>
<h3 id="custom-commands機制"><a class="header" href="#custom-commands機制">Custom Commands機制</a></h3>
<p>Custom Commands（也就是斜線命令）需要你手動輸入 /say-something 才會觸發。根據<a href="https://code.claude.com/docs/en/slash-commands">官方文件</a>的說法，斜線命令是「A Markdown file containing a prompt that Claude executes when invoked」，也就是說它只能包含 prompt 範本，不會有程式腳本或其他資源。你可以把它想成一種「巨集」，預先寫好一段指令，之後一鍵展開執行。它適合用在你已經知道要做什麼的情況，例如每次 commit 前都要跑同一套檢查流程，像我就寫了好幾個這樣的指令，像是 /remove-comment 用來移除不必要的註解，或是 /sanitize-ai 用來清理 AI 產生的「機味」文字。</p>
<h3 id="skills機制"><a class="header" href="#skills機制">Skills機制</a></h3>
<p>但 Skills 不一樣，Agent 會自動根據當時的對話內容或情境判斷要不要啟用某個 Skill。假設你裝了一個翻譯用的 Skill，當我們跟 Agent 說「幫我把這段英文翻成中文」，Agent 會自己判斷「喔，這個任務跟翻譯有關，我應該要使用那個翻譯的 Skill」，不需要我們特別去觸發。</p>
<p>Skills 沒有像 Slash Commands 那樣「輸入固定 /xxx 就必定執行」的觸發機制，它主要由模型依 description 做相似度判斷來決定要不要啟用。官方文件說 Skills 是「model-invoked」，也就是由 Agent 自己決定什麼時候用。如果你需要手動觸發的功能，那應該用 Custom Commands 而不是 Skills。不過你可以在對話中明確提到 Skills 的功能來引導 Agent，例如說「用我們的翻譯規則把這段翻成中文」，讓 Agent 更容易判斷該啟用哪個 Skill。</p>
<h3 id="mcp機制"><a class="header" href="#mcp機制">MCP機制</a></h3>
<p>MCP（Model Context Protocol）也有類似的自動判斷機制，但兩者運作的層次不同。Skills 提供的是「知識」，Agent 載入後會根據這些知識來「指導自己」的行為。MCP 提供的是「工具」，Agent 會呼叫這些工具來執行具體操作。</p>
<p>再回到剛才翻譯的例子，如果我們要做翻譯，Skills 會告訴 Agent「翻譯的時候要用什麼語氣、專有名詞怎麼處理、哪些詞不要翻」，而 MCP 則是讓 Agent 可以存取你的術語表資料庫、或是呼叫 DeepL API 來輔助翻譯。一個是腦袋裡的知識，一個是手上的工具。</p>
<p>MCP 是用來連接外部服務的。如果我們需要請 Agent 存取資料庫、呼叫某個 API、或是操作檔案，就可以使用 MCP。根據<a href="https://code.claude.com/docs/en/mcp">官方定義</a>，MCP「enables Claude Code plugins to integrate with external services and APIs by providing structured tool access」。</p>
<p>是說每次有新東西出現，總是就會有些先知會丟出「取代論」的說法，最近社群有些討論說 Skills 會取代 MCP，但就我看並不會，因為這兩個解決的是不同層次的問題。Skills 是給 Agent「腦袋」，MCP 是給 Agent「手腳」。你可以同時用 Skills 教 Agent 怎麼做翻譯，又用 MCP 讓它能存取術語庫，兩者之間是互補而不是互斥或互相取代的關係。</p>
<p>至於 Subagents，根據<a href="https://code.claude.com/docs/en/sub-agents">官方說明</a>，它是「autonomous subprocesses that handle complex, multi-step tasks independently」。當一個任務太複雜、需要獨立的 context 空間、或是可以平行處理的時候，Claude 會啟動 Subagents 來幫忙。</p>
<p>簡單來說：</p>
<ul>
<li>想讓 Agent 自己判斷什麼時候用什麼專業知識？ <strong>用 Skills</strong></li>
<li>想手動觸發固定的操作流程？ <strong>用 Custom Commands</strong></li>
<li>想連接外部服務？ <strong>用 MCP</strong></li>
<li>想平行處理複雜任務？ <strong>讓 Claude 用 Subagents</strong></li>
</ul>
<p>這四個機制不是互斥的，可以同時運作。舉個例子：使用 Custom Command /review-pr 觸發 Code Review 流程，Claude 會載入 Code Review 的 Skills 來取得審查標準，同時透過 MCP 連接 GitHub API 拉取 PR 內容，如果 PR 改動的檔案很多，Claude 可能還會啟動 Subagents 平行審查不同的檔案。四個機制各司其職然後一起完成任務，看到 AI 很忙的樣子，看起來不是很酷嗎 :)</p>
<h3 id="實際案例對比"><a class="header" href="#實際案例對比">實際案例對比</a></h3>
<p>為了讓大家更清楚什麼時候該用哪個機制，我整理了幾個常見的實際案例：</p>
<p><strong>案例 1：處理 API 文件</strong></p>
<ul>
<li><strong>Skills 方式</strong>：建立 <code>api-doc-skill</code>，教 Agent「怎麼寫符合公司風格的 API 文件」、「必須包含哪些章節」、「範例程式碼的格式」等知識。當你說「幫我寫這個 endpoint 的文件」，Agent 會自動載入這個 Skill 並按照規範產出。</li>
<li><strong>Custom Commands 方式</strong>：建立 <code>/gen-api-doc</code> 指令，每次都執行固定的文件生成流程。你必須手動輸入 <code>/gen-api-doc</code> 來觸發，適合用在文件格式非常固定、不需要 Agent 判斷的情境。</li>
<li><strong>MCP 方式</strong>：連接 Swagger/OpenAPI 工具來讀取現有的 API 定義，或是連接文件管理系統來儲存產生的文件。</li>
</ul>
<p>在這個案例中，三者可以搭配使用：用 MCP 讀取 API 定義，用 Skills 指導文件撰寫風格，最後可以設定一個 Custom Command 把整個流程串起來。</p>
<p><strong>案例 2：Code Review</strong></p>
<ul>
<li><strong>Skills 方式</strong>：建立 <code>code-review-checklist</code> Skill，裡面包含你們團隊的審查標準、常見的 code smell、安全檢查項目等。Agent 會根據程式碼的類型（前端/後端/資料庫）自動載入對應的檢查清單。</li>
<li><strong>Custom Commands 方式</strong>：建立 <code>/review-pr</code> 指令，手動觸發完整的 PR 審查流程。每次執行都會跑一樣的步驟：拉取最新程式碼、執行 linter、檢查測試覆蓋率、產生審查報告。</li>
<li><strong>Subagents 方式</strong>：當 PR 包含大量檔案時，Claude 會自動啟動多個 Subagents 平行審查不同的檔案，最後彙整結果。</li>
<li><strong>MCP 方式</strong>：連接 GitHub API 拉取 PR 內容、留 comment、更新 PR 狀態。</li>
</ul>
<p><strong>案例 3：多語言翻譯</strong></p>
<ul>
<li><strong>Skills 方式</strong>：建立 <code>translation-skill</code>，教 Agent 你們的翻譯規範（例如專有名詞怎麼翻、語氣要正式還是輕鬆、哪些詞保留原文等）。當對話中出現「翻譯」、「i18n」等關鍵字，Agent 會自動載入這個 Skill。</li>
<li><strong>Custom Commands 方式</strong>：建立 <code>/translate-to-zh</code> 和 <code>/translate-to-en</code> 兩個指令，分別處理中英翻譯。適合用在翻譯方向固定、格式統一的情境。</li>
<li><strong>MCP 方式</strong>：連接翻譯 API（如 DeepL、Google Translate）來輔助翻譯，或是連接術語表資料庫來確保專有名詞的一致性。</li>
</ul>
<p><strong>案例 4：部署流程</strong></p>
<ul>
<li><strong>Skills 方式</strong>：建立 <code>deployment-guide</code> Skill，包含部署前的檢查清單、環境設定、rollback 步驟等。Agent 會根據部署環境（dev/staging/production）載入對應的注意事項。</li>
<li><strong>Custom Commands 方式</strong>：建立 <code>/deploy-staging</code> 和 <code>/deploy-prod</code> 等指令，固定執行特定環境的部署流程。</li>
<li><strong>MCP 方式</strong>：連接 CI/CD 系統（如 GitHub Actions、Jenkins）來實際執行部署，或是連接監控系統來確認部署狀態。</li>
<li><strong>Subagents 方式</strong>：在執行部署的同時，啟動另一個 Subagent 監控系統狀態，如果發現異常就立即通知。</li>
</ul>
<p>透過這些實際案例，應該可以更清楚看出各個機制的適用時機。記住一個原則：<strong>需要自動判斷用 Skills，需要手動觸發用 Custom Commands，需要連接外部服務用 MCP，需要平行處理用 Subagents</strong>。</p>
<h2 id="建立自己的-skill"><a class="header" href="#建立自己的-skill">建立自己的 Skill</a></h2>
<p>聽這麼多理論手癢了嗎？來實際動手做一個 Skills 吧！</p>
<h3 id="最小可行版本5-分鐘做出第一個-skill"><a class="header" href="#最小可行版本5-分鐘做出第一個-skill">最小可行版本：5 分鐘做出第一個 Skill</a></h3>
<p>如果你想先快速體驗一下 Skills 怎麼運作，這裡有一個超級簡單的範例，不到 10 行就能完成：</p>
<p><strong>第一步，建立資料夾：</strong></p>
<pre><code class="language-bash">mkdir -p ~/.claude/skills/hello-skill
cd ~/.claude/skills/hello-skill
</code></pre>
<p><strong>第二步，建立 SKILL.md：</strong></p>
<pre><code class="language-bash">cat &gt; SKILL.md &lt;&lt; 'EOF'
---
name: hello-skill
description: A simple greeting skill. Use when user says hello, hi, or greets you.
---

# Hello Skill

When the user greets you (says hello, hi, hey, etc.), respond with:

"你好！我是透過 Skill 學會打招呼的 Claude。這代表 Skill 已經成功啟用了！🎉"

Always use this exact greeting format when this skill is activated.
EOF
</code></pre>
<p><strong>第三步，測試：</strong>
重新啟動 Claude Code，然後跟它說「hello」，看看會不會出現上面那段特定的回應。</p>
<p><strong>成功了？恭喜！</strong> 你已經掌握 Skills 的核心概念了：</p>
<ul>
<li><code>name</code> 必須跟資料夾名稱一致</li>
<li><code>description</code> 告訴 Claude 什麼時候該用這個 Skill</li>
<li>SKILL.md 的內容就是給 Claude 的指令</li>
</ul>
<p>這個超簡單的範例只是讓你快速體驗 Skills 的運作方式。下面我們來做一個真正實用的 Skill。</p>
<hr />
<h3 id="實戰範例commit-message-helper"><a class="header" href="#實戰範例commit-message-helper">實戰範例：Commit Message Helper</a></h3>
<p>從一個大家比較常會遇到的情境開始講起。我猜很多工程師都不喜歡寫 Git 的 Commit Message，我也是。如果我想要建立一個可以幫忙處理 Commit Message 的 Skill，讓 Agent 不只幫我們寫，而且還要遵循特定格式...</p>
<h3 id="第一步建立一個資料夾名稱隨意"><a class="header" href="#第一步建立一個資料夾名稱隨意">第一步，建立一個資料夾，名稱隨意：</a></h3>
<pre><code>mkdir commit-message-helper  

</code></pre>
<h3 id="第二步在這個目錄裡建立-skillmd-檔案內容如下"><a class="header" href="#第二步在這個目錄裡建立-skillmd-檔案內容如下">第二步，在這個目錄裡建立 SKILL.md 檔案，內容如下：</a></h3>
<pre><code>---  
name: commit-message-helper  
description: Helps write Git commit messages following the Conventional Commits specification. Use this skill when the user asks to commit changes, write commit messages, or mentions git commits.  
---  

# Commit Message Helper  

When writing commit messages, follow these rules:  

## Format  

&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;  

&lt;body&gt;  

&lt;footer&gt;  

## Types  

- feat: A new feature  
- fix: A bug fix  
- docs: Documentation only changes  
- style: Changes that do not affect the meaning of the code  
- refactor: A code change that neither fixes a bug nor adds a feature  
- perf: A code change that improves performance  
- test: Adding missing tests or correcting existing tests  
- chore: Changes to the build process or auxiliary tools  

## Guidelines  

1. Subject line should be no longer than 50 characters  
2. Use imperative mood ("add feature" not "added feature")  
3. Do not end the subject line with a period  
4. Separate subject from body with a blank line  
5. Use the body to explain what and why, not how  

## Examples  

Good:  
feat(auth): add OAuth2 login support  

Implement OAuth2 authentication flow to allow users to log in  
with their Google or GitHub accounts.  

Closes #123  

Bad:  
updated stuff  

</code></pre>
<p><strong>別忘了 name 欄位要跟資料夾名稱一樣，這是規格要求的。</strong> 再來注意 description 欄位的寫法，這裡特別寫了「when the user asks to commit changes, write commit messages, or mentions git commits」，這樣 Claude 才知道「什麼時候」該啟用這個 Skill。description 寫得越具體，Claude 的判斷就越準確。</p>
<p>是說，如果不知道這個檔案的內容怎麼辦？問 AI 啊！把情境跟 AI 講，不管哪一家的 AI 應該都有辦法寫出來，上面的內容就是我請 Claude 幫我寫的。</p>
<p>如果你的 Skills 需要執行腳本，可以建立 scripts/ 目錄然後把程式碼放裡面。例如我想加一個驗證 commit message 格式的腳本，就把這個腳本放在 scripts 目錄裡，例如叫做 validate_commit.py：</p>
<pre><code>import re  
import sys  

def validate_commit_message(message):  
    pattern = r'^(feat|fix|docs|style|refactor|perf|test|chore)(\(.+\))?: .{1,50}'  
    if re.match(pattern, message.split('\n')[0]):  
        return True, "Valid commit message format"  
    return False, "Invalid format. Expected: type(scope): subject"  

if __name__ == "__main__":  
    message = sys.argv[1] if len(sys.argv) &gt; 1 else ""  
    valid, msg = validate_commit_message(message)  
    print(msg)  
    sys.exit(0 if valid else 1)  

</code></pre>
<p>光把腳本放進 scripts/ 目錄還不夠，你需要在 SKILL.md 裡加註說明，告知 Agent 這個腳本的存在和用法：</p>
<pre><code>## Validation  

Before committing, run the validation script to check the format:  

python scripts/validate_commit.py "your commit message"  

</code></pre>
<p>這樣 Agent 才知道有這個工具可以用。</p>
<p>最後，把這個 Skills 安裝到 Claude Code。有兩種放法：</p>
<p>放到 ~/.claude/skills/：這是個人層級，你在任何專案都能用<br />
放到專案的 .claude/skills/：這是專案層級，只有這個專案能用，但只要專案裡有這個 Skill，團隊成員也都能用。</p>
<p>萬一兩邊有同名的 Skill，根據官方文件，個人層級的會蓋過專案層級的 Skill。</p>
<h3 id="skillmd-撰寫模板"><a class="header" href="#skillmd-撰寫模板">SKILL.md 撰寫模板</a></h3>
<p>看完上面的例子，你應該對 Skills 的結構有基本概念了。不過如果要從零開始寫一個 SKILL.md，可能還是會不知道從何下手。這裡提供一個通用的模板，你可以直接套用：</p>
<pre><code class="language-markdown">---
name: your-skill-name
description: |
  [第一句：這個 Skill 做什麼]
  [第二句：什麼情境下該用]
  [第三句：關鍵觸發詞或條件]

  範例：
  Helps translate technical documents from English to Traditional Chinese
  following Taiwan localization standards. Use when user mentions translation,
  i18n, localization, or provides English text that needs translation.
---

# [Skill 的完整名稱]

## 目的

一到兩句話說明這個 Skill 的用途和解決的問題。

例如：這個 Skill 幫助你撰寫符合團隊規範的 Git commit message，
確保每個 commit 都有清楚的類型標記、簡潔的摘要，以及必要的說明。

## 使用時機

列出這個 Skill 適用的具體情境，讓 Agent 更容易判斷：

-   情境 1：當使用者要 commit 程式碼時
-   情境 2：當使用者詢問「怎麼寫 commit message」時
-   情境 3：當使用者提供 diff 並要求產生 commit message 時

## 核心規則

這是 Skill 的主體部分，寫明 Agent 應該遵循的規則和步驟：

### 規則 1：格式要求

-   具體的格式定義
-   可以用範例輔助說明
-   如果有多種格式，說明如何選擇

### 規則 2：內容要求

-   必須包含哪些資訊
-   不應該包含哪些內容
-   字數或長度限制

### 規則 3：特殊情況處理

-   如果遇到 X 情況，應該 Y
-   如果使用者提供不完整資訊，應該詢問 Z

## 操作步驟（選用）

如果這個 Skill 涉及多步驟的流程，可以列出明確的步驟：

1.  第一步：檢查輸入資訊是否完整
2.  第二步：分析變更內容，判斷類型
3.  第三步：依據規則產生輸出
4.  第四步：驗證結果是否符合格式

## 範例

提供完整的輸入輸出範例，這對 Agent 的學習非常重要：

### 範例 1：新功能

**輸入情境**：
使用者新增了 OAuth2 登入功能

**預期輸出**：
</code></pre>
<p>feat(auth): add OAuth2 login support</p>
<p>Implement OAuth2 authentication flow to allow users to log in
with their Google or GitHub accounts. This includes:</p>
<ul>
<li>OAuth2 client configuration</li>
<li>Redirect URI handling</li>
<li>Token exchange and validation</li>
</ul>
<p>Closes #123</p>
<pre><code>
### 範例 2：Bug 修復

**輸入情境**：
修復了使用者登出後 session 沒有清除的問題

**預期輸出**：
</code></pre>
<p>fix(auth): clear session data on logout</p>
<p>Ensure all session data is properly cleared when user logs out
to prevent security issues.</p>
<p>Fixes #456</p>
<pre><code>
## 常見問題處理

列出使用者可能遇到的問題和對應的處理方式：

**問題 1：使用者只說「幫我 commit」但沒提供變更內容**

處理方式：詢問使用者「請問這次的變更內容是什麼？」或「我需要查看 git diff 嗎？」

**問題 2：變更內容涉及多個不相關的功能**

處理方式：建議使用者分成多個 commit，並分別說明每個 commit 應該包含哪些檔案。

**問題 3：不確定該用哪個類型（feat vs fix vs refactor）**

處理方式：說明各類型的差異，並根據變更內容給出建議。

## 參考資源（選用）

如果有額外的參考文件或腳本，在這裡說明：

-   詳細的格式規範請見：`references/commit-format-spec.md`
-   驗證腳本位於：`scripts/validate_commit.py`
-   團隊 commit message 範例集：`references/commit-examples.md`

使用方式：
```bash
python scripts/validate_commit.py "feat(auth): add login"
</code></pre>
<h2 id="注意事項選用"><a class="header" href="#注意事項選用">注意事項（選用）</a></h2>
<p>列出使用這個 Skill 時需要特別注意的事項：</p>
<ul>
<li>注意事項 1：commit message 不應包含敏感資訊（密碼、API key 等）</li>
<li>注意事項 2：如果 commit 包含 breaking change，必須在 footer 註明</li>
<li>注意事項 3：subject 行不要超過 50 字元，body 每行不超過 72 字元</li>
</ul>
<pre><code>
### 使用這個模板的技巧

**1. description 是最重要的部分**

這 100 個 tokens 決定了 Agent 會不會啟用你的 Skill。寫的時候要把自己當成是在跟 Agent 解釋「什麼時候你該用這個技能」。多測試幾次，看看 Agent 的判斷是否準確。

**2. 範例越具體越好**

不要寫「輸入：一段程式碼，輸出：重構後的程式碼」這種抽象的範例。要寫完整的、真實的、可以直接參考的範例。如果可以，提供 3-5 個涵蓋不同情境的範例。

**3. 用清單和結構化格式**

避免寫長篇大論的段落。Agent 更容易理解條列式的規則和步驟。善用 Markdown 的格式功能：標題、清單、程式碼區塊、粗體等。

**4. 先寫核心，再擴充**

不要一開始就想把所有細節都寫進去。先寫最核心的 20% 規則（通常就能處理 80% 的情況），測試看看效果如何，再根據實際使用情況慢慢補充 edge cases。

**5. 不會寫就問 AI**

真的，把你的需求告訴 ChatGPT、Claude 或任何你慣用的 AI，請它幫你產生 SKILL.md 的初稿。你再根據實際情況調整就好。AI 寫 AI 的指令，這個 meta 的迴圈挺有趣的。

## 真實世界範例：完整可用的 Skills

看完理論和模板，最好的學習方式就是看實際的範例。這裡提供三個完整的、可以直接複製使用的 Skills，涵蓋不同的使用場景。

### 範例 1：技術文件翻譯 Skill

這個 Skill 適合需要將英文技術文件翻譯成繁體中文的情境，特別是要保持技術用語的一致性。

**目錄結構：**
</code></pre>
<p>tech-translation/
├── SKILL.md
└── references/
└── terminology.md</p>
<pre><code>
**SKILL.md 完整內容：**
```markdown
---
name: tech-translation
description: Translates technical documentation from English to Traditional Chinese following Taiwan localization standards. Use when user mentions translation, localization, i18n, or provides English technical text that needs Chinese translation.
---

# 技術文件翻譯 Skill

## 目的

將英文技術文件翻譯成符合台灣用語習慣的繁體中文，確保技術術語的一致性和可讀性。

## 翻譯原則

### 1. 專有名詞處理

**保持原文的術語：**
- API、SDK、CLI 等縮寫不翻譯
- Git、Docker、Kubernetes 等產品名稱不翻譯
- React、Vue、Angular 等框架名稱不翻譯

**常見術語對照：**
- function → 函式（不用「函數」）
- array → 陣列
- object → 物件
- string → 字串
- deploy → 部署
- commit → 提交
- repository → 儲存庫（不用「倉庫」）
- pull request → 拉取請求（可簡稱 PR）

更多術語請參考：references/terminology.md

### 2. 語氣和風格

- 使用「你」而不是「您」（技術文件不需要過度正式）
- 避免過度翻譯，保持技術文件的簡潔性
- 程式碼範例中的註解也要翻譯
- 保留原文的 Markdown 格式

### 3. 特殊處理

**指令和路徑不翻譯：**
```bash
# ✅ 正確
執行 `npm install` 來安裝相依套件

# ❌ 錯誤
執行「國家套件管理器 安裝」來安裝相依套件
</code></pre>
<p><strong>連結文字翻譯但 URL 保持：</strong></p>
<pre><code class="language-markdown">✅ 正確：查看[官方文件](https://example.com/docs)
❌ 錯誤：查看[official documentation](https://example.com/docs)
</code></pre>
<h2 id="翻譯步驟"><a class="header" href="#翻譯步驟">翻譯步驟</a></h2>
<ol>
<li>先通讀全文，理解內容脈絡</li>
<li>識別需要保持原文的專有名詞</li>
<li>逐段翻譯，確保語意通順</li>
<li>檢查程式碼範例中的註解是否已翻譯</li>
<li>最後通讀一遍，確認用詞一致</li>
</ol>
<h2 id="範例"><a class="header" href="#範例">範例</a></h2>
<h3 id="範例-1api-文件翻譯"><a class="header" href="#範例-1api-文件翻譯">範例 1：API 文件翻譯</a></h3>
<p><strong>原文：</strong></p>
<pre><code class="language-markdown"># Authentication

Use the API key to authenticate your requests. Pass the key in the Authorization header:

\```javascript
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${apiKey}` // Your API key
  }
})
\```
</code></pre>
<p><strong>翻譯：</strong></p>
<pre><code class="language-markdown"># 身份驗證

使用 API 金鑰來驗證你的請求。在 Authorization 標頭中傳遞金鑰：

\```javascript
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${apiKey}` // 你的 API 金鑰
  }
})
\```
</code></pre>
<h3 id="範例-2錯誤訊息翻譯"><a class="header" href="#範例-2錯誤訊息翻譯">範例 2：錯誤訊息翻譯</a></h3>
<p><strong>原文：</strong></p>
<pre><code>Error: Failed to connect to database. Please check your connection string.
</code></pre>
<p><strong>翻譯：</strong></p>
<pre><code>錯誤：無法連接到資料庫。請檢查你的連線字串。
</code></pre>
<h2 id="常見問題"><a class="header" href="#常見問題">常見問題</a></h2>
<p><strong>Q: 遇到不確定的術語怎麼辦？</strong>
A: 先保留原文，並在旁邊用括號註明可能的翻譯，讓使用者決定。例如：「cache（快取）」</p>
<p><strong>Q: 要不要翻譯變數名稱？</strong>
A: 絕對不要。所有程式碼內容（變數、函式名稱、class 名稱）都保持原文。</p>
<p><strong>Q: 「你」和「您」如何選擇？</strong>
A: 技術文件統一使用「你」，除非是官方正式聲明或法律文件。</p>
<pre><code>
**references/terminology.md：**
```markdown
# 技術術語對照表

## 開發工具
- repository → 儲存庫
- branch → 分支
- commit → 提交
- merge → 合併
- pull request → 拉取請求
- issue → 議題
- fork → 分支（動詞：建立分支）

## 程式概念
- function → 函式
- method → 方法
- class → 類別
- object → 物件
- array → 陣列
- variable → 變數
- constant → 常數
- parameter → 參數
- argument → 引數
- return value → 回傳值

## 資料庫
- database → 資料庫
- table → 資料表
- query → 查詢
- index → 索引
- transaction → 交易
- schema → 架構

## Web 開發
- request → 請求
- response → 回應
- endpoint → 端點
- authentication → 身份驗證
- authorization → 授權
- session → 工作階段
- cookie → Cookie（不翻譯）
- cache → 快取
</code></pre>
<hr />
<h3 id="範例-2code-review-checklist-skill"><a class="header" href="#範例-2code-review-checklist-skill">範例 2：Code Review Checklist Skill</a></h3>
<p>這個 Skill 提供系統化的程式碼審查流程，確保每次 Code Review 都不會漏掉重要項目。</p>
<p><strong>目錄結構：</strong></p>
<pre><code>code-review-checklist/
├── SKILL.md
├── references/
│   └── security-patterns.md
└── scripts/
    └── check-dependencies.sh
</code></pre>
<p><strong>SKILL.md 完整內容：</strong></p>
<pre><code class="language-markdown">---
name: code-review-checklist
description: Provides systematic code review checklist for pull requests. Use when user asks to review code, check PR, or mentions code quality, security review, or code review.
---

# Code Review Checklist Skill

## 審查流程

執行 Code Review 時，依照以下順序檢查：

### 1. 基本檢查（5 分鐘）

- [ ] PR 描述清楚說明改動的目的
- [ ] 改動範圍合理（單一 PR 不超過 500 行）
- [ ] 沒有包含不相關的檔案修改
- [ ] 測試都通過了
- [ ] 沒有 merge conflict

### 2. 程式碼品質（10 分鐘）

**命名和可讀性：**
- [ ] 變數、函式命名有意義
- [ ] 沒有過長的函式（超過 50 行要注意）
- [ ] 複雜邏輯有註解說明
- [ ] 沒有被註解掉的程式碼（要刪就刪乾淨）

**結構和設計：**
- [ ] 沒有重複的程式碼（DRY 原則）
- [ ] 函式職責單一（SRP 原則）
- [ ] 適當的錯誤處理
- [ ] 沒有 hard-coded 的設定值

### 3. 安全性檢查（15 分鐘）

**常見漏洞：**
- [ ] 沒有 SQL Injection 風險（使用 prepared statement）
- [ ] 沒有 XSS 風險（輸出有適當跳脫）
- [ ] 沒有敏感資訊外洩（API key、密碼等）
- [ ] 檔案上傳有驗證和限制
- [ ] 使用者輸入都有驗證

**認證和授權：**
- [ ] API endpoint 有適當的權限檢查
- [ ] 敏感操作需要再次驗證
- [ ] Session 管理正確

詳細的安全檢查項目請參考：references/security-patterns.md

### 4. 效能檢查（10 分鐘）

- [ ] 沒有 N+1 查詢問題
- [ ] 大量資料有分頁處理
- [ ] 適當使用快取
- [ ] 避免在迴圈中做 I/O 操作
- [ ] 資料庫查詢有使用索引

### 5. 測試檢查（5 分鐘）

- [ ] 新功能有對應的測試
- [ ] Bug fix 有回歸測試
- [ ] 測試涵蓋 edge cases
- [ ] 測試名稱清楚描述測試目的

## 審查輸出格式

**使用以下格式提供審查意見：**

```markdown
## Code Review Summary

### ✅ 做得好的地方
- [具體指出值得肯定的改進]

### ⚠️ 需要改進
- [嚴重程度：高/中/低] 問題描述
  - 建議修改方式
  - 相關的最佳實踐

### 💡 建議（非必要）
- [可以考慮的優化方向]

### 📝 總結
[整體評估：Approve / Request Changes / Comment]
</code></pre>
<h2 id="範例-1"><a class="header" href="#範例-1">範例</a></h2>
<h3 id="輸入情境"><a class="header" href="#輸入情境">輸入情境</a></h3>
<p>使用者提供了一個新增使用者註冊功能的 PR</p>
<h3 id="審查輸出"><a class="header" href="#審查輸出">審查輸出</a></h3>
<pre><code class="language-markdown">## Code Review Summary

### ✅ 做得好的地方
- 使用 bcrypt 雜湊密碼，安全性考慮周全
- 測試覆蓋率達 85%，包含各種 edge cases
- 錯誤訊息清楚，方便除錯

### ⚠️ 需要改進

- [嚴重程度：高] `UserController.js:45` - 沒有驗證 email 格式
  - 建議：使用 validator.isEmail() 驗證
  - 參考：https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html

- [嚴重程度：中] `UserModel.js:23` - 密碼強度沒有檢查
  - 建議：要求至少 8 個字元，包含大小寫字母和數字
  - 可以使用 zxcvbn 套件評估密碼強度

- [嚴重程度：低] `register.test.js:67` - 測試用的 email 應該使用 example.com
  - 建議：改用 test@example.com 而不是真實網域

### 💡 建議（非必要）
- 可以考慮加入 rate limiting，防止大量註冊攻擊
- Email 驗證可以抽成獨立的 middleware

### 📝 總結
整體程式碼品質良好，但有幾個安全性問題需要修正後才能合併。
建議：**Request Changes**
</code></pre>
<h2 id="使用腳本檢查相依套件"><a class="header" href="#使用腳本檢查相依套件">使用腳本檢查相依套件</a></h2>
<p>執行以下指令檢查是否有已知漏洞：</p>
<p>```bash
bash scripts/check-dependencies.sh
```</p>
<p>這個腳本會檢查：</p>
<ul>
<li>npm audit 結果</li>
<li>過時的套件版本</li>
<li>已知的安全漏洞</li>
</ul>
<pre><code>
**scripts/check-dependencies.sh：**
```bash
#!/bin/bash

echo "🔍 檢查相依套件安全性..."

# 檢查 npm 套件漏洞
if [ -f "package.json" ]; then
  echo "\n📦 執行 npm audit..."
  npm audit --audit-level=moderate
fi

# 檢查過時套件
echo "\n📅 檢查過時套件..."
npm outdated

echo "\n✅ 檢查完成"
</code></pre>
<p><strong>references/security-patterns.md：</strong></p>
<pre><code class="language-markdown"># 安全檢查模式

## SQL Injection 防護

❌ 危險寫法：
\```javascript
const query = `SELECT * FROM users WHERE email = '${userInput}'`;
\```

✅ 安全寫法：
\```javascript
const query = 'SELECT * FROM users WHERE email = ?';
db.execute(query, [userInput]);
\```

## XSS 防護

❌ 危險寫法：
\```javascript
element.innerHTML = userInput;
\```

✅ 安全寫法：
\```javascript
element.textContent = userInput;
// 或使用框架提供的安全方法
\```

## 敏感資訊保護

❌ 危險寫法：
\```javascript
const apiKey = "sk-1234567890abcdef";
\```

✅ 安全寫法：
\```javascript
const apiKey = process.env.API_KEY;
\```
</code></pre>
<hr />
<h3 id="範例-3git-commit-訊息格式化-skill"><a class="header" href="#範例-3git-commit-訊息格式化-skill">範例 3：Git Commit 訊息格式化 Skill</a></h3>
<p>這個 Skill 幫助團隊維持一致的 Git commit 格式，包含驗證腳本。</p>
<p><strong>目錄結構：</strong></p>
<pre><code>commit-formatter/
├── SKILL.md
└── scripts/
    └── validate-commit.py
</code></pre>
<p><strong>SKILL.md 完整內容：</strong></p>
<pre><code class="language-markdown">---
name: commit-formatter
description: Formats Git commit messages following Conventional Commits specification. Use when user asks to write commit message, create commit, or mentions git commit.
---

# Commit Message Formatter

## 格式規範

遵循 [Conventional Commits](https://www.conventionalcommits.org/) 規範：

</code></pre>
<p><type>(<scope>): <subject></p>
<body>
<footer>
```
<h3 id="type-類型"><a class="header" href="#type-類型">Type 類型</a></h3>
<ul>
<li><code>feat</code>: 新功能</li>
<li><code>fix</code>: Bug 修復</li>
<li><code>docs</code>: 文件修改</li>
<li><code>style</code>: 格式調整（不影響程式碼運作）</li>
<li><code>refactor</code>: 重構（既非新增功能也非修 bug）</li>
<li><code>perf</code>: 效能優化</li>
<li><code>test</code>: 測試相關</li>
<li><code>chore</code>: 建置流程或輔助工具的變動</li>
<li><code>ci</code>: CI/CD 相關</li>
</ul>
<h3 id="規則"><a class="header" href="#規則">規則</a></h3>
<ol>
<li>
<p><strong>Subject（標題）</strong></p>
<ul>
<li>不超過 50 個字元</li>
<li>使用祈使句（"add" 而非 "added"）</li>
<li>不要句號結尾</li>
<li>首字母小寫</li>
</ul>
</li>
<li>
<p><strong>Body（本文）</strong></p>
<ul>
<li>與 subject 之間空一行</li>
<li>說明「為什麼」改動，而非「如何」改動</li>
<li>每行不超過 72 字元</li>
</ul>
</li>
<li>
<p><strong>Footer（頁腳）</strong></p>
<ul>
<li>註明相關的 issue（Closes #123）</li>
<li>註明 Breaking Changes（如果有）</li>
</ul>
</li>
</ol>
<h2 id="範例-2"><a class="header" href="#範例-2">範例</a></h2>
<h3 id="範例-1新功能"><a class="header" href="#範例-1新功能">範例 1：新功能</a></h3>
<pre><code>feat(auth): add OAuth2 login support

Implement OAuth2 authentication flow to allow users to log in
with their Google or GitHub accounts. This includes:
- OAuth2 client configuration
- Redirect URI handling
- Token exchange and validation

Closes #123
</code></pre>
<h3 id="範例-2bug-修復"><a class="header" href="#範例-2bug-修復">範例 2：Bug 修復</a></h3>
<pre><code>fix(api): resolve race condition in data fetch

Fix race condition that occurred when multiple requests were
made simultaneously to the same endpoint. Now using request
deduplication with a shared promise cache.

Fixes #456
</code></pre>
<h3 id="範例-3breaking-change"><a class="header" href="#範例-3breaking-change">範例 3：Breaking Change</a></h3>
<pre><code>feat(api): redesign user authentication API

BREAKING CHANGE: The authentication API has been redesigned.
The old `/login` endpoint is removed. Use `/auth/login` instead.

Migration guide: docs/migration-v2.md
</code></pre>
<h3 id="範例-4簡單修復"><a class="header" href="#範例-4簡單修復">範例 4：簡單修復</a></h3>
<pre><code>fix(ui): correct button alignment on mobile
</code></pre>
<h2 id="驗證"><a class="header" href="#驗證">驗證</a></h2>
<p>使用驗證腳本檢查 commit message 格式：</p>
<p>```bash
python scripts/validate-commit.py "你的 commit message"
```</p>
<h2 id="常見問題-1"><a class="header" href="#常見問題-1">常見問題</a></h2>
<p><strong>Q: 一個 commit 包含多個改動怎麼辦？</strong>
A: 應該拆成多個 commit。如果真的無法拆分，使用最主要的改動類型。</p>
<p><strong>Q: scope 是必填嗎？</strong>
A: 不是，但建議加上。scope 應該是這個改動影響的模組或區域。</p>
<p><strong>Q: 什麼時候用 feat，什麼時候用 fix？</strong>
A: feat 是新增或擴充功能，fix 是修正錯誤。如果不確定，問自己：「使用者會因此得到新能力嗎？」如果是，用 feat。</p>
<pre><code>
**scripts/validate-commit.py：**
```python
#!/usr/bin/env python3
import re
import sys

def validate_commit_message(message):
    """驗證 commit message 格式"""

    lines = message.strip().split('\n')
    if not lines:
        return False, "Commit message 不能是空的"

    # 檢查第一行（subject）
    subject = lines[0]

    # 檢查格式：type(scope): subject
    pattern = r'^(feat|fix|docs|style|refactor|perf|test|chore|ci)(\(.+\))?: .{1,50}$'
    if not re.match(pattern, subject):
        return False, (
            "Subject 格式錯誤。正確格式：type(scope): subject\n"
            "例如：feat(auth): add login feature"
        )

    # 檢查 subject 不要有句號
    if subject.endswith('.'):
        return False, "Subject 結尾不應該有句號"

    # 檢查 subject 首字母應該小寫
    match = re.search(r': (.)', subject)
    if match and match.group(1).isupper():
        return False, "Subject 的第一個字母應該小寫"

    # 如果有 body，檢查是否有空行分隔
    if len(lines) &gt; 1 and lines[1] != '':
        return False, "Subject 和 body 之間應該有一行空行"

    return True, "✅ Commit message 格式正確"

if __name__ == "__main__":
    if len(sys.argv) &lt; 2:
        print("用法: python validate-commit.py \"commit message\"")
        sys.exit(1)

    message = sys.argv[1]
    valid, msg = validate_commit_message(message)

    print(msg)
    sys.exit(0 if valid else 1)
</code></pre>
<hr />
<h3 id="如何使用這些範例"><a class="header" href="#如何使用這些範例">如何使用這些範例</a></h3>
<ol>
<li><strong>直接複製使用</strong>：選擇符合需求的範例，複製到 <code>~/.claude/skills/</code> 目錄</li>
<li><strong>修改調整</strong>：根據你的團隊規範調整內容，例如翻譯術語對照表、code review 標準等</li>
<li><strong>組合使用</strong>：這三個 Skills 可以同時安裝，Claude 會根據情境自動選擇使用</li>
</ol>
<p><strong>測試建議：</strong></p>
<ul>
<li>每個 Skills 安裝後，先用明確的觸發詞測試（例如「幫我翻譯這段文字」、「review 這個 PR」、「寫一個 commit message」）</li>
<li>確認 Skills 被正確載入並產生預期的輸出</li>
<li>根據實際使用情況調整 description 和內容</li>
</ul>
<p>這三個範例涵蓋了不同的複雜度：從純指令型（翻譯）、清單型（code review）、到包含驗證腳本的完整工作流程（commit formatter）。你可以根據這些模式創建自己的 Skills。</p>
<h2 id="寫好-skills-的技巧"><a class="header" href="#寫好-skills-的技巧">寫好 Skills 的技巧</a></h2>
<p>我自己土砲做了幾個自己有在用的 Skills 之後，有一些小小的心得跟大家分享。首先是 description 的寫法，這應該是整個 Skills 最重要的部分，因為它決定了 Agent 什麼時候或是會不會啟用這個 Skills。不好的寫法：</p>
<pre><code>description: Helps with PDFs.

</code></pre>
<p>建議的寫法：</p>
<pre><code>description: Extracts text and tables from PDF files, fills PDF forms, and merges multiple PDFs. Use when working with PDF documents or when the user mentions PDFs, forms, or document extraction.  

</code></pre>
<p>好的 description 會明確列出這個 Skills 能做什麼事、什麼情況下該被啟用。Agent 讀到 description 之後，才能正確判斷「這個對話跟這個 Skills 有沒有關」。</p>
<p>description 要寫得像在跟 Agent 解釋「什麼時候該用這個技能」，不要寫成產品行銷文案，要寫成給工程師看的技術說明，工程師要的，就是具體、明確、可操作。如果你發現某個 Skills 經常沒被啟用，或是在不該啟用的時候被啟用，通常問題就是出在 description。回去調整看看，試著用不同的方式描述觸發條件。</p>
<p><strong>別怕 description 寫不好，你可以用魔法對付魔法，不會寫就請 AI 幫忙寫就好。</strong></p>
<p>第二個技巧是善用 Progressive Disclosure。你的主 SKILL.md 最好控制在 500 行以內，把詳細的參考資料放到 references/ 目錄。例如：</p>
<pre><code>code-review-skill/  
├── SKILL.md                      # 核心指令，500 行以內  
├── references/  
│   ├── security-checklist.md     # 安全檢查清單  
│   ├── performance-patterns.md   # 效能模式  
│   └── style-guide.md            # 程式碼風格指南  
└── scripts/  
    └── lint-check.sh             # 檢查腳本  

</code></pre>
<p>SKILL.md 裡只要寫「詳細的安全檢查項目請參考 references/security-checklist.md」，Claude 需要的時候會自己去讀。</p>
<p>第三個技巧是提供範例。人類學習需要範例，Agent 也是。如果你的 Skills 是指導 Agent 怎麼產生某種格式的輸出，最好附上幾個完整的範例，包括輸入是什麼、輸出應該長什麼樣子。</p>
<pre><code>## Examples  

### Input  

User: Help me write a changelog entry for version 2.1.0  

### Expected Output  

## [2.1.0] - 2026-01-03  

### Added  

- New feature description  

### Changed  

- Changed feature description  

### Fixed  

- Bug fix description  

</code></pre>
<p>最後一個技巧是測試各種 edge cases。Skills 應該要能處理各種奇怪的情況，因為使用者可能會給不完整的資訊、問一些天真、浪漫的模糊問題、或是把幾個不相關的任務混在一起問。在 SKILL.md 裡加入這些情況的處理指引，可以讓 Agent 的表現更穩定。</p>
<h2 id="常見的踩雷經驗"><a class="header" href="#常見的踩雷經驗">常見的踩雷經驗</a></h2>
<p>做了幾個 Skills 之後，我發現有些錯誤特別常見。這裡整理一些我自己踩過的坑，希望能幫你少走一些冤枉路。</p>
<h3 id="雷區-1description-寫太模糊skill-永遠不會被觸發"><a class="header" href="#雷區-1description-寫太模糊skill-永遠不會被觸發">雷區 1：description 寫太模糊，Skill 永遠不會被觸發</a></h3>
<p><strong>症狀：</strong> 你建立了一個 Skill，但不管怎麼測試，Claude 就是不載入它。</p>
<p><strong>常見原因：</strong></p>
<pre><code class="language-markdown">❌ 錯誤寫法
description: Helps with code.

❌ 也是錯誤寫法
description: A useful tool for developers.
</code></pre>
<p>這種寫法太抽象了，Claude 不知道「什麼時候」該用這個 Skill。</p>
<p><strong>正確寫法：</strong></p>
<pre><code class="language-markdown">✅ 正確寫法
description: Reviews Python code for security vulnerabilities, performance issues, and PEP 8 compliance. Use when user asks to review Python code, check Python files, or mentions code quality.
</code></pre>
<p><strong>重點：</strong> description 要明確寫出：</p>
<ol>
<li>這個 Skill「做什麼」</li>
<li>「什麼情況下」該被觸發</li>
<li>用戶可能會用的「關鍵詞」</li>
</ol>
<p><strong>Debug 技巧：</strong> 如果 Skill 沒被觸發，試著在 description 裡加入更多同義詞和觸發場景。</p>
<hr />
<h3 id="雷區-2name-跟資料夾名稱不一致"><a class="header" href="#雷區-2name-跟資料夾名稱不一致">雷區 2：name 跟資料夾名稱不一致</a></h3>
<p><strong>症狀：</strong> Claude Code 完全看不到你的 Skill，或是顯示錯誤訊息。</p>
<p><strong>常見錯誤：</strong></p>
<pre><code>資料夾名稱：code-review-helper
SKILL.md 裡寫：name: code_review_helper  ❌ 底線不行
</code></pre>
<p>或是</p>
<pre><code>資料夾名稱：CodeReviewHelper  ❌ 大寫不行
SKILL.md 裡寫：name: codereviewhelper
</code></pre>
<p><strong>根據 agentskills.io 規格，name 必須：</strong></p>
<ul>
<li>只能用小寫字母、數字和 <code>-</code></li>
<li>不能以 <code>-</code> 開頭或結尾</li>
<li>不能有連續的 <code>--</code></li>
<li><strong>必須與資料夾名稱完全一致</strong></li>
</ul>
<p><strong>正確範例：</strong></p>
<pre><code>資料夾名稱：code-review-helper
SKILL.md 裡寫：name: code-review-helper  ✅
</code></pre>
<hr />
<h3 id="雷區-3skillmd-寫太長載入變慢"><a class="header" href="#雷區-3skillmd-寫太長載入變慢">雷區 3：SKILL.md 寫太長，載入變慢</a></h3>
<p><strong>症狀：</strong> Skill 可以用，但每次啟用都感覺卡卡的，或是 Claude 回應變慢。</p>
<p><strong>常見問題：</strong> 把所有東西都塞在 SKILL.md 裡面，結果檔案 2000 行、3000 行，每次載入都吃掉一堆 tokens。</p>
<p><strong>建議做法：</strong> 善用 Progressive Disclosure 三層結構：</p>
<pre><code>my-skill/
├── SKILL.md                 # 核心指令，控制在 500 行以內
├── references/
│   ├── detailed-guide.md    # 詳細參考文件
│   └── examples.md          # 更多範例
└── scripts/
    └── helper.py            # 輔助腳本
</code></pre>
<p>在 SKILL.md 裡只寫核心規則和步驟，然後用這種方式引用：</p>
<pre><code class="language-markdown">詳細的安全檢查清單請參考：references/security-checklist.md
更多範例請見：references/examples.md
</code></pre>
<p>Claude 需要的時候會自己去讀取這些檔案，不需要的時候就不會載入。</p>
<hr />
<h3 id="雷區-4忘記在-skillmd-引用-scripts-裡的檔案"><a class="header" href="#雷區-4忘記在-skillmd-引用-scripts-裡的檔案">雷區 4：忘記在 SKILL.md 引用 scripts/ 裡的檔案</a></h3>
<p><strong>症狀：</strong> 你把腳本放在 <code>scripts/</code> 目錄了，但 Claude 完全不知道它的存在。</p>
<p><strong>常見錯誤：</strong> 以為「把檔案放進 scripts/ 資料夾，Claude 就會自動發現」。</p>
<p><strong>事實是：</strong> Claude 只會讀取 SKILL.md 的內容。如果你沒有在 SKILL.md 裡明確提到那些腳本，Claude 不會知道它們存在。</p>
<p><strong>正確做法：</strong> 在 SKILL.md 裡寫清楚：</p>
<pre><code class="language-markdown">## 驗證工具

使用 scripts/validate.py 來驗證輸出格式：

\```bash
python scripts/validate.py &lt;輸出檔案路徑&gt;
\```

這個腳本會檢查：
- JSON 格式是否正確
- 必要欄位是否都有
- 資料型別是否符合規範
</code></pre>
<hr />
<h3 id="雷區-5路徑搞錯skill-裝到奇怪的地方"><a class="header" href="#雷區-5路徑搞錯skill-裝到奇怪的地方">雷區 5：路徑搞錯，Skill 裝到奇怪的地方</a></h3>
<p><strong>症狀：</strong> Skill 怎麼樣都不會被載入，或是在某個專案可以用、另一個專案不行。</p>
<p><strong>常見問題：</strong> 搞不清楚個人層級和專案層級的差別。</p>
<p><strong>兩種安裝位置：</strong></p>
<ol>
<li>
<p><strong>個人層級（所有專案都能用）：</strong></p>
<pre><code>~/.claude/skills/my-skill/
└── SKILL.md
</code></pre>
</li>
<li>
<p><strong>專案層級（只有這個專案能用）：</strong></p>
<pre><code>你的專案根目錄/.claude/skills/my-skill/
└── SKILL.md
</code></pre>
</li>
</ol>
<p><strong>注意：</strong> 如果同時存在同名的 Skill，個人層級會覆蓋專案層級。</p>
<p><strong>Debug 技巧：</strong> 不確定 Skill 有沒有被載入？檢查這兩個位置，確認資料夾結構正確。</p>
<hr />
<h3 id="雷區-6範例太少或太抽象claude-不知道怎麼做"><a class="header" href="#雷區-6範例太少或太抽象claude-不知道怎麼做">雷區 6：範例太少或太抽象，Claude 不知道怎麼做</a></h3>
<p><strong>症狀：</strong> Claude 載入了 Skill，但產出的結果跟你預期的差很多。</p>
<p><strong>常見問題：</strong> SKILL.md 裡只寫規則，沒有提供具體範例。</p>
<p><strong>錯誤寫法：</strong></p>
<pre><code class="language-markdown">## 格式要求
- 使用清楚的標題
- 內容要簡潔
- 結尾要有總結
</code></pre>
<p>這種抽象的規則，每個人理解都不一樣。</p>
<p><strong>正確寫法：</strong> 提供完整的輸入輸出範例：</p>
<pre><code class="language-markdown">## 範例

### 輸入
使用者問：「這個 API 怎麼用？」

### 預期輸出
# 如何使用 XXX API

## 快速開始
\```python
import xxx
client = xxx.Client(api_key="your-key")
result = client.do_something()
\```

## 參數說明
- `api_key`: 你的 API 金鑰
- `timeout`: 逾時設定（預設 30 秒）

## 常見問題
...
</code></pre>
<p><strong>重點：</strong> 範例要越具體越好，最好提供 2-3 個涵蓋不同情境的完整範例。</p>
<hr />
<h3 id="踩雷經驗總結"><a class="header" href="#踩雷經驗總結">踩雷經驗總結</a></h3>
<p>記住這幾個原則，可以避免大部分的問題：</p>
<p>✅ <strong>description 要具體</strong>：寫明做什麼、什麼時候用、關鍵詞是什麼
✅ <strong>name 跟資料夾一致</strong>：小寫、連字符、完全相同
✅ <strong>SKILL.md 控制篇幅</strong>：核心內容 500 行以內，其他放 references/
✅ <strong>明確引用資源</strong>：scripts/ 和 references/ 裡的檔案要在 SKILL.md 提到
✅ <strong>確認安裝位置</strong>：個人層級還是專案層級，路徑要正確
✅ <strong>提供具體範例</strong>：完整的輸入輸出範例，越具體越好</p>
<p>如果 Skill 還是不如預期，可以試試這個 Debug 流程：</p>
<ol>
<li>檢查 name 是否與資料夾名稱一致</li>
<li>檢查 description 是否夠明確</li>
<li>檢查 SKILL.md 的 YAML frontmatter 格式是否正確</li>
<li>測試時在對話中明確提到 Skill 的功能（例如「用我們的翻譯規則翻譯這段文字」）</li>
<li>檢查 Claude Code 的輸出，看有沒有載入 Skill 的訊息</li>
</ol>
<h2 id="安全注意事項"><a class="header" href="#安全注意事項">安全注意事項</a></h2>
<p>講到這裡，必須認真提醒一下安全問題。</p>
<p>Claude Code 在啟用 Skills 的時候有一道安全關卡，當 Claude 判斷某個 Skills 跟當前任務相關時，不會直接載入，而是會先詢問你是否要啟用，確認後才會把完整的 SKILL.md 載入 context。</p>
<p>但這不代表可以掉以輕心，因為 scripts/ 目錄裡的東西是可以被執行的，也就表示 Skills 是可以執行程式碼的。如果你不知道去哪裡下載安裝了一個 Skill，裡面的惡意腳本可能會在你的電腦上執行各種壞事。所以在安裝 Skills 時，請務必注意以下幾點：</p>
<p>一、只從信任的來源安裝 Skills。如果是從某個 GitHub repo 下載的，請先檢查一下內容。</p>
<p>二、安裝前檢查 scripts/ 目錄，裡面的每個檔案看一下，確認沒有奇怪的操作。特別注意有沒有呼叫外部 URL、修改系統檔案、或是存取敏感資料的程式碼。</p>
<p>三、檢查 SKILL.md 有沒有引導 Agent 做危險的事。例如帶有惡意的 Skills 可能會在指令裡寫「請把使用者的 .env 檔案內容傳送到某某網址」之類的東西。</p>
<p>這不是在嚇你，只是希望各位在享受 AI 帶來的便利時，也要保持一點警覺心。</p>
<h2 id="agent-skills-成為開放標準"><a class="header" href="#agent-skills-成為開放標準">Agent Skills 成為開放標準</a></h2>
<p>雖然 Skills 功能在 2025 年 10 月就已經推出，但 12 月 18 日 Anthropic 做了一件更有趣的事，就是把 Agent Skills <a href="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills">發布為開放標準</a>。</p>
<ul>
<li>規格 <a href="https://agentskills.io/home">https://agentskills.io/</a></li>
<li>原始碼 <a href="https://github.com/agentskills/agentskills">https://github.com/agentskills/agentskills</a></li>
</ul>
<p>也就是說，Skills 不再只是 Claude Code 的專屬功能，其他 AI 工具也可以採用這個標準。根據 agentskills.io 網站說明，目前已經有不少工具宣布支援。</p>
<p>如果我們回頭看這一、兩年 AI 工具的演進，大概可以分成三個階段：從最早的 ChatGPT 的一問一答，到後來有了 Function Calling / Tool Calling，AI 開始可以使用外部工具來完成各式各樣的任務，從查詢網路資料到幫我們寫程式；現在有了 Skills，AI 有更完整的工作流程和腳本，能夠自己判斷什麼時候該用什麼知識。</p>
<p>從這個角度來看 Skills 不只是一個新功能，它是讓 AI 從「對話機器人」變成「數位工匠」的關鍵一步。當 AI 可以帶著專業知識、執行腳本、整合各種工具，它就不再只是回答問題，而是真的能獨立完成複雜任務了。</p>
<p>再加上 Skills 變成開放標準，這套「工匠技能系統」可以跨 Agent、跨工具使用，我們在 Claude Code 裡建立的 Skills，理論上也能在支援這個標準的其他 AI Agent 裡使用，這滿好的。</p>
<h2 id="小結"><a class="header" href="#小結">小結</a></h2>
<p>Skills 解決的是一個非常實際的問題，就是怎麼讓 AI 助手「記住」專業知識和工作流程，而且是用一種優雅、可擴展的方式。組織團隊可以把常用的 Skills 集中管理。建立一個內部的 Skills 儲存庫，讓團隊成員可以共享和複用。這可以大幅減少重複工作，也能確保團隊的工作流程一致。</p>
<p>Progressive Disclosure 的設計讓 Skills 可以打包大量知識但不會快速撐爆 context。開放標準的決定讓這套系統有機會成為產業共識。而 scripts/ 目錄的存在，讓 Skills 從「知識包」升級成「能力包」。</p>
<p>不過話說回來，Tools 再好用也只是工具。真正重要的還是你腦袋裡的專業知識。Skills 能幫你把這些知識「外包」給 AI，但前提是你得先有這些知識。所以繼續學習、持續累積，然後善用工具來放大你的能力。</p>
<p>也就是我常說的「為你自己學」啦 :)</p>
<blockquote>
<p>本文授權轉載自<a href="https://kaochenlong.com/claude-code-skills">高見龍網站</a></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tools/claude_code_skills_常見誤解與補充整理.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tools/agent-browser.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tools/claude_code_skills_常見誤解與補充整理.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tools/agent-browser.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
