<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LLVM 編譯器架構與語言效能深度解析 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="llvm-編譯器架構與語言效能深度解析"><a class="header" href="#llvm-編譯器架構與語言效能深度解析">LLVM 編譯器架構與語言效能深度解析</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#llvm-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5">LLVM 基礎概念</a></li>
<li><a href="#%E7%B7%A8%E8%AD%AF%E5%99%A8%E6%9E%B6%E6%A7%8B%E8%A7%A3%E6%9E%90">編譯器架構解析</a></li>
<li><a href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E5%90%8C%E8%AA%9E%E8%A8%80%E9%83%BD%E7%94%A8-llvm-%E6%95%88%E8%83%BD%E5%8D%BB%E4%B8%8D%E5%90%8C">為什麼不同語言都用 LLVM 效能卻不同</a></li>
<li><a href="#%E5%B8%B8%E8%A6%8B%E8%AA%A4%E8%A7%A3%E6%BE%84%E6%B8%85">常見誤解澄清</a></li>
<li><a href="#llvm-%E5%84%AA%E5%8C%96%E8%83%BD%E5%8A%9B%E8%88%87%E9%99%90%E5%88%B6">LLVM 優化能力與限制</a></li>
<li><a href="#%E5%AF%A6%E9%9A%9B%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">實際案例分析</a></li>
</ol>
<hr />
<h2 id="llvm-基礎概念"><a class="header" href="#llvm-基礎概念">LLVM 基礎概念</a></h2>
<h3 id="什麼是-llvm"><a class="header" href="#什麼是-llvm">什麼是 LLVM？</a></h3>
<p><strong>LLVM</strong> (Low Level Virtual Machine) 是一套模組化、可重用的編譯器基礎設施。儘管名字中有 "Virtual Machine"，但現代 LLVM 遠超過虛擬機的範疇。</p>
<pre><code>傳統編譯器：每個語言需要實現所有功能
C編譯器    ：前端 → 優化器 → x86後端、ARM後端、RISC-V後端...
Fortran編譯器：前端 → 優化器 → x86後端、ARM後端、RISC-V後端...
（大量重複工作）

LLVM 架構：共享優化器和後端
C/C++   → Clang前端   ↘
Rust    → Rust前端    → LLVM IR → LLVM優化器 → LLVM後端 → 各平臺機器碼
Swift   → Swift前端   ↗
Julia   → Julia前端   ↗
</code></pre>
<h3 id="llvm-ir---統一的中間表示"><a class="header" href="#llvm-ir---統一的中間表示">LLVM IR - 統一的中間表示</a></h3>
<p>LLVM IR（Intermediate Representation）是 LLVM 的核心，它是一種低階、類型化的彙編語言。</p>
<pre><code class="language-llvm">; C 代碼：int multiply(int x, int y) { return x * y; }
; 對應的 LLVM IR：

define i32 @multiply(i32 %x, i32 %y) {
entry:
  %result = mul i32 %x, %y
  ret i32 %result
}

; 特點：
; - 靜態單賦值形式（SSA）
; - 強類型（i32 = 32位整數）
; - 無限暫存器
; - 平臺無關
</code></pre>
<hr />
<h2 id="編譯器架構解析"><a class="header" href="#編譯器架構解析">編譯器架構解析</a></h2>
<h3 id="完整編譯流程"><a class="header" href="#完整編譯流程">完整編譯流程</a></h3>
<pre><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   源代碼     │ --&gt; │    前端      │ --&gt; │   中端優化   │ --&gt; │    後端      │
│  (C/Rust)   │     │   (解析)     │     │  (LLVM IR)  │     │  (代碼生成)  │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
       ↓                    ↓                    ↓                    ↓
   程式邏輯            抽象語法樹              優化的IR            機器碼
</code></pre>
<h3 id="三段式架構的優勢"><a class="header" href="#三段式架構的優勢">三段式架構的優勢</a></h3>
<h4 id="1-前端language-specific-frontend"><a class="header" href="#1-前端language-specific-frontend">1. 前端（Language-Specific Frontend）</a></h4>
<p>負責：</p>
<ul>
<li>詞法分析、語法分析</li>
<li>語義檢查</li>
<li>類型檢查</li>
<li>生成 LLVM IR</li>
</ul>
<h4 id="2-中端llvm-optimizer"><a class="header" href="#2-中端llvm-optimizer">2. 中端（LLVM Optimizer）</a></h4>
<p>負責：</p>
<ul>
<li>與機器無關的優化</li>
<li>死代碼消除</li>
<li>函數內聯</li>
<li>循環優化</li>
<li>向量化</li>
</ul>
<h4 id="3-後端target-specific-backend"><a class="header" href="#3-後端target-specific-backend">3. 後端（Target-Specific Backend）</a></h4>
<p>負責：</p>
<ul>
<li>指令選擇</li>
<li>暫存器分配</li>
<li>指令排程</li>
<li>生成目標機器碼</li>
</ul>
<h3 id="zig-作為-cc-編譯器的例子"><a class="header" href="#zig-作為-cc-編譯器的例子">Zig 作為 C/C++ 編譯器的例子</a></h3>
<pre><code class="language-bash"># Zig 內建了完整的 LLVM 工具鏈
zig cc hello.c -o hello        # 作為 C 編譯器
zig c++ hello.cpp -o hello     # 作為 C++ 編譯器

# 實際執行流程：
# hello.c → Clang前端 → LLVM IR → LLVM優化 → LLVM後端 → 執行檔

# 交叉編譯能力
zig cc -target aarch64-linux hello.c   # 編譯 ARM64 Linux
zig cc -target x86_64-windows hello.c  # 編譯 Windows x64
</code></pre>
<hr />
<h2 id="為什麼不同語言都用-llvm-效能卻不同"><a class="header" href="#為什麼不同語言都用-llvm-效能卻不同">為什麼不同語言都用 LLVM 效能卻不同</a></h2>
<h3 id="核心原理llvm-只能優化它看到的"><a class="header" href="#核心原理llvm-只能優化它看到的">核心原理：LLVM 只能優化它看到的</a></h3>
<pre><code>效能差異來源分佈：
┌────────────────────────────────────┐
│ 語言設計 (60%)                      │ ← 記憶體模型、類型系統
├────────────────────────────────────┤
│ 前端品質 (30%)                      │ ← IR 生成品質
├────────────────────────────────────┤
│ LLVM 優化 (10%)                    │ ← 通用優化
└────────────────────────────────────┘
</code></pre>
<h3 id="1-語言設計層面的影響"><a class="header" href="#1-語言設計層面的影響">1. 語言設計層面的影響</a></h3>
<h4 id="記憶體管理模型差異"><a class="header" href="#記憶體管理模型差異">記憶體管理模型差異</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust - 零成本抽象，無GC
fn process_data(data: Vec&lt;u32&gt;) -&gt; u32 {
    data.iter().sum()  // 編譯時決定記憶體釋放點
}
// 生成的 LLVM IR：直接的記憶體操作，無額外開銷

// Go - 垃圾回收
func processData(data []uint32) uint32 {
    sum := uint32(0)
    for _, v := range data {
        sum += v
    }
    return sum
}
// 生成的 LLVM IR：包含 GC safepoint、寫屏障等

// Python - 引用計數 + GC
def process_data(data):
    return sum(data)
<span class="boring">生成的 LLVM IR（如果 JIT）：
</span><span class="boring">- 類型檢查
</span><span class="boring">- 引用計數操作
</span><span class="boring">- 邊界檢查
</span><span class="boring">- 可能的 boxing/unboxing
</span><span class="boring">}</span></code></pre></pre>
<h4 id="類型系統的影響"><a class="header" href="#類型系統的影響">類型系統的影響</a></h4>
<pre><code class="language-c">// C - 靜態類型，無運行時檢查
int add(int a, int b) {
    return a + b;
}
// LLVM IR: 單純的 add 指令

// TypeScript (編譯到 JS) - 動態類型
function add(a: number, b: number): number {
    return a + b;
}
// 運行時仍需類型檢查，LLVM IR 包含：
// - typeof 檢查
// - NaN 檢查
// - 可能的類型轉換

// Rust - 靜態類型 + 明確的溢出行為
fn add(a: i32, b: i32) -&gt; i32 {
    a.wrapping_add(b)  // 明確指定 wrapping
}
// LLVM IR: 明確的 add 指令，無額外檢查
</code></pre>
<h3 id="2-前端編譯器品質差異"><a class="header" href="#2-前端編譯器品質差異">2. 前端編譯器品質差異</a></h3>
<h4 id="相同功能不同-ir-品質"><a class="header" href="#相同功能不同-ir-品質">相同功能，不同 IR 品質</a></h4>
<pre><code class="language-llvm">; 優秀的前端（如 Clang）生成的 IR
define i32 @sum_array(i32* %arr, i32 %n) {
entry:
  %wide.trip.count = zext i32 %n to i64
  %min.iters.check = icmp ult i64 %wide.trip.count, 4
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:
  ; 向量化友好的程式碼
  %vec.phi = phi &lt;4 x i32&gt; 
  ; ... 向量化循環 ...
}

; 較差的前端可能生成
define i32 @sum_array(i8* %obj) {
entry:
  ; 大量運行時檢查
  %type = call i32 @get_type(i8* %obj)
  %is_array = icmp eq i32 %type, 42
  br i1 %is_array, label %array_path, label %error_path
  
array_path:
  ; 無法向量化的循環
  %i = phi i32 [ 0, %entry ], [ %next_i, %loop ]
  %elem_ptr = call i8* @get_element(i8* %obj, i32 %i)
  ; ... 更多間接調用 ...
}
</code></pre>
<h3 id="3-抽象成本差異"><a class="header" href="#3-抽象成本差異">3. 抽象成本差異</a></h3>
<pre><code class="language-cpp">// C++ - 零成本抽象
template&lt;typename T&gt;
inline T max(T a, T b) {
    return a &gt; b ? a : b;
}
// 完全內聯，生成與手寫相同的 IR

// Java（假設用 LLVM）- 有成本的抽象
public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T a, T b) {
    return a.compareTo(b) &gt; 0 ? a : b;
}
// IR 包含虛擬方法調用、可能的 boxing
</code></pre>
<hr />
<h2 id="常見誤解澄清"><a class="header" href="#常見誤解澄清">常見誤解澄清</a></h2>
<h3 id="誤解-1用了-llvm-就會一樣快"><a class="header" href="#誤解-1用了-llvm-就會一樣快">誤解 1：用了 LLVM 就會一樣快</a></h3>
<p><strong>錯誤</strong> ❌</p>
<p><strong>真相</strong>：LLVM 只是工具，語言設計才是效能的決定因素。</p>
<pre><code class="language-python"># Python with Numba (LLVM JIT)
@numba.jit
def slow_function(x):
    return x + "hello"  # 動態類型，無法優化
    
@numba.jit
def fast_function(x: float) -&gt; float:
    return x * 2.0  # 類型明確，可以優化
</code></pre>
<h3 id="誤解-2llvm-可以自動優化所有程式碼"><a class="header" href="#誤解-2llvm-可以自動優化所有程式碼">誤解 2：LLVM 可以自動優化所有程式碼</a></h3>
<p><strong>錯誤</strong> ❌</p>
<p><strong>真相</strong>：LLVM 必須遵守語言語義，不能改變程式行為。</p>
<pre><code class="language-llvm">; LLVM 不能優化掉的例子：

; 1. 語言要求的邊界檢查
%bounds_check = icmp ult i32 %index, %array_len
br i1 %bounds_check, label %safe, label %panic

; 2. 必要的類型檢查（動態語言）
%type_id = call i32 @get_type_id(i8* %object)
switch i32 %type_id, label %type_error [
  i32 1, label %int_case
  i32 2, label %float_case
]

; 3. 記憶體模型要求（GC write barrier）
call void @gc_write_barrier(i8** %target, i8* %value)
</code></pre>
<h3 id="誤解-3jit-一定比-aot-快"><a class="header" href="#誤解-3jit-一定比-aot-快">誤解 3：JIT 一定比 AOT 快</a></h3>
<p><strong>錯誤</strong> ❌</p>
<p><strong>真相</strong>：各有優劣，取決於使用場景。</p>
<pre><code>AOT (Ahead-of-Time) 編譯：
✓ 啟動快
✓ 可預測的效能
✓ 更激進的全程式優化
✗ 無法根據運行時資訊優化

JIT (Just-in-Time) 編譯：
✓ 可根據運行時資訊優化
✓ 可以去虛擬化
✗ 啟動慢（需要編譯）
✗ 需要預熱期
✗ 記憶體開銷（儲存編譯器）
</code></pre>
<h3 id="誤解-4c-永遠最快"><a class="header" href="#誤解-4c-永遠最快">誤解 4：C 永遠最快</a></h3>
<p><strong>部分正確</strong> ⚠️</p>
<p><strong>真相</strong>：Rust、Zig、C++ 可以達到相同效能，有時甚至更快。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 可能比 C 更快的例子
// Rust 的所有權系統允許更激進的優化

// C 版本
void process(char* data, size_t len) {
    // 編譯器不知道 data 是否會 alias
    // 必須保守優化
}

// Rust 版本
fn process(data: &amp;mut [u8]) {
    // 編譯器知道沒有 aliasing
    // 可以更激進地優化
}
<span class="boring">}</span></code></pre></pre>
<h3 id="誤解-5llvm-是萬能的"><a class="header" href="#誤解-5llvm-是萬能的">誤解 5：LLVM 是萬能的</a></h3>
<p><strong>錯誤</strong> ❌</p>
<p><strong>LLVM 的限制</strong>：</p>
<pre><code>LLVM 做不到的事：
1. 改變語言語義
2. 移除語言要求的安全檢查
3. 改變記憶體模型
4. 優化掉有副作用的程式碼
5. 違反 ABI 約定

LLVM 擅長的事：
1. 死代碼消除
2. 常數摺疊和傳播
3. 循環優化
4. 向量化
5. 函數內聯
6. 尾遞迴優化
</code></pre>
<hr />
<h2 id="llvm-優化能力與限制"><a class="header" href="#llvm-優化能力與限制">LLVM 優化能力與限制</a></h2>
<h3 id="llvm-優化-pass-管線"><a class="header" href="#llvm-優化-pass-管線">LLVM 優化 Pass 管線</a></h3>
<pre><code>源 IR → [分析] → [轉換] → [分析] → [轉換] → ... → 優化的 IR

常見優化 Pass：
├─ SimplifyCFG（簡化控制流）
├─ SROA（聚合替換）
├─ EarlyCSE（早期公共子表達式消除）
├─ Inline（函數內聯）
├─ InstCombine（指令組合）
├─ LoopRotate（循環旋轉）
├─ LoopVectorize（循環向量化）
├─ SLP（超字級平行）
└─ DeadCodeElimination（死代碼消除）
</code></pre>
<h3 id="優化範例循環向量化"><a class="header" href="#優化範例循環向量化">優化範例：循環向量化</a></h3>
<h4 id="原始-c-程式碼"><a class="header" href="#原始-c-程式碼">原始 C 程式碼</a></h4>
<pre><code class="language-c">void add_arrays(float* a, float* b, float* c, int n) {
    for (int i = 0; i &lt; n; i++) {
        c[i] = a[i] + b[i];
    }
}
</code></pre>
<h4 id="llvm-優化前的-ir簡化版"><a class="header" href="#llvm-優化前的-ir簡化版">LLVM 優化前的 IR（簡化版）</a></h4>
<pre><code class="language-llvm">define void @add_arrays(float* %a, float* %b, float* %c, i32 %n) {
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %next_i, %loop ]
  %a_ptr = getelementptr float, float* %a, i32 %i
  %b_ptr = getelementptr float, float* %b, i32 %i
  %c_ptr = getelementptr float, float* %c, i32 %i
  %a_val = load float, float* %a_ptr
  %b_val = load float, float* %b_ptr
  %sum = fadd float %a_val, %b_val
  store float %sum, float* %c_ptr
  %next_i = add i32 %i, 1
  %done = icmp eq i32 %next_i, %n
  br i1 %done, label %exit, label %loop

exit:
  ret void
}
</code></pre>
<h4 id="llvm-向量化後的-ir簡化版"><a class="header" href="#llvm-向量化後的-ir簡化版">LLVM 向量化後的 IR（簡化版）</a></h4>
<pre><code class="language-llvm">define void @add_arrays(float* %a, float* %b, float* %c, i32 %n) {
entry:
  %n_vec = and i32 %n, -4  ; 向量化部分的長度
  br label %vector_loop

vector_loop:
  %i = phi i32 [ 0, %entry ], [ %next_i, %vector_loop ]
  %a_ptr = getelementptr float, float* %a, i32 %i
  %b_ptr = getelementptr float, float* %b, i32 %i
  %c_ptr = getelementptr float, float* %c, i32 %i
  %a_vec = bitcast float* %a_ptr to &lt;4 x float&gt;*
  %b_vec = bitcast float* %b_ptr to &lt;4 x float&gt;*
  %c_vec = bitcast float* %c_ptr to &lt;4 x float&gt;*
  %a_val = load &lt;4 x float&gt;, &lt;4 x float&gt;* %a_vec
  %b_val = load &lt;4 x float&gt;, &lt;4 x float&gt;* %b_vec
  %sum = fadd &lt;4 x float&gt; %a_val, %b_val
  store &lt;4 x float&gt; %sum, &lt;4 x float&gt;* %c_vec
  %next_i = add i32 %i, 4
  %done = icmp uge i32 %next_i, %n_vec
  br i1 %done, label %scalar_loop, label %vector_loop

scalar_loop:
  ; 處理剩餘元素
  ; ...
}
</code></pre>
<h3 id="llvm-不能優化的情況"><a class="header" href="#llvm-不能優化的情況">LLVM 不能優化的情況</a></h3>
<pre><code class="language-c">// 1. 有副作用的函數調用
int process(int x) {
    printf("Processing %d\n", x);  // LLVM 不能移除
    return x * 2;
}

// 2. 語言要求的檢查
// Rust 的陣列邊界檢查（debug mode）
let value = array[index];  // 必須保留邊界檢查

// 3. 記憶體模型約束
// Go 的 GC write barrier
*ptr = value  // 需要通知 GC

// 4. 原子操作
atomic_store(&amp;shared_var, value);  // 不能重排序
</code></pre>
<hr />
<h2 id="實際案例分析"><a class="header" href="#實際案例分析">實際案例分析</a></h2>
<h3 id="案例-1相同演算法不同語言的效能"><a class="header" href="#案例-1相同演算法不同語言的效能">案例 1：相同演算法，不同語言的效能</a></h3>
<p><strong>測試：計算斐波那契數列第 40 項</strong></p>
<pre><code class="language-c">// C - 基準效能
int fib(int n) {
    if (n &lt;= 1) return n;
    return fib(n-1) + fib(n-2);
}
// 執行時間：~1.0 秒

// Rust - 相同效能
fn fib(n: i32) -&gt; i32 {
    if n &lt;= 1 { n } else { fib(n-1) + fib(n-2) }
}
// 執行時間：~1.0 秒

// Go - 稍慢（函數調用開銷）
func fib(n int) int {
    if n &lt;= 1 { return n }
    return fib(n-1) + fib(n-2)
}
// 執行時間：~1.2 秒

// Python - 極慢（解釋執行）
def fib(n):
    if n &lt;= 1: return n
    return fib(n-1) + fib(n-2)
// 執行時間：~30 秒

// Python + Numba (LLVM JIT) - 接近 C
@numba.jit
def fib_jit(n):
    if n &lt;= 1: return n
    return fib_jit(n-1) + fib_jit(n-2)
// 執行時間：~1.1 秒（不含編譯時間）
</code></pre>
<h3 id="案例-2向量運算效能比較"><a class="header" href="#案例-2向量運算效能比較">案例 2：向量運算效能比較</a></h3>
<pre><code class="language-python"># NumPy（C + SIMD）
import numpy as np
a = np.random.rand(1000000)
b = np.random.rand(1000000)
c = a + b  # ~2ms

# Pure Python
a = [random.random() for _ in range(1000000)]
b = [random.random() for _ in range(1000000)]
c = [x + y for x, y in zip(a, b)]  # ~200ms

# Rust
let a: Vec&lt;f64&gt; = (0..1000000).map(|_| rand()).collect();
let b: Vec&lt;f64&gt; = (0..1000000).map(|_| rand()).collect();
let c: Vec&lt;f64&gt; = a.iter().zip(b.iter()).map(|(x, y)| x + y).collect();
// ~2ms（自動向量化）
</code></pre>
<h3 id="案例-3字串處理效能"><a class="header" href="#案例-3字串處理效能">案例 3：字串處理效能</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust - 零成本抽象
fn count_words(text: &amp;str) -&gt; usize {
    text.split_whitespace().count()
}
// 直接操作記憶體，無分配

// Go - 需要分配
func countWords(text string) int {
    return len(strings.Fields(text))  // 分配切片
}

// Python - 多層抽象
def count_words(text):
    return len(text.split())  # 建立列表物件
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="效能優化建議"><a class="header" href="#效能優化建議">效能優化建議</a></h2>
<h3 id="選擇適合的語言"><a class="header" href="#選擇適合的語言">選擇適合的語言</a></h3>
<pre><code>計算密集型 + 需要控制：
→ C/C++/Rust/Zig

並發 + 網路服務：
→ Go/Java/C#

科學計算 + 原型開發：
→ Julia/Python+NumPy

系統程式 + 安全性：
→ Rust/Zig

Web + 快速開發：
→ TypeScript/Python/Ruby
</code></pre>
<h3 id="理解語言特性對效能的影響"><a class="header" href="#理解語言特性對效能的影響">理解語言特性對效能的影響</a></h3>
<ol>
<li>
<p><strong>記憶體分配</strong></p>
<ul>
<li>避免不必要的分配</li>
<li>使用物件池</li>
<li>預分配容器</li>
</ul>
</li>
<li>
<p><strong>類型資訊</strong></p>
<ul>
<li>提供類型提示（Python）</li>
<li>使用靜態類型（TypeScript）</li>
<li>避免 any/Object 類型</li>
</ul>
</li>
<li>
<p><strong>抽象層級</strong></p>
<ul>
<li>理解抽象成本</li>
<li>必要時使用低階 API</li>
<li>Profile 驗證效能</li>
</ul>
</li>
</ol>
<h3 id="善用編譯器優化"><a class="header" href="#善用編譯器優化">善用編譯器優化</a></h3>
<pre><code class="language-bash"># C/C++ 優化等級
gcc -O0  # 無優化（除錯用）
gcc -O1  # 基本優化
gcc -O2  # 推薦（平衡編譯時間和效能）
gcc -O3  # 激進優化
gcc -Ofast  # 可能違反標準的優化

# Rust 優化
cargo build --release  # 開啟優化

# Link-Time Optimization (LTO)
gcc -flto  # 跨編譯單元優化
cargo build --release -- -C lto=true
</code></pre>
<hr />
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<h3 id="關鍵要點"><a class="header" href="#關鍵要點">關鍵要點</a></h3>
<ol>
<li>
<p><strong>LLVM 是工具，不是魔法</strong></p>
<ul>
<li>提供優秀的優化和多平臺支援</li>
<li>但無法改變語言的根本設計</li>
</ul>
</li>
<li>
<p><strong>語言設計決定效能上限</strong></p>
<ul>
<li>記憶體模型（GC vs 手動管理）</li>
<li>類型系統（靜態 vs 動態）</li>
<li>抽象成本（零成本 vs 運行時）</li>
</ul>
</li>
<li>
<p><strong>前端品質影響 IR 品質</strong></p>
<ul>
<li>好的前端生成優化友好的 IR</li>
<li>差的前端限制 LLVM 的優化能力</li>
</ul>
</li>
<li>
<p><strong>理解優化的可能與限制</strong></p>
<ul>
<li>LLVM 擅長局部優化</li>
<li>但必須遵守語言語義</li>
<li>不能優化掉副作用</li>
</ul>
</li>
<li>
<p><strong>選擇合適的工具</strong></p>
<ul>
<li>沒有萬能的語言</li>
<li>根據需求選擇</li>
<li>理解 trade-off</li>
</ul>
</li>
</ol>
<h3 id="效能金字塔"><a class="header" href="#效能金字塔">效能金字塔</a></h3>
<pre><code>         ┌───┐
         │C/│  系統程式語言
        │Rust│  （無 GC、零成本抽象）
       │Zig/C++│
      ├─────────┤
      │Go/Swift │  現代編譯語言
     │  Kotlin  │  （有 GC、靜態類型）
    ├────────────┤
    │Java (JIT)  │  JVM/CLR 語言
   │   C# (JIT)  │  （JIT 優化）
  ├───────────────┤
  │Julia/JavaScript│  動態 JIT 語言
 │  Python+Numba   │  （部分 JIT）
├───────────────────┤
│Python/Ruby/PHP    │  解釋型語言
└───────────────────┘  （最慢但最靈活）
</code></pre>
<p>記住：<strong>使用 LLVM ≠ 自動獲得 C 的效能</strong>，但 LLVM 確實是現代編譯器基礎設施的最佳選擇之一！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tools/cross-compiler-llvm-gcc-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tools/03_網路與服務工具.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tools/cross-compiler-llvm-gcc-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tools/03_網路與服務工具.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
