<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Process、Thread 與系統概念完整指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-processthread-與系統概念完整指南"><a class="header" href="#linux-processthread-與系統概念完整指南">Linux Process、Thread 與系統概念完整指南</a></h1>
<h2 id="1-空間劃分概念"><a class="header" href="#1-空間劃分概念">1. 空間劃分概念</a></h2>
<pre><code>Memory Layout:
┌─────────────────┐ 0xFFFFFFFF
│   Kernel Space  │ (內核空間)
│   - 內核代碼    │
│   - 內核數據    │
│   - 驅動程序    │
├─────────────────┤ 0xC0000000 (典型分界)
│   User Space    │ (用戶空間)
│   - 應用程序    │
│   - 庫文件      │
│   - 用戶數據    │
└─────────────────┘ 0x00000000
</code></pre>
<h2 id="2-常見混淆概念對比"><a class="header" href="#2-常見混淆概念對比">2. 常見混淆概念對比</a></h2>
<h3 id="混淆一pid-的不同含義"><a class="header" href="#混淆一pid-的不同含義">混淆一：PID 的不同含義</a></h3>
<pre><code>User Space 視角:
Process A (PID=1234)
├─ Thread 1 
├─ Thread 2
└─ Thread 3

Kernel Space 視角:
task_struct (PID=1234, TGID=1234)  ← Process A 主線程
task_struct (PID=1235, TGID=1234)  ← Thread 1
task_struct (PID=1236, TGID=1234)  ← Thread 2  
task_struct (PID=1237, TGID=1234)  ← Thread 3
</code></pre>
<p><strong>關鍵理解</strong>：</p>
<ul>
<li>User space 的 "PID" = Kernel 的 "TGID"</li>
<li>Kernel 的每個 task 都有獨立的 PID</li>
</ul>
<h3 id="混淆二process-vs-thread-的本質"><a class="header" href="#混淆二process-vs-thread-的本質">混淆二：Process vs Thread 的本質</a></h3>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>User Space 視角</th><th>Kernel Space 視角</th></tr></thead><tbody>
<tr><td>Process</td><td>獨立的程序實體</td><td>一組共享 TGID 的 task</td></tr>
<tr><td>Thread</td><td>Process 內的執行單元</td><td>就是 task，與 process 無區別</td></tr>
<tr><td>創建方式</td><td><code>fork()</code>, <code>exec()</code> vs <code>pthread_create()</code></td><td>都是 <code>clone()</code>，只是參數不同</td></tr>
</tbody></table>
</div>
<h3 id="混淆三資源管理"><a class="header" href="#混淆三資源管理">混淆三：資源管理</a></h3>
<pre><code class="language-c">// User Space 認知
Process A: 有自己的記憶體、檔案等
  Thread 1: 共享 Process A 的資源
  Thread 2: 共享 Process A 的資源

// Kernel Space 實際
task_struct A: 指向一組共享資源
task_struct B: 指向相同的 mm_struct (記憶體)、files_struct (檔案) 等
task_struct C: 指向相同的共享資源
</code></pre>
<h2 id="3-權限與保護"><a class="header" href="#3-權限與保護">3. 權限與保護</a></h2>
<pre><code>User Space (Ring 3):
- 受限制的指令集
- 無法直接存取硬體
- 透過 system call 請求服務

System Call Interface:
- read(), write(), fork(), clone()
- 從 user mode 切換到 kernel mode

Kernel Space (Ring 0):  
- 完整的指令集權限
- 直接存取硬體
- 管理所有資源
</code></pre>
<h2 id="4-調度的誤解"><a class="header" href="#4-調度的誤解">4. 調度的誤解</a></h2>
<p><strong>❌ 錯誤認知</strong>：Kernel 調度 process，process 內部調度 thread</p>
<p><strong>✅ 正確理解</strong>：</p>
<pre><code>Linux Scheduler (CFS):
├─ task_struct (原 Process A 主線程)
├─ task_struct (原 Thread 1)  
├─ task_struct (原 Thread 2)
├─ task_struct (原 Process B)
└─ task_struct (原 Thread 3)
</code></pre>
<ul>
<li>Kernel 只看到 task，統一調度</li>
<li>不區分來源是 process 還是 thread</li>
</ul>
<h2 id="5-創建方式的差異"><a class="header" href="#5-創建方式的差異">5. 創建方式的差異</a></h2>
<pre><code class="language-c">// 創建 process (fork)
clone(SIGCHLD)

// 創建 thread (pthread_create 內部調用)
clone(CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD, ...)
</code></pre>
<h3 id="clone-flags-說明"><a class="header" href="#clone-flags-說明">Clone Flags 說明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>意義</th></tr></thead><tbody>
<tr><td><code>SIGCHLD</code></td><td>子進程結束時發送信號給父進程</td></tr>
<tr><td><code>CLONE_VM</code></td><td>共享虛擬記憶體空間</td></tr>
<tr><td><code>CLONE_FILES</code></td><td>共享檔案描述符表</td></tr>
<tr><td><code>CLONE_FS</code></td><td>共享檔案系統資訊</td></tr>
<tr><td><code>CLONE_SIGHAND</code></td><td>共享信號處理器</td></tr>
<tr><td><code>CLONE_THREAD</code></td><td>放入同一個 thread group</td></tr>
</tbody></table>
</div>
<h2 id="6-實際例子對比"><a class="header" href="#6-實際例子對比">6. 實際例子對比</a></h2>
<pre><code class="language-bash"># User Space 命令
ps aux              # 看到 process 列表
ps -eLf            # 看到 thread 列表  
top                # 預設顯示 process

# 對應的 Kernel 視角
cat /proc/*/task/*  # 每個都是 task_struct
ls /proc/*/task/    # 看到所有 task ID
</code></pre>
<h2 id="7-重要標識符"><a class="header" href="#7-重要標識符">7. 重要標識符</a></h2>
<h3 id="user-space-視角"><a class="header" href="#user-space-視角">User Space 視角</a></h3>
<ul>
<li><strong>PID</strong>: Process ID（實際上是 Kernel 的 TGID）</li>
<li><strong>TID</strong>: Thread ID（在某些工具中顯示）</li>
</ul>
<h3 id="kernel-space-視角"><a class="header" href="#kernel-space-視角">Kernel Space 視角</a></h3>
<ul>
<li><strong>PID</strong>: 每個 task_struct 的唯一 ID</li>
<li><strong>TGID</strong>: Thread Group ID，同一 process 內所有 thread 共享</li>
</ul>
<pre><code>實際對應關係:
User Space PID = Kernel Space TGID
User Space TID = Kernel Space PID
</code></pre>
<h2 id="8-核心要點記憶法"><a class="header" href="#8-核心要點記憶法">8. 核心要點記憶法</a></h2>
<ol>
<li><strong>統一原則</strong>：Kernel 把一切都當作 task</li>
<li><strong>共享程度</strong>：Process vs Thread 只是資源共享程度不同</li>
<li><strong>視角差異</strong>：User space 有層次概念，Kernel space 是平面的</li>
<li><strong>PID 混淆</strong>：User 的 PID = Kernel 的 TGID</li>
<li><strong>調度統一</strong>：Kernel 調度器不區分 process/thread</li>
</ol>
<h2 id="9-thread-vs-process-基本概念與常見誤解"><a class="header" href="#9-thread-vs-process-基本概念與常見誤解">9. Thread vs Process 基本概念與常見誤解</a></h2>
<h3 id="基本定義對比"><a class="header" href="#基本定義對比">基本定義對比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Process</th><th>Thread</th></tr></thead><tbody>
<tr><td><strong>定義</strong></td><td>獨立的執行環境</td><td>Process 內的執行單元</td></tr>
<tr><td><strong>記憶體</strong></td><td>獨立的地址空間</td><td>共享 Process 的地址空間</td></tr>
<tr><td><strong>創建成本</strong></td><td>高（需複製資源）</td><td>低（共享現有資源）</td></tr>
<tr><td><strong>通信方式</strong></td><td>IPC（管道、信號、共享記憶體）</td><td>直接存取共享變數</td></tr>
<tr><td><strong>錯誤隔離</strong></td><td>一個 Process 崩潰不影響其他</td><td>一個 Thread 崩潰可能影響整個 Process</td></tr>
</tbody></table>
</div>
<h3 id="常見誤解與澄清"><a class="header" href="#常見誤解與澄清">常見誤解與澄清</a></h3>
<h4 id="誤解一thread-比較快"><a class="header" href="#誤解一thread-比較快">誤解一：「Thread 比較快」</a></h4>
<pre><code>❌ 錯誤理解：Thread 執行比 Process 快
✅ 正確理解：
- Thread 創建/切換成本較低
- 但執行速度取決於工作負載，不是 Thread/Process 本身
- 單核心上過多 Thread 反而可能因競爭資源而變慢
</code></pre>
<h4 id="誤解二process-無法共享資料"><a class="header" href="#誤解二process-無法共享資料">誤解二：「Process 無法共享資料」</a></h4>
<pre><code>❌ 錯誤理解：Process 間完全無法共享資料
✅ 正確理解：Process 可透過多種 IPC 機制共享資料
- 共享記憶體 (shared memory)
- 記憶體映射檔案 (mmap)
- 管道 (pipe)、訊息佇列等
</code></pre>
<h4 id="誤解三thread-一定比-process-省記憶體"><a class="header" href="#誤解三thread-一定比-process-省記憶體">誤解三：「Thread 一定比 Process 省記憶體」</a></h4>
<pre><code>❌ 錯誤理解：Thread 總是比 Process 節省記憶體
✅ 正確理解：
- Thread 共享 code、data、heap 區段
- 但每個 Thread 仍需獨立的 stack 空間
- 大量 Thread 的 stack 總和可能很可觀
</code></pre>
<h2 id="10-記憶體管理深度解析"><a class="header" href="#10-記憶體管理深度解析">10. 記憶體管理深度解析</a></h2>
<h3 id="process-記憶體布局"><a class="header" href="#process-記憶體布局">Process 記憶體布局</a></h3>
<pre><code>Process A 記憶體空間:
┌─────────────────┐ 高位址
│     Stack       │ ← 各 Thread 獨立
├─────────────────┤
│       ↓         │
│                 │
│   未使用空間    │
│                 │
│       ↑         │ 
├─────────────────┤
│      Heap       │ ← 所有 Thread 共享
├─────────────────┤
│  Uninitialized  │ ← BSS 段
│     Data        │
├─────────────────┤  
│   Initialized   │ ← Data 段 (所有 Thread 共享)
│     Data        │
├─────────────────┤
│      Code       │ ← Text 段 (所有 Thread 共享)
└─────────────────┘ 低位址
</code></pre>
<h3 id="thread-記憶體共享詳解"><a class="header" href="#thread-記憶體共享詳解">Thread 記憶體共享詳解</a></h3>
<pre><code class="language-c">// 共享區域 (所有 Thread 可存取)
- Code segment (程式碼)
- Data segment (全域變數、靜態變數)  
- Heap (malloc/new 分配的記憶體)
- 開啟的檔案描述符
- 信號處理器

// 私有區域 (各 Thread 獨立)
- Stack (區域變數、函數參數)
- 暫存器狀態
- Program Counter (PC)
- Stack Pointer (SP)
</code></pre>
<h3 id="記憶體相關誤解"><a class="header" href="#記憶體相關誤解">記憶體相關誤解</a></h3>
<h4 id="誤解一thread-共享所有記憶體"><a class="header" href="#誤解一thread-共享所有記憶體">誤解一：「Thread 共享所有記憶體」</a></h4>
<pre><code>❌ 錯誤：Thread 共享包含 stack 在內的所有記憶體
✅ 正確：Thread 有各自獨立的 stack 空間

實例:
void* thread_func(void* arg) {
    int local_var = 10;  // 各 Thread 獨立，存在各自 stack
    static int static_var = 20;  // 所有 Thread 共享
    return NULL;
}
</code></pre>
<h4 id="誤解二process-fork-會完整複製記憶體"><a class="header" href="#誤解二process-fork-會完整複製記憶體">誤解二：「Process fork 會完整複製記憶體」</a></h4>
<pre><code>❌ 錯誤：fork() 立即複製所有記憶體內容
✅ 正確：現代系統使用 Copy-on-Write (COW)

機制說明:
1. fork() 後，父子 Process 共享相同的實體記憶體頁面
2. 當任一方嘗試寫入時，才真正複製該頁面
3. 大幅減少 fork() 的記憶體成本
</code></pre>
<h4 id="誤解三thread-stack-大小固定"><a class="header" href="#誤解三thread-stack-大小固定">誤解三：「Thread Stack 大小固定」</a></h4>
<pre><code>❌ 錯誤：每個 Thread 都有固定大小的 stack
✅ 正確：Stack 大小可以設定，且有預設值

Linux 預設值:
- 主 Thread: 8MB (可透過 ulimit 調整)
- 其他 Thread: 2MB (可透過 pthread_attr_setstacksize 調整)

查看方式:
ulimit -s          # 查看 stack 大小限制
cat /proc/PID/maps # 查看記憶體映射
</code></pre>
<h3 id="virtual-memory-與實際記憶體"><a class="header" href="#virtual-memory-與實際記憶體">Virtual Memory 與實際記憶體</a></h3>
<pre><code>虛擬記憶體視角:
Process A: 0x00000000 - 0xFFFFFFFF (4GB 虛擬空間)
Process B: 0x00000000 - 0xFFFFFFFF (4GB 虛擬空間)

實體記憶體視角:
實際可能只有 8GB RAM，透過 MMU 進行映射
- 相同虛擬位址可能對應不同實體位址
- 相同實體位址可能被多個虛擬位址映射 (shared library)
</code></pre>
<h3 id="記憶體洩漏常見情境"><a class="header" href="#記憶體洩漏常見情境">記憶體洩漏常見情境</a></h3>
<h4 id="thread-相關記憶體洩漏"><a class="header" href="#thread-相關記憶體洩漏">Thread 相關記憶體洩漏</a></h4>
<pre><code class="language-c">// ❌ 常見錯誤
pthread_t threads[1000];
for (int i = 0; i &lt; 1000; i++) {
    pthread_create(&amp;threads[i], NULL, worker, NULL);
    // 忘記 pthread_join 或 pthread_detach
}
// 結果：Thread 資源無法回收

// ✅ 正確做法
pthread_t thread;
pthread_create(&amp;thread, NULL, worker, NULL);
pthread_join(thread, NULL);  // 或 pthread_detach(thread);
</code></pre>
<h4 id="共享記憶體洩漏"><a class="header" href="#共享記憶體洩漏">共享記憶體洩漏</a></h4>
<pre><code class="language-c">// ❌ 多個 Thread 都去 malloc，但只有一個 free
void* shared_ptr = malloc(1024);  // Thread 1 分配
free(shared_ptr);                 // Thread 2 釋放，其他 Thread 不知道

// ✅ 明確記憶體管理責任
// 使用 reference counting 或明確定義 owner
</code></pre>
<h2 id="11-實務除錯技巧"><a class="header" href="#11-實務除錯技巧">11. 實務除錯技巧</a></h2>
<h3 id="查看-processthread-狀態"><a class="header" href="#查看-processthread-狀態">查看 Process/Thread 狀態</a></h3>
<pre><code class="language-bash"># 查看 Process 記憶體使用
cat /proc/PID/status | grep -E "(VmSize|VmRSS|Threads)"

# 查看所有 Thread
ps -eLf | grep PROCESS_NAME

# 查看記憶體映射
cat /proc/PID/maps

# 即時監控
htop -H    # 顯示 Thread
</code></pre>
<h3 id="gdb-除錯-thread"><a class="header" href="#gdb-除錯-thread">GDB 除錯 Thread</a></h3>
<pre><code class="language-bash"># 查看所有 Thread
(gdb) info threads

# 切換到特定 Thread
(gdb) thread 2

# 查看 Thread 的 stack
(gdb) bt

# 查看共享變數
(gdb) print global_variable
</code></pre>
<h2 id="12-signal-與-processthread-關係"><a class="header" href="#12-signal-與-processthread-關係">12. Signal 與 Process/Thread 關係</a></h2>
<h3 id="signal-常見誤解"><a class="header" href="#signal-常見誤解">Signal 常見誤解</a></h3>
<h4 id="誤解一signal-只發給-process"><a class="header" href="#誤解一signal-只發給-process">誤解一：「Signal 只發給 Process」</a></h4>
<pre><code>❌ 錯誤：Signal 只能發送給整個 Process
✅ 正確：Linux 支持發送 Signal 給特定 Thread

發送方式:
kill(pid, SIGTERM);                 // 發給整個 Process Group  
pthread_kill(thread_id, SIGTERM);   // 發給特定 Thread
tgkill(tgid, tid, SIGTERM);         // Kernel 層面發給特定 Thread
</code></pre>
<h4 id="誤解二多個-thread-會同時收到-signal"><a class="header" href="#誤解二多個-thread-會同時收到-signal">誤解二：「多個 Thread 會同時收到 Signal」</a></h4>
<pre><code>❌ 錯誤：Signal 發給 Process 時所有 Thread 都會收到
✅ 正確：只有一個 Thread 會處理 Signal

處理規則:
1. 如果有 Thread 明確 blocked 該 Signal → 跳過
2. 如果有 Thread 在等待該 Signal (sigwait) → 優先給它
3. 否則隨機選一個 Thread 處理
</code></pre>
<h3 id="signal-mask-機制"><a class="header" href="#signal-mask-機制">Signal Mask 機制</a></h3>
<pre><code class="language-c">// 各 Thread 有獨立的 Signal Mask
sigset_t set;
sigemptyset(&amp;set);
sigaddset(&amp;set, SIGINT);
pthread_sigmask(SIG_BLOCK, &amp;set, NULL);  // 只影響當前 Thread

// 但 Signal Handler 是所有 Thread 共享的
signal(SIGINT, handler);  // 影響整個 Process
</code></pre>
<h2 id="13-file-descriptor-與-processthread"><a class="header" href="#13-file-descriptor-與-processthread">13. File Descriptor 與 Process/Thread</a></h2>
<h3 id="檔案描述符共享機制"><a class="header" href="#檔案描述符共享機制">檔案描述符共享機制</a></h3>
<h4 id="fork-後的-fd-行為"><a class="header" href="#fork-後的-fd-行為">Fork 後的 FD 行為</a></h4>
<pre><code class="language-c">int fd = open("test.txt", O_RDONLY);
pid_t pid = fork();

if (pid == 0) {
    // 子 Process
    read(fd, buffer, 100);  // ✅ 可以使用，與父 Process 共享
    close(fd);              // ❌ 會影響父 Process！
} else {
    // 父 Process  
    read(fd, buffer, 100);  // 可能讀到子 Process 讀過的位置
}
</code></pre>
<p><strong>關鍵概念</strong>: Fork 後 FD 共享同一個 file table entry</p>
<ul>
<li>檔案位置指標 (file offset) 是共享的</li>
<li>一方 close() 會減少 reference count</li>
<li>只有所有引用都 close() 後才真正關閉檔案</li>
</ul>
<h4 id="thread-間的-fd-共享"><a class="header" href="#thread-間的-fd-共享">Thread 間的 FD 共享</a></h4>
<pre><code class="language-c">// Thread 間完全共享 FD table
int fd = open("test.txt", O_RDONLY);

void* thread1(void* arg) {
    lseek(fd, 100, SEEK_SET);  // 設定檔案位置
    return NULL;
}

void* thread2(void* arg) {
    char buffer[10];
    read(fd, buffer, 10);  // 會從位置 100 開始讀！
    return NULL;
}
</code></pre>
<h3 id="常見-fd-管理錯誤"><a class="header" href="#常見-fd-管理錯誤">常見 FD 管理錯誤</a></h3>
<h4 id="錯誤一多-thread-同時操作同一-fd"><a class="header" href="#錯誤一多-thread-同時操作同一-fd">錯誤一：多 Thread 同時操作同一 FD</a></h4>
<pre><code class="language-c">// ❌ 危險：多個 Thread 同時寫入同一檔案
void* writer_thread(void* arg) {
    write(shared_fd, data, size);  // 可能與其他 Thread 的寫入交錯
}

// ✅ 安全：使用 mutex 保護
pthread_mutex_t fd_mutex = PTHREAD_MUTEX_INITIALIZER;
void* safe_writer_thread(void* arg) {
    pthread_mutex_lock(&amp;fd_mutex);
    write(shared_fd, data, size);
    pthread_mutex_unlock(&amp;fd_mutex);
}
</code></pre>
<h4 id="錯誤二忘記設定-fd_cloexec"><a class="header" href="#錯誤二忘記設定-fd_cloexec">錯誤二：忘記設定 FD_CLOEXEC</a></h4>
<pre><code class="language-c">// ❌ 子 Process 會繼承不必要的 FD
int fd = open("config.txt", O_RDONLY);
execve("/usr/bin/program", argv, envp);  // program 也能存取 config.txt

// ✅ 使用 FD_CLOEXEC
int fd = open("config.txt", O_RDONLY);  
fcntl(fd, F_SETFD, FD_CLOEXEC);  // exec 時自動關閉
</code></pre>
<h2 id="14-同步機制常見誤解"><a class="header" href="#14-同步機制常見誤解">14. 同步機制常見誤解</a></h2>
<h3 id="mutex-vs-spinlock-vs-semaphore"><a class="header" href="#mutex-vs-spinlock-vs-semaphore">Mutex vs Spinlock vs Semaphore</a></h3>
<div class="table-wrapper"><table><thead><tr><th>機制</th><th>使用時機</th><th>CPU 行為</th><th>適用場景</th></tr></thead><tbody>
<tr><td><strong>Mutex</strong></td><td>長時間等待</td><td>Thread 讓出 CPU</td><td>I/O 操作、長運算</td></tr>
<tr><td><strong>Spinlock</strong></td><td>短時間等待</td><td>持續檢查，不讓出 CPU</td><td>保護共享計數器</td></tr>
<tr><td><strong>Semaphore</strong></td><td>資源計數</td><td>可設定資源數量</td><td>連線池、記憶體池</td></tr>
</tbody></table>
</div>
<h3 id="常見同步錯誤"><a class="header" href="#常見同步錯誤">常見同步錯誤</a></h3>
<h4 id="錯誤一誤用-spinlock"><a class="header" href="#錯誤一誤用-spinlock">錯誤一：誤用 Spinlock</a></h4>
<pre><code class="language-c">// ❌ 錯誤：在可能長時間等待的場景使用 Spinlock
spinlock_t lock;
spin_lock(&amp;lock);
sleep(1);  // 持有 lock 時睡眠 → CPU 空轉
spin_unlock(&amp;lock);

// ✅ 正確：使用 Mutex
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&amp;mutex);
sleep(1);
pthread_mutex_unlock(&amp;mutex);
</code></pre>
<h4 id="錯誤二死鎖-deadlock"><a class="header" href="#錯誤二死鎖-deadlock">錯誤二：死鎖 (Deadlock)</a></h4>
<pre><code class="language-c">// ❌ 典型死鎖場景
Thread 1: lock(A) → lock(B)
Thread 2: lock(B) → lock(A)

// ✅ 解決方案：統一加鎖順序
void safe_function() {
    // 總是先鎖 A 再鎖 B
    pthread_mutex_lock(&amp;mutex_A);
    pthread_mutex_lock(&amp;mutex_B);
    // 做事情
    pthread_mutex_unlock(&amp;mutex_B);
    pthread_mutex_unlock(&amp;mutex_A);
}
</code></pre>
<h2 id="15-context-switch-開銷誤解"><a class="header" href="#15-context-switch-開銷誤解">15. Context Switch 開銷誤解</a></h2>
<h3 id="真實的-context-switch-成本"><a class="header" href="#真實的-context-switch-成本">真實的 Context Switch 成本</a></h3>
<pre><code>Process Context Switch:
1. 保存暫存器狀態     (~50 cycles)
2. 切換記憶體映射表   (~100-500 cycles) ← 昂貴
3. TLB flush         (~1000+ cycles) ← 非常昂貴  
4. Cache miss penalty (~數千 cycles) ← 最昂貴

Thread Context Switch (同一 Process):
1. 保存暫存器狀態     (~50 cycles)
2. 切換 Stack pointer (~10 cycles)
3. 不需切換記憶體映射 ← 省下大量成本
</code></pre>
<h4 id="誤解thread-switch-沒有成本"><a class="header" href="#誤解thread-switch-沒有成本">誤解：「Thread Switch 沒有成本」</a></h4>
<pre><code>❌ 錯誤：Thread 間切換完全沒有開銷
✅ 正確：有開銷，但比 Process Switch 小很多

實際測量:
Process Switch: ~1-10 microseconds  
Thread Switch:  ~0.1-1 microseconds
Function Call:  ~1-10 nanoseconds
</code></pre>
<h2 id="16-系統限制與配置"><a class="header" href="#16-系統限制與配置">16. 系統限制與配置</a></h2>
<h3 id="重要的系統限制"><a class="header" href="#重要的系統限制">重要的系統限制</a></h3>
<pre><code class="language-bash"># Thread 相關限制
cat /proc/sys/kernel/threads-max     # 系統最大 Thread 數
ulimit -u                           # 每個使用者最大 Process 數
cat /proc/sys/kernel/pid_max        # 最大 PID 值

# 記憶體相關限制  
ulimit -s                           # Stack 大小限制
ulimit -v                           # 虛擬記憶體限制
cat /proc/sys/vm/max_map_count      # 記憶體映射數量限制

# 檔案相關限制
ulimit -n                           # 每個 Process 最大 FD 數
cat /proc/sys/fs/file-max           # 系統最大檔案數
</code></pre>
<h3 id="常見的無法創建-thread錯誤"><a class="header" href="#常見的無法創建-thread錯誤">常見的「無法創建 Thread」錯誤</a></h3>
<pre><code class="language-c">// 錯誤排查步驟
int ret = pthread_create(&amp;thread, NULL, worker, NULL);
if (ret != 0) {
    switch(ret) {
        case EAGAIN:  // 超過系統限制
            printf("系統資源不足或達到 Thread 數量限制\n");
            break;
        case ENOMEM:  // 記憶體不足
            printf("無法分配記憶體給新 Thread\n");  
            break;
        case EPERM:   // 權限不足
            printf("沒有權限創建 Thread\n");
            break;
    }
}
</code></pre>
<h2 id="17-效能監控與分析"><a class="header" href="#17-效能監控與分析">17. 效能監控與分析</a></h2>
<h3 id="實用監控命令"><a class="header" href="#實用監控命令">實用監控命令</a></h3>
<pre><code class="language-bash"># 即時監控 Process/Thread
htop -H                    # 顯示 Thread
top -H -p PID             # 監控特定 Process 的 Thread

# 分析 Context Switch
vmstat 1                  # cs 欄位顯示 context switch 次數
pidstat -w 1              # 每個 Process 的 context switch

# 記憶體分析
pmap PID                  # Process 記憶體映射
cat /proc/PID/smaps       # 詳細記憶體使用

# CPU 使用分析
perf top                  # 即時 CPU hotspot
perf stat -p PID          # Process 效能統計
</code></pre>
<h3 id="效能分析工具鏈"><a class="header" href="#效能分析工具鏈">效能分析工具鏈</a></h3>
<pre><code class="language-bash"># 系統呼叫追蹤
strace -f -p PID          # 追蹤 Process 及其子 Process/Thread
ltrace -f -p PID          # 追蹤函式庫呼叫

# Thread 同步分析  
helgrind ./program        # Valgrind 工具，檢測競爭條件
drd ./program             # 另一個同步檢測工具
</code></pre>
<h2 id="18-實戰最佳實踐"><a class="header" href="#18-實戰最佳實踐">18. 實戰最佳實踐</a></h2>
<h3 id="process-vs-thread-選擇指南"><a class="header" href="#process-vs-thread-選擇指南">Process vs Thread 選擇指南</a></h3>
<pre><code>選擇 Process 當：
✅ 需要強隔離性（一個崩潰不影響其他）
✅ 需要不同權限等級
✅ 需要分散到不同機器（微服務架構）
✅ CPU 密集型工作且可平行處理

選擇 Thread 當：
✅ 需要頻繁共享大量資料
✅ I/O 密集型工作（如網路服務）
✅ 需要細粒度的併發控制
✅ 記憶體使用需要優化
</code></pre>
<h3 id="避免常見陷阱"><a class="header" href="#避免常見陷阱">避免常見陷阱</a></h3>
<pre><code class="language-c">// 1. Thread 安全的單例模式
class Singleton {
private:
    static std::once_flag flag;
    static Singleton* instance;
public:
    static Singleton* getInstance() {
        std::call_once(flag, []() {
            instance = new Singleton();
        });
        return instance;
    }
};

// 2. 正確的 Thread 終止
volatile bool should_exit = false;
void* worker_thread(void* arg) {
    while (!should_exit) {
        // 做工作
        if (should_exit) break;  // 檢查退出條件
    }
    return NULL;
}

// 3. 記憶體屏障的重要性
// 在某些架構上，需要明確的記憶體屏障
__sync_synchronize();  // GCC builtin
// 或使用 C11 atomic 操作
</code></pre>
<h2 id="19-記憶體管理與-oom-out-of-memory-殺手機制"><a class="header" href="#19-記憶體管理與-oom-out-of-memory-殺手機制">19. 記憶體管理與 OOM (Out of Memory) 殺手機制</a></h2>
<h3 id="記憶體回收機制詳解"><a class="header" href="#記憶體回收機制詳解">記憶體回收機制詳解</a></h3>
<h4 id="虛擬記憶體與實體記憶體的關係"><a class="header" href="#虛擬記憶體與實體記憶體的關係">虛擬記憶體與實體記憶體的關係</a></h4>
<pre><code>虛擬記憶體分配:
Process A 要求 1GB → Linux 立即同意 (虛擬分配)
Process B 要求 2GB → Linux 立即同意 (虛擬分配)  
Process C 要求 4GB → Linux 立即同意 (虛擬分配)

實體記憶體分配:
只有在實際存取時才分配實體記憶體頁面
這就是「延遲分配」(Lazy Allocation) 或「按需分頁」(Demand Paging)
</code></pre>
<h4 id="記憶體回收的層次"><a class="header" href="#記憶體回收的層次">記憶體回收的層次</a></h4>
<pre><code>記憶體壓力響應機制:
1. Page Cache 回收    ← 最溫和，釋放檔案快取
2. Swap 機制啟動      ← 將記憶體頁面寫入交換空間
3. 主動回收機制       ← kswapd 背景進程啟動
4. 直接回收          ← 分配記憶體時同步回收
5. OOM Killer 啟動   ← 最後手段，殺死進程
</code></pre>
<h3 id="oom-殺手-oom-killer-工作原理"><a class="header" href="#oom-殺手-oom-killer-工作原理">OOM 殺手 (OOM Killer) 工作原理</a></h3>
<h4 id="oom-killer-觸發條件"><a class="header" href="#oom-killer-觸發條件">OOM Killer 觸發條件</a></h4>
<pre><code>觸發場景:
1. 實體記憶體 + Swap 空間都耗盡
2. 特定記憶體域 (memory zone) 耗盡
3. 記憶體碎片化嚴重，無法分配大塊連續記憶體
4. cgroup 記憶體限制達到上限

常見誤解:
❌ 錯誤：「記憶體用完就會 OOM」
✅ 正確：「無法分配必要的記憶體才會 OOM」
</code></pre>
<h4 id="oom-score-計算機制"><a class="header" href="#oom-score-計算機制">OOM Score 計算機制</a></h4>
<pre><code class="language-bash"># 查看進程的 OOM Score
cat /proc/PID/oom_score      # 當前分數 (0-1000)
cat /proc/PID/oom_score_adj  # 調整值 (-1000 到 1000)

# OOM Score 計算因子
影響因子              權重說明
記憶體使用量          使用越多分數越高
CPU 時間             運行時間短的進程分數較高  
Nice 值              Nice 值高的進程分數較高
是否為 Root 進程      Root 進程分數會降低
子進程數量           有很多子進程的分數較高
</code></pre>
<h4 id="oom-killer-選擇邏輯-白話解釋"><a class="header" href="#oom-killer-選擇邏輯-白話解釋">OOM Killer 選擇邏輯 (白話解釋)</a></h4>
<pre><code>OOM Killer 的心理活動:
1. "誰用了最多記憶體？" → 記憶體大戶優先考慮
2. "誰剛啟動不久？" → 新進程比老進程更容易被選中
3. "誰不重要？" → Nice 值高的進程更容易被選中
4. "誰是 Root？" → Root 進程有一定保護
5. "殺掉誰能釋放最多記憶體？" → 效益最大化

簡化公式:
OOM Score = (記憶體使用百分比 × 10) + oom_score_adj + 其他修正
</code></pre>
<h3 id="記憶體洩漏-vs-oom-的區別"><a class="header" href="#記憶體洩漏-vs-oom-的區別">記憶體洩漏 vs OOM 的區別</a></h3>
<h4 id="記憶體洩漏-memory-leak"><a class="header" href="#記憶體洩漏-memory-leak">記憶體洩漏 (Memory Leak)</a></h4>
<pre><code class="language-c">// 典型的記憶體洩漏
void leaky_function() {
    for (int i = 0; i &lt; 1000; i++) {
        char *ptr = malloc(1024 * 1024);  // 分配 1MB
        // 忘記 free(ptr); ← 記憶體洩漏
        
        // 即使離開函數，記憶體仍被佔用
        // 虛擬記憶體和實體記憶體都無法回收
    }
}

洩漏特徵:
- 程式仍在運行但記憶體使用持續增長
- 重啟程式後記憶體使用恢復正常
- 影響整個系統的記憶體可用性
</code></pre>
<h4 id="記憶體溢出-oom"><a class="header" href="#記憶體溢出-oom">記憶體溢出 (OOM)</a></h4>
<pre><code class="language-c">// 瞬間大量分配導致 OOM
void oom_function() {
    // 嘗試分配 8GB 記憶體
    char *huge_buffer = malloc(8L * 1024 * 1024 * 1024);
    
    if (huge_buffer == NULL) {
        printf("分配失敗，可能觸發 OOM\n");
    } else {
        // 如果分配成功但系統記憶體不足
        // 在實際使用時可能觸發 OOM Killer
        memset(huge_buffer, 0, 8L * 1024 * 1024 * 1024);
    }
}
</code></pre>
<h3 id="oom-預防與處理策略"><a class="header" href="#oom-預防與處理策略">OOM 預防與處理策略</a></h3>
<h4 id="預防措施"><a class="header" href="#預防措施">預防措施</a></h4>
<pre><code class="language-bash"># 1. 監控記憶體使用
free -h                    # 查看系統記憶體狀況
cat /proc/meminfo          # 詳細記憶體資訊
vmstat 1                   # 即時記憶體統計

# 2. 設定記憶體限制
ulimit -v 2097152          # 限制虛擬記憶體為 2GB
echo 1000000 &gt; /proc/sys/vm/max_map_count  # 限制記憶體映射數

# 3. 調整 Swap 策略
echo 10 &gt; /proc/sys/vm/swappiness  # 降低 swap 使用傾向 (0-100)
echo 1 &gt; /proc/sys/vm/overcommit_memory  # 嚴格記憶體檢查
</code></pre>
<h4 id="程式層面的防護"><a class="header" href="#程式層面的防護">程式層面的防護</a></h4>
<pre><code class="language-c">// 1. 檢查記憶體分配結果
void* safe_malloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        fprintf(stderr, "記憶體分配失敗，請求大小: %zu bytes\n", size);
        // 可以選擇退出或釋放其他資源後重試
        exit(EXIT_FAILURE);
    }
    return ptr;
}

// 2. 使用 mmap 代替大量 malloc
void* large_allocation(size_t size) {
    void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (ptr == MAP_FAILED) {
        return NULL;
    }
    return ptr;
}

// 3. 設定進程記憶體限制
#include &lt;sys/resource.h&gt;
void set_memory_limit(size_t limit_mb) {
    struct rlimit limit;
    limit.rlim_cur = limit_mb * 1024 * 1024;  // 當前限制
    limit.rlim_max = limit_mb * 1024 * 1024;  // 最大限制
    
    if (setrlimit(RLIMIT_AS, &amp;limit) != 0) {
        perror("設定記憶體限制失敗");
    }
}
</code></pre>
<h3 id="oom-killer-日誌分析"><a class="header" href="#oom-killer-日誌分析">OOM Killer 日誌分析</a></h3>
<h4 id="典型-oom-日誌解讀"><a class="header" href="#典型-oom-日誌解讀">典型 OOM 日誌解讀</a></h4>
<pre><code>[12345.678901] Out of memory: Kill process 1234 (myprogram) score 800 or sacrifice child
[12345.678902] Killed process 1234 (myprogram) total-vm:2097152kB, anon-rss:1048576kB, file-rss:0kB, shmem-rss:0kB

解讀:
- Kill process 1234: 被殺的進程 PID
- score 800: OOM Score (最高1000)
- total-vm: 總虛擬記憶體
- anon-rss: 匿名常駐記憶體 (heap, stack)
- file-rss: 檔案映射記憶體
- shmem-rss: 共享記憶體
</code></pre>
<h4 id="oom-事件監控"><a class="header" href="#oom-事件監控">OOM 事件監控</a></h4>
<pre><code class="language-bash"># 1. 查看 OOM Killer 歷史
dmesg | grep -i "killed process"
journalctl --since "1 hour ago" | grep -i oom

# 2. 實時監控記憶體壓力
cat /proc/pressure/memory      # PSI (Pressure Stall Information)
watch -n 1 'free -h &amp;&amp; echo "--- Top Memory Users ---" &amp;&amp; ps aux --sort=-%mem | head -10'

# 3. 設定 OOM 通知
echo "/usr/local/bin/oom_notify.sh" &gt; /proc/sys/vm/panic_on_oom
</code></pre>
<h3 id="容器環境下的-oom-特殊情況"><a class="header" href="#容器環境下的-oom-特殊情況">容器環境下的 OOM 特殊情況</a></h3>
<h4 id="dockerkubernetes-中的-oom"><a class="header" href="#dockerkubernetes-中的-oom">Docker/Kubernetes 中的 OOM</a></h4>
<pre><code class="language-bash"># 容器記憶體限制
docker run -m 512m myapp        # 限制容器記憶體為 512MB

# 當容器超過記憶體限制:
# 1. 容器內的進程會被 OOM Killer 殺死
# 2. 容器可能會重啟 (依 restart policy)
# 3. 不會影響宿主機上的其他容器

# 查看容器 OOM 事件
docker stats                   # 即時資源使用
kubectl top pods              # K8s Pod 資源使用
kubectl describe pod POD_NAME  # 查看 OOM 事件詳情
</code></pre>
<h3 id="記憶體除錯工具"><a class="header" href="#記憶體除錯工具">記憶體除錯工具</a></h3>
<h4 id="valgrind-記憶體檢查"><a class="header" href="#valgrind-記憶體檢查">Valgrind 記憶體檢查</a></h4>
<pre><code class="language-bash"># 檢查記憶體洩漏
valgrind --leak-check=full --show-leak-kinds=all ./myprogram

# 檢查記憶體錯誤
valgrind --tool=memcheck ./myprogram

# 分析記憶體使用模式
valgrind --tool=massif ./myprogram
ms_print massif.out.PID
</code></pre>
<h4 id="系統層面記憶體分析"><a class="header" href="#系統層面記憶體分析">系統層面記憶體分析</a></h4>
<pre><code class="language-bash"># 分析系統記憶體使用
cat /proc/buddyinfo           # 記憶體碎片資訊
cat /proc/pagetypeinfo        # 頁面類型統計
cat /proc/zoneinfo           # 記憶體區域資訊

# 分析進程記憶體映射
pmap -X PID                  # 詳細記憶體映射
cat /proc/PID/smaps          # 最詳細的記憶體使用資訊
</code></pre>
<h2 id="20-圖解複雜記憶體布局與進程關係"><a class="header" href="#20-圖解複雜記憶體布局與進程關係">20. 圖解複雜記憶體布局與進程關係</a></h2>
<h3 id="完整的記憶體分層視圖"><a class="header" href="#完整的記憶體分層視圖">完整的記憶體分層視圖</a></h3>
<pre><code>                           系統記憶體全景圖
┌─────────────────────────────────────────────────────────────────┐
│                        實體記憶體 (RAM)                        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────────────────┐ │
│  │ Page 1  │ │ Page 2  │ │ Page 3  │ │         ...            │ │
│  │  4KB    │ │  4KB    │ │  4KB    │ │                        │ │
│  └─────────┘ └─────────┘ └─────────┘ └─────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                ↑
                      記憶體管理單元 (MMU)
                                ↕
┌─────────────────────────────────────────────────────────────────┐
│                     虛擬記憶體空間映射                          │
│                                                                │
│ Process A 虛擬空間            Process B 虛擬空間               │
│ ┌─────────────────┐           ┌─────────────────┐              │
│ │ 0xFFFF0000     │           │ 0xFFFF0000     │              │
│ │    Stack       │ ────┐     │    Stack       │ ────┐        │
│ │ 0xC0000000     │     │     │ 0xC0000000     │     │        │
│ │      ↓         │     │     │      ↓         │     │        │
│ │                │     │     │                │     │        │
│ │      ↑         │     │     │      ↑         │     │        │
│ │ 0x08000000     │     │     │ 0x08000000     │     │        │
│ │    Heap        │ ────┼──── │    Heap        │ ────┼──→ 不同實體頁面
│ │ 0x00401000     │     │     │ 0x00401000     │     │        │
│ │    Data        │ ────┼──── │    Data        │ ────┘        │
│ │ 0x00400000     │     │     │ 0x00400000     │              │
│ │    Code        │ ────┴──── │    Code        │ ────→ 共享相同實體頁面
│ │ 0x00000000     │           │ 0x00000000     │              │
│ └─────────────────┘           └─────────────────┘              │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="thread-記憶體布局詳細圖解"><a class="header" href="#thread-記憶體布局詳細圖解">Thread 記憶體布局詳細圖解</a></h3>
<pre><code>                   單一 Process 內多 Thread 記憶體分布:

┌─────────────────────────────────────────────────────────────────┐ 0xFFFFFFFF
│                        Kernel Space                            │
│                       (所有進程共用)                           │
├─────────────────────────────────────────────────────────────────┤ 0xC0000000
│                       User Space                               │
│                                                                │
│ Thread 1 Stack      Thread 2 Stack      Thread 3 Stack        │ 高位址
│ ┌─────────────┐     ┌─────────────┐     ┌─────────────┐        │
│ │ 局部變數    │     │ 局部變數    │     │ 局部變數    │        │
│ │ 函數呼叫    │     │ 函數呼叫    │     │ 函數呼叫    │        │
│ │ 回傳位址    │     │ 回傳位址    │     │ 回傳位址    │        │
│ └─────────────┘     └─────────────┘     └─────────────┘        │
│        │                   │                   │               │
│        ↓                   ↓                   ↓               │
│                                                                │
│                      未使用記憶體區域                          │
│                                                                │
│        ↑                                                       │
│        │                                                       │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │                      Heap 區域                             │ │
│ │                (所有 Thread 共享)                          │ │
│ │     malloc()、new、全域變數、動態分配的資料               │ │
│ └─────────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │                      Data 段                               │ │
│ │                (所有 Thread 共享)                          │ │
│ │           全域變數、靜態變數、常數                          │ │
│ └─────────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │                      Code 段                               │ │ 低位址
│ │                (所有 Thread 共享)                          │ │
│ │                   程式執行碼                               │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘ 0x00000000
</code></pre>
<h3 id="fork-vs-thread-creation-視覺化對比"><a class="header" href="#fork-vs-thread-creation-視覺化對比">Fork vs Thread Creation 視覺化對比</a></h3>
<h4 id="fork-創建-process"><a class="header" href="#fork-創建-process">Fork() 創建 Process</a></h4>
<pre><code>                          Fork() 過程

原始 Process A                      新 Process B
┌─────────────────┐   fork()   ┌─────────────────┐
│   Stack A       │    ──→     │   Stack B       │ ← 完整複製
├─────────────────┤            ├─────────────────┤
│   Heap A        │    ──→     │   Heap B        │ ← Copy-on-Write
├─────────────────┤            ├─────────────────┤
│   Data A        │    ──→     │   Data B        │ ← Copy-on-Write
├─────────────────┤            ├─────────────────┤
│   Code A        │    ──→     │   Code B        │ ← 共享只讀
└─────────────────┘            └─────────────────┘

特點:
- 每個 Process 有獨立的虛擬記憶體空間
- 初始時透過 COW 共享實體記憶體
- 寫入時才真正複製頁面
- PID 不同，PPID 指向父進程
</code></pre>
<h4 id="pthread_create-創建-thread"><a class="header" href="#pthread_create-創建-thread">pthread_create() 創建 Thread</a></h4>
<pre><code>                       pthread_create() 過程

原始狀態                           新增 Thread 後
┌─────────────────┐                 ┌─────────────────┐
│   Main Stack    │                 │   Main Stack    │ ← 原有
├─────────────────┤   create thread   ├─────────────────┤
│                 │      ──→       │   Thread Stack  │ ← 新增
│   Shared Heap   │                 │   Shared Heap   │ ← 共享
├─────────────────┤                 ├─────────────────┤
│   Shared Data   │                 │   Shared Data   │ ← 共享
├─────────────────┤                 ├─────────────────┤
│   Shared Code   │                 │   Shared Code   │ ← 共享
└─────────────────┘                 └─────────────────┘

特點:
- 共享相同的虛擬記憶體空間
- 只有 Stack 是獨立的
- 相同的 TGID，不同的 PID (kernel 視角)
- 共享檔案描述符、信號處理器等
</code></pre>
<h3 id="context-switch-視覺化"><a class="header" href="#context-switch-視覺化">Context Switch 視覺化</a></h3>
<h4 id="process-context-switch-昂貴"><a class="header" href="#process-context-switch-昂貴">Process Context Switch (昂貴)</a></h4>
<pre><code>Process A 執行中                切換過程                 Process B 執行中

┌─────────────────┐                儲存 A 狀態:        ┌─────────────────┐
│ CPU Registers   │                ├ 暫存器           │ CPU Registers   │
│ PC: 0x401234    │     ───→       ├ PC 指標          │ PC: 0x501234    │
│ SP: 0xBFFF1000  │                ├ Stack 指標       │ SP: 0xBFFF2000  │
└─────────────────┘                └ 其他狀態         └─────────────────┘

┌─────────────────┐                切換記憶體映射:     ┌─────────────────┐
│ Page Table A    │                ├ 更新 MMU         │ Page Table B    │
│ 虛擬→實體對應   │     ───→       ├ 清空 TLB        │ 虛擬→實體對應   │
│                 │                └ 重建快取         │                 │
└─────────────────┘                                  └─────────────────┘

成本: ~1-10 微秒 (包含 Cache Miss)
</code></pre>
<h4 id="thread-context-switch-便宜"><a class="header" href="#thread-context-switch-便宜">Thread Context Switch (便宜)</a></h4>
<pre><code>Thread 1 執行中               切換過程                Thread 2 執行中

┌─────────────────┐                儲存 Thread 1:      ┌─────────────────┐
│ CPU Registers   │                ├ 暫存器           │ CPU Registers   │
│ PC: 0x401234    │     ───→       ├ PC 指標          │ PC: 0x401456    │
│ SP: 0xBFFF1000  │                └ Stack 指標       │ SP: 0xBFFF2000  │
└─────────────────┘                                  └─────────────────┘

┌─────────────────┐                記憶體映射不變:     ┌─────────────────┐
│ 相同 Page Table │                ├ MMU 不變         │ 相同 Page Table │
│ 虛擬→實體對應   │     ───→       ├ TLB 有效        │ 虛擬→實體對應   │
│                 │                └ Cache 部分有效   │                 │
└─────────────────┘                                  └─────────────────┘

成本: ~0.1-1 微秒 (大部分快取仍有效)
</code></pre>
<h3 id="記憶體分配策略圖解"><a class="header" href="#記憶體分配策略圖解">記憶體分配策略圖解</a></h3>
<h4 id="虛擬記憶體分配-vs-實體記憶體分配"><a class="header" href="#虛擬記憶體分配-vs-實體記憶體分配">虛擬記憶體分配 vs 實體記憶體分配</a></h4>
<pre><code>                    程式請求: malloc(1GB)

                虛擬記憶體配置 (立即):
┌───────────────────────────────────────────────────┐
│ 虛擬位址空間: 0x40000000 - 0x80000000 (1GB)       │
│ 狀態: 已分配但未映射到實體記憶體                   │
│ 成本: 幾乎為零                                     │
└───────────────────────────────────────────────────┘
                          ↓
                      實際存取時
                          ↓
                實體記憶體配置 (按需):
┌───────────────────────────────────────────────────┐
│ 第 1 次存取 0x40000000:                           │
│ └→ 分配實體頁面 Page #1234                        │
│ 第 2 次存取 0x40001000:                           │
│ └→ 分配實體頁面 Page #1235                        │
│ 只有真正使用的部分才佔用實體記憶體                 │
└───────────────────────────────────────────────────┘
</code></pre>
<h3 id="oom-killer-選擇流程圖"><a class="header" href="#oom-killer-選擇流程圖">OOM Killer 選擇流程圖</a></h3>
<pre><code>                      記憶體不足警報
                            │
                            ↓
                ┌─────────────────────────┐
                │    啟動記憶體回收        │
                │  - 清理 Page Cache      │
                │  - 啟動 Swap           │
                │  - 壓縮記憶體           │
                └─────────────┬───────────┘
                            │
                     回收成功? ────→ [Yes] ────→ 繼續運行
                            │
                         [No]
                            │
                            ↓
                ┌─────────────────────────┐
                │     啟動 OOM Killer     │
                │                        │
                │  掃描所有進程:          │
                │  ├─ 計算 OOM Score     │
                │  ├─ 排除受保護進程      │
                │  └─ 選擇最高分進程      │
                └─────────────┬───────────┘
                            │
                            ↓
                ┌─────────────────────────┐
                │  殺死選中的進程         │
                │                        │
                │  記錄日誌:              │
                │  "Killed process 1234   │
                │   (myapp) score 856"    │
                └─────────────┬───────────┘
                            │
                            ↓
                 記憶體壓力緩解 ────→ 系統恢復正常
</code></pre>
<h3 id="signal-在-multi-thread-中的傳遞"><a class="header" href="#signal-在-multi-thread-中的傳遞">Signal 在 Multi-Thread 中的傳遞</a></h3>
<pre><code>           Signal 發送到 Process                Thread 處理機制

外部信號                                 ┌─────────────────┐
(如: kill -TERM 1234)                   │   Thread 1      │
         │                              │ Signal Mask:    │
         │                              │ SIGTERM: 未阻擋 │ ← 可能被選中
         ↓                              └─────────────────┘
┌─────────────────┐                                │
│  Process 1234   │                                │
│  (TGID=1234)    │                     ┌─────────────────┐
│                 │                     │   Thread 2      │
│  內核決定由誰   │ ──────────→     │ Signal Mask:    │
│  處理此信號     │                     │ SIGTERM: 阻擋   │ ← 跳過
└─────────────────┘                     └─────────────────┘
                                              │
                                    ┌─────────────────┐
                                    │   Thread 3      │
                                    │ Signal Mask:    │
                                    │ SIGTERM: 未阻擋 │ ← 可能被選中
                                    │ 但在 sigwait()  │ ← 優先選中
                                    └─────────────────┘

選擇規則:
1. 跳過阻擋該信號的 Thread
2. 優先選擇正在 sigwait() 等待的 Thread  
3. 隨機選擇一個未阻擋的 Thread
4. 只有一個 Thread 會收到信號
</code></pre>
<h3 id="file-descriptor-在-fork-和-thread-中的行為"><a class="header" href="#file-descriptor-在-fork-和-thread-中的行為">File Descriptor 在 Fork 和 Thread 中的行為</a></h3>
<h4 id="fork-後的-fd-共享"><a class="header" href="#fork-後的-fd-共享">Fork 後的 FD 共享</a></h4>
<pre><code>                Fork 前:                            Fork 後:

          Parent Process                 Parent Process    Child Process
         ┌─────────────────┐         ┌─────────────────┐ ┌─────────────────┐
         │ fd=3            │ ─────→  │ fd=3            │ │ fd=3            │
         │ ↓              │         │ ↓              │ │ ↓              │
         └─────────────────┘         └─────────────────┘ └─────────────────┘
                 │                           │             │
                 ↓                           ↓             ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│                      File Table Entry                                      │
│  - file position: 1024                                                    │
│  - access mode: O_RDONLY                                                   │
│  - reference count: 2 ←── 兩個進程都指向同一個                           │
└─────────────────────────────────────────────────────────────────────────────┘

影響:
- 共享檔案位置指標 (file offset)
- 一方 read() 會影響另一方的讀取位置
- 一方 close() 只減少 reference count
</code></pre>
<h4 id="thread-間的-fd-完全共享"><a class="header" href="#thread-間的-fd-完全共享">Thread 間的 FD 完全共享</a></h4>
<pre><code>              Single Process with Multiple Threads:

   Thread 1              Thread 2              Thread 3
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ fd=3            │    │ fd=3            │    │ fd=3            │
│ fd=4            │ ───│ fd=4            │ ───│ fd=4            │
│ fd=5            │    │ fd=5            │    │ fd=5            │
└─────────────────┘    └─────────────────┘    └─────────────────┘
       │                       │                       │
       └───────────────────┼───────────────────┘
                              │
                              ↓
                ┌───────────────────────────────────────┐
                │          共享 FD Table             │
                │  fd=3 → File A                    │
                │  fd=4 → Socket B                  │  
                │  fd=5 → Pipe C                    │
                └───────────────────────────────────────┘

特點:
- 所有 Thread 看到相同的 FD table
- 任一 Thread 的 close() 都會關閉檔案
- 需要同步機制避免競爭條件
</code></pre>
<h2 id="21-linux-調度器-cfs-工作原理白話解釋"><a class="header" href="#21-linux-調度器-cfs-工作原理白話解釋">21. Linux 調度器 (CFS) 工作原理白話解釋</a></h2>
<h3 id="什麼是-cfs-completely-fair-scheduler"><a class="header" href="#什麼是-cfs-completely-fair-scheduler">什麼是 CFS (Completely Fair Scheduler)</a></h3>
<p>CFS 是 Linux 2.6.23 之後的預設調度器，它的設計哲學很簡單：<strong>每個任務都應該得到公平的 CPU 時間</strong>。</p>
<h4 id="cfs-的核心概念"><a class="header" href="#cfs-的核心概念">CFS 的核心概念</a></h4>
<pre><code>傳統調度器的問題:
- 時間片固定 (如 100ms)
- 優先級複雜難理解
- 互動性和公平性難以平衡

CFS 的解決方案:
- 使用「虛擬執行時間」(vruntime) 概念
- 總是執行 vruntime 最小的任務
- 動態調整，沒有固定時間片
</code></pre>
<h3 id="cfs-的虛擬時間機制-白話解釋"><a class="header" href="#cfs-的虛擬時間機制-白話解釋">CFS 的虛擬時間機制 (白話解釋)</a></h3>
<h4 id="虛擬時間就像是欠債記帳"><a class="header" href="#虛擬時間就像是欠債記帳">虛擬時間就像是「欠債記帳」</a></h4>
<pre><code>想像一個公平的咖啡廳:
- 每個客人都應該得到同等的服務時間
- 如果某個客人等太久，下次就優先服務他
- 如果某個客人剛被服務過，就讓其他人先來

CFS 的 vruntime 就是這個「等待債務」:
┌─────────────────┐
│ Task A: 100ms   │ ← vruntime 最小，下一個執行
├─────────────────┤
│ Task B: 150ms   │
├─────────────────┤  
│ Task C: 200ms   │ ← 剛執行過，vruntime 最大
└─────────────────┘
</code></pre>
<h4 id="vruntime-計算方式"><a class="header" href="#vruntime-計算方式">vruntime 計算方式</a></h4>
<pre><code class="language-c">// 簡化的 vruntime 計算
void update_vruntime(struct task_struct *task, u64 runtime) {
    u64 weighted_runtime = runtime;
    
    // Nice 值影響權重
    if (task-&gt;nice &gt; 0) {
        weighted_runtime *= 1.25;  // Nice 值高，虛擬時間走得快
    } else if (task-&gt;nice &lt; 0) {
        weighted_runtime *= 0.8;   // Nice 值低，虛擬時間走得慢
    }
    
    task-&gt;vruntime += weighted_runtime;
}

白話解釋:
- Nice 值高的任務：「虛擬時間走得快」→ 更快輪到下一個
- Nice 值低的任務：「虛擬時間走得慢」→ 可以執行更久
- 這樣 Nice 值低的任務自然得到更多 CPU 時間
</code></pre>
<h3 id="調度決策的完整流程"><a class="header" href="#調度決策的完整流程">調度決策的完整流程</a></h3>
<h4 id="cfs-調度器的心理活動"><a class="header" href="#cfs-調度器的心理活動">CFS 調度器的心理活動</a></h4>
<pre><code>調度器的思考過程:

1. "目前正在跑誰？"
   → 檢查當前任務的 vruntime

2. "他跑夠久了嗎？"  
   → 如果 vruntime 超過左邊鄰居太多 → 需要切換
   → 如果還在合理範圍內 → 繼續執行

3. "下一個該輪誰？"
   → 從紅黑樹最左邊拿出 vruntime 最小的任務

4. "切換成本值得嗎？"
   → 如果切換成本 &gt; 收益，可能延後切換
   
5. "處理完畢，更新紀錄"
   → 更新執行時間、vruntime、統計資料
</code></pre>
<h4 id="紅黑樹調度視覺化"><a class="header" href="#紅黑樹調度視覺化">紅黑樹調度視覺化</a></h4>
<pre><code>                     CFS 紅黑樹 (按 vruntime 排序)
                     
                       Task C (150ms)
                      /              \
             Task A            Task E (300ms)  
            (100ms)           /              \
               \        Task D           Task F
            Task B     (200ms)          (400ms)
           (120ms)        \
                       Task G
                      (250ms)

調度規則:
1. 永遠選擇最左邊的節點 (vruntime 最小)
2. 任務執行後 vruntime 增加，位置右移
3. 樹自動保持平衡，查找時間 O(log n)
4. 插入新任務時會放在適當位置
</code></pre>
<h3 id="不同工作負載下的-cfs-行為"><a class="header" href="#不同工作負載下的-cfs-行為">不同工作負載下的 CFS 行為</a></h3>
<h4 id="cpu-密集型任務"><a class="header" href="#cpu-密集型任務">CPU 密集型任務</a></h4>
<pre><code>場景: 3 個計算任務同時運行

初始狀態:
Task A: vruntime=0, nice=0
Task B: vruntime=0, nice=0  
Task C: vruntime=0, nice=0

執行過程:
Time 0-10ms: Task A 執行 → vruntime=10
Time 10-20ms: Task B 執行 → vruntime=10  
Time 20-30ms: Task C 執行 → vruntime=10
Time 30-40ms: Task A 執行 → vruntime=20
...

結果: 每個任務輪流得到 ~33.3% CPU 時間 (完全公平)
</code></pre>
<h4 id="io-密集型-vs-cpu-密集型混合"><a class="header" href="#io-密集型-vs-cpu-密集型混合">I/O 密集型 vs CPU 密集型混合</a></h4>
<pre><code>場景: I/O 任務 vs CPU 任務

Task A (I/O 密集):
- 執行 2ms → sleep 等待磁碟 → vruntime=2
- 醒來時發現自己 vruntime 最小 → 立即執行
- 再執行 2ms → 又去等待 → vruntime=4

Task B (CPU 密集):  
- 一直想執行，但經常因為 vruntime 較大而等待
- 得到執行機會時會跑較久 (因為沒有其他事要做)

結果: I/O 任務得到優秀的響應性，CPU 任務仍能得到公平時間
</code></pre>
<h3 id="cfs-的智能調整機制"><a class="header" href="#cfs-的智能調整機制">CFS 的智能調整機制</a></h3>
<h4 id="睡眠補償-sleep-credit"><a class="header" href="#睡眠補償-sleep-credit">睡眠補償 (Sleep Credit)</a></h4>
<pre><code class="language-c">// 任務從睡眠中醒來時的處理
void wake_up_task(struct task_struct *task) {
    u64 sleep_time = current_time - task-&gt;sleep_start;
    u64 min_vruntime = get_min_vruntime();
    
    // 如果睡眠太久，調整 vruntime 避免「餓死」其他任務
    if (task-&gt;vruntime &lt; min_vruntime - MAX_SLEEP_CREDIT) {
        task-&gt;vruntime = min_vruntime - MAX_SLEEP_CREDIT;
    }
    
    // 但也不讓它完全追上，保持一點優先性
    if (task-&gt;vruntime &gt; min_vruntime) {
        task-&gt;vruntime = min_vruntime;
    }
}

白話解釋:
- 睡眠的任務不會累積「無限的優先權」
- 醒來時會有一點優先性，但不會壟斷 CPU
- 平衡互動性和公平性
</code></pre>
<h4 id="負載平衡-load-balancing"><a class="header" href="#負載平衡-load-balancing">負載平衡 (Load Balancing)</a></h4>
<pre><code>多核心環境下的 CFS:

CPU 0: [Task A=100ms] [Task B=150ms]  ← 較輕負載
CPU 1: [Task C=80ms] [Task D=90ms] [Task E=120ms] [Task F=200ms] ← 重負載

CFS 的負載平衡:
1. 定期檢查各 CPU 的負載差異
2. 如果差異過大，觸發任務遷移
3. 選擇合適的任務 (通常是 vruntime 較大的)
4. 遷移時調整 vruntime 以適應目標 CPU

遷移後:
CPU 0: [Task A=100ms] [Task B=150ms] [Task F=200ms] ← 平衡後
CPU 1: [Task C=80ms] [Task D=90ms] [Task E=120ms]   ← 平衡後
</code></pre>
<h3 id="常見的-cfs-誤解"><a class="header" href="#常見的-cfs-誤解">常見的 CFS 誤解</a></h3>
<h4 id="誤解一nice-值是優先級"><a class="header" href="#誤解一nice-值是優先級">誤解一：「Nice 值是優先級」</a></h4>
<pre><code>❌ 錯誤理解: Nice -20 的任務有 20 倍優先權
✅ 正確理解: Nice 值影響權重，進而影響時間分配

實際效果:
Nice 0 vs Nice 19: 約 1.5:1 的時間比例 (不是 19:1)
Nice -20 vs Nice 0: 約 9:1 的時間比例 (不是 20:1)

權重計算:
Nice -10: weight = 9548
Nice 0:   weight = 1024  
Nice 10:  weight = 110
Nice 19:  weight = 15
</code></pre>
<h4 id="誤解二時間片固定"><a class="header" href="#誤解二時間片固定">誤解二：「時間片固定」</a></h4>
<pre><code>❌ 錯誤理解: CFS 有固定的時間片 (如 10ms)
✅ 正確理解: CFS 動態調整，沒有固定時間片

實際行為:
- 高負載時: 時間片可能只有 1-2ms
- 低負載時: 時間片可能達到 20-100ms  
- 根據系統負載和任務數量自動調整
- 目標延遲 (target latency) 動態變化
</code></pre>
<h4 id="誤解三實時任務優先級"><a class="header" href="#誤解三實時任務優先級">誤解三：「實時任務優先級」</a></h4>
<pre><code>❌ 錯誤理解: CFS 處理所有任務包括實時任務
✅ 正確理解: 實時任務使用不同的調度器

Linux 調度器層次:
1. RT 調度器 (SCHED_FIFO, SCHED_RR) - 最高優先級
2. Deadline 調度器 (SCHED_DEADLINE) - 截止期限保證
3. CFS 調度器 (SCHED_NORMAL) - 一般任務
4. Idle 調度器 (SCHED_IDLE) - 空閒任務

只有沒有實時任務時，CFS 才開始工作
</code></pre>
<h3 id="cfs-性能調優參數"><a class="header" href="#cfs-性能調優參數">CFS 性能調優參數</a></h3>
<h4 id="重要的-sysctl-參數"><a class="header" href="#重要的-sysctl-參數">重要的 sysctl 參數</a></h4>
<pre><code class="language-bash"># 查看 CFS 參數
sysctl kernel.sched_migration_cost    # 遷移成本閾值
sysctl kernel.sched_min_granularity   # 最小運行時間
sysctl kernel.sched_latency           # 目標延遲
sysctl kernel.sched_wakeup_granularity # 喚醒粒度

# 調整範例
echo 500000 &gt; /proc/sys/kernel/sched_latency        # 減少延遲
echo 100000 &gt; /proc/sys/kernel/sched_min_granularity # 減少最小粒度

效果:
- 較小的延遲：更好的互動性，但更多切換開銷
- 較大的延遲：較少切換開銷，但較差的響應性
</code></pre>
<h4 id="任務優先級調整工具"><a class="header" href="#任務優先級調整工具">任務優先級調整工具</a></h4>
<pre><code class="language-bash"># 調整執行中程式的 Nice 值
renice -10 -p PID              # 提高優先級 (需要權限)
renice 19 -p PID               # 降低優先級

# 啟動時設定 Nice 值  
nice -n -10 ./important_task   # 高優先級啟動
nice -n 19 ./background_task   # 低優先級啟動

# 使用 chrt 調整調度策略
chrt -f 50 ./realtime_task     # 設為實時任務 (FIFO)
chrt -r 50 ./realtime_task     # 設為實時任務 (RR)
chrt -o 0 ./normal_task        # 設為一般任務 (CFS)
</code></pre>
<h3 id="cfs-除錯與監控"><a class="header" href="#cfs-除錯與監控">CFS 除錯與監控</a></h3>
<h4 id="查看調度統計"><a class="header" href="#查看調度統計">查看調度統計</a></h4>
<pre><code class="language-bash"># 查看系統負載
uptime                         # 平均負載
cat /proc/loadavg             # 詳細負載資訊

# 查看調度統計
cat /proc/sched_debug         # 詳細調度資訊
cat /proc/PID/sched           # 特定任務調度資訊

# 即時監控
htop                          # 互動式監控
top -H                        # 顯示線程資訊
pidstat -t 1                  # 每秒統計
</code></pre>
<h4 id="perf-工具分析調度"><a class="header" href="#perf-工具分析調度">perf 工具分析調度</a></h4>
<pre><code class="language-bash"># 記錄調度事件
perf record -e sched:sched_switch -a sleep 10
perf report                    # 分析調度模式

# 即時監控調度
perf top -e sched:sched_switch # 即時調度切換監控
perf sched record -- sleep 10  # 記錄調度活動
perf sched latency             # 分析調度延遲
</code></pre>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<blockquote>
<p><strong>核心概念</strong>: User space 的抽象概念在 kernel space 都被統一成 task 來處理</p>
</blockquote>
<h3 id="關鍵記憶點"><a class="header" href="#關鍵記憶點">關鍵記憶點</a></h3>
<ol>
<li><strong>記憶體共享</strong>：Thread 共享 code/data/heap，但各有獨立 stack</li>
<li><strong>成本差異</strong>：Process 創建成本高但隔離性好，Thread 輕量但易互相影響</li>
<li><strong>除錯觀念</strong>：理解虛擬記憶體 vs 實體記憶體的差異</li>
<li><strong>資源管理</strong>：Thread 資源需要明確管理（join/detach）</li>
<li><strong>COW 機制</strong>：fork 不會立即複製記憶體，而是使用 Copy-on-Write</li>
<li><strong>調度統一</strong>：Linux 內核將 Process 和 Thread 都視為 task，使用相同的調度器</li>
<li><strong>CFS 公平性</strong>：透過 vruntime 機制確保所有任務獲得公平的 CPU 時間</li>
<li><strong>OOM 保護</strong>：了解 OOM Killer 機制，適當設定記憶體限制和監控</li>
</ol>
<h3 id="實務建議"><a class="header" href="#實務建議">實務建議</a></h3>
<ol>
<li><strong>選擇原則</strong>：需要隔離性選 Process，需要共享資料選 Thread</li>
<li><strong>記憶體監控</strong>：定期檢查記憶體使用，預防 OOM 事件</li>
<li><strong>調度調優</strong>：根據工作負載特性調整 Nice 值和調度參數</li>
<li><strong>除錯工具</strong>：熟悉 htop、perf、valgrind 等工具</li>
<li><strong>同步機制</strong>：正確使用 mutex、semaphore 等避免競爭條件</li>
</ol>
<p>記住這個關鍵差異，就能理解為什麼很多系統行為看起來與直覺不符 - 因為我們習慣用 user space 的概念思考，但實際執行是在 kernel space 的邏輯下進行的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux_system/performance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../linux_system/linux-kernel-debug.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux_system/performance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../linux_system/linux-kernel-debug.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
