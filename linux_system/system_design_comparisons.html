<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>系統設計機制完整比較指南 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="系統設計機制完整比較指南"><a class="header" href="#系統設計機制完整比較指南">系統設計機制完整比較指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#io-%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6">I/O 處理機制</a></li>
<li><a href="#%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86">記憶體管理</a></li>
<li><a href="#%E6%8E%92%E7%A8%8B%E7%AD%96%E7%95%A5">排程策略</a></li>
<li><a href="#%E4%B8%A6%E8%A1%8C%E6%8E%A7%E5%88%B6">並行控制</a></li>
<li><a href="#%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E9%81%B8%E6%93%87">資料結構選擇</a></li>
<li><a href="#%E5%BF%AB%E5%8F%96%E7%AD%96%E7%95%A5">快取策略</a></li>
<li><a href="#%E7%B6%B2%E8%B7%AF%E8%88%87%E9%80%9A%E8%A8%8A">網路與通訊</a></li>
<li><a href="#%E5%84%B2%E5%AD%98%E7%AD%96%E7%95%A5">儲存策略</a></li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B">一致性模型</a></li>
<li><a href="#%E5%9F%B7%E8%A1%8C%E6%A8%A1%E5%BC%8F">執行模式</a></li>
<li><a href="#%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F">設計模式</a></li>
</ol>
<hr />
<h2 id="io-處理機制"><a class="header" href="#io-處理機制">I/O 處理機制</a></h2>
<h3 id="1-中斷-vs-輪詢-interrupt-vs-polling"><a class="header" href="#1-中斷-vs-輪詢-interrupt-vs-polling">1. 中斷 vs 輪詢 (Interrupt vs Polling)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>中斷 (Interrupt)</th><th>輪詢 (Polling)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>事件發生時硬體通知CPU</td><td>CPU定期檢查是否有事件</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像門鈴：有客人按門鈴才去開門</td><td>像不停看門：每隔幾秒就去門口看有沒有人</td></tr>
<tr><td><strong>CPU使用率</strong></td><td>低（只在事件發生時處理）</td><td>高（持續檢查浪費資源）</td></tr>
<tr><td><strong>回應時間</strong></td><td>可能有中斷延遲</td><td>立即（但有檢查間隔）</td></tr>
<tr><td><strong>適用場景</strong></td><td>鍵盤輸入、滑鼠點擊、硬碟完成通知</td><td>高速網卡、即時遊戲、感測器讀取</td></tr>
<tr><td><strong>優點</strong></td><td>效率高，CPU可做其他事</td><td>實作簡單，延遲可預測</td></tr>
<tr><td><strong>缺點</strong></td><td>有切換開銷，頻繁中斷效能差</td><td>浪費CPU資源，不適合低頻事件</td></tr>
<tr><td><strong>實際範例</strong></td><td>USB裝置插入時通知系統</td><td>高頻交易系統每微秒檢查市場資料</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>中斷機制</strong>：當你在電腦上按下鍵盤，鍵盤會發送一個中斷訊號給CPU，CPU暫停當前工作，處理鍵盤輸入，然後繼續原本的工作。</li>
<li><strong>輪詢機制</strong>：遊戲引擎每16毫秒檢查一次手把按鈕狀態，確保即時回應玩家操作。</li>
<li><strong>混合策略</strong>：Linux的NAPI在網路封包少時用中斷，封包多時切換到輪詢避免中斷風暴。</li>
</ul>
<hr />
<h3 id="2-同步-vs-異步-synchronous-vs-asynchronous"><a class="header" href="#2-同步-vs-異步-synchronous-vs-asynchronous">2. 同步 vs 異步 (Synchronous vs Asynchronous)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>同步 (Synchronous)</th><th>異步 (Asynchronous)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>等待操作完成才繼續</td><td>發起操作後立即返回，稍後通知</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像排隊買咖啡：站在櫃台等咖啡做好才離開</td><td>像點外賣：下單後可以做其他事，做好了送來</td></tr>
<tr><td><strong>執行流程</strong></td><td>阻塞式，依序執行</td><td>非阻塞式，可併行處理</td></tr>
<tr><td><strong>程式複雜度</strong></td><td>簡單，邏輯順序清晰</td><td>複雜，需要callback或Promise</td></tr>
<tr><td><strong>適用場景</strong></td><td>檔案讀取、資料庫查詢（簡單應用）</td><td>網頁伺服器、聊天應用、大量I/O操作</td></tr>
<tr><td><strong>優點</strong></td><td>易於理解和除錯</td><td>高效率，不浪費等待時間</td></tr>
<tr><td><strong>缺點</strong></td><td>效率低，等待時間無法做其他事</td><td>錯誤處理複雜，除錯困難</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>file.read()</code> 必須等檔案讀完</td><td>Node.js的 <code>fs.readFile()</code> 繼續執行其他程式碼</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>同步範例</strong>：你打電話給客服，必須等電話接通、問題處理完才能掛斷，這段時間什麼都不能做。</li>
<li><strong>異步範例</strong>：你發email給客服，發送後可以繼續工作，收到回覆時再處理。</li>
<li><strong>JavaScript範例</strong>：
<pre><code class="language-javascript">// 同步
const data = readFileSync('file.txt'); // 等待完成
console.log(data);

// 異步
readFile('file.txt', (err, data) =&gt; {
  console.log(data); // 稍後執行
});
console.log('繼續執行'); // 立即執行
</code></pre>
</li>
</ul>
<hr />
<h3 id="3-阻塞-vs-非阻塞-blocking-vs-non-blocking"><a class="header" href="#3-阻塞-vs-非阻塞-blocking-vs-non-blocking">3. 阻塞 vs 非阻塞 (Blocking vs Non-blocking)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>阻塞 (Blocking)</th><th>非阻塞 (Non-blocking)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>呼叫會等待直到有結果</td><td>立即返回，可能還沒準備好</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像ATM提款：插卡後必須等到錢吐出來</td><td>像查詢ATM餘額：按了馬上顯示，不用等</td></tr>
<tr><td><strong>返回時機</strong></td><td>操作完成時返回</td><td>立即返回（可能返回錯誤碼）</td></tr>
<tr><td><strong>錯誤處理</strong></td><td>成功或失敗明確</td><td>需要重複嘗試（EAGAIN）</td></tr>
<tr><td><strong>適用場景</strong></td><td>簡單的單一操作</td><td>需要同時處理多個連接</td></tr>
<tr><td><strong>優點</strong></td><td>邏輯簡單，結果確定</td><td>可同時監控多個操作</td></tr>
<tr><td><strong>缺點</strong></td><td>無法同時處理多個任務</td><td>需要額外邏輯處理「未準備好」狀態</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>recv()</code> 等到收到資料才返回</td><td><code>recv(O_NONBLOCK)</code> 沒資料就返回EAGAIN</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>阻塞範例</strong>：你打電話訂餐，必須等店員接電話、記錄完訂單，電話才能掛斷。</li>
<li><strong>非阻塞範例</strong>：你用App訂餐，點擊送出後App立即回到主畫面，訂單在背景處理。</li>
<li><strong>Socket範例</strong>：
<pre><code class="language-python"># 阻塞模式
data = socket.recv(1024)  # 等到收到資料

# 非阻塞模式
socket.setblocking(False)
try:
    data = socket.recv(1024)  # 立即返回
except BlockingIOError:
    # 資料還沒準備好
    pass
</code></pre>
</li>
</ul>
<hr />
<h3 id="4-dma-vs-pio-direct-memory-access-vs-programmed-io"><a class="header" href="#4-dma-vs-pio-direct-memory-access-vs-programmed-io">4. DMA vs PIO (Direct Memory Access vs Programmed I/O)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>DMA</th><th>PIO</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>硬體直接存取記憶體，CPU不參與資料搬移</td><td>CPU負責在記憶體和I/O裝置間搬移資料</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像快遞直接送貨到府：你不用親自去搬</td><td>像自己去郵局領包裹：要親自搬運</td></tr>
<tr><td><strong>CPU使用率</strong></td><td>低（CPU可做其他事）</td><td>高（CPU忙著搬資料）</td></tr>
<tr><td><strong>傳輸速度</strong></td><td>快（硬體直接存取）</td><td>慢（經過CPU）</td></tr>
<tr><td><strong>適用場景</strong></td><td>大量資料傳輸（硬碟、網卡、音效卡）</td><td>少量資料、簡單裝置（舊式鍵盤、簡單感測器）</td></tr>
<tr><td><strong>優點</strong></td><td>效率高，不佔用CPU</td><td>實作簡單，硬體成本低</td></tr>
<tr><td><strong>缺點</strong></td><td>需要專用硬體支援</td><td>佔用CPU資源</td></tr>
<tr><td><strong>實際範例</strong></td><td>硬碟讀取1GB檔案到RAM</td><td>舊式印表機逐字元傳輸</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>DMA範例</strong>：你下載電影時，網卡收到的資料直接寫入記憶體，CPU可以同時執行其他程式。</li>
<li><strong>PIO範例</strong>：早期電腦讀取軟碟時，CPU要一個一個位元組搬移資料，這時電腦會變得很慢。</li>
<li><strong>效能差異</strong>：
<ul>
<li>DMA：1GB資料傳輸，CPU使用率 &lt; 5%</li>
<li>PIO：1GB資料傳輸，CPU使用率接近 100%</li>
</ul>
</li>
</ul>
<hr />
<h3 id="5-零拷貝-vs-傳統拷貝-zero-copy-vs-traditional-copy"><a class="header" href="#5-零拷貝-vs-傳統拷貝-zero-copy-vs-traditional-copy">5. 零拷貝 vs 傳統拷貝 (Zero-Copy vs Traditional Copy)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>零拷貝 (Zero-Copy)</th><th>傳統拷貝 (Traditional Copy)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>資料直接從來源到目的地,不經過CPU</td><td>資料經過多次CPU拷貝(Kernel→User→Kernel)</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像傳送帶:貨物直接從倉庫到卡車</td><td>像人工搬運:貨物先搬到暫存區再搬上車</td></tr>
<tr><td><strong>CPU使用率</strong></td><td>極低(幾乎不佔用)</td><td>高(CPU忙著拷貝資料)</td></tr>
<tr><td><strong>拷貝次數</strong></td><td>0-1次</td><td>4次(Disk→Kernel→User→Kernel→Network)</td></tr>
<tr><td><strong>適用場景</strong></td><td>大檔案傳輸、影片串流、Proxy伺服器</td><td>需要處理資料內容的場景</td></tr>
<tr><td><strong>優點</strong></td><td>效能極佳,減少CPU和記憶體頻寬佔用</td><td>可以在User space處理資料</td></tr>
<tr><td><strong>缺點</strong></td><td>無法修改資料內容</td><td>效能差,多次拷貝浪費資源</td></tr>
<tr><td><strong>實際範例</strong></td><td>Nginx sendfile、Kafka檔案傳輸</td><td>傳統HTTP伺服器read+write</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明:</strong></p>
<ul>
<li><strong>傳統拷貝流程</strong>:發送檔案給客戶端
<pre><code>1. read(): Disk → Kernel buffer (DMA)
2. read(): Kernel buffer → User buffer (CPU拷貝)
3. write(): User buffer → Socket buffer (CPU拷貝)
4. write(): Socket buffer → Network card (DMA)
總共:2次DMA + 2次CPU拷貝 + 4次上下文切換
</code></pre>
</li>
<li><strong>零拷貝流程</strong>:使用sendfile()
<pre><code>1. sendfile(): Disk → Kernel buffer (DMA)
2. sendfile(): Kernel buffer → Network card (DMA或直接描述符傳遞)
總共:2次DMA + 0次CPU拷貝 + 2次上下文切換
</code></pre>
</li>
<li><strong>實際程式碼對比</strong>:
<pre><code class="language-c">// 傳統方式
char buffer[4096];
while ((n = read(fd, buffer, 4096)) &gt; 0) {
    write(socket, buffer, n);  // 2次CPU拷貝
}

// 零拷貝
sendfile(socket, fd, NULL, file_size);  // 0次CPU拷貝
</code></pre>
</li>
<li><strong>效能提升</strong>:
<ul>
<li>傳統方式:100MB檔案,CPU使用率30%,吞吐量500MB/s</li>
<li>零拷貝:100MB檔案,CPU使用率5%,吞吐量2GB/s</li>
</ul>
</li>
</ul>
<hr />
<h3 id="6-記憶體映射-io-vs-標準-io-memory-mapped-io-vs-standard-io"><a class="header" href="#6-記憶體映射-io-vs-標準-io-memory-mapped-io-vs-standard-io">6. 記憶體映射 I/O vs 標準 I/O (Memory-Mapped I/O vs Standard I/O)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>記憶體映射 I/O (mmap)</th><th>標準 I/O (read/write)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>將檔案映射到記憶體位址,像存取陣列</td><td>使用系統呼叫讀寫檔案</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像把整本書攤開在桌上:隨便翻哪一頁</td><td>像看書:從第一頁依序看</td></tr>
<tr><td><strong>存取方式</strong></td><td>記憶體指標存取</td><td>系統呼叫(read/write)</td></tr>
<tr><td><strong>效能特性</strong></td><td>隨機存取快,大檔案優勢明顯</td><td>順序存取快,小檔案開銷小</td></tr>
<tr><td><strong>適用場景</strong></td><td>大檔案隨機存取、資料庫、共享記憶體</td><td>順序讀寫、小檔案、串流資料</td></tr>
<tr><td><strong>優點</strong></td><td>隨機存取效率高,減少系統呼叫</td><td>實作簡單,適合順序操作</td></tr>
<tr><td><strong>缺點</strong></td><td>需要虛擬記憶體支援,小檔案開銷大</td><td>隨機存取慢,系統呼叫開銷</td></tr>
<tr><td><strong>實際範例</strong></td><td>資料庫索引(B-tree)、進程間共享記憶體</td><td>日誌寫入、檔案複製</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明:</strong></p>
<ul>
<li><strong>mmap範例</strong>:隨機存取大檔案
<pre><code class="language-c">// 映射檔案到記憶體
int fd = open("data.db", O_RDWR);
char* addr = mmap(NULL, file_size, PROT_READ|PROT_WRITE,
                  MAP_SHARED, fd, 0);

// 像存取陣列一樣存取檔案
addr[1000] = 'A';      // 直接修改offset 1000
addr[999999] = 'B';    // 跳到offset 999999,無需seek

munmap(addr, file_size);
</code></pre>
</li>
<li><strong>標準I/O範例</strong>:順序讀取
<pre><code class="language-c">FILE* fp = fopen("data.txt", "r");
char buffer[4096];
while (fread(buffer, 1, 4096, fp) &gt; 0) {
    process(buffer);
}
fclose(fp);
</code></pre>
</li>
<li><strong>效能對比</strong>(100MB檔案,隨機存取10000次):
<ul>
<li>mmap:約100ms(頁面錯誤後幾乎零開銷)</li>
<li>read/write + lseek:約5000ms(每次都要系統呼叫)</li>
</ul>
</li>
<li><strong>共享記憶體應用</strong>:多程序通訊
<pre><code class="language-c">// 程序A
void* shared = mmap(NULL, SIZE, PROT_READ|PROT_WRITE,
                    MAP_SHARED|MAP_ANONYMOUS, -1, 0);
fork();  // 子程序繼承映射

// 父子程序共享這塊記憶體,無需pipe或socket
</code></pre>
</li>
<li><strong>注意事項</strong>:
<ul>
<li>mmap檔案修改不會立即寫入磁碟,需要msync()強制同步</li>
<li>映射大檔案可能耗盡虛擬記憶體位址空間(32位元系統)</li>
<li>適合大檔案(&gt;幾MB),小檔案反而比read/write慢</li>
</ul>
</li>
</ul>
<hr />
<h2 id="記憶體管理"><a class="header" href="#記憶體管理">記憶體管理</a></h2>
<h3 id="5-分頁-vs-分段-paging-vs-segmentation"><a class="header" href="#5-分頁-vs-分段-paging-vs-segmentation">5. 分頁 vs 分段 (Paging vs Segmentation)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>分頁 (Paging)</th><th>分段 (Segmentation)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>將記憶體分成固定大小的頁（如4KB）</td><td>依邏輯單元分成不同大小的段</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像停車格：每個格子一樣大，不管車型</td><td>像衣櫃分區：上衣區、褲子區、大小不同</td></tr>
<tr><td><strong>記憶體單位</strong></td><td>固定大小（4KB、2MB等）</td><td>可變大小（依據程式邏輯）</td></tr>
<tr><td><strong>碎片問題</strong></td><td>內部碎片（頁內浪費）</td><td>外部碎片（段間浪費）</td></tr>
<tr><td><strong>適用場景</strong></td><td>現代作業系統（Windows、Linux）</td><td>早期系統、或需要邏輯分離的場景</td></tr>
<tr><td><strong>優點</strong></td><td>管理簡單，無外部碎片</td><td>符合程式邏輯結構，保護容易</td></tr>
<tr><td><strong>缺點</strong></td><td>有內部碎片，查表開銷</td><td>有外部碎片，需要壓縮整理</td></tr>
<tr><td><strong>實際範例</strong></td><td>程式佔用100頁（400KB）</td><td>Code段50KB、Data段30KB、Stack段20KB</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>分頁範例</strong>：一個程式需要17KB記憶體，在4KB分頁系統中會分配5頁（20KB），浪費3KB。</li>
<li><strong>分段範例</strong>：程式的程式碼、資料、堆疊分別放在不同的段，每段有自己的起始位址和長度。</li>
<li><strong>混合使用</strong>：現代x86-64系統同時支援分頁和分段，但主要使用分頁。</li>
</ul>
<hr />
<h3 id="6-寫回-vs-寫透-write-back-vs-write-through"><a class="header" href="#6-寫回-vs-寫透-write-back-vs-write-through">6. 寫回 vs 寫透 (Write-back vs Write-through)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>寫回 (Write-back)</th><th>寫透 (Write-through)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>先寫快取，稍後批次寫回記憶體</td><td>同時寫入快取和記憶體</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像筆記本：先記在本子上，有空再整理到電腦</td><td>像雙寫：同時寫筆記本和打電腦</td></tr>
<tr><td><strong>寫入速度</strong></td><td>快（只寫快取）</td><td>慢（等記憶體寫完）</td></tr>
<tr><td><strong>資料一致性</strong></td><td>可能不一致</td><td>一定一致</td></tr>
<tr><td><strong>適用場景</strong></td><td>一般應用程式、資料庫快取</td><td>關鍵系統、需要即時持久化</td></tr>
<tr><td><strong>優點</strong></td><td>效能最佳，減少記憶體存取</td><td>資料安全，不會遺失</td></tr>
<tr><td><strong>缺點</strong></td><td>斷電可能遺失資料</td><td>效能較差</td></tr>
<tr><td><strong>實際範例</strong></td><td>CPU L1 Cache</td><td>銀行交易系統</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>寫回範例</strong>：你在Word編輯文件，修改先存在記憶體，過一段時間或關閉時才存到硬碟。</li>
<li><strong>寫透範例</strong>：每次輸入都立即存檔，確保不會遺失任何內容，但存檔頻繁會變慢。</li>
<li><strong>混合策略</strong>：資料庫的Write-Ahead Log（WAL）先寫日誌（寫透），資料頁面用寫回。</li>
</ul>
<hr />
<h3 id="7-靜態分配-vs-動態分配-static-vs-dynamic-allocation"><a class="header" href="#7-靜態分配-vs-動態分配-static-vs-dynamic-allocation">7. 靜態分配 vs 動態分配 (Static vs Dynamic Allocation)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>靜態分配</th><th>動態分配</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>編譯時決定記憶體大小和位置</td><td>執行時根據需要分配記憶體</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像固定座位：買票時就決定坐哪</td><td>像自由座：上車後找空位坐</td></tr>
<tr><td><strong>分配時機</strong></td><td>編譯期間</td><td>執行期間</td></tr>
<tr><td><strong>彈性</strong></td><td>無彈性，大小固定</td><td>彈性高，依需求調整</td></tr>
<tr><td><strong>適用場景</strong></td><td>全域變數、陣列大小確定時</td><td>鏈結串列、動態陣列、物件建立</td></tr>
<tr><td><strong>優點</strong></td><td>速度快，無overhead，可預測</td><td>彈性使用記憶體，適應不同需求</td></tr>
<tr><td><strong>缺點</strong></td><td>浪費記憶體，無法調整大小</td><td>有分配/釋放開銷，可能記憶體洩漏</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>int arr[100];</code></td><td><code>int* arr = malloc(n * sizeof(int));</code></td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>靜態範例</strong>：宣告 <code>char buffer[1024];</code> 直接在stack上配置1024 bytes，編譯時就決定了。</li>
<li><strong>動態範例</strong>：<code>std::vector</code> 初始可能只配置8個元素空間，使用時自動擴充到16、32、64...</li>
<li><strong>記憶體區域</strong>：
<ul>
<li>靜態：放在 Stack（區域變數）或 Data Segment（全域變數）</li>
<li>動態：放在 Heap</li>
</ul>
</li>
</ul>
<hr />
<h2 id="排程策略"><a class="header" href="#排程策略">排程策略</a></h2>
<h3 id="8-搶佔式-vs-非搶佔式-preemptive-vs-non-preemptive"><a class="header" href="#8-搶佔式-vs-非搶佔式-preemptive-vs-non-preemptive">8. 搶佔式 vs 非搶佔式 (Preemptive vs Non-preemptive)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>搶佔式 (Preemptive)</th><th>非搶佔式 (Non-preemptive)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>可以強制中斷正在執行的任務</td><td>等任務自願放棄CPU</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像急診室：重症病人可以插隊</td><td>像銀行排隊：必須等前面的人辦完</td></tr>
<tr><td><strong>任務切換</strong></td><td>時間到就強制切換</td><td>只能等任務完成或主動讓出</td></tr>
<tr><td><strong>回應時間</strong></td><td>快，高優先權任務可立即執行</td><td>慢，可能等很久</td></tr>
<tr><td><strong>適用場景</strong></td><td>現代多工系統、即時系統</td><td>簡單系統、批次處理</td></tr>
<tr><td><strong>優點</strong></td><td>回應快，公平，適合互動式應用</td><td>實作簡單，無切換開銷</td></tr>
<tr><td><strong>缺點</strong></td><td>有切換開銷，實作複雜</td><td>一個任務可能霸佔CPU</td></tr>
<tr><td><strong>實際範例</strong></td><td>Linux、Windows的程序排程</td><td>早期MS-DOS、簡單嵌入式系統</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>搶佔式範例</strong>：你在看影片時下載檔案，作業系統每10毫秒切換一次，兩個程式都能執行。</li>
<li><strong>非搶佔式範例</strong>：舊系統執行一個程式，必須等它執行完或主動sleep才能執行下一個。</li>
<li><strong>即時系統</strong>：飛機控制系統用搶佔式，確保緊急任務（如引擎故障）能立即處理。</li>
</ul>
<hr />
<h3 id="9-fcfs-vs-sjf-vs-rr-first-come-first-served-vs-shortest-job-first-vs-round-robin"><a class="header" href="#9-fcfs-vs-sjf-vs-rr-first-come-first-served-vs-shortest-job-first-vs-round-robin">9. FCFS vs SJF vs RR (First-Come First-Served vs Shortest Job First vs Round Robin)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>FCFS</th><th>SJF</th><th>Round Robin</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>依到達順序執行</td><td>先執行最短的工作</td><td>輪流執行，每次固定時間片</td></tr>
<tr><td><strong>白話比喻</strong></td><td>排隊：先到先服務</td><td>快速通關：短工作優先</td><td>輪流玩遊戲：每人玩5分鐘</td></tr>
<tr><td><strong>平均等待時間</strong></td><td>可能很長</td><td>最短</td><td>中等</td></tr>
<tr><td><strong>公平性</strong></td><td>公平（但可能飢餓）</td><td>不公平（長工作可能等很久）</td><td>最公平</td></tr>
<tr><td><strong>適用場景</strong></td><td>批次系統、簡單任務</td><td>已知工作時間的系統</td><td>多工互動式系統（Linux、Windows）</td></tr>
<tr><td><strong>優點</strong></td><td>實作簡單</td><td>最佳化平均等待時間</td><td>公平，回應時間可預測</td></tr>
<tr><td><strong>缺點</strong></td><td>長工作會阻塞後面所有工作</td><td>長工作可能餓死</td><td>有切換開銷</td></tr>
<tr><td><strong>實際範例</strong></td><td>印表機佇列</td><td>作業批次處理</td><td>CPU時間分配</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>FCFS範例</strong>：3個工作：A(24秒)、B(3秒)、C(3秒)，B和C必須等A完成，平均等待時間=(0+24+27)/3=17秒</li>
<li><strong>SJF範例</strong>：同樣3個工作，執行順序變成B(3秒)、C(3秒)、A(24秒)，平均等待時間=(0+3+6)/3=3秒</li>
<li><strong>RR範例</strong>：時間片4秒，執行順序：A→B→C→A→A→A→A→A→A，每個工作輪流執行</li>
</ul>
<hr />
<h3 id="10-時間分享-vs-空間分享-time-sharing-vs-space-sharing"><a class="header" href="#10-時間分享-vs-空間分享-time-sharing-vs-space-sharing">10. 時間分享 vs 空間分享 (Time-sharing vs Space-sharing)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>時間分享</th><th>空間分享</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>資源輪流給不同使用者</td><td>資源分割給不同使用者</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像共用一台車：輪流開</td><td>像停車場：每人有固定車位</td></tr>
<tr><td><strong>資源使用</strong></td><td>同一資源，不同時間使用</td><td>不同部分同時使用</td></tr>
<tr><td><strong>隔離性</strong></td><td>時間隔離</td><td>空間隔離</td></tr>
<tr><td><strong>適用場景</strong></td><td>CPU、網路頻寬</td><td>記憶體、硬碟空間</td></tr>
<tr><td><strong>優點</strong></td><td>資源利用率高</td><td>效能穩定，無競爭</td></tr>
<tr><td><strong>缺點</strong></td><td>需要切換機制</td><td>可能浪費未使用的空間</td></tr>
<tr><td><strong>實際範例</strong></td><td>多個程序共用一顆CPU</td><td>每個程序有獨立的記憶體空間</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>時間分享範例</strong>：一顆4核CPU同時運行100個程序，每個程序輪流使用CPU。</li>
<li><strong>空間分享範例</strong>：8GB記憶體分給4個程式，每個程式固定使用2GB。</li>
<li><strong>混合使用</strong>：現代系統CPU用時間分享，記憶體用空間分享。</li>
</ul>
<hr />
<h2 id="並行控制"><a class="header" href="#並行控制">並行控制</a></h2>
<h3 id="11-鎖-vs-無鎖-lock-based-vs-lock-free"><a class="header" href="#11-鎖-vs-無鎖-lock-based-vs-lock-free">11. 鎖 vs 無鎖 (Lock-based vs Lock-free)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>鎖 (Lock-based)</th><th>無鎖 (Lock-free)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>使用互斥鎖保護共享資源</td><td>使用原子操作（CAS）避免鎖</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像廁所門鎖：進去就上鎖</td><td>像搶座位：看到空位就快速坐下</td></tr>
<tr><td><strong>阻塞情況</strong></td><td>會阻塞其他執行緒</td><td>不會阻塞，失敗就重試</td></tr>
<tr><td><strong>死鎖風險</strong></td><td>可能死鎖</td><td>無死鎖</td></tr>
<tr><td><strong>適用場景</strong></td><td>一般應用、資料庫</td><td>高效能系統、即時系統</td></tr>
<tr><td><strong>優點</strong></td><td>實作簡單，容易理解</td><td>效能好，無死鎖</td></tr>
<tr><td><strong>缺點</strong></td><td>可能死鎖、效能瓶頸</td><td>實作複雜，難以除錯</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>pthread_mutex_lock()</code></td><td>Java的 <code>AtomicInteger.compareAndSet()</code></td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>鎖範例</strong>：銀行帳戶轉帳時，先鎖定兩個帳戶，完成轉帳後解鎖。
<pre><code class="language-cpp">mutex.lock();
balance += amount;
mutex.unlock();
</code></pre>
</li>
<li><strong>無鎖範例</strong>：多個執行緒更新計數器，使用CAS操作。
<pre><code class="language-cpp">do {
    old_value = counter;
    new_value = old_value + 1;
} while (!compare_and_swap(&amp;counter, old_value, new_value));
</code></pre>
</li>
<li><strong>效能比較</strong>：無競爭時鎖快；高競爭時無鎖快。</li>
</ul>
<hr />
<h3 id="12-悲觀鎖-vs-樂觀鎖-pessimistic-vs-optimistic-locking"><a class="header" href="#12-悲觀鎖-vs-樂觀鎖-pessimistic-vs-optimistic-locking">12. 悲觀鎖 vs 樂觀鎖 (Pessimistic vs Optimistic Locking)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>悲觀鎖</th><th>樂觀鎖</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>假設會衝突，先鎖住再操作</td><td>假設不會衝突，衝突時才重試</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像保險箱：先鎖起來，確保沒人動</td><td>像購物車：放進去，結帳時才檢查還有沒有貨</td></tr>
<tr><td><strong>鎖定時機</strong></td><td>讀取時就鎖定</td><td>更新時才檢查</td></tr>
<tr><td><strong>衝突處理</strong></td><td>預防衝突</td><td>偵測衝突後重試</td></tr>
<tr><td><strong>適用場景</strong></td><td>寫多讀少、衝突頻繁</td><td>讀多寫少、衝突少</td></tr>
<tr><td><strong>優點</strong></td><td>確保不會衝突</td><td>效能好，無需等待</td></tr>
<tr><td><strong>缺點</strong></td><td>效能差，可能造成等待</td><td>衝突多時需要重試</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>SELECT ... FOR UPDATE</code></td><td>資料庫版本號機制</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>悲觀鎖範例</strong>：電影訂票系統，選座位時立即鎖定，避免同時被兩人選到。
<pre><code class="language-sql">BEGIN TRANSACTION;
SELECT * FROM seats WHERE id = 10 FOR UPDATE;
UPDATE seats SET booked = true WHERE id = 10;
COMMIT;
</code></pre>
</li>
<li><strong>樂觀鎖範例</strong>：Wiki編輯，編輯時不鎖定，提交時檢查版本號是否變更。
<pre><code class="language-sql">UPDATE articles 
SET content = '新內容', version = version + 1
WHERE id = 100 AND version = 5;
-- 如果version已經變更，UPDATE會失敗
</code></pre>
</li>
<li><strong>選擇原則</strong>：衝突率低選樂觀鎖，衝突率高選悲觀鎖。</li>
</ul>
<hr />
<h3 id="13-粗粒度鎖-vs-細粒度鎖-coarse-grained-vs-fine-grained-locking"><a class="header" href="#13-粗粒度鎖-vs-細粒度鎖-coarse-grained-vs-fine-grained-locking">13. 粗粒度鎖 vs 細粒度鎖 (Coarse-grained vs Fine-grained Locking)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>粗粒度鎖</th><th>細粒度鎖</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>鎖住大範圍（整個資料庫/表）</td><td>鎖住小範圍（單一記錄）</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像整棟樓的大門鎖：進樓就鎖門</td><td>像每個房間的鎖：只鎖使用的房間</td></tr>
<tr><td><strong>並發程度</strong></td><td>低</td><td>高</td></tr>
<tr><td><strong>實作複雜度</strong></td><td>簡單</td><td>複雜</td></tr>
<tr><td><strong>適用場景</strong></td><td>低並發、簡單應用</td><td>高並發、大型系統</td></tr>
<tr><td><strong>優點</strong></td><td>實作簡單，死鎖機率低</td><td>並發高，效能好</td></tr>
<tr><td><strong>缺點</strong></td><td>並發差，效能瓶頸</td><td>實作複雜，可能死鎖</td></tr>
<tr><td><strong>實際範例</strong></td><td>鎖整個資料表</td><td>鎖單一資料列</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>粗粒度鎖範例</strong>：整個購物網站共用一個庫存鎖，任何人修改任何商品庫存都要等待。
<pre><code class="language-python">with global_lock:
    update_inventory(product_id, quantity)
</code></pre>
</li>
<li><strong>細粒度鎖範例</strong>：每個商品有自己的鎖，修改A商品不影響B商品。
<pre><code class="language-python">with product_locks[product_id]:
    update_inventory(product_id, quantity)
</code></pre>
</li>
<li><strong>死鎖風險</strong>：細粒度鎖如果同時鎖定多個資源需注意順序，避免死鎖。</li>
</ul>
<hr />
<h2 id="資料結構選擇"><a class="header" href="#資料結構選擇">資料結構選擇</a></h2>
<h3 id="14-陣列-vs-鏈結串列-array-vs-linked-list"><a class="header" href="#14-陣列-vs-鏈結串列-array-vs-linked-list">14. 陣列 vs 鏈結串列 (Array vs Linked List)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>陣列 (Array)</th><th>鏈結串列 (Linked List)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>連續記憶體空間儲存元素</td><td>節點透過指標連接</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像公寓：房間連續排列</td><td>像尋寶遊戲：每個線索指向下一個</td></tr>
<tr><td><strong>記憶體配置</strong></td><td>連續</td><td>分散</td></tr>
<tr><td><strong>隨機存取</strong></td><td>O(1)</td><td>O(n)</td></tr>
<tr><td><strong>插入/刪除</strong></td><td>O(n)</td><td>O(1)</td></tr>
<tr><td><strong>適用場景</strong></td><td>需要快速查詢、大小固定</td><td>頻繁增刪、大小不定</td></tr>
<tr><td><strong>優點</strong></td><td>存取快、cache友善</td><td>插入刪除快、動態大小</td></tr>
<tr><td><strong>缺點</strong></td><td>插入刪除慢、大小固定</td><td>存取慢、需要額外指標空間</td></tr>
<tr><td><strong>實際範例</strong></td><td><code>int arr[100]</code></td><td><code>struct Node { int data; Node* next; }</code></td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>陣列範例</strong>：學生成績表，可以直接查詢第50個學生 <code>grades[49]</code>，但插入新學生需要移動後面所有元素。</li>
<li><strong>鏈結串列範例</strong>：播放清單，可以輕鬆插入新歌曲，但要找第50首歌需要從頭走訪。</li>
<li><strong>效能對比</strong>：
<ul>
<li>陣列存取：<code>arr[1000]</code> 一次記憶體存取</li>
<li>鏈結串列存取：需要走訪1000次指標</li>
</ul>
</li>
<li><strong>記憶體使用</strong>：鏈結串列每個節點需要額外8 bytes（64位元）儲存指標</li>
</ul>
<hr />
<h3 id="15-堆疊-vs-佇列-stack-vs-queue"><a class="header" href="#15-堆疊-vs-佇列-stack-vs-queue">15. 堆疊 vs 佇列 (Stack vs Queue)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>堆疊 (Stack)</th><th>佇列 (Queue)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>LIFO（後進先出）</td><td>FIFO（先進先出）</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像盤子堆疊：最後放的最先拿</td><td>像排隊：先到的先服務</td></tr>
<tr><td><strong>操作</strong></td><td>push（放）、pop（取）</td><td>enqueue（放）、dequeue（取）</td></tr>
<tr><td><strong>適用場景</strong></td><td>函式呼叫、括號匹配、回溯演算法</td><td>任務排程、廣度優先搜尋、緩衝區</td></tr>
<tr><td><strong>優點</strong></td><td>簡單、適合遞迴</td><td>公平、順序處理</td></tr>
<tr><td><strong>缺點</strong></td><td>不適合需要順序處理的場景</td><td>不適合需要回溯的場景</td></tr>
<tr><td><strong>實際範例</strong></td><td>瀏覽器上一頁功能</td><td>印表機列印佇列</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>堆疊範例</strong>：函式呼叫 <code>main() → funcA() → funcB()</code>，funcB執行完回到funcA，funcA執行完回到main。
<pre><code class="language-cpp">void funcA() {
    int x = 10;  // 壓入stack
    funcB();
}  // x彈出stack
</code></pre>
</li>
<li><strong>佇列範例</strong>：訊息系統，使用者依序發送訊息1、2、3，伺服器依序處理1、2、3。
<pre><code class="language-python">queue.put("訊息1")
queue.put("訊息2")
msg = queue.get()  # 取得"訊息1"
</code></pre>
</li>
<li><strong>變體</strong>：
<ul>
<li>雙端佇列（Deque）：兩端都可以插入和刪除</li>
<li>優先佇列（Priority Queue）：依優先權而非順序取出</li>
</ul>
</li>
</ul>
<hr />
<h3 id="16-hash-table-vs-tree-雜湊表-vs-樹"><a class="header" href="#16-hash-table-vs-tree-雜湊表-vs-樹">16. Hash Table vs Tree (雜湊表 vs 樹)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>Hash Table</th><th>Tree (如BST、B-tree)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>用hash函數計算位置直接存取</td><td>有序結構，用比較找到位置</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像字典：知道單字直接翻到該頁</td><td>像圖書館分類：一層層找下去</td></tr>
<tr><td><strong>查詢時間</strong></td><td>O(1) 平均</td><td>O(log n)</td></tr>
<tr><td><strong>範圍查詢</strong></td><td>不支援</td><td>支援</td></tr>
<tr><td><strong>排序</strong></td><td>無序</td><td>有序</td></tr>
<tr><td><strong>適用場景</strong></td><td>快速查詢、資料無序</td><td>範圍查詢、需要排序</td></tr>
<tr><td><strong>優點</strong></td><td>查詢最快</td><td>支援範圍查詢、有序</td></tr>
<tr><td><strong>缺點</strong></td><td>可能碰撞、無序</td><td>查詢較慢、實作複雜</td></tr>
<tr><td><strong>實際範例</strong></td><td>Python的dict、資料庫索引</td><td>MySQL的B+tree索引</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>Hash Table範例</strong>：查詢學生成績，用學號hash後直接找到。
<pre><code class="language-python">grades = {"A001": 85, "A002": 92}
score = grades["A001"]  # O(1)
</code></pre>
</li>
<li><strong>Tree範例</strong>：查詢薪水在50K-80K的員工，可以用樹快速範圍查詢。
<pre><code class="language-sql">SELECT * FROM employees WHERE salary BETWEEN 50000 AND 80000;
-- 使用B-tree索引
</code></pre>
</li>
<li><strong>碰撞處理</strong>：Hash Table碰撞時用鏈結串列（Chaining）或開放定址法（Open Addressing）。</li>
<li><strong>實務應用</strong>：資料庫同時使用Hash Index（點查詢）和B-tree Index（範圍查詢）。</li>
</ul>
<hr />
<h2 id="快取策略"><a class="header" href="#快取策略">快取策略</a></h2>
<h3 id="17-lru-vs-lfu-vs-fifo-替換演算法"><a class="header" href="#17-lru-vs-lfu-vs-fifo-替換演算法">17. LRU vs LFU vs FIFO (替換演算法)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>LRU</th><th>LFU</th><th>FIFO</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>移除最近最少使用的</td><td>移除最不常使用的</td><td>移除最早進來的</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像整理書桌：丟掉很久沒用的</td><td>像整理衣櫃：丟掉最少穿的</td><td>像堆疊雜誌：丟掉最舊的</td></tr>
<tr><td><strong>考量因素</strong></td><td>最近使用時間</td><td>使用頻率</td><td>進入時間</td></tr>
<tr><td><strong>適用場景</strong></td><td>一般應用、網頁快取</td><td>熱門資料重要的場景</td><td>簡單系統</td></tr>
<tr><td><strong>優點</strong></td><td>符合時間局部性</td><td>保留熱門資料</td><td>實作最簡單</td></tr>
<tr><td><strong>缺點</strong></td><td>實作複雜</td><td>新資料不易進入</td><td>效能差</td></tr>
<tr><td><strong>實際範例</strong></td><td>Redis、作業系統分頁</td><td>CDN快取</td><td>早期快取系統</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>LRU範例</strong>：瀏覽器快取，最近看過的網頁保留，很久沒看的清除。
<pre><code>快取容量3，存取順序：A B C A D
- 初始：[]
- A：[A]
- B：[A, B]
- C：[A, B, C]
- A：[B, C, A]（A移到最前）
- D：[C, A, D]（移除B）
</code></pre>
</li>
<li><strong>LFU範例</strong>：影片推薦系統，記錄觀看次數，保留熱門影片。
<pre><code>存取次數：A(5次) B(2次) C(8次) D(1次)
快取滿時，移除D（最少被存取）
</code></pre>
</li>
<li><strong>FIFO範例</strong>：簡單的緩衝區，先進先出。
<pre><code>快取容量3，存取順序：A B C D
- D進入時，移除A（最早的）
- 結果：[B, C, D]
</code></pre>
</li>
</ul>
<hr />
<h3 id="18-直接映射-vs-全相聯-vs-組相聯-cache-mapping"><a class="header" href="#18-直接映射-vs-全相聯-vs-組相聯-cache-mapping">18. 直接映射 vs 全相聯 vs 組相聯 (Cache Mapping)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>直接映射</th><th>全相聯</th><th>組相聯</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>每個區塊只能放一個固定位置</td><td>可放任何位置</td><td>分成多組，組內可任意放</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像固定車位：你的車只能停A區</td><td>像自由停車：任何空位都能停</td><td>像分區停車：A區內任何位置都可以</td></tr>
<tr><td><strong>查找速度</strong></td><td>最快（直接計算）</td><td>最慢（全部檢查）</td><td>中等</td></tr>
<tr><td><strong>命中率</strong></td><td>最低</td><td>最高</td><td>中等</td></tr>
<tr><td><strong>適用場景</strong></td><td>簡單快取</td><td>小容量快取</td><td>CPU快取（最常用）</td></tr>
<tr><td><strong>優點</strong></td><td>硬體簡單、快速</td><td>彈性最大、命中率高</td><td>折衷效能和成本</td></tr>
<tr><td><strong>缺點</strong></td><td>衝突多</td><td>硬體複雜、查找慢</td><td>折衷方案</td></tr>
<tr><td><strong>實際範例</strong></td><td>簡單微控制器</td><td>TLB（Translation Lookaside Buffer）</td><td>CPU L1/L2/L3 Cache</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>直接映射範例</strong>：記憶體位址0x1000只能映射到快取位置0，位址0x2000也映射到位置0，會產生衝突。
<pre><code>快取8個位置（0-7）
位址0x08 → 位置0
位址0x10 → 位置0（衝突！）
</code></pre>
</li>
<li><strong>全相聯範例</strong>：任何記憶體位址都能放入任何快取位置，需要比較所有tag。
<pre><code>位址0x1000可以放在位置0-7的任何一個
查找時需要檢查全部8個位置
</code></pre>
</li>
<li><strong>組相聯範例</strong>：8-way組相聯，快取分成多組，每組8個位置。
<pre><code>64個快取位置，分成8組
位址0x1000 → 映射到組0，可放組0的任何8個位置
查找時只需檢查組0的8個位置
</code></pre>
</li>
</ul>
<hr />
<h2 id="網路與通訊"><a class="header" href="#網路與通訊">網路與通訊</a></h2>
<h3 id="19-push-vs-pull-推送-vs-拉取"><a class="header" href="#19-push-vs-pull-推送-vs-拉取">19. Push vs Pull (推送 vs 拉取)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>Push（推送）</th><th>Pull（拉取）</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>伺服器主動推送資料給客戶端</td><td>客戶端主動向伺服器請求資料</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像新聞通知：有新聞主動推送給你</td><td>像查郵件：你自己去查看有沒有新信</td></tr>
<tr><td><strong>資料流向</strong></td><td>Server → Client</td><td>Client ← Server</td></tr>
<tr><td><strong>即時性</strong></td><td>高（立即通知）</td><td>低（需要定期查詢）</td></tr>
<tr><td><strong>適用場景</strong></td><td>即時通訊、股票報價、社群通知</td><td>電子郵件、RSS訂閱、定期同步</td></tr>
<tr><td><strong>優點</strong></td><td>即時、不需輪詢</td><td>客戶端可控制頻率</td></tr>
<tr><td><strong>缺點</strong></td><td>需要保持連接、伺服器負擔大</td><td>有延遲、可能錯過更新</td></tr>
<tr><td><strong>實際範例</strong></td><td>WebSocket、Firebase</td><td>HTTP polling、Email POP3</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>Push範例</strong>：Line訊息，朋友傳訊息時伺服器立即推送到你的手機。
<pre><code class="language-javascript">// WebSocket Push
socket.on('message', (data) =&gt; {
    displayMessage(data); // 收到訊息立即顯示
});
</code></pre>
</li>
<li><strong>Pull範例</strong>：Email客戶端每15分鐘自動檢查一次新郵件。
<pre><code class="language-python">while True:
    emails = fetch_new_emails()  # 主動拉取
    time.sleep(900)  # 等15分鐘
</code></pre>
</li>
<li><strong>混合模式</strong>：
<ul>
<li>Long Polling：Pull但保持連接直到有新資料</li>
<li>Server-Sent Events（SSE）：單向Push</li>
</ul>
</li>
</ul>
<hr />
<h3 id="20-tcp-vs-udp"><a class="header" href="#20-tcp-vs-udp">20. TCP vs UDP</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>TCP</th><th>UDP</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>可靠、有序、連接導向</td><td>快速、無連接、不保證送達</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像掛號信：確保收到、有順序</td><td>像廣播：快速發送、不管有沒有收到</td></tr>
<tr><td><strong>連接</strong></td><td>需要三次握手建立連接</td><td>無需建立連接</td></tr>
<tr><td><strong>可靠性</strong></td><td>保證送達、有順序</td><td>不保證送達、可能亂序</td></tr>
<tr><td><strong>適用場景</strong></td><td>網頁、檔案傳輸、Email</td><td>線上遊戲、視訊通話、DNS</td></tr>
<tr><td><strong>優點</strong></td><td>可靠、有序、流量控制</td><td>快速、低延遲、開銷小</td></tr>
<tr><td><strong>缺點</strong></td><td>慢、開銷大</td><td>不可靠、需要應用層處理</td></tr>
<tr><td><strong>實際範例</strong></td><td>HTTP/HTTPS、SSH、FTP</td><td>線上遊戲、Zoom、DNS查詢</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>TCP範例</strong>：下載檔案，必須確保每個byte都正確且依序到達。
<pre><code>三次握手：
1. Client → Server: SYN
2. Server → Client: SYN-ACK
3. Client → Server: ACK
然後才能傳輸資料
</code></pre>
</li>
<li><strong>UDP範例</strong>：視訊通話，掉幾個封包無所謂，重要的是即時性。
<pre><code class="language-python">sock.sendto(video_frame, (ip, port))  # 直接發送
# 不等待確認，不重傳遺失的封包
</code></pre>
</li>
<li><strong>效能對比</strong>：
<ul>
<li>TCP：100ms延遲（含握手、確認）</li>
<li>UDP：10ms延遲（直接發送）</li>
</ul>
</li>
<li><strong>實務應用</strong>：
<ul>
<li>HTTP/3使用QUIC（基於UDP但加入可靠性）</li>
<li>遊戲混用：重要資料用TCP，位置更新用UDP</li>
</ul>
</li>
</ul>
<hr />
<h3 id="21-短連接-vs-長連接-short-lived-vs-persistent-connection"><a class="header" href="#21-短連接-vs-長連接-short-lived-vs-persistent-connection">21. 短連接 vs 長連接 (Short-lived vs Persistent Connection)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>短連接</th><th>長連接</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>每次請求建立連接，完成後關閉</td><td>建立一次連接，重複使用</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像計程車：每次叫新車</td><td>像包車：司機一直等你</td></tr>
<tr><td><strong>連接次數</strong></td><td>多（每次請求）</td><td>少（只建立一次）</td></tr>
<tr><td><strong>伺服器負擔</strong></td><td>建立連接的開銷大</td><td>維持連接的資源佔用</td></tr>
<tr><td><strong>適用場景</strong></td><td>低頻請求、簡單服務</td><td>高頻請求、即時通訊</td></tr>
<tr><td><strong>優點</strong></td><td>實作簡單、無需維護連接</td><td>減少建立連接開銷、效能好</td></tr>
<tr><td><strong>缺點</strong></td><td>每次建立連接有開銷</td><td>佔用伺服器資源、需要心跳機制</td></tr>
<tr><td><strong>實際範例</strong></td><td>HTTP/1.0</td><td>WebSocket、資料庫連接池</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>短連接範例</strong>：每次瀏覽網頁都建立新連接。
<pre><code>1. 建立TCP連接（三次握手）
2. 發送HTTP請求
3. 接收HTTP回應
4. 關閉TCP連接（四次揮手）
</code></pre>
</li>
<li><strong>長連接範例</strong>：聊天應用，建立一次WebSocket連接後持續使用。
<pre><code class="language-javascript">const ws = new WebSocket('wss://chat.example.com');
ws.send('Hello');  // 使用已建立的連接
ws.send('World');  // 重複使用同一連接
</code></pre>
</li>
<li><strong>HTTP演進</strong>：
<ul>
<li>HTTP/1.0：短連接</li>
<li>HTTP/1.1：引入 <code>Connection: keep-alive</code> 支援長連接</li>
<li>HTTP/2：多路複用，一個連接處理多個請求</li>
</ul>
</li>
<li><strong>心跳機制</strong>：長連接需要定期發送心跳包，確保連接存活。
<pre><code class="language-python">while True:
    send_heartbeat()
    time.sleep(30)
</code></pre>
</li>
</ul>
<hr />
<h2 id="儲存策略"><a class="header" href="#儲存策略">儲存策略</a></h2>
<h3 id="22-順序讀寫-vs-隨機讀寫-sequential-vs-random-access"><a class="header" href="#22-順序讀寫-vs-隨機讀寫-sequential-vs-random-access">22. 順序讀寫 vs 隨機讀寫 (Sequential vs Random Access)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>順序讀寫</th><th>隨機讀寫</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>連續存取資料</td><td>跳躍式存取資料</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像看書：從第一頁依序看到最後</td><td>像查字典：直接翻到需要的頁</td></tr>
<tr><td><strong>存取方式</strong></td><td>連續位址</td><td>任意位址</td></tr>
<tr><td><strong>效能差異</strong></td><td>HDD快、SSD差異小</td><td>HDD慢、SSD快</td></tr>
<tr><td><strong>適用場景</strong></td><td>日誌寫入、影片播放、備份</td><td>資料庫索引、作業系統分頁</td></tr>
<tr><td><strong>優點</strong></td><td>效能最佳（尤其HDD）</td><td>彈性高、符合應用需求</td></tr>
<tr><td><strong>缺點</strong></td><td>不彈性</td><td>HDD效能差</td></tr>
<tr><td><strong>實際範例</strong></td><td>影片檔案讀取</td><td>資料庫B-tree查詢</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>順序讀寫範例</strong>：寫日誌檔案，每次追加到檔案尾端。
<pre><code class="language-python">with open('log.txt', 'a') as f:
    f.write('新的日誌\n')  # 順序寫入
</code></pre>
</li>
<li><strong>隨機讀寫範例</strong>：資料庫更新，可能要存取不同位置的資料。
<pre><code class="language-sql">UPDATE users SET name = 'Alice' WHERE id = 1000;
UPDATE users SET name = 'Bob' WHERE id = 50;
-- 存取位置可能相距很遠
</code></pre>
</li>
<li><strong>效能差異（HDD）</strong>：
<ul>
<li>順序讀取：100-200 MB/s</li>
<li>隨機讀取：0.5-2 MB/s（慢100倍！）</li>
</ul>
</li>
<li><strong>SSD優勢</strong>：
<ul>
<li>順序讀取：500-3500 MB/s</li>
<li>隨機讀取：300-3000 MB/s（差異小很多）</li>
</ul>
</li>
<li><strong>優化策略</strong>：資料庫使用寫前日誌（WAL），隨機寫轉換為順序寫。</li>
</ul>
<hr />
<h3 id="23-集中式-vs-分散式-centralized-vs-distributed"><a class="header" href="#23-集中式-vs-分散式-centralized-vs-distributed">23. 集中式 vs 分散式 (Centralized vs Distributed)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>集中式</th><th>分散式</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>單一節點處理所有請求</td><td>多個節點協同處理</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像總公司：所有決策一個地方做</td><td>像連鎖店：各分店獨立運作</td></tr>
<tr><td><strong>單點故障</strong></td><td>有（節點故障全停）</td><td>無（部分節點故障仍可運作）</td></tr>
<tr><td><strong>複雜度</strong></td><td>簡單</td><td>複雜（需要協調機制）</td></tr>
<tr><td><strong>適用場景</strong></td><td>小型應用、單一地區</td><td>大型應用、全球服務</td></tr>
<tr><td><strong>優點</strong></td><td>實作簡單、一致性容易保證</td><td>高可用、可擴展、容錯</td></tr>
<tr><td><strong>缺點</strong></td><td>單點故障、擴展性差</td><td>複雜、一致性難保證</td></tr>
<tr><td><strong>實際範例</strong></td><td>傳統資料庫（單機）</td><td>Google搜尋、Facebook</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>集中式範例</strong>：小型電商網站，單一伺服器處理所有訂單。
<pre><code>[所有使用者] → [單一伺服器] → [單一資料庫]
伺服器故障 = 整個網站停擺
</code></pre>
</li>
<li><strong>分散式範例</strong>：YouTube影片存儲，分散在全球數千台伺服器。
<pre><code>[美國使用者] → [美國伺服器]
[台灣使用者] → [台灣伺服器]
任一伺服器故障不影響其他地區
</code></pre>
</li>
<li><strong>CAP定理</strong>：分散式系統無法同時滿足一致性、可用性、分區容錯性。</li>
<li><strong>分散式挑戰</strong>：
<ul>
<li>資料同步：如何保持各節點資料一致</li>
<li>時鐘同步：不同伺服器時間可能不一致</li>
<li>網路分區：節點間無法通訊時如何處理</li>
</ul>
</li>
</ul>
<hr />
<h3 id="24-複製-vs-分片-replication-vs-sharding"><a class="header" href="#24-複製-vs-分片-replication-vs-sharding">24. 複製 vs 分片 (Replication vs Sharding)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>複製 (Replication)</th><th>分片 (Sharding)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>相同資料存多份到不同節點</td><td>資料切分到不同節點</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像備份：每台電腦都有完整資料</td><td>像圖書館分館：每館只有部分書</td></tr>
<tr><td><strong>資料分佈</strong></td><td>每個節點都有全部資料</td><td>每個節點只有部分資料</td></tr>
<tr><td><strong>目的</strong></td><td>提高可用性和讀取效能</td><td>提高容量和寫入效能</td></tr>
<tr><td><strong>適用場景</strong></td><td>讀多寫少、需要高可用性</td><td>資料量大、需要水平擴展</td></tr>
<tr><td><strong>優點</strong></td><td>容錯好、讀取快</td><td>容量無限、寫入分散</td></tr>
<tr><td><strong>缺點</strong></td><td>寫入需要同步、儲存成本高</td><td>跨分片查詢慢、複雜度高</td></tr>
<tr><td><strong>實際範例</strong></td><td>MySQL主從複製、Redis Sentinel</td><td>MongoDB分片、分散式資料庫</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>複製範例</strong>：電商網站有3個資料庫副本。
<pre><code>Master DB（主）：處理寫入
Slave DB 1（從）：處理讀取
Slave DB 2（從）：處理讀取
→ 讀取效能提升3倍，任一故障不影響服務
</code></pre>
</li>
<li><strong>分片範例</strong>：社群網站依使用者ID分片。
<pre><code>Shard 1：使用者 ID 0-999999
Shard 2：使用者 ID 1000000-1999999
Shard 3：使用者 ID 2000000-2999999
→ 每個分片只處理部分資料，容量可無限擴展
</code></pre>
</li>
<li><strong>混合使用</strong>：每個分片內部做複製。
<pre><code>Shard 1 Master + 2 Slaves
Shard 2 Master + 2 Slaves
→ 既能擴容又能容錯
</code></pre>
</li>
<li><strong>分片鍵選擇</strong>：
<ul>
<li>好的分片鍵：使用者ID（均勻分佈）</li>
<li>壞的分片鍵：註冊日期（新使用者集中在一個分片）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="一致性模型"><a class="header" href="#一致性模型">一致性模型</a></h2>
<h3 id="25-強一致性-vs-最終一致性-strong-vs-eventual-consistency"><a class="header" href="#25-強一致性-vs-最終一致性-strong-vs-eventual-consistency">25. 強一致性 vs 最終一致性 (Strong vs Eventual Consistency)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>強一致性</th><th>最終一致性</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>寫入後立即所有節點看到相同資料</td><td>寫入後過一段時間才一致</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像廣播：所有人同時聽到消息</td><td>像傳話遊戲：消息逐漸傳開</td></tr>
<tr><td><strong>延遲</strong></td><td>高（需等待所有節點確認）</td><td>低（不等待）</td></tr>
<tr><td><strong>可用性</strong></td><td>較低（節點故障可能無法寫入）</td><td>高（總是可以寫入）</td></tr>
<tr><td><strong>適用場景</strong></td><td>金融交易、庫存系統</td><td>社群媒體、快取、DNS</td></tr>
<tr><td><strong>優點</strong></td><td>資料一定正確</td><td>效能好、高可用</td></tr>
<tr><td><strong>缺點</strong></td><td>效能差、可用性低</td><td>短期內可能不一致</td></tr>
<tr><td><strong>實際範例</strong></td><td>銀行轉帳</td><td>Facebook按讚數</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>強一致性範例</strong>：銀行轉帳，A轉1000元給B，必須確保兩邊同時生效。
<pre><code>1. A帳戶 -1000（所有副本都確認）
2. B帳戶 +1000（所有副本都確認）
3. 交易完成
如果任一步驟失敗，整個交易回滾
</code></pre>
</li>
<li><strong>最終一致性範例</strong>：Facebook貼文按讚。
<pre><code>時間 0秒：Alice按讚，美國伺服器記錄
時間 1秒：按讚數顯示+1（在美國）
時間 5秒：資料同步到亞洲伺服器
時間 5秒：按讚數顯示+1（在台灣）
→ 短期內不同地區看到不同數字，但最終會一致
</code></pre>
</li>
<li><strong>一致性級別</strong>（由強到弱）：
<ol>
<li>線性一致性（Linearizability）：最強</li>
<li>順序一致性（Sequential Consistency）</li>
<li>因果一致性（Causal Consistency）</li>
<li>最終一致性（Eventual Consistency）：最弱</li>
</ol>
</li>
</ul>
<hr />
<h3 id="26-cp-vs-ap-cap定理"><a class="header" href="#26-cp-vs-ap-cap定理">26. CP vs AP (CAP定理)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>CP（一致性+分區容錯）</th><th>AP（可用性+分區容錯）</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>網路分區時犧牲可用性保證一致性</td><td>網路分區時犧牲一致性保證可用性</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像嚴格的考試：寧可不考也不給錯答案</td><td>像開卷考試：先給答案，對錯之後再說</td></tr>
<tr><td><strong>網路分區時</strong></td><td>拒絕服務或返回錯誤</td><td>繼續服務但可能不一致</td></tr>
<tr><td><strong>適用場景</strong></td><td>金融系統、庫存管理、選舉</td><td>DNS、快取、社群媒體</td></tr>
<tr><td><strong>優點</strong></td><td>資料絕對正確</td><td>服務永遠可用</td></tr>
<tr><td><strong>缺點</strong></td><td>可能暫時無法使用</td><td>可能讀到舊資料</td></tr>
<tr><td><strong>實際範例</strong></td><td>銀行系統、訂票系統</td><td>Amazon購物車、Twitter</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>CAP定理</strong>：一致性（Consistency）、可用性（Availability）、分區容錯性（Partition Tolerance）三者只能取其二。</li>
<li><strong>CP範例</strong>：訂票系統，網路分區時寧可停止售票，也不能超賣。
<pre><code>情境：兩個資料中心失去連接
CP做法：停止售票，等網路恢復
→ 確保不會把同一個座位賣給兩個人
</code></pre>
</li>
<li><strong>AP範例</strong>：購物車，網路分區時繼續加商品，稍後合併。
<pre><code>情境：使用者在美國加商品A，網路分區
AP做法：先加入本地購物車
→ 稍後網路恢復，與其他資料中心的購物車合併
可能出現：短期內不同地區看到不同購物車內容
</code></pre>
</li>
<li><strong>實務選擇</strong>：
<ul>
<li>金融：選CP（寧可暫停服務，不能出錯）</li>
<li>社群：選AP（暫時不一致沒關係，服務可用更重要）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="執行模式"><a class="header" href="#執行模式">執行模式</a></h2>
<h3 id="27-單執行緒-vs-多執行緒-vs-多程序-single-threaded-vs-multi-threaded-vs-multi-process"><a class="header" href="#27-單執行緒-vs-多執行緒-vs-多程序-single-threaded-vs-multi-threaded-vs-multi-process">27. 單執行緒 vs 多執行緒 vs 多程序 (Single-threaded vs Multi-threaded vs Multi-process)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>單執行緒</th><th>多執行緒</th><th>多程序</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>一次只做一件事</td><td>多個執行緒共享記憶體</td><td>多個程序獨立記憶體</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像一人廚房：一次煮一道菜</td><td>像團隊廚房：共用鍋碗瓢盆</td><td>像多間廚房：各自獨立</td></tr>
<tr><td><strong>記憶體</strong></td><td>共享全部</td><td>共享同一程序記憶體</td><td>完全獨立</td></tr>
<tr><td><strong>切換開銷</strong></td><td>無</td><td>低</td><td>高</td></tr>
<tr><td><strong>適用場景</strong></td><td>簡單任務、I/O密集（Node.js）</td><td>CPU密集、需要共享資料</td><td>需要隔離、安全性高</td></tr>
<tr><td><strong>優點</strong></td><td>簡單、無同步問題</td><td>效能好、共享資料容易</td><td>隔離好、穩定</td></tr>
<tr><td><strong>缺點</strong></td><td>無法利用多核</td><td>需要同步、可能死鎖</td><td>通訊慢、記憶體佔用大</td></tr>
<tr><td><strong>實際範例</strong></td><td>JavaScript（瀏覽器）</td><td>Java應用、科學計算</td><td>Chrome瀏覽器分頁、Nginx</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>單執行緒範例</strong>：Node.js使用事件迴圈處理多個請求。
<pre><code class="language-javascript">// 雖然只有一個執行緒，但可以處理多個請求
server.on('request', (req, res) =&gt; {
    // 非阻塞I/O，不會卡住其他請求
    fs.readFile('file.txt', (err, data) =&gt; {
        res.end(data);
    });
});
</code></pre>
</li>
<li><strong>多執行緒範例</strong>：影片處理軟體，每個執行緒處理一段影片。
<pre><code class="language-python">import threading

def process_chunk(start, end):
    # 處理影片的一部分
    pass

threads = []
for i in range(4):  # 4個執行緒
    t = threading.Thread(target=process_chunk, args=(i*100, (i+1)*100))
    threads.append(t)
    t.start()
</code></pre>
</li>
<li><strong>多程序範例</strong>：Chrome每個分頁一個程序，一個分頁崩潰不影響其他。
<pre><code class="language-python">from multiprocessing import Process

def worker(data):
    # 完全獨立的處理
    pass

processes = []
for i in range(4):
    p = Process(target=worker, args=(data[i],))
    processes.append(p)
    p.start()
</code></pre>
</li>
<li><strong>效能對比</strong>：
<ul>
<li>單執行緒：1核心100%，其他核心閒置</li>
<li>多執行緒：4核心各100%（4倍效能）</li>
<li>多程序：4核心各100%，但記憶體佔用是多執行緒的4倍</li>
</ul>
</li>
</ul>
<hr />
<h3 id="28-事件驅動-vs-多執行緒-event-driven-vs-multi-threaded"><a class="header" href="#28-事件驅動-vs-多執行緒-event-driven-vs-multi-threaded">28. 事件驅動 vs 多執行緒 (Event-driven vs Multi-threaded)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>事件驅動</th><th>多執行緒</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>單執行緒+事件迴圈處理多個連接</td><td>每個連接一個執行緒</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像櫃台人員：一個人服務多個客戶</td><td>像私人助理：每個客戶一個助理</td></tr>
<tr><td><strong>並發方式</strong></td><td>協作式多工（cooperative）</td><td>搶佔式多工（preemptive）</td></tr>
<tr><td><strong>資源佔用</strong></td><td>低（單執行緒）</td><td>高（每個執行緒需要stack）</td></tr>
<tr><td><strong>適用場景</strong></td><td>I/O密集（網頁伺服器、聊天）</td><td>CPU密集（影片編碼）</td></tr>
<tr><td><strong>優點</strong></td><td>低開銷、高並發連接數</td><td>實作簡單、符合直覺</td></tr>
<tr><td><strong>缺點</strong></td><td>不適合CPU密集</td><td>執行緒多時開銷大</td></tr>
<tr><td><strong>實際範例</strong></td><td>Node.js、Nginx</td><td>Apache（傳統模式）</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>事件驅動範例</strong>：Node.js處理10000個同時連接。
<pre><code class="language-javascript">// 單執行緒處理多個連接
const server = http.createServer();
server.on('request', async (req, res) =&gt; {
    const data = await db.query();  // 非阻塞
    res.end(data);
});
// 10000個連接只需要一個執行緒
</code></pre>
</li>
<li><strong>多執行緒範例</strong>：Apache為每個連接建立執行緒。
<pre><code>連接1 → 執行緒1
連接2 → 執行緒2
連接3 → 執行緒3
...
→ 10000個連接需要10000個執行緒（記憶體爆炸）
</code></pre>
</li>
<li><strong>C10K問題</strong>：如何讓一台伺服器處理10000個同時連接。
<ul>
<li>傳統多執行緒：失敗（記憶體不足）</li>
<li>事件驅動：成功（低記憶體佔用）</li>
</ul>
</li>
<li><strong>混合模式</strong>：
<ul>
<li>Node.js：主執行緒事件驅動 + Worker執行緒處理CPU密集</li>
<li>Nginx：事件驅動處理連接 + Worker程序平行處理</li>
</ul>
</li>
</ul>
<hr />
<h3 id="29-同步執行-vs-平行執行-vs-並發執行-synchronous-vs-parallel-vs-concurrent"><a class="header" href="#29-同步執行-vs-平行執行-vs-並發執行-synchronous-vs-parallel-vs-concurrent">29. 同步執行 vs 平行執行 vs 並發執行 (Synchronous vs Parallel vs Concurrent)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>同步執行</th><th>平行執行</th><th>並發執行</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>依序執行，一次一個</td><td>真正同時執行（多核）</td><td>快速切換，看似同時</td></tr>
<tr><td><strong>白話比喻</strong></td><td>一人排隊辦事：辦完一件再辦下一件</td><td>多個櫃台同時辦事</td><td>一人快速處理多件事</td></tr>
<tr><td><strong>硬體需求</strong></td><td>單核即可</td><td>需要多核心</td><td>單核即可</td></tr>
<tr><td><strong>真正同時</strong></td><td>否</td><td>是</td><td>否（輪流）</td></tr>
<tr><td><strong>適用場景</strong></td><td>簡單任務</td><td>CPU密集、科學計算</td><td>I/O密集、多任務</td></tr>
<tr><td><strong>優點</strong></td><td>簡單、可預測</td><td>最快（利用硬體）</td><td>高效使用單核</td></tr>
<tr><td><strong>缺點</strong></td><td>慢</td><td>需要多核、同步複雜</td><td>不能加速CPU密集</td></tr>
<tr><td><strong>實際範例</strong></td><td>簡單腳本</td><td>影片渲染、機器學習訓練</td><td>作業系統多工</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>同步執行範例</strong>：煮飯流程。
<pre><code class="language-python">煮飯()    # 30分鐘
炒菜()    # 20分鐘
煮湯()    # 15分鐘
總時間：65分鐘
</code></pre>
</li>
<li><strong>平行執行範例</strong>：三個人同時煮。
<pre><code class="language-python"># 3個CPU核心
Thread1: 煮飯()  # 30分鐘
Thread2: 炒菜()  # 20分鐘
Thread3: 煮湯()  # 15分鐘
總時間：30分鐘（最長的任務）
</code></pre>
</li>
<li><strong>並發執行範例</strong>：一個人快速切換。
<pre><code class="language-python"># 單核心，快速切換
0-10分鐘：煮飯
10-15分鐘：炒菜
15-20分鐘：煮湯
20-25分鐘：煮飯
...（不斷切換）
總時間：接近65分鐘（因為有切換開銷）
</code></pre>
</li>
<li><strong>Python範例</strong>：
<pre><code class="language-python"># 同步
result1 = task1()
result2 = task2()

# 並發（I/O）
import asyncio
result1, result2 = await asyncio.gather(task1(), task2())

# 平行（CPU）
from multiprocessing import Pool
pool = Pool(4)
results = pool.map(task, data)
</code></pre>
</li>
</ul>
<hr />
<h2 id="設計模式"><a class="header" href="#設計模式">設計模式</a></h2>
<h3 id="30-單體-vs-微服務-monolithic-vs-microservices"><a class="header" href="#30-單體-vs-微服務-monolithic-vs-microservices">30. 單體 vs 微服務 (Monolithic vs Microservices)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>單體 (Monolithic)</th><th>微服務 (Microservices)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>所有功能在一個應用程式</td><td>功能拆分成獨立服務</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像百貨公司：所有部門在一棟樓</td><td>像商店街：每個店面獨立營運</td></tr>
<tr><td><strong>部署單位</strong></td><td>整個應用一起部署</td><td>每個服務獨立部署</td></tr>
<tr><td><strong>技術棧</strong></td><td>統一</td><td>可以不同</td></tr>
<tr><td><strong>適用場景</strong></td><td>小型專案、快速開發</td><td>大型專案、需要彈性擴展</td></tr>
<tr><td><strong>優點</strong></td><td>開發簡單、部署容易</td><td>獨立開發、獨立擴展、容錯</td></tr>
<tr><td><strong>缺點</strong></td><td>難以擴展、一個bug影響全部</td><td>複雜度高、需要服務治理</td></tr>
<tr><td><strong>實際範例</strong></td><td>傳統電商網站</td><td>Netflix、Uber</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>單體範例</strong>：傳統電商系統。
<pre><code>單一應用程式包含：
- 使用者管理
- 商品管理
- 訂單處理
- 付款處理
- 物流追蹤
→ 改一個功能要重新部署整個應用
</code></pre>
</li>
<li><strong>微服務範例</strong>：Netflix架構。
<pre><code>獨立服務：
- User Service（使用者服務）
- Video Service（影片服務）
- Recommendation Service（推薦服務）
- Billing Service（計費服務）
→ 每個服務可以獨立開發、部署、擴展
</code></pre>
</li>
<li><strong>演進過程</strong>：
<ol>
<li>小型新創：單體（快速開發）</li>
<li>業務成長：單體開始變慢、難維護</li>
<li>拆分服務：逐步轉為微服務</li>
</ol>
</li>
<li><strong>挑戰</strong>：
<ul>
<li>服務間通訊：需要API Gateway</li>
<li>資料一致性：分散式交易</li>
<li>服務發現：如何找到其他服務</li>
<li>監控除錯：需要分散式追蹤</li>
</ul>
</li>
</ul>
<hr />
<h3 id="31-拉模型-vs-推模型-pull-vs-push-model---資料流"><a class="header" href="#31-拉模型-vs-推模型-pull-vs-push-model---資料流">31. 拉模型 vs 推模型 (Pull vs Push Model - 資料流)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>比較項目</th><th>拉模型 (Pull)</th><th>推模型 (Push)</th></tr></thead><tbody>
<tr><td><strong>運作方式</strong></td><td>消費者主動拉取資料</td><td>生產者主動推送資料</td></tr>
<tr><td><strong>白話比喻</strong></td><td>像去餐廳點餐：你決定吃什麼</td><td>像外送訂閱：固定送來你家</td></tr>
<tr><td><strong>控制權</strong></td><td>消費者控制</td><td>生產者控制</td></tr>
<tr><td><strong>背壓處理</strong></td><td>天然支援（拉取速度自己控制）</td><td>需要額外機制</td></tr>
<tr><td><strong>適用場景</strong></td><td>Kafka消費者、批次處理</td><td>WebSocket、即時通知</td></tr>
<tr><td><strong>優點</strong></td><td>消費者可控制速率、避免過載</td><td>即時性好、低延遲</td></tr>
<tr><td><strong>缺點</strong></td><td>可能有延遲</td><td>容易壓垮消費者</td></tr>
<tr><td><strong>實際範例</strong></td><td>Kafka Consumer拉取訊息</td><td>Firebase即時資料庫推送</td></tr>
</tbody></table>
</div>
<p><strong>詳細說明：</strong></p>
<ul>
<li><strong>拉模型範例</strong>：Kafka消費者。
<pre><code class="language-python"># 消費者主動拉取
while True:
    messages = consumer.poll(timeout=1.0)
    for message in messages:
        process(message)
    # 處理完一批再拉取下一批，速度自己控制
</code></pre>
</li>
<li><strong>推模型範例</strong>：WebSocket推送。
<pre><code class="language-javascript">// 伺服器主動推送
socket.on('connect', () =&gt; {
    socket.emit('newMessage', message);  // 有訊息就推送
});
// 消費者被動接收，無法控制速度
</code></pre>
</li>
<li><strong>背壓問題</strong>：推模型可能壓垮慢速消費者。
<pre><code>生產者：每秒產生10000條訊息
消費者：每秒只能處理1000條
→ 推模型：消費者記憶體爆炸
→ 拉模型：消費者慢慢拉，不會過載
</code></pre>
</li>
<li><strong>混合模式</strong>：
<ul>
<li>RabbitMQ：支援推和拉兩種模式</li>
<li>gRPC Streaming：可以雙向推送</li>
</ul>
</li>
</ul>
<hr />
<h2 id="選擇決策樹"><a class="header" href="#選擇決策樹">選擇決策樹</a></h2>
<pre><code>選擇技術時的考量順序：

1. 業務需求
   ├─ 一致性要求高？ → 強一致性、CP
   └─ 可用性要求高？ → 最終一致性、AP

2. 資料特性
   ├─ 資料量大？ → 分片
   ├─ 讀多寫少？ → 複製 + 快取
   └─ 寫多讀少？ → 寫優化的資料結構

3. 效能需求
   ├─ 低延遲？ → 快取、異步
   ├─ 高吞吐？ → 平行處理、批次
   └─ 即時性？ → Push、WebSocket

4. 系統規模
   ├─ 小型？ → 單體、集中式
   ├─ 中型？ → 垂直擴展、複製
   └─ 大型？ → 微服務、分散式

5. 團隊能力
   ├─ 經驗少？ → 選擇簡單方案
   └─ 經驗多？ → 可選複雜但效能好的方案
</code></pre>
<hr />
<h2 id="實務建議"><a class="header" href="#實務建議">實務建議</a></h2>
<h3 id="1-不要過度設計"><a class="header" href="#1-不要過度設計">1. 不要過度設計</a></h3>
<ul>
<li>從簡單開始，需要時再優化</li>
<li>單體 → 垂直擴展 → 水平擴展 → 微服務</li>
</ul>
<h3 id="2-測量再優化"><a class="header" href="#2-測量再優化">2. 測量再優化</a></h3>
<ul>
<li>先測量瓶頸在哪</li>
<li>不要憑感覺優化</li>
</ul>
<h3 id="3-權衡取捨"><a class="header" href="#3-權衡取捨">3. 權衡取捨</a></h3>
<ul>
<li>沒有完美方案，只有適合的方案</li>
<li>考慮維護成本、開發時間、效能</li>
</ul>
<h3 id="4-關注變化"><a class="header" href="#4-關注變化">4. 關注變化</a></h3>
<ul>
<li>技術持續演進</li>
<li>保持學習，適時調整</li>
</ul>
<h3 id="5-文件化決策"><a class="header" href="#5-文件化決策">5. 文件化決策</a></h3>
<ul>
<li>記錄為什麼選擇這個方案</li>
<li>未來回顧時有依據</li>
</ul>
<hr />
<h2 id="總結對照表"><a class="header" href="#總結對照表">總結對照表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>分類</th><th>機制對比</th><th>核心差異</th><th>選擇關鍵</th></tr></thead><tbody>
<tr><td>I/O</td><td>中斷 vs 輪詢</td><td>主動通知 vs 被動檢查</td><td>事件頻率</td></tr>
<tr><td>I/O</td><td>同步 vs 異步</td><td>等待 vs 回調</td><td>並發需求</td></tr>
<tr><td>I/O</td><td>阻塞 vs 非阻塞</td><td>等結果 vs 立即返回</td><td>多工需求</td></tr>
<tr><td>I/O</td><td>DMA vs PIO</td><td>硬體搬移 vs CPU搬移</td><td>資料量</td></tr>
<tr><td>記憶體</td><td>分頁 vs 分段</td><td>固定 vs 可變</td><td>管理複雜度</td></tr>
<tr><td>記憶體</td><td>寫回 vs 寫透</td><td>延遲寫 vs 立即寫</td><td>資料安全性</td></tr>
<tr><td>記憶體</td><td>靜態 vs 動態</td><td>編譯期 vs 執行期</td><td>彈性需求</td></tr>
<tr><td>排程</td><td>搶佔 vs 非搶佔</td><td>強制切換 vs 自願讓出</td><td>即時性</td></tr>
<tr><td>排程</td><td>FCFS vs SJF vs RR</td><td>順序 vs 最短 vs 輪流</td><td>公平性</td></tr>
<tr><td>並行</td><td>鎖 vs 無鎖</td><td>互斥 vs 原子操作</td><td>競爭程度</td></tr>
<tr><td>並行</td><td>悲觀 vs 樂觀</td><td>預防 vs 偵測</td><td>衝突率</td></tr>
<tr><td>並行</td><td>粗粒度 vs 細粒度</td><td>大鎖 vs 小鎖</td><td>並發需求</td></tr>
<tr><td>資料結構</td><td>陣列 vs 鏈結串列</td><td>連續 vs 分散</td><td>存取模式</td></tr>
<tr><td>資料結構</td><td>堆疊 vs 佇列</td><td>LIFO vs FIFO</td><td>處理順序</td></tr>
<tr><td>資料結構</td><td>Hash vs Tree</td><td>無序快速 vs 有序範圍</td><td>查詢類型</td></tr>
<tr><td>快取</td><td>LRU vs LFU vs FIFO</td><td>時間 vs 頻率 vs 順序</td><td>存取模式</td></tr>
<tr><td>快取</td><td>直接映射 vs 全相聯 vs 組相聯</td><td>固定 vs 任意 vs 分組</td><td>硬體成本</td></tr>
<tr><td>網路</td><td>Push vs Pull</td><td>推送 vs 拉取</td><td>即時性</td></tr>
<tr><td>網路</td><td>TCP vs UDP</td><td>可靠 vs 快速</td><td>資料重要性</td></tr>
<tr><td>網路</td><td>短連接 vs 長連接</td><td>用完丟 vs 重複用</td><td>請求頻率</td></tr>
<tr><td>儲存</td><td>順序 vs 隨機</td><td>連續 vs 跳躍</td><td>資料存取模式</td></tr>
<tr><td>儲存</td><td>集中式 vs 分散式</td><td>單點 vs 多點</td><td>規模</td></tr>
<tr><td>儲存</td><td>複製 vs 分片</td><td>備份 vs 分割</td><td>目的</td></tr>
<tr><td>一致性</td><td>強一致 vs 最終一致</td><td>立即 vs 延遲</td><td>業務需求</td></tr>
<tr><td>一致性</td><td>CP vs AP</td><td>一致性 vs 可用性</td><td>CAP取捨</td></tr>
<tr><td>執行</td><td>單執行緒 vs 多執行緒 vs 多程序</td><td>一個 vs 共享 vs 隔離</td><td>隔離需求</td></tr>
<tr><td>執行</td><td>事件驅動 vs 多執行緒</td><td>單執行緒多工 vs 多執行緒</td><td>I/O vs CPU</td></tr>
<tr><td>執行</td><td>同步 vs 平行 vs 並發</td><td>依序 vs 同時 vs 輪流</td><td>硬體資源</td></tr>
<tr><td>設計</td><td>單體 vs 微服務</td><td>一體 vs 拆分</td><td>系統規模</td></tr>
<tr><td>資料流</td><td>Pull vs Push</td><td>拉取 vs 推送</td><td>控制權</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>最後提醒：</strong>
選擇技術方案沒有絕對的對錯，關鍵是：</p>
<ol>
<li>理解每種方案的優缺點</li>
<li>評估你的實際需求和限制</li>
<li>做出合理的權衡</li>
<li>持續監控和優化</li>
</ol>
<p>希望這份整理能幫助你在系統設計時做出更好的決策！ 🚀</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../software_engineering/testing_methods_guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../performance/Performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../software_engineering/testing_methods_guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../performance/Performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
