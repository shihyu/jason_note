<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TSE Receiver å„ªåŒ–æŒ‡å— - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tse-receiver-å®Œæ•´å„ªåŒ–æŒ‡å—"><a class="header" href="#tse-receiver-å®Œæ•´å„ªåŒ–æŒ‡å—">TSE Receiver å®Œæ•´å„ªåŒ–æŒ‡å—</a></h1>
<h2 id="-ç›®éŒ„"><a class="header" href="#-ç›®éŒ„">ğŸ“‹ ç›®éŒ„</a></h2>
<ol>
<li><a href="#io-%E6%A8%A1%E5%BC%8F%E5%B0%8D%E6%AF%94%E5%88%86%E6%9E%90">I/O æ¨¡å¼å°æ¯”åˆ†æ</a></li>
<li><a href="#%E7%95%B6%E5%89%8D%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B%E5%88%86%E6%9E%90">ç•¶å‰ç¨‹å¼ç‹€æ…‹åˆ†æ</a></li>
<li><a href="#%E5%84%AA%E5%8C%96%E6%96%B9%E6%A1%88%E7%B8%BD%E8%A6%BD">å„ªåŒ–æ–¹æ¡ˆç¸½è¦½</a></li>
<li><a href="#%E6%96%B9%E6%A1%88-1-blocking-io-%E8%BC%95%E9%87%8F%E5%84%AA%E5%8C%96">æ–¹æ¡ˆ 1: Blocking I/O è¼•é‡å„ªåŒ–</a></li>
<li><a href="#%E6%96%B9%E6%A1%88-2-non-blocking--busy-polling-hft-%E7%B4%9A">æ–¹æ¡ˆ 2: Non-blocking + Busy Polling (HFT ç´š)</a></li>
<li><a href="#%E6%96%B9%E6%A1%88-3-%E5%AE%8C%E6%95%B4-hft-%E7%89%88%E6%9C%AC">æ–¹æ¡ˆ 3: å®Œæ•´ HFT ç‰ˆæœ¬</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E5%B0%8D%E6%AF%94%E8%88%87%E9%81%B8%E6%93%87%E5%BB%BA%E8%AD%B0">æ€§èƒ½å°æ¯”èˆ‡é¸æ“‡å»ºè­°</a></li>
<li><a href="#%E7%B3%BB%E7%B5%B1%E7%B4%9A%E5%84%AA%E5%8C%96%E9%85%8D%E7%BD%AE">ç³»çµ±ç´šå„ªåŒ–é…ç½®</a></li>
<li><a href="#%E7%9B%A3%E6%8E%A7%E8%88%87%E8%AA%BF%E8%A9%A6%E5%B7%A5%E5%85%B7">ç›£æ§èˆ‡èª¿è©¦å·¥å…·</a></li>
</ol>
<hr />
<h2 id="io-æ¨¡å¼å°æ¯”åˆ†æ"><a class="header" href="#io-æ¨¡å¼å°æ¯”åˆ†æ">I/O æ¨¡å¼å°æ¯”åˆ†æ</a></h2>
<h3 id="å»¶é²çµ„æˆåˆ†æ"><a class="header" href="#å»¶é²çµ„æˆåˆ†æ">å»¶é²çµ„æˆåˆ†æ</a></h3>
<pre><code>ç¸½å»¶é² = ç¶²è·¯å‚³è¼¸æ™‚é–“ + å…§æ ¸è™•ç†æ™‚é–“ + æ‡‰ç”¨å±¤è™•ç†æ™‚é–“
</code></pre>
<h3 id="ä¸‰ç¨®-io-æ¨¡å¼å°æ¯”"><a class="header" href="#ä¸‰ç¨®-io-æ¨¡å¼å°æ¯”">ä¸‰ç¨® I/O æ¨¡å¼å°æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>I/O æ¨¡å¼</th><th>å»¶é²è·¯å¾‘</th><th>P50 å»¶é²</th><th>P99 å»¶é²</th><th>CPU ä½¿ç”¨ç‡</th></tr></thead><tbody>
<tr><td><strong>Blocking I/O</strong></td><td>æ•¸æ“šåˆ°é” â†’ å…§æ ¸å–šé†’ç·šç¨‹ â†’ recvfrom è¿”å› â†’ è™•ç†</td><td>2-7 Î¼s</td><td>10-50 Î¼s</td><td>~0%</td></tr>
<tr><td><strong>epoll</strong></td><td>æ•¸æ“šåˆ°é” â†’ å…§æ ¸å–šé†’ â†’ epoll_wait è¿”å› â†’ recvfrom â†’ è™•ç†</td><td>3-10 Î¼s</td><td>15-60 Î¼s</td><td>~0%</td></tr>
<tr><td><strong>Busy Polling</strong></td><td>æ•¸æ“šåˆ°é” â†’ (ç¨‹å¼å·²é‹è¡Œ) â†’ recvfrom ç«‹å³è¿”å› â†’ è™•ç†</td><td>0.5-2 Î¼s</td><td>3-10 Î¼s</td><td>100%</td></tr>
</tbody></table>
</div>
<h3 id="ç‚ºä»€éº¼-epoll-ä¸é©åˆé€™å€‹å ´æ™¯"><a class="header" href="#ç‚ºä»€éº¼-epoll-ä¸é©åˆé€™å€‹å ´æ™¯">ç‚ºä»€éº¼ epoll ä¸é©åˆé€™å€‹å ´æ™¯ï¼Ÿ</a></h3>
<h4 id="-epoll-çš„å•é¡Œ"><a class="header" href="#-epoll-çš„å•é¡Œ">âŒ epoll çš„å•é¡Œ</a></h4>
<ol>
<li>
<p><strong>å–®ä¸€ Socket å ´æ™¯</strong></p>
<ul>
<li>ç•¶å‰åªç›£è½ 1 å€‹ UDP multicast socket</li>
<li>epoll å„ªå‹¢æ˜¯ç®¡ç†æ•¸åƒå€‹ä¸¦ç™¼é€£ç·š</li>
<li>å–®ä¸€ socket æ™‚ï¼Œepoll åªæœƒå¢åŠ ç³»çµ±èª¿ç”¨é–‹éŠ·</li>
</ul>
</li>
<li>
<p><strong>å¢åŠ å»¶é²</strong></p>
<pre><code>Blocking: æ•¸æ“šåˆ°é” â†’ ç«‹å³è™•ç† (2 Î¼s)
epoll:    æ•¸æ“šåˆ°é” â†’ epoll_wait â†’ recvfrom â†’ è™•ç† (3-4 Î¼s)
</code></pre>
</li>
<li>
<p><strong>UDP ç‰¹æ€§</strong></p>
<ul>
<li>UDP ç„¡ç‹€æ…‹ï¼Œç„¡éœ€ç®¡ç†é€£ç·š</li>
<li>æ•¸æ“šåˆ°é”æ™‚ blocking recvfrom ç«‹å³å–šé†’</li>
<li>æ²’æœ‰ TCP çš„é€£ç·šç¶­è­·é–‹éŠ·</li>
</ul>
</li>
</ol>
<h4 id="-æ­£ç¢ºé¸æ“‡"><a class="header" href="#-æ­£ç¢ºé¸æ“‡">âœ… æ­£ç¢ºé¸æ“‡</a></h4>
<ul>
<li><strong>ä¸€èˆ¬å ´æ™¯</strong> â†’ Blocking I/O</li>
<li><strong>HFT å ´æ™¯</strong> â†’ Busy Polling</li>
<li><strong>æ°¸é ä¸ç”¨</strong> â†’ epoll (å–®ä¸€ socket)</li>
</ul>
<hr />
<h2 id="ç•¶å‰ç¨‹å¼ç‹€æ…‹åˆ†æ"><a class="header" href="#ç•¶å‰ç¨‹å¼ç‹€æ…‹åˆ†æ">ç•¶å‰ç¨‹å¼ç‹€æ…‹åˆ†æ</a></h2>
<h3 id="ç›®å‰ä½¿ç”¨çš„-io-æ¨¡å¼blocking-io"><a class="header" href="#ç›®å‰ä½¿ç”¨çš„-io-æ¨¡å¼blocking-io">ç›®å‰ä½¿ç”¨çš„ I/O æ¨¡å¼ï¼š<strong>Blocking I/O</strong></a></h3>
<h4 id="è­‰æ“š-1-socket-å‰µå»º"><a class="header" href="#è­‰æ“š-1-socket-å‰µå»º">è­‰æ“š 1: Socket å‰µå»º</a></h4>
<pre><code class="language-c">// ç¬¬ 289 è¡Œ - é»˜èªå‰µå»ºé˜»å¡å¼ socket
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
// âŒ æ²’æœ‰è¨­ç½® O_NONBLOCK
</code></pre>
<h4 id="è­‰æ“š-2-recvfrom-èª¿ç”¨"><a class="header" href="#è­‰æ“š-2-recvfrom-èª¿ç”¨">è­‰æ“š 2: recvfrom èª¿ç”¨</a></h4>
<pre><code class="language-c">// ç¬¬ 360 è¡Œ - flags = 0 è¡¨ç¤ºé˜»å¡æ¨¡å¼
nbytes = recvfrom(sockfd, buf, BUF_SIZE, 0,  // â† é˜»å¡å¼
                  (struct sockaddr*)&amp;src_addr, &amp;addrlen);
</code></pre>
<h4 id="è­‰æ“š-3-éŒ¯èª¤è™•ç†é‚è¼¯"><a class="header" href="#è­‰æ“š-3-éŒ¯èª¤è™•ç†é‚è¼¯">è­‰æ“š 3: éŒ¯èª¤è™•ç†é‚è¼¯</a></h4>
<pre><code class="language-c">if (nbytes &lt; 0) {
    perror("æ¥æ”¶éŒ¯èª¤");
    break;  // âŒ æ²’æœ‰è™•ç† EAGAINï¼Œè¡¨ç¤ºä¸æ˜¯ non-blocking
}
</code></pre>
<h3 id="é©—è­‰æ–¹æ³•"><a class="header" href="#é©—è­‰æ–¹æ³•">é©—è­‰æ–¹æ³•</a></h3>
<h4 id="æ–¹æ³•-1-ä½¿ç”¨-strace"><a class="header" href="#æ–¹æ³•-1-ä½¿ç”¨-strace">æ–¹æ³• 1: ä½¿ç”¨ strace</a></h4>
<pre><code class="language-bash">strace -e trace=recvfrom ./tse_receiver 2&gt;&amp;1 | head -20
</code></pre>
<p><strong>é æœŸè¼¸å‡º (Blocking):</strong></p>
<pre><code>recvfrom(3, &lt;æœªå®Œæˆ&gt;...  â† ç¨‹å¼åœ¨æ­¤ç­‰å¾…
recvfrom(3, "...", 5120, 0, ...) = 256  â† æ•¸æ“šåˆ°é”å¾Œè¿”å›
</code></pre>
<h4 id="æ–¹æ³•-2-æŸ¥çœ‹-socket-flags"><a class="header" href="#æ–¹æ³•-2-æŸ¥çœ‹-socket-flags">æ–¹æ³• 2: æŸ¥çœ‹ socket flags</a></h4>
<pre><code class="language-c">int flags = fcntl(sockfd, F_GETFL, 0);
if (flags &amp; O_NONBLOCK) {
    printf("Non-blocking\n");
} else {
    printf("Blocking\n");  // â† æœƒå°é€™å€‹
}
</code></pre>
<h4 id="æ–¹æ³•-3-è§€å¯Ÿ-cpu-ä½¿ç”¨ç‡"><a class="header" href="#æ–¹æ³•-3-è§€å¯Ÿ-cpu-ä½¿ç”¨ç‡">æ–¹æ³• 3: è§€å¯Ÿ CPU ä½¿ç”¨ç‡</a></h4>
<pre><code class="language-bash">top -p $(pgrep tse_receiver)
# Blocking: CPU ~0%
# Busy Polling: CPU ~100%
</code></pre>
<hr />
<h2 id="å„ªåŒ–æ–¹æ¡ˆç¸½è¦½"><a class="header" href="#å„ªåŒ–æ–¹æ¡ˆç¸½è¦½">å„ªåŒ–æ–¹æ¡ˆç¸½è¦½</a></h2>
<h3 id="æ–¹æ¡ˆå°æ¯”çŸ©é™£"><a class="header" href="#æ–¹æ¡ˆå°æ¯”çŸ©é™£">æ–¹æ¡ˆå°æ¯”çŸ©é™£</a></h3>
<div class="table-wrapper"><table><thead><tr><th>æ–¹æ¡ˆ</th><th>è¤‡é›œåº¦</th><th>å»¶é²æ”¹å–„</th><th>CPU æˆæœ¬</th><th>é©ç”¨å ´æ™¯</th><th>é–‹ç™¼æ™‚é–“</th></tr></thead><tbody>
<tr><td><strong>æ–¹æ¡ˆ 1: Blocking è¼•é‡å„ªåŒ–</strong></td><td>ä½</td><td>20-30%</td><td>ç„¡</td><td>ä¸€èˆ¬è¡Œæƒ…æ¥æ”¶</td><td>1 å°æ™‚</td></tr>
<tr><td><strong>æ–¹æ¡ˆ 2: Busy Polling</strong></td><td>ä¸­</td><td>70-80%</td><td>é«˜ (100%)</td><td>é«˜é »äº¤æ˜“</td><td>2 å°æ™‚</td></tr>
<tr><td><strong>æ–¹æ¡ˆ 3: å®Œæ•´ HFT</strong></td><td>ä¸­</td><td>80-90%</td><td>é«˜ (100%)</td><td>å°ˆæ¥­ HFT</td><td>3 å°æ™‚</td></tr>
<tr><td><strong>DPDK (ä¸æ¨è–¦)</strong></td><td>æ¥µé«˜</td><td>90-95%</td><td>æ¥µé«˜</td><td>è¶…é«˜é »</td><td>æ•¸é€±</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="æ–¹æ¡ˆ-1-blocking-io-è¼•é‡å„ªåŒ–"><a class="header" href="#æ–¹æ¡ˆ-1-blocking-io-è¼•é‡å„ªåŒ–">æ–¹æ¡ˆ 1: Blocking I/O è¼•é‡å„ªåŒ–</a></h2>
<p><strong>é©ç”¨å ´æ™¯:</strong> ä¸€èˆ¬è¡Œæƒ…æ¥æ”¶ã€é‡åŒ–äº¤æ˜“å›æ¸¬ã€æ•¸æ“šåˆ†æ</p>
<p><strong>å»¶é²æ”¹å–„:</strong> 20-30% (å¾ 3-7 Î¼s â†’ 2-5 Î¼s)</p>
<p><strong>CPU æˆæœ¬:</strong> å¹¾ä¹ç„¡ (~0%)</p>
<h3 id="å„ªåŒ–-1-å…§æ ¸æ™‚é–“æˆ³-so_timestampns"><a class="header" href="#å„ªåŒ–-1-å…§æ ¸æ™‚é–“æˆ³-so_timestampns">å„ªåŒ– 1: å…§æ ¸æ™‚é–“æˆ³ (SO_TIMESTAMPNS)</a></h3>
<p><strong>æ•ˆæœ:</strong> æ¶ˆé™¤ç”¨æˆ¶æ…‹æ™‚é–“æˆ³èª¤å·®ï¼Œç²¾åº¦é”åˆ°ç´ç§’ç´š</p>
<pre><code class="language-c">// ========================================
// åœ¨ socket å‰µå»ºå¾Œæ·»åŠ 
// ========================================

int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

// 1. å•Ÿç”¨å…§æ ¸æ™‚é–“æˆ³
int ts_flag = 1;
if (setsockopt(sockfd, SOL_SOCKET, SO_TIMESTAMPNS, &amp;ts_flag, sizeof(ts_flag)) &lt; 0) {
    perror("setsockopt SO_TIMESTAMPNS");
}

printf("âœ“ å•Ÿç”¨å…§æ ¸æ™‚é–“æˆ³ (SO_TIMESTAMPNS)\n");
</code></pre>
<pre><code class="language-c">// ========================================
// ä¿®æ”¹æ¥æ”¶é‚è¼¯ï¼Œä½¿ç”¨ recvmsg æ›¿ä»£ recvfrom
// ========================================

// æº–å‚™ recvmsg æ‰€éœ€çµæ§‹
struct msghdr msg;
struct iovec iov;
char ctrl_buf[CMSG_SPACE(sizeof(struct timespec))];
struct timespec kernel_ts;

memset(&amp;msg, 0, sizeof(msg));
iov.iov_base = buf;
iov.iov_len = BUF_SIZE;
msg.msg_iov = &amp;iov;
msg.msg_iovlen = 1;
msg.msg_control = ctrl_buf;
msg.msg_controllen = sizeof(ctrl_buf);
msg.msg_name = &amp;src_addr;
msg.msg_namelen = sizeof(src_addr);

// æ¥æ”¶æ•¸æ“š
nbytes = recvmsg(sockfd, &amp;msg, 0);

if (nbytes &lt; 0) {
    perror("recvmsg");
    break;
}

// è§£æå…§æ ¸æ™‚é–“æˆ³
int got_kernel_ts = 0;
for (struct cmsghdr *cmsg = CMSG_FIRSTHDR(&amp;msg); 
     cmsg != NULL; 
     cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) {
    
    if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; 
        cmsg-&gt;cmsg_type == SO_TIMESTAMPNS) {
        
        memcpy(&amp;kernel_ts, CMSG_DATA(cmsg), sizeof(struct timespec));
        got_kernel_ts = 1;
        break;
    }
}

// ä½¿ç”¨å…§æ ¸æ™‚é–“æˆ³è¨ˆç®—å»¶é²
long long local_timestamp_micros;
if (got_kernel_ts) {
    // ä½¿ç”¨å…§æ ¸æ™‚é–“æˆ³ï¼ˆæ›´ç²¾ç¢ºï¼‰
    local_timestamp_micros = (long long)kernel_ts.tv_sec * 1000000LL + 
                            kernel_ts.tv_nsec / 1000;
} else {
    // é™ç´šåˆ°ç”¨æˆ¶æ…‹æ™‚é–“æˆ³
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &amp;ts);
    local_timestamp_micros = (long long)ts.tv_sec * 1000000LL + 
                            ts.tv_nsec / 1000;
}

// å¾ŒçºŒè™•ç†...
</code></pre>
<h3 id="å„ªåŒ–-2-cpu-ç¶æ ¸-cpu-affinity"><a class="header" href="#å„ªåŒ–-2-cpu-ç¶æ ¸-cpu-affinity">å„ªåŒ– 2: CPU ç¶æ ¸ (CPU Affinity)</a></h3>
<p><strong>æ•ˆæœ:</strong> æ¸›å°‘ CPU é·ç§»ï¼Œé™ä½ cache missï¼Œå»¶é²é™ä½ 10-20%</p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;

// ========================================
// åœ¨ main å‡½æ•¸é–‹é ­æ·»åŠ 
// ========================================

/**
 * ç¶å®šåˆ°æŒ‡å®š CPU æ ¸å¿ƒ
 * å»ºè­°ï¼šä½¿ç”¨ CPU 2 æˆ–æ›´é«˜ï¼ˆé¿é–‹ CPU 0/1ï¼Œç³»çµ±å¸¸ç”¨ï¼‰
 */
void bind_to_cpu(int cpu_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&amp;cpuset);
    CPU_SET(cpu_id, &amp;cpuset);
    
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &amp;cpuset) != 0) {
        perror("pthread_setaffinity_np");
        fprintf(stderr, "è­¦å‘Š: CPU ç¶æ ¸å¤±æ•—\n");
        return;
    }
    
    printf("âœ“ ç·šç¨‹å·²ç¶å®šåˆ° CPU %d\n", cpu_id);
}

int main() {
    // ç¶å®šåˆ° CPU 2
    bind_to_cpu(2);
    
    // å…¶é¤˜ä»£ç¢¼...
}
</code></pre>
<h3 id="å„ªåŒ–-3-å¢å¤§æ¥æ”¶ç·©è¡å€"><a class="header" href="#å„ªåŒ–-3-å¢å¤§æ¥æ”¶ç·©è¡å€">å„ªåŒ– 3: å¢å¤§æ¥æ”¶ç·©è¡å€</a></h3>
<p><strong>æ•ˆæœ:</strong> é¿å…çªç™¼æµé‡å°è‡´çš„ä¸ŸåŒ…</p>
<pre><code class="language-c">// ========================================
// åœ¨ bind ä¹‹å‰æ·»åŠ 
// ========================================

// å¢å¤§æ¥æ”¶ç·©è¡å€åˆ° 16MB
int rcvbuf = 16 * 1024 * 1024;
if (setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf)) &lt; 0) {
    perror("setsockopt SO_RCVBUF");
}

// é©—è­‰å¯¦éš›è¨­ç½®çš„å¤§å°
socklen_t len = sizeof(rcvbuf);
getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, &amp;len);
printf("âœ“ æ¥æ”¶ç·©è¡å€: %d bytes (%.2f MB)\n", rcvbuf, rcvbuf / 1024.0 / 1024.0);
</code></pre>
<h3 id="å„ªåŒ–-4-å³æ™‚æ’ç¨‹å„ªå…ˆç´š-å¯é¸éœ€è¦-root"><a class="header" href="#å„ªåŒ–-4-å³æ™‚æ’ç¨‹å„ªå…ˆç´š-å¯é¸éœ€è¦-root">å„ªåŒ– 4: å³æ™‚æ’ç¨‹å„ªå…ˆç´š (å¯é¸ï¼Œéœ€è¦ root)</a></h3>
<p><strong>æ•ˆæœ:</strong> ç¢ºä¿æ¥æ”¶ç·šç¨‹å„ªå…ˆåŸ·è¡Œï¼Œæ¸›å°‘æ’ç¨‹å»¶é²</p>
<pre><code class="language-c">#include &lt;sched.h&gt;

// ========================================
// åœ¨ main å‡½æ•¸ä¸­ï¼Œbind_to_cpu ä¹‹å¾Œæ·»åŠ 
// ========================================

void set_realtime_priority(int priority) {
    struct sched_param param;
    param.sched_priority = priority;  // 1-99
    
    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) {
        perror("sched_setscheduler");
        fprintf(stderr, "æç¤º: ä½¿ç”¨ sudo åŸ·è¡Œä»¥å•Ÿç”¨å³æ™‚å„ªå…ˆç´š\n");
        return;
    }
    
    printf("âœ“ è¨­ç½® SCHED_FIFO å„ªå…ˆç´š: %d\n", priority);
}

int main() {
    bind_to_cpu(2);
    
    // è¨­ç½®å³æ™‚å„ªå…ˆç´šï¼ˆéœ€è¦ root æ¬Šé™ï¼‰
    if (geteuid() == 0) {
        set_realtime_priority(50);  // ä¸­ç­‰å„ªå…ˆç´š
    } else {
        printf("âš  é root ç”¨æˆ¶ï¼Œè·³éå³æ™‚å„ªå…ˆç´šè¨­ç½®\n");
    }
    
    // å…¶é¤˜ä»£ç¢¼...
}
</code></pre>
<h3 id="å®Œæ•´çš„æ–¹æ¡ˆ-1-å·®ç•°æª”"><a class="header" href="#å®Œæ•´çš„æ–¹æ¡ˆ-1-å·®ç•°æª”">å®Œæ•´çš„æ–¹æ¡ˆ 1 å·®ç•°æª”</a></h3>
<pre><code class="language-c">// ========================================
// æ–‡ä»¶é–‹é ­æ·»åŠ 
// ========================================
#define _GNU_SOURCE
#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;

// ========================================
// åœ¨å…¨å±€è®Šé‡å€åŸŸæ·»åŠ 
// ========================================
static struct timespec g_last_kernel_ts = {0};

// ========================================
// è¼”åŠ©å‡½æ•¸å€åŸŸæ·»åŠ 
// ========================================

void bind_to_cpu(int cpu_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&amp;cpuset);
    CPU_SET(cpu_id, &amp;cpuset);
    
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &amp;cpuset) != 0) {
        perror("pthread_setaffinity_np");
        return;
    }
    printf("âœ“ ç·šç¨‹å·²ç¶å®šåˆ° CPU %d\n", cpu_id);
}

void set_realtime_priority(int priority) {
    struct sched_param param;
    param.sched_priority = priority;
    
    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) {
        perror("sched_setscheduler");
        fprintf(stderr, "æç¤º: ä½¿ç”¨ sudo åŸ·è¡Œä»¥å•Ÿç”¨å³æ™‚å„ªå…ˆç´š\n");
        return;
    }
    printf("âœ“ è¨­ç½® SCHED_FIFO å„ªå…ˆç´š: %d\n", priority);
}

// ========================================
// main å‡½æ•¸ä¿®æ”¹
// ========================================

int main() {
    int sockfd;
    struct sockaddr_in local_addr, src_addr;
    struct ip_mreq group;
    unsigned char buf[BUF_SIZE];
    ssize_t nbytes;
    
    printf("TSE Receiver - è¼•é‡å„ªåŒ–ç‰ˆ\n\n");
    
    // å„ªåŒ– 1: CPU ç¶æ ¸
    bind_to_cpu(2);
    
    // å„ªåŒ– 2: å³æ™‚å„ªå…ˆç´šï¼ˆå¯é¸ï¼‰
    if (geteuid() == 0) {
        set_realtime_priority(50);
    }
    
    // å‰µå»º socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        return 1;
    }
    
    // å„ªåŒ– 3: å•Ÿç”¨å…§æ ¸æ™‚é–“æˆ³
    int ts_flag = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_TIMESTAMPNS, &amp;ts_flag, sizeof(ts_flag)) == 0) {
        printf("âœ“ å•Ÿç”¨ SO_TIMESTAMPNS\n");
    }
    
    // å„ªåŒ– 4: å¢å¤§æ¥æ”¶ç·©è¡å€
    int rcvbuf = 16 * 1024 * 1024;
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf)) == 0) {
        socklen_t len = sizeof(rcvbuf);
        getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, &amp;len);
        printf("âœ“ æ¥æ”¶ç·©è¡å€: %.2f MB\n", rcvbuf / 1024.0 / 1024.0);
    }
    
    // SO_REUSEADDR
    int reuse = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));
    
    // Bind
    memset(&amp;local_addr, 0, sizeof(local_addr));
    local_addr.sin_family = AF_INET;
    local_addr.sin_addr.s_addr = INADDR_ANY;
    local_addr.sin_port = htons(MCAST_PORT_TSE);
    
    if (bind(sockfd, (struct sockaddr*)&amp;local_addr, sizeof(local_addr))) {
        perror("bind");
        close(sockfd);
        return 1;
    }
    
    // åŠ å…¥ Multicast
    group.imr_multiaddr.s_addr = inet_addr(MCAST_GRP_TSE);
    group.imr_interface.s_addr = inet_addr(LOCAL_INTERFACE_IP);
    if (group.imr_interface.s_addr == INADDR_NONE) {
        group.imr_interface.s_addr = INADDR_ANY;
    }
    
    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group)) &lt; 0) {
        perror("IP_ADD_MEMBERSHIP");
        close(sockfd);
        return 1;
    }
    
    printf("âœ“ ç›£è½ %s:%d\n\n", MCAST_GRP_TSE, MCAST_PORT_TSE);
    
    // ========================================
    // æ¥æ”¶å¾ªç’°ï¼ˆä½¿ç”¨ recvmsg ç²å–å…§æ ¸æ™‚é–“æˆ³ï¼‰
    // ========================================
    
    struct msghdr msg;
    struct iovec iov;
    char ctrl_buf[CMSG_SPACE(sizeof(struct timespec))];
    
    while (1) {
        // æº–å‚™ recvmsg çµæ§‹
        memset(&amp;msg, 0, sizeof(msg));
        iov.iov_base = buf;
        iov.iov_len = BUF_SIZE;
        msg.msg_iov = &amp;iov;
        msg.msg_iovlen = 1;
        msg.msg_control = ctrl_buf;
        msg.msg_controllen = sizeof(ctrl_buf);
        msg.msg_name = &amp;src_addr;
        msg.msg_namelen = sizeof(src_addr);
        
        // æ¥æ”¶æ•¸æ“š
        nbytes = recvmsg(sockfd, &amp;msg, 0);
        
        if (nbytes &lt; 0) {
            perror("recvmsg");
            break;
        }
        
        // è§£æå…§æ ¸æ™‚é–“æˆ³
        struct timespec kernel_ts;
        int got_kernel_ts = 0;
        
        for (struct cmsghdr *cmsg = CMSG_FIRSTHDR(&amp;msg); 
             cmsg != NULL; 
             cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) {
            
            if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; 
                cmsg-&gt;cmsg_type == SO_TIMESTAMPNS) {
                
                memcpy(&amp;kernel_ts, CMSG_DATA(cmsg), sizeof(struct timespec));
                got_kernel_ts = 1;
                break;
            }
        }
        
        // è¨ˆç®—æ™‚é–“æˆ³
        long long local_timestamp_micros;
        if (got_kernel_ts) {
            local_timestamp_micros = (long long)kernel_ts.tv_sec * 1000000LL + 
                                    kernel_ts.tv_nsec / 1000;
        } else {
            struct timespec ts;
            clock_gettime(CLOCK_REALTIME, &amp;ts);
            local_timestamp_micros = (long long)ts.tv_sec * 1000000LL + 
                                    ts.tv_nsec / 1000;
        }
        
        // å°åŒ…è™•ç†é‚è¼¯ï¼ˆèˆ‡åŸç‰ˆç›¸åŒï¼‰
        int msgStart = 0;
        while (msgStart &lt; nbytes) {
            if (buf[msgStart] == ESC_CHAR) {
                int msgLen = GetBCD(buf, msgStart + 1, 2);
                
                if (msgStart + msgLen &gt; nbytes) {
                    break;
                }
                
                if (buf[msgStart + msgLen - 2] == 0x0D &amp;&amp;
                    buf[msgStart + msgLen - 1] == 0x0A) {
                    
                    unsigned char checkSum = 0;
                    for (int i = msgStart + 1; i &lt; msgStart + msgLen - 3; i++) {
                        checkSum ^= buf[i];
                    }
                    
                    if (buf[msgStart + msgLen - 3] == checkSum) {
                        int msgKind = GetBCD(buf, msgStart + 4, 1);
                        
                        if (msgKind == 6) {
                            TseQuote quote;
                            quote.Market = MARKET_TSE;
                            ParseQuoteBody(&amp;quote, buf, msgStart + HEADER_LEN, 
                                         local_timestamp_micros);
                            PrintQuote(&amp;quote);
                        }
                    }
                    
                    msgStart += msgLen;
                } else {
                    msgStart++;
                }
            } else {
                msgStart++;
            }
        }
    }
    
    close(sockfd);
    return 0;
}
</code></pre>
<h3 id="ç·¨è­¯èˆ‡åŸ·è¡Œ"><a class="header" href="#ç·¨è­¯èˆ‡åŸ·è¡Œ">ç·¨è­¯èˆ‡åŸ·è¡Œ</a></h3>
<pre><code class="language-bash"># ç·¨è­¯
gcc -o tse_receiver_opt1 tse_receiver_opt1.c -pthread

# åŸ·è¡Œï¼ˆç„¡ rootï¼‰
./tse_receiver_opt1

# åŸ·è¡Œï¼ˆæœ‰ rootï¼Œå•Ÿç”¨å³æ™‚å„ªå…ˆç´šï¼‰
sudo ./tse_receiver_opt1
</code></pre>
<hr />
<h2 id="æ–¹æ¡ˆ-2-non-blocking--busy-polling-hft-ç´š"><a class="header" href="#æ–¹æ¡ˆ-2-non-blocking--busy-polling-hft-ç´š">æ–¹æ¡ˆ 2: Non-blocking + Busy Polling (HFT ç´š)</a></h2>
<p><strong>é©ç”¨å ´æ™¯:</strong> é«˜é »äº¤æ˜“ã€åšå¸‚å•†ã€å¥—åˆ©ç­–ç•¥</p>
<p><strong>å»¶é²æ”¹å–„:</strong> 70-80% (å¾ 3-7 Î¼s â†’ 0.5-2 Î¼s)</p>
<p><strong>CPU æˆæœ¬:</strong> é«˜ (100% å–®æ ¸)</p>
<h3 id="æ ¸å¿ƒæ”¹å‹•"><a class="header" href="#æ ¸å¿ƒæ”¹å‹•">æ ¸å¿ƒæ”¹å‹•</a></h3>
<ol>
<li><strong>è¨­ç½®éé˜»å¡ socket</strong></li>
<li><strong>æŒçºŒè¼ªè©¢ (busy polling)</strong></li>
<li><strong>CPU ç¶æ ¸</strong></li>
<li><strong>å³æ™‚æ’ç¨‹</strong></li>
</ol>
<h3 id="é—œéµä»£ç¢¼"><a class="header" href="#é—œéµä»£ç¢¼">é—œéµä»£ç¢¼</a></h3>
<pre><code class="language-c">// ========================================
// è¨­ç½®éé˜»å¡ socket
// ========================================

int make_socket_nonblocking(int sockfd) {
    int flags = fcntl(sockfd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        return -1;
    }
    
    if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        return -1;
    }
    
    printf("âœ“ Socket è¨­ç½®ç‚º Non-blocking\n");
    return 0;
}

// åœ¨å‰µå»º socket å¾Œèª¿ç”¨
make_socket_nonblocking(sockfd);
</code></pre>
<pre><code class="language-c">// ========================================
// Busy Polling æ¥æ”¶å¾ªç’°
// ========================================

unsigned long long poll_count = 0;
unsigned long long packet_count = 0;

while (1) {
    struct sockaddr_in src_addr;
    socklen_t addrlen = sizeof(src_addr);
    
    // æŒçºŒè¼ªè©¢ï¼ˆä¸ç¡çœ ï¼‰
    nbytes = recvfrom(sockfd, buf, BUF_SIZE, 0,
                     (struct sockaddr*)&amp;src_addr, &amp;addrlen);
    
    poll_count++;
    
    if (nbytes &gt; 0) {
        // ç«‹å³è¨˜éŒ„æ™‚é–“æˆ³
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &amp;ts);
        long long local_timestamp_micros = 
            (long long)ts.tv_sec * 1000000LL + ts.tv_nsec / 1000;
        
        packet_count++;
        
        // è™•ç†å°åŒ…...
        
        // æ¯ 100 è¬æ¬¡è¼ªè©¢å ±å‘Šçµ±è¨ˆ
        if (poll_count % 1000000 == 0) {
            double hit_rate = (packet_count * 100.0) / poll_count;
            printf("[çµ±è¨ˆ] è¼ªè©¢: %llu, æ”¶åŒ…: %llu, å‘½ä¸­ç‡: %.4f%%\n",
                   poll_count, packet_count, hit_rate);
        }
        
    } else if (nbytes &lt; 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            // ç„¡æ•¸æ“šï¼Œç¹¼çºŒè¼ªè©¢ï¼ˆé€™æ˜¯æ­£å¸¸çš„ï¼‰
            continue;
        } else {
            // çœŸæ­£çš„éŒ¯èª¤
            perror("recvfrom");
            break;
        }
    }
}
</code></pre>
<h3 id="é¡å¤–å„ªåŒ–"><a class="header" href="#é¡å¤–å„ªåŒ–">é¡å¤–å„ªåŒ–</a></h3>
<pre><code class="language-c">// ========================================
// SO_BUSY_POLL - å…§æ ¸ç´š busy polling
// ========================================

// è®“å…§æ ¸åœ¨è¼ªè©¢ç¶²å¡æ™‚ä¸ç«‹å³ç¡çœ ï¼ˆLinux 3.11+ï¼‰
int busy_poll = 50;  // å¾®ç§’
if (setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL, &amp;busy_poll, sizeof(busy_poll)) == 0) {
    printf("âœ“ å•Ÿç”¨ SO_BUSY_POLL (50 Î¼s)\n");
}
</code></pre>
<hr />
<h2 id="æ–¹æ¡ˆ-3-å®Œæ•´-hft-ç‰ˆæœ¬"><a class="header" href="#æ–¹æ¡ˆ-3-å®Œæ•´-hft-ç‰ˆæœ¬">æ–¹æ¡ˆ 3: å®Œæ•´ HFT ç‰ˆæœ¬</a></h2>
<p><strong>å®Œæ•´çš„ç”Ÿç”¢ç´š HFT æ¥æ”¶å™¨ï¼ŒåŒ…å«æ‰€æœ‰å„ªåŒ–</strong></p>
<h3 id="å®Œæ•´ä»£ç¢¼"><a class="header" href="#å®Œæ•´ä»£ç¢¼">å®Œæ•´ä»£ç¢¼</a></h3>
<pre><code class="language-c">/*
 * TSE/OTC Quote Receiver - High Frequency Trading Edition
 * ç‰¹æ€§: Non-blocking + Busy Polling + CPU ç¶æ ¸ + å³æ™‚å„ªå…ˆç´š
 * ç·¨è­¯: gcc -o tse_receiver_hft tse_receiver_hft.c -pthread -O3
 * åŸ·è¡Œ: sudo ./tse_receiver_hft
 */

#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;time.h&gt;

// --- è¨­å®šåƒæ•¸ ---
#define MCAST_GRP_TSE "224.0.200.200"
#define MCAST_PORT_TSE 20000
#define LOCAL_INTERFACE_IP "10.102.22.111"
#define BUF_SIZE 5120
#define ESC_CHAR 0x1B
#define HEADER_LEN 10

// HFT å„ªåŒ–åƒæ•¸
#define HFT_CPU_CORE 2              // ç¶å®š CPU æ ¸å¿ƒ
#define HFT_PRIORITY 80             // å³æ™‚å„ªå…ˆç´š (1-99)
#define ENABLE_BUSY_POLLING 1       // å•Ÿç”¨ busy polling
#define ENABLE_CPU_AFFINITY 1       // å•Ÿç”¨ CPU ç¶æ ¸
#define ENABLE_REALTIME_SCHED 1     // å•Ÿç”¨å³æ™‚æ’ç¨‹
#define STATS_INTERVAL 1000000      // çµ±è¨ˆå ±å‘Šé–“éš”

// --- è³‡æ–™çµæ§‹ ---
typedef enum {
    MARKET_TSE = 1,
    MARKET_OTC = 2
} MarketEnum;

typedef struct {
    MarketEnum Market;
    char ProdID[7];
    char OrderBookChangeTime[24];
    char LocalReceiveTime[24];
    long long RawLatencyMicros;
    long long CalibratedLatencyMicros;
    int Price;
    int Volume;
    int TotalVolume;
    int BuyPrice1;
    int BuyVolume1;
    int SellPrice1;
    int SellVolume1;
    int DealCount;
    int BuyCount;
    int SellCount;
} TseQuote;

// --- å…¨å±€è®Šé‡ ---
static long long g_clock_offset = 0;
static int g_is_calibrated = 0;
static unsigned long long g_total_packets = 0;
static unsigned long long g_poll_count = 0;
static unsigned long long g_error_count = 0;

// --- HFT å„ªåŒ–å‡½æ•¸ ---

/**
 * ç¶å®šåˆ°æŒ‡å®š CPU æ ¸å¿ƒ
 */
int bind_to_cpu(int cpu_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&amp;cpuset);
    CPU_SET(cpu_id, &amp;cpuset);
    
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &amp;cpuset) != 0) {
        perror("pthread_setaffinity_np");
        return -1;
    }
    
    printf("âœ“ ç·šç¨‹å·²ç¶å®šåˆ° CPU %d\n", cpu_id);
    return 0;
}

/**
 * è¨­ç½®å³æ™‚æ’ç¨‹å„ªå…ˆç´š
 */
int set_realtime_priority(int priority) {
    struct sched_param param;
    param.sched_priority = priority;
    
    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) {
        perror("sched_setscheduler");
        fprintf(stderr, "æç¤º: ä½¿ç”¨ sudo åŸ·è¡Œç¨‹å¼ä»¥å•Ÿç”¨å³æ™‚å„ªå…ˆç´š\n");
        return -1;
    }
    
    printf("âœ“ è¨­ç½® SCHED_FIFO å„ªå…ˆç´š: %d\n", priority);
    return 0;
}

/**
 * è¨­ç½® socket ç‚ºéé˜»å¡æ¨¡å¼
 */
int make_socket_nonblocking(int sockfd) {
    int flags = fcntl(sockfd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        return -1;
    }
    
    if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        return -1;
    }
    
    printf("âœ“ Socket å·²è¨­ç½®ç‚º Non-blocking æ¨¡å¼\n");
    return 0;
}

/**
 * HFT ç´šåˆ¥çš„ socket å„ªåŒ–
 */
void optimize_socket_for_hft(int sockfd) {
    int result;
    
    // 1. å¢å¤§æ¥æ”¶ç·©è¡å€ (16MB)
    int rcvbuf = 16 * 1024 * 1024;
    result = setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf));
    if (result == 0) {
        socklen_t len = sizeof(rcvbuf);
        getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, &amp;len);
        printf("âœ“ æ¥æ”¶ç·©è¡å€: %.2f MB\n", rcvbuf / 1024.0 / 1024.0);
    }
    
    // 2. å•Ÿç”¨å…§æ ¸æ™‚é–“æˆ³ (ç´ç§’ç²¾åº¦)
    int ts_flag = 1;
    result = setsockopt(sockfd, SOL_SOCKET, SO_TIMESTAMPNS, &amp;ts_flag, sizeof(ts_flag));
    if (result == 0) {
        printf("âœ“ å•Ÿç”¨ SO_TIMESTAMPNS (å…§æ ¸æ™‚é–“æˆ³)\n");
    }
    
    // 3. å•Ÿç”¨ busy poll (Linux 3.11+)
    int busy_poll = 50; // å¾®ç§’
    result = setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL, &amp;busy_poll, sizeof(busy_poll));
    if (result == 0) {
        printf("âœ“ å•Ÿç”¨ SO_BUSY_POLL (50 Î¼s)\n");
    }
    
    // 4. è¨­ç½®ä½å»¶é²æ¨¡å¼
    int low_latency = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_PRIORITY, &amp;low_latency, sizeof(low_latency));
}

// --- è¼”åŠ©å‡½å¼ (èˆ‡åŸç‰ˆç›¸åŒ) ---

int GetBCD(unsigned char* msg, int start, int len) {
    int result = 0;
    for (int i = start; i &lt; start + len; i++) {
        result *= 100;
        unsigned char bt = msg[i];
        result += (bt &gt;&gt; 4) * 10 + (bt &amp; 0x0F);
    }
    return result;
}

long long ParseTimeToMicros(const char* time_str) {
    int hh, mm, ss, us;
    sscanf(time_str, "%d:%d:%d.%d", &amp;hh, &amp;mm, &amp;ss, &amp;us);
    return (long long)hh * 3600000000LL + (long long)mm * 60000000LL +
           (long long)ss * 1000000LL + (long long)us;
}

long long CalculateLatency(long long local_micros, const char* orderbook_time_str) {
    time_t seconds = local_micros / 1000000LL;
    struct tm* tm_info = localtime(&amp;seconds);
    long long local_day_micros = (long long)tm_info-&gt;tm_hour * 3600000000LL +
                                 (long long)tm_info-&gt;tm_min * 60000000LL +
                                 (long long)tm_info-&gt;tm_sec * 1000000LL +
                                 (local_micros % 1000000LL);
    
    long long orderbook_micros = ParseTimeToMicros(orderbook_time_str);
    return local_day_micros - orderbook_micros;
}

void ParseQuoteBody(TseQuote* quote, unsigned char* buf, int start, long long local_timestamp_micros) {
    // è‚¡ç¥¨ä»£è™Ÿ
    memcpy(quote-&gt;ProdID, &amp;buf[start], 6);
    quote-&gt;ProdID[6] = '\0';
    
    // æ›å–®ç°¿è®Šå‹•æ™‚é–“
    int hh = GetBCD(buf, start + 6, 1);
    int mm = GetBCD(buf, start + 7, 1);
    int ss = GetBCD(buf, start + 8, 1);
    int us = GetBCD(buf, start + 9, 3);
    snprintf(quote-&gt;OrderBookChangeTime, sizeof(quote-&gt;OrderBookChangeTime),
             "%02d:%02d:%02d.%06d", hh, mm, ss, us);
    
    // æœ¬åœ°æ¥æ”¶æ™‚é–“
    time_t seconds = local_timestamp_micros / 1000000LL;
    long long micros_part = local_timestamp_micros % 1000000LL;
    struct tm* tm_info = localtime(&amp;seconds);
    snprintf(quote-&gt;LocalReceiveTime, sizeof(quote-&gt;LocalReceiveTime),
             "%02d:%02d:%02d.%06lld",
             tm_info-&gt;tm_hour, tm_info-&gt;tm_min, tm_info-&gt;tm_sec, micros_part);
    
    // è¨ˆç®—å»¶é²
    quote-&gt;RawLatencyMicros = CalculateLatency(local_timestamp_micros, quote-&gt;OrderBookChangeTime);
    
    // æ™‚é˜æ ¡æº–
    if (!g_is_calibrated) {
        g_clock_offset = quote-&gt;RawLatencyMicros;
        g_is_calibrated = 1;
        printf("\n=== æ™‚é˜æ ¡æº–å®Œæˆ ===\n");
        printf("æª¢æ¸¬åˆ°æ™‚é˜åç§»: %lld Î¼s (%.3f ms)\n",
               g_clock_offset, g_clock_offset / 1000.0);
        printf("=====================\n\n");
    }
    
    quote-&gt;CalibratedLatencyMicros = quote-&gt;RawLatencyMicros - g_clock_offset;
    
    // PriceNote
    unsigned char priceNote = buf[start + 12];
    quote-&gt;DealCount = (priceNote &amp; 0x80) &gt;&gt; 7;
    quote-&gt;BuyCount = (priceNote &amp; 0x70) &gt;&gt; 4;
    quote-&gt;SellCount = (priceNote &amp; 0x0E) &gt;&gt; 1;
    
    // ç¸½é‡
    quote-&gt;TotalVolume = GetBCD(buf, start + 15, 4);
    
    // æˆäº¤åƒ¹
    if (quote-&gt;DealCount &gt; 0) {
        int base = start + 19;
        quote-&gt;Price = GetBCD(buf, base, 5);
        quote-&gt;Volume = GetBCD(buf, base + 5, 4);
    } else {
        quote-&gt;Price = 0;
        quote-&gt;Volume = 0;
    }
    
    // è²·é€²åƒ¹
    if (quote-&gt;BuyCount &gt; 0) {
        int i = quote-&gt;DealCount;
        int base = start + 19 + (i * 9);
        quote-&gt;BuyPrice1 = GetBCD(buf, base, 5);
        quote-&gt;BuyVolume1 = GetBCD(buf, base + 5, 4);
    } else {
        quote-&gt;BuyPrice1 = 0;
        quote-&gt;BuyVolume1 = 0;
    }
    
    // è³£å‡ºåƒ¹
    if (quote-&gt;SellCount &gt; 0) {
        int i = quote-&gt;DealCount + quote-&gt;BuyCount;
        int base = start + 19 + (i * 9);
        quote-&gt;SellPrice1 = GetBCD(buf, base, 5);
        quote-&gt;SellVolume1 = GetBCD(buf, base + 5, 4);
    } else {
        quote-&gt;SellPrice1 = 0;
        quote-&gt;SellVolume1 = 0;
    }
}

void PrintQuote(TseQuote* q) {
    printf("========================================\n");
    printf("è‚¡ç¥¨: %s | ", q-&gt;ProdID);
    printf("å»¶é²: %lld Î¼s (%.3f ms)\n", 
           q-&gt;CalibratedLatencyMicros, q-&gt;CalibratedLatencyMicros / 1000.0);
    printf("æ›å–®ç°¿æ™‚é–“: %s\n", q-&gt;OrderBookChangeTime);
    printf("æ¥æ”¶æ™‚é–“  : %s\n", q-&gt;LocalReceiveTime);
    
    if (q-&gt;BuyCount &gt; 0 &amp;&amp; q-&gt;SellCount &gt; 0) {
        printf("è²·: %.2f (%d) | è³£: %.2f (%d)\n",
               q-&gt;BuyPrice1 / 100.0, q-&gt;BuyVolume1,
               q-&gt;SellPrice1 / 100.0, q-&gt;SellVolume1);
    }
    
    double hit_rate = (g_poll_count &gt; 0) ? (g_total_packets * 100.0 / g_poll_count) : 0;
    printf("çµ±è¨ˆ: æ”¶åŒ… %llu | è¼ªè©¢ %llu | å‘½ä¸­ç‡ %.4f%%\n",
           g_total_packets, g_poll_count, hit_rate);
    printf("========================================\n");
}

// --- ä¸»ç¨‹å¼ ---

int main() {
    int sockfd;
    struct sockaddr_in local_addr;
    struct ip_mreq group;
    unsigned char buf[BUF_SIZE];
    ssize_t nbytes;
    
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  TSE Receiver - HFT Edition                â•‘\n");
    printf("â•‘  Non-blocking I/O + Busy Polling           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\n");
    
    // æª¢æŸ¥æ¬Šé™
    if (geteuid() != 0) {
        printf("âš  è­¦å‘Š: é root ç”¨æˆ¶ï¼Œéƒ¨åˆ†å„ªåŒ–å°‡ç„¡æ³•å•Ÿç”¨\n");
        printf("  å»ºè­°: sudo ./tse_receiver_hft\n\n");
    }
    
    // HFT å„ªåŒ– 1: CPU ç¶æ ¸
    if (ENABLE_CPU_AFFINITY) {
        bind_to_cpu(HFT_CPU_CORE);
    }
    
    // HFT å„ªåŒ– 2: å³æ™‚å„ªå…ˆç´š
    if (ENABLE_REALTIME_SCHED &amp;&amp; geteuid() == 0) {
        set_realtime_priority(HFT_PRIORITY);
    }
    
    // å»ºç«‹ Socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        return 1;
    }
    
    // è¨­ç½® SO_REUSEADDR
    int reuse = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));
    
    // HFT å„ªåŒ– 3: Socket å„ªåŒ–
    optimize_socket_for_hft(sockfd);
    
    // HFT å„ªåŒ– 4: éé˜»å¡æ¨¡å¼
    if (ENABLE_BUSY_POLLING) {
        make_socket_nonblocking(sockfd);
    }
    
    // Bind
    memset(&amp;local_addr, 0, sizeof(local_addr));
    local_addr.sin_family = AF_INET;
    local_addr.sin_addr.s_addr = INADDR_ANY;
    local_addr.sin_port = htons(MCAST_PORT_TSE);
    
    if (bind(sockfd, (struct sockaddr*)&amp;local_addr, sizeof(local_addr))) {
        perror("bind");
        close(sockfd);
        return 1;
    }
    
    // åŠ å…¥ Multicast ç¾¤çµ„
    group.imr_multiaddr.s_addr = inet_addr(MCAST_GRP_TSE);
    group.imr_interface.s_addr = inet_addr(LOCAL_INTERFACE_IP);
    
    if (group.imr_interface.s_addr == INADDR_NONE) {
        group.imr_interface.s_addr = INADDR_ANY;
    }
    
    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group)) &lt; 0) {
        perror("IP_ADD_MEMBERSHIP");
        close(sockfd);
        return 1;
    }
    
    printf("âœ“ å·²åŠ å…¥ Multicast ç¾¤çµ„ %s:%d\n", MCAST_GRP_TSE, MCAST_PORT_TSE);
    printf("\n");
    printf("ğŸš€ Busy Polling å·²å•Ÿå‹• (CPU å°‡é”åˆ° 100%%)\n");
    printf("\n");
    
    // Busy Polling æ¥æ”¶å¾ªç’°
    while (1) {
        struct sockaddr_in src_addr;
        socklen_t addrlen = sizeof(src_addr);
        
        // æŒçºŒè¼ªè©¢
        nbytes = recvfrom(sockfd, buf, BUF_SIZE, 0,
                         (struct sockaddr*)&amp;src_addr, &amp;addrlen);
        
        g_poll_count++;
        
        if (nbytes &gt; 0) {
            // ç«‹å³è¨˜éŒ„æ™‚é–“æˆ³
            struct timespec ts;
            clock_gettime(CLOCK_REALTIME, &amp;ts);
            long long local_timestamp_micros = 
                (long long)ts.tv_sec * 1000000LL + ts.tv_nsec / 1000;
            
            g_total_packets++;
            
            // è™•ç†å°åŒ…
            int msgStart = 0;
            while (msgStart &lt; nbytes) {
                if (buf[msgStart] == ESC_CHAR) {
                    int msgLen = GetBCD(buf, msgStart + 1, 2);
                    
                    if (msgStart + msgLen &gt; nbytes) {
                        break;
                    }
                    
                    if (buf[msgStart + msgLen - 2] == 0x0D &amp;&amp;
                        buf[msgStart + msgLen - 1] == 0x0A) {
                        
                        unsigned char checkSum = 0;
                        for (int i = msgStart + 1; i &lt; msgStart + msgLen - 3; i++) {
                            checkSum ^= buf[i];
                        }
                        
                        if (buf[msgStart + msgLen - 3] == checkSum) {
                            int msgKind = GetBCD(buf, msgStart + 4, 1);
                            
                            if (msgKind == 6) {
                                TseQuote quote;
                                quote.Market = MARKET_TSE;
                                ParseQuoteBody(&amp;quote, buf, msgStart + HEADER_LEN, 
                                             local_timestamp_micros);
                                PrintQuote(&amp;quote);
                            }
                        } else {
                            g_error_count++;
                        }
                        
                        msgStart += msgLen;
                    } else {
                        msgStart++;
                    }
                } else {
                    msgStart++;
                }
            }
            
        } else if (nbytes &lt; 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // ç„¡æ•¸æ“šï¼Œç¹¼çºŒè¼ªè©¢
                continue;
            } else {
                perror("recvfrom");
                g_error_count++;
                break;
            }
        }
    }
    
    close(sockfd);
    return 0;
}
</code></pre>
<h3 id="ç·¨è­¯èˆ‡åŸ·è¡Œ-1"><a class="header" href="#ç·¨è­¯èˆ‡åŸ·è¡Œ-1">ç·¨è­¯èˆ‡åŸ·è¡Œ</a></h3>
<pre><code class="language-bash"># ç·¨è­¯ï¼ˆé–‹å•Ÿ O3 å„ªåŒ–ï¼‰
gcc -o tse_receiver_hft tse_receiver_hft.c -pthread -O3

# åŸ·è¡Œï¼ˆéœ€è¦ rootï¼‰
sudo ./tse_receiver_hft

# æˆ–ä½¿ç”¨ capabilitiesï¼ˆæ¨è–¦ï¼‰
sudo setcap cap_sys_nice=eip ./tse_receiver_hft
./tse_receiver_hft
</code></pre>
<hr />
<h2 id="æ€§èƒ½å°æ¯”èˆ‡é¸æ“‡å»ºè­°"><a class="header" href="#æ€§èƒ½å°æ¯”èˆ‡é¸æ“‡å»ºè­°">æ€§èƒ½å°æ¯”èˆ‡é¸æ“‡å»ºè­°</a></h2>
<h3 id="å»¶é²å°æ¯”è¡¨"><a class="header" href="#å»¶é²å°æ¯”è¡¨">å»¶é²å°æ¯”è¡¨</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ç‰ˆæœ¬</th><th>I/O æ¨¡å¼</th><th>P50 å»¶é²</th><th>P99 å»¶é²</th><th>CPU</th><th>é©ç”¨å ´æ™¯</th></tr></thead><tbody>
<tr><td><strong>åŸç‰ˆ</strong></td><td>Blocking</td><td>3-7 Î¼s</td><td>10-50 Î¼s</td><td>~0%</td><td>ä¸€èˆ¬è¡Œæƒ…</td></tr>
<tr><td><strong>æ–¹æ¡ˆ 1</strong></td><td>Blocking + å„ªåŒ–</td><td>2-5 Î¼s</td><td>8-30 Î¼s</td><td>~0%</td><td>é‡åŒ–äº¤æ˜“</td></tr>
<tr><td><strong>æ–¹æ¡ˆ 2</strong></td><td>Busy Polling</td><td>0.8-2 Î¼s</td><td>3-8 Î¼s</td><td>100%</td><td>HFT</td></tr>
<tr><td><strong>æ–¹æ¡ˆ 3</strong></td><td>å®Œæ•´ HFT</td><td>0.5-1.5 Î¼s</td><td>2-6 Î¼s</td><td>100%</td><td>å°ˆæ¥­ HFT</td></tr>
</tbody></table>
</div>
<h3 id="é¸æ“‡æŒ‡å—"><a class="header" href="#é¸æ“‡æŒ‡å—">é¸æ“‡æŒ‡å—</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä½ çš„å»¶é²è¦æ±‚æ˜¯å¤šå°‘ï¼Ÿ                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€ &lt; 100 Î¼s (æ¯«ç§’ç´š) â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨åŸç‰ˆ Blocking
         â”‚
         â”œâ”€ &lt; 10 Î¼s (åå¾®ç§’ç´š) â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨æ–¹æ¡ˆ 1 (è¼•é‡å„ªåŒ–)
         â”‚
         â”œâ”€ &lt; 3 Î¼s (å¾®ç§’ç´š) â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨æ–¹æ¡ˆ 2/3 (HFT)
         â”‚
         â””â”€ &lt; 1 Î¼s (ç´ç§’ç´š) â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ è€ƒæ…® DPDK/FPGA

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä½ æœ‰å¤šå°‘ CPU è³‡æºï¼Ÿ                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€ CPU æœ‰é™ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨æ–¹æ¡ˆ 1
         â”‚
         â”œâ”€ æœ‰å°ˆç”¨æ ¸å¿ƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨æ–¹æ¡ˆ 2/3
         â”‚
         â””â”€ å°ˆç”¨ä¼ºæœå™¨ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä½¿ç”¨æ–¹æ¡ˆ 3 + ç³»çµ±èª¿å„ª
</code></pre>
<hr />
<h2 id="ç³»çµ±ç´šå„ªåŒ–é…ç½®"><a class="header" href="#ç³»çµ±ç´šå„ªåŒ–é…ç½®">ç³»çµ±ç´šå„ªåŒ–é…ç½®</a></h2>
<h3 id="1-éš”é›¢-cpu-æ ¸å¿ƒ"><a class="header" href="#1-éš”é›¢-cpu-æ ¸å¿ƒ">1. éš”é›¢ CPU æ ¸å¿ƒ</a></h3>
<p><strong>ç›®çš„:</strong> é¿å…ç³»çµ±ä»»å‹™å¹²æ“¾ HFT ç¨‹å¼</p>
<pre><code class="language-bash"># ç·¨è¼¯ /etc/default/grub
sudo nano /etc/default/grub

# æ·»åŠ ä»¥ä¸‹åƒæ•¸åˆ° GRUB_CMDLINE_LINUX
isolcpus=2,3 nohz_full=2,3 rcu_nocbs=2,3

# æ›´æ–° grub
sudo update-grub
sudo reboot
</code></pre>
<p><strong>åƒæ•¸èªªæ˜:</strong></p>
<ul>
<li><code>isolcpus=2,3</code>: éš”é›¢ CPU 2 å’Œ 3ï¼Œä¸æ¥å—ä¸€èˆ¬æ’ç¨‹</li>
<li><code>nohz_full=2,3</code>: æ¸›å°‘æ™‚é˜ä¸­æ–·</li>
<li><code>rcu_nocbs=2,3</code>: å°‡ RCU å›èª¿ç§»åˆ°å…¶ä»– CPU</li>
</ul>
<h3 id="2-ç¦ç”¨-cpu-é »ç‡èª¿æ•´"><a class="header" href="#2-ç¦ç”¨-cpu-é »ç‡èª¿æ•´">2. ç¦ç”¨ CPU é »ç‡èª¿æ•´</a></h3>
<p><strong>ç›®çš„:</strong> ä¿æŒ CPU å…¨é€Ÿé‹è¡Œï¼Œé¿å…é »ç‡åˆ‡æ›å»¶é²</p>
<pre><code class="language-bash"># è¨­ç½®ç‚º performance æ¨¡å¼
echo performance | sudo tee /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
echo performance | sudo tee /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor

# é©—è­‰
cat /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
</code></pre>
<h3 id="3-ç¶²å¡ä¸­æ–·ç¶å®š"><a class="header" href="#3-ç¶²å¡ä¸­æ–·ç¶å®š">3. ç¶²å¡ä¸­æ–·ç¶å®š</a></h3>
<p><strong>ç›®çš„:</strong> å°‡ç¶²å¡ä¸­æ–·ç¶å®šåˆ°ééš”é›¢çš„ CPU</p>
<pre><code class="language-bash"># æŸ¥çœ‹ç¶²å¡ä¸­æ–·è™Ÿ
cat /proc/interrupts | grep eth0

# å‡è¨­ä¸­æ–·è™Ÿæ˜¯ 25ï¼Œç¶å®šåˆ° CPU 0
echo 1 &gt; /proc/irq/25/smp_affinity

# é©—è­‰
cat /proc/irq/25/smp_affinity_list
</code></pre>
<h3 id="4-é—œé–‰ä¸å¿…è¦çš„æœå‹™"><a class="header" href="#4-é—œé–‰ä¸å¿…è¦çš„æœå‹™">4. é—œé–‰ä¸å¿…è¦çš„æœå‹™</a></h3>
<pre><code class="language-bash"># åœç”¨ IRQ balanceï¼ˆé¿å…ä¸­æ–·é·ç§»ï¼‰
sudo systemctl stop irqbalance
sudo systemctl disable irqbalance

# åœç”¨ç¯€èƒ½åŠŸèƒ½
sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target
</code></pre>
<h3 id="5-ç¶²å¡å„ªåŒ–"><a class="header" href="#5-ç¶²å¡å„ªåŒ–">5. ç¶²å¡å„ªåŒ–</a></h3>
<pre><code class="language-bash"># å¢å¤§ç¶²å¡æ¥æ”¶ç·©è¡å€
sudo ethtool -G eth0 rx 4096

# å•Ÿç”¨ç¶²å¡å¤šéšŠåˆ—
sudo ethtool -L eth0 combined 4

# é—œé–‰ç¶²å¡ç¯€èƒ½
sudo ethtool -s eth0 speed 10000 duplex full autoneg off

# å•Ÿç”¨ RSS (Receive Side Scaling)
sudo ethtool -X eth0 equal 4
</code></pre>
<h3 id="6-è¨˜æ†¶é«”é–å®š"><a class="header" href="#6-è¨˜æ†¶é«”é–å®š">6. è¨˜æ†¶é«”é–å®š</a></h3>
<pre><code class="language-bash"># å…è¨±ç¨‹å¼é–å®šè¨˜æ†¶é«”ï¼ˆé¿å… swapï¼‰
sudo sh -c 'echo "* soft memlock unlimited" &gt;&gt; /etc/security/limits.conf'
sudo sh -c 'echo "* hard memlock unlimited" &gt;&gt; /etc/security/limits.conf'
</code></pre>
<p>åœ¨ç¨‹å¼ä¸­æ·»åŠ ï¼š</p>
<pre><code class="language-c">#include &lt;sys/mman.h&gt;

int main() {
    // é–å®šæ‰€æœ‰è¨˜æ†¶é«”
    if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
        perror("mlockall");
    }
    
    // å…¶é¤˜ä»£ç¢¼...
}
</code></pre>
<h3 id="7-å·¨é -huge-pages"><a class="header" href="#7-å·¨é -huge-pages">7. å·¨é  (Huge Pages)</a></h3>
<pre><code class="language-bash"># é…ç½® 2MB å·¨é 
echo 1024 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

# é©—è­‰
cat /proc/meminfo | grep Huge
</code></pre>
<hr />
<h2 id="ç›£æ§èˆ‡èª¿è©¦å·¥å…·"><a class="header" href="#ç›£æ§èˆ‡èª¿è©¦å·¥å…·">ç›£æ§èˆ‡èª¿è©¦å·¥å…·</a></h2>
<h3 id="1-å¯¦æ™‚ç›£æ§-cpu-ä½¿ç”¨ç‡"><a class="header" href="#1-å¯¦æ™‚ç›£æ§-cpu-ä½¿ç”¨ç‡">1. å¯¦æ™‚ç›£æ§ CPU ä½¿ç”¨ç‡</a></h3>
<pre><code class="language-bash"># å®‰è£ htop
sudo apt-get install htop

# ç›£æ§ç‰¹å®šç¨‹å¼
htop -p $(pgrep tse_receiver)
</code></pre>
<h3 id="2-æŸ¥çœ‹ç¨‹å¼å„ªå…ˆç´š"><a class="header" href="#2-æŸ¥çœ‹ç¨‹å¼å„ªå…ˆç´š">2. æŸ¥çœ‹ç¨‹å¼å„ªå…ˆç´š</a></h3>
<pre><code class="language-bash"># æŸ¥çœ‹æ’ç¨‹ç­–ç•¥å’Œå„ªå…ˆç´š
chrt -p $(pgrep tse_receiver)

# è¼¸å‡ºç¯„ä¾‹ï¼š
# pid 1234's current scheduling policy: SCHED_FIFO
# pid 1234's current scheduling priority: 80
</code></pre>
<h3 id="3-æŸ¥çœ‹-cpu-ç¶å®š"><a class="header" href="#3-æŸ¥çœ‹-cpu-ç¶å®š">3. æŸ¥çœ‹ CPU ç¶å®š</a></h3>
<pre><code class="language-bash"># æŸ¥çœ‹ç¨‹å¼ç¶å®šçš„ CPU
taskset -cp $(pgrep tse_receiver)

# è¼¸å‡ºç¯„ä¾‹ï¼š
# pid 1234's current affinity list: 2
</code></pre>
<h3 id="4-ç¶²è·¯çµ±è¨ˆ"><a class="header" href="#4-ç¶²è·¯çµ±è¨ˆ">4. ç¶²è·¯çµ±è¨ˆ</a></h3>
<pre><code class="language-bash"># æŸ¥çœ‹ç¶²å¡çµ±è¨ˆ
netstat -i

# æŸ¥çœ‹ UDP çµ±è¨ˆ
netstat -su

# å¯¦æ™‚ç›£æ§å°åŒ…
sudo tcpdump -i eth0 -n dst 224.0.200.200 and port 20000
</code></pre>
<h3 id="5-å»¶é²æ¸¬é‡å·¥å…·"><a class="header" href="#5-å»¶é²æ¸¬é‡å·¥å…·">5. å»¶é²æ¸¬é‡å·¥å…·</a></h3>
<pre><code class="language-bash"># å®‰è£ perf
sudo apt-get install linux-tools-generic

# æ¸¬é‡ç¨‹å¼çš„å»¶é²åˆ†ä½ˆ
sudo perf stat -e cycles,instructions,cache-misses ./tse_receiver_hft

# è¨˜éŒ„ CPU äº‹ä»¶
sudo perf record -g ./tse_receiver_hft
sudo perf report
</code></pre>
<h3 id="6-ç³»çµ±èª¿ç”¨è¿½è¹¤"><a class="header" href="#6-ç³»çµ±èª¿ç”¨è¿½è¹¤">6. ç³»çµ±èª¿ç”¨è¿½è¹¤</a></h3>
<pre><code class="language-bash"># è¿½è¹¤ç³»çµ±èª¿ç”¨
strace -c ./tse_receiver_hft

# åªè¿½è¹¤ç¶²è·¯ç›¸é—œèª¿ç”¨
strace -e trace=network ./tse_receiver_hft

# æ¸¬é‡æ¯å€‹ç³»çµ±èª¿ç”¨çš„æ™‚é–“
strace -T -e trace=recvfrom ./tse_receiver_hft
</code></pre>
<h3 id="7-è‡ªè¨‚ç›£æ§è…³æœ¬"><a class="header" href="#7-è‡ªè¨‚ç›£æ§è…³æœ¬">7. è‡ªè¨‚ç›£æ§è…³æœ¬</a></h3>
<pre><code class="language-bash">#!/bin/bash
# monitor_hft.sh - ç›£æ§ HFT ç¨‹å¼ç‹€æ…‹

PID=$(pgrep tse_receiver)

while true; do
    clear
    echo "=== TSE Receiver HFT ç›£æ§ ==="
    echo "æ™‚é–“: $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""
    
    # CPU ä½¿ç”¨ç‡
    CPU=$(ps -p $PID -o %cpu= 2&gt;/dev/null)
    echo "CPU ä½¿ç”¨ç‡: ${CPU}%"
    
    # è¨˜æ†¶é«”ä½¿ç”¨
    MEM=$(ps -p $PID -o rss= 2&gt;/dev/null)
    echo "è¨˜æ†¶é«”: $((MEM / 1024)) MB"
    
    # ç¶å®šçš„ CPU
    AFFINITY=$(taskset -cp $PID 2&gt;/dev/null | awk '{print $NF}')
    echo "CPU ç¶å®š: $AFFINITY"
    
    # æ’ç¨‹å„ªå…ˆç´š
    SCHED=$(chrt -p $PID 2&gt;/dev/null | grep policy | awk '{print $NF}')
    PRIO=$(chrt -p $PID 2&gt;/dev/null | grep priority | awk '{print $NF}')
    echo "æ’ç¨‹: $SCHED, å„ªå…ˆç´š: $PRIO"
    
    # ç¶²è·¯çµ±è¨ˆ
    echo ""
    echo "=== ç¶²è·¯çµ±è¨ˆ ==="
    netstat -su | grep -E "packets received|packet receive errors"
    
    sleep 5
done
</code></pre>
<p>ä½¿ç”¨æ–¹å¼ï¼š</p>
<pre><code class="language-bash">chmod +x monitor_hft.sh
./monitor_hft.sh
</code></pre>
<hr />
<h2 id="é™„éŒ„å®Œæ•´å„ªåŒ–-checklist"><a class="header" href="#é™„éŒ„å®Œæ•´å„ªåŒ–-checklist">é™„éŒ„ï¼šå®Œæ•´å„ªåŒ– Checklist</a></h2>
<h3 id="è»Ÿé«”å±¤é¢"><a class="header" href="#è»Ÿé«”å±¤é¢">è»Ÿé«”å±¤é¢</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
è¨­ç½® socket ç‚º non-blocking</li>
<li><input disabled="" type="checkbox"/>
å•Ÿç”¨ SO_TIMESTAMPNS (å…§æ ¸æ™‚é–“æˆ³)</li>
<li><input disabled="" type="checkbox"/>
å•Ÿç”¨ SO_BUSY_POLL</li>
<li><input disabled="" type="checkbox"/>
å¢å¤§æ¥æ”¶ç·©è¡å€ (SO_RCVBUF)</li>
<li><input disabled="" type="checkbox"/>
CPU ç¶æ ¸ (pthread_setaffinity_np)</li>
<li><input disabled="" type="checkbox"/>
å³æ™‚æ’ç¨‹å„ªå…ˆç´š (SCHED_FIFO)</li>
<li><input disabled="" type="checkbox"/>
è¨˜æ†¶é«”é–å®š (mlockall)</li>
<li><input disabled="" type="checkbox"/>
ä½¿ç”¨ç·¨è­¯å™¨å„ªåŒ– (-O3)</li>
</ul>
<h3 id="ç³»çµ±å±¤é¢"><a class="header" href="#ç³»çµ±å±¤é¢">ç³»çµ±å±¤é¢</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
éš”é›¢ CPU æ ¸å¿ƒ (isolcpus)</li>
<li><input disabled="" type="checkbox"/>
ç¦ç”¨ CPU é »ç‡èª¿æ•´</li>
<li><input disabled="" type="checkbox"/>
ç¶²å¡ä¸­æ–·ç¶å®š</li>
<li><input disabled="" type="checkbox"/>
åœç”¨ IRQ balance</li>
<li><input disabled="" type="checkbox"/>
é—œé–‰ç¯€èƒ½åŠŸèƒ½</li>
<li><input disabled="" type="checkbox"/>
é…ç½®å·¨é </li>
<li><input disabled="" type="checkbox"/>
å¢å¤§ç¶²å¡ç·©è¡å€</li>
<li><input disabled="" type="checkbox"/>
å•Ÿç”¨ç¶²å¡å¤šéšŠåˆ—</li>
</ul>
<h3 id="ç¶²è·¯å±¤é¢"><a class="header" href="#ç¶²è·¯å±¤é¢">ç¶²è·¯å±¤é¢</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
ä½¿ç”¨å°ˆç”¨ç¶²è·¯ä»‹é¢</li>
<li><input disabled="" type="checkbox"/>
é…ç½® VLAN éš”é›¢</li>
<li><input disabled="" type="checkbox"/>
å•Ÿç”¨ç¶²å¡ RSS</li>
<li><input disabled="" type="checkbox"/>
é—œé–‰ç¶²å¡ç¯€èƒ½</li>
<li><input disabled="" type="checkbox"/>
å¢å¤§ socket ç·©è¡å€é™åˆ¶</li>
<li><input disabled="" type="checkbox"/>
èª¿æ•´ net.core.rmem_max</li>
</ul>
<h3 id="ç›£æ§å±¤é¢"><a class="header" href="#ç›£æ§å±¤é¢">ç›£æ§å±¤é¢</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
éƒ¨ç½² CPU ç›£æ§</li>
<li><input disabled="" type="checkbox"/>
éƒ¨ç½²è¨˜æ†¶é«”ç›£æ§</li>
<li><input disabled="" type="checkbox"/>
éƒ¨ç½²ç¶²è·¯ç›£æ§</li>
<li><input disabled="" type="checkbox"/>
éƒ¨ç½²å»¶é²ç›£æ§</li>
<li><input disabled="" type="checkbox"/>
è¨­ç½®å‘Šè­¦æ©Ÿåˆ¶</li>
</ul>
<hr />
<h2 id="ç¸½çµ"><a class="header" href="#ç¸½çµ">ç¸½çµ</a></h2>
<h3 id="å¿«é€Ÿæ±ºç­–æ¨¹"><a class="header" href="#å¿«é€Ÿæ±ºç­–æ¨¹">å¿«é€Ÿæ±ºç­–æ¨¹</a></h3>
<pre><code>éœ€è¦å„ªåŒ– TSE Receiver å»¶é²ï¼Ÿ
â”‚
â”œâ”€ å»¶é²è¦æ±‚ &lt; 10 Î¼sï¼Ÿ
â”‚  â”‚
â”‚  â”œâ”€ å¦ â†’ ä½¿ç”¨æ–¹æ¡ˆ 1ï¼ˆBlocking + è¼•é‡å„ªåŒ–ï¼‰
â”‚  â”‚       - æœ€ç°¡å–®
â”‚  â”‚       - CPU æ•ˆç‡é«˜
â”‚  â”‚       - é©åˆ 90% å ´æ™¯
â”‚  â”‚
â”‚  â””â”€ æ˜¯ â†’ ç¹¼çºŒå¾€ä¸‹
â”‚
â”œâ”€ æœ‰å°ˆç”¨ CPU æ ¸å¿ƒï¼Ÿ
â”‚  â”‚
â”‚  â”œâ”€ å¦ â†’ é‚„æ˜¯ç”¨æ–¹æ¡ˆ 1
â”‚  â”‚       - Busy polling ä¸é©åˆå…±äº«ç’°å¢ƒ
â”‚  â”‚
â”‚  â””â”€ æ˜¯ â†’ ä½¿ç”¨æ–¹æ¡ˆ 2/3ï¼ˆBusy Pollingï¼‰
â”‚           - å»¶é²é™ä½ 70-80%
â”‚           - CPU 100% ä½†å€¼å¾—
â”‚
â””â”€ éœ€è¦ &lt; 1 Î¼sï¼Ÿ
   â”‚
   â””â”€ æ˜¯ â†’ è€ƒæ…® DPDK/FPGA
           - è¤‡é›œåº¦æ¥µé«˜
           - éœ€è¦å°ˆæ¥­åœ˜éšŠ
           - æˆæœ¬é«˜æ˜‚
</code></pre>
<h3 id="æœ€ä½³å¯¦è¸å»ºè­°"><a class="header" href="#æœ€ä½³å¯¦è¸å»ºè­°">æœ€ä½³å¯¦è¸å»ºè­°</a></h3>
<ol>
<li>
<p><strong>å…ˆæ¸¬é‡ï¼Œå†å„ªåŒ–</strong></p>
<ul>
<li>ä½¿ç”¨ <code>perf</code> æˆ– <code>strace</code> ç¢ºèªç“¶é ¸</li>
<li>è¨˜éŒ„å„ªåŒ–å‰å¾Œçš„å»¶é²æ•¸æ“š</li>
</ul>
</li>
<li>
<p><strong>å¾ªåºæ¼¸é€²</strong></p>
<ul>
<li>å…ˆå¯¦æ–½æ–¹æ¡ˆ 1ï¼ˆæˆæœ¬ä½ï¼Œæ•ˆæœå¥½ï¼‰</li>
<li>ç¢ºèªä¸å¤ å†å‡ç´šåˆ°æ–¹æ¡ˆ 2/3</li>
</ul>
</li>
<li>
<p><strong>é—œæ³¨æ•´é«”ç³»çµ±</strong></p>
<ul>
<li>å„ªåŒ–ç¨‹å¼åªæ˜¯ä¸€éƒ¨åˆ†</li>
<li>ç³»çµ±é…ç½®ã€ç¶²è·¯ã€ç¡¬é«”éƒ½å¾ˆé‡è¦</li>
</ul>
</li>
<li>
<p><strong>æŒçºŒç›£æ§</strong></p>
<ul>
<li>éƒ¨ç½²ç›£æ§ç³»çµ±</li>
<li>è¨­ç½®å»¶é²å‘Šè­¦</li>
<li>å®šæœŸæª¢æŸ¥æ€§èƒ½é€€åŒ–</li>
</ul>
</li>
</ol>
<hr />
<h2 id="ç·¨è­¯æŒ‡ä»¤ç¸½çµ"><a class="header" href="#ç·¨è­¯æŒ‡ä»¤ç¸½çµ">ç·¨è­¯æŒ‡ä»¤ç¸½çµ</a></h2>
<pre><code class="language-bash"># æ–¹æ¡ˆ 1: Blocking + è¼•é‡å„ªåŒ–
gcc -o tse_receiver_opt1 tse_receiver_opt1.c -pthread -O2

# æ–¹æ¡ˆ 2/3: HFT ç‰ˆæœ¬
gcc -o tse_receiver_hft tse_receiver_hft.c -pthread -O3

# åŸ·è¡Œï¼ˆæ–¹æ¡ˆ 1ï¼Œç„¡éœ€ rootï¼‰
./tse_receiver_opt1

# åŸ·è¡Œï¼ˆæ–¹æ¡ˆ 2/3ï¼Œéœ€è¦ rootï¼‰
sudo ./tse_receiver_hft

# æˆ–ä½¿ç”¨ capabilitiesï¼ˆæ¨è–¦ï¼‰
sudo setcap cap_sys_nice=eip ./tse_receiver_hft
./tse_receiver_hft
</code></pre>
<hr />
<p><strong>æ–‡ä»¶ç‰ˆæœ¬:</strong> 1.0<br />
<strong>æœ€å¾Œæ›´æ–°:</strong> 2026-01-09<br />
<strong>ä½œè€…:</strong> Claude (Anthropic)</p>
<p><strong>é©ç”¨æ–¼:</strong> Linux (Ubuntu/Debian/RHEL/CentOS)<br />
<strong>æ¸¬è©¦ç’°å¢ƒ:</strong> Ubuntu 20.04 LTS, Linux kernel 5.15+</p>
<hr />
<h2 id="è¯çµ¡èˆ‡æ”¯æ´"><a class="header" href="#è¯çµ¡èˆ‡æ”¯æ´">è¯çµ¡èˆ‡æ”¯æ´</a></h2>
<p>å¦‚æœ‰å•é¡Œæˆ–éœ€è¦é€²ä¸€æ­¥å”åŠ©ï¼Œè«‹ï¼š</p>
<ol>
<li>æª¢æŸ¥ç¨‹å¼è¼¸å‡ºçš„éŒ¯èª¤è¨Šæ¯</li>
<li>ä½¿ç”¨ <code>strace</code> å’Œ <code>perf</code> å·¥å…·è¨ºæ–·</li>
<li>æŸ¥çœ‹ç³»çµ±æ—¥èªŒ (<code>dmesg</code>, <code>/var/log/syslog</code>)</li>
<li>ç¢ºèªç¶²è·¯é€£ç·šå’Œ multicast é…ç½®</li>
</ol>
<p>ç¥ä½ å„ªåŒ–é †åˆ©ï¼ğŸš€</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../hft/02-system/low_latency_trading_system_design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../hft/02-system/TSE_RECEIVER_OPTIMIZATION_ANALYSIS.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../hft/02-system/low_latency_trading_system_design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../hft/02-system/TSE_RECEIVER_OPTIMIZATION_ANALYSIS.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>



    </div>
    </body>
</html>
