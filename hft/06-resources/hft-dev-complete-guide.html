<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>HFT 開發完整指南 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="高頻交易開發完整指南"><a class="header" href="#高頻交易開發完整指南">高頻交易開發完整指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE">開發環境設置</a></li>
<li><a href="#%E7%B7%A8%E8%AD%AF%E7%AD%96%E7%95%A5">編譯策略</a></li>
<li><a href="#%E6%95%88%E8%83%BD%E6%B8%AC%E9%87%8F%E8%88%87%E5%84%AA%E5%8C%96">效能測量與優化</a></li>
<li><a href="#%E7%B3%BB%E7%B5%B1%E5%B1%A4%E7%B4%9A%E5%84%AA%E5%8C%96">系統層級優化</a></li>
<li><a href="#%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5">記憶體管理策略</a></li>
<li><a href="#%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">網路程式設計</a></li>
<li><a href="#%E4%B8%A6%E8%A1%8C%E8%88%87%E7%84%A1%E9%8E%96%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">並行與無鎖程式設計</a></li>
<li><a href="#%E9%99%A4%E9%8C%AF%E8%88%87%E5%95%8F%E9%A1%8C%E6%8E%92%E6%9F%A5">除錯與問題排查</a></li>
<li><a href="#%E5%B8%B8%E8%A6%8B%E9%99%B7%E9%98%B1%E8%88%87%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90">常見陷阱與最佳實踐</a></li>
<li><a href="#%E7%94%9F%E7%94%A2%E7%92%B0%E5%A2%83%E9%83%A8%E7%BD%B2">生產環境部署</a></li>
</ol>
<hr />
<h2 id="開發環境設置"><a class="header" href="#開發環境設置">開發環境設置</a></h2>
<h3 id="問題場景"><a class="header" href="#問題場景">問題場景</a></h3>
<ul>
<li>交易主機只有內網，無法直接連網</li>
<li>需要通過 SCP 傳輸套件和編譯文件</li>
<li>需要測試不同版本編譯器和工具</li>
</ul>
<h3 id="推薦方案"><a class="header" href="#推薦方案">推薦方案</a></h3>
<h4 id="1-本地-docker-容器開發最推薦"><a class="header" href="#1-本地-docker-容器開發最推薦">1. 本地 Docker 容器開發（最推薦）</a></h4>
<p>在本地機器安裝與機房<strong>完全相同版本</strong>的 Linux：</p>
<pre><code class="language-bash"># 拉取與機房相同的系統
docker pull ubuntu:24.04
# 或
docker pull centos:7

# 啟動開發容器
docker run -it --rm -v $(pwd):/workspace ubuntu:24.04 bash
</code></pre>
<p><strong>優點：</strong></p>
<ul>
<li>環境一致性高，避免相容性問題</li>
<li>可以快速測試不同編譯器版本（GCC 9/10/11, Clang 等）</li>
<li>編譯好的 binary 可直接 scp 到機房使用</li>
<li>本地測試方便，減少往返機房次數</li>
</ul>
<h4 id="2-dockerfile-範例"><a class="header" href="#2-dockerfile-範例">2. Dockerfile 範例</a></h4>
<pre><code class="language-dockerfile">FROM ubuntu:24.04

RUN apt-get update &amp;&amp; apt-get install -y \
    build-essential \
    cmake \
    linux-tools-generic \
    valgrind \
    gdb \
    git \
    perf \
    strace \
    htop

# 設置與機房相同的編譯環境
ENV CC=gcc-11
ENV CXX=g++-11

WORKDIR /workspace
</code></pre>
<h4 id="3-開發流程"><a class="header" href="#3-開發流程">3. 開發流程</a></h4>
<pre><code class="language-bash"># 階段 1: 本地 Docker 功能測試
docker run -it --rm -v $(pwd):/workspace ubuntu:24.04
./trader --test-mode

# 階段 2: 本地效能基準測試
perf stat ./trader --benchmark

# 階段 3: 機房環境測試（真實數據）
scp trader user@trading-host:/opt/trading/
ssh user@trading-host './trader --production'
</code></pre>
<hr />
<h2 id="編譯策略"><a class="header" href="#編譯策略">編譯策略</a></h2>
<h3 id="static-vs-dynamic-linking"><a class="header" href="#static-vs-dynamic-linking">Static vs Dynamic Linking</a></h3>
<h4 id="動態連結推薦"><a class="header" href="#動態連結推薦">動態連結（推薦）</a></h4>
<pre><code class="language-bash"># 在本地 Docker 中使用與機房相同的環境
docker run -it ubuntu:24.04 bash

# 正常編譯（動態連結）
g++ -O3 -march=skylake your_code.cpp -o trader

# 檢查依賴
ldd trader
</code></pre>
<p><strong>前提條件：</strong></p>
<ol>
<li>相同的 Linux 發行版和版本</li>
<li>相同的共享庫版本（glibc, libstdc++）</li>
</ol>
<p><strong>檢查依賴輸出範例：</strong></p>
<pre><code>linux-vdso.so.1
libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6
libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6
</code></pre>
<h4 id="靜態連結備選"><a class="header" href="#靜態連結備選">靜態連結（備選）</a></h4>
<pre><code class="language-bash"># 完全靜態編譯
g++ -O3 -static -march=native your_code.cpp -o trader

# 部分靜態連結
g++ -O3 your_code.cpp -o trader \
    -Wl,-Bstatic -lboost_system \
    -Wl,-Bdynamic -lpthread
</code></pre>
<p><strong>靜態編譯的效能影響：</strong></p>
<ul>
<li>效能差異通常 &lt; 5%</li>
<li>Binary 檔案較大</li>
<li>可移植性高</li>
</ul>
<h3 id="動態連結-vs-靜態連結比較"><a class="header" href="#動態連結-vs-靜態連結比較">動態連結 vs 靜態連結比較</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>動態連結</th><th>靜態連結</th></tr></thead><tbody>
<tr><td><strong>效能</strong></td><td>略好（可使用系統優化的庫）</td><td>略差但可接受</td></tr>
<tr><td><strong>檔案大小</strong></td><td>小（幾 MB）</td><td>大（可能 10+ MB）</td></tr>
<tr><td><strong>可移植性</strong></td><td>需環境一致</td><td>高</td></tr>
<tr><td><strong>適合高頻交易</strong></td><td>✅ 是</td><td>可接受</td></tr>
</tbody></table>
</div>
<h3 id="系統優化庫說明"><a class="header" href="#系統優化庫說明">系統優化庫說明</a></h3>
<p>系統安裝的共享庫（如 glibc）通常包含：</p>
<ul>
<li><strong>SIMD 指令優化</strong>：SSE, AVX, AVX2, AVX-512</li>
<li><strong>運行時 CPU 檢測</strong>：自動選擇最佳實現</li>
</ul>
<pre><code class="language-c">// glibc 動態版本的 memcpy 示例
void *memcpy(void *dest, const void *src, size_t n) {
    // 運行時 CPU 檢測
    if (cpu_has_avx512()) return memcpy_avx512(dest, src, n);
    if (cpu_has_avx2())   return memcpy_avx2(dest, src, n);
    return memcpy_generic(dest, src, n);
}
</code></pre>
<h3 id="針對封包處理的編譯選項"><a class="header" href="#針對封包處理的編譯選項">針對封包處理的編譯選項</a></h3>
<p>封包重組和位元計算適合 <strong>Static linking</strong>：</p>
<pre><code class="language-bash"># 推薦的編譯選項
g++ -O3 \
    -march=native \        # 使用機房 CPU 的所有指令集
    -flto \                # Link Time Optimization
    -static \              # 靜態連結
    -ffast-math \          # 如果有浮點運算
    -funroll-loops \       # 展開循環
    -finline-functions \   # 激進內聯
    packet_parser.cpp -o parser
</code></pre>
<p><strong>為什麼 Static 適合封包處理：</strong></p>
<ol>
<li>位元運算不依賴系統庫優化</li>
<li>減少函數調用開銷</li>
<li>更好的 CPU Cache 利用</li>
</ol>
<h3 id="額外的編譯優化選項"><a class="header" href="#額外的編譯優化選項">額外的編譯優化選項</a></h3>
<pre><code class="language-bash"># Profile-Guided Optimization (PGO)
# 步驟 1: 編譯帶 instrumentation 的版本
g++ -O3 -fprofile-generate your_code.cpp -o trader

# 步驟 2: 運行典型 workload 收集 profile
./trader --benchmark

# 步驟 3: 使用 profile 重新編譯
g++ -O3 -fprofile-use your_code.cpp -o trader

# Link Time Optimization
g++ -O3 -flto file1.cpp file2.cpp -o trader

# 激進優化（需謹慎測試）
g++ -O3 -Ofast -march=native -mtune=native \
    -ffast-math -funroll-loops -finline-functions \
    your_code.cpp -o trader
</code></pre>
<hr />
<h2 id="效能測量與優化"><a class="header" href="#效能測量與優化">效能測量與優化</a></h2>
<h3 id="1-延遲測量工具"><a class="header" href="#1-延遲測量工具">1. 延遲測量工具</a></h3>
<h4 id="rdtsc-指令測量-cpu-cycles"><a class="header" href="#rdtsc-指令測量-cpu-cycles">RDTSC 指令測量 CPU cycles</a></h4>
<pre><code class="language-cpp">#include &lt;x86intrin.h&gt;

inline uint64_t rdtsc() {
    unsigned int lo, hi;
    __asm__ volatile("rdtsc" : "=a"(lo), "=d"(hi));
    return ((uint64_t)hi &lt;&lt; 32) | lo;
}

// 測量封包處理延遲
uint64_t start = rdtsc();
process_packet(data);
uint64_t end = rdtsc();
uint64_t cycles = end - start;

// 轉換成納秒（假設 3GHz CPU）
double ns = cycles / 3.0;
</code></pre>
<h4 id="clock_gettime高精度"><a class="header" href="#clock_gettime高精度">clock_gettime（高精度）</a></h4>
<pre><code class="language-cpp">#include &lt;time.h&gt;

struct timespec start, end;
clock_gettime(CLOCK_MONOTONIC, &amp;start);
process_packet(data);
clock_gettime(CLOCK_MONOTONIC, &amp;end);

long ns = (end.tv_sec - start.tv_sec) * 1e9 + 
          (end.tv_nsec - start.tv_nsec);
</code></pre>
<h4 id="更準確的-rdtscp"><a class="header" href="#更準確的-rdtscp">更準確的 RDTSCP</a></h4>
<pre><code class="language-cpp">// RDTSCP 包含 memory barrier，更準確
inline uint64_t rdtscp() {
    unsigned int lo, hi;
    __asm__ volatile("rdtscp" : "=a"(lo), "=d"(hi) :: "rcx");
    return ((uint64_t)hi &lt;&lt; 32) | lo;
}

// 完整的測量範例
inline uint64_t measure_latency() {
    // Warm up
    __asm__ volatile("" ::: "memory");
    
    uint64_t start = rdtscp();
    process_critical_path();
    uint64_t end = rdtscp();
    
    return end - start;
}
</code></pre>
<h3 id="2-profiling-工具"><a class="header" href="#2-profiling-工具">2. Profiling 工具</a></h3>
<h4 id="perf必學"><a class="header" href="#perf必學">perf（必學）</a></h4>
<pre><code class="language-bash"># CPU cycles 和 instructions
perf stat -e cycles,instructions,cache-references,cache-misses \
    ./trader

# 找出熱點函數
perf record -g ./trader
perf report

# 查看 CPU cache 行為
perf stat -e L1-dcache-loads,L1-dcache-load-misses \
    -e LLC-loads,LLC-load-misses ./trader

# 查看分支預測
perf stat -e branches,branch-misses ./trader

# 記錄特定 CPU 上的事件
perf record -C 2 -g ./trader

# 查看 context switches
perf stat -e context-switches,cpu-migrations ./trader
</code></pre>
<h4 id="valgrind--cachegrindcache-分析"><a class="header" href="#valgrind--cachegrindcache-分析">valgrind + cachegrind（Cache 分析）</a></h4>
<pre><code class="language-bash">valgrind --tool=cachegrind ./trader
cg_annotate cachegrind.out.xxx

# 查看特定函數的 cache 行為
cg_annotate cachegrind.out.xxx --auto=yes | grep function_name
</code></pre>
<h4 id="intel-vtune商業工具"><a class="header" href="#intel-vtune商業工具">Intel VTune（商業工具）</a></h4>
<pre><code class="language-bash"># Hotspot 分析
vtune -collect hotspots -result-dir vtune_results ./trader

# Microarchitecture 分析
vtune -collect uarch-exploration -result-dir vtune_results ./trader
</code></pre>
<h3 id="3-延遲分佈統計"><a class="header" href="#3-延遲分佈統計">3. 延遲分佈統計</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

class LatencyTracker {
    std::vector&lt;uint64_t&gt; latencies;
    uint64_t min_latency = UINT64_MAX;
    uint64_t max_latency = 0;
    uint64_t sum = 0;
    
public:
    void record(uint64_t ns) {
        latencies.push_back(ns);
        min_latency = std::min(min_latency, ns);
        max_latency = std::max(max_latency, ns);
        sum += ns;
    }
    
    void report() {
        std::sort(latencies.begin(), latencies.end());
        size_t n = latencies.size();
        
        printf("Count: %zu\n", n);
        printf("Min:   %lu ns\n", min_latency);
        printf("Mean:  %lu ns\n", sum / n);
        printf("P50:   %lu ns\n", latencies[n/2]);
        printf("P90:   %lu ns\n", latencies[n*90/100]);
        printf("P95:   %lu ns\n", latencies[n*95/100]);
        printf("P99:   %lu ns\n", latencies[n*99/100]);
        printf("P99.9: %lu ns\n", latencies[n*999/1000]);
        printf("Max:   %lu ns\n", max_latency);
    }
    
    // 找出異常值
    void report_outliers(uint64_t threshold) {
        printf("\nOutliers (&gt; %lu ns):\n", threshold);
        for (size_t i = 0; i &lt; latencies.size(); i++) {
            if (latencies[i] &gt; threshold) {
                printf("  Sample %zu: %lu ns\n", i, latencies[i]);
            }
        }
    }
};
</code></pre>
<h3 id="4-建立效能基準"><a class="header" href="#4-建立效能基準">4. 建立效能基準</a></h3>
<pre><code class="language-cpp">// benchmark.cpp
#include &lt;benchmark/benchmark.h&gt;

static void BM_PacketParsing(benchmark::State&amp; state) {
    uint8_t packet[1024] = {/* test data */};
    
    for (auto _ : state) {
        parse_packet(packet);
        benchmark::DoNotOptimize(packet);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_PacketParsing);

// 測試不同參數
static void BM_OrderBook_Insert(benchmark::State&amp; state) {
    OrderBook book;
    int num_orders = state.range(0);
    
    for (auto _ : state) {
        for (int i = 0; i &lt; num_orders; i++) {
            book.insert(Order{i, 100 + i, 1000});
        }
        benchmark::DoNotOptimize(book);
    }
}
BENCHMARK(BM_OrderBook_Insert)-&gt;Range(8, 8&lt;&lt;10);

BENCHMARK_MAIN();
</code></pre>
<p>編譯並運行：</p>
<pre><code class="language-bash">g++ -O3 -lbenchmark -lpthread benchmark.cpp -o bench
./bench --benchmark_repetitions=10
./bench --benchmark_filter=PacketParsing
</code></pre>
<hr />
<h2 id="系統層級優化"><a class="header" href="#系統層級優化">系統層級優化</a></h2>
<h3 id="1-cpu-隔離和親和性"><a class="header" href="#1-cpu-隔離和親和性">1. CPU 隔離和親和性</a></h3>
<h4 id="隔離-cpu-core"><a class="header" href="#隔離-cpu-core">隔離 CPU core</a></h4>
<pre><code class="language-bash"># 編輯 /etc/default/grub
GRUB_CMDLINE_LINUX="isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5"

# 更新 grub
sudo update-grub
sudo reboot

# 驗證隔離
cat /sys/devices/system/cpu/isolated
</code></pre>
<h4 id="程式碼綁定-cpu"><a class="header" href="#程式碼綁定-cpu">程式碼綁定 CPU</a></h4>
<pre><code class="language-cpp">#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;

void pin_to_core(int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&amp;cpuset);
    CPU_SET(core_id, &amp;cpuset);
    pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &amp;cpuset);
}

// 設置優先級
void set_realtime_priority() {
    struct sched_param param;
    param.sched_priority = 99;  // 最高優先級
    sched_setscheduler(0, SCHED_FIFO, &amp;param);
}

int main() {
    pin_to_core(2);  // 綁定到隔離的 core 2
    set_realtime_priority();
    // ...
}
</code></pre>
<h4 id="numa-感知"><a class="header" href="#numa-感知">NUMA 感知</a></h4>
<pre><code class="language-bash"># 查看 NUMA 拓撲
numactl --hardware

# 在特定 NUMA node 運行
numactl --cpunodebind=0 --membind=0 ./trader

# 查看記憶體分配
numastat -p $(pidof trader)
</code></pre>
<pre><code class="language-cpp">#include &lt;numa.h&gt;

void init_numa() {
    if (numa_available() &lt; 0) {
        fprintf(stderr, "NUMA not available\n");
        return;
    }
    
    // 綁定到 NUMA node 0
    numa_run_on_node(0);
    numa_set_preferred(0);
    
    // 分配 NUMA-local 記憶體
    void* buffer = numa_alloc_onnode(SIZE, 0);
}
</code></pre>
<h3 id="2-記憶體優化"><a class="header" href="#2-記憶體優化">2. 記憶體優化</a></h3>
<h4 id="huge-pages"><a class="header" href="#huge-pages">Huge Pages</a></h4>
<pre><code class="language-bash"># 啟用 Huge Pages
echo 1024 &gt; /proc/sys/vm/nr_hugepages

# 檢查
cat /proc/meminfo | grep Huge

# 持久化設置
echo "vm.nr_hugepages = 1024" &gt;&gt; /etc/sysctl.conf
</code></pre>
<pre><code class="language-cpp">#include &lt;sys/mman.h&gt;

// 使用 Huge Pages 分配記憶體
void* buffer = mmap(NULL, SIZE, PROT_READ | PROT_WRITE,
                    MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                    -1, 0);
if (buffer == MAP_FAILED) {
    perror("mmap hugepage failed");
}
</code></pre>
<h4 id="記憶體預分配和-lock"><a class="header" href="#記憶體預分配和-lock">記憶體預分配和 lock</a></h4>
<pre><code class="language-cpp">#include &lt;sys/mman.h&gt;

int main() {
    // 鎖定記憶體，防止 swap
    if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
        perror("mlockall failed");
    }
    
    // 預分配所有需要的記憶體
    std::vector&lt;Packet&gt; packet_pool;
    packet_pool.reserve(10000);
    
    // 預先觸碰所有頁面，避免運行時 page fault
    for (size_t i = 0; i &lt; packet_pool.capacity(); i++) {
        packet_pool.emplace_back();
    }
    
    // 或者手動觸碰記憶體
    char* buffer = new char[BUFFER_SIZE];
    for (size_t i = 0; i &lt; BUFFER_SIZE; i += 4096) {
        buffer[i] = 0;  // 觸發 page fault
    }
}
</code></pre>
<h3 id="3-網路優化"><a class="header" href="#3-網路優化">3. 網路優化</a></h3>
<h4 id="kernel-網路調優"><a class="header" href="#kernel-網路調優">Kernel 網路調優</a></h4>
<pre><code class="language-bash"># 增加 ring buffer
ethtool -G eth0 rx 4096 tx 4096

# 關閉中斷合併（降低延遲）
ethtool -C eth0 rx-usecs 0 tx-usecs 0

# 啟用 RSS (Receive Side Scaling)
ethtool -L eth0 combined 4

# 綁定網卡中斷到特定 CPU
echo 2 &gt; /proc/irq/YOUR_IRQ/smp_affinity_list

# 查看網卡統計
ethtool -S eth0

# TCP 調優
cat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOF
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_congestion_control = bbr
EOF

sysctl -p
</code></pre>
<h4 id="socket-優化"><a class="header" href="#socket-優化">Socket 優化</a></h4>
<pre><code class="language-cpp">int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

// 設置 socket buffer size
int buffer_size = 8 * 1024 * 1024;
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, 
           &amp;buffer_size, sizeof(buffer_size));

// 設置 busy polling（減少延遲）
int busy_poll = 50;
setsockopt(sockfd, SOL_SOCKET, SO_BUSY_POLL, 
           &amp;busy_poll, sizeof(busy_poll));

// SO_TIMESTAMP 獲取精確時間戳
int enable = 1;
setsockopt(sockfd, SOL_SOCKET, SO_TIMESTAMPNS, 
           &amp;enable, sizeof(enable));

// 設置 TCP_NODELAY（關閉 Nagle 算法）
setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, 
           &amp;enable, sizeof(enable));

// 設置 SO_REUSEADDR
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, 
           &amp;enable, sizeof(enable));
</code></pre>
<h3 id="4-關閉不必要的服務"><a class="header" href="#4-關閉不必要的服務">4. 關閉不必要的服務</a></h3>
<pre><code class="language-bash"># 關閉 CPU 頻率調整
echo performance &gt; /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# 關閉 Turbo Boost（保持穩定延遲）
echo 1 &gt; /sys/devices/system/cpu/intel_pstate/no_turbo

# 關閉 NUMA balancing
echo 0 &gt; /proc/sys/kernel/numa_balancing

# 關閉透明大頁面（可能造成抖動）
echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled

# 關閉 swap
swapoff -a

# 設置中斷親和性腳本
#!/bin/bash
for irq in $(grep eth0 /proc/interrupts | awk '{print $1}' | sed 's/://'); do
    echo 2 &gt; /proc/irq/$irq/smp_affinity_list
done

# 關閉不必要的系統服務
systemctl disable bluetooth.service
systemctl disable cups.service
systemctl stop irqbalance
</code></pre>
<hr />
<h2 id="記憶體管理策略"><a class="header" href="#記憶體管理策略">記憶體管理策略</a></h2>
<h3 id="stack-vs-static-vs-heap-比較"><a class="header" href="#stack-vs-static-vs-heap-比較">Stack vs Static vs Heap 比較</a></h3>
<h4 id="效能排名"><a class="header" href="#效能排名">效能排名</a></h4>
<p><strong>速度：Stack &gt; Static &gt; Heap</strong></p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Stack</th><th>Static</th><th>Heap</th></tr></thead><tbody>
<tr><td><strong>分配速度</strong></td><td>⭐⭐⭐⭐⭐ (1-2ns)</td><td>⭐⭐⭐⭐⭐ (0ns)</td><td>⭐ (150ns)</td></tr>
<tr><td><strong>訪問速度</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr>
<tr><td><strong>生命週期</strong></td><td>函數內</td><td>程序全局</td><td>手動管理</td></tr>
<tr><td><strong>大小限制</strong></td><td>~8MB</td><td>幾乎無限</td><td>幾乎無限</td></tr>
<tr><td><strong>Cache 友好</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐</td></tr>
<tr><td><strong>靈活性</strong></td><td>⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr>
<tr><td><strong>適合高頻</strong></td><td>✅ 臨時變量</td><td>✅ 資源池</td><td>❌ 避免</td></tr>
</tbody></table>
</div>
<h4 id="實測效能對比"><a class="header" href="#實測效能對比">實測效能對比</a></h4>
<pre><code class="language-cpp">#include &lt;x86intrin.h&gt;
#include &lt;stdio.h&gt;

struct Order {
    uint64_t id;
    uint32_t price;
    uint32_t quantity;
};

// Static
static Order static_orders[10000];

// Heap
Order* heap_orders = new Order[10000];

void test_stack() {
    uint64_t total = 0;
    for (int i = 0; i &lt; 10000; i++) {
        uint64_t start = __rdtsc();
        
        Order order;  // Stack
        order.price = i;
        
        uint64_t end = __rdtsc();
        total += (end - start);
    }
    printf("Stack:  %.2f cycles/op\n", total / 10000.0);
}

void test_static() {
    uint64_t total = 0;
    for (int i = 0; i &lt; 10000; i++) {
        uint64_t start = __rdtsc();
        
        static_orders[i].price = i;
        
        uint64_t end = __rdtsc();
        total += (end - start);
    }
    printf("Static: %.2f cycles/op\n", total / 10000.0);
}

void test_heap() {
    uint64_t total = 0;
    for (int i = 0; i &lt; 10000; i++) {
        uint64_t start = __rdtsc();
        
        Order* order = new Order();
        order-&gt;price = i;
        delete order;
        
        uint64_t end = __rdtsc();
        total += (end - start);
    }
    printf("Heap:   %.2f cycles/op\n", total / 10000.0);
}
</code></pre>
<p><strong>典型結果（3GHz CPU）：</strong></p>
<pre><code>Stack:  3.2 cycles/op   (~1ns)    ← 最快
Static: 8.5 cycles/op   (~3ns)    ← 次快
Heap:   450 cycles/op   (~150ns)  ← 最慢

速度比：Stack : Static : Heap = 1 : 2.7 : 140
</code></pre>
<h3 id="static-記憶體模式推薦"><a class="header" href="#static-記憶體模式推薦">Static 記憶體模式（推薦）</a></h3>
<h4 id="1-object-pool"><a class="header" href="#1-object-pool">1. Object Pool</a></h4>
<pre><code class="language-cpp">template&lt;typename T, size_t N&gt;
class StaticPool {
    alignas(64) T pool[N];
    uint32_t free_list[N];
    uint32_t free_count = N;
    
public:
    StaticPool() {
        for (uint32_t i = 0; i &lt; N; i++) {
            free_list[i] = i;
        }
    }
    
    T* allocate() {
        if (free_count == 0) return nullptr;
        uint32_t idx = free_list[--free_count];
        return &amp;pool[idx];
    }
    
    void deallocate(T* ptr) {
        uint32_t idx = ptr - pool;
        free_list[free_count++] = idx;
    }
    
    size_t available() const { return free_count; }
};

// 使用
static StaticPool&lt;Order, 10000&gt; order_pool;

Order* order = order_pool.allocate();  // ~5ns
if (order) {
    order-&gt;price = 12345;
    // ...
    order_pool.deallocate(order);  // ~3ns
}
</code></pre>
<h4 id="2-ring-buffer封包處理"><a class="header" href="#2-ring-buffer封包處理">2. Ring Buffer（封包處理）</a></h4>
<pre><code class="language-cpp">template&lt;typename T, size_t N&gt;
class RingBuffer {
    static_assert((N &amp; (N - 1)) == 0, "N must be power of 2");
    
    alignas(64) T buffer[N];
    alignas(64) uint32_t read_idx = 0;
    alignas(64) uint32_t write_idx = 0;
    
public:
    bool push(const T&amp; item) {
        uint32_t next = (write_idx + 1) &amp; (N - 1);  // 快速取模
        if (next == read_idx) return false;  // Full
        
        buffer[write_idx] = item;
        write_idx = next;
        return true;
    }
    
    bool pop(T&amp; item) {
        if (read_idx == write_idx) return false;  // Empty
        
        item = buffer[read_idx];
        read_idx = (read_idx + 1) &amp; (N - 1);
        return true;
    }
    
    size_t size() const {
        return (write_idx - read_idx) &amp; (N - 1);
    }
};

// 使用
static RingBuffer&lt;Packet, 4096&gt; packet_buffer;
</code></pre>
<h4 id="3-fixed-size-array訂單簿"><a class="header" href="#3-fixed-size-array訂單簿">3. Fixed-size Array（訂單簿）</a></h4>
<pre><code class="language-cpp">class OrderBook {
    static constexpr size_t MAX_LEVELS = 100;
    static constexpr size_t MAX_ORDERS = 10000;
    
    struct Level {
        uint32_t price;
        uint32_t quantity;
        uint16_t order_count;
    };
    
    alignas(64) Level bids[MAX_LEVELS];
    alignas(64) Level asks[MAX_LEVELS];
    alignas(64) Order orders[MAX_ORDERS];
    
    uint32_t bid_count = 0;
    uint32_t ask_count = 0;
    
public:
    void add_order(const Order&amp; order) {
        uint32_t idx = order.id % MAX_ORDERS;
        orders[idx] = order;
        
        // 更新價格層級
        if (order.side == Side::BUY) {
            update_level(bids, bid_count, order);
        } else {
            update_level(asks, ask_count, order);
        }
    }
    
private:
    void update_level(Level* levels, uint32_t&amp; count, const Order&amp; order);
};

static OrderBook book;
</code></pre>
<h3 id="記憶體布局優化"><a class="header" href="#記憶體布局優化">記憶體布局優化</a></h3>
<h4 id="1-cache-line-對齊"><a class="header" href="#1-cache-line-對齊">1. Cache Line 對齊</a></h4>
<pre><code class="language-cpp">// ❌ 不好：可能跨 cache line
struct Order {
    uint32_t id;
    uint32_t price;
    // 總共 8 bytes
};

// ✅ 好：對齊到 64 bytes（一個 cache line）
struct alignas(64) Order {
    uint32_t id;
    uint32_t price;
    uint32_t quantity;
    uint32_t timestamp;
    char padding[48];
};

// 或者緊密排列多個小對象
struct Order {
    uint32_t id;
    uint32_t price;
} __attribute__((packed));

static_assert(sizeof(Order) == 8);
</code></pre>
<h4 id="2-熱數據集中"><a class="header" href="#2-熱數據集中">2. 熱數據集中</a></h4>
<pre><code class="language-cpp">// ❌ 不好：冷熱數據混合
struct Order {
    uint64_t timestamp;     // 熱數據
    uint32_t price;         // 熱數據
    char symbol[16];        // 冷數據
    char client_id[32];     // 冷數據
};

// ✅ 好：分離熱數據
struct OrderHot {
    uint64_t timestamp;
    uint32_t price;
    uint32_t quantity;
    uint32_t order_id;
} __attribute__((packed));

struct OrderCold {
    char symbol[16];
    char client_id[32];
};

static OrderHot hot_data[10000];
static OrderCold cold_data[10000];
</code></pre>
<h4 id="3-陣列的結構-soa-vs-結構的陣列-aos"><a class="header" href="#3-陣列的結構-soa-vs-結構的陣列-aos">3. 陣列的結構 (SoA) vs 結構的陣列 (AoS)</a></h4>
<pre><code class="language-cpp">// AoS (Array of Structures) - 預設方式
struct Order {
    uint32_t id;
    uint32_t price;
    uint32_t quantity;
};
Order orders[1000];

// SoA (Structure of Arrays) - SIMD 友好
struct Orders {
    uint32_t ids[1000];
    uint32_t prices[1000];
    uint32_t quantities[1000];
};

// SoA 適合批量處理
void process_orders(Orders&amp; orders, size_t count) {
    for (size_t i = 0; i &lt; count; i += 8) {
        // 使用 SIMD 一次處理 8 個價格
        __m256i prices = _mm256_loadu_si256((__m256i*)&amp;orders.prices[i]);
        // ...
    }
}
</code></pre>
<h3 id="thread-local-static最佳組合"><a class="header" href="#thread-local-static最佳組合">Thread-local Static（最佳組合）</a></h3>
<pre><code class="language-cpp">// 結合 Static 和 Stack 的優點
thread_local static Order order_buffer[1000];
thread_local static char message_buffer[65536];

void worker_thread() {
    // 每個線程有自己的 static buffer
    // - Static 的速度
    // - 無需鎖
    // - 生命週期貫穿線程
    
    for (int i = 0; i &lt; 1000; i++) {
        order_buffer[i].price = get_price();
    }
}
</code></pre>
<h3 id="混合策略最佳實踐"><a class="header" href="#混合策略最佳實踐">混合策略（最佳實踐）</a></h3>
<pre><code class="language-cpp">class OrderProcessor {
    // Static: 長期存在的資源池
    static Order order_pool[10000];
    static uint32_t free_list[10000];
    static uint32_t free_count;
    
public:
    void process_packet(const uint8_t* data) {
        // Stack: 臨時解析結果
        OrderMessage msg;
        parse_message(data, &amp;msg);
        
        // Static pool: 分配訂單對象
        Order* order = allocate_from_pool();
        order-&gt;price = msg.price;
        
        // Stack: 臨時計算
        uint32_t total_value = calculate_value(order);
        
        submit_order(order);
    }
    
private:
    Order* allocate_from_pool() {
        if (free_count == 0) return nullptr;
        return &amp;order_pool[free_list[--free_count]];
    }
};
</code></pre>
<hr />
<h2 id="網路程式設計"><a class="header" href="#網路程式設計">網路程式設計</a></h2>
<h3 id="1-接收封包的方式"><a class="header" href="#1-接收封包的方式">1. 接收封包的方式</a></h3>
<h4 id="標準-socket-較慢"><a class="header" href="#標準-socket-較慢">標準 Socket (較慢)</a></h4>
<pre><code class="language-cpp">int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

// 接收封包
char buffer[2048];
struct sockaddr_in src_addr;
socklen_t addrlen = sizeof(src_addr);

ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                     (struct sockaddr*)&amp;src_addr, &amp;addrlen);
</code></pre>
<h4 id="零拷貝--mmap-較快"><a class="header" href="#零拷貝--mmap-較快">零拷貝 + mmap (較快)</a></h4>
<pre><code class="language-cpp">// 使用 packet socket + mmap
int sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

// 設置 ring buffer
struct tpacket_req req = {
    .tp_block_size = 4096,
    .tp_block_nr = 64,
    .tp_frame_size = 2048,
    .tp_frame_nr = 128
};

setsockopt(sockfd, SOL_PACKET, PACKET_RX_RING, &amp;req, sizeof(req));

// mmap ring buffer
void* ring = mmap(NULL, req.tp_block_size * req.tp_block_nr,
                  PROT_READ | PROT_WRITE, MAP_SHARED, sockfd, 0);

// 零拷貝讀取
struct tpacket_hdr* header = (struct tpacket_hdr*)ring;
while (header-&gt;tp_status &amp; TP_STATUS_USER) {
    process_packet((uint8_t*)header + header-&gt;tp_mac);
    header-&gt;tp_status = TP_STATUS_KERNEL;  // 歸還給 kernel
    header = next_frame(header);
}
</code></pre>
<h4 id="kernel-bypass-最快"><a class="header" href="#kernel-bypass-最快">Kernel Bypass (最快)</a></h4>
<pre><code class="language-cpp">// 使用 DPDK 或 Solarflare OpenOnload
// 完全繞過 kernel，直接從網卡讀取

// DPDK 範例
struct rte_mbuf* pkts[BURST_SIZE];
uint16_t nb_rx = rte_eth_rx_burst(port_id, queue_id, pkts, BURST_SIZE);

for (uint16_t i = 0; i &lt; nb_rx; i++) {
    process_packet(rte_pktmbuf_mtod(pkts[i], uint8_t*));
    rte_pktmbuf_free(pkts[i]);
}
</code></pre>
<h3 id="2-多播-multicast-訂閱"><a class="header" href="#2-多播-multicast-訂閱">2. 多播 (Multicast) 訂閱</a></h3>
<pre><code class="language-cpp">int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

// 加入多播組
struct ip_mreq mreq;
mreq.imr_multiaddr.s_addr = inet_addr("239.1.1.1");
mreq.imr_interface.s_addr = INADDR_ANY;

setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
           &amp;mreq, sizeof(mreq));

// 綁定到多播端口
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(12345);
addr.sin_addr.s_addr = INADDR_ANY;
bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));
</code></pre>
<h3 id="3-發送封包優化"><a class="header" href="#3-發送封包優化">3. 發送封包優化</a></h3>
<pre><code class="language-cpp">// 使用 sendmmsg 批量發送
struct mmsghdr msgs[BATCH_SIZE];
struct iovec iovecs[BATCH_SIZE];

for (int i = 0; i &lt; BATCH_SIZE; i++) {
    iovecs[i].iov_base = packets[i];
    iovecs[i].iov_len = packet_sizes[i];
    
    msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];
    msgs[i].msg_hdr.msg_iovlen = 1;
}

int sent = sendmmsg(sockfd, msgs, BATCH_SIZE, 0);
</code></pre>
<h3 id="4-封包解析優化"><a class="header" href="#4-封包解析優化">4. 封包解析優化</a></h3>
<pre><code class="language-cpp">// 零拷貝封包解析
struct __attribute__((packed)) MarketDataHeader {
    uint16_t msg_type;
    uint16_t msg_len;
    uint32_t seq_num;
    uint64_t timestamp;
};

const MarketDataHeader* parse_header(const uint8_t* data) {
    // 直接轉型，不複製
    return reinterpret_cast&lt;const MarketDataHeader*&gt;(data);
}

// 使用 SIMD 加速校驗和計算
uint32_t checksum_simd(const uint8_t* data, size_t len) {
    __m256i sum = _mm256_setzero_si256();
    
    for (size_t i = 0; i &lt; len; i += 32) {
        __m256i chunk = _mm256_loadu_si256((__m256i*)&amp;data[i]);
        sum = _mm256_add_epi32(sum, chunk);
    }
    
    // 水平求和
    uint32_t result = 0;
    uint32_t* p = (uint32_t*)&amp;sum;
    for (int i = 0; i &lt; 8; i++) result += p[i];
    return result;
}
</code></pre>
<hr />
<h2 id="並行與無鎖程式設計"><a class="header" href="#並行與無鎖程式設計">並行與無鎖程式設計</a></h2>
<h3 id="1-atomic-操作"><a class="header" href="#1-atomic-操作">1. Atomic 操作</a></h3>
<pre><code class="language-cpp">#include &lt;atomic&gt;

// 無鎖計數器
std::atomic&lt;uint64_t&gt; seq_num{0};

uint64_t get_next_seq() {
    return seq_num.fetch_add(1, std::memory_order_relaxed);
}

// 無鎖 flag
std::atomic&lt;bool&gt; ready{false};

// Producer
data = prepare_data();
ready.store(true, std::memory_order_release);

// Consumer
while (!ready.load(std::memory_order_acquire)) {
    // spin
}
process(data);
</code></pre>
<h3 id="2-lock-free-queue-單生產者單消費者"><a class="header" href="#2-lock-free-queue-單生產者單消費者">2. Lock-free Queue (單生產者單消費者)</a></h3>
<pre><code class="language-cpp">template&lt;typename T, size_t N&gt;
class SPSCQueue {
    static_assert((N &amp; (N - 1)) == 0, "N must be power of 2");
    
    alignas(64) std::atomic&lt;uint32_t&gt; write_idx{0};
    alignas(64) std::atomic&lt;uint32_t&gt; read_idx{0};
    alignas(64) T buffer[N];
    
public:
    bool push(const T&amp; item) {
        uint32_t w = write_idx.load(std::memory_order_relaxed);
        uint32_t next_w = (w + 1) &amp; (N - 1);
        
        if (next_w == read_idx.load(std::memory_order_acquire)) {
            return false;  // Full
        }
        
        buffer[w] = item;
        write_idx.store(next_w, std::memory_order_release);
        return true;
    }
    
    bool pop(T&amp; item) {
        uint32_t r = read_idx.load(std::memory_order_relaxed);
        
        if (r == write_idx.load(std::memory_order_acquire)) {
            return false;  // Empty
        }
        
        item = buffer[r];
        read_idx.store((r + 1) &amp; (N - 1), std::memory_order_release);
        return true;
    }
};
</code></pre>
<h3 id="3-無鎖的訂單簿更新"><a class="header" href="#3-無鎖的訂單簿更新">3. 無鎖的訂單簿更新</a></h3>
<pre><code class="language-cpp">struct PriceLevel {
    std::atomic&lt;uint32_t&gt; quantity{0};
    std::atomic&lt;uint16_t&gt; order_count{0};
};

class LockFreeOrderBook {
    static constexpr size_t MAX_LEVELS = 100;
    
    alignas(64) PriceLevel bids[MAX_LEVELS];
    alignas(64) PriceLevel asks[MAX_LEVELS];
    
public:
    void add_order(uint32_t price, uint32_t qty, bool is_bid) {
        PriceLevel&amp; level = is_bid ? bids[price % MAX_LEVELS] 
                                   : asks[price % MAX_LEVELS];
        
        level.quantity.fetch_add(qty, std::memory_order_relaxed);
        level.order_count.fetch_add(1, std::memory_order_relaxed);
    }
    
    uint32_t get_best_bid() {
        for (int i = MAX_LEVELS - 1; i &gt;= 0; i--) {
            uint32_t qty = bids[i].quantity.load(std::memory_order_relaxed);
            if (qty &gt; 0) return i;
        }
        return 0;
    }
};
</code></pre>
<h3 id="4-memory-order-選擇指南"><a class="header" href="#4-memory-order-選擇指南">4. Memory Order 選擇指南</a></h3>
<pre><code class="language-cpp">// memory_order_relaxed: 最快，無同步保證
counter.fetch_add(1, std::memory_order_relaxed);

// memory_order_acquire/release: 用於生產者-消費者
// Producer
data = prepare();
ready.store(true, std::memory_order_release);

// Consumer  
while (!ready.load(std::memory_order_acquire));
process(data);

// memory_order_seq_cst: 最慢，全局順序一致性
flag.store(true, std::memory_order_seq_cst);
</code></pre>
<h3 id="5-避免-false-sharing"><a class="header" href="#5-避免-false-sharing">5. 避免 False Sharing</a></h3>
<pre><code class="language-cpp">// ❌ 不好：false sharing
struct Data {
    std::atomic&lt;uint64_t&gt; counter1;
    std::atomic&lt;uint64_t&gt; counter2;  // 可能在同一個 cache line
};

// ✅ 好：cache line 對齊
struct Data {
    alignas(64) std::atomic&lt;uint64_t&gt; counter1;
    alignas(64) std::atomic&lt;uint64_t&gt; counter2;
};
</code></pre>
<hr />
<h2 id="除錯與問題排查"><a class="header" href="#除錯與問題排查">除錯與問題排查</a></h2>
<h3 id="1-常見問題診斷"><a class="header" href="#1-常見問題診斷">1. 常見問題診斷</a></h3>
<h4 id="高延遲問題"><a class="header" href="#高延遲問題">高延遲問題</a></h4>
<pre><code class="language-bash"># 檢查 CPU 頻率是否被調降
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq

# 檢查是否有 context switch
perf stat -e context-switches ./trader

# 檢查 page fault
perf stat -e page-faults ./trader

# 檢查是否有 swap
vmstat 1

# 檢查網卡 drop
ethtool -S eth0 | grep drop
</code></pre>
<h4 id="記憶體問題"><a class="header" href="#記憶體問題">記憶體問題</a></h4>
<pre><code class="language-bash"># 檢查記憶體洩漏
valgrind --leak-check=full ./trader

# 查看記憶體使用
pmap -x $(pidof trader)

# 檢查 huge pages
cat /proc/meminfo | grep Huge
</code></pre>
<h4 id="cpu-使用問題"><a class="header" href="#cpu-使用問題">CPU 使用問題</a></h4>
<pre><code class="language-bash"># 查看哪個函數最耗 CPU
perf top -g

# 查看 CPU cache miss
perf stat -e cache-misses,cache-references ./trader

# 查看分支預測失敗
perf stat -e branch-misses,branches ./trader
</code></pre>
<h3 id="2-gdb-除錯技巧"><a class="header" href="#2-gdb-除錯技巧">2. GDB 除錯技巧</a></h3>
<pre><code class="language-bash"># 啟動 GDB
gdb ./trader

# 設置斷點
break process_packet
break main.cpp:123

# 條件斷點
break process_packet if price &gt; 10000

# 查看記憶體
x/16xb 0x12345678  # 以 16 進制查看 16 bytes

# 查看結構體
p order
p/x order.price  # 以 16 進制顯示

# 查看 backtrace
bt

# 附加到運行中的進程
gdb -p $(pidof trader)
</code></pre>
<h3 id="3-效能回歸檢測"><a class="header" href="#3-效能回歸檢測">3. 效能回歸檢測</a></h3>
<pre><code class="language-cpp">// regression_test.cpp
#include "trader.h"
#include &lt;fstream&gt;

int main() {
    // 載入基準數據
    std::ifstream baseline("baseline.json");
    Metrics baseline_metrics = load_metrics(baseline);
    
    // 運行測試
    Metrics current_metrics = run_benchmark();
    
    // 比較
    if (current_metrics.p99_latency &gt; baseline_metrics.p99_latency * 1.05) {
        fprintf(stderr, "REGRESSION: P99 latency increased by %.2f%%\n",
                (current_metrics.p99_latency / baseline_metrics.p99_latency - 1) * 100);
        return 1;
    }
    
    printf("PASS: No performance regression detected\n");
    return 0;
}
</code></pre>
<h3 id="4-日誌策略"><a class="header" href="#4-日誌策略">4. 日誌策略</a></h3>
<pre><code class="language-cpp">// 延遲日誌到非關鍵路徑
class AsyncLogger {
    static constexpr size_t BUFFER_SIZE = 1024 * 1024;
    
    char buffer[BUFFER_SIZE];
    std::atomic&lt;size_t&gt; write_pos{0};
    
public:
    void log(const char* fmt, ...) {
        size_t pos = write_pos.fetch_add(256, std::memory_order_relaxed);
        if (pos + 256 &gt; BUFFER_SIZE) return;  // Buffer full
        
        va_list args;
        va_start(args, fmt);
        vsnprintf(&amp;buffer[pos], 256, fmt, args);
        va_end(args);
    }
    
    void flush() {
        size_t end = write_pos.load(std::memory_order_acquire);
        write(log_fd, buffer, end);
        write_pos.store(0, std::memory_order_release);
    }
};

// 使用
thread_local AsyncLogger logger;

void process_order(Order* order) {
    logger.log("Processing order %u at price %u\n", order-&gt;id, order-&gt;price);
    // ... critical path ...
}

// 定期 flush（在非關鍵路徑）
void housekeeping_thread() {
    while (running) {
        sleep(1);
        logger.flush();
    }
}
</code></pre>
<hr />
<h2 id="常見陷阱與最佳實踐"><a class="header" href="#常見陷阱與最佳實踐">常見陷阱與最佳實踐</a></h2>
<h3 id="1-避免的操作在-hot-path"><a class="header" href="#1-避免的操作在-hot-path">1. 避免的操作（在 hot path）</a></h3>
<pre><code class="language-cpp">// ❌ 避免
std::string msg = "Order: " + std::to_string(order_id);  // 動態分配
std::cout &lt;&lt; msg &lt;&lt; std::endl;  // I/O 操作
std::map&lt;int, Order&gt; orders;    // 查找慢
std::vector&lt;Order&gt; v;
v.push_back(order);  // 可能重新分配

// ✅ 推薦
char buf[256];
snprintf(buf, sizeof(buf), "Order: %d", order_id);  // 棧上分配
// 延遲到非關鍵路徑再做 logging
std::unordered_map&lt;int, Order&gt; orders;  // 或 flat_map
std::vector&lt;Order&gt; v;
v.reserve(10000);  // 預分配
v.push_back(order);  // 不會重新分配
</code></pre>
<h3 id="2-編譯時檢查"><a class="header" href="#2-編譯時檢查">2. 編譯時檢查</a></h3>
<pre><code class="language-cpp">// 確保結構體大小符合預期
static_assert(sizeof(OrderMessage) == 64, "Unexpected padding");
static_assert(alignof(OrderMessage) == 8, "Wrong alignment");

// 確保是 trivial type（可以 memcpy）
static_assert(std::is_trivially_copyable_v&lt;OrderMessage&gt;);
static_assert(std::is_standard_layout_v&lt;OrderMessage&gt;);

// 確保沒有虛函數
static_assert(!std::is_polymorphic_v&lt;OrderMessage&gt;);
</code></pre>
<h3 id="3-位元操作優化"><a class="header" href="#3-位元操作優化">3. 位元操作優化</a></h3>
<pre><code class="language-cpp">// 使用編譯器內建函數（intrinsics）
#include &lt;x86intrin.h&gt;

// 計算 leading zeros
int len = __builtin_clz(header);

// 計算 population count (bit 為 1 的數量)
int count = __builtin_popcount(flags);

// SIMD 處理多個封包
__m256i data = _mm256_loadu_si256((__m256i*)packet);
__m256i mask = _mm256_set1_epi32(0xFF);
__m256i result = _mm256_and_si256(data, mask);

// 快速取模（當除數是 2 的冪）
uint32_t index = hash &amp; (SIZE - 1);  // 比 hash % SIZE 快

// 位元欄位
struct Flags {
    uint32_t is_buy : 1;
    uint32_t is_market : 1;
    uint32_t is_ioc : 1;
    uint32_t reserved : 29;
};
</code></pre>
<h3 id="4-zero-copy-封包處理"><a class="header" href="#4-zero-copy-封包處理">4. Zero-copy 封包處理</a></h3>
<pre><code class="language-cpp">// 避免複製，直接操作原始 buffer
const uint8_t* parse_packet(const uint8_t* buf) {
    // 直接讀取，不 memcpy
    uint32_t price = *(uint32_t*)(buf + PRICE_OFFSET);
    uint32_t qty = *(uint32_t*)(buf + QTY_OFFSET);
    
    // 或使用 unaligned load (更安全)
    uint32_t price;
    memcpy(&amp;price, buf + PRICE_OFFSET, sizeof(price));
    
    return buf + packet_len;
}
</code></pre>
<h3 id="5-使用-likelyunlikely-hints"><a class="header" href="#5-使用-likelyunlikely-hints">5. 使用 likely/unlikely hints</a></h3>
<pre><code class="language-cpp">#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

if (likely(is_trade_message(type))) {
    // 最常見的路徑
    process_trade(msg);
} else if (unlikely(is_error(type))) {
    // 很少發生
    handle_error(msg);
}
</code></pre>
<h3 id="6-監控抖動jitter"><a class="header" href="#6-監控抖動jitter">6. 監控抖動（Jitter）</a></h3>
<pre><code class="language-cpp">class JitterMonitor {
    uint64_t threshold_ns;
    std::vector&lt;uint64_t&gt; outliers;
    
public:
    JitterMonitor(uint64_t threshold) : threshold_ns(threshold) {}
    
    void record(uint64_t latency_ns, uint64_t timestamp) {
        if (latency_ns &gt; threshold_ns) {
            outliers.push_back((timestamp &lt;&lt; 32) | latency_ns);
            
            // 即時警告
            fprintf(stderr, "JITTER ALERT: %lu ns at %lu\n", 
                    latency_ns, timestamp);
        }
    }
    
    void report() {
        printf("Total outliers: %zu\n", outliers.size());
        for (auto entry : outliers) {
            uint64_t ts = entry &gt;&gt; 32;
            uint64_t lat = entry &amp; 0xFFFFFFFF;
            printf("  %lu: %lu ns\n", ts, lat);
        }
    }
};
</code></pre>
<h3 id="7-預取-prefetching"><a class="header" href="#7-預取-prefetching">7. 預取 (Prefetching)</a></h3>
<pre><code class="language-cpp">// 手動預取資料到 cache
void process_orders(Order* orders, size_t count) {
    for (size_t i = 0; i &lt; count; i++) {
        // 預取下一個 order
        if (i + 1 &lt; count) {
            __builtin_prefetch(&amp;orders[i + 1], 0, 3);
        }
        
        process_order(&amp;orders[i]);
    }
}

// 預取等級
// 0 = 不提示, 1 = L1, 2 = L2, 3 = L3
__builtin_prefetch(ptr, 0, 3);  // read, L3
__builtin_prefetch(ptr, 1, 1);  // write, L1
</code></pre>
<hr />
<h2 id="生產環境部署"><a class="header" href="#生產環境部署">生產環境部署</a></h2>
<h3 id="1-部署前檢查清單"><a class="header" href="#1-部署前檢查清單">1. 部署前檢查清單</a></h3>
<pre><code class="language-bash">#!/bin/bash
# pre_deploy_check.sh

echo "=== Pre-deployment Checks ==="

# 檢查 binary 是否靜態編譯或依賴正確
echo "Checking binary dependencies..."
ldd ./trader

# 檢查檔案權限
echo "Checking permissions..."
ls -l ./trader

# 檢查系統設定
echo "Checking system settings..."
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
cat /sys/kernel/mm/transparent_hugepage/enabled

# 檢查網路設定
echo "Checking network settings..."
ethtool -i eth0
ethtool -g eth0

# 檢查記憶體
echo "Checking memory..."
cat /proc/meminfo | grep -E "Huge|Mem"

# 測試基本功能
echo "Running smoke test..."
./trader --test-mode

echo "=== All checks passed ==="
</code></pre>
<h3 id="2-啟動腳本"><a class="header" href="#2-啟動腳本">2. 啟動腳本</a></h3>
<pre><code class="language-bash">#!/bin/bash
# start_trader.sh

# 設置環境
export LD_LIBRARY_PATH=/opt/trading/lib
export TRADING_CONFIG=/opt/trading/config/prod.conf

# CPU 親和性
CORE_ID=2

# 啟動前檢查
if ! ./pre_deploy_check.sh; then
    echo "Pre-deployment checks failed"
    exit 1
fi

# 啟動交易系統
echo "Starting trader on core $CORE_ID..."
taskset -c $CORE_ID ./trader --production 2&gt;&amp;1 | \
    tee /var/log/trading/trader.log

# 或使用 systemd
# systemctl start trader.service
</code></pre>
<h3 id="3-systemd-service-配置"><a class="header" href="#3-systemd-service-配置">3. Systemd Service 配置</a></h3>
<pre><code class="language-ini"># /etc/systemd/system/trader.service
[Unit]
Description=High Frequency Trading System
After=network.target

[Service]
Type=simple
User=trading
Group=trading
WorkingDirectory=/opt/trading
Environment="LD_LIBRARY_PATH=/opt/trading/lib"
ExecStart=/opt/trading/bin/trader --production
Restart=on-failure
RestartSec=10

# 資源限制
LimitMEMLOCK=infinity
LimitNOFILE=1048576

# 實時優先級
CPUSchedulingPolicy=fifo
CPUSchedulingPriority=99

# CPU 親和性
CPUAffinity=2 3 4 5

[Install]
WantedBy=multi-user.target
</code></pre>
<h3 id="4-監控腳本"><a class="header" href="#4-監控腳本">4. 監控腳本</a></h3>
<pre><code class="language-bash">#!/bin/bash
# monitor.sh

while true; do
    PID=$(pidof trader)
    
    if [ -z "$PID" ]; then
        echo "[ERROR] Trader process not found!"
        # 發送告警
        continue
    fi
    
    # CPU 使用率
    CPU=$(ps -p $PID -o %cpu= | tr -d ' ')
    
    # 記憶體使用
    MEM=$(ps -p $PID -o rss= | awk '{print $1/1024}')
    
    # 網路統計
    RX_PACKETS=$(cat /sys/class/net/eth0/statistics/rx_packets)
    TX_PACKETS=$(cat /sys/class/net/eth0/statistics/tx_packets)
    
    echo "$(date): CPU=$CPU% MEM=${MEM}MB RX=$RX_PACKETS TX=$TX_PACKETS"
    
    sleep 5
done
</code></pre>
<h3 id="5-緊急停止腳本"><a class="header" href="#5-緊急停止腳本">5. 緊急停止腳本</a></h3>
<pre><code class="language-bash">#!/bin/bash
# emergency_stop.sh

echo "Initiating emergency stop..."

# 發送 graceful shutdown 信號
PID=$(pidof trader)
if [ ! -z "$PID" ]; then
    kill -TERM $PID
    
    # 等待 5 秒
    sleep 5
    
    # 如果還沒停止，強制終止
    if ps -p $PID &gt; /dev/null; then
        echo "Forcefully killing process..."
        kill -9 $PID
    fi
fi

echo "Trader stopped"
</code></pre>
<h3 id="6-配置文件範例"><a class="header" href="#6-配置文件範例">6. 配置文件範例</a></h3>
<pre><code class="language-ini"># config/prod.conf
[network]
multicast_address = 239.1.1.1
multicast_port = 12345
interface = eth0

[trading]
max_order_size = 1000
max_orders_per_second = 10000
risk_limit = 1000000

[system]
cpu_core = 2
use_huge_pages = true
log_level = warning

[monitoring]
enable_metrics = true
metrics_interval_ms = 1000
alert_threshold_ns = 100000
</code></pre>
<h3 id="7-健康檢查"><a class="header" href="#7-健康檢查">7. 健康檢查</a></h3>
<pre><code class="language-cpp">// health_check.cpp
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // 檢查進程是否運行
    FILE* fp = popen("pidof trader", "r");
    char buf[32];
    if (fgets(buf, sizeof(buf), fp) == NULL) {
        printf("CRITICAL: Trader not running\n");
        return 2;
    }
    pclose(fp);
    
    // 檢查最近延遲
    fp = fopen("/var/log/trading/latency.log", "r");
    if (!fp) {
        printf("WARNING: Cannot read latency log\n");
        return 1;
    }
    
    // 解析最後一行
    char line[256];
    char* last_line = NULL;
    while (fgets(line, sizeof(line), fp)) {
        last_line = line;
    }
    
    if (last_line) {
        uint64_t latency_ns;
        sscanf(last_line, "%*s %lu", &amp;latency_ns);
        
        if (latency_ns &gt; 100000) {  // &gt; 100us
            printf("WARNING: High latency detected: %lu ns\n", latency_ns);
            fclose(fp);
            return 1;
        }
    }
    
    fclose(fp);
    printf("OK: System healthy\n");
    return 0;
}
</code></pre>
<hr />
<h2 id="效能基準參考"><a class="header" href="#效能基準參考">效能基準參考</a></h2>
<h3 id="典型延遲指標"><a class="header" href="#典型延遲指標">典型延遲指標</a></h3>
<pre><code>操作類型                延遲
───────────────────────────────
L1 cache 訪問           ~1 ns
L2 cache 訪問           ~3 ns
L3 cache 訪問           ~10 ns
主記憶體訪問            ~100 ns
malloc/free            ~150 ns
Context switch         ~1-10 μs
System call            ~1-5 μs
網路往返 (同機房)       ~100 μs
網路往返 (跨機房)       ~1-10 ms
</code></pre>
<h3 id="目標延遲等級"><a class="header" href="#目標延遲等級">目標延遲等級</a></h3>
<div class="table-wrapper"><table><thead><tr><th>等級</th><th>延遲範圍</th><th>優化重點</th></tr></thead><tbody>
<tr><td>亞微秒級</td><td>&lt; 1μs</td><td>極致優化、kernel bypass、FPGA</td></tr>
<tr><td>微秒級</td><td>1-10μs</td><td>系統調優、static 記憶體、無鎖</td></tr>
<tr><td>毫秒級</td><td>&gt; 1ms</td><td>基本優化即可</td></tr>
</tbody></table>
</div>
<h3 id="不同交易類型的延遲要求"><a class="header" href="#不同交易類型的延遲要求">不同交易類型的延遲要求</a></h3>
<div class="table-wrapper"><table><thead><tr><th>交易類型</th><th>P50</th><th>P99</th><th>P99.9</th></tr></thead><tbody>
<tr><td>做市</td><td>&lt; 5μs</td><td>&lt; 20μs</td><td>&lt; 50μs</td></tr>
<tr><td>套利</td><td>&lt; 10μs</td><td>&lt; 50μs</td><td>&lt; 100μs</td></tr>
<tr><td>趨勢追蹤</td><td>&lt; 100μs</td><td>&lt; 1ms</td><td>&lt; 5ms</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="回歸測試與持續整合"><a class="header" href="#回歸測試與持續整合">回歸測試與持續整合</a></h2>
<h3 id="回歸測試腳本"><a class="header" href="#回歸測試腳本">回歸測試腳本</a></h3>
<pre><code class="language-bash">#!/bin/bash
# regression_test.sh

set -e

# 編譯新版本
echo "Building new version..."
make clean &amp;&amp; make

# 運行效能測試
echo "Running performance tests..."
./bench --benchmark_repetitions=10 &gt; results_new.txt

# 比較結果
echo "Comparing with baseline..."
if [ -f results_baseline.txt ]; then
    python3 check_regression.py results_baseline.txt results_new.txt
else
    echo "No baseline found, creating new baseline..."
    cp results_new.txt results_baseline.txt
fi

# 運行單元測試
echo "Running unit tests..."
./unit_tests

# 運行整合測試
echo "Running integration tests..."
./integration_tests

echo "All tests passed!"
</code></pre>
<h3 id="效能回歸檢查"><a class="header" href="#效能回歸檢查">效能回歸檢查</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
# check_regression.py

import sys
import re

def parse_results(filename):
    metrics = {}
    with open(filename, 'r') as f:
        for line in f:
            match = re.match(r'(\w+)\s+(\d+)\s+ns', line)
            if match:
                metrics[match.group(1)] = int(match.group(2))
    return metrics

def main():
    baseline = parse_results(sys.argv[1])
    current = parse_results(sys.argv[2])
    
    regression_found = False
    
    for key in baseline:
        if key not in current:
            print(f"WARNING: {key} missing from current results")
            continue
            
        baseline_val = baseline[key]
        current_val = current[key]
        change = (current_val - baseline_val) / baseline_val * 100
        
        if change &gt; 5:  # 5% regression threshold
            print(f"REGRESSION: {key} increased by {change:.1f}%")
            print(f"  Baseline: {baseline_val} ns")
            print(f"  Current:  {current_val} ns")
            regression_found = True
        elif change &lt; -5:
            print(f"IMPROVEMENT: {key} decreased by {-change:.1f}%")
            print(f"  Baseline: {baseline_val} ns")
            print(f"  Current:  {current_val} ns")
    
    if regression_found:
        sys.exit(1)
    else:
        print("No performance regressions detected")
        sys.exit(0)

if __name__ == '__main__':
    main()
</code></pre>
<hr />
<h2 id="文檔和版本控制"><a class="header" href="#文檔和版本控制">文檔和版本控制</a></h2>
<h3 id="git-commit-最佳實踐"><a class="header" href="#git-commit-最佳實踐">Git Commit 最佳實踐</a></h3>
<pre><code class="language-bash"># 記錄每次優化的效果
git commit -m "Optimize packet parsing using SIMD

Baseline: P99 = 850ns, P99.9 = 1200ns
After:    P99 = 720ns, P99.9 = 980ns
Improvement: P99 -15.3%, P99.9 -18.3%

Changes:
- Use AVX2 for checksum validation
- Unroll parsing loop (4x)
- Align packet buffer to 64 bytes
- Remove unnecessary branches

Tested with:
- 1M packets benchmark
- perf showed 30% reduction in L1 cache misses
- No functional regressions
"
</code></pre>
<h3 id="變更日誌範例"><a class="header" href="#變更日誌範例">變更日誌範例</a></h3>
<pre><code class="language-markdown"># Changelog

## [2.1.0] - 2024-12-05

### Added
- SIMD-accelerated packet checksum validation
- Lock-free order book implementation
- Automatic jitter monitoring

### Changed
- Switched from heap to static memory pool (-40% latency)
- Optimized network buffer alignment (+15% throughput)

### Performance
- P99 latency: 850ns → 720ns (-15.3%)
- P99.9 latency: 1200ns → 980ns (-18.3%)
- Throughput: 1.2M msg/s → 1.5M msg/s (+25%)

### Fixed
- Race condition in order cancellation
- Memory leak in error handling path
</code></pre>
<hr />
<h2 id="關鍵建議總結"><a class="header" href="#關鍵建議總結">關鍵建議總結</a></h2>
<h3 id="開發環境"><a class="header" href="#開發環境">開發環境</a></h3>
<ol>
<li>✅ 使用 Docker 確保本地環境 = 機房環境</li>
<li>✅ 優先使用動態連結（環境一致時）</li>
<li>✅ 封包處理考慮靜態連結</li>
<li>✅ 使用 PGO (Profile-Guided Optimization)</li>
</ol>
<h3 id="效能測量"><a class="header" href="#效能測量">效能測量</a></h3>
<ol>
<li>✅ 測量一切：沒有測量就沒有優化依據</li>
<li>✅ 關注 P99/P99.9：不只是平均值</li>
<li>✅ 使用 perf、RDTSC、valgrind</li>
<li>✅ 建立基準並監控回歸</li>
</ol>
<h3 id="系統調優"><a class="header" href="#系統調優">系統調優</a></h3>
<ol>
<li>✅ 隔離 CPU core</li>
<li>✅ 啟用 Huge Pages</li>
<li>✅ 鎖定記憶體（mlockall）</li>
<li>✅ 調整網路參數</li>
<li>✅ 設置 NUMA 親和性</li>
</ol>
<h3 id="記憶體策略"><a class="header" href="#記憶體策略">記憶體策略</a></h3>
<ol>
<li>✅ 臨時變量用 Stack</li>
<li>✅ 資源池用 Static</li>
<li>✅ 避免使用 Heap（malloc/new）</li>
<li>✅ Cache line 對齊（64 bytes）</li>
<li>✅ 分離熱數據和冷數據</li>
</ol>
<h3 id="代碼優化"><a class="header" href="#代碼優化">代碼優化</a></h3>
<ol>
<li>✅ Hot path 避免動態分配</li>
<li>✅ 使用 SIMD 指令</li>
<li>✅ Zero-copy 設計</li>
<li>✅ 編譯時檢查（static_assert）</li>
<li>✅ 無鎖數據結構</li>
<li>✅ 預取 (Prefetching)</li>
<li>✅ Likely/Unlikely hints</li>
</ol>
<h3 id="網路優化"><a class="header" href="#網路優化">網路優化</a></h3>
<ol>
<li>✅ 考慮 kernel bypass (DPDK)</li>
<li>✅ 使用零拷貝技術</li>
<li>✅ 批量處理 (sendmmsg/recvmmsg)</li>
<li>✅ 設置 busy polling</li>
</ol>
<h3 id="部署與監控"><a class="header" href="#部署與監控">部署與監控</a></h3>
<ol>
<li>✅ 完整的部署檢查清單</li>
<li>✅ 自動化健康檢查</li>
<li>✅ 監控延遲分佈</li>
<li>✅ 告警機制</li>
<li>✅ 緊急停止程序</li>
</ol>
<hr />
<h2 id="參考資源"><a class="header" href="#參考資源">參考資源</a></h2>
<h3 id="文檔"><a class="header" href="#文檔">文檔</a></h3>
<ul>
<li>Linux perf 文檔: https://perf.wiki.kernel.org/</li>
<li>Intel 優化手冊: https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</li>
<li>Brendan Gregg 的效能分析: https://www.brendangregg.com/</li>
<li>DPDK 文檔: https://doc.dpdk.org/</li>
</ul>
<h3 id="書籍"><a class="header" href="#書籍">書籍</a></h3>
<ul>
<li>"Systems Performance" by Brendan Gregg</li>
<li>"The Art of Multiprocessor Programming" by Maurice Herlihy</li>
<li>"Computer Architecture: A Quantitative Approach" by Hennessy &amp; Patterson</li>
</ul>
<h3 id="工具"><a class="header" href="#工具">工具</a></h3>
<ul>
<li>perf: Linux 效能分析工具</li>
<li>valgrind: 記憶體除錯和 profiling</li>
<li>Intel VTune: 商業 profiling 工具</li>
<li>Google Benchmark: C++ 微基準測試框架</li>
</ul>
<h3 id="社群"><a class="header" href="#社群">社群</a></h3>
<ul>
<li>Mechanical Sympathy: https://groups.google.com/g/mechanical-sympathy</li>
<li>r/algotrading: https://reddit.com/r/algotrading</li>
<li>Stack Overflow [high-frequency-trading] tag</li>
</ul>
<hr />
<h2 id="附錄快速參考卡"><a class="header" href="#附錄快速參考卡">附錄：快速參考卡</a></h2>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<pre><code class="language-bash"># 編譯優化
g++ -O3 -march=native -flto your_code.cpp -o trader

# 效能測試
perf stat -e cycles,instructions,cache-misses ./trader
perf record -g ./trader
perf report

# 系統設置
echo performance &gt; /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
echo 1024 &gt; /proc/sys/vm/nr_hugepages

# 網路調優
ethtool -G eth0 rx 4096 tx 4096
ethtool -C eth0 rx-usecs 0 tx-usecs 0

# 監控
watch -n1 'cat /proc/$(pidof trader)/status | grep -E "VmRSS|VmSwap"'
</code></pre>
<h3 id="常用-c-模式"><a class="header" href="#常用-c-模式">常用 C++ 模式</a></h3>
<pre><code class="language-cpp">// 測量延遲
uint64_t start = __rdtsc();
critical_path();
uint64_t cycles = __rdtsc() - start;

// 無鎖 flag
std::atomic&lt;bool&gt; ready{false};
ready.store(true, std::memory_order_release);
while (!ready.load(std::memory_order_acquire));

// Object pool
static StaticPool&lt;Order, 10000&gt; pool;
Order* o = pool.allocate();
pool.deallocate(o);

// 對齊
struct alignas(64) Data { /* ... */ };

// Likely hint
if (likely(common_case)) { /* ... */ }
</code></pre>
<hr />
<p>最後更新：2024-12-05
版本：2.0</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../hft/06-resources/hft-introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../hft/06-resources/低延遲技術最佳實踐指南.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../hft/06-resources/hft-introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../hft/06-resources/低延遲技術最佳實踐指南.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>



    </div>
    </body>
</html>
