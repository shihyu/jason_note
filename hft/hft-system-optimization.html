<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高頻交易系統優化指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="高頻交易系統作業系統效能調優完整指南"><a class="header" href="#高頻交易系統作業系統效能調優完整指南">高頻交易系統：作業系統效能調優完整指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#1-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%B4%B9">1. 背景介紹</a></li>
<li><a href="#2-numa%E6%9E%B6%E6%A7%8B%E8%A9%B3%E8%A7%A3">2. NUMA架構詳解</a></li>
<li><a href="#3-%E6%A0%B8%E5%BF%83%E9%9A%94%E9%9B%A2%E6%8A%80%E8%A1%93">3. 核心隔離技術</a></li>
<li><a href="#4-%E8%A8%98%E6%86%B6%E9%AB%94%E5%84%AA%E5%8C%96%E7%AD%96%E7%95%A5">4. 記憶體優化策略</a></li>
<li><a href="#5-%E5%BF%AB%E5%8F%96%E5%84%AA%E5%8C%96%E6%8A%80%E8%A1%93">5. 快取優化技術</a></li>
<li><a href="#6-%E7%B6%B2%E8%B7%AF%E5%84%AA%E5%8C%96">6. 網路優化</a></li>
<li><a href="#7-%E7%9B%A3%E6%8E%A7%E8%88%87%E8%A8%BA%E6%96%B7">7. 監控與診斷</a></li>
<li><a href="#8-%E5%AF%A6%E6%88%B0%E6%A1%88%E4%BE%8B">8. 實戰案例</a></li>
</ul>
<hr />
<h2 id="1-背景介紹"><a class="header" href="#1-背景介紹">1. 背景介紹</a></h2>
<h3 id="11-高頻交易的挑戰"><a class="header" href="#11-高頻交易的挑戰">1.1 高頻交易的挑戰</a></h3>
<p>高頻量化交易（HFT）是一場發生在奈秒（Nanosecond, ns）尺度上的戰爭。效能指標對比：</p>
<div class="table-wrapper"><table><thead><tr><th>系統類型</th><th>延遲要求</th><th>抖動容忍度</th><th>吞吐量</th></tr></thead><tbody>
<tr><td>傳統交易系統</td><td>100-1000ms</td><td>±50ms</td><td>1K-10K/秒</td></tr>
<tr><td>低延遲交易</td><td>1-10ms</td><td>±5ms</td><td>10K-100K/秒</td></tr>
<tr><td>高頻交易</td><td>1-100μs</td><td>±1μs</td><td>100K-1M/秒</td></tr>
<tr><td>超高頻交易</td><td>&lt;1μs</td><td>±100ns</td><td>&gt;1M/秒</td></tr>
</tbody></table>
</div>
<h3 id="12-延遲來源分析"><a class="header" href="#12-延遲來源分析">1.2 延遲來源分析</a></h3>
<pre><code>總延遲 = 網路延遲 + 系統延遲 + 應用延遲

其中系統延遲包括：
├── CPU調度延遲 (1-100μs)
├── 記憶體存取延遲 (60-200ns)
├── 快取未命中 (1-100ns)
├── 中斷處理 (1-10μs)
├── 系統呼叫 (100-1000ns)
└── 上下文切換 (1-10μs)
</code></pre>
<h3 id="13-核心技術棧"><a class="header" href="#13-核心技術棧">1.3 核心技術棧</a></h3>
<ul>
<li><strong>硬體層</strong>：CPU親和性、NUMA、快取、網路卡</li>
<li><strong>作業系統層</strong>：核心調度、中斷處理、記憶體管理</li>
<li><strong>應用層</strong>：無鎖資料結構、記憶體池、零拷貝</li>
</ul>
<hr />
<h2 id="2-numa架構詳解"><a class="header" href="#2-numa架構詳解">2. NUMA架構詳解</a></h2>
<h3 id="21-numa基本概念"><a class="header" href="#21-numa基本概念">2.1 NUMA基本概念</a></h3>
<p>NUMA（Non-Uniform Memory Access）是現代多處理器伺服器的主流架構：</p>
<pre><code>傳統SMP架構：
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│CPU0 │ │CPU1 │ │CPU2 │ │CPU3 │
└──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘
   └───────┴───────┴───────┘
           │
    ┌──────▼──────┐
    │  記憶體控制器  │
    └──────┬──────┘
    ┌──────▼──────┐
    │    記憶體     │
    └─────────────┘

NUMA架構：
┌─────────Node 0─────────┐  ┌─────────Node 1─────────┐
│ ┌─────┐ ┌─────┐       │  │       ┌─────┐ ┌─────┐ │
│ │CPU0 │ │CPU1 │       │  │       │CPU2 │ │CPU3 │ │
│ └──┬──┘ └──┬──┘       │  │       └──┬──┘ └──┬──┘ │
│    └──┬────┘          │  │          └────┬──┘    │
│  ┌────▼────┐          │  │          ┌────▼────┐  │
│  │記憶體控制器│        │◄─┼─────────►│記憶體控制器│  │
│  └────┬────┘          │  │          └────┬────┘  │
│  ┌────▼────┐          │  │          ┌────▼────┐  │
│  │本地記憶體 │          │  │          │本地記憶體 │  │
│  └─────────┘          │  │          └─────────┘  │
└───────────────────────┘  └───────────────────────┘
        QPI/UPI互連
</code></pre>
<h3 id="22-numa效能特性"><a class="header" href="#22-numa效能特性">2.2 NUMA效能特性</a></h3>
<h4 id="記憶體存取延遲對比"><a class="header" href="#記憶體存取延遲對比">記憶體存取延遲對比</a></h4>
<div class="table-wrapper"><table><thead><tr><th>存取類型</th><th>延遲</th><th>相對成本</th></tr></thead><tbody>
<tr><td>L1 Cache</td><td>0.5ns</td><td>1x</td></tr>
<tr><td>L2 Cache</td><td>7ns</td><td>14x</td></tr>
<tr><td>L3 Cache</td><td>20ns</td><td>40x</td></tr>
<tr><td>本地記憶體</td><td>60-80ns</td><td>120-160x</td></tr>
<tr><td>遠端記憶體</td><td>120-200ns</td><td>240-400x</td></tr>
<tr><td>SSD</td><td>150μs</td><td>300,000x</td></tr>
<tr><td>HDD</td><td>10ms</td><td>20,000,000x</td></tr>
</tbody></table>
</div>
<h4 id="numa距離矩陣範例"><a class="header" href="#numa距離矩陣範例">NUMA距離矩陣範例</a></h4>
<pre><code class="language-bash">$ numactl --hardware
node distances:
node   0   1   2   3
  0:  10  21  31  21
  1:  21  10  21  31
  2:  31  21  10  21
  3:  21  31  21  10
</code></pre>
<h3 id="23-numa優化策略"><a class="header" href="#23-numa優化策略">2.3 NUMA優化策略</a></h3>
<h4 id="策略1記憶體本地化"><a class="header" href="#策略1記憶體本地化">策略1：記憶體本地化</a></h4>
<pre><code class="language-cpp">// 不良實踐：跨NUMA存取
void cross_numa_access() {
    // CPU在Node0，記憶體可能在Node1
    int* data = new int[SIZE];
    process_data(data);  // 每次存取都可能跨節點
}

// 最佳實踐：本地化存取
void local_numa_access() {
    // 綁定CPU和記憶體到同一節點
    numa_run_on_node(0);
    numa_set_preferred(0);
    
    // 分配本地記憶體
    int* data = (int*)numa_alloc_onnode(
        sizeof(int) * SIZE, 0
    );
    process_data(data);  // 全部本地存取
}
</code></pre>
<h4 id="策略2資料分片"><a class="header" href="#策略2資料分片">策略2：資料分片</a></h4>
<pre><code class="language-cpp">class NUMAOptimizedQueue {
private:
    struct NodeData {
        alignas(64) std::atomic&lt;size_t&gt; head;
        alignas(64) std::atomic&lt;size_t&gt; tail;
        void* buffer;
    };
    
    NodeData* nodes[MAX_NUMA_NODES];
    
public:
    void init() {
        int num_nodes = numa_num_configured_nodes();
        for(int i = 0; i &lt; num_nodes; i++) {
            // 每個NUMA節點一個隊列分片
            nodes[i] = (NodeData*)numa_alloc_onnode(
                sizeof(NodeData), i
            );
            nodes[i]-&gt;buffer = numa_alloc_onnode(
                BUFFER_SIZE, i
            );
        }
    }
};
</code></pre>
<hr />
<h2 id="3-核心隔離技術"><a class="header" href="#3-核心隔離技術">3. 核心隔離技術</a></h2>
<h3 id="31-cpu親和性設定"><a class="header" href="#31-cpu親和性設定">3.1 CPU親和性設定</a></h3>
<h4 id="物理核心拓撲識別"><a class="header" href="#物理核心拓撲識別">物理核心拓撲識別</a></h4>
<pre><code class="language-bash"># 查看CPU拓撲
$ lscpu --extended
CPU NODE SOCKET CORE L1d:L1i:L2:L3 ONLINE
0   0    0      0    0:0:0:0       yes
1   0    0      1    1:1:1:0       yes
2   0    0      2    2:2:2:0       yes
3   0    0      3    3:3:3:0       yes
4   0    0      0    0:0:0:0       yes  # 超執行緒
5   0    0      1    1:1:1:0       yes  # 超執行緒
</code></pre>
<h4 id="cpu綁定實作"><a class="header" href="#cpu綁定實作">CPU綁定實作</a></h4>
<pre><code class="language-cpp">#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;

class ThreadManager {
public:
    // 綁定執行緒到指定CPU核心
    static bool bind_to_cpu(int cpu_id) {
        cpu_set_t cpuset;
        CPU_ZERO(&amp;cpuset);
        CPU_SET(cpu_id, &amp;cpuset);
        
        pthread_t thread = pthread_self();
        return pthread_setaffinity_np(
            thread, sizeof(cpuset), &amp;cpuset
        ) == 0;
    }
    
    // 綁定到物理核心（跳過超執行緒）
    static bool bind_to_physical_core(int core_id) {
        return bind_to_cpu(core_id * 2);  // 假設偶數是物理核
    }
    
    // 設定執行緒優先級
    static bool set_realtime_priority(int priority) {
        struct sched_param param;
        param.sched_priority = priority;
        
        return pthread_setschedparam(
            pthread_self(),
            SCHED_FIFO,  // 實時調度策略
            &amp;param
        ) == 0;
    }
};
</code></pre>
<h3 id="32-中斷處理優化"><a class="header" href="#32-中斷處理優化">3.2 中斷處理優化</a></h3>
<h4 id="中斷親和性設定"><a class="header" href="#中斷親和性設定">中斷親和性設定</a></h4>
<pre><code class="language-bash">#!/bin/bash
# 將網路中斷綁定到專用CPU

# 找出網路卡中斷號
IFACE="eth0"
IRQ_LIST=$(grep $IFACE /proc/interrupts | awk -F: '{print $1}')

# 設定中斷親和性（綁定到CPU 16-23）
for IRQ in $IRQ_LIST; do
    echo "ff0000" &gt; /proc/irq/$IRQ/smp_affinity
done

# 停用 irqbalance 服務
systemctl stop irqbalance
systemctl disable irqbalance
</code></pre>
<h3 id="33-核心參數調優"><a class="header" href="#33-核心參數調優">3.3 核心參數調優</a></h3>
<h4 id="完整的grub配置"><a class="header" href="#完整的grub配置">完整的GRUB配置</a></h4>
<pre><code class="language-bash"># /etc/default/grub
GRUB_CMDLINE_LINUX="
    # CPU隔離
    isolcpus=8-15
    nohz_full=8-15
    rcu_nocbs=8-15
    
    # 中斷處理
    irqaffinity=0-7
    
    # 記憶體管理
    transparent_hugepage=never
    numa_balancing=disable
    
    # 電源管理
    intel_pstate=disable
    processor.max_cstate=1
    intel_idle.max_cstate=0
    
    # 其他優化
    nowatchdog
    nosoftlockup
    nmi_watchdog=0
"
</code></pre>
<hr />
<h2 id="4-記憶體優化策略"><a class="header" href="#4-記憶體優化策略">4. 記憶體優化策略</a></h2>
<h3 id="41-記憶體鎖定"><a class="header" href="#41-記憶體鎖定">4.1 記憶體鎖定</a></h3>
<pre><code class="language-cpp">class MemoryManager {
private:
    struct MemoryBlock {
        void* addr;
        size_t size;
        int numa_node;
        bool locked;
        bool huge_page;
    };
    
    std::vector&lt;MemoryBlock&gt; blocks;
    
public:
    void* allocate_locked_memory(
        size_t size, 
        int numa_node = -1,
        bool use_huge_page = true
    ) {
        void* ptr = nullptr;
        
        if (use_huge_page) {
            // 分配大頁記憶體
            ptr = mmap(nullptr, size,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                -1, 0);
        } else {
            // 分配普通記憶體
            if (numa_node &gt;= 0) {
                ptr = numa_alloc_onnode(size, numa_node);
            } else {
                ptr = numa_alloc_local(size);
            }
        }
        
        if (ptr &amp;&amp; ptr != MAP_FAILED) {
            // 鎖定記憶體
            if (mlock(ptr, size) == 0) {
                // 預取記憶體
                memset(ptr, 0, size);
                
                // 記錄記憶體塊
                blocks.push_back({
                    ptr, size, numa_node, true, use_huge_page
                });
                
                return ptr;
            }
        }
        
        return nullptr;
    }
};
</code></pre>
<h3 id="42-大頁記憶體配置"><a class="header" href="#42-大頁記憶體配置">4.2 大頁記憶體配置</a></h3>
<pre><code class="language-bash"># 系統配置
echo 'vm.nr_hugepages=1024' &gt;&gt; /etc/sysctl.conf
echo 'vm.hugetlb_shm_group=1001' &gt;&gt; /etc/sysctl.conf

# 掛載hugetlbfs
mkdir -p /mnt/hugepages
mount -t hugetlbfs nodev /mnt/hugepages

# 檢查配置
grep Huge /proc/meminfo
</code></pre>
<h3 id="43-記憶體池實作"><a class="header" href="#43-記憶體池實作">4.3 記憶體池實作</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
class LockFreeMemoryPool {
private:
    struct Node {
        T data;
        std::atomic&lt;Node*&gt; next;
    };
    
    std::atomic&lt;Node*&gt; head;
    std::atomic&lt;size_t&gt; size;
    Node* memory_block;
    
public:
    LockFreeMemoryPool(size_t capacity, int numa_node = -1) {
        // 分配連續記憶體塊
        size_t total_size = sizeof(Node) * capacity;
        
        if (numa_node &gt;= 0) {
            memory_block = (Node*)numa_alloc_onnode(
                total_size, numa_node
            );
        } else {
            memory_block = (Node*)aligned_alloc(
                64, total_size  // 64位元組對齊
            );
        }
        
        // 初始化自由列表
        for (size_t i = 0; i &lt; capacity - 1; ++i) {
            memory_block[i].next = &amp;memory_block[i + 1];
        }
        memory_block[capacity - 1].next = nullptr;
        
        head.store(memory_block);
        size.store(capacity);
    }
    
    T* allocate() {
        Node* old_head = head.load();
        while (old_head &amp;&amp; 
               !head.compare_exchange_weak(
                   old_head, old_head-&gt;next.load())) {
            // CAS重試
        }
        
        if (old_head) {
            size.fetch_sub(1);
            return &amp;old_head-&gt;data;
        }
        return nullptr;
    }
    
    void deallocate(T* ptr) {
        Node* node = reinterpret_cast&lt;Node*&gt;(
            reinterpret_cast&lt;char*&gt;(ptr) - offsetof(Node, data)
        );
        
        Node* old_head = head.load();
        do {
            node-&gt;next = old_head;
        } while (!head.compare_exchange_weak(old_head, node));
        
        size.fetch_add(1);
    }
};
</code></pre>
<hr />
<h2 id="5-快取優化技術"><a class="header" href="#5-快取優化技術">5. 快取優化技術</a></h2>
<h3 id="51-快取行對齊"><a class="header" href="#51-快取行對齊">5.1 快取行對齊</a></h3>
<pre><code class="language-cpp">// 避免偽共享
struct alignas(64) CacheLine {
    std::atomic&lt;uint64_t&gt; value;
    char padding[64 - sizeof(std::atomic&lt;uint64_t&gt;)];
};

// 優化的計數器陣列
class OptimizedCounters {
private:
    struct alignas(64) Counter {
        std::atomic&lt;uint64_t&gt; count{0};
    };
    
    Counter* counters;
    size_t num_counters;
    
public:
    OptimizedCounters(size_t n) : num_counters(n) {
        // 確保每個計數器獨占快取行
        counters = new (std::align_val_t(64)) Counter[n];
    }
    
    void increment(size_t idx) {
        counters[idx].count.fetch_add(1, std::memory_order_relaxed);
    }
};
</code></pre>
<h3 id="52-預取優化"><a class="header" href="#52-預取優化">5.2 預取優化</a></h3>
<pre><code class="language-cpp">class DataProcessor {
public:
    void process_array(int* data, size_t size) {
        const size_t prefetch_distance = 8;
        
        for (size_t i = 0; i &lt; size; ++i) {
            // 預取未來的資料
            if (i + prefetch_distance &lt; size) {
                __builtin_prefetch(
                    &amp;data[i + prefetch_distance], 
                    0,  // 讀取
                    3   // 高時間局部性
                );
            }
            
            // 處理當前資料
            process_element(data[i]);
        }
    }
    
private:
    void process_element(int&amp; elem) {
        // 實際處理邏輯
        elem = complex_calculation(elem);
    }
};
</code></pre>
<h3 id="53-intel-cat配置"><a class="header" href="#53-intel-cat配置">5.3 Intel CAT配置</a></h3>
<pre><code class="language-cpp">// 使用Intel RDT進行快取分配
class CacheAllocator {
public:
    bool setup_cache_allocation() {
        // 檢查CAT支援
        if (!check_cat_support()) {
            return false;
        }
        
        // 為關鍵任務分配專用快取
        // COS 1: 75% 快取給交易引擎
        set_cos_mask(1, 0xFFF0);
        
        // COS 2: 25% 快取給其他任務
        set_cos_mask(2, 0x000F);
        
        // 綁定程序到COS
        bind_task_to_cos(getpid(), 1);
        
        return true;
    }
    
private:
    bool check_cat_support() {
        // 檢查CPUID是否支援CAT
        unsigned int eax, ebx, ecx, edx;
        __cpuid_count(0x10, 0, eax, ebx, ecx, edx);
        return (ebx &amp; 0x2) != 0;  // L3 CAT
    }
    
    void set_cos_mask(int cos, uint64_t mask) {
        // 設定COS遮罩（需要MSR權限）
        uint32_t msr = 0xC90 + cos;
        wrmsr(msr, mask);
    }
};
</code></pre>
<hr />
<h2 id="6-網路優化"><a class="header" href="#6-網路優化">6. 網路優化</a></h2>
<h3 id="61-核心旁路技術"><a class="header" href="#61-核心旁路技術">6.1 核心旁路技術</a></h3>
<pre><code class="language-cpp">// DPDK 初始化範例
class DPDKNetworkHandler {
private:
    struct rte_mempool* mbuf_pool;
    uint16_t port_id;
    
public:
    bool init(int argc, char** argv) {
        // 初始化EAL
        int ret = rte_eal_init(argc, argv);
        if (ret &lt; 0) {
            return false;
        }
        
        // 建立記憶體池
        mbuf_pool = rte_pktmbuf_pool_create(
            "MBUF_POOL",
            8192,  // 緩衝區數量
            250,   // 快取大小
            0,
            RTE_MBUF_DEFAULT_BUF_SIZE,
            rte_socket_id()
        );
        
        // 配置網路埠
        struct rte_eth_conf port_conf = {};
        port_conf.rxmode.mq_mode = ETH_MQ_RX_RSS;
        
        ret = rte_eth_dev_configure(
            port_id, 1, 1, &amp;port_conf
        );
        
        return ret == 0;
    }
    
    void receive_packets() {
        struct rte_mbuf* bufs[BURST_SIZE];
        
        while (true) {
            // 輪詢接收封包
            uint16_t nb_rx = rte_eth_rx_burst(
                port_id, 0, bufs, BURST_SIZE
            );
            
            for (uint16_t i = 0; i &lt; nb_rx; i++) {
                process_packet(bufs[i]);
                rte_pktmbuf_free(bufs[i]);
            }
        }
    }
};
</code></pre>
<h3 id="62-網路卡優化參數"><a class="header" href="#62-網路卡優化參數">6.2 網路卡優化參數</a></h3>
<pre><code class="language-bash">#!/bin/bash
# 網路卡調優腳本

IFACE="eth0"

# 增加環形緩衝區
ethtool -G $IFACE rx 4096 tx 4096

# 啟用巨型幀
ip link set $IFACE mtu 9000

# 關閉中斷調節
ethtool -C $IFACE rx-usecs 0 tx-usecs 0

# 啟用RSS
ethtool -K $IFACE ntuple on
ethtool -K $IFACE rxhash on

# 設定RSS隊列數
ethtool -L $IFACE combined 8

# 關閉省電功能
ethtool -s $IFACE speed 10000 duplex full autoneg off
</code></pre>
<hr />
<h2 id="7-監控與診斷"><a class="header" href="#7-監控與診斷">7. 監控與診斷</a></h2>
<h3 id="71-效能監控工具"><a class="header" href="#71-效能監控工具">7.1 效能監控工具</a></h3>
<h4 id="系統層面監控"><a class="header" href="#系統層面監控">系統層面監控</a></h4>
<pre><code class="language-bash"># CPU監控
mpstat -P ALL 1

# 記憶體監控
numastat -c

# 中斷監控
watch -n 1 'cat /proc/interrupts | grep eth'

# 快取監控
perf stat -e cache-misses,cache-references ./app

# 延遲監控
cyclictest -m -p 99 -i 1000 -n
</code></pre>
<h4 id="應用層面監控"><a class="header" href="#應用層面監控">應用層面監控</a></h4>
<pre><code class="language-cpp">class PerformanceMonitor {
private:
    struct Metrics {
        std::atomic&lt;uint64_t&gt; total_latency{0};
        std::atomic&lt;uint64_t&gt; max_latency{0};
        std::atomic&lt;uint64_t&gt; min_latency{UINT64_MAX};
        std::atomic&lt;uint64_t&gt; count{0};
        
        // 延遲直方圖
        std::atomic&lt;uint64_t&gt; histogram[100]{};
    };
    
    alignas(64) Metrics metrics;
    
public:
    void record_latency(uint64_t latency_ns) {
        metrics.total_latency.fetch_add(latency_ns);
        metrics.count.fetch_add(1);
        
        // 更新最大/最小值
        uint64_t prev_max = metrics.max_latency.load();
        while (latency_ns &gt; prev_max &amp;&amp; 
               !metrics.max_latency.compare_exchange_weak(
                   prev_max, latency_ns)) {}
        
        uint64_t prev_min = metrics.min_latency.load();
        while (latency_ns &lt; prev_min &amp;&amp; 
               !metrics.min_latency.compare_exchange_weak(
                   prev_min, latency_ns)) {}
        
        // 更新直方圖
        size_t bucket = std::min(
            latency_ns / 100, size_t(99)
        );
        metrics.histogram[bucket].fetch_add(1);
    }
    
    void print_statistics() {
        uint64_t count = metrics.count.load();
        if (count == 0) return;
        
        double avg = metrics.total_latency.load() / 
                    static_cast&lt;double&gt;(count);
        
        std::cout &lt;&lt; "Latency Statistics:\n"
                  &lt;&lt; "  Average: " &lt;&lt; avg &lt;&lt; " ns\n"
                  &lt;&lt; "  Min: " &lt;&lt; metrics.min_latency.load() &lt;&lt; " ns\n"
                  &lt;&lt; "  Max: " &lt;&lt; metrics.max_latency.load() &lt;&lt; " ns\n"
                  &lt;&lt; "  Count: " &lt;&lt; count &lt;&lt; "\n";
        
        // 計算百分位數
        print_percentiles();
    }
};
</code></pre>
<h3 id="72-問題診斷清單"><a class="header" href="#72-問題診斷清單">7.2 問題診斷清單</a></h3>
<div class="table-wrapper"><table><thead><tr><th>問題</th><th>可能原因</th><th>診斷方法</th><th>解決方案</th></tr></thead><tbody>
<tr><td>延遲尖峰</td><td>CPU調度</td><td><code>trace-cmd</code></td><td>CPU隔離</td></tr>
<tr><td>延遲不穩定</td><td>中斷干擾</td><td><code>/proc/interrupts</code></td><td>中斷親和性</td></tr>
<tr><td>記憶體慢</td><td>NUMA跨節點</td><td><code>numastat</code></td><td>NUMA綁定</td></tr>
<tr><td>快取未命中高</td><td>偽共享</td><td><code>perf c2c</code></td><td>資料對齊</td></tr>
<tr><td>網路延遲</td><td>核心協定棧</td><td><code>tcpdump</code></td><td>DPDK/XDP</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="8-實戰案例"><a class="header" href="#8-實戰案例">8. 實戰案例</a></h2>
<h3 id="81-完整的hft系統配置"><a class="header" href="#81-完整的hft系統配置">8.1 完整的HFT系統配置</a></h3>
<pre><code class="language-cpp">class HFTSystem {
private:
    // 配置參數
    struct Config {
        int trading_cpu = 8;      // 交易引擎CPU
        int market_data_cpu = 9;   // 市場資料CPU
        int network_cpu = 10;      // 網路處理CPU
        int numa_node = 0;         // NUMA節點
        size_t memory_size = 1024 * 1024 * 1024;  // 1GB
    } config;
    
    // 核心元件
    std::unique_ptr&lt;MemoryManager&gt; memory_manager;
    std::unique_ptr&lt;NetworkHandler&gt; network_handler;
    std::unique_ptr&lt;TradingEngine&gt; trading_engine;
    
public:
    bool initialize() {
        // 1. 系統層級設定
        if (!setup_system()) {
            return false;
        }
        
        // 2. 記憶體初始化
        memory_manager = std::make_unique&lt;MemoryManager&gt;();
        void* trading_memory = memory_manager-&gt;allocate_locked_memory(
            config.memory_size,
            config.numa_node,
            true  // 使用大頁
        );
        
        // 3. CPU綁定
        ThreadManager::bind_to_cpu(config.trading_cpu);
        ThreadManager::set_realtime_priority(99);
        
        // 4. 網路初始化
        network_handler = std::make_unique&lt;NetworkHandler&gt;();
        network_handler-&gt;init_dpdk();
        
        // 5. 交易引擎初始化
        trading_engine = std::make_unique&lt;TradingEngine&gt;(
            trading_memory,
            config.memory_size
        );
        
        return true;
    }
    
private:
    bool setup_system() {
        // 檢查權限
        if (geteuid() != 0) {
            std::cerr &lt;&lt; "需要root權限\n";
            return false;
        }
        
        // 設定CPU調速器
        system("cpupower frequency-set -g performance");
        
        // 關閉透明大頁
        system("echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled");
        
        // 設定記憶體鎖定限制
        struct rlimit rlim;
        rlim.rlim_cur = RLIM_INFINITY;
        rlim.rlim_max = RLIM_INFINITY;
        setrlimit(RLIMIT_MEMLOCK, &amp;rlim);
        
        return true;
    }
};
</code></pre>
<h3 id="82-延遲測試結果"><a class="header" href="#82-延遲測試結果">8.2 延遲測試結果</a></h3>
<pre><code>測試環境：
- CPU: Intel Xeon Gold 6248R (24C/48T)
- 記憶體: 256GB DDR4-2933 (8通道)
- 網路: Mellanox ConnectX-5 100GbE
- OS: CentOS 8.4 RT Kernel

優化前：
- 平均延遲: 85μs
- P99延遲: 250μs
- 最大延遲: 2ms
- 抖動: ±50μs

優化後：
- 平均延遲: 18μs
- P99延遲: 22μs
- 最大延遲: 35μs
- 抖動: ±1μs

改善幅度：
- 平均延遲降低: 78.8%
- P99延遲降低: 91.2%
- 最大延遲降低: 98.3%
- 抖動降低: 98%
</code></pre>
<hr />
<h2 id="9-最佳實踐總結"><a class="header" href="#9-最佳實踐總結">9. 最佳實踐總結</a></h2>
<h3 id="91-硬體選擇建議"><a class="header" href="#91-硬體選擇建議">9.1 硬體選擇建議</a></h3>
<div class="table-wrapper"><table><thead><tr><th>元件</th><th>建議配置</th><th>原因</th></tr></thead><tbody>
<tr><td>CPU</td><td>Intel Xeon Gold/AMD EPYC</td><td>高主頻、大快取</td></tr>
<tr><td>記憶體</td><td>DDR4-3200以上</td><td>低延遲、高頻寬</td></tr>
<tr><td>網路卡</td><td>Mellanox/Intel XL710</td><td>支援DPDK/核心旁路</td></tr>
<tr><td>儲存</td><td>Intel Optane SSD</td><td>超低延遲</td></tr>
</tbody></table>
</div>
<h3 id="92-軟體配置清單"><a class="header" href="#92-軟體配置清單">9.2 軟體配置清單</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
作業系統核心參數調優</li>
<li><input disabled="" type="checkbox"/>
CPU隔離與綁定</li>
<li><input disabled="" type="checkbox"/>
NUMA優化配置</li>
<li><input disabled="" type="checkbox"/>
大頁記憶體設定</li>
<li><input disabled="" type="checkbox"/>
中斷親和性調整</li>
<li><input disabled="" type="checkbox"/>
網路協定棧優化</li>
<li><input disabled="" type="checkbox"/>
即時核心安裝（可選）</li>
<li><input disabled="" type="checkbox"/>
監控系統部署</li>
</ul>
<h3 id="93-開發建議"><a class="header" href="#93-開發建議">9.3 開發建議</a></h3>
<ol>
<li>
<p><strong>設計原則</strong></p>
<ul>
<li>無鎖資料結構優先</li>
<li>避免動態記憶體分配</li>
<li>最小化系統呼叫</li>
<li>資料局部性優化</li>
</ul>
</li>
<li>
<p><strong>測試方法</strong></p>
<ul>
<li>使用生產環境硬體</li>
<li>模擬真實負載</li>
<li>長時間穩定性測試</li>
<li>極端情況壓力測試</li>
</ul>
</li>
<li>
<p><strong>持續優化</strong></p>
<ul>
<li>建立基準測試</li>
<li>定期效能分析</li>
<li>追蹤新技術發展</li>
<li>保持程式碼簡潔</li>
</ul>
</li>
</ol>
<hr />
<h2 id="10-進階資源"><a class="header" href="#10-進階資源">10. 進階資源</a></h2>
<h3 id="101-參考文獻"><a class="header" href="#101-參考文獻">10.1 參考文獻</a></h3>
<ul>
<li>Intel® 64 and IA-32 Architectures Optimization Reference Manual</li>
<li>DPDK Programmer's Guide</li>
<li>Linux Performance and Tuning Guidelines</li>
<li>High-Performance Trading System Design</li>
</ul>
<h3 id="102-開源專案"><a class="header" href="#102-開源專案">10.2 開源專案</a></h3>
<ul>
<li><a href="https://www.dpdk.org/">DPDK</a> - 資料平面開發套件</li>
<li><a href="http://seastar.io/">Seastar</a> - 高效能C++框架</li>
<li><a href="https://github.com/real-logic/aeron">Aeron</a> - 高效能訊息傳輸</li>
<li><a href="https://lmax-exchange.github.io/disruptor/">Disruptor</a> - 高效能佇列</li>
</ul>
<h3 id="103-監控工具"><a class="header" href="#103-監控工具">10.3 監控工具</a></h3>
<ul>
<li><a href="https://software.intel.com/vtune">Intel VTune</a> - 效能分析</li>
<li><a href="https://perf.wiki.kernel.org/">perf</a> - Linux效能工具</li>
<li><a href="https://ebpf.io/">BPF/eBPF</a> - 核心追蹤</li>
<li><a href="https://github.com/andikleen/pmu-tools">PMU Tools</a> - CPU效能監控</li>
</ul>
<hr />
<h2 id="附錄a常用命令速查"><a class="header" href="#附錄a常用命令速查">附錄A：常用命令速查</a></h2>
<pre><code class="language-bash"># CPU相關
taskset -c 0-3 ./app          # CPU親和性
chrt -f 99 ./app              # 實時優先級
cpupower frequency-info       # CPU頻率資訊

# 記憶體相關
numactl --hardware            # NUMA拓撲
numastat -c                   # NUMA統計
echo 1024 &gt; /proc/sys/vm/nr_hugepages  # 大頁設定

# 網路相關
ethtool -g eth0              # 查看環形緩衝區
ethtool -C eth0              # 中斷調節設定
tc qdisc show                # 流量控制

# 監控相關
mpstat -P ALL 1              # CPU使用率
sar -n DEV 1                 # 網路流量
pidstat -d -p PID 1          # 程序I/O
</code></pre>
<h2 id="附錄b故障排除指南"><a class="header" href="#附錄b故障排除指南">附錄B：故障排除指南</a></h2>
<div class="table-wrapper"><table><thead><tr><th>症狀</th><th>診斷步驟</th><th>可能的解決方案</th></tr></thead><tbody>
<tr><td>延遲突然增加</td><td>1. 檢查CPU頻率<br>2. 查看中斷統計<br>3. 檢查記憶體分配</td><td>- 固定CPU頻率<br>- 調整中斷親和性<br>- 使用記憶體池</td></tr>
<tr><td>效能不穩定</td><td>1. 監控系統負載<br>2. 檢查NUMA配置<br>3. 分析快取命中率</td><td>- CPU隔離<br>- NUMA綁定<br>- 資料結構優化</td></tr>
<tr><td>網路延遲高</td><td>1. 檢查網路卡配置<br>2. 分析協定棧<br>3. 查看丟包率</td><td>- 使用DPDK<br>- 調整緩衝區<br>- 優化批次處理</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>文件版本</strong>: 1.0<br />
<strong>最後更新</strong>: 2024年<br />
<strong>作者</strong>: HFT系統優化團隊<br />
<strong>授權</strong>: MIT License</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hft/api-trading-performance-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../hft/network-optimization-guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hft/api-trading-performance-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../hft/network-optimization-guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
