<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 高頻交易開發指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-高頻交易開發技術指南"><a class="header" href="#rust-高頻交易開發技術指南">Rust 高頻交易開發技術指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ul>
<li><a href="#rust-vs-c-%E5%9C%A8-hft-%E4%B8%AD%E7%9A%84%E5%B0%8D%E6%AF%94">Rust vs C++ 在 HFT 中的對比</a></li>
<li><a href="#rust-%E7%9A%84%E8%AA%9E%E8%A8%80%E5%84%AA%E5%8B%A2">Rust 的語言優勢</a></li>
<li><a href="#%E9%9B%B6%E6%8B%B7%E8%B2%9D%E9%80%9A%E4%BF%A1%E5%AF%A6%E7%8F%BE">零拷貝通信實現</a></li>
<li><a href="#simd-%E5%84%AA%E5%8C%96%E7%AD%96%E7%95%A5">SIMD 優化策略</a></li>
<li><a href="#%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86%E8%88%87%E5%84%AA%E5%8C%96">記憶體管理與優化</a></li>
<li><a href="#%E4%B8%A6%E7%99%BC%E6%A8%A1%E5%9E%8B">並發模型</a></li>
<li><a href="#%E5%AF%A6%E6%88%B0%E7%AF%84%E4%BE%8B">實戰範例</a></li>
</ul>
<h2 id="rust-vs-c-在-hft-中的對比"><a class="header" href="#rust-vs-c-在-hft-中的對比">Rust vs C++ 在 HFT 中的對比</a></h2>
<h3 id="相同之處"><a class="header" href="#相同之處">相同之處</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>說明</th></tr></thead><tbody>
<tr><td><strong>零成本抽象</strong></td><td>兩者都提供編譯時優化，運行時無額外開銷</td></tr>
<tr><td><strong>手動記憶體管理</strong></td><td>精確控制記憶體分配和釋放</td></tr>
<tr><td><strong>內聯優化</strong></td><td>積極的函數內聯</td></tr>
<tr><td><strong>LLVM 後端</strong></td><td>Rust 使用 LLVM，可獲得類似優化</td></tr>
<tr><td><strong>系統調用</strong></td><td>同樣可以直接使用 OS 級別的零拷貝 API</td></tr>
</tbody></table>
</div>
<h3 id="關鍵差異"><a class="header" href="#關鍵差異">關鍵差異</a></h3>
<div class="table-wrapper"><table><thead><tr><th>方面</th><th>C++</th><th>Rust</th></tr></thead><tbody>
<tr><td><strong>記憶體安全</strong></td><td>需要手動管理，容易出錯</td><td>編譯時保證，無 data race</td></tr>
<tr><td><strong>生命週期</strong></td><td>隱式管理</td><td>顯式生命週期標註</td></tr>
<tr><td><strong>錯誤處理</strong></td><td>異常或錯誤碼</td><td><code>Result&lt;T, E&gt;</code> 類型</td></tr>
<tr><td><strong>並發模型</strong></td><td>需要小心處理共享狀態</td><td><code>Send</code>/<code>Sync</code> trait 保證安全</td></tr>
<tr><td><strong>編譯速度</strong></td><td>較快</td><td>較慢（但程式更安全）</td></tr>
</tbody></table>
</div>
<h2 id="rust-的語言優勢"><a class="header" href="#rust-的語言優勢">Rust 的語言優勢</a></h2>
<h3 id="1-所有權系統帶來的優化"><a class="header" href="#1-所有權系統帶來的優化">1. 所有權系統帶來的優化</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 的所有權系統允許編譯器進行更激進的優化
fn process_data(mut data: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; {
    // 編譯器知道 data 是唯一擁有者，可以直接修改
    // 不需要擔心別名問題
    data.iter_mut().for_each(|x| *x *= 2.0);
    data  // 移動語義，零拷貝返回
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-無畏並發fearless-concurrency"><a class="header" href="#2-無畏並發fearless-concurrency">2. 無畏並發（Fearless Concurrency）</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use crossbeam::channel;

// 編譯時保證線程安全
fn parallel_processing&lt;T: Send + Sync + 'static&gt;(data: Arc&lt;T&gt;) {
    // Send trait 保證可以安全地在線程間傳遞
    // Sync trait 保證可以安全地在線程間共享引用
    std::thread::spawn(move || {
        // 使用 data，編譯器保證安全
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="零拷貝通信實現"><a class="header" href="#零拷貝通信實現">零拷貝通信實現</a></h2>
<h3 id="1-共享記憶體映射"><a class="header" href="#1-共享記憶體映射">1. 共享記憶體映射</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use memmap2::{MmapMut, MmapOptions};
use std::fs::OpenOptions;
use std::os::unix::io::AsRawFd;

pub struct SharedMemoryBuffer {
    mmap: MmapMut,
    size: usize,
}

impl SharedMemoryBuffer {
    pub fn create(path: &amp;str, size: usize) -&gt; std::io::Result&lt;Self&gt; {
        // 創建共享記憶體文件
        let file = OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(path)?;
        
        file.set_len(size as u64)?;
        
        // 內存映射 - 零拷貝的關鍵
        let mut mmap = unsafe { 
            MmapOptions::new()
                .len(size)
                .map_mut(&amp;file)? 
        };
        
        // 鎖定內存，防止交換
        mmap.lock()?;
        
        Ok(Self { mmap, size })
    }
    
    // 零拷貝寫入
    pub fn write_at&lt;T&gt;(&amp;mut self, offset: usize, data: &amp;T) 
    where T: Copy {
        unsafe {
            let ptr = self.mmap.as_mut_ptr().add(offset) as *mut T;
            ptr.write_volatile(*data);
        }
    }
    
    // 零拷貝讀取
    pub fn read_at&lt;T&gt;(&amp;self, offset: usize) -&gt; T 
    where T: Copy {
        unsafe {
            let ptr = self.mmap.as_ptr().add(offset) as *const T;
            ptr.read_volatile()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-linux-特定零拷貝-api"><a class="header" href="#2-linux-特定零拷貝-api">2. Linux 特定零拷貝 API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nix::sys::sendfile;
use nix::fcntl::{splice, SpliceFFlags};
use std::os::unix::io::RawFd;

pub struct ZeroCopyTransfer;

impl ZeroCopyTransfer {
    // 使用 sendfile 零拷貝傳輸
    pub fn sendfile_transfer(
        out_fd: RawFd,
        in_fd: RawFd,
        count: usize
    ) -&gt; nix::Result&lt;usize&gt; {
        sendfile::sendfile(out_fd, in_fd, None, count)
    }
    
    // 使用 splice 在管道間移動數據
    pub fn splice_transfer(
        fd_in: RawFd,
        fd_out: RawFd,
        len: usize
    ) -&gt; nix::Result&lt;usize&gt; {
        splice(
            fd_in,
            None,
            fd_out,
            None,
            len,
            SpliceFFlags::SPLICE_F_MOVE
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-高性能環形緩衝區"><a class="header" href="#3-高性能環形緩衝區">3. 高性能環形緩衝區</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering};
use std::alloc::{alloc, dealloc, Layout};

#[repr(C, align(64))]  // 快取行對齊
pub struct RingBuffer&lt;T&gt; {
    buffer: *mut T,
    capacity: usize,
    // 使用 padding 避免 false sharing
    _pad1: [u8; 64 - 16],
    
    write_pos: AtomicUsize,
    _pad2: [u8; 64 - 8],
    
    read_pos: AtomicUsize,
    _pad3: [u8; 64 - 8],
}

unsafe impl&lt;T: Send&gt; Send for RingBuffer&lt;T&gt; {}
unsafe impl&lt;T: Send&gt; Sync for RingBuffer&lt;T&gt; {}

impl&lt;T&gt; RingBuffer&lt;T&gt; {
    pub fn new(capacity: usize) -&gt; Self {
        let layout = Layout::array::&lt;T&gt;(capacity).unwrap();
        let buffer = unsafe { alloc(layout) as *mut T };
        
        Self {
            buffer,
            capacity,
            _pad1: [0; 64 - 16],
            write_pos: AtomicUsize::new(0),
            _pad2: [0; 64 - 8],
            read_pos: AtomicUsize::new(0),
            _pad3: [0; 64 - 8],
        }
    }
    
    // 無鎖寫入
    pub fn push(&amp;self, value: T) -&gt; bool {
        let write = self.write_pos.load(Ordering::Acquire);
        let next_write = (write + 1) % self.capacity;
        
        if next_write == self.read_pos.load(Ordering::Acquire) {
            return false; // 緩衝區滿
        }
        
        unsafe {
            self.buffer.add(write).write(value);
        }
        
        self.write_pos.store(next_write, Ordering::Release);
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="simd-優化策略"><a class="header" href="#simd-優化策略">SIMD 優化策略</a></h2>
<h3 id="1-使用-packed_simd-或-stdsimd"><a class="header" href="#1-使用-packed_simd-或-stdsimd">1. 使用 packed_simd 或 std::simd</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(portable_simd)]
<span class="boring">fn main() {
</span>use std::simd::*;

pub fn calculate_returns_simd(prices: &amp;[f32], returns: &amp;mut [f32]) {
    // Rust 的 SIMD API（實驗性）
    let chunks = prices.chunks_exact(8);
    let remainder = chunks.remainder();
    
    for (price_chunk, return_chunk) in 
        chunks.zip(returns.chunks_exact_mut(8)) {
        
        let prices_vec = f32x8::from_slice(price_chunk);
        let prev_prices = f32x8::from_slice(&amp;price_chunk[1..]);
        
        let returns_vec = (prices_vec - prev_prices) / prev_prices;
        returns_vec.copy_to_slice(return_chunk);
    }
    
    // 處理剩餘部分
    for i in 0..remainder.len()-1 {
        returns[prices.len() - remainder.len() + i] = 
            (remainder[i+1] - remainder[i]) / remainder[i];
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-自動向量化提示"><a class="header" href="#2-自動向量化提示">2. 自動向量化提示</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用迭代器讓編譯器自動向量化
#[inline(always)]
pub fn dot_product(a: &amp;[f64], b: &amp;[f64]) -&gt; f64 {
    // Rust 編譯器會自動向量化這個
    a.iter()
        .zip(b.iter())
        .map(|(x, y)| x * y)
        .sum()
}

// 使用 target-feature 啟用特定 SIMD 指令集
#[target_feature(enable = "avx2")]
unsafe fn process_avx2(data: &amp;mut [f32]) {
    // 編譯器會使用 AVX2 指令
    for x in data {
        *x = x.mul_add(2.0, 1.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-明確的-simd-控制"><a class="header" href="#3-明確的-simd-控制">3. 明確的 SIMD 控制</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use packed_simd_2::*;

pub struct PriceProcessor;

impl PriceProcessor {
    // 批量處理價格更新
    pub fn update_prices_batch(
        bid_prices: &amp;mut [f32],
        ask_prices: &amp;mut [f32],
        adjustment: f32
    ) {
        const LANES: usize = 8;
        let adjustment_vec = f32x8::splat(adjustment);
        
        let chunks = bid_prices.chunks_exact_mut(LANES)
            .zip(ask_prices.chunks_exact_mut(LANES));
        
        for (bid_chunk, ask_chunk) in chunks {
            let bid_vec = f32x8::from_slice_unaligned(bid_chunk);
            let ask_vec = f32x8::from_slice_unaligned(ask_chunk);
            
            let new_bid = bid_vec * adjustment_vec;
            let new_ask = ask_vec * adjustment_vec;
            
            new_bid.write_to_slice_unaligned(bid_chunk);
            new_ask.write_to_slice_unaligned(ask_chunk);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="記憶體管理與優化"><a class="header" href="#記憶體管理與優化">記憶體管理與優化</a></h2>
<h3 id="1-自定義分配器"><a class="header" href="#1-自定義分配器">1. 自定義分配器</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::alloc::{GlobalAlloc, Layout};
use jemallocator::Jemalloc;

// 使用 jemalloc 提高性能
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

// 或者創建專用的內存池
pub struct PoolAllocator {
    pool: Vec&lt;u8&gt;,
    offset: AtomicUsize,
}

impl PoolAllocator {
    pub fn new(size: usize) -&gt; Self {
        let mut pool = Vec::with_capacity(size);
        unsafe { pool.set_len(size); }
        
        Self {
            pool,
            offset: AtomicUsize::new(0),
        }
    }
    
    pub fn allocate(&amp;self, size: usize) -&gt; *mut u8 {
        let offset = self.offset.fetch_add(size, Ordering::SeqCst);
        if offset + size &gt; self.pool.len() {
            panic!("Pool exhausted");
        }
        unsafe { self.pool.as_ptr().add(offset) as *mut u8 }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-大頁面支持"><a class="header" href="#2-大頁面支持">2. 大頁面支持</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nix::sys::mman::{mmap, MapFlags, ProtFlags};

pub fn allocate_huge_pages(size: usize) -&gt; *mut u8 {
    let addr = std::ptr::null_mut();
    let length = size;
    let prot = ProtFlags::PROT_READ | ProtFlags::PROT_WRITE;
    let flags = MapFlags::MAP_PRIVATE | 
                MapFlags::MAP_ANONYMOUS | 
                MapFlags::MAP_HUGETLB;
    
    unsafe {
        mmap(addr, length, prot, flags, -1, 0)
            .expect("Failed to allocate huge pages")
            as *mut u8
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="並發模型"><a class="header" href="#並發模型">並發模型</a></h2>
<h3 id="1-無鎖數據結構"><a class="header" href="#1-無鎖數據結構">1. 無鎖數據結構</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crossbeam::queue::ArrayQueue;
use std::sync::Arc;

pub struct OrderProcessor {
    queue: Arc&lt;ArrayQueue&lt;Order&gt;&gt;,
}

impl OrderProcessor {
    pub fn new(capacity: usize) -&gt; Self {
        Self {
            queue: Arc::new(ArrayQueue::new(capacity)),
        }
    }
    
    // 生產者
    pub fn submit_order(&amp;self, order: Order) -&gt; Result&lt;(), Order&gt; {
        self.queue.push(order)
    }
    
    // 消費者
    pub fn process_orders(&amp;self) {
        while let Some(order) = self.queue.pop() {
            self.handle_order(order);
        }
    }
    
    fn handle_order(&amp;self, order: Order) {
        // 處理訂單
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-高性能異步-io"><a class="header" href="#2-高性能異步-io">2. 高性能異步 IO</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::UdpSocket;
use bytes::BytesMut;

pub struct MarketDataReceiver {
    socket: UdpSocket,
    buffer: BytesMut,
}

impl MarketDataReceiver {
    pub async fn new(addr: &amp;str) -&gt; std::io::Result&lt;Self&gt; {
        let socket = UdpSocket::bind(addr).await?;
        
        // 設置接收緩衝區大小
        socket.set_recv_buffer_size(8 * 1024 * 1024)?;
        
        Ok(Self {
            socket,
            buffer: BytesMut::with_capacity(65536),
        })
    }
    
    pub async fn receive_data(&amp;mut self) -&gt; std::io::Result&lt;MarketData&gt; {
        self.buffer.clear();
        let n = self.socket.recv_buf(&amp;mut self.buffer).await?;
        
        // 零拷貝解析
        let data = self.parse_market_data(&amp;self.buffer[..n]);
        Ok(data)
    }
    
    fn parse_market_data(&amp;self, bytes: &amp;[u8]) -&gt; MarketData {
        // 直接從 bytes 解析，避免拷貝
        unsafe {
            std::ptr::read(bytes.as_ptr() as *const MarketData)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="實戰範例"><a class="header" href="#實戰範例">實戰範例</a></h2>
<h3 id="完整的-hft-組件示例"><a class="header" href="#完整的-hft-組件示例">完整的 HFT 組件示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use parking_lot::RwLock;
use ahash::AHashMap;

#[derive(Clone, Copy)]
#[repr(C, packed)]
pub struct MarketData {
    pub timestamp: u64,
    pub symbol_id: u32,
    pub bid_price: f64,
    pub ask_price: f64,
    pub bid_size: u32,
    pub ask_size: u32,
}

pub struct TradingEngine {
    // 使用 parking_lot 的 RwLock（比標準庫快）
    order_book: RwLock&lt;AHashMap&lt;u32, OrderBook&gt;&gt;,
    
    // 預分配的內存池
    memory_pool: PoolAllocator,
    
    // 性能統計
    latency_histogram: hdrhistogram::Histogram&lt;u64&gt;,
}

impl TradingEngine {
    pub fn new() -&gt; Self {
        Self {
            order_book: RwLock::new(AHashMap::new()),
            memory_pool: PoolAllocator::new(1024 * 1024 * 1024), // 1GB
            latency_histogram: hdrhistogram::Histogram::new(5).unwrap(),
        }
    }
    
    #[inline(always)]
    pub fn process_market_data(&amp;mut self, data: &amp;MarketData) {
        let start = Instant::now();
        
        // 關鍵路徑：避免任何分配
        let book = self.order_book.read();
        if let Some(orders) = book.get(&amp;data.symbol_id) {
            // 處理訂單匹配
            self.match_orders(orders, data);
        }
        
        // 記錄延遲（在非關鍵路徑）
        let latency = start.elapsed().as_nanos() as u64;
        self.latency_histogram.record(latency).ok();
    }
    
    #[inline(always)]
    fn match_orders(&amp;self, orders: &amp;OrderBook, data: &amp;MarketData) {
        // 訂單匹配邏輯
        // 使用 likely/unlikely 提示分支預測
        if likely(data.bid_price &gt; 0.0) {
            // 快速路徑
        }
    }
}

// 分支預測提示
#[inline(always)]
fn likely(b: bool) -&gt; bool {
    // 使用 LLVM 內建函數
    unsafe { std::intrinsics::likely(b) }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="編譯優化設置"><a class="header" href="#編譯優化設置">編譯優化設置</a></h3>
<pre><code class="language-toml"># Cargo.toml
[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
panic = "abort"
strip = true

# 針對特定 CPU 優化
[build]
rustflags = [
    "-C", "target-cpu=native",
    "-C", "target-feature=+avx2,+fma",
    "-C", "link-arg=-fuse-ld=lld",
]

# 使用高性能依賴
[dependencies]
parking_lot = "0.12"     # 更快的鎖
ahash = "0.8"            # 更快的哈希
crossbeam = "0.8"        # 無鎖數據結構
jemallocator = "0.5"     # 更好的分配器
packed_simd_2 = "0.3"    # SIMD 支持
tokio = { version = "1", features = ["net", "rt-multi-thread"] }
</code></pre>
<h2 id="rust-特有優勢總結"><a class="header" href="#rust-特有優勢總結">Rust 特有優勢總結</a></h2>
<h3 id="相比-c-的優點"><a class="header" href="#相比-c-的優點">相比 C++ 的優點</a></h3>
<ol>
<li>
<p><strong>記憶體安全保證</strong></p>
<ul>
<li>編譯時防止 data race</li>
<li>無需擔心 use-after-free</li>
<li>更容易寫出正確的並發代碼</li>
</ul>
</li>
<li>
<p><strong>更好的工具鏈</strong></p>
<ul>
<li>Cargo 統一的構建系統</li>
<li>內建的測試框架</li>
<li>優秀的錯誤訊息</li>
</ul>
</li>
<li>
<p><strong>現代語言特性</strong></p>
<ul>
<li>Pattern matching</li>
<li>Option/Result 類型</li>
<li>Trait system</li>
</ul>
</li>
</ol>
<h3 id="性能考量"><a class="header" href="#性能考量">性能考量</a></h3>
<div class="table-wrapper"><table><thead><tr><th>方面</th><th>Rust 實現方式</th></tr></thead><tbody>
<tr><td><strong>零成本抽象</strong></td><td>內聯、單態化</td></tr>
<tr><td><strong>記憶體佈局</strong></td><td><code>#[repr(C)]</code> 精確控制</td></tr>
<tr><td><strong>SIMD</strong></td><td>portable_simd、auto-vectorization</td></tr>
<tr><td><strong>並發</strong></td><td>Send/Sync traits、無鎖結構</td></tr>
<tr><td><strong>系統調用</strong></td><td>直接 FFI 調用</td></tr>
</tbody></table>
</div>
<h3 id="最佳實踐"><a class="header" href="#最佳實踐">最佳實踐</a></h3>
<ol>
<li>
<p><strong>使用 <code>unsafe</code> 進行關鍵優化</strong></p>
<ul>
<li>在熱路徑上謹慎使用</li>
<li>封裝在安全的 API 後面</li>
</ul>
</li>
<li>
<p><strong>利用 Rust 的零成本抽象</strong></p>
<ul>
<li>迭代器通常比手寫循環快</li>
<li>使用泛型實現編譯時優化</li>
</ul>
</li>
<li>
<p><strong>選擇合適的數據結構</strong></p>
<ul>
<li><code>Vec</code> 用於連續數據</li>
<li><code>SmallVec</code> 用於小數據避免堆分配</li>
<li>無鎖結構用於高並發</li>
</ul>
</li>
</ol>
<h2 id="結論"><a class="header" href="#結論">結論</a></h2>
<p>Rust 在 HFT 領域是 C++ 的有力競爭者，提供了：</p>
<ul>
<li>✅ 相同的底層控制能力</li>
<li>✅ 更好的記憶體安全保證</li>
<li>✅ 現代的工具鏈和生態系統</li>
<li>✅ 零成本抽象</li>
</ul>
<p>主要挑戰是：</p>
<ul>
<li>⚠️ 生態系統相對年輕</li>
<li>⚠️ 學習曲線較陡</li>
<li>⚠️ 某些底層 API 需要 unsafe</li>
</ul>
<p>總的來說，Rust 完全可以達到 C++ 的性能水平，同時提供更好的安全性和開發體驗。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hft/hft-cpp-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../hft/why-hft-avoids-go.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hft/hft-cpp-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../hft/why-hft-avoids-go.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
