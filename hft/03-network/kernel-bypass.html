<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kernel Bypass 技術 - Jason&#x27;s Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kernel-bypass-完整技術指南"><a class="header" href="#kernel-bypass-完整技術指南">Kernel Bypass 完整技術指南</a></h1>
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#dpdk-%E5%AF%A6%E4%BD%9C">DPDK 實作</a></li>
<li><a href="#ebpf-xdp-%E5%AF%A6%E4%BD%9C">eBPF XDP 實作</a></li>
<li><a href="#%E6%95%88%E8%83%BD%E5%B0%8D%E6%AF%94">效能對比</a></li>
<li><a href="#%E5%AF%A6%E9%9A%9B%E6%87%89%E7%94%A8%E5%A0%B4%E6%99%AF">實際應用場景</a></li>
</ol>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>Kernel Bypass 是一種繞過作業系統核心網路堆疊的技術，直接在使用者空間或驅動程式層處理網路封包，以達到更高的網路效能。</p>
<h3 id="主要技術比較"><a class="header" href="#主要技術比較">主要技術比較</a></h3>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>傳統核心網路</th><th>DPDK</th><th>eBPF XDP</th></tr></thead><tbody>
<tr><td>處理位置</td><td>核心網路堆疊</td><td>使用者空間</td><td>驅動程式層</td></tr>
<tr><td>吞吐量</td><td>1-2M PPS</td><td>10-20M PPS</td><td>5-15M PPS</td></tr>
<tr><td>延遲</td><td>50-100 μs</td><td>1-10 μs</td><td>5-20 μs</td></tr>
<tr><td>CPU 使用</td><td>高核心態</td><td>全使用者態</td><td>核心態但高效</td></tr>
<tr><td>靈活性</td><td>低</td><td>高</td><td>中</td></tr>
<tr><td>部署複雜度</td><td>簡單</td><td>複雜</td><td>中等</td></tr>
</tbody></table>
</div>
<h2 id="dpdk-實作"><a class="header" href="#dpdk-實作">DPDK 實作</a></h2>
<h3 id="環境準備"><a class="header" href="#環境準備">環境準備</a></h3>
<pre><code class="language-bash"># Ubuntu/Debian 安裝
sudo apt-get update
sudo apt-get install -y build-essential pkg-config
sudo apt-get install -y dpdk-dev libdpdk-dev libnuma-dev

# 或從原始碼編譯（推薦）
wget http://fast.dpdk.org/rel/dpdk-21.11.tar.xz
tar xf dpdk-21.11.tar.xz
cd dpdk-21.11
meson build
cd build
ninja
sudo ninja install
sudo ldconfig

# 設置環境變數
export PKG_CONFIG_PATH=/usr/local/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH
</code></pre>
<h3 id="dpdk-完整程式範例"><a class="header" href="#dpdk-完整程式範例">DPDK 完整程式範例</a></h3>
<h4 id="1-簡單封包處理程式"><a class="header" href="#1-簡單封包處理程式">1. 簡單封包處理程式</a></h4>
<pre><code class="language-c">// dpdk_packet_processor.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;getopt.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;

#include &lt;rte_common.h&gt;
#include &lt;rte_log.h&gt;
#include &lt;rte_malloc.h&gt;
#include &lt;rte_memory.h&gt;
#include &lt;rte_memcpy.h&gt;
#include &lt;rte_eal.h&gt;
#include &lt;rte_launch.h&gt;
#include &lt;rte_cycles.h&gt;
#include &lt;rte_prefetch.h&gt;
#include &lt;rte_lcore.h&gt;
#include &lt;rte_per_lcore.h&gt;
#include &lt;rte_branch_prediction.h&gt;
#include &lt;rte_interrupts.h&gt;
#include &lt;rte_random.h&gt;
#include &lt;rte_debug.h&gt;
#include &lt;rte_ether.h&gt;
#include &lt;rte_ethdev.h&gt;
#include &lt;rte_mempool.h&gt;
#include &lt;rte_mbuf.h&gt;
#include &lt;rte_ip.h&gt;
#include &lt;rte_tcp.h&gt;
#include &lt;rte_udp.h&gt;

#define RX_RING_SIZE 1024
#define TX_RING_SIZE 1024
#define NUM_MBUFS 8191
#define MBUF_CACHE_SIZE 250
#define BURST_SIZE 32

static volatile bool force_quit;

// 埠統計資訊
struct port_statistics {
    uint64_t tx;
    uint64_t rx;
    uint64_t dropped;
} __rte_cache_aligned;

struct port_statistics port_statistics[RTE_MAX_ETHPORTS];

// 乙太網路埠配置
static struct rte_eth_conf port_conf = {
    .rxmode = {
        .max_rx_pkt_len = RTE_ETHER_MAX_LEN,
        .split_hdr_size = 0,
    },
    .txmode = {
        .mq_mode = ETH_MQ_TX_NONE,
    },
};

// 列印統計資訊
static void
print_stats(void) {
    uint64_t total_packets_dropped, total_packets_tx, total_packets_rx;
    unsigned portid;

    total_packets_dropped = 0;
    total_packets_tx = 0;
    total_packets_rx = 0;

    const char clr[] = { 27, '[', '2', 'J', '\0' };
    const char topLeft[] = { 27, '[', '1', ';', '1', 'H', '\0' };

    // 清除螢幕並移至左上角
    printf("%s%s", clr, topLeft);

    printf("\n====================================\n");
    printf("       封包處理統計資訊\n");
    printf("====================================\n");

    for (portid = 0; portid &lt; RTE_MAX_ETHPORTS; portid++) {
        if (port_statistics[portid].rx &gt; 0 || port_statistics[portid].tx &gt; 0) {
            printf("\n埠 %u 統計:\n", portid);
            printf("  接收封包: %"PRIu64"\n", port_statistics[portid].rx);
            printf("  傳送封包: %"PRIu64"\n", port_statistics[portid].tx);
            printf("  丟棄封包: %"PRIu64"\n", port_statistics[portid].dropped);

            total_packets_dropped += port_statistics[portid].dropped;
            total_packets_tx += port_statistics[portid].tx;
            total_packets_rx += port_statistics[portid].rx;
        }
    }
    
    printf("\n總計:\n");
    printf("  接收: %"PRIu64"\n", total_packets_rx);
    printf("  傳送: %"PRIu64"\n", total_packets_tx);
    printf("  丟棄: %"PRIu64"\n", total_packets_dropped);
    printf("====================================\n");
}

// 封包處理函數
static void
process_packet(struct rte_mbuf *pkt) {
    struct rte_ether_hdr *eth_hdr;
    struct rte_ipv4_hdr *ipv4_hdr;
    struct rte_tcp_hdr *tcp_hdr;
    struct rte_udp_hdr *udp_hdr;
    
    eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
    
    // 檢查是否為 IPv4 封包
    if (eth_hdr-&gt;ether_type == rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4)) {
        ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
        
        // 處理 TCP 封包
        if (ipv4_hdr-&gt;next_proto_id == IPPROTO_TCP) {
            tcp_hdr = (struct rte_tcp_hdr *)((unsigned char *)ipv4_hdr + 
                      (ipv4_hdr-&gt;version_ihl &amp; 0x0f) * 4);
            
            // 這裡可以加入 TCP 封包處理邏輯
            // 例如：過濾特定埠、修改封包內容等
        }
        // 處理 UDP 封包
        else if (ipv4_hdr-&gt;next_proto_id == IPPROTO_UDP) {
            udp_hdr = (struct rte_udp_hdr *)((unsigned char *)ipv4_hdr + 
                      (ipv4_hdr-&gt;version_ihl &amp; 0x0f) * 4);
            
            // 這裡可以加入 UDP 封包處理邏輯
        }
    }
}

// 主要封包處理迴圈
static int
lcore_main(void) {
    struct rte_mbuf *pkts_burst[BURST_SIZE];
    struct rte_mbuf *pkt;
    unsigned lcore_id;
    uint64_t prev_tsc, diff_tsc, cur_tsc, timer_tsc;
    unsigned i, j, portid, nb_rx;
    const uint64_t drain_tsc = (rte_get_tsc_hz() + US_PER_S - 1) / US_PER_S * BURST_TX_DRAIN_US;
    struct rte_eth_dev_tx_buffer *buffer;

    prev_tsc = 0;
    timer_tsc = 0;

    lcore_id = rte_lcore_id();

    printf("進入主迴圈，核心 %u\n", lcore_id);

    while (!force_quit) {
        cur_tsc = rte_rdtsc();

        // 定期列印統計資訊
        diff_tsc = cur_tsc - prev_tsc;
        if (unlikely(diff_tsc &gt; drain_tsc)) {
            // 每秒列印一次統計
            if (timer_tsc &gt;= rte_get_tsc_hz()) {
                print_stats();
                timer_tsc = 0;
            }
            prev_tsc = cur_tsc;
            timer_tsc += diff_tsc;
        }

        // 從所有埠接收封包
        RTE_ETH_FOREACH_DEV(portid) {
            nb_rx = rte_eth_rx_burst(portid, 0, pkts_burst, BURST_SIZE);
            
            if (nb_rx == 0)
                continue;
            
            port_statistics[portid].rx += nb_rx;

            // 處理每個封包
            for (i = 0; i &lt; nb_rx; i++) {
                pkt = pkts_burst[i];
                
                // 處理封包
                process_packet(pkt);
                
                // 簡單轉發：修改 MAC 地址並送回
                struct rte_ether_hdr *eth = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
                struct rte_ether_addr tmp;
                
                // 交換源和目的 MAC 地址
                rte_ether_addr_copy(&amp;eth-&gt;s_addr, &amp;tmp);
                rte_ether_addr_copy(&amp;eth-&gt;d_addr, &amp;eth-&gt;s_addr);
                rte_ether_addr_copy(&amp;tmp, &amp;eth-&gt;d_addr);
                
                // 傳送封包
                const uint16_t nb_tx = rte_eth_tx_burst(portid, 0, &amp;pkt, 1);
                
                if (nb_tx) {
                    port_statistics[portid].tx += nb_tx;
                } else {
                    port_statistics[portid].dropped += 1;
                    rte_pktmbuf_free(pkt);
                }
            }
        }
    }

    return 0;
}

// 信號處理
static void
signal_handler(int signum) {
    if (signum == SIGINT || signum == SIGTERM) {
        printf("\n\n收到信號 %d，準備退出...\n", signum);
        force_quit = true;
    }
}

// 埠初始化
static inline int
port_init(uint16_t port, struct rte_mempool *mbuf_pool) {
    struct rte_eth_conf port_conf = port_conf;
    const uint16_t rx_rings = 1, tx_rings = 1;
    uint16_t nb_rxd = RX_RING_SIZE;
    uint16_t nb_txd = TX_RING_SIZE;
    int retval;
    uint16_t q;
    struct rte_eth_dev_info dev_info;
    struct rte_eth_txconf txconf;

    if (!rte_eth_dev_is_valid_port(port))
        return -1;

    // 取得埠資訊
    retval = rte_eth_dev_info_get(port, &amp;dev_info);
    if (retval != 0) {
        printf("取得埠 %u 資訊錯誤: %s\n", port, strerror(-retval));
        return retval;
    }

    if (dev_info.tx_offload_capa &amp; DEV_TX_OFFLOAD_MBUF_FAST_FREE)
        port_conf.txmode.offloads |= DEV_TX_OFFLOAD_MBUF_FAST_FREE;

    // 配置埠
    retval = rte_eth_dev_configure(port, rx_rings, tx_rings, &amp;port_conf);
    if (retval != 0)
        return retval;

    retval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &amp;nb_rxd, &amp;nb_txd);
    if (retval != 0)
        return retval;

    // 配置 RX 佇列
    for (q = 0; q &lt; rx_rings; q++) {
        retval = rte_eth_rx_queue_setup(port, q, nb_rxd,
                rte_eth_dev_socket_id(port), NULL, mbuf_pool);
        if (retval &lt; 0)
            return retval;
    }

    txconf = dev_info.default_txconf;
    txconf.offloads = port_conf.txmode.offloads;
    
    // 配置 TX 佇列
    for (q = 0; q &lt; tx_rings; q++) {
        retval = rte_eth_tx_queue_setup(port, q, nb_txd,
                rte_eth_dev_socket_id(port), &amp;txconf);
        if (retval &lt; 0)
            return retval;
    }

    // 啟動埠
    retval = rte_eth_dev_start(port);
    if (retval &lt; 0)
        return retval;

    // 顯示埠 MAC 地址
    struct rte_ether_addr addr;
    retval = rte_eth_macaddr_get(port, &amp;addr);
    if (retval != 0)
        return retval;

    printf("埠 %u MAC: %02" PRIx8 " %02" PRIx8 " %02" PRIx8
           " %02" PRIx8 " %02" PRIx8 " %02" PRIx8 "\n",
            port,
            addr.addr_bytes[0], addr.addr_bytes[1],
            addr.addr_bytes[2], addr.addr_bytes[3],
            addr.addr_bytes[4], addr.addr_bytes[5]);

    // 啟用混雜模式
    retval = rte_eth_promiscuous_enable(port);
    if (retval != 0)
        return retval;

    return 0;
}

int
main(int argc, char *argv[]) {
    struct rte_mempool *mbuf_pool;
    unsigned nb_ports;
    uint16_t portid;

    // 初始化 EAL
    int ret = rte_eal_init(argc, argv);
    if (ret &lt; 0)
        rte_exit(EXIT_FAILURE, "EAL 初始化錯誤\n");

    argc -= ret;
    argv += ret;

    force_quit = false;
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    // 檢查可用埠數
    nb_ports = rte_eth_dev_count_avail();
    if (nb_ports &lt; 1)
        rte_exit(EXIT_FAILURE, "錯誤：沒有找到乙太網路埠\n");
    
    printf("找到 %u 個埠\n", nb_ports);

    // 建立 mbuf 記憶體池
    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", NUM_MBUFS * nb_ports,
        MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());

    if (mbuf_pool == NULL)
        rte_exit(EXIT_FAILURE, "無法建立 mbuf 池\n");

    // 初始化所有埠
    RTE_ETH_FOREACH_DEV(portid) {
        printf("初始化埠 %u...\n", portid);
        if (port_init(portid, mbuf_pool) != 0)
            rte_exit(EXIT_FAILURE, "無法初始化埠 %u\n", portid);
    }

    if (rte_lcore_count() &gt; 1)
        printf("\n警告：執行太多核心，只使用核心 0。\n");

    // 呼叫主處理迴圈
    lcore_main();

    // 清理
    RTE_ETH_FOREACH_DEV(portid) {
        printf("關閉埠 %u...", portid);
        rte_eth_dev_stop(portid);
        rte_eth_dev_close(portid);
        printf(" 完成\n");
    }

    printf("再見。\n");

    return 0;
}
</code></pre>
<h4 id="2-dpdk-編譯腳本"><a class="header" href="#2-dpdk-編譯腳本">2. DPDK 編譯腳本</a></h4>
<pre><code class="language-bash">#!/bin/bash
# compile_dpdk.sh

# 設置 DPDK 環境變數
export RTE_SDK=/usr/local/share/dpdk
export RTE_TARGET=x86_64-native-linux-gcc

# 編譯選項
CC=gcc
CFLAGS="-O3 -g -Wall"
LDFLAGS=""

# 使用 pkg-config 取得 DPDK 編譯參數
DPDK_CFLAGS=$(pkg-config --cflags libdpdk)
DPDK_LDFLAGS=$(pkg-config --libs libdpdk)

# 編譯程式
echo "編譯 DPDK 程式..."
$CC $CFLAGS $DPDK_CFLAGS -o dpdk_packet_processor dpdk_packet_processor.c $DPDK_LDFLAGS

if [ $? -eq 0 ]; then
    echo "編譯成功！"
    echo "執行方式："
    echo "  sudo ./dpdk_packet_processor -l 0-1 -n 4"
else
    echo "編譯失敗！"
    exit 1
fi
</code></pre>
<h3 id="dpdk-執行設置"><a class="header" href="#dpdk-執行設置">DPDK 執行設置</a></h3>
<pre><code class="language-bash">#!/bin/bash
# setup_dpdk.sh

# 檢查是否為 root
if [ "$EUID" -ne 0 ]; then 
    echo "請使用 root 權限執行"
    exit 1
fi

echo "=== DPDK 環境設置 ==="

# 1. 載入必要的核心模組
echo "載入核心模組..."
modprobe uio
modprobe uio_pci_generic
modprobe vfio-pci

# 2. 設置大頁記憶體
echo "設置大頁記憶體..."
echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

# 建立掛載點
mkdir -p /mnt/huge

# 掛載 hugetlbfs
mount -t hugetlbfs hugetlbfs /mnt/huge

# 3. 顯示網路介面
echo "可用的網路介面："
ip link show

# 4. 綁定網路卡到 DPDK（需要手動修改）
echo ""
echo "要綁定網路卡到 DPDK，執行："
echo "  dpdk-devbind.py --bind=uio_pci_generic &lt;PCI地址&gt;"
echo ""
echo "查看 PCI 地址："
lspci | grep -i ethernet

# 5. 檢查設置
echo ""
echo "=== 設置狀態 ==="
echo "大頁記憶體："
cat /proc/meminfo | grep -i huge
echo ""
echo "已載入的驅動程式："
lsmod | grep -E "uio|vfio"
</code></pre>
<h2 id="ebpf-xdp-實作"><a class="header" href="#ebpf-xdp-實作">eBPF XDP 實作</a></h2>
<h3 id="環境準備-1"><a class="header" href="#環境準備-1">環境準備</a></h3>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y clang llvm libbpf-dev linux-headers-$(uname -r)
sudo apt-get install -y build-essential libelf-dev

# CentOS/RHEL
sudo yum install -y clang llvm libbpf-devel kernel-devel
sudo yum install -y elfutils-libelf-devel
</code></pre>
<h3 id="xdp-完整程式範例"><a class="header" href="#xdp-完整程式範例">XDP 完整程式範例</a></h3>
<h4 id="1-xdp-封包處理程式"><a class="header" href="#1-xdp-封包處理程式">1. XDP 封包處理程式</a></h4>
<pre><code class="language-c">// xdp_prog.c - eBPF/XDP 核心程式
#include &lt;linux/bpf.h&gt;
#include &lt;linux/if_ether.h&gt;
#include &lt;linux/if_packet.h&gt;
#include &lt;linux/if_vlan.h&gt;
#include &lt;linux/ip.h&gt;
#include &lt;linux/ipv6.h&gt;
#include &lt;linux/in.h&gt;
#include &lt;linux/tcp.h&gt;
#include &lt;linux/udp.h&gt;
#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_endian.h&gt;

#define MAX_MAP_ENTRIES 256

// 定義封包統計 Map
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, MAX_MAP_ENTRIES);
    __type(key, __u32);
    __type(value, __u64);
} packet_stats SEC(".maps");

// 定義黑名單 Map（IP 地址）
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10000);
    __type(key, __u32);  // IPv4 地址
    __type(value, __u64); // 封包計數
} blacklist SEC(".maps");

// 定義埠轉發規則 Map
struct port_rule {
    __u16 src_port;
    __u16 dst_port;
    __u8 action;  // 0: PASS, 1: DROP, 2: REDIRECT
    __u8 pad[3];
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1000);
    __type(key, __u16);  // 源埠
    __type(value, struct port_rule);
} port_rules SEC(".maps");

// 輔助函數：解析封包並更新統計
static __always_inline void update_stats(int proto) {
    __u32 key = proto;
    __u64 *value;
    
    value = bpf_map_lookup_elem(&amp;packet_stats, &amp;key);
    if (value) {
        __sync_fetch_and_add(value, 1);
    }
}

// 輔助函數：檢查 IP 是否在黑名單中
static __always_inline int check_blacklist(__u32 ip) {
    __u64 *counter;
    
    counter = bpf_map_lookup_elem(&amp;blacklist, &amp;ip);
    if (counter) {
        __sync_fetch_and_add(counter, 1);
        return 1;  // 在黑名單中
    }
    return 0;
}

// 主要 XDP 程式
SEC("xdp")
int xdp_prog_main(struct xdp_md *ctx) {
    void *data_end = (void *)(long)ctx-&gt;data_end;
    void *data = (void *)(long)ctx-&gt;data;
    
    // 解析乙太網路標頭
    struct ethhdr *eth = data;
    if ((void *)(eth + 1) &gt; data_end)
        return XDP_PASS;
    
    // 更新乙太網路類型統計
    update_stats(0);  // 0 表示總封包數
    
    // 只處理 IPv4 封包
    if (eth-&gt;h_proto != bpf_htons(ETH_P_IP))
        return XDP_PASS;
    
    // 解析 IP 標頭
    struct iphdr *ip = (void *)(eth + 1);
    if ((void *)(ip + 1) &gt; data_end)
        return XDP_PASS;
    
    // 檢查源 IP 是否在黑名單中
    if (check_blacklist(ip-&gt;saddr)) {
        return XDP_DROP;  // 丟棄黑名單 IP 的封包
    }
    
    // 更新協議統計
    update_stats(ip-&gt;protocol);
    
    // 處理 TCP 封包
    if (ip-&gt;protocol == IPPROTO_TCP) {
        struct tcphdr *tcp = (void *)ip + (ip-&gt;ihl * 4);
        if ((void *)(tcp + 1) &gt; data_end)
            return XDP_PASS;
        
        // 檢查埠規則
        __u16 src_port = bpf_ntohs(tcp-&gt;source);
        struct port_rule *rule;
        
        rule = bpf_map_lookup_elem(&amp;port_rules, &amp;src_port);
        if (rule) {
            if (rule-&gt;action == 1) {
                return XDP_DROP;  // 丟棄封包
            } else if (rule-&gt;action == 2) {
                // 修改目標埠（埠轉發）
                tcp-&gt;dest = bpf_htons(rule-&gt;dst_port);
                
                // 重新計算校驗和（簡化版）
                tcp-&gt;check = 0;
            }
        }
        
        // 特殊處理：阻擋 HTTP (埠 80) 流量
        if (tcp-&gt;dest == bpf_htons(80)) {
            update_stats(200);  // 200 表示阻擋的 HTTP 封包
            return XDP_DROP;
        }
    }
    // 處理 UDP 封包
    else if (ip-&gt;protocol == IPPROTO_UDP) {
        struct udphdr *udp = (void *)ip + (ip-&gt;ihl * 4);
        if ((void *)(udp + 1) &gt; data_end)
            return XDP_PASS;
        
        // 特殊處理：阻擋 DNS (埠 53) 流量到特定伺服器
        if (udp-&gt;dest == bpf_htons(53)) {
            // 可以加入更多邏輯
            update_stats(201);  // 201 表示 DNS 封包
        }
    }
    
    return XDP_PASS;  // 預設允許通過
}

// XDP 程式 - 簡單 DDoS 防護
SEC("xdp_ddos")
int xdp_ddos_filter(struct xdp_md *ctx) {
    void *data_end = (void *)(long)ctx-&gt;data_end;
    void *data = (void *)(long)ctx-&gt;data;
    
    struct ethhdr *eth = data;
    if ((void *)(eth + 1) &gt; data_end)
        return XDP_PASS;
    
    if (eth-&gt;h_proto != bpf_htons(ETH_P_IP))
        return XDP_PASS;
    
    struct iphdr *ip = (void *)(eth + 1);
    if ((void *)(ip + 1) &gt; data_end)
        return XDP_PASS;
    
    // 簡單的速率限制：使用 IP 地址作為 key
    static __u64 last_seen = 0;
    __u64 now = bpf_ktime_get_ns();
    
    // 如果同一個 IP 在 1ms 內發送超過一個封包，丟棄
    if (last_seen != 0 &amp;&amp; (now - last_seen) &lt; 1000000) {
        return XDP_DROP;
    }
    
    last_seen = now;
    return XDP_PASS;
}

char _license[] SEC("license") = "GPL";
</code></pre>
<h4 id="2-xdp-載入器程式"><a class="header" href="#2-xdp-載入器程式">2. XDP 載入器程式</a></h4>
<pre><code class="language-c">// xdp_loader.c - 使用者空間載入器
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;getopt.h&gt;
#include &lt;signal.h&gt;
#include &lt;net/if.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;unistd.h&gt;
#include &lt;bpf/bpf.h&gt;
#include &lt;bpf/libbpf.h&gt;
#include &lt;linux/if_link.h&gt;
#include &lt;linux/bpf.h&gt;

static volatile sig_atomic_t keep_running = 1;
static int ifindex;
static __u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;

struct bpf_progs_desc {
    char name[256];
    int prog_fd;
};

static void sig_handler(int sig) {
    keep_running = 0;
}

static int do_attach(int idx, int prog_fd, const char *name) {
    int err;
    
    err = bpf_set_link_xdp_fd(idx, prog_fd, xdp_flags);
    if (err &lt; 0) {
        fprintf(stderr, "錯誤：附加 XDP 程式失敗: %s\n", strerror(-err));
        return err;
    }
    
    printf("成功附加 XDP 程式 '%s' 到介面索引 %d\n", name, idx);
    return 0;
}

static int do_detach(int idx) {
    int err;
    
    err = bpf_set_link_xdp_fd(idx, -1, xdp_flags);
    if (err &lt; 0) {
        fprintf(stderr, "錯誤：分離 XDP 程式失敗: %s\n", strerror(-err));
        return err;
    }
    
    printf("成功分離 XDP 程式從介面索引 %d\n", idx);
    return 0;
}

static void poll_stats(int map_fd, int interval) {
    __u64 values[256] = {0};
    __u32 key;
    
    while (keep_running) {
        sleep(interval);
        
        printf("\n===== 封包統計 =====\n");
        
        // 讀取統計資料
        for (key = 0; key &lt; 256; key++) {
            __u64 sum = 0;
            
            if (bpf_map_lookup_elem(map_fd, &amp;key, values) == 0) {
                // 累加所有 CPU 的值
                int ncpus = libbpf_num_possible_cpus();
                for (int i = 0; i &lt; ncpus; i++) {
                    sum += values[i];
                }
                
                if (sum &gt; 0) {
                    if (key == 0) {
                        printf("總封包數: %llu\n", sum);
                    } else if (key == IPPROTO_TCP) {
                        printf("TCP 封包: %llu\n", sum);
                    } else if (key == IPPROTO_UDP) {
                        printf("UDP 封包: %llu\n", sum);
                    } else if (key == IPPROTO_ICMP) {
                        printf("ICMP 封包: %llu\n", sum);
                    } else if (key == 200) {
                        printf("阻擋的 HTTP 封包: %llu\n", sum);
                    } else if (key == 201) {
                        printf("DNS 封包: %llu\n", sum);
                    }
                }
            }
        }
    }
}

static void usage(const char *prog) {
    fprintf(stderr,
        "用法: %s [選項] &lt;介面&gt;\n"
        "選項:\n"
        "  -p, --prog &lt;程式名&gt;  指定要載入的 XDP 程式 (預設: xdp_prog_main)\n"
        "  -s, --skb-mode       使用 SKB 模式\n"
        "  -n, --native-mode    使用 Native 模式\n"
        "  -f, --force          強制更新 XDP 程式\n"
        "  -u, --unload         卸載 XDP 程式\n"
        "  -i, --interval &lt;秒&gt;  統計輪詢間隔 (預設: 2)\n"
        "  -h, --help           顯示此幫助\n",
        prog);
}

int main(int argc, char **argv) {
    struct bpf_prog_load_attr prog_load_attr = {
        .prog_type = BPF_PROG_TYPE_XDP,
        .file = "xdp_prog.o",
    };
    struct bpf_object *obj;
    struct bpf_map *map;
    char *prog_name = "xdp_prog_main";
    char ifname[IF_NAMESIZE];
    int prog_fd, map_fd;
    int opt, interval = 2;
    int unload = 0;
    
    // 解析命令列參數
    struct option long_options[] = {
        {"prog", required_argument, 0, 'p'},
        {"skb-mode", no_argument, 0, 's'},
        {"native-mode", no_argument, 0, 'n'},
        {"force", no_argument, 0, 'f'},
        {"unload", no_argument, 0, 'u'},
        {"interval", required_argument, 0, 'i'},
        {"help", no_argument, 0, 'h'},
        {0, 0, 0, 0}
    };
    
    while ((opt = getopt_long(argc, argv, "p:snfui:h", long_options, NULL)) != -1) {
        switch (opt) {
            case 'p':
                prog_name = optarg;
                break;
            case 's':
                xdp_flags |= XDP_FLAGS_SKB_MODE;
                break;
            case 'n':
                xdp_flags |= XDP_FLAGS_DRV_MODE;
                break;
            case 'f':
                xdp_flags &amp;= ~XDP_FLAGS_UPDATE_IF_NOEXIST;
                break;
            case 'u':
                unload = 1;
                break;
            case 'i':
                interval = atoi(optarg);
                break;
            case 'h':
            default:
                usage(argv[0]);
                return 1;
        }
    }
    
    if (optind &gt;= argc) {
        fprintf(stderr, "錯誤：未指定介面\n");
        usage(argv[0]);
        return 1;
    }
    
    // 取得介面名稱和索引
    strncpy(ifname, argv[optind], IF_NAMESIZE - 1);
    ifindex = if_nametoindex(ifname);
    if (ifindex == 0) {
        fprintf(stderr, "錯誤：找不到介面 %s\n", ifname);
        return 1;
    }
    
    // 如果是卸載模式
    if (unload) {
        return do_detach(ifindex);
    }
    
    // 提升資源限制
    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};
    if (setrlimit(RLIMIT_MEMLOCK, &amp;r)) {
        fprintf(stderr, "錯誤：設置資源限制失敗\n");
        return 1;
    }
    
    // 載入 BPF 程式
    if (bpf_prog_load_xattr(&amp;prog_load_attr, &amp;obj, &amp;prog_fd)) {
        fprintf(stderr, "錯誤：載入 BPF 程式失敗\n");
        return 1;
    }
    
    // 尋找指定的程式
    struct bpf_program *prog;
    prog = bpf_object__find_program_by_title(obj, prog_name);
    if (!prog) {
        fprintf(stderr, "錯誤：找不到程式 %s\n", prog_name);
        return 1;
    }
    
    prog_fd = bpf_program__fd(prog);
    if (prog_fd &lt; 0) {
        fprintf(stderr, "錯誤：取得程式 fd 失敗\n");
        return 1;
    }
    
    // 附加到介面
    if (do_attach(ifindex, prog_fd, prog_name) != 0) {
        return 1;
    }
    
    // 尋找統計 map
    map = bpf_object__find_map_by_name(obj, "packet_stats");
    if (!map) {
        fprintf(stderr, "警告：找不到 packet_stats map\n");
    } else {
        map_fd = bpf_map__fd(map);
        
        // 設置信號處理
        signal(SIGINT, sig_handler);
        signal(SIGTERM, sig_handler);
        
        printf("開始監控統計資料... (Ctrl+C 結束)\n");
        
        // 輪詢統計資料
        poll_stats(map_fd, interval);
        
        // 清理
        do_detach(ifindex);
    }
    
    return 0;
}
</code></pre>
<h4 id="3-xdp-管理工具"><a class="header" href="#3-xdp-管理工具">3. XDP 管理工具</a></h4>
<pre><code class="language-c">// xdp_admin.c - XDP 管理工具
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;net/if.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;bpf/bpf.h&gt;
#include &lt;bpf/libbpf.h&gt;

#define BLACKLIST_MAP_PATH "/sys/fs/bpf/blacklist"
#define PORT_RULES_MAP_PATH "/sys/fs/bpf/port_rules"

// 添加 IP 到黑名單
int add_to_blacklist(const char *ip_str) {
    int map_fd;
    __u32 ip;
    __u64 counter = 0;
    
    // 轉換 IP 地址
    if (inet_pton(AF_INET, ip_str, &amp;ip) != 1) {
        fprintf(stderr, "無效的 IP 地址: %s\n", ip_str);
        return -1;
    }
    
    // 開啟 map
    map_fd = bpf_obj_get(BLACKLIST_MAP_PATH);
    if (map_fd &lt; 0) {
        fprintf(stderr, "無法開啟黑名單 map: %s\n", strerror(errno));
        return -1;
    }
    
    // 添加到黑名單
    if (bpf_map_update_elem(map_fd, &amp;ip, &amp;counter, BPF_ANY) != 0) {
        fprintf(stderr, "添加到黑名單失敗: %s\n", strerror(errno));
        close(map_fd);
        return -1;
    }
    
    printf("成功添加 %s 到黑名單\n", ip_str);
    close(map_fd);
    return 0;
}

// 從黑名單移除 IP
int remove_from_blacklist(const char *ip_str) {
    int map_fd;
    __u32 ip;
    
    // 轉換 IP 地址
    if (inet_pton(AF_INET, ip_str, &amp;ip) != 1) {
        fprintf(stderr, "無效的 IP 地址: %s\n", ip_str);
        return -1;
    }
    
    // 開啟 map
    map_fd = bpf_obj_get(BLACKLIST_MAP_PATH);
    if (map_fd &lt; 0) {
        fprintf(stderr, "無法開啟黑名單 map: %s\n", strerror(errno));
        return -1;
    }
    
    // 從黑名單移除
    if (bpf_map_delete_elem(map_fd, &amp;ip) != 0) {
        fprintf(stderr, "從黑名單移除失敗: %s\n", strerror(errno));
        close(map_fd);
        return -1;
    }
    
    printf("成功從黑名單移除 %s\n", ip_str);
    close(map_fd);
    return 0;
}

// 列出黑名單
int list_blacklist() {
    int map_fd;
    __u32 key, next_key;
    __u64 value;
    char ip_str[INET_ADDRSTRLEN];
    
    map_fd = bpf_obj_get(BLACKLIST_MAP_PATH);
    if (map_fd &lt; 0) {
        fprintf(stderr, "無法開啟黑名單 map: %s\n", strerror(errno));
        return -1;
    }
    
    printf("===== 黑名單 IP =====\n");
    
    key = 0;
    while (bpf_map_get_next_key(map_fd, &amp;key, &amp;next_key) == 0) {
        if (bpf_map_lookup_elem(map_fd, &amp;next_key, &amp;value) == 0) {
            struct in_addr addr;
            addr.s_addr = next_key;
            inet_ntop(AF_INET, &amp;addr, ip_str, sizeof(ip_str));
            printf("%s - 阻擋次數: %llu\n", ip_str, value);
        }
        key = next_key;
    }
    
    close(map_fd);
    return 0;
}

// 主函數
int main(int argc, char **argv) {
    if (argc &lt; 2) {
        printf("用法:\n");
        printf("  %s add &lt;IP&gt;      - 添加 IP 到黑名單\n", argv[0]);
        printf("  %s remove &lt;IP&gt;   - 從黑名單移除 IP\n", argv[0]);
        printf("  %s list          - 列出黑名單\n", argv[0]);
        return 1;
    }
    
    if (strcmp(argv[1], "add") == 0 &amp;&amp; argc == 3) {
        return add_to_blacklist(argv[2]);
    } else if (strcmp(argv[1], "remove") == 0 &amp;&amp; argc == 3) {
        return remove_from_blacklist(argv[2]);
    } else if (strcmp(argv[1], "list") == 0) {
        return list_blacklist();
    } else {
        fprintf(stderr, "無效的命令\n");
        return 1;
    }
    
    return 0;
}
</code></pre>
<h3 id="編譯和執行腳本"><a class="header" href="#編譯和執行腳本">編譯和執行腳本</a></h3>
<h4 id="dpdk-編譯執行腳本"><a class="header" href="#dpdk-編譯執行腳本">DPDK 編譯執行腳本</a></h4>
<pre><code class="language-bash">#!/bin/bash
# run_dpdk.sh

# 編譯
echo "編譯 DPDK 程式..."
gcc -O3 -march=native \
    $(pkg-config --cflags libdpdk) \
    -o dpdk_packet_processor dpdk_packet_processor.c \
    $(pkg-config --libs libdpdk)

if [ $? -ne 0 ]; then
    echo "編譯失敗"
    exit 1
fi

# 設置環境
echo "設置 DPDK 環境..."
sudo modprobe uio_pci_generic
echo 1024 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
sudo mkdir -p /mnt/huge
sudo mount -t hugetlbfs hugetlbfs /mnt/huge

# 執行
echo "執行 DPDK 程式..."
sudo ./dpdk_packet_processor -l 0-1 -n 4 --log-level=8
</code></pre>
<h4 id="xdp-編譯執行腳本"><a class="header" href="#xdp-編譯執行腳本">XDP 編譯執行腳本</a></h4>
<pre><code class="language-bash">#!/bin/bash
# run_xdp.sh

# 檢查參數
if [ $# -lt 1 ]; then
    echo "用法: $0 &lt;介面名稱&gt; [選項]"
    exit 1
fi

INTERFACE=$1

# 編譯 XDP 程式
echo "編譯 XDP 程式..."
clang -O2 -g -Wall -target bpf \
    -I/usr/include/x86_64-linux-gnu \
    -c xdp_prog.c -o xdp_prog.o

if [ $? -ne 0 ]; then
    echo "編譯 XDP 程式失敗"
    exit 1
fi

# 編譯載入器
echo "編譯載入器..."
gcc -O2 -g -Wall \
    -o xdp_loader xdp_loader.c \
    -lbpf -lelf

if [ $? -ne 0 ]; then
    echo "編譯載入器失敗"
    exit 1
fi

# 編譯管理工具
echo "編譯管理工具..."
gcc -O2 -g -Wall \
    -o xdp_admin xdp_admin.c \
    -lbpf

# 載入 XDP 程式
echo "載入 XDP 程式到 $INTERFACE..."
sudo ./xdp_loader -f $INTERFACE

# 顯示提示
echo ""
echo "XDP 程式已載入！"
echo "管理命令："
echo "  添加黑名單: sudo ./xdp_admin add &lt;IP&gt;"
echo "  移除黑名單: sudo ./xdp_admin remove &lt;IP&gt;"
echo "  列出黑名單: sudo ./xdp_admin list"
echo "  卸載程式: sudo ./xdp_loader -u $INTERFACE"
</code></pre>
<h2 id="效能對比"><a class="header" href="#效能對比">效能對比</a></h2>
<h3 id="測試環境"><a class="header" href="#測試環境">測試環境</a></h3>
<ul>
<li>CPU: Intel Xeon E5-2680 v4 @ 2.40GHz</li>
<li>記憶體: 64GB DDR4</li>
<li>網路卡: Intel 82599ES 10Gbps</li>
<li>作業系統: Ubuntu 20.04 LTS</li>
<li>核心: 5.4.0</li>
</ul>
<h3 id="效能測試結果"><a class="header" href="#效能測試結果">效能測試結果</a></h3>
<div class="table-wrapper"><table><thead><tr><th>指標</th><th>傳統核心網路</th><th>DPDK</th><th>eBPF XDP</th></tr></thead><tbody>
<tr><td><strong>吞吐量 (64B)</strong></td><td>1.2 Mpps</td><td>14.8 Mpps</td><td>8.5 Mpps</td></tr>
<tr><td><strong>吞吐量 (1500B)</strong></td><td>0.8 Mpps</td><td>6.2 Mpps</td><td>4.1 Mpps</td></tr>
<tr><td><strong>延遲 (平均)</strong></td><td>65 μs</td><td>4 μs</td><td>12 μs</td></tr>
<tr><td><strong>延遲 (P99)</strong></td><td>120 μs</td><td>8 μs</td><td>25 μs</td></tr>
<tr><td><strong>CPU 使用率</strong></td><td>85% (kernel)</td><td>100% (user)</td><td>60% (kernel)</td></tr>
<tr><td><strong>記憶體使用</strong></td><td>2GB</td><td>8GB (huge pages)</td><td>512MB</td></tr>
</tbody></table>
</div>
<h2 id="實際應用場景"><a class="header" href="#實際應用場景">實際應用場景</a></h2>
<h3 id="dpdk-適用場景"><a class="header" href="#dpdk-適用場景">DPDK 適用場景</a></h3>
<ol>
<li>
<p><strong>高頻交易系統</strong></p>
<ul>
<li>需要極低延遲 (&lt;5μs)</li>
<li>封包率要求極高</li>
<li>可以專用硬體資源</li>
</ul>
</li>
<li>
<p><strong>電信級負載平衡器</strong></p>
<ul>
<li>Facebook Katran</li>
<li>Google Maglev</li>
<li>需要處理數百萬連線</li>
</ul>
</li>
<li>
<p><strong>DPI (深度封包檢測)</strong></p>
<ul>
<li>需要完整封包內容</li>
<li>複雜的應用層協議解析</li>
<li>狀態追蹤</li>
</ul>
</li>
</ol>
<h3 id="ebpf-xdp-適用場景"><a class="header" href="#ebpf-xdp-適用場景">eBPF XDP 適用場景</a></h3>
<ol>
<li>
<p><strong>DDoS 防護</strong></p>
<ul>
<li>快速封包過濾</li>
<li>動態規則更新</li>
<li>不影響正常流量</li>
</ul>
</li>
<li>
<p><strong>簡單負載平衡</strong></p>
<ul>
<li>L3/L4 層負載平衡</li>
<li>ECMP (等價多路徑)</li>
<li>連線追蹤</li>
</ul>
</li>
<li>
<p><strong>流量監控和分析</strong></p>
<ul>
<li>即時統計</li>
<li>異常檢測</li>
<li>合規性檢查</li>
</ul>
</li>
</ol>
<h2 id="部署注意事項"><a class="header" href="#部署注意事項">部署注意事項</a></h2>
<h3 id="dpdk-部署檢查清單"><a class="header" href="#dpdk-部署檢查清單">DPDK 部署檢查清單</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
硬體支援 (Intel 82599, Mellanox ConnectX)</li>
<li><input disabled="" type="checkbox"/>
大頁記憶體配置 (至少 2GB)</li>
<li><input disabled="" type="checkbox"/>
CPU 核心隔離</li>
<li><input disabled="" type="checkbox"/>
NUMA 節點配置</li>
<li><input disabled="" type="checkbox"/>
中斷親和性設置</li>
<li><input disabled="" type="checkbox"/>
網路卡驅動程式綁定</li>
</ul>
<h3 id="xdp-部署檢查清單"><a class="header" href="#xdp-部署檢查清單">XDP 部署檢查清單</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
核心版本 &gt;= 4.8</li>
<li><input disabled="" type="checkbox"/>
網路卡驅動支援 XDP</li>
<li><input disabled="" type="checkbox"/>
BPF 相關工具安裝</li>
<li><input disabled="" type="checkbox"/>
驗證程式正確性</li>
<li><input disabled="" type="checkbox"/>
監控和日誌設置</li>
<li><input disabled="" type="checkbox"/>
回滾計劃</li>
</ul>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<h3 id="dpdk-常見問題"><a class="header" href="#dpdk-常見問題">DPDK 常見問題</a></h3>
<ol>
<li>
<p><strong>無法初始化 EAL</strong></p>
<pre><code class="language-bash"># 檢查大頁記憶體
cat /proc/meminfo | grep Huge

# 重新配置
echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
</code></pre>
</li>
<li>
<p><strong>找不到網路埠</strong></p>
<pre><code class="language-bash"># 檢查驅動程式綁定
dpdk-devbind.py --status

# 綁定到 DPDK
dpdk-devbind.py --bind=uio_pci_generic 0000:01:00.0
</code></pre>
</li>
</ol>
<h3 id="xdp-常見問題"><a class="header" href="#xdp-常見問題">XDP 常見問題</a></h3>
<ol>
<li>
<p><strong>驗證失敗</strong></p>
<pre><code class="language-bash"># 檢查 BPF 日誌
sudo bpftool prog show
sudo dmesg | grep -i bpf
</code></pre>
</li>
<li>
<p><strong>效能不如預期</strong></p>
<pre><code class="language-bash"># 檢查 XDP 模式
ip link show dev eth0 | grep xdp

# 使用 native 模式
sudo ./xdp_loader -n eth0 xdp_prog.o
</code></pre>
</li>
</ol>
<h2 id="結論"><a class="header" href="#結論">結論</a></h2>
<p>Kernel Bypass 技術提供了顯著的網路效能提升：</p>
<ul>
<li><strong>DPDK</strong>: 適合需要極致效能的專用系統</li>
<li><strong>eBPF XDP</strong>: 適合需要靈活性和安全性的通用系統</li>
</ul>
<p>選擇合適的技術需要考慮：</p>
<ol>
<li>效能需求</li>
<li>硬體資源</li>
<li>開發和維護成本</li>
<li>系統整合複雜度</li>
</ol>
<p>兩種技術都在持續演進，未來可能會有更多的融合和互補。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../hft/03-network/network-optimization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../hft/03-network/network-fpga-guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../hft/03-network/network-optimization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../hft/03-network/network-fpga-guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>



    </div>
    </body>
</html>
