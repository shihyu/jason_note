<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高頻交易系統完整指南 - Jason Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="高頻交易系統完整指南"><a class="header" href="#高頻交易系統完整指南">高頻交易系統完整指南</a></h1>
<h2 id="hft-os-調校--開源項目--台灣市場實踐"><a class="header" href="#hft-os-調校--開源項目--台灣市場實踐">HFT OS 調校 + 開源項目 + 台灣市場實踐</a></h2>
<hr />
<h2 id="目錄"><a class="header" href="#目錄">目錄</a></h2>
<ol>
<li><a href="#hft-%E7%B3%BB%E7%B5%B1-os-%E8%AA%BF%E6%A0%A1%E6%A0%B8%E5%BF%83">HFT 系統 OS 調校核心</a></li>
<li><a href="#github-%E9%96%8B%E6%BA%90%E9%A0%85%E7%9B%AE%E6%8E%A8%E8%96%A6">GitHub 開源項目推薦</a></li>
<li><a href="#%E5%8F%B0%E7%81%A3%E5%B8%82%E5%A0%B4%E5%85%B7%E9%AB%94%E5%AF%A6%E8%B8%90%E8%A7%A3%E5%B0%81%E5%8C%85--%E6%94%B6%E5%A0%B1%E5%83%B9">台灣市場具體實踐：解封包 &amp; 收報價</a></li>
<li><a href="#%E6%95%88%E8%83%BD%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7">效能測試工具</a></li>
<li><a href="#%E8%A1%93%E8%AA%9E%E9%80%9F%E6%9F%A5%E8%A1%A8">術語速查表</a></li>
</ol>
<hr />
<h2 id="hft-系統-os-調校核心"><a class="header" href="#hft-系統-os-調校核心">HFT 系統 OS 調校核心</a></h2>
<h3 id="背景"><a class="header" href="#背景">背景</a></h3>
<p>高頻量化交易（HFT）是奈秒級戰爭。要從毫秒精度（傳統）降到微秒精度（HFT），必須馴服：</p>
<ul>
<li>作業系統排程不確定性</li>
<li>硬體資源爭用（超執行緒、快取、NUMA）</li>
<li>傳統 I/O 瓶頸</li>
</ul>
<p><strong>目標</strong>：將關鍵路徑延遲從 ±50μs 壓縮到 ±1μs，平均延遲 &lt;20μs。</p>
<h3 id="1-核心隔離消除資源競爭"><a class="header" href="#1-核心隔離消除資源競爭">1. 核心隔離：消除資源競爭</a></h3>
<h4 id="11-停用超執行緒--cpu-pinning"><a class="header" href="#11-停用超執行緒--cpu-pinning">1.1 停用超執行緒 &amp; CPU Pinning</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>超執行緒（HT）將實體核模擬為 2 個邏輯核，共享執行單元和 L1/L2 快取</li>
<li>兄弟執行緒的 AVX 計算會完全佔用浮點單元，導致交易線程被阻塞</li>
<li>快取汙染：兄弟線程的資料會驅逐你的熱點數據</li>
</ul>
<p><strong>實測結果</strong>：停用 HT 可降低延遲 22%，更重要的是大幅降低 Jitter。</p>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 檢視實體核拓撲
lscpu -p | grep -v '#' | awk -F, '{print $1,$3}' | sort -t, -k2n

# 綁定策略進程到實體核 8-15（跳過 HT 核）
taskset -c 8-15 ./strategy_engine
</code></pre>
<p><strong>C++ 實作</strong>：</p>
<pre><code class="language-cpp">#include &lt;sched.h&gt;
cpu_set_t cpuset;
CPU_ZERO(&amp;cpuset);
for(int i=8; i&lt;=15; i++) CPU_SET(i, &amp;cpuset);
sched_setaffinity(0, sizeof(cpuset), &amp;cpuset);
</code></pre>
<h4 id="12-中斷重定向"><a class="header" href="#12-中斷重定向">1.2 中斷重定向</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>網卡中斷預設由 CPU 0 處理</li>
<li>中斷搶佔交易線程，造成上下文切換</li>
<li>中斷程序存取記憶體會汙染 L1d 快取</li>
<li>單次中斷可增加 ~300ns 延遲</li>
</ul>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 將 eth0 中斷綁定到 CPU 16-23
IRQ=$(awk -F: '/eth0/{print $1}' /proc/interrupts | head -1)
echo "fff000" &gt; /proc/irq/$IRQ/smp_affinity
</code></pre>
<h4 id="13-核心排程隔離"><a class="header" href="#13-核心排程隔離">1.3 核心排程隔離</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>即使 CPU 綁定，核心線程（ksoftirqd、kworker）仍可能搶佔</li>
<li>時鐘中斷每 ms 檢查一次有無其他任務要執行</li>
<li>RCU 回調可能在關鍵線程上執行</li>
</ul>
<p><strong>設定方法</strong>（編輯 GRUB）：</p>
<pre><code class="language-bash"># /etc/default/grub
grub_cmdline="isolcpus=8-15 nohz_full=8-15 rcu_nocbs=8-15"

# 應用設定
sudo grub2-mkconfig -o /boot/grub2/grub.cfg
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>參數</th><th>功能</th></tr></thead><tbody>
<tr><td><code>isolcpus=8-15</code></td><td>隔離這些核心，核心調度器不會在其上運行普通進程</td></tr>
<tr><td><code>nohz_full=8-15</code></td><td>關閉時鐘中斷，讓這些核心安靜執行（無週期性中斷）</td></tr>
<tr><td><code>rcu_nocbs=8-15</code></td><td>RCU 回調卸載到其他非隔離核心</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="2-numa-記憶體最佳化"><a class="header" href="#2-numa-記憶體最佳化">2. NUMA 記憶體最佳化</a></h3>
<h4 id="21-記憶體本地化綁定"><a class="header" href="#21-記憶體本地化綁定">2.1 記憶體本地化綁定</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>NUMA 系統中，本地節點存取速度最快</li>
<li>遠端節點存取延遲高 50-100%</li>
<li>跨節點延遲不確定性很大</li>
</ul>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 啟動時綁定到 Node 0
numactl --cpunodebind=0 --membind=0 ./strategy

# 檢視 NUMA 拓撲
numactl --hardware
</code></pre>
<p><strong>程式碼控制</strong>：</p>
<pre><code class="language-cpp">#include &lt;numa.h&gt;
numa_set_localalloc();          // 優先本地分配
void* mem = numa_alloc_local(1024*1024);  // 分配本地記憶體
</code></pre>
<h4 id="22-記憶體鎖定mlock"><a class="header" href="#22-記憶體鎖定mlock">2.2 記憶體鎖定（mlock）</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>預設 OS 會根據記憶體壓力換頁到磁碟</li>
<li>執行時換入導致毫秒級不可預測停頓</li>
<li><code>mlock</code> 保證記憶體永不被換出</li>
</ul>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 增大記憶體鎖定配額（預設 64KB）
sudo sysctl vm.lock_limit_kb=1048576  # 設為 1GB
echo "vm.lock_limit_kb=1048576" &gt;&gt; /etc/sysctl.conf

# 停用交換空間
sudo swapoff -a
</code></pre>
<p><strong>程式碼實作</strong>：</p>
<pre><code class="language-cpp">#include &lt;sys/mman.h&gt;

void* allocateLockedMemory(size_t size) {
    void* mem;
    if (posix_memalign(&amp;mem, sysconf(_SC_PAGESIZE), size) != 0) {
        return nullptr;
    }
    
    if (mlock(mem, size) == -1) {
        free(mem);
        return nullptr;
    }
    
    return mem;
}
</code></pre>
<h4 id="23-大頁記憶體hugepage"><a class="header" href="#23-大頁記憶體hugepage">2.3 大頁記憶體（HugePage）</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>預設頁大小 4KB，TLB 未命中頻繁</li>
<li>大頁（2MB/1GB）使 TLB 條目覆蓋更大記憶體範圍</li>
<li>減少頁表遍歷開銷</li>
</ul>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 預留 1024 個 2MB 大頁
sudo vim /etc/sysctl.conf
vm.nr_hugepages = 1024

# 關閉透明大頁（THP）避免不確定性
sudo sh -c 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled'

# 編輯 GRUB 永久關閉 THP
# /etc/default/grub
transparent_hugepage=never
</code></pre>
<p><strong>程式碼實作</strong>：</p>
<pre><code class="language-cpp">#include &lt;sys/mman.h&gt;

void* allocateHuge(size_t size) {
    int flags = MAP_PRIVATE | MAP_ANON | MAP_HUGETLB;
    int prot = PROT_READ | PROT_WRITE;
    void* ptr = mmap(nullptr, size, prot, flags, -1, 0);
    
    if (ptr != MAP_FAILED) {
        mlock(ptr, size);  // 再加鎖
    }
    
    return ptr == MAP_FAILED ? nullptr : ptr;
}
</code></pre>
<h4 id="24-記憶體預取"><a class="header" href="#24-記憶體預取">2.4 記憶體預取</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>鎖定保證實體駐留，但虛擬到實體映射可能未建立</li>
<li>預取在初始化階段主動觸發所有缺頁中斷</li>
</ul>
<p><strong>程式碼實作</strong>：</p>
<pre><code class="language-cpp">// 手動觸發缺頁中斷
memset(lockedMem, 0, memSize);

// 預取到 L1 快取
__builtin_prefetch(lockedMem, 0, 3);
</code></pre>
<hr />
<h3 id="3-快取最佳化"><a class="header" href="#3-快取最佳化">3. 快取最佳化</a></h3>
<h4 id="31-快取隔離intel-cat"><a class="header" href="#31-快取隔離intel-cat">3.1 快取隔離（Intel CAT）</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>所有核心共享 L3 快取</li>
<li>其他核心的存取會驅逐你的快取行</li>
<li>CAT 可劃分 L3 為多個獨立區域</li>
</ul>
<p><strong>設定方法</strong>：</p>
<pre><code class="language-bash"># 安裝 Intel RDT 工具
sudo apt install intel-cmt-cat

# 驗證硬體支援
grep -E 'cat_l3' /proc/cpuinfo
pqos -d

# 設定快取隔離
sudo pqos -e 'llc:1=0xff0'   # COS1 分配中間 8 位快取
sudo pqos -a 'llc:1=1234'    # 綁定 PID 1234 到 COS1

# 監控
pqos -m all:1
</code></pre>
<h4 id="32-資料結構對齊消除偽共享"><a class="header" href="#32-資料結構對齊消除偽共享">3.2 資料結構對齊（消除偽共享）</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>快取行 64 位元組，多線程存取同一快取行內的不同變數導致效能崩潰</li>
<li>對齊至快取行可消除偽共享</li>
</ul>
<p><strong>程式碼實作</strong>：</p>
<pre><code class="language-cpp">struct __attribute__((aligned(64))) MarketData {
    std::atomic&lt;uint64_t&gt; timestamp;
    double bid_price;
    int64_t bid_qty;
    // 剩餘空間自動填充至 64 位元組
};

// 驗證對齊
static_assert(sizeof(MarketData) % 64 == 0, "Alignment failed");
</code></pre>
<h4 id="33-simd-指令加速"><a class="header" href="#33-simd-指令加速">3.3 SIMD 指令加速</a></h4>
<p><strong>為什麼</strong>：</p>
<ul>
<li>一條指令處理多個資料（e.g., AVX-512 處理 8 個浮點數同時）</li>
<li>對高頻策略的大量計算提速</li>
</ul>
<p><strong>程式碼範例</strong>：</p>
<pre><code class="language-cpp">#include &lt;immintrin.h&gt;

// 計算 8 支股票的價差（AVX-512）
__m512 calculate_spread(const float* bid, const float* ask) {
    __m512 bid_v = _mm512_loadu_ps(bid);
    __m512 ask_v = _mm512_loadu_ps(ask);
    return _mm512_sub_ps(ask_v, bid_v);
}
</code></pre>
<hr />
<h3 id="4-調校優先級策略"><a class="header" href="#4-調校優先級策略">4. 調校優先級策略</a></h3>
<div class="table-wrapper"><table><thead><tr><th>優先級</th><th>技術方向</th><th>核心價值</th><th>關鍵手段</th></tr></thead><tbody>
<tr><td>1</td><td><strong>核心隔離</strong></td><td>消除 OS 排程和硬體中斷不確定性</td><td>isolcpus、中斷重定向、CPU Pinning</td></tr>
<tr><td>2</td><td><strong>NUMA 記憶體</strong></td><td>解決跨節點延遲翻倍</td><td>numactl 綁核、hugepage、mlock</td></tr>
<tr><td>3</td><td><strong>快取控制</strong></td><td>避免共享快取爭用</td><td>CAT 隔離、資料對齐、SIMD</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="github-開源項目推薦"><a class="header" href="#github-開源項目推薦">GitHub 開源項目推薦</a></h2>
<h3 id="1-低延遲撮合引擎cc"><a class="header" href="#1-低延遲撮合引擎cc">1. 低延遲撮合引擎（C/C++）</a></h3>
<h4 id="11-rapidtrader"><a class="header" href="#11-rapidtrader">1.1 RapidTrader</a></h4>
<ul>
<li><strong>Repo</strong>: <code>jmsadair/RapidTrader</code></li>
<li><strong>語言</strong>: C++17</li>
<li><strong>特點</strong>: 低延遲撮合、lock-free 資料結構</li>
<li><strong>應用</strong>: 直接綁定到隔離核心執行</li>
</ul>
<h4 id="12-submicrotrading"><a class="header" href="#12-submicrotrading">1.2 SubMicroTrading</a></h4>
<ul>
<li><strong>Repo</strong>: <code>gsitgithub/SubMicroTrading</code></li>
<li><strong>語言</strong>: C++</li>
<li><strong>特點</strong>: Ultra-low latency algo trading framework，component-based 架構</li>
<li><strong>應用</strong>: 線程拆分設計已為 CPU pin 做好準備</li>
</ul>
<h4 id="13-其他-hft-撮合系統"><a class="header" href="#13-其他-hft-撮合系統">1.3 其他 HFT 撮合系統</a></h4>
<ul>
<li>GitHub topic: <code>hft-trading</code> (C++ 為主)</li>
<li>GitHub topic: <code>kernel-bypass</code> (kernel bypass 技術集合)</li>
</ul>
<h3 id="2-numa--hugepage--記憶體調校c--rust"><a class="header" href="#2-numa--hugepage--記憶體調校c--rust">2. NUMA / HugePage / 記憶體調校（C + Rust）</a></h3>
<h4 id="21-hugepagedemo-rust"><a class="header" href="#21-hugepagedemo-rust">2.1 HugePageDemo (Rust)</a></h4>
<ul>
<li><strong>Repo</strong>: <code>evanj/hugepagedemo</code></li>
<li><strong>內容</strong>:
<ul>
<li><code>mmap() + MAP_HUGETLB / MAP_HUGE_1GB</code> 配置</li>
<li>4K vs 2M vs 1G 頁大小的 latency/throughput benchmark</li>
<li>實測數據對比</li>
</ul>
</li>
<li><strong>應用</strong>: 直接借鑒記憶體分配和 benchmark 方法</li>
</ul>
<h4 id="22-hft-伺服器設定"><a class="header" href="#22-hft-伺服器設定">2.2 HFT 伺服器設定</a></h4>
<ul>
<li><strong>Repo</strong>: <code>twanas/hft-server-settings</code></li>
<li><strong>內容</strong>:
<ul>
<li><code>isolcpus</code> / <code>nohz_full</code> / <code>rcu_nocbs</code> 設定</li>
<li>hugepages 配置腳本</li>
<li><code>numactl</code> 綁定示例</li>
</ul>
</li>
<li><strong>應用</strong>: OS 層調校 check list</li>
</ul>
<h4 id="23-low-latency-system-學習倉庫"><a class="header" href="#23-low-latency-system-學習倉庫">2.3 Low Latency System 學習倉庫</a></h4>
<ul>
<li><strong>Repo</strong>: <code>ashavijit/Lowlatencysystem</code></li>
<li><strong>內容</strong>: Kernel bypass、NUMA、快取調校的學習資源集合</li>
<li><strong>應用</strong>: 當作你的「實作清單」延伸</li>
</ul>
<h3 id="3-kernel-bypass--dpdk--網路加速cc"><a class="header" href="#3-kernel-bypass--dpdk--網路加速cc">3. Kernel Bypass / DPDK / 網路加速（C/C++）</a></h3>
<h4 id="31-pcapplusplus"><a class="header" href="#31-pcapplusplus">3.1 PcapPlusPlus</a></h4>
<ul>
<li><strong>Repo</strong>: <code>pcapplusplus/pcapplusplus</code></li>
<li><strong>語言</strong>: C++ (封裝 DPDK C 接口)</li>
<li><strong>特點</strong>:
<ul>
<li>Kernel bypass（DPDK 驅動）收發封包</li>
<li>Zero-copy 技術</li>
<li>Polling mode driver</li>
</ul>
</li>
<li><strong>應用</strong>: 如果想先用 C++ 庫玩 DPDK 再下探純 C API</li>
</ul>
<h4 id="32-dpdk-相關專案集合"><a class="header" href="#32-dpdk-相關專案集合">3.2 DPDK 相關專案集合</a></h4>
<ul>
<li>GitHub topic: <code>dpdk</code> (眾多 C 專案)</li>
<li>包括:
<ul>
<li>L2/L3 forwarding samples</li>
<li>高性能代理</li>
<li>負載均衡器</li>
</ul>
</li>
<li><strong>關鍵特性都有</strong>: CPU pin、hugepage、NUMA aware memory pool、輪詢隊列</li>
</ul>
<h4 id="33-rust--dpdk-wrapper"><a class="header" href="#33-rust--dpdk-wrapper">3.3 Rust + DPDK Wrapper</a></h4>
<ul>
<li><code>dpdk-rs</code>、<code>capsule</code> 等 Rust DPDK wrapper</li>
<li>從 <code>dpdk</code> topic 和 <code>kernel-bypass</code> topic 中尋找</li>
<li>展示如何：
<ul>
<li>在 Rust 端封裝 unsafe DPDK C API</li>
<li>保證 zero-copy + lock-free</li>
<li>Cache line 對齐</li>
</ul>
</li>
</ul>
<h3 id="4-技術文章--調查報告"><a class="header" href="#4-技術文章--調查報告">4. 技術文章 / 調查報告</a></h3>
<h4 id="41-hardware-low-latency-techniques"><a class="header" href="#41-hardware-low-latency-techniques">4.1 Hardware Low Latency Techniques</a></h4>
<ul>
<li><strong>來源</strong>: <code>zhanghaowx.github.io/Blog-Escape/low-latency-techniques</code></li>
<li><strong>內容</strong>: Tickless kernel、CPU isolation、Hyper-threading、NUMA pinning</li>
<li><strong>應用</strong>: Cross-check 你的理解</li>
</ul>
<h4 id="42-2025-a-股低延遲技術調研"><a class="header" href="#42-2025-a-股低延遲技術調研">4.2 2025 A 股低延遲技術調研</a></h4>
<ul>
<li><strong>來源</strong>: <code>heth.ink/AShareLowLatency/</code></li>
<li><strong>內容</strong>: 市場行情解析、延遲測試、工具推薦</li>
<li><strong>應用</strong>: 對標台灣市場的技術路線</li>
</ul>
<hr />
<h2 id="台灣市場具體實踐解封包--收報價"><a class="header" href="#台灣市場具體實踐解封包--收報價">台灣市場具體實踐：解封包 &amp; 收報價</a></h2>
<h3 id="背景主機共置co-location"><a class="header" href="#背景主機共置co-location">背景：主機共置（Co-Location）</a></h3>
<p>台灣交易所（TWSE）與期貨交易所（TAIFEX）都提供主機共置服務，讓券商在交易所機房內部署伺服器，直接接收 multicast 行情。</p>
<h3 id="1-行情協議概覽"><a class="header" href="#1-行情協議概覽">1. 行情協議概覽</a></h3>
<div class="table-wrapper"><table><thead><tr><th>交易所</th><th>協議</th><th>傳輸</th><th>內容</th></tr></thead><tbody>
<tr><td><strong>TWSE</strong> (股票)</td><td>自定義電文</td><td>Multicast UDP + TCP</td><td>逐筆成交、最佳5檔、成交統計</td></tr>
<tr><td><strong>TAIFEX</strong> (期貨)</td><td>TMP (Taifex Message Protocol)</td><td>Multicast UDP + TCP</td><td>期貨逐筆、選擇權、指數</td></tr>
</tbody></table>
</div>
<p><strong>官方文件</strong>:</p>
<ul>
<li>臺灣證券交易所資訊傳輸作業手冊（定義所有電文格式）</li>
<li>臺灣期貨交易所資訊傳輸作業手冊</li>
</ul>
<h3 id="2-解封包流程"><a class="header" href="#2-解封包流程">2. 解封包流程</a></h3>
<pre><code>交易所 Multicast (224.x.x.x:port)
   ↓
券商 NIC 接收
   ↓
DPDK 或 kernel bypass 驅動
   ↓
用戶態應用（策略引擎）
   ↓
解析 TWSE 電文格式
   ↓
更新本地 orderbook / tick data
   ↓
觸發交易信號
</code></pre>
<h3 id="3-c-解封包實作框架"><a class="header" href="#3-c-解封包實作框架">3. C++ 解封包實作框架</a></h3>
<pre><code class="language-cpp">#include &lt;rte_eal.h&gt;
#include &lt;rte_ethdev.h&gt;
#include &lt;stdint.h&gt;

// 訊息類型定義（根據 TWSE 文件）
enum TWSEMessageType {
    TWSE_MSG_TRADE = 1,      // 成交訊息
    TWSE_MSG_QUOTE = 2,      // 報價（最佳5檔）
    TWSE_MSG_STAT = 3,       // 統計資訊
};

struct OrderBook {
    double bid[5], ask[5];          // 買賣5檔價格
    int64_t bid_qty[5], ask_qty[5]; // 對應量
    uint64_t timestamp;             // 奈秒級時戳
};

// 解析最佳5檔報價
void parse_quote_message(const uint8_t* payload, OrderBook&amp; book) {
    // 根據 TWSE 電文格式，位元組偏移位置
    // payload[0] = 訊息類型
    // payload[1:2] = 代碼長度
    // payload[3:8] = 股票代碼
    // payload[9:16] = 最佳買價 (8 bytes, big endian)
    // payload[17:24] = 最佳賣價
    // ...依此類推
    
    uint64_t bid_price = be64toh(*(uint64_t*)(payload + 9));
    uint64_t ask_price = be64toh(*(uint64_t*)(payload + 17));
    
    book.bid[0] = bid_price / 10000.0;  // 假設 4 位小數
    book.ask[0] = ask_price / 10000.0;
}

// HFT 主迴圈
void hft_engine() {
    OrderBook book;
    
    // 初始化 DPDK EAL
    rte_eal_init(0, nullptr);
    
    uint16_t port_id = 0;
    rte_eth_dev_start(port_id);
    
    while(trading_active) {
        // 從網卡接收 multicast 行情（32 個封包批次）
        struct rte_mbuf* pkts[32];
        uint16_t nb_rx = rte_eth_rx_burst(port_id, 0, pkts, 32);
        
        for(uint16_t i = 0; i &lt; nb_rx; i++) {
            struct rte_mbuf* pkt = pkts[i];
            
            // 去掉 L2/L3/L4 header（MAC/IP/UDP），指向 TWSE 電文
            uint8_t* payload = rte_pktmbuf_mtod_offset(pkt, uint8_t*,
                              sizeof(struct ether_hdr) +
                              sizeof(struct ipv4_hdr) +
                              sizeof(struct udp_hdr));
            
            // 路由：根據訊息類型分發
            uint8_t msg_type = payload[0];
            
            if (msg_type == TWSE_MSG_QUOTE) {
                parse_quote_message(payload, book);
            } else if (msg_type == TWSE_MSG_TRADE) {
                parse_trade_message(payload, book);
            }
            
            // 記錄時戳（CPU 時鐘，奈秒級精度）
            book.timestamp = rdtsc();
            
            // 檢查交易信號
            if (should_buy(book)) {
                // 執行買單邏輯
                send_buy_order(book.ask[0], 100);
            }
            
            // 釋放 mbuf
            rte_pktmbuf_free(pkt);
        }
    }
}
</code></pre>
<h3 id="4-報價是什麼"><a class="header" href="#4-報價是什麼">4. 「報價」是什麼</a></h3>
<h4 id="level-1最佳報價5-檔"><a class="header" href="#level-1最佳報價5-檔">Level 1：最佳報價（5 檔）</a></h4>
<ul>
<li><strong>內容</strong>: 最佳買/賣 5 檔及其成交量</li>
<li><strong>更新頻率</strong>: 逐筆撮合後立即推送（~1-10ms）</li>
<li><strong>來源</strong>: TWSE 官方 multicast</li>
</ul>
<h4 id="level-2完整-orderbook"><a class="header" href="#level-2完整-orderbook">Level 2：完整 Orderbook</a></h4>
<ul>
<li><strong>內容</strong>: 所有掛單快照</li>
<li><strong>台灣市場</strong>: 尚未完全開放 Level 2（不同於美國 NASDAQ）</li>
<li><strong>商業方案</strong>: 部分券商提供 Level 2 API</li>
</ul>
<h4 id="level-3逐筆成交tick-data"><a class="header" href="#level-3逐筆成交tick-data">Level 3：逐筆成交（Tick Data）</a></h4>
<ul>
<li><strong>內容</strong>: 每一筆成交的時間、價格、量</li>
<li><strong>更新頻率</strong>: 微秒到毫秒級</li>
<li><strong>來源</strong>: TWSE multicast</li>
</ul>
<h3 id="5-實戰路徑"><a class="header" href="#5-實戰路徑">5. 實戰路徑</a></h3>
<h4 id="短期1-2-個月用券商-api"><a class="header" href="#短期1-2-個月用券商-api">短期（1-2 個月）：用券商 API</a></h4>
<pre><code>1. 選擇支持低延遲 API 的券商
   - 群益、元大、永豐 等
   
2. 接入 tick data stream
   - 通常是 TCP push 或 gRPC
   
3. 自寫 C++ 解析層
   - tick → orderbook → 交易信號
</code></pre>
<h4 id="中期2-4-個月co-location--自寫解析"><a class="header" href="#中期2-4-個月co-location--自寫解析">中期（2-4 個月）：Co-Location + 自寫解析</a></h4>
<pre><code>1. 申請 TWSE co-location
   - 成本: NT$10-50k/月 + 建置費
   - 等待: 1-2 個月核准
   
2. 部署自己的伺服器在 co-location 機房
   
3. 訂閱 TWSE multicast 行情
   - IP: 224.x.x.x (TWSE 告知)
   - Port: 特定 UDP port
   
4. 用 DPDK 或 kernel bypass 收封包
   
5. 按 TWSE 電文手冊解析
</code></pre>
<h4 id="長期4-6-個月極致優化"><a class="header" href="#長期4-6-個月極致優化">長期（4-6 個月）：極致優化</a></h4>
<pre><code>1. DPDK + Solarflare NIC
   - 進一步降低延遲到 μs 級
   
2. 應用 OS 調校全套
   - CPU pin / NUMA / hugepage / isolcpus
   
3. 考慮 FPGA 加速（預算允許）
   - 在網卡端做初步解析
</code></pre>
<hr />
<h2 id="效能測試工具"><a class="header" href="#效能測試工具">效能測試工具</a></h2>
<h3 id="1-延遲測試"><a class="header" href="#1-延遲測試">1. 延遲測試</a></h3>
<h4 id="cyclictest實時延遲測試"><a class="header" href="#cyclictest實時延遲測試">cyclictest（實時延遲測試）</a></h4>
<pre><code class="language-bash">sudo apt-get install rt-tests

# 測試系統延遲抖動
sudo cyclictest -p 99 -t 1 -n -i 1000 -l 100000 -h 1000 -q
</code></pre>
<h4 id="自製延遲測試程式"><a class="header" href="#自製延遲測試程式">自製延遲測試程式</a></h4>
<pre><code class="language-cpp">#include &lt;chrono&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

void measure_latency() {
    const int iterations = 1000000;
    std::vector&lt;long&gt; latencies;
    
    for(int i = 0; i &lt; iterations; i++) {
        auto start = std::chrono::high_resolution_clock::now();
        // 你的交易邏輯
        auto end = std::chrono::high_resolution_clock::now();
        
        auto latency = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;
                      (end - start).count();
        latencies.push_back(latency);
    }
    
    std::sort(latencies.begin(), latencies.end());
    
    std::cout &lt;&lt; "P50: " &lt;&lt; latencies[iterations * 0.50] &lt;&lt; "ns\n";
    std::cout &lt;&lt; "P99: " &lt;&lt; latencies[iterations * 0.99] &lt;&lt; "ns\n";
    std::cout &lt;&lt; "P99.9: " &lt;&lt; latencies[iterations * 0.999] &lt;&lt; "ns\n";
}
</code></pre>
<h3 id="2-cpu-和中斷監控"><a class="header" href="#2-cpu-和中斷監控">2. CPU 和中斷監控</a></h3>
<h4 id="perf系統效能分析"><a class="header" href="#perf系統效能分析">perf（系統效能分析）</a></h4>
<pre><code class="language-bash">sudo apt-get install linux-tools-generic

# 監控 CPU 事件
sudo perf stat -C 8-15 ./strategy_engine

# 快取命中率
sudo perf stat -e cache-references,cache-misses ./strategy_engine

# 上下文切換
sudo perf stat -e context-switches,cpu-migrations ./strategy_engine
</code></pre>
<h4 id="監控中斷"><a class="header" href="#監控中斷">監控中斷</a></h4>
<pre><code class="language-bash"># 即時監控中斷分佈
watch -n 1 'cat /proc/interrupts | grep eth0'

# 檢查 CPU 親和性
for i in /proc/irq/*/smp_affinity; do 
    echo "$i: $(cat $i)"
done
</code></pre>
<h3 id="3-numa-和記憶體測試"><a class="header" href="#3-numa-和記憶體測試">3. NUMA 和記憶體測試</a></h3>
<h4 id="numactl-測試"><a class="header" href="#numactl-測試">numactl 測試</a></h4>
<pre><code class="language-bash"># 檢視 NUMA 拓撲
numactl --hardware

# 本地節點測試
numactl --cpunodebind=0 --membind=0 ./memory_test

# 遠端節點測試
numactl --cpunodebind=0 --membind=1 ./memory_test
</code></pre>
<h3 id="4-快取效能測試"><a class="header" href="#4-快取效能測試">4. 快取效能測試</a></h3>
<h4 id="pqos快取隔離監控"><a class="header" href="#pqos快取隔離監控">pqos（快取隔離監控）</a></h4>
<pre><code class="language-bash">sudo apt install intel-cmt-cat

# 監控 L3 快取使用
sudo pqos -m llc:1

# 測試隔離效果前後
sudo pqos -m all:1 -t 10
</code></pre>
<h3 id="5-網路延遲測試"><a class="header" href="#5-網路延遲測試">5. 網路延遲測試</a></h3>
<h4 id="sockperfsocket-效能測試"><a class="header" href="#sockperfsocket-效能測試">sockperf（Socket 效能測試）</a></h4>
<pre><code class="language-bash"># Server 端
./sockperf server -i 192.168.1.100 -p 12345

# Client 測試
./sockperf ping-pong -i 192.168.1.100 -p 12345 -t 60
</code></pre>
<h3 id="6-整合測試腳本"><a class="header" href="#6-整合測試腳本">6. 整合測試腳本</a></h3>
<pre><code class="language-bash">#!/bin/bash
# performance_test.sh

echo "=== HFT System Performance Test ==="

echo "1. System Configuration:"
echo "CPU Isolation: $(cat /proc/cmdline | grep isolcpus)"
echo "Huge Pages: $(grep HugePages_Total /proc/meminfo)"

echo -e "\n2. CPU Latency Test:"
sudo cyclictest -p 99 -t 1 -n -i 1000 -l 10000 -h 100 -q | tail -n 10

echo -e "\n3. Memory Latency:"
sudo numactl --hardware | grep "node distances"

echo -e "\n4. Cache Performance:"
sudo perf stat -e cache-references,cache-misses sleep 1 2&gt;&amp;1 | grep cache

echo -e "\n5. Network Latency:"
ping -c 100 -i 0.001 localhost | tail -n 3

echo -e "\n=== Test Complete ==="
</code></pre>
<h3 id="7-效能基準對比"><a class="header" href="#7-效能基準對比">7. 效能基準對比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>指標</th><th>優化前</th><th>優化後</th><th>測試工具</th></tr></thead><tbody>
<tr><td>CPU 延遲抖動</td><td>±50μs</td><td>±1μs</td><td>cyclictest</td></tr>
<tr><td>平均延遲</td><td>100μs</td><td>&lt;20μs</td><td>自製測試程式</td></tr>
<tr><td>快取命中率</td><td>85%</td><td>&gt;98%</td><td>perf stat</td></tr>
<tr><td>NUMA 遠端存取</td><td>+50%</td><td>0%</td><td>numactl</td></tr>
<tr><td>網路 RTT</td><td>50μs</td><td>&lt;10μs</td><td>sockperf</td></tr>
<tr><td>上下文切換</td><td>&gt;1000/s</td><td>&lt;100/s</td><td>perf stat</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="術語速查表"><a class="header" href="#術語速查表">術語速查表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>術語</th><th>全稱</th><th>白話解釋</th></tr></thead><tbody>
<tr><td>HFT</td><td>High-Frequency Trading</td><td>高頻交易</td></tr>
<tr><td>CFS</td><td>Completely Fair Scheduler</td><td>Linux 公平排程器</td></tr>
<tr><td>IRQ</td><td>Interrupt Request</td><td>中斷請求</td></tr>
<tr><td>NUMA</td><td>Non-Uniform Memory Access</td><td>非統一記憶體存取</td></tr>
<tr><td>TLB</td><td>Translation Lookaside Buffer</td><td>地址轉換緩衝</td></tr>
<tr><td>Cache Line</td><td>-</td><td>快取最小單位（通常 64 bytes）</td></tr>
<tr><td>False Sharing</td><td>-</td><td>偽共享，多線程對同一快取行競爭</td></tr>
<tr><td>Page Fault</td><td>-</td><td>缺頁中斷</td></tr>
<tr><td>Jitter</td><td>-</td><td>延遲不穩定程度</td></tr>
<tr><td>SIMD</td><td>Single Instruction Multiple Data</td><td>單指令多資料</td></tr>
<tr><td>DPDK</td><td>Data Plane Development Kit</td><td>數據平面開發套件</td></tr>
<tr><td>CAT</td><td>Cache Allocation Technology</td><td>Intel 快取分配技術</td></tr>
<tr><td>HugePages</td><td>-</td><td>大頁記憶體（2MB/1GB）</td></tr>
<tr><td>Co-Location</td><td>-</td><td>主機共置，伺服器放在交易所機房</td></tr>
<tr><td>Kernel Bypass</td><td>-</td><td>繞過核心直接處理網路</td></tr>
<tr><td>Multicast</td><td>-</td><td>多播，同時發送給多個接收方</td></tr>
<tr><td>AVX</td><td>Advanced Vector Extensions</td><td>Intel SIMD 擴充指令集</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="下一步核心旁路技術實踐"><a class="header" href="#下一步核心旁路技術實踐">下一步：核心旁路技術實踐</a></h2>
<p>儘管系統層最佳化已將延遲壓至微秒級，<strong>網路 I/O 仍是最堅固的效能壁壘</strong>。</p>
<p>傳統核心網路協議堆疊的瓶頸：</p>
<ul>
<li>協議堆疊處理耗時 &gt;10μs</li>
<li>多次資料拷貝</li>
<li>不確定的 TCP 重傳</li>
</ul>
<p><strong>解決方案</strong>：核心旁路技術（DPDK、XDP、Solarflare）</p>
<ul>
<li><strong>消除核心開銷</strong>：避免上下文切換</li>
<li><strong>零拷貝</strong>：NIC DMA 直接到用戶空間</li>
<li><strong>輪詢驅動</strong>：替代中斷，降低延遲</li>
<li><strong>線速處理</strong>：達到網卡硬體極限</li>
</ul>
<p>預期效果：端到端延遲進一步降至 <strong>&lt;1μs</strong>，實現真正的奈秒級交易系統。</p>
<hr />
<h2 id="快速參考調校檢查表"><a class="header" href="#快速參考調校檢查表">快速參考：調校檢查表</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
禁用超執行緒或分離關鍵核心</li>
<li><input disabled="" type="checkbox"/>
設定 <code>isolcpus</code> / <code>nohz_full</code> / <code>rcu_nocbs</code></li>
<li><input disabled="" type="checkbox"/>
CPU pinning：綁定策略進程到實體核</li>
<li><input disabled="" type="checkbox"/>
中斷重定向：網卡中斷指向非隔離核心</li>
<li><input disabled="" type="checkbox"/>
NUMA 綁定：核心和記憶體綁到同一節點</li>
<li><input disabled="" type="checkbox"/>
記憶體鎖定：<code>mlock</code> + <code>madvise</code></li>
<li><input disabled="" type="checkbox"/>
大頁配置：預留 hugepages，停用 THP</li>
<li><input disabled="" type="checkbox"/>
記憶體預取：初始化時觸發所有缺頁中斷</li>
<li><input disabled="" type="checkbox"/>
快取隔離：用 CAT 劃分 L3 區域</li>
<li><input disabled="" type="checkbox"/>
資料對齐：消除偽共享（64 bytes 對齐）</li>
<li><input disabled="" type="checkbox"/>
SIMD 優化：用 AVX/AVX-512 向量化計算</li>
<li><input disabled="" type="checkbox"/>
性能測試：用 cyclictest / perf / numactl 驗證</li>
</ul>
<hr />
<p><em>本文基於高頻交易系統 OS 調校最佳實踐、GitHub 開源項目調研、以及台灣市場具體實踐整理。</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hft/hft-os-tuning.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../hft/hft-github-projects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hft/hft-os-tuning.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../hft/hft-github-projects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
